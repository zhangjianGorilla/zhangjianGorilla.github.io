<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统（已完成） | 个人文档</title><meta name="author" content="Zhang Jian"><meta name="copyright" content="Zhang Jian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="第一章1.1.1 概念、功能和目标概念 操作系统是控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。 操作系统的功能和目标  进程是一个程序的执行过程。执行前需要将该程序放到内存中，才能被CPU处理。   作为系统资源的管理者  处理机管理：为程序分配CPU资源 存储器管理：需要把程序相关数">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统（已完成）">
<meta property="og:url" content="http://example.com/2022/07/31/operatingSystem/index.html">
<meta property="og:site_name" content="个人文档">
<meta property="og:description" content="第一章1.1.1 概念、功能和目标概念 操作系统是控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。 操作系统的功能和目标  进程是一个程序的执行过程。执行前需要将该程序放到内存中，才能被CPU处理。   作为系统资源的管理者  处理机管理：为程序分配CPU资源 存储器管理：需要把程序相关数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2022-07-31T07:44:00.000Z">
<meta property="article:modified_time" content="2022-12-14T01:50:58.626Z">
<meta property="article:author" content="Zhang Jian">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/07/31/operatingSystem/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统（已完成）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-14 09:50:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/xxx.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">个人文档</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">操作系统（已完成）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-31T07:44:00.000Z" title="发表于 2022-07-31 15:44:00">2022-07-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-14T01:50:58.626Z" title="更新于 2022-12-14 09:50:58">2022-12-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">63.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>191分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统（已完成）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-1-1-概念、功能和目标"><a href="#1-1-1-概念、功能和目标" class="headerlink" title="1.1.1 概念、功能和目标"></a>1.1.1 概念、功能和目标</h3><p><strong>概念</strong></p>
<p>操作系统是控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。</p>
<p><strong>操作系统的功能和目标</strong></p>
<blockquote>
<p>进程是一个程序的执行过程。执行前需要将该程序放到内存中，才能被CPU处理。</p>
</blockquote>
<ul>
<li><p>作为系统资源的管理者</p>
<ul>
<li>处理机管理：为程序分配CPU资源</li>
<li>存储器管理：需要把程序相关数据放入内存中的某个位置</li>
<li>文件管理：对应用程序的相关文件进行分层级的管理</li>
<li>设备管理：将程序需要的硬件设备划分配给进程或者回收。</li>
<li>目标：安全、高效</li>
</ul>
</li>
<li><p>作为用户和计算机硬件之间的接口</p>
<ul>
<li>提供命令接口：联机命令接口（用户说一句，系统做一句）、脱机命令接口（用户说一堆，系统做一堆）</li>
<li>提供程序接口（允许用户通过程序间接使用）：由一组系统调用组成（程序接口&#x3D;系统调用）</li>
<li>提供GUI（图形用户界面）</li>
<li>目标：方便用户使用</li>
</ul>
</li>
<li><p>作为最接近硬件的层次</p>
<ul>
<li>实现对硬件机器的拓展</li>
</ul>
</li>
</ul>
<p>没有任何软件支持的计算机称为裸机。在裸机上安装的操作系统，可以提供资源管理和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。通常把覆盖了软件的机器称为扩充机器，又称为虚拟机。</p>
<h3 id="1-1-2-操作系统的特征"><a href="#1-1-2-操作系统的特征" class="headerlink" title="1.1.2 操作系统的特征"></a>1.1.2 操作系统的特征</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。</p>
<p>并行：指两个或多个事件在同一时刻发生。</p>
<p>操作系统的并发性指计算机系统中同时存在着多个运行着的程序。</p>
<h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>共享即资源共享，是指系统中的资源可提供内存中多个并发执行的进程共同使用。</p>
<p>资源共享方式</p>
<ul>
<li><p>互斥共享方式</p>
<p>  系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源</p>
</li>
<li><p>同时共享方式</p>
<p>  系统中的某些资源，允许一个时间段内有多个进程“同时”对他们进行访问</p>
<p>  所谓的”同时“往往是宏观上的，而在微观上，这些进程可能是交替地对资源进行访问的（即分时复用）</p>
</li>
</ul>
<p><strong>并发性和共享性互为存在条件</strong>。如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义。如果失去共享性，则两个或多个程序不能同时访问硬盘资源，就无法实现比如同时发送文件，也就无法并发。</p>
<h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p>
<blockquote>
<p>一个程序需要放入内存并给它分配CPU才能执行。虚拟技术中的“时分复用技术”，微观上处理机在各个微小的时间段内交替着为各个进程服务。</p>
</blockquote>
<p>虚拟技术可分为空分复用技术（如虚拟存储区技术）和时分复用技术（如虚拟处理器）。如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<strong>没有并发性，就谈不上虚拟性</strong>。 </p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>异步是指在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>
<p>如果失去了并发性，则系统只能串行地处理各个进程，每个进程的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。</p>
<h3 id="1-1-3-操作系统的发展和分类"><a href="#1-1-3-操作系统的发展和分类" class="headerlink" title="1.1.3 操作系统的发展和分类"></a>1.1.3 操作系统的发展和分类</h3><h4 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h4><p>手工操作阶段人们将程序写到纸带上，通过在纸带上打孔来区分0&#x2F;1。计算机通过读取纸带上的程序来执行，执行完后再将程序结果打印在纸带上。计算机读取和打印结果的过程很慢（输入&#x2F;输出慢），但是执行程序的时间很快（处理速度快）。</p>
<p>主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低。</p>
<h4 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h4><ul>
<li><p>单道批处理系统</p>
<p>  引入脱机输入&#x2F;输出技术（用磁带完成），并<strong>监督程序</strong>（操作系统的雏形）负责控制作业的输入、输出。</p>
<p>  程序员先将自己在纸带上的程序通过外围机读到磁带上面，计算机读取磁带里的程序进行执行，并将执行结果输出到磁带中，程序员再通过外围机将程序输出带纸带上。</p>
</li>
</ul>
<p>优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。</p>
<p>缺点：内存中仅能有一道程序运行，只有该程序运行结束后才能调入下一道程序。<strong>CPU仍有大量的时间是在空闲等待I&#x2F;O完成</strong>。资源利用率依然很低。</p>
<ul>
<li><p>多道批处理系统</p>
<p>   在单道批处理系统的基础上，每次网内存中输入多道程序，操作系统正式诞生，并引入了中断技术，有操作系统负责管理这些程序的运行。各个程序并发执行。</p>
</li>
</ul>
<p>优点：多道程序并发执行，贡献计算机资源。资源利用率大幅提升，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。</p>
<p>缺点：用户响应时间长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行）</p>
<h4 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h4><p>计算机以时间片为单位轮流为各个用户&#x2F;作业服务，各个用户可通过终端与计算机进行交互。</p>
<p>优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p>
<p>缺点：不能优先处理一些紧急任务。操作系统对各个用户&#x2F;作业都是完全公平的，循环地为每个用户&#x2F;作业一个时间片，不区分任务的紧急性。</p>
<h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><p>优点：能够优先响应一些紧急任务，某些紧急任务不需要时间片排队。</p>
<p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。</p>
<ul>
<li>硬实时系统：必须在绝对严格的规定时间内完成处理（如：导弹控制系统、自动驾驶系统）</li>
<li>软实时系统：能接受偶尔违反时间规定（如：12306火车订票系统）</li>
</ul>
<h4 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h4><p>是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows NT就是一种典型的网络操作系统，网站服务器就可以使用）</p>
<h4 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h4><p>主要特点是分布性和并发性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由他们并行、协同完成这个任务。</p>
<h4 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h4><p>如Windows XP、MacOS，方便个人使用。</p>
<h3 id="1-1-4-操作系统的运行机制与体系结构"><a href="#1-1-4-操作系统的运行机制与体系结构" class="headerlink" title="1.1.4 操作系统的运行机制与体系结构"></a>1.1.4 操作系统的运行机制与体系结构</h3><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><blockquote>
<p>问题：“指令”和我们平时所说的“代码”有什么区别？</p>
</blockquote>
<p>一段C语言代码通过编译，形成机器语言指令。<strong>一条高级语言的代码编译过后可能会对应多条指令。</strong></p>
<p>简单来说，“指令”就是处理器CPU能识别、执行的最基本命令</p>
<p>比如：加法指令就是让CPU进行加法运算</p>
<blockquote>
<p>新的问题：有的指令“人畜无害”。比如：加、减、乘、除这些普通的运算指令。有的指令有很高的权限。比如内存清零指令。比如用户程序可以使用这个指令，就意味着一个用户可以将其他用户的内存数据随意清零，这样做显然是很危险的。</p>
</blockquote>
<p>指令可以分为：</p>
<ul>
<li>特权指令：如内存清零指令（不允许用户程序使用）</li>
<li>非特权指令：如普通的运算指令</li>
</ul>
<blockquote>
<p>问题：CPU如何判断当前是否可以执行特权指令？</p>
</blockquote>
<p>两种处理器状态（用程序状态字寄存器PSW中的某标志位来标识当前处理器处于什么状态。如0为用户态，1为核心态）</p>
<ul>
<li>用户态（目态），此时CPU只能执行非特权指令</li>
<li>核心态（管态），特权指令、非特权指令都可以执行</li>
</ul>
<p>两种程序</p>
<ul>
<li><p>内核程序</p>
<p>  操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。</p>
</li>
<li><p>应用程序</p>
<p>  为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态。</p>
</li>
</ul>
<blockquote>
<p>操作系统中的那些功能应该由内核程序实现呢？</p>
</blockquote>
<h4 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h4><p>计算机系统的层次结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="计算机系统的层次结构"></p>
<p>时钟管理：实现计时功能</p>
<p>中断处理：负责实现中断机制</p>
<p>原语：</p>
<ul>
<li>一种特殊的程序。</li>
<li>是最接近硬件的部分。</li>
<li>这种程序的运行具有原子性——运行只能一气呵成，不可中断。</li>
<li>运行时间较短、调用频繁。</li>
</ul>
<p>内核是计算机配置的底层软件，是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是内核程序。</p>
<p>对系统资源进行管理的功能：</p>
<ul>
<li>进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ul>
<p>ps：有的系统不把这部分归为“内核功能”。也就是说，不同的操作系统，对内核功能的划分可能并不一样。</p>
<h4 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h4><p>操作系统的体系结构可分为：</p>
<ul>
<li><p>大内核</p>
<p>  将操作系统的主要功能模块都作为系统内核，运行在核心态</p>
<p>  优点：高性能</p>
<p>  缺点：内核代码庞大，结构混乱，难以维护</p>
</li>
<li><p>微内核</p>
<p>  只把最基本的功能保留在内核</p>
<p>  优点：内核功能少，结构清晰，方便维护</p>
<p>  缺点：需要频繁地在核心态和用户态之间切换，性能低</p>
</li>
</ul>
<p>类比：</p>
<p>操作系统的体系结构问题与企业的管理问题很相似。</p>
<p>内核就是企业的管理层，负责一些重要的工作。只有管理层才能执行特权指令，普通员工只能执行非特权指令。用户态、核心态之间的切换相当于普通员工和管理层之间的工作交接。</p>
<p>大内核：企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高；缺点是组织结构混乱，难以维护。</p>
<p>微内核：随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护；缺点是效率低。</p>
<h3 id="1-1-5-中断和异常"><a href="#1-1-5-中断和异常" class="headerlink" title="1.1.5 中断和异常"></a>1.1.5 中断和异常</h3><h4 id="中断机制的诞生"><a href="#中断机制的诞生" class="headerlink" title="中断机制的诞生"></a><strong>中断机制的诞生</strong></h4><p>为了解决各程序在早起的计算机中只能串行执行，系统资源利用率低的问题，人们发明了操作系统（作为计算机的管理者），引入中断机制，实现了多道程序并发执行。</p>
<p>本质：发生中断就意味着需要操作系统介入，开展管理工作。</p>
<h4 id="中断的概念和作用"><a href="#中断的概念和作用" class="headerlink" title="中断的概念和作用"></a><strong>中断的概念和作用</strong></h4><ol>
<li>当中断发生时，CPU立即进入核心态</li>
<li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理。</li>
<li>对于不同的中断信号，会进行不同的处理</li>
</ol>
<p>发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作（比如进程切换、分配I&#x2F;O设备等）需要使用特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行。</p>
<blockquote>
<p>问题：用户态、核心态之间的切换是怎么实现的？</p>
</blockquote>
<p>用户态 -&gt; 核心态是通过中断实现的。并且中断是唯一途径。</p>
<h4 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a><strong>中断的分类</strong></h4><p>中断可分为：</p>
<ul>
<li><p>内中断</p>
<p>  也称异常、例外、陷入。信号来源于CPU内部与当前执行的指令有关</p>
<ul>
<li><p>自愿中断——指令中断</p>
<p>  如系统调用时使用的访管指令（又叫陷入指令、trap指令）</p>
</li>
<li><p>强迫中断</p>
<ul>
<li>硬件故障（如缺页）</li>
<li>软件中断（如整数除0）</li>
</ul>
</li>
</ul>
</li>
<li><p>外中断</p>
<p>  信号来源于CPU外部。与当前执行的指令无关</p>
<ul>
<li>外设请求（如I&#x2F;O操作完成发出的中断信号）</li>
<li>人工干预（如用户强行终止一个进程）</li>
</ul>
</li>
</ul>
<p>另一种分类方式：</p>
<ul>
<li>内中断（内部异常）<ul>
<li>陷阱、陷入trap（有意而为之的异常，如系统调用）</li>
<li>故障fault（由错误条件引起的，可能被故障处理程序修复，如缺页）</li>
<li>终止abort（不可恢复的致命错误造成的结果，终止处理程序不再将控制返回给引发终止的应用程序，如整数除0）</li>
</ul>
</li>
<li>外中断<ul>
<li>I&#x2F;O中断请求</li>
<li>人工干预</li>
</ul>
</li>
</ul>
<h4 id="外中断的处理过程"><a href="#外中断的处理过程" class="headerlink" title="外中断的处理过程"></a><strong>外中断的处理过程</strong></h4><ol>
<li>执行完每个指令之后，CPU都要检查当前是否有外部中断信号</li>
<li>如果监测到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW、程序计数器PC、各种通用寄存器）</li>
<li>根据中断信号类型转入相应的中断处理程序</li>
<li>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</li>
</ol>
<h3 id="1-1-6-系统调用"><a href="#1-1-6-系统调用" class="headerlink" title="1.1.6 系统调用"></a>1.1.6 系统调用</h3><h4 id="什么是系统调用，有何作用？"><a href="#什么是系统调用，有何作用？" class="headerlink" title="什么是系统调用，有何作用？"></a><strong>什么是系统调用，有何作用？</strong></h4><p>系统调用是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为 一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获取操作系统的服务。</p>
<p>应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡事与资源有关的操作（如存储分配、I&#x2F;O操作、文件管理），都必须通过系统调用的方式来操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p>
<p>系统调用按功能可以分为：</p>
<ul>
<li>设备管理：完成设备的请求&#x2F;释放&#x2F;启动等功能</li>
<li>文件管理：完成文件的读&#x2F;写&#x2F;创建&#x2F;删除等功能</li>
<li>进程控制：完成进程的创建&#x2F;撤销&#x2F;阻塞&#x2F;唤醒等功能</li>
<li>进程通信：完成进程之间的消息传递&#x2F;信号传递等功能</li>
<li>内存管理：完成内存的分配&#x2F;回收等功能</li>
</ul>
<blockquote>
<p>系统调用相关处理涉及到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此系统调用的相关处理需要在核心态下进行。</p>
</blockquote>
<h4 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a><strong>系统调用和库函数的区别</strong></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8E%E5%BA%93%E5%87%BD%E6%95%B0.png" alt="系统调用与库函数"></p>
<table>
<thead>
<tr>
<th align="left">普通应用程序</th>
<th>可直接进行系统调用，也可以使用库函数。有的库函数设计系统调用，有的不涉及</th>
</tr>
</thead>
<tbody><tr>
<td align="left">编程语言</td>
<td>向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使上层进行系统调用更加方便。</td>
</tr>
<tr>
<td align="left">操作系统</td>
<td>向上提供系统调用</td>
</tr>
<tr>
<td align="left">裸机</td>
<td></td>
</tr>
</tbody></table>
<p>区别：</p>
<ul>
<li>系统调用是操作系统向上层提供的接口</li>
<li>有的库函数是对系统调用的进一步封装</li>
<li>当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用</li>
</ul>
<h4 id="系统调用背后的过程"><a href="#系统调用背后的过程" class="headerlink" title="系统调用背后的过程"></a><strong>系统调用背后的过程</strong></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="系统调用过程"></p>
<p>传递系统调用参数 -&gt; 执行陷入指令(用户态) -&gt; 执行系统调用相应服务程序(核心态) -&gt; 返回用户程序</p>
<p>注意：</p>
<ol>
<li>陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，从而CPU进入核心态。</li>
<li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</li>
<li>陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令</li>
</ol>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="2-1-1-进程的定义、组成、组织方式、特征"><a href="#2-1-1-进程的定义、组成、组织方式、特征" class="headerlink" title="2.1.1 进程的定义、组成、组织方式、特征"></a>2.1.1 进程的定义、组成、组织方式、特征</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>从不同的角度，进程可以有不同的定义，比较传统典型的定义有：</p>
<ol>
<li>进程是程序的一次执行过程。</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li>
<li>进程是具有独立功能的程序在数据集合上运行的过程，它是系统进程资源分配和调度的一个独立单位。</li>
</ol>
<p>不管从什么角度，它们都在强调进程是“动态性”的。</p>
<p>引入进程实体的概念后，可以把进程定义为：</p>
<p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p><strong>程序：</strong>一个指令序列。</p>
<p>引入多道程序技术后，为了方便操作系统管理，完成各程序并发执行，引入了进程、进程实体的概念。</p>
<p>PCB、程序段、数据段三部分构成了进程实体 （进程映像）。</p>
<blockquote>
<p>PCB：系统为每个运行的程序配置一个数据结构，称为进程控制块(PCB)，用来描述进程的各种信息(如程序代码存放位置)</p>
<p>程序段：存放要执行的程序代码</p>
<p>数据段：存放程序运行过程中处理的各种数据，如全局变量、局部变量等。</p>
</blockquote>
<p>程序段、数据段、PCB三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体就简称为进程，例如：所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。</p>
<p><strong>PCB是进程存在的唯一标志！</strong></p>
<p>PCB中存放的信息：</p>
<ul>
<li><p>进程描述信息</p>
<ul>
<li>进程标识符PID：进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，用于区分不同的进程。</li>
<li>用户标识符UID</li>
</ul>
</li>
<li><p>进程控制和管理信息</p>
<ul>
<li>进程当前状态</li>
<li>进程优先级</li>
</ul>
</li>
<li><p>资源分配清单</p>
<ul>
<li>程序段指针</li>
<li>数据段指针</li>
<li>键盘</li>
<li>鼠标</li>
</ul>
</li>
<li><p>处理机相关信息</p>
<ul>
<li><p>各种寄存器值</p>
<p>  当进程切换时，需要把进程当前的运行情况记录下来保存在PCB中，如程序计数器的值表示了当前程序执行到那一句</p>
</li>
</ul>
</li>
</ul>
<h4 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h4><p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。</p>
<p>ps：进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题。</p>
<p>进程的组织方式包括：</p>
<ul>
<li><p>链接方式</p>
<p>  链接方式按照进程状态将PCB分为多个队列，操作系统有志向各个队列的指针</p>
</li>
<li><p>索引方式</p>
<p>  索引方式根据进程状态的不同，建立几张索引表，各表项指向一个PCB，操作系统持有指向各个索引表的指针</p>
</li>
</ul>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li><p>动态性</p>
<p>  进程是程序的一次执行过程，是动态地产生、变化和消亡的</p>
</li>
<li><p>并发性</p>
<p>  内存中有多个进程实体，各进程可并发执行</p>
</li>
<li><p>独立性</p>
<p>  进程是能独立运行、独立获得资源、独立接受调度的基本单位</p>
</li>
<li><p>异步性</p>
<p>  各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题</p>
</li>
<li><p>结构性</p>
<p>  每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</p>
</li>
</ul>
<blockquote>
<p>动态性是进程最基本的特征。进程是资源分配、接受调度的基本单位。异步性会导致并发程序执行结果的不确定性。</p>
</blockquote>
<h3 id="2-1-2-进程的状态与转换"><a href="#2-1-2-进程的状态与转换" class="headerlink" title="2.1.2 进程的状态与转换"></a>2.1.2 进程的状态与转换</h3><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化的。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。</p>
<p>进程的三种基本状态：</p>
<ul>
<li><p>就绪态（Ready）</p>
<p>  此时进程已经具备运行条件（除处理机之外所有需要的资源），但由于没有空闲的CPU，而暂时不能运行。一旦获得处理机，即可立即进入运行态开始运行。</p>
</li>
<li><p>运行态（Running）</p>
<p>  此时进程占有CPU，并在CPU上运行。单核处理机环境下，每一个时刻最多只有一个进程处于运行态。双核环境下可以同时有两个进程处于运行态。</p>
</li>
<li><p>阻塞态（Waiting&#x2F;Blocked，又称：等待态）</p>
<p>  因等待某一事件而暂时不能运行。如等待操作系统分配打印机、等待磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务。</p>
</li>
</ul>
<p>一个进程的诞生和消亡过程并不是一瞬间完成的，也有一个创建和消亡的过程，所以进程还有两种状态：</p>
<ul>
<li><p>创建态（New，又称：新建态）</p>
<p>  一个程序需要在计算机中运行，操作系统需要完成创建进程。操作系统为该进程分配所需要的内存空间等系统资源，并为其创建、初始化PCB（如为进程分配PID）</p>
</li>
<li><p>终止态（Terminated，又称：结束态）</p>
<p>  进程运行结束（或者由于bug导致进程无法继续执行下去，比如数组越界错误，整数除零），需要撤销进程。操作系统需要完成撤销进程的相关工作。完成将分配给进程的资源回收，撤销进程PCB等工作。</p>
</li>
</ul>
<h4 id="进程状态的转换"><a href="#进程状态的转换" class="headerlink" title="进程状态的转换"></a>进程状态的转换</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="进程状态的转换"></p>
<p>进程从运行态 -&gt; 阻塞态是一种进程自身作出的主动行为</p>
<p>进程从阻塞态 -&gt; 就绪态不是进程自身能控制的，是一种被动行为</p>
<p>ps: 不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态，因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求。</p>
<ul>
<li><p>就绪态 -&gt; 运行态</p>
<p>  进程被调度</p>
</li>
<li><p>运行态 -&gt; 就绪态</p>
<p>  时间片到，或CPU被其他高优先级的进程抢占</p>
</li>
<li><p>运行态 -&gt; 阻塞态</p>
<p>  等待系统资源分配，或等待某事件发生（主动行为）</p>
</li>
<li><p>阻塞态 -&gt; 就绪态</p>
<p>  资源分配到尾，等待的事件发生（被动行为）</p>
</li>
<li><p>创建态 -&gt; 就绪态</p>
<p>  系统完成创建进程相关的工作</p>
</li>
<li><p>运行态 -&gt; 终止态</p>
<p>  进程运行结束，或运行过程中遇到不可修复的错误</p>
</li>
</ul>
<h3 id="2-1-3-进程控制"><a href="#2-1-3-进程控制" class="headerlink" title="2.1.3 进程控制"></a>2.1.3 进程控制</h3><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p>
<p>简化理解：反正进程控制就是要实现进程状态转换。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6.png" alt="进程控制"></p>
<p>创建进程：需要初始化PCB、分配系统资源。</p>
<p>创建态 -&gt; 就绪态：需要修改PCB内容和相应队列</p>
<p>就绪态 -&gt; 运行态：需要回复进程运行环境、修改PCB内容和相应队列</p>
<p>运行态 -&gt; 就绪态：需要保存进程运行环境、修改PCB内容和相应队列</p>
<p>运行态 -&gt; 阻塞态：需要保存进程运行环境、修改PCB内容和相应队列</p>
<p>阻塞态 -&gt; 就绪态：需要修改PCB内容和相应队列。如果等待的是资源，则还需为进程分配系统资源</p>
<p>运行态 -&gt; 终止态：需回收进程拥有的资源，撤销PCB</p>
<p>进程状态的切换，中间所做的事情是比较复杂的，需要修改PCB的内容和将PCB放入相应的队列。加入一个进程的PCB从一个队列放入另一个队列中，但是并没有修改PCB中状态标志成新的状态。这种情况会导致系统错误，为了解决这个问题，引入了原语。</p>
<h4 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h4><p>用原语实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。</p>
<p>这种不可被中断的操作称为原子操作。</p>
<p>原语采用“关中断指令”和“开中断指令”实现。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E5%8E%9F%E8%AF%AD.png" alt="原语"></p>
<p>关&#x2F;开中断指令的权限非常大，必然是只允许在核心态下执行的特权命令。</p>
<p>进程控制会导致进程状态的转换。无论哪个原语，要做的无非是三类事情：</p>
<ol>
<li><p>更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）</p>
<p> a. 所有的进程控制原语一定都会修改进程状态标志</p>
<p> b. 剥夺当前运行进程的CPU使用权，必然需要保存其运行环境</p>
<p> c. 某进程开始运行前必然要恢复其运行环境</p>
</li>
<li><p>将PCB插入合适的队列</p>
</li>
<li><p>分配&#x2F;回收资源</p>
</li>
</ol>
<h4 id="进程控制相关的原语"><a href="#进程控制相关的原语" class="headerlink" title="进程控制相关的原语"></a>进程控制相关的原语</h4><ol>
<li>进程的创建：</li>
</ol>
<p>创建原语（无 -&gt; 创建态 -&gt; 就绪态）</p>
<ul>
<li>申请空白PCB</li>
<li>为新进程分配所需资源</li>
<li>初始化PCB</li>
<li>将PCB插入就绪队列</li>
</ul>
<p>引起进程创建的事件</p>
<ul>
<li>用户登录：分时系统中，用户登录成功，系统会建立为其建立一个新的进程</li>
<li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li>
<li>提供服务：用户向操作系统提出某些请求时，会建立一个进程处理该请求</li>
<li>应用请求：由用户进程主动请求创建一个子进程</li>
</ul>
<ol start="2">
<li>进程的终止：</li>
</ol>
<p>撤销原语（就绪态&#x2F;阻塞态&#x2F;运行态 -&gt; 终止态 -&gt; 无）</p>
<ul>
<li>从PCB集合中找到终止进程的PCB</li>
<li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li>
<li>终止其所有子进程</li>
<li>将该进程拥有的所有资源归还给父进程或操作系统</li>
<li>删除PCB</li>
</ul>
<p>引起进程终止的事件：</p>
<ul>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ul>
<ol start="3">
<li>进程的阻塞和唤醒（阻塞和唤醒要成对出现）</li>
</ol>
<p>阻塞原语（运行态 -&gt; 阻塞态）</p>
<ul>
<li>找到要阻塞的进程对应的PCB</li>
<li>保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li>
<li>将PCB插入相应事件的等待队列</li>
</ul>
<p>引起进程阻塞的事件：</p>
<ul>
<li>需要等待系统分配某种资源</li>
<li>需要等待相互合作的其他进程完成工作</li>
</ul>
<p>唤醒原语（阻塞态 -&gt; 就绪态）</p>
<ul>
<li>在事件等待队列中找到PCB</li>
<li>将PCB从等待队列移除，设置进程为就绪态</li>
<li>将PCB插入就绪队列，等待被调度</li>
</ul>
<p>引起进程唤醒的事件：</p>
<ul>
<li>等待的事件发生</li>
</ul>
<ol start="4">
<li>进程的切换</li>
</ol>
<p>切换原语（运行态 -&gt; 阻塞态&#x2F;就绪态；就绪态 -&gt; 运行态）：</p>
<ul>
<li><p>将运行环境信息存入PCB</p>
</li>
<li><p>PCB移入相应队列</p>
</li>
<li><p>选择另一个进程执行，并更新其PCB</p>
</li>
<li><p>根据PCB恢复新进程所需的运行环境</p>
</li>
</ul>
<p>引起进程切换的事件：</p>
<ul>
<li>当前进程时间片到</li>
<li>有更高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
<h3 id="2-1-4-进程通信"><a href="#2-1-4-进程通信" class="headerlink" title="2.1.4 进程通信"></a>2.1.4 进程通信</h3><blockquote>
<p>什么是进程通信？</p>
</blockquote>
<p>顾名思义，进程通信指进程之间的信息交换。</p>
<p>进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程</strong>拥有的<strong>内存地址空间相互独立</strong>。</p>
<p>为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p>
<p>实现进程间的安全通信的方法有<strong>共享存储</strong>、<strong>消息传递</strong>、<strong>管道通信</strong>。</p>
<h4 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h4><p>共享存储要求两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）。</p>
<p>操作系统只负责提供共享空间和同步互斥工具（如P、V操作）。</p>
<p>共享存储可分为基于数据结构的共享和基于存储区的贡献。</p>
<p><strong>基于数据结构</strong>的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。</p>
<p><strong>基于存储区</strong>的共享：在内存中画出一块共享存储区，数据的形式、 存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。</p>
<h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><blockquote>
<p>“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。</p>
</blockquote>
<ol>
<li>管道只能采用半双工通信，某一时间段内只能实现单项的传输。如果要实现双向同时通信，则需要设置两个管道。</li>
<li>各进程要互斥地访问管道。</li>
<li>数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。</li>
<li>如果没写满，就不允许读。如果没读空，就不允许写。</li>
<li>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。</li>
</ol>
<h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p>进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息&#x2F;接收消息”两个原语进行数据交换。</p>
<p>格式化的消息包括消息头、消息体。</p>
<p>消息头包括发送进程ID、接收进程ID、消息类型、消息长度等格式化的信息（计算机网络中发送的“报文”其实就是一种格式化的消息）</p>
<p>消息传递的两种方式：</p>
<ol>
<li><p>直接通信方式</p>
<p> 消息直接挂到接收进程的消息缓冲队列上</p>
</li>
<li><p>间接通信方式</p>
<p> 消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。eg：计算机网络中的电子邮件系统。</p>
</li>
</ol>
<h3 id="2-1-5-线程概念和多线程模型"><a href="#2-1-5-线程概念和多线程模型" class="headerlink" title="2.1.5 线程概念和多线程模型"></a>2.1.5 线程概念和多线程模型</h3><h4 id="什么是线程，为什么要引入线程？"><a href="#什么是线程，为什么要引入线程？" class="headerlink" title="什么是线程，为什么要引入线程？"></a>什么是线程，为什么要引入线程？</h4><p>可以把线程理解为“轻量级进程“。</p>
<p>线程是一个<strong>基本的CPU执行单元</strong>，也是<strong>程序执行流的最小单位</strong>。</p>
<p>引入线程后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步<strong>提升了系统的并发度</strong>，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）</p>
<p>引入线程之后，进程制作为<strong>除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间都是分配给进程的）。</p>
<h4 id="引入线程机制后，有什么变化？"><a href="#引入线程机制后，有什么变化？" class="headerlink" title="引入线程机制后，有什么变化？"></a>引入线程机制后，有什么变化？</h4><p>从资源分配、调度来看：</p>
<ul>
<li>传统进程机制中，进程是资源分配、调度的基本单位</li>
<li>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</li>
</ul>
<p>从并发性来看：</p>
<ul>
<li>传统进程机制中，只能进程间并发</li>
<li>引入线程后，各线程间也能并发，提升了并发度</li>
</ul>
<p>从系统开销来看：</p>
<ul>
<li>传统的进程间并发，需要切换进程的运行环境，系统开销很大</li>
<li>线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小</li>
<li>引入线程后，并发所带来的系统开销减小</li>
</ul>
<h4 id="线程有哪些重要的属性"><a href="#线程有哪些重要的属性" class="headerlink" title="线程有哪些重要的属性"></a>线程有哪些重要的属性</h4><ul>
<li>线程是处理机调度的单位，进程是资源分配的单位</li>
<li>同一进程的各线程共享拥有的资源</li>
<li>同一进程内的线程切换不会导致进程切换</li>
<li>多CPU计算机中，各线程可占用不同的CPU</li>
<li>每个线程都有一个线程ID、线程控制块（TCB）</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>不同进程中的线程切换，会引起进程切换</li>
<li>切换同进程内的线程，系统开销很小</li>
<li>切换进程，系统开销很大</li>
</ul>
<h4 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h4><p><strong>用户级线程(User-Level Thread, ULT)</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B.png" alt="用户级线程"></p>
<p>用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换）</p>
<p>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</p>
<p>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明）</p>
<p>可以理解为，“用户级线程”就是“从用户视角看能看到的线程”。</p>
<p><strong>内核级线程(Kernel-Level Thread, KLT, 又称“内核支持的线程”</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B.png" alt="内核级线程"></p>
<p>内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。可以理解为，“内核级线程”就是“从操作系统内核视角看能看到的线程”。</p>
<p>在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m个内核级线程上（n&gt;m）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%90%88.png" alt="用户级线程和内核级线程组合"></p>
<p><strong>重点</strong>：</p>
<p>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</p>
<p>例如上面的模型中，该进程有两个内核级线程，三个用户级线程，在用户看来，这个进程中有三个线程。但即使该进程在一个四核处理机的计算机上运行，也最多只能被分配到两个核，最多只能有两个用户线程并行执行。</p>
<h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p>在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”为题。</p>
<p><strong>多对一模型</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/OperationSystem/%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B.png" alt="多对一模型"></p>
<p>多个用户级线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</p>
<p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p>
<p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p>
<p><strong>一对一模型</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B.png" alt="一对一模型"></p>
<p>一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p>
<p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p>
<p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p>
<p><strong>多对多模型</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B.png" alt="多对多模型"></p>
<p>n用户级线程映射到m内核级线程（n≥m）。每个用户级进程对应m个内核级线程。</p>
<p>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>
<h3 id="2-2-1-处理机调度的概念、层次"><a href="#2-2-1-处理机调度的概念、层次" class="headerlink" title="2.2.1 处理机调度的概念、层次"></a>2.2.1 处理机调度的概念、层次</h3><h4 id="调度的基本概念"><a href="#调度的基本概念" class="headerlink" title="调度的基本概念"></a>调度的基本概念</h4><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。</p>
<p>在多道程序系统中，进程的数量往往是多余处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</p>
<h4 id="调度的三个层次"><a href="#调度的三个层次" class="headerlink" title="调度的三个层次"></a>调度的三个层次</h4><p>::: tip<br>外存：指计算机随机存储器(RAM)和CPU缓存之外的存储器，例如，计算机硬盘、软盘、光盘、U盘等。<br>:::</p>
<p><strong>1. 高级调度</strong></p>
<p>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</p>
<p>高级调度(作业调度)。按一定的原则从外存上处于后备队列的作业中挑选一个(或多个)作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB)，以使它(们)获得竞争处理机的权利。</p>
<p>高级调度是辅存(外存)与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p>
<p><strong>2. 中级调度</strong></p>
<p>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。</p>
<p>这么做的目的是为了提高内存利用率和系统吞吐量。</p>
<p>暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到挂起队列中。</p>
<p>中级调度(内存调度)，就是要决定将哪个处于挂起状态的进程重新调入内存。</p>
<p>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</p>
<p><strong>3. 低级调度</strong></p>
<p>低级调度(进程调度)，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</p>
<p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</p>
<p>进程调度的频率很高，一般几十毫秒一次。</p>
<p><strong>补充：进程的挂起态与七状态模型</strong></p>
<p>暂时调到外存等待的进程状态为挂起状态(挂起态，suspend)</p>
<p>挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</p>
<p>五状态模型 -&gt; 七状态模型</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt="七状态模型"></p>
<p>注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但是挂起状态是将进程映像调到外存中去了，而阻塞态下的进程映像还在内存中。有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p>
<p><strong>三种调度的联系、对比</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">要做什么</th>
<th align="center">调度发生在</th>
<th align="center">发生频率</th>
<th align="center">对进程状态的影响</th>
</tr>
</thead>
<tbody><tr>
<td align="center">高级调度<br />(作业调度)</td>
<td align="center">按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td>
<td align="center">外存 -&gt; 内存<br />(面向作业)</td>
<td align="center">最低</td>
<td align="center">无 -&gt; 创建态 -&gt; 就绪态</td>
</tr>
<tr>
<td align="center">中级调度<br />(内存调度)</td>
<td align="center">按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td>
<td align="center">外存 -&gt; 内存<br />(面向进程)</td>
<td align="center">中等</td>
<td align="center">挂起态 -&gt; 就绪态<br />(阻塞挂起 -&gt; 阻塞态)</td>
</tr>
<tr>
<td align="center">低级调度<br />(进程调度)</td>
<td align="center">按照某种规则，从就绪队列中选择一个进程为其分配处理机</td>
<td align="center">内存 -&gt; CPU</td>
<td align="center">最高</td>
<td align="center">就绪态 -&gt; 运行态</td>
</tr>
</tbody></table>
<h3 id="2-2-2-进程调度的时机、切换与过程、方式"><a href="#2-2-2-进程调度的时机、切换与过程、方式" class="headerlink" title="2.2.2 进程调度的时机、切换与过程、方式"></a>2.2.2 进程调度的时机、切换与过程、方式</h3><h4 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a><strong>进程调度的时机</strong></h4><p>进程调度(低级调度)就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p>
<p>需要进行进程调度与切换的情况：</p>
<ul>
<li>当前运行的进程主动放弃处理机<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常而终止</li>
<li>进程主动请求阻塞(如等待I&#x2F;O)</li>
</ul>
</li>
<li>当前运行的进程被动放弃处理机<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急的事需要处理(如I&#x2F;O中断)</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
</ul>
<p>不能进行进程调度与切换的情况：</p>
<ul>
<li>在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进程切换。</li>
<li>进程在操作系统内核程序临界区中。</li>
<li>在原子操作过程中(原语)。原子操作不可中断，要一气呵成(如修改PCB中进程状态标志，并把PCB放到相应队列)</li>
</ul>
<blockquote>
<p>进程在操作系统内核程序临界区中不能进行调度与切换。 ✓</p>
<p>进程处于临界区时不能进行处理机调度。✖︎</p>
<p>临界资源：一段时间内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。</p>
<p>临界区：访问临界资源的那段代码。</p>
<p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列(由各种就绪进程的PCB组成)。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E5%86%85%E6%A0%B8%E4%B8%B4%E7%95%8C%E5%8C%BA%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.png" alt="内核临界区进程调度"></p>
<p>如果还没退出临界区(还没解锁)就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度。内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E6%99%AE%E9%80%9A%E4%B8%B4%E7%95%8C%E5%8C%BA.png" alt="普通临界区"></p>
<p>在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲。普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时，可以进行调度与切换。</p>
<h4 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a><strong>进程调度的方式</strong></h4><ul>
<li><p>非剥夺调度方式</p>
<p>  又称非抢占方式。即只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</p>
<p>  实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。</p>
</li>
<li><p>剥夺调度式</p>
<p>  又称抢占式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</p>
<p>  可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能(通过始终中断)。适合于分时操作系统、实时操作系统。</p>
</li>
</ul>
<h4 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a><strong>进程的切换与过程</strong></h4><p>“狭义的进程调度”与“进程切换”的区别：</p>
<p>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换)</p>
<p>进程切换指一个进程让出处理机，由另一个进程占用处理机的过程。</p>
<p>广义的进程调度包含了选择一个进程和进程切换两个步骤。</p>
<p>进程切换的过程主要完成了：</p>
<ol>
<li>对原来运行进程各种数据的保护</li>
<li>对新的进程各种数据的恢复</li>
</ol>
<p>​		如程序计数器、程序状态字、各种数据寄存器等处理机线程信息，这些信息一般保存在进程控制块PCB）</p>
<p>ps：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
<h3 id="2-2-3-调度算法的评价指标"><a href="#2-2-3-调度算法的评价指标" class="headerlink" title="2.2.3 调度算法的评价指标"></a>2.2.3 调度算法的评价指标</h3><h4 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h4><p>指CPU“忙碌”的事件占总时间的比例。</p>
<p>利用率 &#x3D; 忙碌的事件 &#x2F; 总时间</p>
<h4 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h4><p>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业。</p>
<p>系统吞吐量指单位时间内完成作业的数量</p>
<p>系统吞吐量 &#x3D; 总共完成了多少道作业 &#x2F; 总共花了多少时间</p>
<h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h4><p>对于计算机来说，他很关心自己的作业从提交到完成花了多少时间。</p>
<p>周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。</p>
<p>它包括四个部分：作业在外存后备队列上等待作业调度(高级调度)的时间、进程在就绪队列上等待进程调度(低级调度)的时间、进程在CPU上执行的时间、进程等待I&#x2F;O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。</p>
<p>周转时间 &#x3D; 作业完成时间 - 作业提交时间</p>
<p>平均周转时间 &#x3D; 各作业周转时间之和 &#x2F; 作业数</p>
<p>带权周转时间 &#x3D; 作业周转时间 &#x2F; 作业实际运行的时间 &#x3D; (作业完成时间 - 作业提交时间) &#x2F; 作业实际运行的时间</p>
<h4 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h4><p>计算机的用户希望自己的作业尽可能少的等待处理机</p>
<p>等待时间是指进程&#x2F;作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</p>
<p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I&#x2F;O完成的期间其实进程也是在被服务的，所以不计入等待时间。</p>
<p>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p>
<p>一个作业总共需要被CPU服务多久，被I&#x2F;O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业&#x2F;进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。</p>
<h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4><p>对于计算机用户来说，会希望自己提交的请求(比如通过键盘输入了一个调试命令)尽早地开始被系统服务、回应。</p>
<p>响应时间指从用户提交请求到首次产生响应所用的时间。</p>
<h3 id="2-2-4-调度算法"><a href="#2-2-4-调度算法" class="headerlink" title="2.2.4 调度算法"></a>2.2.4 调度算法</h3><h4 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务(FCFS)"></a><strong>先来先服务(FCFS)</strong></h4><ul>
<li><p>算法思想</p>
<p>  主要从“公平”的角度考虑(类似于我们生活中排队买东西的例子)</p>
</li>
<li><p>算法规则</p>
<p>  按照作业&#x2F;进程到达的先后顺序进行服务</p>
</li>
<li><p>用于作业&#x2F;进程调度</p>
<p>  用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列</p>
</li>
<li><p>是否可抢占？</p>
<p>  非抢占式的算法</p>
</li>
<li><p>优缺点</p>
<p>  优点：公平、算法实现简单</p>
<p>  缺点：排在长作业(进程)后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即FCFS算法对长作业有利，对短作业不利</p>
</li>
<li><p>是否会导致饥饿</p>
<p>  不会</p>
</li>
</ul>
<h4 id="短作业优先-SJF"><a href="#短作业优先-SJF" class="headerlink" title="短作业优先(SJF)"></a><strong>短作业优先(SJF)</strong></h4><ul>
<li><p>算法思想</p>
<p>  最求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间</p>
</li>
<li><p>算法规则</p>
<p>  最短的作业&#x2F;进程优先得到服务(所谓“最短”，是指要求服务时间最短)</p>
</li>
<li><p>用于作业&#x2F;进程调度</p>
<p>  既可用于作业调度，也可以用于进程调度。用于进程调度时称为“短进程优先”(SPF, Shortest Process First)算法。</p>
</li>
<li><p>是否可抢占</p>
<p>  SJF和SPF是非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法(SRTN， Shortest Remaining Time Next)</p>
</li>
<li><p>优缺点</p>
<p>  优点：“最短的”平均等待时间、平均周转时间</p>
<p>  缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业&#x2F;进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。</p>
</li>
<li><p>是否会导致饥饿</p>
<p>  会。如果源源不断的有短作业&#x2F;进程到来，可能是长作业&#x2F;进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”</p>
</li>
</ul>
<h4 id="高响应比优先-HRRN"><a href="#高响应比优先-HRRN" class="headerlink" title="高响应比优先(HRRN)"></a><strong>高响应比优先(HRRN)</strong></h4><ul>
<li><p>算法思想</p>
<p>  要综合考虑作业&#x2F;进程的等待时间和要求服务的时间</p>
</li>
<li><p>算法规则</p>
<p>  在每次调度时先计算各个作业&#x2F;进程的响应比，选择响应比最高的作业&#x2F;进程为其服务</p>
<p>  响应比 &#x3D; (等待时间 + 要求服务时间) &#x2F; 要求服务时间</p>
</li>
<li><p>用于作业&#x2F;进程调度</p>
<p>  既可用于作业调度，也可用于进程调度</p>
</li>
<li><p>是否可抢占</p>
<p>  非抢占式的算法。因此只有当前运行的作业&#x2F;进程主动放弃处理机时，才需要调度，才需要计算响应比。</p>
</li>
<li><p>优缺点</p>
<p>  综合考虑了等待时间和运行时间(要求服务时间)等待时间相同时，要求服务时间短的优先(SJF的优点)；要求服务时间相同时，等待时间长的优先(FCFS的优点)；对于长作业来说，随着等待时间越来越久，其响应也会越来越大，从而避免了长作业饥饿的问题。</p>
</li>
<li><p>是否会导致饥饿</p>
<p>  不会</p>
</li>
</ul>
<blockquote>
<p>ps: 这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于早期的批处理系统，当然，GCFS算法也结合其他的算法使用，在现在也扮演着很重要的角色。</p>
</blockquote>
<p>​    </p>
<h3 id="2-2-5-适合交互式系统的调度算法"><a href="#2-2-5-适合交互式系统的调度算法" class="headerlink" title="2.2.5 适合交互式系统的调度算法"></a>2.2.5 适合交互式系统的调度算法</h3><h4 id="时间片轮转-RR-Round-Robin"><a href="#时间片轮转-RR-Round-Robin" class="headerlink" title="时间片轮转(RR, Round-Robin)"></a>时间片轮转(RR, Round-Robin)</h4><ul>
<li><p>算法思想</p>
<p>  公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p>
</li>
<li><p>算法规则</p>
<p>  按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片(如100ms)。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</p>
</li>
<li><p>用于作业&#x2F;进程调度</p>
<p>  用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)</p>
</li>
<li><p>是否可抢占</p>
<p>  若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到。</p>
</li>
<li><p>优缺点</p>
<p>  优点：公平、响应快，适用于分时操作系统。</p>
<p>  缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</p>
</li>
<li><p>是否会导致饥饿</p>
<p>  不会</p>
</li>
<li><p>补充</p>
<p>  如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</p>
<p>  另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减小。可见时间片也不能太小。</p>
</li>
</ul>
<h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><ul>
<li><p>算法思想</p>
<p>  随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序。</p>
</li>
<li><p>算法规则</p>
<p>  调度时选择优先级最高的作业&#x2F;进程</p>
</li>
<li><p>用于作业&#x2F;进程调度</p>
<p>  既可用于作业调度，也可用于进程调度。甚至，还会用于I&#x2F;O调度中。</p>
</li>
<li><p>是否可抢占</p>
<p>  抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。</p>
</li>
<li><p>优缺点</p>
<p>  优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各个作业&#x2F;进程的偏好程度。</p>
<p>  缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</p>
</li>
<li><p>是否会导致饥饿</p>
<p>  会</p>
</li>
<li><p>补充</p>
<p>  就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近对头的位置。</p>
<p>  根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。</p>
<p>  静态优先级：创建进程时确定，之后一直不变。</p>
<p>  动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</p>
<blockquote>
<p>如何合理地设置各类进程的优先级？</p>
</blockquote>
<p>  通常系统进程优先级高于用户进程、前台进程优先级高于后台进程、操作系统更偏好I&#x2F;O型进程(或称I&#x2F;O繁忙型进程)</p>
<p>  Ps: 与I&#x2F;O型进程相对的是计算行进程(或称CPU繁忙型进程)</p>
<blockquote>
<p>如果采用的是动态优先级，什么时候应该调整？</p>
</blockquote>
<p>  可以从追求公平、提升资源利用率等角度考虑。如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级。如果某进程占用处理机运行了很长时间，则可适当降低其优先级。如果发现一个进程繁忙地进行I&#x2F;O操作，则可适当提升其优先级。</p>
</li>
</ul>
<h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><ul>
<li><p>算法思想</p>
<p>  对其他调度算法的折中权衡</p>
</li>
<li><p>算法规则</p>
<ol>
<li>设置多集就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾。</li>
<li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li>
</ol>
</li>
<li><p>用于作业&#x2F;进程调度</p>
<p>  用于进程调度</p>
</li>
<li><p>是否可抢占</p>
<p>  抢占式的算法。在k级队列的进程运行过程中，若更上级的队列(1～k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</p>
</li>
<li><p>优缺点</p>
<p>  对各类型进程相对公平(FCFS的优点)；每个新到达的进程都可以很快就得到响应(RR的优点)；短进程只用较少的十斤啊就可完成(SPF的优点)；不必实现估计进程的运行时间(避免用户作假)；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I&#x2F;O密集型进程(拓展：可以讲因I&#x2F;O而阻塞的进程重新放回原队列，这样I&#x2F;O型进程就可以保持较高优先级)</p>
</li>
<li><p>是否会导致饥饿</p>
<p>  会</p>
</li>
</ul>
<h3 id="2-3-1-进程同步、进程互斥"><a href="#2-3-1-进程同步、进程互斥" class="headerlink" title="2.3.1 进程同步、进程互斥"></a>2.3.1 进程同步、进程互斥</h3><h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><p>  同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于他们之间的相互合作。</p>
<h4 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h4><p>进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源(比如内存，又比如打印机、摄像头这样的I&#x2F;O设备)</p>
<p>资源共享的两种方式：</p>
<ul>
<li><p>互斥共享方式</p>
<p>  系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源</p>
</li>
<li><p>同时共享方式</p>
<p>  系统中的某些资源，允许一个时间段内有多个“同时”对它们进行访问。</p>
</li>
</ul>
<p>我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p>
<p>对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源后，另一个进程才能去访问临界资源。</p>
<p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  entry section;			<span class="comment">// 进入区</span></span><br><span class="line">  critical section;		<span class="comment">// 临界区</span></span><br><span class="line">  <span class="built_in">exit</span> section;				<span class="comment">// 退出区</span></span><br><span class="line">  remainder section;	<span class="comment">// 剩余区	</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>进入区：负责检查是否可进入临界区，若可以进入，则应设置<strong>正在访问临界资源的标志</strong>(可理解为“上锁”)，以阻止其他进程同时进入临界区</li>
<li>临界区：访问临界资源的那段代码</li>
<li>退出区：负责解除<strong>正在访问临界资源的标志</strong>(可理解为“解锁”)</li>
<li>剩余区：做其他处理</li>
</ul>
<p>ps：临界区是进程中访问临界资源的代码段。进入区和退出区是负责实现互斥的代码段。临界区也可称为“临界段”。</p>
<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p>
<ol>
<li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li>
<li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li>
<li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)；</li>
<li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ol>
<h3 id="2-3-2-进程互斥的软件实现方法"><a href="#2-3-2-进程互斥的软件实现方法" class="headerlink" title="2.3.2 进程互斥的软件实现方法"></a>2.3.2 进程互斥的软件实现方法</h3><h4 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h4><p>算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>; 			<span class="comment">// turn 表示当前允许进入临界区的进程号</span></span><br><span class="line"><span class="comment">// P0进程：</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">0</span>);	<span class="comment">// ①</span></span><br><span class="line">critical section;		<span class="comment">// ②</span></span><br><span class="line">turn = <span class="number">1</span>;						<span class="comment">// ③</span></span><br><span class="line">remainder section;	<span class="comment">// ④</span></span><br><span class="line"><span class="comment">// P1进程:</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">1</span>);	<span class="comment">// ⑤ 进入区</span></span><br><span class="line">critical section;		<span class="comment">// ⑥ 临界区</span></span><br><span class="line">turn = <span class="number">0</span>;						<span class="comment">// ⑦ 退出区</span></span><br><span class="line">remainder section;	<span class="comment">// ⑧ 剩余区</span></span><br></pre></td></tr></table></figure>

<p>turn的初值为0，即刚开始只允许0号进程进入临界区。</p>
<p>若P1先上处理机运行，则会一直卡在⑤。直到P1的时间片用完，发生调度，切换P0上处理机运行。</p>
<p>代码①不会卡住P0，P0可以正常访问临界区，在P0访问临界区期间及时切换回P1，P1依然会卡在⑤。</p>
<p>只有P0在退出区将turn改为1后，P1才能进入临界区。</p>
<p>因此，该算法可以实现“同一时刻最多只允许一个进程访问临界区”</p>
<p>turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。也就是说，对于临界区的访问，一定是按P0 -&gt; P1 -&gt; P0 -&gt; P1 -&gt; ……这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。</p>
<p>因此，单标志存在的主要问题是：违背“空闲让进”原则。</p>
<h4 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h4><p>算法思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程相进入临界区的意愿，比如<code>flag[0] = true</code>意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];				<span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;		<span class="comment">// 刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"><span class="comment">// P0进程：</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);		<span class="comment">// ①</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;			<span class="comment">// ②</span></span><br><span class="line">critical section;		<span class="comment">// ③</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;		<span class="comment">// ④</span></span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">// P1进程：</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);		<span class="comment">// ⑤ 如果此时P0想进入临界区，P1就一直循环等待</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;			<span class="comment">// ⑥ 标记为P1进程想要进入临界区</span></span><br><span class="line">critical section;		<span class="comment">// ⑦ 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;		<span class="comment">// ⑧ 访问完临界区，修改标记为P1不想使用临界区</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>

<p>若按照①⑤②⑥③⑦……的顺序执行，P0和P1将会同时访问临界区。</p>
<p>因此，双标志先检查法的主要问题是：违反“忙则等待”原则。</p>
<p>原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</p>
<h4 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h4><p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临时区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];					<span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;			<span class="comment">// 刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"><span class="comment">// P0进程：</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;				<span class="comment">// ①</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);			<span class="comment">// ②</span></span><br><span class="line">critical section;			<span class="comment">// ③</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;			<span class="comment">// ④</span></span><br><span class="line">remainder = section;</span><br><span class="line"><span class="comment">// P1进程：</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;				<span class="comment">// ⑤ 标记为P1进程都想要进入临界区</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);			<span class="comment">// ⑥ 如果P0也想进入临界区，则P1循环等待</span></span><br><span class="line">critical section;			<span class="comment">// ⑦ 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;			<span class="comment">// ⑧ 访问完临界区，修改标记为P1不想使用临界区</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>

<p>若按照①⑤②⑥……的顺序执行，P0和P1将都无法进入临界区</p>
<p>因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿“现象。</p>
<p>两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。</p>
<h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p>算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L. Peterson想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方使用临界区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];										<span class="comment">// 表示进入临界区意愿的数组，初始值都是false</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;										<span class="comment">// turn表示优先让哪个进程进入临界区</span></span><br><span class="line"><span class="comment">// P0进程：</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;									<span class="comment">// ①</span></span><br><span class="line">turn = <span class="number">1</span>;												<span class="comment">// ②</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>);		<span class="comment">// ③</span></span><br><span class="line">critical section;								<span class="comment">// ④</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;								<span class="comment">// ⑤</span></span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">// P1进程:</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;									<span class="comment">// ⑥ 表示自己想进入临界区</span></span><br><span class="line">turn = <span class="number">0</span>;												<span class="comment">// ⑦ 可以优先让对方进入临界区</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);		<span class="comment">// ⑧ 对方想进，且最后一次是自己“让梨”，那自己就循环等待</span></span><br><span class="line">critical section;								<span class="comment">// ⑨</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;								<span class="comment">// ⑩ 访问完临界区，表示自己已经不想访问临界区了</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>

<p>两种双标志法的问题都是由于进入区的几个操作不能一气呵成导致的。我们可以推理验证在Peterson算法中，两个进程进入区中的各个操作按不同的顺序穿插执行会发生什么情况：</p>
<p>①②③⑥⑦⑧……</p>
<p>①⑥②③……</p>
<p>Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。</p>
<h3 id="2-3-3-进程互斥的硬件实现方法"><a href="#2-3-3-进程互斥的硬件实现方法" class="headerlink" title="2.3.3 进程互斥的硬件实现方法"></a>2.3.3 进程互斥的硬件实现方法</h3><h4 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h4><p>利用“开&#x2F;关中断指令”实现(与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同事访问临界区的情况)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">关中断；<span class="comment">// 关中断后即不允许当前进程被中断，也必然不会发生进程切换</span></span><br><span class="line">临界区；</span><br><span class="line">开中断；<span class="comment">// 直到当前进程访问完临界区，在执行开中断指令，才有可能有别的进程上处理机并访问临界区</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>优点：简单、高效</p>
<p>缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程(因为开&#x2F;关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)。</p>
<h4 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h4><p>简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令。</p>
<p>TSL指令是硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 布尔型共享标量lock表示当前临界区是否被枷锁</span></span><br><span class="line"><span class="comment">// true表示已加锁，false表示未加锁</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span> <span class="params">(<span class="type">bool</span> *lock)</span> &#123;</span><br><span class="line">  <span class="type">bool</span> old;</span><br><span class="line">  old = *lock;	<span class="comment">// old用来存放lock原来的值</span></span><br><span class="line">  *lock = <span class="literal">true</span>; <span class="comment">// 无论之前是否已加锁，都将lock设为true</span></span><br><span class="line">  <span class="keyword">return</span> old;		<span class="comment">// 返回lock原来的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下是使用TSL指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span> (TestAndSet (&amp;lock));	<span class="comment">// &quot;上锁&quot;并“检查”</span></span><br><span class="line">临界区代码段...</span><br><span class="line">lock = <span class="literal">false</span>;	<span class="comment">// &quot;解锁&quot;</span></span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure>

<p>若刚开始lock是false，则TSL返回的old值为false，while循环条件不满足，直接跳过循环，进入临界区。若刚开始lock是true，则执行TLS后old返回的值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p>
<p>相比软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</p>
<p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p>
<p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等“。</p>
<h4 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h4><p>有的地方也叫Exchange指令，或简称XCHG指令</p>
<p>Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swap指令的作用是交换两个变量的值</span></span><br><span class="line">Swap （<span class="type">bool</span> *a, <span class="type">bool</span> *b) &#123;</span><br><span class="line">  <span class="type">bool</span> temp;</span><br><span class="line">  temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下是用Swap指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="comment">// lock表示当前临界区是否被枷锁</span></span><br><span class="line"><span class="type">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (old == <span class="literal">true</span>)</span><br><span class="line">  Swap (&amp;lock, &amp;old);</span><br><span class="line">临界区代码段...</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure>

<p>逻辑上来看Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁(记录在old变量上)，再将上锁标记lock设置为true，最后检查old，如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p>
<p>优点：实现简单，无需像软件实现方法那样严格检查是否有逻辑漏洞；适用于多处理机环境</p>
<p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等“。</p>
<h3 id="2-3-4-信号量机制"><a href="#2-3-4-信号量机制" class="headerlink" title="2.3.4 信号量机制"></a>2.3.4 信号量机制</h3><blockquote>
<p>进程互斥的解决方案包括软件实现方式：单标志法、双标志先检查、双标志后检查、Peterson算法；硬件实现方式：中断屏蔽方法、TS&#x2F;TSL指令、Swap&#x2F;XCHG指令。但是在双标志先检查法中，进入区的“检查”、“上锁”操作无法一气呵成，从而导致两个进程有可能同时进入临界区的问题；以上所有方法都无法实现“让权等待”原则。1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法——<strong>信号量机制</strong></p>
</blockquote>
<p>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</p>
<p>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。</p>
<p>原语是一种特殊的程序段，其执行职能一气呵成，不可被中断。原语是由关中断&#x2F;开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</p>
<p>一对原语：wait(S)原语和signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的信号量S其实就是函数调用时传入的一个参数。</p>
<p>wait、signal原语常简称为P、V操作(来自荷兰语proberen和verhogen)。因此，做题的时候常把wait(S)、signal(S)两个操作分别写为P(S)、V(S)</p>
<h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p>用一个<strong>整数型的变量</strong>作为信号量，用来<strong>表示系统中某种资源的数量</strong>。</p>
<p>与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作</p>
<p>eg：某计算机系统中有一台打印机……</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">1</span>;							<span class="comment">// 初始化整型信号量S，表示当前系统中可用的打印机资源数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span> <span class="params">(<span class="type">int</span> S)</span> &#123;			<span class="comment">// wait原语，相当于“进入区”</span></span><br><span class="line">  <span class="keyword">while</span> (S &lt;= <span class="number">0</span>);				<span class="comment">// 如果资源数不够，就一直循环等待</span></span><br><span class="line">  S = S - <span class="number">1</span>; 						<span class="comment">// 如果资源数够，则占用一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(<span class="type">int</span> S)</span> &#123;		<span class="comment">// signal原语，相当于“退出区”</span></span><br><span class="line">  S = S + <span class="number">1</span>;						<span class="comment">// 使用完资源后，在退出区释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进程P0:</span></span><br><span class="line">...</span><br><span class="line">wati(S);								<span class="comment">// 进入区，申请资源</span></span><br><span class="line">使用打印机资源...				 <span class="comment">// 临界区，访问资源</span></span><br><span class="line">signal(S);							<span class="comment">// 退出区，释放资源</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//进程P1:</span></span><br><span class="line">...</span><br><span class="line">wati(S);</span><br><span class="line">使用打印机资源...</span><br><span class="line">signal(S);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//进程P2:</span></span><br><span class="line">...</span><br><span class="line">wati(S);</span><br><span class="line">使用打印机资源...</span><br><span class="line">signal(S);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>wait原语“检查”和“上锁”一气呵成，避免了并发、异步导致的问题。但是还是存在不满足“让权等待”原则，会发生“忙等”</p>
<h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>整型信号量的缺陷是存在“忙等”问题，因此又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记录型信号量的定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> value;						<span class="comment">// 剩余资源数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span>		<span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"><span class="comment">/*某进程需要使用资源时，通过wait原语申请*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span> <span class="params">(semaphore S)</span> &#123;</span><br><span class="line">  S.value--;</span><br><span class="line">  <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    block(S.L)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*进程使用完资源后，通过signal原语释放*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(semaphore S)</span> &#123;</span><br><span class="line">  S.value++;</span><br><span class="line">  <span class="keyword">if</span> (S.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    wakeup(S.L);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// P0进程：</span></span><br><span class="line">...</span><br><span class="line">wait(S);</span><br><span class="line">使用打印机...</span><br><span class="line">signal(S);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// P1进程：</span></span><br><span class="line">...</span><br><span class="line">wait(S);</span><br><span class="line">使用打印机...</span><br><span class="line">signal(S);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// P2进程：</span></span><br><span class="line">...</span><br><span class="line">wait(S);</span><br><span class="line">使用打印机...</span><br><span class="line">signal(S);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列（即阻塞队列）中。</p>
<p>释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态。</p>
<p>wait(S)、signal(S)也可以记为P(S)、V(S)，用于<strong>实现系统资源的“申请”和“释放”</strong>。</p>
<p><strong>S.value的初值</strong>表示系统中<strong>某种资源的数目</strong>。</p>
<p>对信号量S的一次P操作意味着进程<strong>请求一个单位的该类资源</strong>，因此需要执行S.value–, 表示资源数减1，当S.value &lt; 0时表示该类资源已分配完毕，因此进程应<strong>调用block原语进行自我阻塞<strong>（当前运行的进程从</strong>运行态 -&gt; 阻塞态</strong>），主动放弃处理机，并插入该类资源的等待队列S.L中。可见，该机制<strong>遵循了“让权等待”原则</strong>，不会出现“忙等”现象。</p>
<p>对信号量S的<strong>一次V操作</strong>意味着进程<strong>释放一个单位的该类资源</strong>，因此需要执行S.value++, 表示资源数加1，若加1后仍是S.value &lt;&#x3D;. 0，表示仍然有进程在等待该类资源，因此应**调用wakeup原语唤醒等待队列中第一个进程**（被唤醒进程从阻塞态 -&gt; 就绪态）。</p>
<h3 id="2-3-5-信号量的应用"><a href="#2-3-5-信号量的应用" class="headerlink" title="2.3.5 信号量的应用"></a>2.3.5 信号量的应用</h3><h4 id="实现进程互斥"><a href="#实现进程互斥" class="headerlink" title="实现进程互斥"></a>实现进程互斥</h4><ol>
<li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</li>
<li>设置互斥信号量mutex，初始值为1</li>
<li>在临界区之前执行P(mutex)</li>
<li>在临界区之后执行V(mutex)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*信号量机制实现互斥*/</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;			<span class="comment">// 初始化信号量</span></span><br><span class="line">P1() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(mutex);						<span class="comment">// 使用临界资源前需要加锁</span></span><br><span class="line">  临界区代码段...</span><br><span class="line">  V(mutex);						<span class="comment">// 使用临界资源后需要解锁</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(mutex);</span><br><span class="line">  临界区代码段...</span><br><span class="line">  V(mutex);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Ps: 对<strong>不同的临界资源</strong>需要<strong>设置不同的互斥信号量</strong>。<strong>P、V操作必须成对出现</strong>。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</p>
<h4 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a>实现进程同步</h4><p>进程同步：各并发进程按要求有序地推进。</p>
<p>用信号量实现进程同步：</p>
<ol>
<li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作(或两句代码)</li>
<li>设置同步信号量S，初始值为0</li>
<li>在“前操作”之后执行V操作</li>
<li>在“后操作”之前执行P操作</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*信号量机制实现同步*/</span></span><br><span class="line">semaphore S = <span class="number">0</span>;			<span class="comment">// 初始化同步信号量，初始值为0</span></span><br><span class="line">P1() &#123;</span><br><span class="line">  代码<span class="number">1</span>;</span><br><span class="line">  代码<span class="number">2</span>;</span><br><span class="line">  V(S);</span><br><span class="line">  代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">  P(S);</span><br><span class="line">  代码<span class="number">4</span>;</span><br><span class="line">  代码<span class="number">5</span>;</span><br><span class="line">  代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若先执行到V(S)操作，则S++后S &#x3D; 1。之后当执行到P(S)操作时，由于S &#x3D; 1，表示有可用资源，会执行S–，S的值变回0，P2进程不会执行block原语，而是继续往下执行代码4。</p>
<p>若先执行到P(S)操作，由于S&#x3D;0，S–后S &#x3D; -1，表示此时没有可用资源，因此P操作会执行block原语，主动请求阻塞。之后当执行完代码2，继而执行V(S)操作，S++，使S变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作执行wakeup原语，唤醒P2进程。这样P2就可以继续执行代码4了。</p>
<h4 id="实现进程的前驱关系"><a href="#实现进程的前驱关系" class="headerlink" title="实现进程的前驱关系"></a>实现进程的前驱关系</h4><p>进程P1中有句代码S1，P2中有句代码S2，… P3 …P6中有句代码S6。这些代码要求按如下前驱图所示的顺序来执行：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E5%89%8D%E9%A9%B1%E5%9B%BE.png" alt="前驱图"></p>
<p>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）</p>
<ol>
<li>要为每一对前驱关系各设置一个同步变量</li>
<li>在“前操作”之后对相应的同步变量执行V操作</li>
<li>在“后操作”之前对相应的同步变量执行P操作</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">P1() &#123;</span><br><span class="line">  ...</span><br><span class="line">  S1;</span><br><span class="line">  V(a);</span><br><span class="line">  V(b);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(a);</span><br><span class="line">  S2;</span><br><span class="line">  V(c);</span><br><span class="line">  V(d);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">P3() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(b);</span><br><span class="line">  S3;</span><br><span class="line">  V(g);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">P4() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(c);</span><br><span class="line">  S4;</span><br><span class="line">  V(e);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">P5() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(d);</span><br><span class="line">  S5;</span><br><span class="line">  V(f);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">P6() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(e);</span><br><span class="line">  P(f);</span><br><span class="line">  P(g);</span><br><span class="line">  S6;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-6-生产者-消费者问题"><a href="#2-3-6-生产者-消费者问题" class="headerlink" title="2.3.6 生产者-消费者问题"></a>2.3.6 生产者-消费者问题</h3><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区取出一个产品并使用。（这里的“产品”理解为某种数据）。</p>
<p>生产者、消费者共享一个初始为空、大小为n的缓冲区。</p>
<p>分析：</p>
<ul>
<li><p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</p>
<p>  同步关系。缓冲区满时，生产者要等待消费者取走产品</p>
</li>
<li><p>只有缓冲区不为空时，消费者才能从中取出产品，否则必须等待。</p>
<p>  同步关系。缓冲区空时，消费者要等待生产者放入产品</p>
</li>
<li><p>缓冲区是临界资源，各进程必须互斥地访问。</p>
<p>  互斥</p>
</li>
</ul>
<p>处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;	<span class="comment">// 互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore enpty = n;	<span class="comment">// 同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;		<span class="comment">// 同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br><span class="line">producer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    生产一个产品;</span><br><span class="line">    P(empty);			<span class="comment">// ①</span></span><br><span class="line">    P(mutex);			<span class="comment">// ②</span></span><br><span class="line">    把产品放入缓冲区;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(full);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(full);			<span class="comment">// ③</span></span><br><span class="line">    P(mutex);			<span class="comment">// ④</span></span><br><span class="line">    从缓冲区取出一个产品;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(empty);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考：能够修改①和②，③和④的顺序。</p>
<p>如果修改，若此时缓冲区内已经放满产品，则empty &#x3D; 0，full &#x3D; n。</p>
<p>则生产者进程执行②使mutex &#x3D; 0，在执行①，由于已经没有空闲缓冲区，因此生产者被阻塞。由于生产者阻塞，因此切换回消费者进程。消费者进程执行④，由于mutex &#x3D; 0，即生产者还没有释放对临界资源的“锁”，因此消费者也被阻塞。</p>
<p>这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“死锁”。</p>
<p>同样的，若缓冲区中没有产品，即full &#x3D; 0，empty &#x3D; n。按④③②的顺序执行也会发生死锁。</p>
<p>因此，<strong>实现互斥的P操作一定要在实现同步的P操作之后</strong>。</p>
<p>V操作不会导致进程阻塞，因此两个V操作顺序可以交换。</p>
<h3 id="2-3-7-多生产者-多消费者问题"><a href="#2-3-7-多生产者-多消费者问题" class="headerlink" title="2.3.7 多生产者-多消费者问题"></a>2.3.7 多生产者-多消费者问题</h3><p> 桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可以向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</p>
<p><strong>分析：</strong></p>
<p>互斥关系：（mutex &#x3D; 1）</p>
<p>对缓冲区（盘子）的访问要互斥地进行</p>
<p>同步关系：（一前一后）</p>
<ol>
<li>父亲将苹果放入盘子后，女儿才能取苹果</li>
<li>母亲将橘子放入盘子后，儿子才能取橘子</li>
<li>只有盘子为空时，父亲或母亲才能放入水果</li>
</ol>
<p><strong>实现：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85.png" alt="多生产者多消费者"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;		<span class="comment">// 实现互斥访问盘子（缓冲区）</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;		<span class="comment">// 盘子中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>;		<span class="comment">// 盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;		<span class="comment">// 盘子中还可以放多少个水果</span></span><br><span class="line">dad() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    准备一个苹果;</span><br><span class="line">    P(plate);</span><br><span class="line">    P(mutex);</span><br><span class="line">    把苹果放入盘子;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(apple);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">mom() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    准备一个橘子;</span><br><span class="line">    P(plate);</span><br><span class="line">    P(mutex);</span><br><span class="line">    把橘子放入盘子;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(orange);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">daughter() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(apple);</span><br><span class="line">    P(mutex);</span><br><span class="line">    从盘子中取出苹果;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(plate);</span><br><span class="line">    吃掉苹果;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">son() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(orange);</span><br><span class="line">    P(mutex);</span><br><span class="line">    从盘子中取出橘子;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(plate);</span><br><span class="line">    吃掉橘子;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思考：</strong>可不可以不用互斥信号量</p>
<p><strong>分析：</strong>刚开始，儿子、女儿进程即使上处理机也会被阻塞。如果刚开始是父亲进程先上处理机，则：父亲P(plate)，可以访问盘子 -&gt; 母亲P(plate)，阻塞等待盘子 -&gt; 父亲放入苹果V(apple)，女儿进程被唤醒，其他进程即使运行也都会阻塞，暂时不可能访问临界资源(盘子) -&gt; 女儿P(apple)，访问盘子，V(plate)，等待盘子的母亲进程被唤醒 -&gt; 母亲进程访问盘子（其他进程暂时都无法进入临界区） -&gt; ……</p>
<p><strong>结论：</strong></p>
<p>当缓冲区的容量为1时，即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象。因为缓冲区的大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区……但是，当缓冲区的容量大于1时，会出现两个进程同时访问缓冲区的情况，有可能导致连个进程写入缓冲区的数据相互覆盖的情况。所以，如果缓冲区的大小大于1，就必须专门设置一个互斥信号量mutex来保证互斥访问缓冲区。</p>
<p><strong>总结：</strong></p>
<p>在生产者-消费者问题中，如果缓冲区大小为1，那么<strong>有可能</strong>不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</p>
<h3 id="2-3-8-吸烟者问题"><a href="#2-3-8-吸烟者问题" class="headerlink" title="2.3.8 吸烟者问题"></a>2.3.8 吸烟者问题</h3><p><strong>描述：</strong></p>
<p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一只烟，抽烟者需要三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放在桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复（让三哥抽烟者轮流地抽烟）</p>
<p><strong>分析：</strong></p>
<ul>
<li>组合一：纸+胶水</li>
<li>组合二：烟草+胶水</li>
<li>组合三：烟草+纸</li>
</ul>
<p>同步关系：</p>
<ul>
<li>桌子上有组合一 -&gt; 第一个抽烟者取走东西</li>
<li>桌子上有组合二 -&gt; 第二个抽烟者取走东西</li>
<li>桌子上有组合三 -&gt; 第三个抽烟者取走东西</li>
<li>发出完成信号 -&gt; 供应者将下一个组合放到桌子上</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E6%8A%BD%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98.png" alt="抽烟者问题"></p>
<p><strong>实现：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>;		<span class="comment">// 桌上组合一的数量</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>;		<span class="comment">// 桌上组合二的数量</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>;		<span class="comment">// 桌上组合三的数量</span></span><br><span class="line">semaphore finish = <span class="number">0</span>;		<span class="comment">// 抽烟是否完成</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;					<span class="comment">// 用于实现“三个抽烟者轮流抽烟”</span></span><br><span class="line">provider() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      将组合一放桌上;</span><br><span class="line">      V(offer1);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">      将组合二放桌上;</span><br><span class="line">      V(offer2);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>) &#123;</span><br><span class="line">      将组合三放桌上;</span><br><span class="line">      V(offer3);</span><br><span class="line">    &#125;</span><br><span class="line">    i = (i + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">    P(finish);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker1() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(offer1):</span><br><span class="line">    从桌上拿走组合一;</span><br><span class="line">    卷烟;</span><br><span class="line">    抽掉;</span><br><span class="line">    V(finish);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker2() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(offer2):</span><br><span class="line">    从桌上拿走组合二;</span><br><span class="line">    卷烟;</span><br><span class="line">    抽掉;</span><br><span class="line">    V(finish);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker3() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(offer3):</span><br><span class="line">    从桌上拿走组合三;</span><br><span class="line">    卷烟;</span><br><span class="line">    抽掉;</span><br><span class="line">    V(finish);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-9-读者-写者问题"><a href="#2-3-9-读者-写者问题" class="headerlink" title="2.3.9 读者-写者问题"></a>2.3.9 读者-写者问题</h3><p> <strong>问题</strong>：</p>
<p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p>
<ol>
<li>允许多个读者可以同时对文件执行读操作；</li>
<li>只允许一个写者往文件中写信息；</li>
<li>任一写者在完成写操作之前不允许其他读者或写者工作；</li>
<li>写者执行写操作前，应让已有的读者和写者全部退出。</li>
</ol>
<p><strong>分析：</strong></p>
<p>两类进程：写进程、读进程</p>
<p>互斥关系：写进程—写进程、写进程—读进程。读进程与读进程不存在互斥关系。</p>
<ul>
<li><p>写者进程和任何进程都互斥，设置一个互斥信号量rw，在写者访问共享文件前后分别执行P、V操作。</p>
</li>
<li><p>读者进程和写者进程也要互斥，因此读者访问共享文件前后也要对rw执行P、V操作。</p>
</li>
<li><p>如果所有读者进程在访问共享文件之前都执行P(rw)操作，那么会导致各个读进程之间无法同时访问文件。</p>
</li>
<li><p><strong>读者写者问题的核心思想——怎么处理该问题呢？</strong></p>
<p>  P(rw)和V(rw)其实就是对共享文件的“加锁”和“解锁”。既然各个读进程需要同时访问，而读进程与写进程又必须互斥访问，那么我们可以让第一个访问文件的读进程“加锁”，让最后一个访问完文件的读进程“解锁”。可以设置一个整数变量count来记录当前有几个读进程在访问文件。</p>
</li>
</ul>
<p><strong>实现一：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>;		<span class="comment">// 用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;			<span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">writer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(rw);		<span class="comment">// 写之前“加锁”</span></span><br><span class="line">    写文件...;</span><br><span class="line">    V(rw);		<span class="comment">// 写之后“解锁”</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">      P(rw);				<span class="comment">// 第一个读进程负责“加锁”</span></span><br><span class="line">    &#125;	</span><br><span class="line">    count++;				<span class="comment">// 访问文件的进程书+1</span></span><br><span class="line">    读文件...;</span><br><span class="line">    count--;				<span class="comment">// 访问文件的读进程数-1</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">      V(rw);				<span class="comment">// 最后一个读进程负责“解锁“</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>思考：</strong></p>
<p>若两个读进程并发执行，则两个读进程可能先后执行P(rw), 从而使第二个读进程阻塞的情况。</p>
<p>如何解决：</p>
<p>出现上述问题的原因在于对count变量的检查和赋值无法一气呵成，因此可以设置另一个互斥信号量来保证各读进程count的访问时互斥的。</p>
<p><strong>实现二：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>;			<span class="comment">// 用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;				<span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;	<span class="comment">// 用于保证对count变量的互斥访问 </span></span><br><span class="line">writer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(rw);		<span class="comment">// 写之前“加锁”</span></span><br><span class="line">    写文件...;</span><br><span class="line">    V(rw);		<span class="comment">// 写之后“解锁”</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(mutex);				<span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">      P(rw);				<span class="comment">// 第一个读进程负责“加锁”</span></span><br><span class="line">    &#125;	</span><br><span class="line">    count++;				<span class="comment">// 访问文件的进程书+1</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    读文件...;</span><br><span class="line">    P(mutex);				<span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">    count--;				<span class="comment">// 访问文件的读进程数-1</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">      V(rw);				<span class="comment">// 最后一个读进程负责“解锁“</span></span><br><span class="line">    &#125;</span><br><span class="line">    V(mutex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>潜在的问题：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此，这种算法中，读进程是优先的。</p>
</blockquote>
<p><strong>实现三：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>;			<span class="comment">// 用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;				<span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;	<span class="comment">// 用于保证对count变量的互斥访问 </span></span><br><span class="line">semaphore w = <span class="number">1</span>;			<span class="comment">// 用于实现“写优先”</span></span><br><span class="line">writer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(w);</span><br><span class="line">    P(rw);		<span class="comment">// 写之前“加锁”</span></span><br><span class="line">    写文件...;</span><br><span class="line">    V(rw);		<span class="comment">// 写之后“解锁”</span></span><br><span class="line">    V(w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(w);</span><br><span class="line">    P(mutex);				<span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">      P(rw);				<span class="comment">// 第一个读进程负责“加锁”</span></span><br><span class="line">    &#125;	</span><br><span class="line">    count++;				<span class="comment">// 访问文件的进程书+1</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    V(w);</span><br><span class="line">    读文件...;</span><br><span class="line">    P(mutex);				<span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">    count--;				<span class="comment">// 访问文件的读进程数-1</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">      V(rw);				<span class="comment">// 最后一个读进程负责“解锁“</span></span><br><span class="line">    &#125;</span><br><span class="line">    V(mutex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong></p>
<p>在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。也称为“读写公平法”。</p>
<h3 id="2-3-10-哲学家进餐问题"><a href="#2-3-10-哲学家进餐问题" class="headerlink" title="2.3.10 哲学家进餐问题"></a>2.3.10 哲学家进餐问题</h3><p><strong>问题：</strong></p>
<p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌子摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子(一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98.png" alt="哲学家进餐问题"></p>
<p><strong>分析：</strong></p>
<ol>
<li>关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</li>
<li>整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。</li>
<li>信号量设置。定义互斥信号量数组chopstick[5]&#x3D;{1,1,1,1,1}用于实现对5个筷子的互斥访问。并对哲学家按0～4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5。</li>
</ol>
<p><strong>思考：</strong></p>
<p>如何防止死锁的发生？</p>
<ol>
<li>可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。</li>
<li>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一支筷子，另一个会直接阻塞。这就避免了占有一只后再等待另一只的情况。</li>
<li>规定同时只有一个哲学家能拿起筷子吃饭</li>
</ol>
<p><strong>实现3：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;				<span class="comment">// 互斥地取筷子</span></span><br><span class="line">Pi() &#123;											<span class="comment">// i号哲学家的进程</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    P(chopstick[i]);				<span class="comment">// 拿左边的筷子</span></span><br><span class="line">    p(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);	<span class="comment">// 拿右边的筷子</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    吃饭...;</span><br><span class="line">    V(chopstick[i]);				<span class="comment">// 放下左边的筷子</span></span><br><span class="line">    V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);	<span class="comment">// 放下右边的筷子</span></span><br><span class="line">    思考...;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-11-管程"><a href="#2-3-11-管程" class="headerlink" title="2.3.11 管程"></a>2.3.11 管程</h3><h4 id="为什么要引入管程"><a href="#为什么要引入管程" class="headerlink" title="为什么要引入管程"></a>为什么要引入管程</h4><p>信号量机制存在的问题：编写程序困难、易出错。程序员在编程时需要关注复杂的PV操作。</p>
<h4 id="管程的定义和基本特征"><a href="#管程的定义和基本特征" class="headerlink" title="管程的定义和基本特征"></a>管程的定义和基本特征</h4><p>管程是一种特殊的软件模块，有这些部分组成：</p>
<ol>
<li>局部于管程的<strong>共享数据结构</strong>说明；</li>
<li>对该数据结构进行操作的<strong>一组过程</strong>（“过程”就是“函数”）；</li>
<li>对局部于管程的<strong>共享数据设置初始值的语句</strong>；</li>
<li>管程有一个名字。</li>
</ol>
<p><strong>管程的基本特征</strong>：</p>
<ol>
<li>局部于管程的数据智能被局部于管程的过程所访问；</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li>
<li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong>。</li>
</ol>
<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p><strong>用管程解决生产中消费者问题</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">  condition full, empty;	<span class="comment">//条件变量用来实现同步（排队）</span></span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;	<span class="comment">// 缓冲区中的产品数</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">insert</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(count == N) &#123;</span><br><span class="line">      wait(full);</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">    insert_item(item);</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">1</span>) &#123;</span><br><span class="line">      signal(empty);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	Item <span class="title function_">remove</span><span class="params">()</span> &#123;	<span class="comment">// 从缓冲区中取出一个产品</span></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">      wait(empty);</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span>(count == N<span class="number">-1</span>) &#123;</span><br><span class="line">      signal(full);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> remove_item();</span><br><span class="line">  &#125;</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line">producer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    item = 生产一个产品;</span><br><span class="line">    ProducerConsumer.insert(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者进程</span></span><br><span class="line">consumer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    item = ProducerConsumer.remove();</span><br><span class="line">    消费产品item;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>管程中设置条件变量和等待&#x2F;唤醒操作，以解决同步问题。</p>
<p><strong>由编译器负责实现个进程互斥地进入管程中的过程。</strong></p>
</blockquote>
<p>引入管程的目的无非就是要更方便地实现进程互斥和同步。</p>
<ol>
<li>需要在管程中定义共享数据(如生产者消费者问题中的缓冲区)</li>
<li>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数（如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，在定义一个函数用于从缓冲区取出产品）</li>
<li>只有<strong>通过这些特定的“入口”才能访问共享数据</strong></li>
<li>管程中有很多“入口”，但是<strong>每次只能开放其中一个“入口”</strong>，并且<strong>只能让一个进程或线程进入</strong>（如生产者消费者问题中，个进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意：<strong>这种互斥特性是由编译器负责实现的，程序员不用关心</strong>。）</li>
<li>可在管程中设置条件变量即等待&#x2F;唤醒操作以解决同步问题。可以让一个进程或线程在田间变量上等待（此时，该进程应先释放管程的使用权，也就是让出“入口”）；可以通过唤醒操作将等待在条件上的进程或线程唤醒。</li>
</ol>
<p><strong>Java中，如果用关键字Synchronized来描述一个函数，那么这个函数同一时间段内只能被一个线程调用</strong>。</p>
<h3 id="2-4-1-死锁的概念"><a href="#2-4-1-死锁的概念" class="headerlink" title="2.4.1 死锁的概念"></a>2.4.1 死锁的概念</h3><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>在并发环境下，个进程因竞争资源而造成的一种**互相等待对方手里的资源，导致进程都阻塞，都无法向前推进的现象，就是死锁。</p>
<h4 id="死锁、饥饿、死循环的区别"><a href="#死锁、饥饿、死循环的区别" class="headerlink" title="死锁、饥饿、死循环的区别"></a>死锁、饥饿、死循环的区别</h4><p>死锁：各进程相互等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p>
<p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先(SPF)算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</p>
<p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">区别</th>
</tr>
</thead>
<tbody><tr>
<td align="center">死锁</td>
<td align="center">死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那至少<strong>有两个或两个以上的进程同时发生死锁</strong>。另外，发生死锁的进程一定处于阻塞态。</td>
</tr>
<tr>
<td align="center">饥饿</td>
<td align="center"><strong>可能只有一个进程发生饥饿</strong>。发生饥饿的进程既可能是阻塞态（如长期得不到需要的I&#x2F;O设备），也可能是就绪态（长期得不到处理机）</td>
</tr>
<tr>
<td align="center">死循环</td>
<td align="center">可能只有一个进程发生死循环。死循环的进程可以上处理机运行(可以是运行态)，只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。<strong>死锁和饥饿是管理者(操作系统)的问题，死循环是被管理者的问题</strong></td>
</tr>
</tbody></table>
<blockquote>
<p>共同点：都是进程无法顺利向前推进的现象（故意设计的死循环除外）。</p>
</blockquote>
<h4 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h4><p>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。</p>
<ol>
<li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源)。</li>
<li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ol>
<p>Tips：发生死锁时一定有循环等待，但是发生循环等待时未必死锁(循环等待是死锁的必要不充分条件)。如果同类资源数大于1，则及时有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p>
<h4 id="什么时候会发生死锁"><a href="#什么时候会发生死锁" class="headerlink" title="什么时候会发生死锁"></a>什么时候会发生死锁</h4><ol>
<li>对系统资源的竞争。各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的。</li>
<li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两种会因为申请的资源被对方占有而阻塞，从而发生死锁。</li>
<li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看作是一种抽象的系统资源）</li>
</ol>
<p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p>
<h3 id="2-4-2-死锁的处理策略-预防死锁"><a href="#2-4-2-死锁的处理策略-预防死锁" class="headerlink" title="2.4.2 死锁的处理策略-预防死锁"></a>2.4.2 死锁的处理策略-预防死锁</h3><h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。</p>
<p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如SPOOLing技术。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备……</p>
<p>该策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。</p>
<h4 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h4><p>不剥夺条件：进程所获得的资源在未使用完之前，不能有其他进程强行夺走，只能主动释放。</p>
<p>破坏不剥夺条件：</p>
<p>方案一：当某个进程请求新的资源得不到满足时，他必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p>
<p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级(比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)</p>
<p>该策略的缺点：</p>
<ol>
<li>实现起来比较复杂</li>
<li>释放已获得的资源可能造成前一阶段工作的实效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU</li>
<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量</li>
<li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li>
</ol>
<h4 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h4><p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</p>
<p>可以采用静态分配方法，即进程在运行前一次申请完他所需要的全部资源，在他的资源为满足前，不让他投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p>
<p>该策略实现起来简单，但也有明显的缺点：</p>
<p>有些资源可能只需要很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</p>
<h4 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h4><p>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</p>
<p>可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（机编号相同的资源）一次申请完。</p>
<p>原理分析：一个进程只有已占有小编好的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编好的资源，从而就不会产生循环等待的现象。</p>
<p>该策略的缺点：</p>
<ol>
<li>不方便增加新的设备，因为可能需要重新分配所有的编号</li>
<li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li>
<li>必须按规定次序申请资源，用户编程麻烦</li>
</ol>
<h3 id="2-4-3-死锁的处理策略-避免死锁"><a href="#2-4-3-死锁的处理策略-避免死锁" class="headerlink" title="2.4.3 死锁的处理策略-避免死锁"></a>2.4.3 死锁的处理策略-避免死锁</h3><h4 id="什么是安全序列"><a href="#什么是安全序列" class="headerlink" title="什么是安全序列"></a>什么是安全序列</h4><p><strong>银行家算法：</strong></p>
<p>你是一位成功的银行家，手里掌握着100个亿的资金……有三个企业想找你贷款，分别是企业B、企业A、企业T，为了方便描述，简称BAT。</p>
<ul>
<li>B表示：“大哥，我最多会跟你姐70亿……”</li>
<li>A表示：“大哥，我最多会跟你借40亿……”</li>
<li>T表示：“大哥，我最多会跟你借50亿……”</li>
</ul>
<p>然而江湖中有个不成文的规矩：如果你借给企业的钱总数达不到企业提出的最大要求，那么不管你之前给企业借了多少钱，那些钱都拿不回来了……</p>
<p>刚开始，BAT三个企业分别从你这借了20、10、30亿……</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">最大需求</th>
<th align="center">已借走</th>
<th align="center">最多还会借</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B</td>
<td align="center">70</td>
<td align="center">20</td>
<td align="center">50</td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">40</td>
<td align="center">10</td>
<td align="center">30</td>
</tr>
<tr>
<td align="center">T</td>
<td align="center">50</td>
<td align="center">30</td>
<td align="center">20</td>
</tr>
</tbody></table>
<p>所谓<strong>安全序列</strong>，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</p>
<p>如果分配了资源之后，系统中找不到任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。</p>
<p>银行家算法是荷兰学者Dijkstra为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用来避免死锁。</p>
<p><strong>核心思想：</strong>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p>
<p>可以把单维的数字拓展为多维的向量。比如：系统中有5个进程P0～P4，3中资源R0～R2，初始数量为(10，5，7)。</p>
<p>假设系统中有n个进程，m种资源，每个进程在运行前先声明对各种资源的最大需求数，则可用一个n×m的矩阵(可用二维数组实现)表示所有进程对各种资源的最大需求数。不妨称为最大需求矩阵Max，Max[i,j]&#x3D;k表示进程Pi最多需要k个资源Rj。同理，系统可以用一个n×m的分配矩阵Allocation表示对所有进程的资源分配情况。Max-Allocation&#x3D;Need矩阵，表示各进程最多还需要多少各类子资源。</p>
<p>另外，还要用一个长度为m的一维数组Available表示当前系统中还有多少可用资源。</p>
<p>某进程Pi向系统申请资源，可用一个长度为m的一维数组Request<sub>i</sub>表示本次申请的各种资源量。</p>
<p>可用银行家算法预判本次分配是否会导致系统进入不安全状态：</p>
<ol>
<li><p>如果Request<sub>i</sub>[j]&lt;&#x3D;Need[i,j] (0&lt;&#x3D;j&lt;&#x3D;m) 便转向2；否则认为出错。</p>
</li>
<li><p>如果Request<sub>i</sub>[j]&lt;&#x3D;Available[j] (0&lt;&#x3D;j&lt;&#x3D;m)，便转向3；否则表示尚无足够资源，Pi必须等待。</p>
</li>
<li><p>系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判）：</p>
<p> Available &#x3D; Available - Request<sub>i</sub> ;</p>
<p> Allocation[i,j] &#x3D; Allocation[i, j] + Request<sub>i</sub>[j] ;</p>
<p> Need[i, j] &#x3D; Need[i, j] - Request<sub>i</sub>[j]</p>
</li>
<li><p>操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。</p>
</li>
</ol>
<h3 id="2-4-4-死锁的处理策略-检测和解除"><a href="#2-4-4-死锁的处理策略-检测和解除" class="headerlink" title="2.4.4 死锁的处理策略-检测和解除"></a>2.4.4 死锁的处理策略-检测和解除</h3><p>数据结构：资源分配图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png" alt="资源分配图"></p>
<ul>
<li>两种节点<ul>
<li>进程节点：对应一个进程</li>
<li>资源节点：对应一类资源，一类资源可能有多个</li>
</ul>
</li>
<li>两种边<ul>
<li>进程节点 -&gt; 资源节点：表示进程想申请几个资源（每条边代表一个）</li>
<li>资源节点 -&gt; 进程节点：表示已经为进程分配了几个资源（每条边代表一个）</li>
</ul>
</li>
</ul>
<h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><p>为了能对系统是否已发生了死锁进行检测，必须：</p>
<p>①用某种数据结构来保存资源的请求和分配信息；</p>
<p>②提供一种算法，利用上述信息来检测系统是否已进入死锁状态。</p>
<p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程……</p>
<p>如果按上述过程分析，最终能消除所有边，就称这个图是<strong>可完全简化的</strong>。此时一定没有发生死锁（相当于能找到一个安全序列）</p>
<p>如果最终不能消除所有边，那么此时就是发生了死锁。</p>
<p>最终还连着边的那些进程就是处于死锁状态的进程。</p>
<p><strong>检测死锁的算法：</strong></p>
<ol>
<li>在资源分配图中，找出既不阻塞又不是孤点的进程Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。</li>
<li>进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。</li>
</ol>
<p>死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。</p>
<h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h4><p>一旦检测出死锁的发生，就应该立即揭出死锁。</p>
<p>补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法<strong>化简资源分配图后，还连着边的那些进程就是死锁进程</strong></p>
<p>解除死锁的主要方法有：</p>
<ol>
<li>资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占他的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li>
</ol>
<p>Tips：如何决定“对谁下手“</p>
<ol>
<li>进程优先级</li>
<li>已执行多长时间</li>
<li>还要多久能完成</li>
<li>进程已经使用了多少资源</li>
<li>进程是交互式的还是批处理式的</li>
</ol>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="3-1-1-内存的基础知识"><a href="#3-1-1-内存的基础知识" class="headerlink" title="3.1.1 内存的基础知识"></a>3.1.1 内存的基础知识</h3><h4 id="什么是内存，有何作用"><a href="#什么是内存，有何作用" class="headerlink" title="什么是内存，有何作用"></a>什么是内存，有何作用</h4><p>内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E5%86%85%E5%AD%98.png" alt="内存"></p>
<p>内存中各有一个一个的“小房间”，每个小房间就是一个“存储单元”。如果计算机“按字节编址”，则每个存储单元大小为1字节，即1B，即8个二进制位。</p>
<p>内存地址从0开始，每个地址对应一个存储单元</p>
<p><strong>常见的数量单位</strong></p>
<p>2<sup>10</sup> &#x3D; 1K	(千)</p>
<p>2<sup>20</sup> &#x3D; 1M	(兆，百万)</p>
<p>2<sup>30</sup> &#x3D; 1G	(十亿，千兆)</p>
<p>Ps：一台手机&#x2F;电脑有4GB内存，是什么意思？</p>
<p>是指该内存中可以存放4*2<sup>30</sup>个字节。如果是按字节编址的话，也就是有4*<sup>30</sup> &#x3D; 2<sup>32</sup>个“小房间”。这么多“小房间”，需要2<sup>32</sup>个地址才能一一标识，所以地址需要用32个二进制位来表示（0～2<sup>32</sup>-1）。</p>
<h4 id="进程运行的基本原理"><a href="#进程运行的基本原理" class="headerlink" title="进程运行的基本原理"></a>进程运行的基本原理</h4><p><strong>指令</strong></p>
<p>我们平时写的代码通过编译成CPU能够识别的指令。指令会告诉CPU应该去内存的哪个地址存&#x2F;取数据，这个数据应该做怎样的处理。</p>
<p><strong>逻辑地址 &amp; 物理地址</strong></p>
<blockquote>
<p>宿舍四个人一起出去旅行，四个人的学号尾号分别是0、1、2、3。住酒店时，酒店给你们安排了4个房号相连的房间。四个人按学号递增次序入住房间。比如0、1、2、3号同学分别去住了5、6、7、8号房间。四个人的编号0、1、2、3、4其实就是一个“相对位置”，而各自入住的房间号是一个“绝对位置”。只要知道0号同学住的是房间号为N的房间，那么M号同学的房号一定是N+M。也就是说，只要知道各个同学的“相对位置”和“起始房号”，就一定可以算出所有同学的“绝对位置”</p>
</blockquote>
<p>指令中的地址也可以采用这种思想。编译时产生的指令只关心“相对地址”，实际放入内存中时再想办法根据起始位置得到“绝对地址”。</p>
<p>eg：编译时只需要确定变量x存放的相对地址是100（也就是说相对进程在内存中的起始地址而言的地址）。CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。</p>
<p><strong>相对地址</strong>又称<strong>逻辑地址</strong>，<strong>绝对地址</strong>又称<strong>物理地址</strong>。</p>
<p><strong>从写程序到程序运行</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E4%BB%8E%E5%86%99%E7%A8%8B%E5%BA%8F%E5%88%B0%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C.png" alt="从写程序到程序运行"></p>
<p>编译：由编译程序将用户源码编译成若干个目标模块(编译就是把高级语言翻译为机器语言)</p>
<p>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块</p>
<p>装入(装载)：由装入程序将装入模块装入内存运行</p>
<h4 id="三种链接方式："><a href="#三种链接方式：" class="headerlink" title="三种链接方式："></a>三种链接方式：</h4><ul>
<li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件(装入模块)，之后不再拆开。</li>
<li>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式。</li>
<li>运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</li>
</ul>
<h4 id="三种装入方式："><a href="#三种装入方式：" class="headerlink" title="三种装入方式："></a>三种装入方式：</h4><p><strong>绝对装入</strong></p>
<p>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。</p>
<p>绝对装入<strong>只适合用于单道程序环境</strong>。程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时在转换为绝对地址。</p>
<p><strong>静态重定位</strong></p>
<p>又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时依次完成的）。</p>
<p>静态重定位的特点是在一个作业装入内存时，必须分配器要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</p>
<p><strong>动态重定位</strong></p>
<p>又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。</p>
<p>重定位寄存器：存放装入模块存放的起始位置。</p>
<p>采用动态重定位时允许程序在内存中发生移动。并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</p>
<h3 id="3-1-2-内存管理的概念"><a href="#3-1-2-内存管理的概念" class="headerlink" title="3.1.2 内存管理的概念"></a>3.1.2 内存管理的概念</h3><blockquote>
<p>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？</p>
</blockquote>
<h4 id="内存空间的分配与回收"><a href="#内存空间的分配与回收" class="headerlink" title="内存空间的分配与回收"></a>内存空间的分配与回收</h4><p>操作系统负责内存空间的分配与回收</p>
<h4 id="内存空间的扩展"><a href="#内存空间的扩展" class="headerlink" title="内存空间的扩展"></a>内存空间的扩展</h4><p>操作系统需要提供某种技术从逻辑上对<strong>内存空间进行扩充</strong></p>
<h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而<strong>逻辑地址到物理地址的转换</strong>(这个过程称为地址定位)应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。</p>
<h4 id="存储保护"><a href="#存储保护" class="headerlink" title="存储保护"></a>存储保护</h4><p>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。</p>
<p>方法一：</p>
<p>在CPU设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</p>
<p>方法二：采用<strong>重定位寄存器</strong>(又称<strong>基址寄存器</strong>)和<strong>界地址寄存器</strong>(又称<strong>限长寄存器</strong>)进行越界检查。重定位寄存器中存放的是进程的<strong>起始物理地址</strong>。界地址寄存器中存放的是进程的<strong>最大逻辑地址</strong>。</p>
<h3 id="3-1-3-覆盖与交换"><a href="#3-1-3-覆盖与交换" class="headerlink" title="3.1.3 覆盖与交换"></a>3.1.3 覆盖与交换</h3><h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><blockquote>
<p>早起的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常会出现内存大小不够的情况。后来人们引入了覆盖技术，用来解决“程序大小超过物理内存综合”的问题。</p>
</blockquote>
<p>覆盖技术的思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时掉入内存。</p>
<p>内存中分为一个“固定区”和若干个“覆盖区”。</p>
<p>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）</p>
<p>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF.png" alt="覆盖技术"></p>
<p>按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一个覆盖区。</p>
<p>缺点：必须由程序员声明覆盖结构，操作系统完成自动覆盖。对用户不透明，增加了用户编程负担。覆盖技术只用于早起的操作系统中，现在已成为历史。</p>
<h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><p>交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</p>
<p>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</p>
<p>暂时换出外存等待的进程状态为挂起状态（挂起态，suspend）</p>
<p>挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</p>
<ol>
<li><p>应该在外存（磁盘）的什么位置保存被换出的进程？</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4.png" alt="磁盘存储空间"></p>
<p> 具有对换功能的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分。文件区主要用于存放文件，<strong>主要追求存储空间的利用率</strong>，因此对文件区空间的管理<strong>采用离散分配方式</strong>；对换区空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理<strong>主要追求换入换出速度</strong>，因此通常对换区<strong>采用连续分配方式</strong>。总之，<strong>对换区的I&#x2F;O速度比文件区的更快</strong>。</p>
</li>
<li><p>什么时候应该交换？</p>
<p> 交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停，例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。</p>
</li>
<li><p>应该换出哪些进程？</p>
<p> 可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间……</p>
</li>
</ol>
<blockquote>
<p>Tip：PCB会常驻内存，不会被换出外存。</p>
</blockquote>
<h3 id="3-1-4-连续分配管理方式"><a href="#3-1-4-连续分配管理方式" class="headerlink" title="3.1.4 连续分配管理方式"></a>3.1.4 连续分配管理方式</h3><h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D.png" alt="单一连续分配"></p>
<p>在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。</p>
<p>内存中只能有一道用户程序，用户程序独占整个用户区空间。</p>
<p>优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早起的PC操作系统MS-DOS）。</p>
<p>缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。</p>
<h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D.png" alt="固定分区分配"></p>
<p>20世纪60年代出现了多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会互相干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p>
<p>固定分区分配与两种方式：</p>
<ul>
<li><p>分区大小相等</p>
<p>  缺乏灵活性，但是很适用于一台计算机控制多个相同对象的场合（比如：钢铁厂有n个相同的锻钢炉，就可以把内存分为n个大小相等的区域存放n个炼钢炉控制程序）</p>
</li>
<li><p>分区大小不等</p>
<p>  增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区、适量中等分区、少量大分区）</p>
</li>
</ul>
<p>操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表象对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。</p>
<table>
<thead>
<tr>
<th align="center">分区号</th>
<th align="center">大小（MB）</th>
<th align="center">起始地址（M）</th>
<th align="center">状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">8</td>
<td align="center">未分配</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">10</td>
<td align="center">未分配</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">12</td>
<td align="center">已分配</td>
</tr>
<tr>
<td align="center">……</td>
<td align="center">……</td>
<td align="center">……</td>
<td align="center">……</td>
</tr>
</tbody></table>
<p>当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。</p>
<p>优点：实现简单，无外部碎片。</p>
<p>缺点：</p>
<ul>
<li>当用户程序太大时，可能所有的分区都不满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能</li>
<li>会产生内部碎片，内存利用率低。</li>
</ul>
<h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p>动态分区又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg：假设某计算机内存大小为64MB，系统区8MB，用户区共56MB……）</p>
<ol>
<li><p>系统要用什么样的数据结构记录内存的使用情况？</p>
<p> 两种常用的数据结构：空闲分区表和空闲分区链。</p>
<table>
<thead>
<tr>
<th align="center">分区号</th>
<th align="center">大小（MB）</th>
<th align="center">起始地址（M）</th>
<th align="center">状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">20</td>
<td align="center">8</td>
<td align="center">空闲</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">10</td>
<td align="center">32</td>
<td align="center">空闲</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">64</td>
<td align="center">空闲</td>
</tr>
</tbody></table>
<p> 空闲分区表：每个空闲分区对应一个表项。表项中包含分区好、分区大小、分区起始地址等信息。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E7%A9%BA%E9%97%B2%E5%88%86%E5%8C%BA%E9%93%BE.png" alt="空闲分区链"></p>
<p> 空闲分区链：每个分区的起始部分和末尾部分分别设置向前指针和向后指针。起始部分处还可记录分区大小等信息。</p>
</li>
<li><p>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p>
<p> 把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。</p>
</li>
<li><p>如何进行分区的分配与回收操作？</p>
<ul>
<li><p>回收区的后面又一个相邻的空闲分区</p>
<p>  两个相邻的空闲分区合并为一个</p>
</li>
<li><p>回收区的前面有一个相邻的空闲分区</p>
<p>  两个相邻的空闲分区合并为一个</p>
</li>
<li><p>回收区前后各有一个相邻的空闲分区</p>
<p>  三个相邻的空闲分区合并为一个</p>
</li>
<li><p>回收区的前后都没有相邻的空闲分区</p>
<p>  新增一个表项</p>
<p>  各表项的顺序不一定按照地址递增顺序排序，具体的排序方式需要依据动态分区分配算法来确定。</p>
</li>
</ul>
<p> 动态分区分配没有内部碎片，但是有外部碎片。</p>
<p> 内部碎片：分配给某进程的内存区域中，如果有些部分没有用上。</p>
<p> 外部碎片：是指内存中的某些空闲分区由于太小而难以利用。</p>
<p> 如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片“不能满足进程的需求。</p>
<p> 可通过紧凑（拼凑，Compaction）技术来解决外部碎片。</p>
</li>
</ol>
<h3 id="3-1-5-动态分区分配算法"><a href="#3-1-5-动态分区分配算法" class="headerlink" title="3.1.5 动态分区分配算法"></a>3.1.5 动态分区分配算法</h3><h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</p>
<p>实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p>
<h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲去，即，优先使用更小的空闲去。</p>
<p>实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p>
<p>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。</p>
<h4 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h4><p>又称最大适应算法（Largest Fit）</p>
<p>算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p>
<p>实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p>
<p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后“大进程”到达，就没有内存分区可用了。</p>
<h4 id="临近适应算法"><a href="#临近适应算法" class="headerlink" title="临近适应算法"></a>临近适应算法</h4><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p>
<p>实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p>
<p>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）。</p>
<p>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）</p>
<h3 id="3-1-6-基本分页存储管理的基本概念"><a href="#3-1-6-基本分页存储管理的基本概念" class="headerlink" title="3.1.6 基本分页存储管理的基本概念"></a>3.1.6 基本分页存储管理的基本概念</h3><p><strong>把“固定分区分配”改造为“非连续分配版本”</strong></p>
<p>假设进程A大小为23MB，但是每个分区大小只有10MB，如果进程只能占用一个分区，那显然放不下。</p>
<p>解决思路：如果允许进程占用多个分区，那么可以把进程拆分成10MB+10MB+3MB三个部分，再把这三个部分分别放到三个分区中（这些分区不要求连续）……</p>
<p>进程A的最后一个部分是3MB，放入分区后会残生7MB的内部碎片。</p>
<p>如果每个分区大小为2MB，那么进程A可以拆分成11*2MB + 1MB共12个部分，只有最后一部分1MB占不满分区，会产生1MB的内部碎片。</p>
<p>显然，如果把分区大小设置得更小一些，内存碎片会更小，内存利用率会更高。</p>
<blockquote>
<p>基本分页存储的思想：把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分。</p>
</blockquote>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>将内存空间分为一个个大小相等的分区（比如：每个分区4KB），每个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“页框号”（或者“内存块号”、“页帧号”、“物理块号”）页框号从0开始。</p>
<p>将用户进程的地址空间也分为与页框大小相等的一个个区域，称为”页“或”页面“。每个页面也有一个编号，即”页号“，页号也是从0开始。</p>
<p>ps：进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片）</p>
<p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。</p>
<p>各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。</p>
<h4 id="如何实现地址的转换"><a href="#如何实现地址的转换" class="headerlink" title="如何实现地址的转换"></a>如何实现地址的转换</h4><p>将进程地址空间分页后，操作系统该如何实现逻辑地址到物理地址的转换？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="地址转换"></p>
<p>CPU执行指令1，需要访问逻辑地址为80的内存单元，如何转化为物理地址？</p>
<p>逻辑地址为80的内存单元：</p>
<p>应该在1号页，该页在内存中的起始位置为450，逻辑地址为80的内存单元相对于该页的起始地址而言，“偏移量”应该是30。实际物理地址 &#x3D; 450 + 30 &#x3D; 480</p>
<ol>
<li>要算出逻辑地址对应的页号</li>
<li>要知道该页号对应页面在内存中的起始地址</li>
<li>要算出逻辑地址在页面内的“偏移量”</li>
<li>物理地址 &#x3D; 页面地址 + 页内偏移量</li>
</ol>
<p>如何计算：</p>
<p>页号 &#x3D; 逻辑地址 &#x2F; 页面长度 （取除法的整数部分）</p>
<p>页内偏移量 &#x3D; 逻辑地址 % 页面长度 （取除法的余数部分）</p>
<p>页面在内存中的起始位置：操作系统需要某种数据结构记录进程各个页面的起始位置。</p>
<p>页号 &#x3D; 80 &#x2F; 50 &#x3D; 1</p>
<p>页内偏移量 &#x3D; 80 % 50 &#x3D; 30</p>
<p>1号页在内存中存放的起始位置450</p>
<p>为了方便计算页号、页内偏移量，页面大小一般设为2的整数幂</p>
<h4 id="如何知道该页号对应页面在内存中的起始地址"><a href="#如何知道该页号对应页面在内存中的起始地址" class="headerlink" title="如何知道该页号对应页面在内存中的起始地址"></a>如何知道该页号对应页面在内存中的起始地址</h4><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。</p>
<ol>
<li>一个进程对应一张页表</li>
<li>进程的每一页对应一个页表项</li>
<li>每个页表项由“页号”和“块号”组成</li>
<li>页表记录进程页面和实际存放的内存块之间的对应关系</li>
<li>每个页表项的长度是相同的，页号是“隐含“的</li>
</ol>
<h3 id="3-1-7基本地址变换机构"><a href="#3-1-7基本地址变换机构" class="headerlink" title="3.1.7基本地址变换机构"></a>3.1.7基本地址变换机构</h3><h4 id="页表寄存器的作用"><a href="#页表寄存器的作用" class="headerlink" title="页表寄存器的作用"></a>页表寄存器的作用</h4><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</p>
<p>通常会在系统中设置一个<strong>页表寄存器</strong>（PTR），存放<strong>页表在内存中的起始地址F</strong>和<strong>页表长度M</strong>。进程未执行时，页表的始值和页表长度<strong>放在进程控制块（PCB）</strong>中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p>
<p>ps：页面大小事2的整数幂。</p>
<h4 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B.png" alt="基本地址变换过程"></p>
<p>设页面大小为L，逻辑地址A到物理地址E的变换过程如下：</p>
<ol>
<li>计算页号P和页内偏移量W（如果用十进制数手算，则P&#x3D;A&#x2F;L，W&#x3D;A%L；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）</li>
<li>比较页号P和页表长度M，若P≥M，则产生越界中断，否则继续执行。（注意：页号是从0开始的，而页表长度至少为1，因此P&#x3D;M时也会越界）</li>
<li>页表中页号P对应的页表项地址 &#x3D; 页表起始地址F + 页号P * 页表项长度，取出该页表项内容b，即为内存块号。（注意区分页表项长度、页表长度、页面大小的区别。页表长度是指这个页表中总共有几个页表项，即总共有几个页；页表项长度指的是每个页表项占多大的存储空间；页面大小指的是一个页面占多大的存储空间）</li>
<li>计算E &#x3D; b * L + W，用得到的物理地址E去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）</li>
</ol>
<p>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显示地告诉系统这个逻辑地址中，页内偏移量占多少位。</p>
<h3 id="3-1-8-具有快表的地址变换机构"><a href="#3-1-8-具有快表的地址变换机构" class="headerlink" title="3.1.8 具有快表的地址变换机构"></a>3.1.8 具有快表的地址变换机构</h3><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）</p>
<p><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）</p>
<p>在基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。可以利用这个特性减少访问页表的次数。</p>
<h4 id="什么是快表（TLB）"><a href="#什么是快表（TLB）" class="headerlink" title="什么是快表（TLB）"></a>什么是快表（TLB）</h4><p>快表，又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E5%BF%AB%E8%A1%A8.png" alt="快表"></p>
<h4 id="引入快表后，地址的变换过程"><a href="#引入快表后，地址的变换过程" class="headerlink" title="引入快表后，地址的变换过程"></a>引入快表后，地址的变换过程</h4><ol>
<li>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</li>
<li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</li>
<li>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存。（注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</li>
</ol>
<p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。由于局部性原理，一般来说快表的命中率可以达到90%以上。</p>
<h3 id="3-1-9-两级页表"><a href="#3-1-9-两级页表" class="headerlink" title="3.1.9 两级页表"></a>3.1.9 两级页表</h3><h4 id="单级页表存在什么问题？"><a href="#单级页表存在什么问题？" class="headerlink" title="单级页表存在什么问题？"></a>单级页表存在什么问题？</h4><ul>
<li><p>页表必须连续存放，因此当页表很大时，需要占用多个连续的页框</p>
<p>  可将长长的页表进行分组，使某个内存块刚好可以放入一个分组（比如：页面大小4KB，每个页表项4B，每个页面可存放1K个页表项，因此每1K个连续的页表项为一组，每组刚好占一个内存块，再将各族离散地放到各个内存块中）</p>
<p>  另外，要为离散分配的页表再建立一张页表，成为页目录表，或称外层页表，或称顶层页表</p>
</li>
<li><p>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面</p>
</li>
</ul>
<h4 id="两级页表的原理、逻辑地址结构"><a href="#两级页表的原理、逻辑地址结构" class="headerlink" title="两级页表的原理、逻辑地址结构"></a>两级页表的原理、逻辑地址结构</h4><table>
<thead>
<tr>
<th align="center">31             ……            22</th>
<th align="center">21         ……       12</th>
<th align="center">11       ……       0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">一级页号</td>
<td align="center">二级页号</td>
<td align="center">页内偏移量</td>
</tr>
</tbody></table>
<p>10位一级页号刚好可表示0～1023</p>
<h4 id="如何实现地址变换？"><a href="#如何实现地址变换？" class="headerlink" title="如何实现地址变换？"></a>如何实现地址变换？</h4><p>例：将逻辑地址（0000000000, 0000000001, 111111111111）转换为物理地址（用十进制表示）。</p>
<ol>
<li>按照地址结构将逻辑地址拆分成三部分</li>
<li>从PCB中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置</li>
<li>根据二级页号查表，找到最终想访问的内存块号</li>
<li>结合页内偏移量得到物理地址</li>
</ol>
<h4 id="两级页表问题需要注意的几个细节"><a href="#两级页表问题需要注意的几个细节" class="headerlink" title="两级页表问题需要注意的几个细节"></a>两级页表问题需要注意的几个细节</h4><ol>
<li><p>若采用多级页表机制，则各级页表的大小不能超过一个页面</p>
</li>
<li><p>两级页表的访存次数分析（假设没有快表机构）</p>
<p> 第一次访存：访问内存中的页目录表</p>
<p> 第二次访存：访问内存中的二级页表</p>
<p> 第三次访存：访问目标内存单元</p>
</li>
</ol>
<h3 id="3-1-10-基本分段式存储管理方式"><a href="#3-1-10-基本分段式存储管理方式" class="headerlink" title="3.1.10 基本分段式存储管理方式"></a>3.1.10 基本分段式存储管理方式</h3><h4 id="什么是分段"><a href="#什么是分段" class="headerlink" title="什么是分段"></a>什么是分段</h4><p>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址</p>
<p>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E5%88%86%E6%AE%B5.png" alt="分段"></p>
<p>分段系统的逻辑地址就够由段号（段名）和段内地址（段内偏移量）所组成。如：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E5%88%86%E6%AE%B5%E7%B3%BB%E7%BB%9F%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%84%E6%88%90.png" alt="分段系统逻辑地址组成"></p>
<p>段号的位数决定了每个进程最多可以分几个段</p>
<p>段内地址位数决定了每个段的最大长度是多少</p>
<p>在上述例子中，若系统是按字节寻址的，则</p>
<p>段号占16位，因此在该系统中，每个进程最多有2<sup>16</sup> &#x3D; 64K个段</p>
<p>段内地址占16位，因此每个段的最大长度是2<sup>16</sup> &#x3D; 64KB。</p>
<h4 id="什么是段表"><a href="#什么是段表" class="headerlink" title="什么是段表"></a>什么是段表</h4><p>程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E6%AE%B5%E8%A1%A8.png" alt="段表"></p>
<ol>
<li>每个段对应一个段表项，其中记录了该段在内存中的起始位置（又称“基址”）和段的长度。</li>
<li>各个段表项的长度是相同的。例如：某系统按字节寻址，采用分段存储管理，逻辑地址结构为（段号16位，段内地址16位），因此用16位即可表示最大段长。物理内存大小为4GB（可用32位表示整个物理内存地址空间）。因此，可以让每个段表项占16+32&#x3D;48位，即6B。由于段表项长度相同，因此段号可以是隐含的，不占存储空间。若段表存放的起始地址位M，则K号段对应的段表项存放的地址为M+K*6</li>
</ol>
<h4 id="如何实现地址变换"><a href="#如何实现地址变换" class="headerlink" title="如何实现地址变换"></a>如何实现地址变换</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E6%AE%B5%E8%A1%A8%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="段表存储管理方式地址变换"></p>
<h4 id="分段、分页管理的对比"><a href="#分段、分页管理的对比" class="headerlink" title="分段、分页管理的对比"></a>分段、分页管理的对比</h4><p>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</p>
<p>段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显示地给出段名。</p>
<p>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</p>
<p>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。</p>
<p>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</p>
<p>分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）</p>
<p>访问一个逻辑地址需要几次访存？</p>
<p>分页（单级页表）：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共两次访存</p>
<p>分段：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共两次访存于分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表放到快表中，这样可以少访问，加快地址变化速度。</p>
<h3 id="3-1-11-段页式管理方式"><a href="#3-1-11-段页式管理方式" class="headerlink" title="3.1.11 段页式管理方式"></a>3.1.11 段页式管理方式</h3><h4 id="分页、分段管理方式中最大的优缺点"><a href="#分页、分段管理方式中最大的优缺点" class="headerlink" title="分页、分段管理方式中最大的优缺点"></a>分页、分段管理方式中最大的优缺点</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">分页管理</td>
<td align="center">内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</td>
<td align="center">不方便按照逻辑模块实现信息的共享和保护</td>
</tr>
<tr>
<td align="center">分段管理</td>
<td align="center">很方便按照逻辑模块实现信息的共享和保护</td>
<td align="center">如果段长过大，为其分配很大的连续空间会很不方便，另外段式管理会产生外部碎片</td>
</tr>
</tbody></table>
<h4 id="分段-分页的结合——段页式管理方式"><a href="#分段-分页的结合——段页式管理方式" class="headerlink" title="分段+分页的结合——段页式管理方式"></a>分段+分页的结合——段页式管理方式</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86.png" alt="段页式管理"></p>
<p>将进程按逻辑模块分段，再将各段分页（如每个页面4KB）再将内存空间分为大小相同的内存块&#x2F;页框&#x2F;页帧&#x2F;物理块进程前将各页面分别装入内存块中。</p>
<p>分段系统的逻辑地址结构由段号和段内地址（段内偏移量）组成，如：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E5%88%86%E5%BA%A6%E7%B3%BB%E7%BB%9F%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png" alt="分度系统逻辑地址结构"></p>
<p>段页式系统的逻辑地址结构由段号、页号、页内地址（页内偏移量）组成，如：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png" alt="段页式系统地址结构"></p>
<blockquote>
<p>“分段”是对用户可见的，程序员编程时需要显示地给出段号、段内地址。而将各段“分页”对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此<strong>段页式管理地址结构是二维的</strong>。</p>
</blockquote>
<p>段号的位数决定了每个进程最多可以分为几个段</p>
<p>页号位数决定了每个段最大有多少页</p>
<p>页内偏移量决定了页面大小、内存块大小是多少</p>
<p>在上述例子中，若系统是按字节寻址的，则</p>
<p>段号占16位，因此在该系统中，每个进程最多有2<sup>16</sup> &#x3D; 64K个段</p>
<p>页号占4位，因此每个段最多有2<sup>4</sup> &#x3D; 16页</p>
<p>页内偏移量占12位，因此每个页面\每个内存块大小为2<sup>12</sup> &#x3D; 4096 &#x3D;4KB</p>
<h4 id="段表、页表"><a href="#段表、页表" class="headerlink" title="段表、页表"></a>段表、页表</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E6%AE%B5%E8%A1%A8%E6%AE%B5%E9%A1%B5.png" alt="段表段页"></p>
<p>每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成。每个段表项长度相等，段号是隐含的。</p>
<p>每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。</p>
<h4 id="如何实现地址变换-1"><a href="#如何实现地址变换-1" class="headerlink" title="如何实现地址变换"></a>如何实现地址变换</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="段页式管理地址变换"></p>
<h3 id="3-2-1-虚拟内存的基本概念"><a href="#3-2-1-虚拟内存的基本概念" class="headerlink" title="3.2.1 虚拟内存的基本概念"></a>3.2.1 虚拟内存的基本概念</h3><h4 id="传统存储管理方式的特征、缺点"><a href="#传统存储管理方式的特征、缺点" class="headerlink" title="传统存储管理方式的特征、缺点"></a>传统存储管理方式的特征、缺点</h4><p>传统存储管理（很多暂时用不到的数据也会长期占用内存，导致内存利用率不高）</p>
<ul>
<li>连续分配<ul>
<li>单一连续分配</li>
<li>固定分区分配</li>
<li>动态分区分配</li>
</ul>
</li>
<li>非连续分配<ul>
<li>基本分页存储管理</li>
<li>基本分段存储管理</li>
<li>基本段页式存储管理</li>
</ul>
</li>
</ul>
<p>一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：1. 作业很大时，不能全部装入内存，导致大作业无法运行；2. 当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。</p>
<p>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</p>
<h4 id="局部性原理-1"><a href="#局部性原理-1" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）</p>
<p>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="计算机中存储器的层次结构"></p>
<p>快表机构就是将近期常访问的页表项副本放到更高速的联想寄存器中</p>
<p>高速缓冲技术的思想：将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中。</p>
<h4 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="计算机中存储器的层次结构"></p>
<p>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。</p>
<p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。</p>
<p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p>
<p>在操作系统的管理下，在用户看来似乎有一个比实际内存大的多的内存，这就是虚拟内存。</p>
<blockquote>
<p>操作系统虚拟性的一个体现，实际的物理内存大小没有变，知识在逻辑上进行了扩充。</p>
</blockquote>
<p>虚拟内存有以下三个主要特征：</p>
<p>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</p>
<p>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入换出。</p>
<p>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</p>
<h4 id="如何实现虚拟内存技术"><a href="#如何实现虚拟内存技术" class="headerlink" title="如何实现虚拟内存技术"></a>如何实现虚拟内存技术</h4><p>虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在离散分配的内存管理方式基础上。</p>
<p>虚拟内存的实现：</p>
<ul>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ul>
<p>传统的非连续分配存储管理和虚拟内存技术的主要区别：</p>
<p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。（操作系统要提供请求调页或请求调段功能）</p>
<p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。（操作系统要提供页面置换或段置换的功能）</p>
<h3 id="3-2-2-请求分页管理方式"><a href="#3-2-2-请求分页管理方式" class="headerlink" title="3.2.2 请求分页管理方式"></a>3.2.2 请求分页管理方式</h3><h4 id="请求分页存储管理与基本分页存储管理的主要区别："><a href="#请求分页存储管理与基本分页存储管理的主要区别：" class="headerlink" title="请求分页存储管理与基本分页存储管理的主要区别："></a>请求分页存储管理与基本分页存储管理的主要区别：</h4><h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h4><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需要知道该页面在外存中存放的位置。</p>
<p>当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面：有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6.png" alt="页表机制"></p>
<h4 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h4><p>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。</p>
<p>此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。</p>
<p>如何内存有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。</p>
<p>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</p>
<p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。</p>
<p>一条指令在执行期间，可能产生多次缺页中断。</p>
<h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p>请求分页存储管理与基本分页存储管理的主要区别：</p>
<p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。</p>
<p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png" alt="地址变换机构"></p>
<h3 id="3-2-3-页面置换算法"><a href="#3-2-3-页面置换算法" class="headerlink" title="3.2.3 页面置换算法"></a>3.2.3 页面置换算法</h3><h4 id="最佳置换算法OPT"><a href="#最佳置换算法OPT" class="headerlink" title="最佳置换算法OPT"></a>最佳置换算法OPT</h4><p>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。</p>
<p>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。</p>
<h4 id="先进先出置换算法FIFO"><a href="#先进先出置换算法FIFO" class="headerlink" title="先进先出置换算法FIFO"></a>先进先出置换算法FIFO</h4><p>每次选择淘汰的页面是最早进入内存的页面</p>
<p>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择对头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。</p>
<p>Belady异常——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p>
<p>只有IFO算法会产生Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差</p>
<h4 id="最近最久未使用置换算法LRU"><a href="#最近最久未使用置换算法LRU" class="headerlink" title="最近最久未使用置换算法LRU"></a>最近最久未使用置换算法LRU</h4><p>每次淘汰的页面是最近最久未使用的页面</p>
<p>实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/LRU.png" alt="LRU"></p>
<h4 id="时钟置换算法CLOCK"><a href="#时钟置换算法CLOCK" class="headerlink" title="时钟置换算法CLOCK"></a>时钟置换算法CLOCK</h4><p>最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法。</p>
<p>简单的CLOCK算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过连接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位置依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/CLOCK.png" alt="CLOCK"></p>
<h4 id="改进型的时钟置换算法"><a href="#改进型的时钟置换算法" class="headerlink" title="改进型的时钟置换算法"></a>改进型的时钟置换算法</h4><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I&#x2F;O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</p>
<p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I&#x2F;O操作。这就是改进型的时钟置换算法的思想。</p>
<p>修改位&#x3D;0，表示页面没有被修改过；修改位&#x3D;1，表示页面被修改过。</p>
<p>为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1，1）表示一个页面近期被访问过，且被修改过。</p>
<p>算法规则：将所有可能被置换的页面排成一个循环队列</p>
<p>第一轮：从当前位置开始扫描到第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位。</p>
<p>第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的帧访问位设为0.</p>
<p>第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位。</p>
<p>第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。</p>
<p>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描。</p>
<p><strong>四种页面置换算法比较</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E5%9B%9B%E7%A7%8D%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.png" alt="四种页面置换算法比较"></p>
<h3 id="3-2-4-页面分配策略"><a href="#3-2-4-页面分配策略" class="headerlink" title="3.2.4 页面分配策略"></a>3.2.4 页面分配策略</h3><h4 id="页面分配、置换策略"><a href="#页面分配、置换策略" class="headerlink" title="页面分配、置换策略"></a>页面分配、置换策略</h4><p><strong>驻留集：</strong>指请求分页存储管理中给进程分配的物理块的集合。</p>
<p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。</p>
<p>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于即成推进的时间很少；驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。</p>
<p><strong>固定分配：</strong>操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变。</p>
<p><strong>可变分配：</strong>先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变。</p>
<p><strong>局部置换：</strong>发生缺页时只能选进程自己的物理块进行置换。</p>
<p><strong>全局置换：</strong>可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</p>
<p><strong>固定分配局部置换：</strong>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。（采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）</p>
<p><strong>可变分配全剧置换：</strong>刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。</p>
<p><strong>可变分配局部置换：</strong>刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</p>
<p>可变分配全剧置换：只要缺页就给分配新物理块</p>
<p>可变分配局部置换：要根据发生缺页的频率来动态地增加或减少进程的物理块</p>
<h4 id="调入页面的时机"><a href="#调入页面的时机" class="headerlink" title="调入页面的时机"></a>调入页面的时机</h4><ol>
<li>预调页策略：根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要用于进程的首次调入，由程序员指出应该先调入哪些部分。</li>
<li>请求调页策略：进程在运行期间发现缺页时才将所缺页调入内存。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I&#x2F;O操作，因此I&#x2F;O开销比较大。</li>
</ol>
<h4 id="从何处调页"><a href="#从何处调页" class="headerlink" title="从何处调页"></a>从何处调页</h4><ol>
<li>系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。</li>
<li>系统缺少足够的对换区空间：凡事不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需要写回磁盘对换区，下次需要时再从对换区调入。</li>
<li>UNIX方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</li>
</ol>
<h4 id="抖动（颠簸）现象"><a href="#抖动（颠簸）现象" class="headerlink" title="抖动（颠簸）现象"></a>抖动（颠簸）现象</h4><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）。</p>
<blockquote>
<p>为进程分配的物理块太少，会使即成发生动都现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率</p>
</blockquote>
<h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><p>驻留集：指请求分页存储管理中给进程分配的内存块的集合</p>
<p>工作集：指在某段时间间隔里，进程实际访问页面的集合</p>
<p>操作系统会根据“窗口尺寸”来算出工作集。</p>
<p>工作集太小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若个内存块。如：窗口尺寸为5，经过一段时间的检测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。一般来说，<strong>驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页。</strong></p>
<blockquote>
<p>基于局部性原理克制，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。因此，可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法——选择一个不在工作集中的页面进行淘汰。</p>
</blockquote>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="4-1-1-初识文件管理"><a href="#4-1-1-初识文件管理" class="headerlink" title="4.1.1 初识文件管理"></a>4.1.1 初识文件管理</h3><p><strong>文件的定义</strong>：一组有意义的信息的集合</p>
<h4 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h4><ul>
<li><p>文件名</p>
<p>  由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件。</p>
</li>
<li><p>标识符</p>
<p>  一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</p>
</li>
<li><p>类型</p>
<p>  指明文件的类型</p>
</li>
<li><p>位置</p>
<p>  文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</p>
</li>
<li><p>大小</p>
<p>  指明文件大小</p>
</li>
<li><p>创建时间、上次修改时间</p>
</li>
<li><p>文件所有者信息</p>
</li>
<li><p>保护信息</p>
<p>  对文件进行保护的访问控制信息</p>
</li>
</ul>
<h4 id="文件内部的数据应该怎样组织起来？"><a href="#文件内部的数据应该怎样组织起来？" class="headerlink" title="文件内部的数据应该怎样组织起来？"></a>文件内部的数据应该怎样组织起来？</h4><p>无结构文件：如文本文件。由一些二进制或字符流组成，又称“流式文件”</p>
<p>有结构文件：如数据库表。由一组相似的记录组成，又称“记录式文件”。记录是一组相关数据项的集合。</p>
<blockquote>
<p>数据项式文件系统中最基本的数据单位</p>
</blockquote>
<h4 id="文件内部的数据应该怎样组织起来？-1"><a href="#文件内部的数据应该怎样组织起来？-1" class="headerlink" title="文件内部的数据应该怎样组织起来？"></a>文件内部的数据应该怎样组织起来？</h4><p>文件的逻辑结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="文件结构"></p>
<h4 id="文件之间应该怎样组织起来？"><a href="#文件之间应该怎样组织起来？" class="headerlink" title="文件之间应该怎样组织起来？"></a>文件之间应该怎样组织起来？</h4><p>目录结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E6%96%87%E4%BB%B6%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.png" alt="文件逻辑结构"></p>
<p>用户可以自己创建一层一层的目录，各层目录中存放相应的文件。系统中的各个文件就通过一层一层的目录合理有序的组织起来。</p>
<p>目录其实也是一种特殊的有结构文件（由记录组成）。所谓的“目录”其实就是我们熟悉的“文件夹”。</p>
<h4 id="操作系统应该向上提供哪些功能？"><a href="#操作系统应该向上提供哪些功能？" class="headerlink" title="操作系统应该向上提供哪些功能？"></a>操作系统应该向上提供哪些功能？</h4><p>可以“<strong>创建文件</strong>”，新建后，图形化交互进程在背后调用了“<strong>create系统调用”</strong>。</p>
<p>可以“<strong>读文件</strong>”，将文件数据读入内存，才能让CPU处理（“记事本”应用程序通过操作系统提供的“读文件”功能，即<strong>read系统调用</strong>，将文件数据从外存读入内存，并显示在屏幕上）</p>
<p>可以“写文件”，将更改过的文件数据写回外存（“记事本”应用程序中编辑文件内容，点击“保存”后，“记事本”应用程序通过操作系统提供的“<strong>写文件</strong>”功能，即<strong>write系统调用</strong>，将文件数据从内存写回外存）</p>
<p>可以“<strong>删除文件</strong>”（点了“删除”之后，图形化交互进程通过操作系统提供的“<strong>删除文件</strong>”功能，即<strong>delete系统调用</strong>，将文件数据从外存中删除）</p>
<p>向上提供的几个最基本的功能：</p>
<ul>
<li>创建文件，create系统调用</li>
<li>删除文件，delete系统调用</li>
<li>读文件，read系统调用</li>
<li>写文件，write系统调用</li>
<li>打开文件，open系统调用。读&#x2F;写文件之前，需要“打开文件”。</li>
<li>关闭文件，close系统调用。读&#x2F;写文件结束之后，需要“关闭文件”。</li>
</ul>
<blockquote>
<p>可用几个基本操作完成更复杂的操作，比如：“文件复制”：先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中。</p>
</blockquote>
<h4 id="文件应该如何存放在外存？"><a href="#文件应该如何存放在外存？" class="headerlink" title="文件应该如何存放在外存？"></a>文件应该如何存放在外存？</h4><p>与内存一样，外存也是由一个个存储单元组成的，每个存储单元可以存储一定量的数据。每个存储单元对应一个物理地址。</p>
<p>类似于内存分为一个个“内存块”，外存会分为一个个“块&#x2F;磁盘块&#x2F;物理块”。每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址。同样类似的事，文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转换为外存的物理地址（物理块号，块内地址）的形式。块内地址的位数取决于磁盘块的大小。</p>
<p>操作系统以“块”为单位为文件分配存储空间，因此即使一个文件大小只有10B，但它依然需要占用1KB的磁盘块。外存中的数据读入内存时同样以块为单位。</p>
<h3 id="4-1-2-文件的逻辑结构"><a href="#4-1-2-文件的逻辑结构" class="headerlink" title="4.1.2 文件的逻辑结构"></a>4.1.2 文件的逻辑结构</h3><blockquote>
<p>所谓的“逻辑结构”，就是指在用户看来，文件内部的数据应该是如何组织起来的。而“物理结构”指的是在操作系统看来，文件的数据是如何放在外存中的。</p>
</blockquote>
<p>按文件是否有结构分类，可以分为无结构文件、有结构文件两种。</p>
<h4 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h4><p><strong>无结构文件</strong>：文件内部的数据就是一系列二进制流或字符流组成。又称“<strong>流式文件</strong>”。</p>
<p>如windows操作系统中的.txt文件。文件内部的数据其实就是一系列字符流，没有明显的结构特性。因此也不用探讨无结构文件的“逻辑结构”问题。</p>
<h4 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h4><p><strong>有结构文件</strong>：由一组相似的记录组成，又称“<strong>记录式文件</strong>”。每条记录由若干个数据项组成。如：数据库表文件。一般来说，每条记录有一个数据项可作为<strong>关键字</strong>。根据各条记录的长度（占用的存储空间）是否相等，又可分为<strong>定长记录</strong>和<strong>可变长记录</strong>两种。</p>
<p>根据有结构文件中的各条记录在逻辑上如何组织，可以分为三类：</p>
<ul>
<li><p>顺序文件</p>
<p>  文件中的记录一个接一个顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。</p>
<p>  顺序存储：逻辑上相邻的记录物理上也相邻（类似于顺序表）。可变长记录无法实现随机存取。每次只能从第一个记录开始依次往后查找。定长记录可实现随机存取。记录长度为L，则第i个记录存放的相对位置是i*L；若采用串结构，无法快速找到某关键字对应的记录；若采用顺序结构，可以快速找到关键字对应的记录（如折半查找）</p>
<p>  链式存储：逻辑上相邻的记录物理上不一定相邻（类似于链表）。无论是定长&#x2F;可变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找</p>
</li>
<li><p>索引文件</p>
<p>  缺点：每个记录对应一个索引表项，因此索引表可能会很大。比如：文件的每个记录平均只占8B，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了。</p>
</li>
<li><p>索引顺序文件</p>
<p>  索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是<strong>一组记录对应一个索引表项</strong>。</p>
<p>  索引顺序文件的索引项也不需要按关键字顺序排列，这样可以极大地方便新表项的插入。</p>
<p>  为了进一步提高检索效率，可以为顺序文件建立多极索引表。</p>
</li>
</ul>
<h3 id="4-1-3-文件目录"><a href="#4-1-3-文件目录" class="headerlink" title="4.1.3 文件目录"></a>4.1.3 文件目录</h3><h4 id="文件目录的实现"><a href="#文件目录的实现" class="headerlink" title="文件目录的实现"></a>文件目录的实现</h4><p><strong>文件控制块</strong></p>
<p>目录文件中的一条记录就是一个“文件控制块（FCB）“</p>
<p>FCB的有序集合称为”文件目录“，一个FC B就是一个文件目录项。</p>
<p>FCB中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读&#x2F;可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）</p>
<p>最重要，最基本还是文件名、文件存放的物理地址。（FCB实现了文件名和文件之间的映射。使用户（用户程序）可以实现“按名存取”）</p>
<p>需要对目录进行哪些操作？</p>
<p>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</p>
<p>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项</p>
<p>删除文件：当删除一个文件时，需要在目录中删除相应的目录项</p>
<p>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</p>
<p>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文件重命名）</p>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p><strong>单级目录结构</strong></p>
<p>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项。</p>
<p>单级目录实现了“按名存取“，但是不允许文件重名。在创建文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中。</p>
<p>显然，单级目录结构不适用于多用户操作系统</p>
<p><strong>两级目录结构</strong></p>
<p>早起的多用户操作系统，采用两级目录结构。分为主文件目录（MFD，Master File Directory）和用户文件目录（UFD，User File Directory）。</p>
<p>主文件目录记录用户名及相应用户文件目录的存放位置。</p>
<p>用户文件目录由该用户的文件FCB组成。</p>
<p>两级目录结构允许不同用户的文件重名，也可以在目录上实现访问限制（检查此时登录的用户名是否匹配）。但是两级目录结构依然缺乏灵活性，用户不能对自己的文件进行分类。</p>
<p><strong>多级目录结构</strong></p>
<p>又称树形目录结构。</p>
<p>用户或用户进程要访问某个文件时，要用文件路径名标识文件，文件路径名是个字符串。各级目录之间用“&#x2F;”隔开。从根目录出发的路径称为绝对路径。</p>
<p>例如：自拍.png的绝对路径是“&#x2F;照片&#x2F;2022-07&#x2F;自拍.png“</p>
<p>系统根据绝对路径一层一层地找到下一级目录。刚开始从外存读入根目录的目录表；找到”照片”目录的存放位置后，从外存读入对应的目录表；再找到“2022-07”目录的存放位置，再从外存读入对应目录表；最后才找到文件“自拍.png“的存放位置。整个过程需要3次读磁盘I&#x2F;O操作。</p>
<p>很多时候，用户会连续访问同一目录内的多个问津啊（比如：接连查看”2022-07“目录内的多个照片文件），显然，每次都从根目录开始查找，是很低效的。因此可以设置一个”当前目录“。例如，此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为“当前目录”。当用户想要访问某个文件时，可以使用从当前目录出发的“相对路径”。</p>
<p>在linux中，“**.**”表示当前目录，因此如果“照片”是当前目录，则“自拍.png”的相对路径为：“.&#x2F;2022-07&#x2F;自拍.png“。从当前路径出发，只需要查询内存中的”照片“目录表，即可知道”2022-07“目录表的存放位置，从外存调入该目录，即可知道”自拍.png“存放的位置了。</p>
<p>可见，引入”当前目录“和”相对路径“后，磁盘I&#x2F;O的次数减少了。这就提升了访问文件的效率。</p>
<p>树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构”。</p>
<p><strong>无环图目录结构</strong></p>
<p>在树形目录结构的基础上，增加一些指向同一节点的有向边，使整个目录称为一个有向无环图。可以更方便地实现多个用户间的文件共享。</p>
<p><strong>可以用不同的文件名只想同一个文件</strong>，甚至可以指向同一个目录（共享同一目录下的所有内容）。</p>
<p>需要为<strong>每个共享结点设置一个共享计数器</strong>，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的PCB、并使<strong>共享计数器减1</strong>，并不会直接删除共享结点。<strong>只有共享计数器减为0时，才删除结点。</strong></p>
<p>注意：共享文件不同于复制文件。在<strong>共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。</strong></p>
<h4 id="索引结点"><a href="#索引结点" class="headerlink" title="索引结点"></a>索引结点</h4><p>其实在查找各级目录的过程中，只需要用到“文件名”这个信息，只有文件名匹配时，才需要读出文件的其他信息。因此可以考虑让目录表“瘦身”来提升效率。</p>
<p>这样做有什么好处？</p>
<p>假设一个FCB是64B，磁盘块的大小为1KB，则每个磁盘块中只能存放16个FCB。若一个文件目录中共有640个目录项，则共需要占用640&#x2F;16&#x3D;40个盘块。因此按照某文件名检索该目录，平均需要查询320个目录项，平均需要启动磁盘（每次磁盘I&#x2F;O读入一块）。</p>
<p>若使用索引结点机制，文件名占14B，索引结点指针占2B，则每个盘块可存放64个目录项，那么按文件名检索目录平均只需要读入320&#x2F;64&#x3D;5个磁盘块。显然，这将大大提升文件检索速度。</p>
<p>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。</p>
<p>存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”。</p>
<p>相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件等。</p>
<h3 id="4-1-4-文件的物理结构"><a href="#4-1-4-文件的物理结构" class="headerlink" title="4.1.4 文件的物理结构"></a>4.1.4 文件的物理结构</h3><h4 id="文件块、磁盘块"><a href="#文件块、磁盘块" class="headerlink" title="文件块、磁盘块"></a>文件块、磁盘块</h4><p>类似于内存分页，磁盘中的存储单元也会被分为一个个“块&#x2F;磁盘块&#x2F;物理块”。很多操作系统中，<strong>磁盘块的大小与内存块、页面的大小相同。</strong></p>
<p>内存与磁盘之间的数据交换（即读&#x2F;写操作、磁盘I&#x2F;O）都是以“块”为单位进行的。即每次读入一块，或每次写出一块。</p>
<p>在内存管理中，进程的逻辑地址空间被分为一个一个页面</p>
<p>同样的，在外存管理中，为了方便对文件数据的姑那里，文件的逻辑地址空间也被分为了一个一个的文件“块”。</p>
<p>于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式。</p>
<p>操作系统为文件分配存储空间都是以块为单位的。</p>
<p>用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射。</p>
<h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>连续分配方式要求每个文件在磁盘上占有一组连续的块。</p>
<blockquote>
<p>用户通过逻辑地址来操作自己的文件，操作系统如何实现从逻辑地址到物理地址的映射？</p>
</blockquote>
<p>（逻辑块号，块内地址）-&gt;（物理块号，块内地址）。只需转换块号就行，块内地址保持不变</p>
<p>用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项FCB……</p>
<p>物理块号 &#x3D; 起始块号 + 逻辑块号</p>
<p>当然，还需要检查用户提供的逻辑块号是否合法（逻辑块号 ≥ 长度 就不合法）。可以直接算出逻辑块号对应的物理块号，因此连续分配支持顺序访问和直接访问（即随机访问）。</p>
<p>读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。</p>
<p>结论：</p>
<p><strong>连续分配的文件在顺序读&#x2F;写时速度最快</strong></p>
<p>物理上采用<strong>连续分配的文件不方便拓展</strong></p>
<p>物理上采用<strong>连续分配，存储空间利用率低，会产生难以利用的磁盘碎片</strong>，可以用紧凑来处理碎片，但是需要耗费很大的时间代价。</p>
<p>优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快</p>
<p>缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片</p>
<h4 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h4><p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显示链接两种。</p>
<p><strong>隐式链接</strong></p>
<blockquote>
<p>如何实现文件的逻辑块号到物理块号的转变？</p>
</blockquote>
<p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项FCB……</p>
<p>从目录项中找到起始块号（即0号块），将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，再找到2号逻辑块的存放位置……以此类推。</p>
<p>因此，读入i号逻辑块，总共需要i+1次磁盘I&#x2F;O。</p>
<p>结论：采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查找效率低。另外，指向下一个盘块的指针页需要耗费少量的存储空间。采用隐式链接的链接分配方式，很方便文件拓展。另外，所有的的空闲磁盘块都可以被利用，不会有碎片问题，外存利用率高。</p>
<p>隐式链接——除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。</p>
<p>优点：很方便文件拓展，不会有碎片问题，外存利用率高。</p>
<p>缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</p>
<p><strong>显式链接</strong></p>
<p>把用于链接文件各物理块的指针显示地存放在一张表中。即文件分配表（FAT，File Allocation Table）。</p>
<p>假设某个新创建的文件“aaa“一次存放在磁盘块2 -&gt; 5 -&gt; 0 -&gt; 1，在目录中只需记录文件的起始块号。</p>
<p>注意：一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存。FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以时隐含的。</p>
<blockquote>
<p>如何实现文件的逻辑块号到物理块号的转变？</p>
</blockquote>
<p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项FCB……</p>
<p>从目录项中国呢找到起始块号，若i&gt;0，则查询内存中的文件分配表FAT，往后找到i号逻辑块对应的物理块号。<strong>逻辑块号转换成物理块号的过程不需要读磁盘操作。</strong></p>
<p>结论：采用<strong>链式分配（显式链接）</strong>方式的文件，支持顺序访问，也<strong>支持随机访问（想访问i号逻辑块时，并不需要依次访问之前的0～i-1号逻辑块）</strong>，由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。</p>
<p>显然，显式链接也<strong>不会产生外部碎片，也可以很方便地对文件进行拓展。</strong></p>
<p>显示链接——把用于链接文件各物理块的指针显示地存放在一张表中，即<strong>文件分配表</strong>（FAT，File Allocation Table）。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。</p>
<p>优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</p>
<p>缺点：文件分配表的需要占用一定的存储空间。</p>
<h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><p>索引分配允许文件离散地分配在各个磁盘块中，系统会<strong>为每个文件建立一张索引表</strong>，索引表中记录了文件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系）。索引表存放的磁盘块称为<strong>索引块</strong>。文件数据存放的磁盘块称为<strong>数据块</strong>。</p>
<p>假设某个新创建的文件“aaa”的数据一次存放在磁盘块2 -&gt; 5 -&gt; 13 -&gt; 9。7号磁盘块作为“aaa”的索引块，索引块中保存了索引表的内容。</p>
<p>注：在显式链接的链式分配方式中，文件分配表FAT是一个磁盘对应一张。而索引分配方式中，索引表是一个文件对应一张。</p>
<p>可以用固定的长度表示物理块号（如：假设磁盘总容量为1TB&#x3D;2<sup>40</sup>B，磁盘块大小为1KB，则共有2<sup>30</sup>个磁盘块，则可用4B表示磁盘块号），因此，索引表中的“逻辑块号”可以是隐含的。</p>
<p>目录中需要记录文件的索引块是极好磁盘块。</p>
<blockquote>
<p>如何实现文件的逻辑块号到物理块号的转换？</p>
</blockquote>
<p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项FCB……</p>
<p>从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可指i号逻辑块在外存中的存放位置。</p>
<p>可见，索引分配方式可以支持随机访问。文件拓展也很容易实现（只需要给文件分配一个空闲块，并增加了一个索引表项即可）但是索引表需要占用一定的存储空间</p>
<blockquote>
<p>如果一个文件的大小超过了256块，那么一个磁盘块是装不下文件的整张索引表的，如何解决这个问题？</p>
</blockquote>
<ol>
<li><p>链接方案</p>
<p> 如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</p>
</li>
<li><p>多层索引</p>
<p> 建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。</p>
</li>
<li><p>混合索引</p>
<p> 多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表）。</p>
<p> 优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少。</p>
</li>
</ol>
<h3 id="4-1-5-文件存储空间管理"><a href="#4-1-5-文件存储空间管理" class="headerlink" title="4.1.5 文件存储空间管理"></a>4.1.5 文件存储空间管理</h3><h4 id="存储空间的划分与初始化"><a href="#存储空间的划分与初始化" class="headerlink" title="存储空间的划分与初始化"></a>存储空间的划分与初始化</h4><p>存储空间的划分：将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘）。如：安装Windows操作系统的时候，一个必经步骤是——为磁盘分区（C:盘、D:盘、E:盘等）。有的系统支持超大型文件，可支持由多个物理磁盘组成一个文件卷。</p>
<p>存储空间的初始化：将各个文件卷划分为目录区、文件区。目录区主要存放文件目录信息FCB、用于磁盘存储空间管理的信息。文件区用于存放文件数据。</p>
<h4 id="几种管理方法"><a href="#几种管理方法" class="headerlink" title="几种管理方法"></a>几种管理方法</h4><p><strong>空闲表法</strong></p>
<p>如何分配磁盘块：与内存管理中的动态分区分配很类似，为一个文件<strong>分配连续的存储空间</strong>。同样<strong>可采用首次适应、最佳适应、最坏适应等算法</strong>来决定要为文件分配哪个区间。</p>
<p>如何回收磁盘块：与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况——1.回收区的前后都没有相邻空闲区；2.回收区的前后都是空闲区；3.回收区前面是空闲区；4.回收区后面是空闲区。<strong>总之，回收时需要注意表项的合并问题。</strong></p>
<p><strong>空闲链表法</strong></p>
<ul>
<li><p>空闲盘块链</p>
<p>  以盘块为单位组成一条空闲链。空闲盘块中存储这下一个空闲盘块的指针。操作系统中保存着链头、链尾指针。</p>
<p>  如何分配：若某文件申请K个盘块，则从链头开始一次摘下K个盘块分配，并修改空闲链的链头指针。</p>
<p>  如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</p>
</li>
<li><p>空闲盘区链</p>
<p>  以盘区为单位组成一条空闲链。空闲盘区中的第一个盘块内记录了盘区的长度、下一个盘区的指针。连续的空闲盘块组成一个空闲盘区。</p>
<p>  如何分配：若某文件申请k个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。</p>
<p>  如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有喝任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</p>
</li>
</ul>
<p><strong>位示图法</strong></p>
<p>位示图：每个二进制对应一个盘块。位示图一般用连续的“字”来表示，如一个字的字长是16位，字中的每一位对应一个盘块。因此可以用（字号，位号）对应一个盘块号。当然有的题目中也描述为（行号，列号）</p>
<p>（字号，位号）&#x3D;（i，j）的二进制位对应的盘块号b &#x3D; ni + j</p>
<p>b号盘块对应的字号i &#x3D; b &#x2F; n，位号j &#x3D; b % n	</p>
<p>如何分配：若文件需要k个块，1.顺序扫描位示图，找到k个相邻或不相邻的“0”；2.根据字号、位号算出对应的盘块号，将相应盘块分配给文件；3.将相应位设置为“1”。</p>
<p>如何回收：1.根据回收的盘块号计算出对应的字号、位号；2.将相应二进制位设为“0”</p>
<p><strong>成组链接法</strong></p>
<p>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX系统中采用了成组链接法对磁盘空闲块进行管理。</p>
<p>文件卷的目录区中专门用一个磁盘块作为“超级块“，当系统启动时需要将超级块读入内存。并且要保证内存与外存中的”超级块“数据一致。</p>
<h3 id="4-1-6-文件的基本操作"><a href="#4-1-6-文件的基本操作" class="headerlink" title="4.1.6 文件的基本操作"></a>4.1.6 文件的基本操作</h3><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><p>进行Create系统调用时，需要提供的几个主要参数：</p>
<ol>
<li>所需的外存空间大小</li>
<li>文件存放路径</li>
<li>文件名</li>
</ol>
<p>操作系统在处理create系统调用时，主要做了两件事：</p>
<ol>
<li>在外存中找到文件所需的空间</li>
<li>根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息。</li>
</ol>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>进行Delete系统调用时，需要提供的几个主要参数：</p>
<ol>
<li>文件存放路径</li>
<li>文件名</li>
</ol>
<p>操作系统在处理Delete系统调用时，主要做了几件事：</p>
<ol>
<li>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项。</li>
<li>根据该目录项纪录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块。</li>
<li>从目录表中删除文件对应的目录项。</li>
</ol>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>进程使用read系统调用完成操作。需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明读入多少数据、指明读入的数据要放在内存中的什么位置。</p>
<p>操作系统在处理read系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</p>
<h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>进程使用write系统调用完成操作，需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要写出多少数据、写回外存的数据放在内存中的什么位置。</p>
<p>操作系统在处理write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。</p>
<h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>在很多操作系统中，在对文件进行操作之前，要求用户先使用open系统调用“打开文件“，需要提供的几个主要参数：</p>
<ol>
<li>文件存放路径</li>
<li>文件名</li>
<li>要对文件操作的类型，如：r只读，rw读写等。</li>
</ol>
<p>操作系统在处理open系统调用时，主要做了几件事：</p>
<ol>
<li>根据文件存放路径找到文件名对应的目录项，并检查该用户是否有指定的操作权限。</li>
<li>将目录项复制到内存中的”打开文件表“中。并将对应表的编号返回给用户。之后用户使用打开文件表的标号来指明要操作的文件。</li>
</ol>
<h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p>进程使用完文件后，要“关闭文件”</p>
<p>操作系统在处理Close系统调用时，主要做了几件事：</p>
<ol>
<li>将进程的打开文件表相应表项删除</li>
<li>回收分配给该文件的内存空间等资源</li>
<li>系统打开文件表的打开计数器count减1，若count&#x3D;0，则删除对应表项。</li>
</ol>
<h3 id="4-1-7-文件共享"><a href="#4-1-7-文件共享" class="headerlink" title="4.1.7 文件共享"></a>4.1.7 文件共享</h3><blockquote>
<p>多个用户共享同一个文件，意味着系统中只有“一份“文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。如果是多个用户都“复制”了同一个文件，那么系统中会有”好几份“文件数据。其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响。</p>
</blockquote>
<h4 id="基于索引结点的共享方式（硬链接）"><a href="#基于索引结点的共享方式（硬链接）" class="headerlink" title="基于索引结点的共享方式（硬链接）"></a>基于索引结点的共享方式（硬链接）</h4><p>索引结点，是一种文件目录瘦身策略。由于检索文件时只需要用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。</p>
<p>索引结点中设置了一个链接技术变量count，用于表示链接到本索引结点上的用户目录项数。</p>
<p>若count&#x3D;2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。</p>
<p>若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减1.</p>
<p>若count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。</p>
<p>当count&#x3D;0时系统负责删除文件。</p>
<h4 id="基于符号链的共享方式（软链接）"><a href="#基于符号链的共享方式（软链接）" class="headerlink" title="基于符号链的共享方式（软链接）"></a>基于符号链的共享方式（软链接）</h4><p>在一个Link型的文件中记录共享文件的存放路径（windows快捷方式）</p>
<p>操作系统根据路径一层层查找目录，最终找到共享文件</p>
<p>即使软链接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查找共享文件会失败（找不到对应目录项）</p>
<p>由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I&#x2F;O，因此用软链接访问。</p>
<h3 id="4-1-8-文件保护"><a href="#4-1-8-文件保护" class="headerlink" title="4.1.8 文件保护"></a>4.1.8 文件保护</h3><h4 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h4><p>为文件设置一个“口令”，用户请求访问该文件时必须提供“口令”。</p>
<p>口令一般存放在文件对应的FCB或索引结点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件。</p>
<p>优点：保存口令的空间开销不多，验证口令的时间开销也很小。</p>
<p>缺点：正确的“口令“存放在系统内部，不够安全。</p>
<h4 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h4><p>使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码“才能对文件进行正确的解密。</p>
<p>优点：保密性强，不需要在系统中存储”密码“</p>
<p>缺点：编码&#x2F;译码，或者说加密&#x2F;解密要花费一定时间。</p>
<h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>在每个文件的FCB（或索引结点）中增加一个访问控制列表（Access-Control List, ACL），该表中记录了各个用户可以对该文件执行哪些操作。</p>
<p>访问类型：</p>
<ul>
<li>读：从文件中读数据</li>
<li>写：向文件中写数据</li>
<li>执行：将文件装入内存并执行</li>
<li>添加：将信息添加到文件结尾部分</li>
<li>删除：删除文件，释放空间</li>
<li>列表清单：列出文件名和文件属性</li>
</ul>
<p>精简的访问列表：以“组”为单位，标记各“组”用户可以对问及那执行哪些操作。如：分为系统管理员、文件主、文件主的伙伴、其他用户几个分组。</p>
<p>当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。</p>
<h3 id="4-1-9-文件系统的层次结构"><a href="#4-1-9-文件系统的层次结构" class="headerlink" title="4.1.9 文件系统的层次结构"></a>4.1.9 文件系统的层次结构</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="文件系统的层次结构"></p>
<p>用一个例子来辅助记忆文件系统的层次结构：</p>
<p>假设某用户请求删除文件“D:&#x2F;工作目录&#x2F;学生信息.xlsx“的最后100条记录。</p>
<ol>
<li>用户需要通过操作系统提供的接口发出上述请求——用户接口</li>
<li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项——文件目录系统</li>
<li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限——存取控制模块（存取控制验证层）</li>
<li>验证了用户的访问权限之后，需要把用户提供的”记录号“转变为对应的逻辑结构——逻辑文件系统与文件信息缓冲区</li>
<li>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址——物理文件系统</li>
<li>要删除这条记录，必定要对磁盘设备发出请求——设备管理程序模块</li>
<li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收——辅助分配模块</li>
</ol>
<h3 id="4-2-1-磁盘的结构"><a href="#4-2-1-磁盘的结构" class="headerlink" title="4.2.1 磁盘的结构"></a>4.2.1 磁盘的结构</h3><h4 id="磁盘、磁道、扇区的概念"><a href="#磁盘、磁道、扇区的概念" class="headerlink" title="磁盘、磁道、扇区的概念"></a>磁盘、磁道、扇区的概念</h4><p>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</p>
<p>磁盘的磁面被划分成一个个磁道。这样的一个“圈”就是一个磁道。</p>
<p>最内侧磁道上的扇区面积最小，因此数据密度最大</p>
<p>一个磁道又被分成一个个扇区，每个扇区就是一个“磁盘块”。各个扇区存放的数据量相同。</p>
<h4 id="如何在磁盘中读-x2F-写数据"><a href="#如何在磁盘中读-x2F-写数据" class="headerlink" title="如何在磁盘中读&#x2F;写数据"></a>如何在磁盘中读&#x2F;写数据</h4><p>需要把“磁头”移动到想要读&#x2F;写的扇区所在的磁道。磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读&#x2F;写操作。</p>
<h4 id="盘面、柱面的概念"><a href="#盘面、柱面的概念" class="headerlink" title="盘面、柱面的概念"></a>盘面、柱面的概念</h4><p>一个盘片可能会有两个盘面，每个 盘面对应一个磁头，所有的磁头都是连在同一个磁臂上的，因此所有磁头只能“共进退”，所有盘面中相对位置相同的磁道组成柱面。</p>
<h4 id="磁盘的物理地址"><a href="#磁盘的物理地址" class="headerlink" title="磁盘的物理地址"></a>磁盘的物理地址</h4><p>可用（柱面号，盘面号，扇区号）来定位任意一个“磁盘块“。文件数据存放在外存中的几号块，这个块号就可以转换成（柱面号，盘面号，扇区号）的地址形式。</p>
<p>可根据该地址读取一个”块”</p>
<ol>
<li>根据“柱面号”移动磁臂，让磁头指向柱面</li>
<li>激活指定盘面对应的磁头</li>
<li>磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读&#x2F;写。</li>
</ol>
<h4 id="磁盘的分类"><a href="#磁盘的分类" class="headerlink" title="磁盘的分类"></a>磁盘的分类</h4><p>磁头可以移动的活动头磁盘。磁臂可以来回伸缩来带动磁头定位磁道。</p>
<p>磁头不可移动的称为固定磁盘。这种磁盘中每个磁道由一个磁头。</p>
<p>盘片可以更换的称为可换盘磁盘。盘片不可更换的称为固定盘磁盘。</p>
<h3 id="4-2-2-磁盘调度算法"><a href="#4-2-2-磁盘调度算法" class="headerlink" title="4.2.2 磁盘调度算法"></a>4.2.2 磁盘调度算法</h3><h4 id="一次磁盘读-x2F-写操作需要的时间"><a href="#一次磁盘读-x2F-写操作需要的时间" class="headerlink" title="一次磁盘读&#x2F;写操作需要的时间"></a>一次磁盘读&#x2F;写操作需要的时间</h4><p><strong>寻找时间(寻道时间)T<sub>s</sub></strong>:</p>
<p>在读&#x2F;写数据钱，将磁头移动到指定磁道所花的时间。</p>
<ol>
<li><p>启动磁头臂是需要时间的。假设耗时为s；</p>
</li>
<li><p>移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。则：</p>
<p> 寻道时间T<sub>s</sub> &#x3D; s + m * n</p>
</li>
</ol>
<p><strong>延迟时间T<sub>R</sub></strong></p>
<p>通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r(单位：转&#x2F;秒，或转&#x2F;分)，则平均所需的延迟时间T<sub>R</sub> &#x3D; (1&#x2F;2) * (1&#x2F;r) &#x3D; 1&#x2F;2r。</p>
<p>1&#x2F;r就是转一圈需要的时间。找到目标扇区平均需要转半圈，因此再乘以1&#x2F;2。</p>
<p><strong>传输时间T<sub>t</sub></strong></p>
<p>从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读&#x2F;写的字节数为b，每个磁道上的字节数为N。则：传输时间T<sub>t</sub> &#x3D; (1&#x2F;r) * (b&#x2F;N) &#x3D; b&#x2F;(rN)。</p>
<p>总的平均存取时间T<sub>a</sub> &#x3D; T<sub>s</sub> + 1&#x2F;2r + b&#x2F;(rN)</p>
<blockquote>
<p>每个磁道要可存N字节的数据，因此b字节的数据需要b&#x2F;N个磁道才能存储。而读&#x2F;写一个磁道所需要的时间刚好又是转一圈所需要的时间1&#x2F;r。延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间。</p>
</blockquote>
<h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><p><strong>先来先服务FCFS</strong></p>
<p>根据进程请求访问磁盘的先后顺序进行调度。</p>
<p>假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道。按照FCFS的规则，按照请求到达的顺序，磁头需要一次移动到55、58、39、18、90、160、150、38、184号磁道。磁头总共移动了45+3+19+21+72+70+10+112+146&#x3D;498个磁道</p>
<p>响应一个请求平均需要移动498&#x2F;9&#x3D;55.3个磁道（平均寻找长度）</p>
<p>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过得去。</p>
<p>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。</p>
<p><strong>最短寻找时间优先SSTF</strong></p>
<p>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优）</p>
<p>假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道。</p>
<p>磁头总共移动了（100-18）+（184-18）&#x3D;248个磁道</p>
<p>响应一个请求平均需要移动248&#x2F;9 &#x3D; 27.5个磁道（平均寻找长度）</p>
<p>优点：性能较好，平均寻道时间短</p>
<p>缺点：可能产生“饥饿”现象</p>
<p>eg：本例中，如果在处理18号磁道的访问请求时又来了一个38号磁道的访问请求，处理38号磁道的访问请求又来了一个18号磁道的访问请求。如果有源源不断的18号、38号磁道的访问请求到来的话，150、160、184号磁道的访问请求就永远得不到满足，从而产生“饥饿”现象。</p>
<blockquote>
<p>产生饥饿的原因在于：磁头在一个小区域内来回来去地移动。</p>
</blockquote>
<p><strong>扫描算法SCAN</strong></p>
<p>SSTF算法产生饥饿的原因在于：磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。这就是扫描算法的思想。由于磁头移动的方式很像电梯，因此也叫电梯算法。</p>
<p>假设某磁盘的磁道为0～200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、16 0、150、38、184号磁道</p>
<p>磁头总共移动了（200-100）+（200 -18）&#x3D; 32个磁道</p>
<p>响应一个请求平均需要移动282&#x2F;9&#x3D;31.3个磁道（平均寻找长度）</p>
<p>优点：</p>
<ol>
<li>只有到达最边上的磁道时，才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后，就不需要再往右移动磁头了。</li>
<li>SCAN算法对于各个位置磁道的响应频率不平均（如：假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离；而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了）</li>
</ol>
<p><strong>Look调度算法</strong></p>
<p>扫描算法中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。Look调度算法就是为了解决这个问题，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。（边移动边观察，因此叫Look）</p>
<p>假设某磁盘的磁道为0～200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道</p>
<p>磁头总共移动了（184 - 100）+（184 - 18）&#x3D; 250个磁道</p>
<p>响应一个请求平均需要移动250 &#x2F; 9 &#x3D; 27.5 个磁道（平均寻找长度）</p>
<p>优点：比起SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短。</p>
<p><strong>循环扫描算法C-SCAN</strong></p>
<p>SCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</p>
<p>假设某磁盘的磁道为0～200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道</p>
<p>磁头总共移动了（200 -100）+（200-0）+（90-0）&#x3D; 390 个磁道</p>
<p>响应一个请求平均需要移动390 &#x2F; 9 &#x3D; 43.3 个磁道（平均寻找长度）</p>
<p>优点：比起SCAN来，对于各个位置磁道的响应频率很平均。</p>
<p>缺点：只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了；并且，磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。另外，比起SCAN算法来，平均寻道时间更长。</p>
<p><strong>C-LOOK调度算法</strong></p>
<p>C-SCAN算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p>
<p>假设某磁盘的磁道为0～200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道</p>
<p>磁头总共移动了（184 - 100）+（184 - 18） +（90 - 18）&#x3D; 322 个磁道</p>
<p>响应一个请求平均需要移动322 &#x2F; 9 &#x3D; 35.8个磁道（平均寻找长度）</p>
<p>优点：比起C-SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短。</p>
<h3 id="4-2-3-减少磁盘延迟时间的方法"><a href="#4-2-3-减少磁盘延迟时间的方法" class="headerlink" title="4.2.3 减少磁盘延迟时间的方法"></a>4.2.3 减少磁盘延迟时间的方法</h3><h4 id="交替编号"><a href="#交替编号" class="headerlink" title="交替编号"></a>交替编号</h4><p>具体做法：让编号相邻的扇区在物理上不相邻</p>
<p>原理：读取完一个扇区后需要一段时间处理才可以继续读入下一个扇区</p>
<h4 id="错位命名"><a href="#错位命名" class="headerlink" title="错位命名"></a>错位命名</h4><p>具体做法：让相邻盘面的扇区编号“错位”</p>
<p>原理：与“交替编号”的原理相同。”错位命名法“可降低延迟时间</p>
<h4 id="磁盘地址结构的设计"><a href="#磁盘地址结构的设计" class="headerlink" title="磁盘地址结构的设计"></a>磁盘地址结构的设计</h4><blockquote>
<p>为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）</p>
</blockquote>
<p>假设某磁盘有8个柱面&#x2F;磁道（假设最内侧柱面&#x2F;磁道号为0），4个盘面，8个扇区。则可用3个二进制位表示柱面，2个二进制位表示盘面，3个二进制位表示扇区。</p>
<p>若物理地址结构式（盘面号，柱面号，扇区号），且需要连续读取物理地址（00，000，000）～（00，001，111）的扇区：</p>
<p>（00，000，000）～（00，000，111）转两圈可读完</p>
<p>之后再读取物理地址相邻的区域，即（00，001，000）～（00，001，111），需要启动磁头臂，将磁头移动到下一个磁道。</p>
<p>若物理地址结构式（柱面号，盘面号，扇区号），且需要连续读取物理地址（000，00，000）～（000，01，111）的扇区：</p>
<p>（000，00，000）～（000，00，111）由盘面0的磁头读入数据之后再读取物理地址相邻的区域，即（000，01， 000）～（000，01，111），由于柱面号&#x2F;磁道号相同，只是盘面号不同，因此不需要移动磁头臂。只需要激活相邻盘面的磁头即可。</p>
<p>原因：在读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间。</p>
<h3 id="4-2-4-磁盘的管理"><a href="#4-2-4-磁盘的管理" class="headerlink" title="4.2.4 磁盘的管理"></a>4.2.4 磁盘的管理</h3><h4 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h4><ol>
<li>进行低级格式化（物理格式化），将磁盘的各个磁道划分为扇区。一个扇区通常可分为头、数据区域（如512B大小）、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶检验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误）</li>
<li>将磁盘分区，每个分区由若干柱面组成（即分为我们熟悉的C盘、D盘、E盘）</li>
<li>进行逻辑格式化，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表）</li>
</ol>
<h4 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h4><p>计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行初始化程序（自举程序）完成的。初始化程序可以放在ROM（只读存储器）中。</p>
<p>ROM中的数据在出厂时就写入了，并且以后不能再修改。</p>
<p>ROM一般是出厂时就集成在主板上的。</p>
<p>ROM中只存放很小的“自举装入程序”。</p>
<p>完成的自举程序放在磁盘的启动块（即引导块&#x2F;启动分区）上，启动块位于磁盘的固定位置。</p>
<p>开机时计算机先运行“自举装入程序”，通过执行该程序就可找到引导块，并将完整的“自举程序”读入内存，完成初始化。拥有启动分区的磁盘称为启动磁盘或系统磁盘（C:盘）</p>
<h4 id="坏块的管理"><a href="#坏块的管理" class="headerlink" title="坏块的管理"></a>坏块的管理</h4><p>坏了、无法正常使用的是扇区就是“坏块”。这属于硬件故障，操作系统是无法修复的。应该将坏块标记出来，以免错误地使用到它。</p>
<p>对于简单的磁盘，可以在逻辑格式化时（建立文件系统时）对整个磁盘进行坏块检查，表明哪些扇区是坏扇区，比如：在FAT表上表明。（在这种方式中，坏块对操作系统不透明）</p>
<p>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。</p>
<p>在磁盘出厂前进行低级格式化（物理格式化）时就讲坏块链进行初始化。</p>
<p>会保留一些”备用扇区“，用于替换坏块。这种方案称为扇区备用。且这种处理方式中，坏块对操作系统透明。</p>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="5-1-1-I-x2F-O设备的概念和分类"><a href="#5-1-1-I-x2F-O设备的概念和分类" class="headerlink" title="5.1.1 I&#x2F;O设备的概念和分类"></a>5.1.1 I&#x2F;O设备的概念和分类</h3><h4 id="什么是I-x2F-O设备"><a href="#什么是I-x2F-O设备" class="headerlink" title="什么是I&#x2F;O设备"></a>什么是I&#x2F;O设备</h4><p>“I&#x2F;O”就是“输入&#x2F;输出”（Input&#x2F;Output）</p>
<p>I&#x2F;O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</p>
<p>UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。</p>
<p>Write操作：向外部设备写出数据</p>
<p>Read操作：从外部设备读入数据</p>
<h4 id="按使用特性分类"><a href="#按使用特性分类" class="headerlink" title="按使用特性分类"></a>按使用特性分类</h4><ul>
<li><p>人机交互类外部设备</p>
<p>  数据传输速度慢。包括鼠标、键盘、打印机等，用于人机交互</p>
</li>
<li><p>存储设备</p>
<p>  数据传输速度快。包括移动硬盘、光盘等，用于数据存储</p>
</li>
<li><p>网络通信设备</p>
<p>  数据传输速度介于上述两种之间。包括调制解调器等，用于网络通信</p>
</li>
</ul>
<h4 id="按传输速率分类"><a href="#按传输速率分类" class="headerlink" title="按传输速率分类"></a>按传输速率分类</h4><ul>
<li>低速设备：鼠标、键盘，每秒几个到几百字节</li>
<li>中速设备：激光打印机，每秒数千至上万个字节</li>
<li>高速设备：磁盘，每秒数千字节至前兆字节</li>
</ul>
<h4 id="按信息交换的单位分类"><a href="#按信息交换的单位分类" class="headerlink" title="按信息交换的单位分类"></a>按信息交换的单位分类</h4><ul>
<li><p>块设备：传输速率较高，可寻址，即对它随机地读&#x2F;写任一块。如磁盘等，数据传输的基本单位是“块”。</p>
</li>
<li><p>字符设备：传输速率较慢，不可寻址，在输入&#x2F;输出时常采用中断驱动方式。如鼠标、键盘等，数据传输的基本单位是字符。</p>
</li>
</ul>
<h3 id="5-1-2-I-x2F-O控制器"><a href="#5-1-2-I-x2F-O控制器" class="headerlink" title="5.1.2 I&#x2F;O控制器"></a>5.1.2 I&#x2F;O控制器</h3><p>CPU无法直接控制I&#x2F;O设备的机械部件，因此I&#x2F;O设备还要有一个电子部件作为CPU和I&#x2F;O设备机械部件之间的“中介”，用于实现CPU对设备的控制。</p>
<p>这个电子部件就是I&#x2F;O控制器，又称设备控制器。CPU可控制I&#x2F;O控制器，又由I&#x2F;O控制器来控制设备的机械部件。</p>
<h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ul>
<li><p>接受和识别CPU发出的命令</p>
<p>  如CPU发来的read&#x2F;write命令，I&#x2F;O控制器中会有相应的控制寄存器来存放命令和参数</p>
</li>
<li><p>向CPU报告设备的状态</p>
<p>  I&#x2F;O控制器中会有相应的状态寄存器，用于记录I&#x2F;O设备的当前状态。如1表示空闲，0表示忙碌</p>
</li>
<li><p>数据交换</p>
<p>  I&#x2F;O控制器中会设置相应的数据寄存器。输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备。输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据。</p>
</li>
<li><p>地址识别</p>
<p>  类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的”地址“。I&#x2F;O控制器通过CPU提供的“地址”来判断CPU要读&#x2F;写的是哪个寄存器。</p>
</li>
</ul>
<h4 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h4><ul>
<li><p>CPU与控制器的接口</p>
<p>  用于实现CPU与控制器之间的通信。CPU通过控制线发出命令；通过地址线指明要操作的设备；通过数据线来取出（输入）数据，或放入（输出）数据</p>
</li>
<li><p>I&#x2F;O逻辑</p>
<p>  负责接收和识别CPU的各种命令（如地址译码），并负责对设备发出命令</p>
</li>
<li><p>控制器与设备的接口</p>
<p>  用于实现控制器与设备之间的通信</p>
</li>
</ul>
<p>ps：</p>
<ol>
<li>一个I&#x2F;O控制器可能会对应多个设备；</li>
<li>数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制&#x2F;状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像I&#x2F;O；另一些计算机则采用I&#x2F;O专用地址，即寄存器独立编址。</li>
</ol>
<h4 id="两种寄存器编址方式"><a href="#两种寄存器编址方式" class="headerlink" title="两种寄存器编址方式"></a>两种寄存器编址方式</h4><ul>
<li><p>内存映射I&#x2F;O</p>
<p>  控制器中的寄存器与内存地址统一编址</p>
<p>  优点：简化了指令。可以采用对内存进行操作的指令来对控制器进行操作。</p>
</li>
<li><p>寄存器独立编址</p>
<p>  控制器中的寄存器使用单独的地址。</p>
<p>  缺点：需要设置专门的指令来实现对控制器的操作，不仅要指明寄存器的地址，还要指明控制器的编号。</p>
</li>
</ul>
<h3 id="5-1-3-I-x2F-O控制方式"><a href="#5-1-3-I-x2F-O控制方式" class="headerlink" title="5.1.3 I&#x2F;O控制方式"></a>5.1.3 I&#x2F;O控制方式</h3><h4 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h4><p><strong>Key word：轮询</strong></p>
<ol>
<li><p>完成一次读&#x2F;写操作的流程（以读操作为例）</p>
<p> ①CPU向控制器发出读指令。于是设备启动，并且状态寄存器设为1（未就绪）</p>
<p> ②轮询检查控制器的状态（其实就是在不断地执行程序的循环，若状态位一直是1，说明设备还没准备好要输入的数据，于是CPU会不断地轮询）</p>
<p> ③摄入设备准备好数据后将数据传给控制器，并报告自身状态</p>
<p> ④控制器将输入的数据放到数据寄存器中，并将状态改为0（已就绪）</p>
<p> ⑤CPU发现设备已就绪，即可将数据寄存器中的内容读入CPU的寄存器中，再把CPU寄存器中的内容放入内存</p>
<p> ⑥若还要继续读入数据，则CPU继续发出读指令</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png" alt="程序直接控制方式"></p>
</li>
<li><p>CPU干预的频率</p>
<p> 很频繁，I&#x2F;O操作开始之前、完成之后需要CPU介入，并且在等待I&#x2F;O完成的过程中CPU需要不断地轮询检查。</p>
</li>
<li><p>数据传送的单位</p>
<p> 每次读&#x2F;写一个字</p>
</li>
<li><p>数据的流向</p>
<p> 读操作（数据输入）：I&#x2F;O设备 -&gt; CPU -&gt; 内存</p>
<p> 写操作（数据输出）：内存 -&gt; CPU -&gt; I&#x2F;O设备</p>
<p> 每个字的读&#x2F;写都需要CPU的帮助</p>
</li>
<li><p>主要缺点和主要优点</p>
<p> 优点：实现简单。在读&#x2F;写指令之后，加上实现循环检查的一系列指令即可（因此才称为“程序直接控制方式”）</p>
<p> 缺点：CPU和I&#x2F;O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等“状态，CPU利用率低。</p>
</li>
</ol>
<h4 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h4><ol>
<li><p>完成一次读&#x2F;写操作的过程</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F.png" alt="中断驱动方式"></p>
</li>
<li><p>CPU干预的频率</p>
<p> 每次I&#x2F;O操作开始之前、完成之后需要CPU介入。等待I&#x2F;O完成的过程中CPU可以切换到别的进程执行。</p>
</li>
<li><p>数据传送的单位</p>
<p> 每次读&#x2F;写一个字</p>
</li>
<li><p>数据的流向</p>
<p> 读操作（数据输入）：I&#x2F;O设备 -&gt; CPU -&gt; 内存</p>
<p> 写操作（数据输出）：内存 -&gt; CPU -&gt; I&#x2F;O设备</p>
</li>
<li><p>主要缺点和主要优点</p>
<p> 优点：与“程序直接控制方式”相比，在“中断驱动方式”中，I&#x2F;O控制器会通过中断信号主动报告I&#x2F;O已完成，CPU不再需要不停地轮询。CPU和I&#x2F;O设备可并行工作，CPU利用率得到明显提升。</p>
<p> 缺点：每个字在I&#x2F;O设备与内存之间的传输，都需要经过CPU。而频繁的中断处理会消耗较多的CPU时间。</p>
</li>
</ol>
<p>引入中断机制。由于I&#x2F;O设备速度很慢，因此在CPU发出读&#x2F;写命令后，可将等待I&#x2F;O的进程阻塞，先切换到别的进程执行。当I&#x2F;O完成后，控制器会向CPU发出一个中断信号，CPU监测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，CPU从I&#x2F;O控制器读一个字的数据传送到CPU寄存器，在写入主存。接着，CPU恢复等待I&#x2F;O的进程（或其他进程）的运行环境，然后继续执行。</p>
<p>ps：</p>
<ol>
<li>CPU会在每个指令周期的末尾检查中断；</li>
<li>中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。如果中断发生的频率太高，也会降低系统性能。</li>
</ol>
<h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><p>与“中断驱动方式”相比，DMA方式（Direct Memory Access，直接存储器存取。主要用于块设备的I&#x2F;O控制）有这样几个改进：</p>
<p>①数据的传送单位是“块”。不再是一个字、一个字的传送</p>
<p>②数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为“快递小哥”</p>
<p>③仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/DMA%E6%8E%A7%E5%88%B6%E5%99%A8.png" alt="DMA控制器"></p>
<p>DR（Data Register，数据寄存器）：暂存从设备到内存，或从内存到设备的数据。</p>
<p>MAR（Memory Address Register，内存地址寄存器）：在输入时，MAR表示数据应放到内存中的什么位置；输出时MAR表示要输出的数据放在内存中的什么位置。</p>
<p>DC（Data Counter，数据计数器）：表示剩余要读&#x2F;写的字节数。</p>
<p>CR（Command Register，命令&#x2F;状态寄存器）：用于存放CPU发来的I&#x2F;O命令，或设备的状态信息。</p>
<ol>
<li><p>完成一次读&#x2F;写操作的流程</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/DMA%E6%96%B9%E5%BC%8F.png" alt="DMA方式"></p>
</li>
<li><p>CPU干预的频率</p>
<p> 仅在传送一个或多个数据块的开始和结束时，才需要CPU干预</p>
</li>
<li><p>数据传送的单位</p>
<p> 每次读&#x2F;写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）</p>
</li>
<li><p>数据的流向（不再需要经过CPU）</p>
<p> 读操作（数据输入）：I&#x2F;O设备 -&gt; 内存</p>
<p> 写操作（数据输出）：内存 -&gt; I&#x2F;O设备</p>
</li>
<li><p>主要缺点和主要优点</p>
<p> 优点：数据传输以“块”为单位，CPU介入频率进一步降低。数据的传输不再需要先经过CPU在写入内存，数据传输效率进一步增加。CPU和I&#x2F;O设备的并行性得到提升。</p>
<p> 缺点：CPU每发出一条I&#x2F;O指令，只能读&#x2F;写一个或多个连续的数据块。如果要读&#x2F;写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I&#x2F;O指令，进行多次中断处理才能完成。</p>
</li>
</ol>
<h4 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h4><p>通道：一种硬件，可以理解为是“弱鸡版的CPU”。通道可以识别并执行一系列通道指令。与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存</p>
<p>①CPU向通道发出I&#x2F;O指令。指明通道程序在内存中的位置，并指明要操作的是哪个I&#x2F;O设备。之后CPU就切换到其他进程执行了</p>
<p>②通道执行内存中的通道程序（其中指明了要读入&#x2F;写出多少数据，读&#x2F;写的数据应放在内存的什么位置等信息）</p>
<p>③通道执行完规定的任务后，向CPU发出中断信号，之后C PU对中断进行处理</p>
<ol>
<li><p>完成一次读&#x2F;写操作的流程</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png" alt="通道控制方式"></p>
</li>
<li><p>CPU干预的频率</p>
<p> 极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读&#x2F;写后才需要发出中断信号，请求CPU干预。</p>
</li>
<li><p>数据传送的单位</p>
<p> 每次读&#x2F;写一组数据块</p>
</li>
<li><p>数据的流向（在通道的控制下进行）</p>
<p> 读操作（数据输入）：I&#x2F;O设备 -&gt; 内存</p>
<p> 写操作（数据输出）：内存 -&gt; I&#x2F;O设备</p>
</li>
<li><p>主要缺点和主要优点</p>
<p> 缺点：实现复杂，需要专门的通道硬件支持</p>
<p> 优点：CPU、通道、I&#x2F;O设备可并行工作，资源利用率很高</p>
</li>
</ol>
<h3 id="5-1-4-I-x2F-O软件层次结构"><a href="#5-1-4-I-x2F-O软件层次结构" class="headerlink" title="5.1.4 I&#x2F;O软件层次结构"></a>5.1.4 I&#x2F;O软件层次结构</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/IO%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="IO软件层次结构"></p>
<h4 id="用户层软件"><a href="#用户层软件" class="headerlink" title="用户层软件"></a>用户层软件</h4><p>实现了与用户交互的接口，用户可直接使用该层提供的、与I&#x2F;O操作相关的库函数对设备进行操作</p>
<p>用户层软件将用户请求翻译成格式化的I&#x2F;O请求，并通过“系统调用”请求操作系统内核的服务</p>
<p>Windows操作系统向外提供的一系列系统调用，但是由于系统调用的格式严格，使用麻烦，因此在用户层上封装了一系列更方便的库函数共用户使用</p>
<h4 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h4><p>又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。</p>
<p>主要功能：</p>
<ol>
<li><p>向上一层提供统一的调用接口（如read&#x2F;write系统调用）</p>
</li>
<li><p>设备的保护</p>
<p> 原理类似与文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样。</p>
</li>
<li><p>差错处理</p>
<p> 设备独立性软件需要对一些设备的错误进行处理</p>
</li>
<li><p>设备的分配与回收</p>
</li>
<li><p>数据缓冲区管理</p>
<p> 可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</p>
</li>
<li><p>建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序</p>
<p> 用户或用户层软件发出I&#x2F;O操作相关系统调用时，需要指明此次要操作的I&#x2F;O设备的逻辑设备名</p>
<p> 设备独立性软件需要通过“逻辑设备表”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序</p>
</li>
</ol>
<p>操作系统可以采用两种方式管理逻辑设备表LUT：</p>
<ul>
<li>整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种只适用于丹用户操作系统。</li>
<li>为每个用户设置一张LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</li>
</ul>
<blockquote>
<p>为何不同的设备需要不同的设备驱动程序？</p>
</blockquote>
<p>不同设备的内部硬件特性不同，这些特性只有厂家才知道，因此厂家必须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作。</p>
<h4 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h4><p>主要负责对硬件设备的具体控制，将上层发出的一系列命令（如read&#x2F;write）转化成特定设备“能听得懂”的一些列操作。包括设置设备寄存器；检查设备状态等。</p>
<p>ps：驱动程序一般会以一个独立进程的方式存在。</p>
<h4 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h4><p>当I&#x2F;O任务完成时，I&#x2F;O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序的处理流程如下：</p>
<p>从控制器读出设备状态，若I&#x2F;O正常结束，从设备中读入一个字的数据并经由CPU放到内存缓冲区中。若I&#x2F;O异常结束，根据异常原因做响应处理。</p>
<h3 id="5-1-5-I-x2F-O核心子系统"><a href="#5-1-5-I-x2F-O核心子系统" class="headerlink" title="5.1.5 I&#x2F;O核心子系统"></a>5.1.5 I&#x2F;O核心子系统</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/IO%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F.png" alt="IO核心子系统"></p>
<h4 id="各功能要在那个层次实现"><a href="#各功能要在那个层次实现" class="headerlink" title="各功能要在那个层次实现"></a>各功能要在那个层次实现</h4><p>用户层软件：假脱机技术SPOOLing技术</p>
<p>设备独立性软件：I&#x2F;O调度、设备保护、设备分配与回收、缓冲区管理（即缓冲与高速缓存）</p>
<p>ps：假脱机技术SPOOLing技术需要请求“磁盘设备”的设备独立性软件的服务，因此一般来说假脱机技术是在用户层软件实现的。</p>
<p>I&#x2F;O调用：用某种算法确定一个好的顺序来处理各个I&#x2F;O请求。</p>
<h3 id="5-1-6-假脱机技术"><a href="#5-1-6-假脱机技术" class="headerlink" title="5.1.6 假脱机技术"></a>5.1.6 假脱机技术</h3><h4 id="什么是脱机技术，脱机技术可以解决什么问题"><a href="#什么是脱机技术，脱机技术可以解决什么问题" class="headerlink" title="什么是脱机技术，脱机技术可以解决什么问题"></a>什么是脱机技术，脱机技术可以解决什么问题</h4><p>手工操作阶段：主机直接从I&#x2F;O设备获得数据，由于设备速度慢，主机速度很快 。人机速度矛盾明显，主机要浪费很多时间来等待设备。</p>
<p>批处理阶段引入了脱机输入&#x2F;输出技术：在外围控制机的控制下，慢速输入设备的数据先辈输入到更快速的磁带上。之后主机可以从快速的磁带上读入数据，从而缓解了速度矛盾。引入脱机技术后，缓解了CPU与慢速I&#x2F;O设备的速度矛盾。另一方面，即使CPU在忙碌，也可以提前将数据输入到磁带；即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁道。</p>
<blockquote>
<p>脱机——脱离主机的控制进行的输入&#x2F;输出操作。</p>
</blockquote>
<h4 id="假脱机技术的实现原理"><a href="#假脱机技术的实现原理" class="headerlink" title="假脱机技术的实现原理"></a>假脱机技术的实现原理</h4><p>“假脱机技术”又称“SPOOLing技术”，是用软件的方式模拟脱机技术。SPOOLing系统的组成如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/spooling%E7%BB%84%E6%88%90.png" alt="spooling组成"></p>
<p><strong>输入井和输出井</strong></p>
<p>“输入井”模拟脱机输入时的磁带，用于收容I&#x2F;O设备输入的数据。</p>
<p>“输出井”模拟脱机输出时的磁带，用于收容用户进程输出的数据。</p>
<p><strong>输入进程和输出进程</strong></p>
<p>“输入进程”模拟脱机输入时的外围控制机</p>
<p>“输出进程”模拟脱机输出时的外围控制机</p>
<p><strong>输入缓冲区和输出缓冲区</strong></p>
<p>在输入进程的控制下，“输入缓冲区”用于暂存从输入设备输入的数据，之后在转存到输入井中</p>
<p>在输出进程的控制下，”输出缓冲区“用于暂存从输出井送来的数据，之后再传送到输出设备上</p>
<h4 id="共享打印机原理"><a href="#共享打印机原理" class="headerlink" title="共享打印机原理"></a>共享打印机原理</h4><p>独占式设备——只允许各个进程串行使用的设备。一段时间只能满足一个进程的请求。</p>
<p>共享设备——允许多个进程“同时”使用的设备（宏观上同时使用，微观上可能是交替使用）。可以同时满足多个进程的使用请求。</p>
<p>打印机是种“独占式设备”，但是可以用SPOOLing技术改造成“共享设备”</p>
<p>独占式设备的例子：若进程1正在使用打印机，则进程2请求使用打印机时必然阻塞等待</p>
<p>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给它们，而是由假脱机管理进程为每个进程做两件事：</p>
<ol>
<li>在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中；</li>
<li>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上。</li>
</ol>
<p>当打印机空闲时，输出进程会从文件队列的对头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务。</p>
<p>虽然系统中只有一台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。</p>
<p>SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备。</p>
<h3 id="5-1-7-设备的分配与回收"><a href="#5-1-7-设备的分配与回收" class="headerlink" title="5.1.7 设备的分配与回收"></a>5.1.7 设备的分配与回收</h3><h4 id="设备分配时应考虑的因素"><a href="#设备分配时应考虑的因素" class="headerlink" title="设备分配时应考虑的因素"></a>设备分配时应考虑的因素</h4><ul>
<li><p>设备的固有属性</p>
<ul>
<li>独占设备：一个时段只能分配给一个进程，如打印机</li>
<li>共享设备：可同时分配给多个进程使用，如磁盘。各进程往往使宏观上同时共享使用设备，而微观上交替使用。</li>
<li>虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用，如采用SPOOLing技术实现的共享打印机</li>
</ul>
</li>
<li><p>设备分配算法</p>
<p>  先来先服务、优先级高者优先、短任务优先等</p>
</li>
<li><p>设备分配中的安全性</p>
<ul>
<li><p>安全分配方式：为进程分配一个设备后就讲进程阻塞，本次I&#x2F;O完成后才将进程唤醒。</p>
<p>  一个时段内每个进程只能使用一个设备。</p>
<p>  优点：破坏了“请求和保持”条件，不会死锁</p>
<p>  缺点：对于一个进程来说，CPU和I&#x2F;O设备只能串行工作</p>
</li>
<li><p>不安全分配方式：进程发出I&#x2F;O请求后，系统为其分配I&#x2F;O设备，进程可继续执行，之后还可以发出新的I&#x2F;O请求。只有某个I&#x2F;O请求得不到满足时才将进程阻塞。</p>
<p>  一个进程可以同时使用多个设备</p>
<p>  优点：进程的计算任务和I&#x2F;O任务可以并行处理，使进程迅速推进</p>
<p>  缺点：有可能发生死锁（死锁避免、死锁的检测和解除）</p>
</li>
</ul>
</li>
</ul>
<h4 id="静态分配与动态分配"><a href="#静态分配与动态分配" class="headerlink" title="静态分配与动态分配"></a>静态分配与动态分配</h4><p>静态分配：进程运行前为其分配全部所需资源，运行结束后归坏资源。破坏了“请求和保持”条件，不会发生死锁</p>
<p>动态分配：进程运行过程中动态申请设备资源</p>
<h4 id="设备分配管理中的数据结构"><a href="#设备分配管理中的数据结构" class="headerlink" title="设备分配管理中的数据结构"></a>设备分配管理中的数据结构</h4><p>“设备、控制器、通道”之间的关系：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8%E9%80%9A%E9%81%93%E5%85%B3%E7%B3%BB.png"></p>
<p>一个通道可控制多个设备控制器，每个设备控制器可控制多个设备。</p>
<p>设备控制表（DCT）：系统为每个设备配置一张DCT，用于记录设备情况</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E8%A1%A8.png" alt="设备控制表"></p>
<p>控制器控制表（COCT）：每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E6%8E%A7%E5%88%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E8%A1%A8.png" alt="控制器控制表"></p>
<p>通道控制表（CHCT）：每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E8%A1%A8.png" alt="通道控制表"></p>
<p>系统设备表（SDT）：记录了系统中全部设备的情况，每个设备对应一个表目</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/operationSystem/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%A4%87%E8%A1%A8.png" alt="系统设备表"></p>
<h4 id="设备分配的步骤"><a href="#设备分配的步骤" class="headerlink" title="设备分配的步骤"></a>设备分配的步骤</h4><ol>
<li>根据进程请求的物理设备名查找SDT（注：物理设备名时进程请求分配设备时提供的参数）</li>
<li>根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。</li>
<li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li>
<li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li>
</ol>
<blockquote>
<p>只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I&#x2F;O设备进行数据传送</p>
</blockquote>
<p>缺点：</p>
<ol>
<li>用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程</li>
<li>若换了一个物理设备，则程序无法运行</li>
<li>若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</li>
</ol>
<p>改进：建立逻辑设备名与物理设备名的映射机制，用户编程时只需要提供逻辑设备名</p>
<h4 id="设备分配步骤的改进方法"><a href="#设备分配步骤的改进方法" class="headerlink" title="设备分配步骤的改进方法"></a>设备分配步骤的改进方法</h4><ol>
<li>根据进程请求的逻辑设备名查找SDT（用户编程时提供的逻辑设备名其实就是“设备类型”）</li>
<li>查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表LUT中新增一个表项。</li>
<li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li>
<li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li>
</ol>
<p>逻辑设备表LUT建立了逻辑设备名与物理设备名之间的映射关系。</p>
<p>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项。</p>
<p>如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址。</p>
<p>逻辑设备表的设置问题：</p>
<p>整个系统只有一张LUT：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统</p>
<p>每个用户一张LUT：不同用户的逻辑设备名可重复，适用于多用户操作系统</p>
<h3 id="5-1-8-缓冲区管理"><a href="#5-1-8-缓冲区管理" class="headerlink" title="5.1.8 缓冲区管理"></a>5.1.8 缓冲区管理</h3><h4 id="缓冲区的概念"><a href="#缓冲区的概念" class="headerlink" title="缓冲区的概念"></a>缓冲区的概念</h4><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</p>
<p>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</p>
<p>一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要阻止管理好这些缓冲区</p>
<p>缓冲区的作用：</p>
<ul>
<li>缓和CPU与I&#x2F;O设备之间速度不匹配的矛盾</li>
<li>减少对CPU的中断频率，放宽对CPU中断相应时间的限制</li>
<li>解决数据力度不匹配的问题</li>
<li>提高CPU与I&#x2F;O设备之间的并行性</li>
</ul>
<h4 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h4><p>假设某用户进程请求某块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区。当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满后，才能冲缓冲区把数据传出。</p>
<p>处理一块数据平均耗时Max(C, T) + M</p>
<h4 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h4><p>假设某用户进程请求某种块设备读入若干块的数据。若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区。</p>
<p>处理一个数据块的平均耗时为Max(T, C + M)</p>
<h4 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h4><p>将多个大小相等的缓冲区连接成一个循环队列。</p>
<h4 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h4><p>缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。</p>
<p>另外，根据一个缓冲区在世纪运算中扮演的功能不同，又设置了四种工作缓冲区：</p>
<ul>
<li>用于收容输入数据的工作缓冲区（hin）</li>
<li>用于提取输入数据的工作缓冲区（sin）</li>
<li>用于收容输出数据的工作缓冲区（hout）</li>
<li>用于提取输出数据的工作缓冲区（sout）</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/02/dsa/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构与算法</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/13/computer/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0"><span class="toc-number">1.</span> <span class="toc-text">第一章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E6%A6%82%E5%BF%B5%E3%80%81%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.</span> <span class="toc-text">1.1.1 概念、功能和目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.</span> <span class="toc-text">1.1.2 操作系统的特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">1.2.1.</span> <span class="toc-text">并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB"><span class="toc-number">1.2.2.</span> <span class="toc-text">共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">虚拟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-number">1.2.4.</span> <span class="toc-text">异步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">1.1.3 操作系统的发展和分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%B7%A5%E6%93%8D%E4%BD%9C%E9%98%B6%E6%AE%B5"><span class="toc-number">1.3.1.</span> <span class="toc-text">手工操作阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5"><span class="toc-number">1.3.2.</span> <span class="toc-text">批处理阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">分时操作系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.4.</span> <span class="toc-text">实时操作系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.5.</span> <span class="toc-text">网络操作系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.6.</span> <span class="toc-text">分布式操作系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.7.</span> <span class="toc-text">个人计算机操作系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">1.1.4 操作系统的运行机制与体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">运行机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8"><span class="toc-number">1.4.2.</span> <span class="toc-text">操作系统内核</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.3.</span> <span class="toc-text">操作系统的体系结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-5-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">1.5.</span> <span class="toc-text">1.1.5 中断和异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="toc-number">1.5.1.</span> <span class="toc-text">中断机制的诞生</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">中断的概念和作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.3.</span> <span class="toc-text">中断的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.4.</span> <span class="toc-text">外中断的处理过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">1.1.6 系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%8C%E6%9C%89%E4%BD%95%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.6.1.</span> <span class="toc-text">什么是系统调用，有何作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.2.</span> <span class="toc-text">系统调用和库函数的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%83%8C%E5%90%8E%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.3.</span> <span class="toc-text">系统调用背后的过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0"><span class="toc-number">2.</span> <span class="toc-text">第二章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E7%BB%84%E6%88%90%E3%80%81%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%E3%80%81%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.</span> <span class="toc-text">2.1.1 进程的定义、组成、组织方式、特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E6%88%90"><span class="toc-number">2.1.2.</span> <span class="toc-text">组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E7%BB%87"><span class="toc-number">2.1.3.</span> <span class="toc-text">组织</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.4.</span> <span class="toc-text">特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.</span> <span class="toc-text">2.1.2 进程的状态与转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.2.</span> <span class="toc-text">进程状态的转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">2.1.3 进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E8%AF%AD"><span class="toc-number">2.3.1.</span> <span class="toc-text">原语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8E%9F%E8%AF%AD"><span class="toc-number">2.3.2.</span> <span class="toc-text">进程控制相关的原语</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.</span> <span class="toc-text">2.1.4 进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">共享存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.2.</span> <span class="toc-text">管道通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">2.4.3.</span> <span class="toc-text">消息传递</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.5.</span> <span class="toc-text">2.1.5 线程概念和多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.5.1.</span> <span class="toc-text">什么是线程，为什么要引入线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E5%90%8E%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="toc-number">2.5.2.</span> <span class="toc-text">引入线程机制后，有什么变化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">2.5.3.</span> <span class="toc-text">线程有哪些重要的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.4.</span> <span class="toc-text">线程的实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.5.5.</span> <span class="toc-text">多线程模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%B1%82%E6%AC%A1"><span class="toc-number">2.6.</span> <span class="toc-text">2.2.1 处理机调度的概念、层次</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.6.1.</span> <span class="toc-text">调度的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1"><span class="toc-number">2.6.2.</span> <span class="toc-text">调度的三个层次</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%E3%80%81%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B%E3%80%81%E6%96%B9%E5%BC%8F"><span class="toc-number">2.7.</span> <span class="toc-text">2.2.2 进程调度的时机、切换与过程、方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">2.7.1.</span> <span class="toc-text">进程调度的时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.7.2.</span> <span class="toc-text">进程调度的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B"><span class="toc-number">2.7.3.</span> <span class="toc-text">进程的切换与过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-number">2.8.</span> <span class="toc-text">2.2.3 调度算法的评价指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">2.8.1.</span> <span class="toc-text">CPU利用率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">2.8.2.</span> <span class="toc-text">系统吞吐量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4"><span class="toc-number">2.8.3.</span> <span class="toc-text">周转时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4"><span class="toc-number">2.8.4.</span> <span class="toc-text">等待时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4"><span class="toc-number">2.8.5.</span> <span class="toc-text">响应时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.</span> <span class="toc-text">2.2.4 调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-FCFS"><span class="toc-number">2.9.1.</span> <span class="toc-text">先来先服务(FCFS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88-SJF"><span class="toc-number">2.9.2.</span> <span class="toc-text">短作业优先(SJF)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88-HRRN"><span class="toc-number">2.9.3.</span> <span class="toc-text">高响应比优先(HRRN)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-%E9%80%82%E5%90%88%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.10.</span> <span class="toc-text">2.2.5 适合交互式系统的调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC-RR-Round-Robin"><span class="toc-number">2.10.1.</span> <span class="toc-text">时间片轮转(RR, Round-Robin)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.10.2.</span> <span class="toc-text">优先级调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.10.3.</span> <span class="toc-text">多级反馈队列调度算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">2.11.</span> <span class="toc-text">2.3.1 进程同步、进程互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">2.11.1.</span> <span class="toc-text">进程同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">2.11.2.</span> <span class="toc-text">进程互斥</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">2.12.</span> <span class="toc-text">2.3.2 进程互斥的软件实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95"><span class="toc-number">2.12.1.</span> <span class="toc-text">单标志法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5%E6%B3%95"><span class="toc-number">2.12.2.</span> <span class="toc-text">双标志先检查法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5%E6%B3%95"><span class="toc-number">2.12.3.</span> <span class="toc-text">双标志后检查法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Peterson%E7%AE%97%E6%B3%95"><span class="toc-number">2.12.4.</span> <span class="toc-text">Peterson算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">2.13.</span> <span class="toc-text">2.3.3 进程互斥的硬件实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E6%96%B9%E6%B3%95"><span class="toc-number">2.13.1.</span> <span class="toc-text">中断屏蔽方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TestAndSet%E6%8C%87%E4%BB%A4"><span class="toc-number">2.13.2.</span> <span class="toc-text">TestAndSet指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Swap%E6%8C%87%E4%BB%A4"><span class="toc-number">2.13.3.</span> <span class="toc-text">Swap指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">2.14.</span> <span class="toc-text">2.3.4 信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.14.1.</span> <span class="toc-text">整型信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.14.2.</span> <span class="toc-text">记录型信号量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-5-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.15.</span> <span class="toc-text">2.3.5 信号量的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">2.15.1.</span> <span class="toc-text">实现进程互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">2.15.2.</span> <span class="toc-text">实现进程同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="toc-number">2.15.3.</span> <span class="toc-text">实现进程的前驱关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-6-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.16.</span> <span class="toc-text">2.3.6 生产者-消费者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-7-%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.17.</span> <span class="toc-text">2.3.7 多生产者-多消费者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-8-%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.18.</span> <span class="toc-text">2.3.8 吸烟者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-9-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.19.</span> <span class="toc-text">2.3.9 读者-写者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-10-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">2.20.</span> <span class="toc-text">2.3.10 哲学家进餐问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-11-%E7%AE%A1%E7%A8%8B"><span class="toc-number">2.21.</span> <span class="toc-text">2.3.11 管程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E7%AE%A1%E7%A8%8B"><span class="toc-number">2.21.1.</span> <span class="toc-text">为什么要引入管程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">2.21.2.</span> <span class="toc-text">管程的定义和基本特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95"><span class="toc-number">2.21.3.</span> <span class="toc-text">拓展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.22.</span> <span class="toc-text">2.4.1 死锁的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81"><span class="toc-number">2.22.1.</span> <span class="toc-text">什么是死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E3%80%81%E9%A5%A5%E9%A5%BF%E3%80%81%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.22.2.</span> <span class="toc-text">死锁、饥饿、死循环的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.22.3.</span> <span class="toc-text">死锁产生的必要条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81"><span class="toc-number">2.22.4.</span> <span class="toc-text">什么时候会发生死锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5-%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">2.23.</span> <span class="toc-text">2.4.2 死锁的处理策略-预防死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.23.1.</span> <span class="toc-text">破坏互斥条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E4%B8%8D%E5%89%A5%E5%A4%BA%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.23.2.</span> <span class="toc-text">破坏不剥夺条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E8%AF%B7%E6%B1%82%E5%92%8C%E4%BF%9D%E6%8C%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.23.3.</span> <span class="toc-text">破坏请求和保持条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.23.4.</span> <span class="toc-text">破坏循环等待条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">2.24.</span> <span class="toc-text">2.4.3 死锁的处理策略-避免死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E5%85%A8%E5%BA%8F%E5%88%97"><span class="toc-number">2.24.1.</span> <span class="toc-text">什么是安全序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5-%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4"><span class="toc-number">2.25.</span> <span class="toc-text">2.4.4 死锁的处理策略-检测和解除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">2.25.1.</span> <span class="toc-text">死锁的检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4"><span class="toc-number">2.25.2.</span> <span class="toc-text">死锁的解除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0"><span class="toc-number">3.</span> <span class="toc-text">第三章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">3.1.</span> <span class="toc-text">3.1.1 内存的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%EF%BC%8C%E6%9C%89%E4%BD%95%E4%BD%9C%E7%94%A8"><span class="toc-number">3.1.1.</span> <span class="toc-text">什么是内存，有何作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.2.</span> <span class="toc-text">进程运行的基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">3.1.3.</span> <span class="toc-text">三种链接方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">3.1.4.</span> <span class="toc-text">三种装入方式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.2.</span> <span class="toc-text">3.1.2 内存管理的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">3.2.1.</span> <span class="toc-text">内存空间的分配与回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">内存空间的扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.2.3.</span> <span class="toc-text">地址转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E4%BF%9D%E6%8A%A4"><span class="toc-number">3.2.4.</span> <span class="toc-text">存储保护</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"><span class="toc-number">3.3.</span> <span class="toc-text">3.1.3 覆盖与交换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF"><span class="toc-number">3.3.1.</span> <span class="toc-text">覆盖技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">3.3.2.</span> <span class="toc-text">交换技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">3.1.4 连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">3.4.1.</span> <span class="toc-text">单一连续分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">3.4.2.</span> <span class="toc-text">固定分区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">3.4.3.</span> <span class="toc-text">动态分区分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-5-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">3.1.5 动态分区分配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.1.</span> <span class="toc-text">首次适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.2.</span> <span class="toc-text">最佳适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.3.</span> <span class="toc-text">最坏适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.4.</span> <span class="toc-text">临近适应算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-6-%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.6.</span> <span class="toc-text">3.1.6 基本分页存储管理的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.6.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.6.2.</span> <span class="toc-text">如何实现地址的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E8%AF%A5%E9%A1%B5%E5%8F%B7%E5%AF%B9%E5%BA%94%E9%A1%B5%E9%9D%A2%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%B5%B7%E5%A7%8B%E5%9C%B0%E5%9D%80"><span class="toc-number">3.6.3.</span> <span class="toc-text">如何知道该页号对应页面在内存中的起始地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-7%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">3.7.</span> <span class="toc-text">3.1.7基本地址变换机构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.7.1.</span> <span class="toc-text">页表寄存器的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">3.7.2.</span> <span class="toc-text">地址变换过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-8-%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">3.8.</span> <span class="toc-text">3.1.8 具有快表的地址变换机构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">3.8.1.</span> <span class="toc-text">局部性原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E8%A1%A8%EF%BC%88TLB%EF%BC%89"><span class="toc-number">3.8.2.</span> <span class="toc-text">什么是快表（TLB）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%BF%AB%E8%A1%A8%E5%90%8E%EF%BC%8C%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">3.8.3.</span> <span class="toc-text">引入快表后，地址的变换过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-9-%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">3.9.</span> <span class="toc-text">3.1.9 两级页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.9.1.</span> <span class="toc-text">单级页表存在什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">3.9.2.</span> <span class="toc-text">两级页表的原理、逻辑地址结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%EF%BC%9F"><span class="toc-number">3.9.3.</span> <span class="toc-text">如何实现地址变换？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E9%97%AE%E9%A2%98%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%87%A0%E4%B8%AA%E7%BB%86%E8%8A%82"><span class="toc-number">3.9.4.</span> <span class="toc-text">两级页表问题需要注意的几个细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-10-%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.10.</span> <span class="toc-text">3.1.10 基本分段式存储管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E6%AE%B5"><span class="toc-number">3.10.1.</span> <span class="toc-text">什么是分段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AE%B5%E8%A1%A8"><span class="toc-number">3.10.2.</span> <span class="toc-text">什么是段表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">3.10.3.</span> <span class="toc-text">如何实现地址变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E3%80%81%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.10.4.</span> <span class="toc-text">分段、分页管理的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-11-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.11.</span> <span class="toc-text">3.1.11 段页式管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E3%80%81%E5%88%86%E6%AE%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.11.1.</span> <span class="toc-text">分页、分段管理方式中最大的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5-%E5%88%86%E9%A1%B5%E7%9A%84%E7%BB%93%E5%90%88%E2%80%94%E2%80%94%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.11.2.</span> <span class="toc-text">分段+分页的结合——段页式管理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8%E3%80%81%E9%A1%B5%E8%A1%A8"><span class="toc-number">3.11.3.</span> <span class="toc-text">段表、页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2-1"><span class="toc-number">3.11.4.</span> <span class="toc-text">如何实现地址变换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.12.</span> <span class="toc-text">3.2.1 虚拟内存的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E7%89%B9%E5%BE%81%E3%80%81%E7%BC%BA%E7%82%B9"><span class="toc-number">3.12.1.</span> <span class="toc-text">传统存储管理方式的特征、缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86-1"><span class="toc-number">3.12.2.</span> <span class="toc-text">局部性原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81"><span class="toc-number">3.12.3.</span> <span class="toc-text">虚拟内存的定义和特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="toc-number">3.12.4.</span> <span class="toc-text">如何实现虚拟内存技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.13.</span> <span class="toc-text">3.2.2 请求分页管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">3.13.1.</span> <span class="toc-text">请求分页存储管理与基本分页存储管理的主要区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">3.13.2.</span> <span class="toc-text">页表机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84"><span class="toc-number">3.13.3.</span> <span class="toc-text">缺页中断机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">3.13.4.</span> <span class="toc-text">地址变换机构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.14.</span> <span class="toc-text">3.2.3 页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95OPT"><span class="toc-number">3.14.1.</span> <span class="toc-text">最佳置换算法OPT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95FIFO"><span class="toc-number">3.14.2.</span> <span class="toc-text">先进先出置换算法FIFO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95LRU"><span class="toc-number">3.14.3.</span> <span class="toc-text">最近最久未使用置换算法LRU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95CLOCK"><span class="toc-number">3.14.4.</span> <span class="toc-text">时钟置换算法CLOCK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E5%9E%8B%E7%9A%84%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">3.14.5.</span> <span class="toc-text">改进型的时钟置换算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">3.15.</span> <span class="toc-text">3.2.4 页面分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E3%80%81%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">3.15.1.</span> <span class="toc-text">页面分配、置换策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">3.15.2.</span> <span class="toc-text">调入页面的时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E4%BD%95%E5%A4%84%E8%B0%83%E9%A1%B5"><span class="toc-number">3.15.3.</span> <span class="toc-text">从何处调页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8%EF%BC%88%E9%A2%A0%E7%B0%B8%EF%BC%89%E7%8E%B0%E8%B1%A1"><span class="toc-number">3.15.4.</span> <span class="toc-text">抖动（颠簸）现象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-number">3.15.5.</span> <span class="toc-text">工作集</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0"><span class="toc-number">4.</span> <span class="toc-text">第四章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E5%88%9D%E8%AF%86%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">4.1.1 初识文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">4.1.1.</span> <span class="toc-text">文件的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%86%85%E9%83%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%94%E8%AF%A5%E6%80%8E%E6%A0%B7%E7%BB%84%E7%BB%87%E8%B5%B7%E6%9D%A5%EF%BC%9F"><span class="toc-number">4.1.2.</span> <span class="toc-text">文件内部的数据应该怎样组织起来？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%86%85%E9%83%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%94%E8%AF%A5%E6%80%8E%E6%A0%B7%E7%BB%84%E7%BB%87%E8%B5%B7%E6%9D%A5%EF%BC%9F-1"><span class="toc-number">4.1.3.</span> <span class="toc-text">文件内部的数据应该怎样组织起来？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B9%8B%E9%97%B4%E5%BA%94%E8%AF%A5%E6%80%8E%E6%A0%B7%E7%BB%84%E7%BB%87%E8%B5%B7%E6%9D%A5%EF%BC%9F"><span class="toc-number">4.1.4.</span> <span class="toc-text">文件之间应该怎样组织起来？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E8%AF%A5%E5%90%91%E4%B8%8A%E6%8F%90%E4%BE%9B%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">4.1.5.</span> <span class="toc-text">操作系统应该向上提供哪些功能？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%98%E6%94%BE%E5%9C%A8%E5%A4%96%E5%AD%98%EF%BC%9F"><span class="toc-number">4.1.6.</span> <span class="toc-text">文件应该如何存放在外存？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">4.1.2 文件的逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.1.</span> <span class="toc-text">无结构文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%BB%93%E6%9E%84%E6%96%87%E4%BB%B6"><span class="toc-number">4.2.2.</span> <span class="toc-text">有结构文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-number">4.3.</span> <span class="toc-text">4.1.3 文件目录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">文件目录的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.2.</span> <span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9"><span class="toc-number">4.3.3.</span> <span class="toc-text">索引结点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">4.4.</span> <span class="toc-text">4.1.4 文件的物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%9D%97%E3%80%81%E7%A3%81%E7%9B%98%E5%9D%97"><span class="toc-number">4.4.1.</span> <span class="toc-text">文件块、磁盘块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">4.4.2.</span> <span class="toc-text">连续分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D"><span class="toc-number">4.4.3.</span> <span class="toc-text">链接分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D"><span class="toc-number">4.4.4.</span> <span class="toc-text">索引分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-5-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">4.5.</span> <span class="toc-text">4.1.5 文件存储空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%92%E5%88%86%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.5.1.</span> <span class="toc-text">存储空间的划分与初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">4.5.2.</span> <span class="toc-text">几种管理方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-6-%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.6.</span> <span class="toc-text">4.1.6 文件的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-number">4.6.1.</span> <span class="toc-text">创建文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">4.6.2.</span> <span class="toc-text">删除文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">4.6.3.</span> <span class="toc-text">读文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">4.6.4.</span> <span class="toc-text">写文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">4.6.5.</span> <span class="toc-text">打开文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-number">4.6.6.</span> <span class="toc-text">关闭文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-7-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">4.7.</span> <span class="toc-text">4.1.7 文件共享</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%EF%BC%88%E7%A1%AC%E9%93%BE%E6%8E%A5%EF%BC%89"><span class="toc-number">4.7.1.</span> <span class="toc-text">基于索引结点的共享方式（硬链接）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%AC%A6%E5%8F%B7%E9%93%BE%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%EF%BC%88%E8%BD%AF%E9%93%BE%E6%8E%A5%EF%BC%89"><span class="toc-number">4.7.2.</span> <span class="toc-text">基于符号链的共享方式（软链接）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-8-%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-number">4.8.</span> <span class="toc-text">4.1.8 文件保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A3%E4%BB%A4%E4%BF%9D%E6%8A%A4"><span class="toc-number">4.8.1.</span> <span class="toc-text">口令保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E4%BF%9D%E6%8A%A4"><span class="toc-number">4.8.2.</span> <span class="toc-text">加密保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">4.8.3.</span> <span class="toc-text">访问控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-9-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">4.9.</span> <span class="toc-text">4.1.9 文件系统的层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">4.10.</span> <span class="toc-text">4.2.1 磁盘的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E3%80%81%E7%A3%81%E9%81%93%E3%80%81%E6%89%87%E5%8C%BA%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.10.1.</span> <span class="toc-text">磁盘、磁道、扇区的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A3%81%E7%9B%98%E4%B8%AD%E8%AF%BB-x2F-%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">4.10.2.</span> <span class="toc-text">如何在磁盘中读&#x2F;写数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%98%E9%9D%A2%E3%80%81%E6%9F%B1%E9%9D%A2%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.10.3.</span> <span class="toc-text">盘面、柱面的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">4.10.4.</span> <span class="toc-text">磁盘的物理地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">4.10.5.</span> <span class="toc-text">磁盘的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.11.</span> <span class="toc-text">4.2.2 磁盘调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E7%A3%81%E7%9B%98%E8%AF%BB-x2F-%E5%86%99%E6%93%8D%E4%BD%9C%E9%9C%80%E8%A6%81%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">4.11.1.</span> <span class="toc-text">一次磁盘读&#x2F;写操作需要的时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.11.2.</span> <span class="toc-text">磁盘调度算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E5%87%8F%E5%B0%91%E7%A3%81%E7%9B%98%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.12.</span> <span class="toc-text">4.2.3 减少磁盘延迟时间的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%9B%BF%E7%BC%96%E5%8F%B7"><span class="toc-number">4.12.1.</span> <span class="toc-text">交替编号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E4%BD%8D%E5%91%BD%E5%90%8D"><span class="toc-number">4.12.2.</span> <span class="toc-text">错位命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.12.3.</span> <span class="toc-text">磁盘地址结构的设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">4.13.</span> <span class="toc-text">4.2.4 磁盘的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.13.1.</span> <span class="toc-text">磁盘初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E5%9D%97"><span class="toc-number">4.13.2.</span> <span class="toc-text">引导块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%8F%E5%9D%97%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">4.13.3.</span> <span class="toc-text">坏块的管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0"><span class="toc-number">5.</span> <span class="toc-text">第五章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-I-x2F-O%E8%AE%BE%E5%A4%87%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">5.1.1 I&#x2F;O设备的概念和分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFI-x2F-O%E8%AE%BE%E5%A4%87"><span class="toc-number">5.1.1.</span> <span class="toc-text">什么是I&#x2F;O设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E4%BD%BF%E7%94%A8%E7%89%B9%E6%80%A7%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.2.</span> <span class="toc-text">按使用特性分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.3.</span> <span class="toc-text">按传输速率分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2%E7%9A%84%E5%8D%95%E4%BD%8D%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.4.</span> <span class="toc-text">按信息交换的单位分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-I-x2F-O%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">5.1.2 I&#x2F;O控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">5.2.1.</span> <span class="toc-text">主要功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E6%88%90-1"><span class="toc-number">5.2.2.</span> <span class="toc-text">组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%AF%84%E5%AD%98%E5%99%A8%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.3.</span> <span class="toc-text">两种寄存器编址方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-I-x2F-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">5.1.3 I&#x2F;O控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.1.</span> <span class="toc-text">程序直接控制方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.2.</span> <span class="toc-text">中断驱动方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DMA%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.3.</span> <span class="toc-text">DMA方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.4.</span> <span class="toc-text">通道控制方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4-I-x2F-O%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.</span> <span class="toc-text">5.1.4 I&#x2F;O软件层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%B1%82%E8%BD%AF%E4%BB%B6"><span class="toc-number">5.4.1.</span> <span class="toc-text">用户层软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6"><span class="toc-number">5.4.2.</span> <span class="toc-text">设备独立性软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.4.3.</span> <span class="toc-text">设备驱动程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.4.4.</span> <span class="toc-text">中断处理程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-5-I-x2F-O%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.5.</span> <span class="toc-text">5.1.5 I&#x2F;O核心子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E5%8A%9F%E8%83%BD%E8%A6%81%E5%9C%A8%E9%82%A3%E4%B8%AA%E5%B1%82%E6%AC%A1%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.5.1.</span> <span class="toc-text">各功能要在那个层次实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-6-%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">5.6.</span> <span class="toc-text">5.1.6 假脱机技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF%EF%BC%8C%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">5.6.1.</span> <span class="toc-text">什么是脱机技术，脱机技术可以解决什么问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">5.6.2.</span> <span class="toc-text">假脱机技术的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%89%93%E5%8D%B0%E6%9C%BA%E5%8E%9F%E7%90%86"><span class="toc-number">5.6.3.</span> <span class="toc-text">共享打印机原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-7-%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">5.7.</span> <span class="toc-text">5.1.7 设备的分配与回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E6%97%B6%E5%BA%94%E8%80%83%E8%99%91%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-number">5.7.1.</span> <span class="toc-text">设备分配时应考虑的因素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D%E4%B8%8E%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">5.7.2.</span> <span class="toc-text">静态分配与动态分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.7.3.</span> <span class="toc-text">设备分配管理中的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.7.4.</span> <span class="toc-text">设备分配的步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E6%AD%A5%E9%AA%A4%E7%9A%84%E6%94%B9%E8%BF%9B%E6%96%B9%E6%B3%95"><span class="toc-number">5.7.5.</span> <span class="toc-text">设备分配步骤的改进方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-8-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-number">5.8.</span> <span class="toc-text">5.1.8 缓冲区管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.8.1.</span> <span class="toc-text">缓冲区的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BC%93%E5%86%B2"><span class="toc-number">5.8.2.</span> <span class="toc-text">单缓冲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="toc-number">5.8.3.</span> <span class="toc-text">双缓冲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2"><span class="toc-number">5.8.4.</span> <span class="toc-text">循环缓冲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-number">5.8.5.</span> <span class="toc-text">缓冲池</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Zhang Jian</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="xxxx"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>