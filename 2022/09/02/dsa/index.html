<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构与算法 | 个人文档</title><meta name="author" content="Zhang Jian"><meta name="copyright" content="Zhang Jian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="数据结构绪论 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 程序设计 &#x3D; 数据结构 + 算法  基本概念和术语数据描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。 比如我们现在常用的搜索引擎，一般会有网页、MP3、图片、视频等分类。MP3就是声音数据">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="http://example.com/2022/09/02/dsa/index.html">
<meta property="og:site_name" content="个人文档">
<meta property="og:description" content="数据结构绪论 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 程序设计 &#x3D; 数据结构 + 算法  基本概念和术语数据描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。 比如我们现在常用的搜索引擎，一般会有网页、MP3、图片、视频等分类。MP3就是声音数据">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/cover.jpeg">
<meta property="article:published_time" content="2022-09-02T07:44:00.000Z">
<meta property="article:modified_time" content="2022-12-14T03:32:44.016Z">
<meta property="article:author" content="Zhang Jian">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/cover.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/09/02/dsa/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-14 11:32:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">个人文档</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-02T07:44:00.000Z" title="发表于 2022-09-02 15:44:00">2022-09-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-14T03:32:44.016Z" title="更新于 2022-12-14 11:32:44">2022-12-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">80.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>275分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构与算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="数据结构绪论"><a href="#数据结构绪论" class="headerlink" title="数据结构绪论"></a>数据结构绪论</h2><blockquote>
<p>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</p>
<p>程序设计 &#x3D; 数据结构 + 算法</p>
</blockquote>
<h3 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h3><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p><strong>描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</strong></p>
<p>比如我们现在常用的搜索引擎，一般会有网页、MP3、图片、视频等分类。MP3就是声音数据，图片是图像数据，而网页其实指的就是全部数据的搜索，包括最重要的数字和字符等文字数据。</p>
<p>也就是说，这里说的数据，其实就是符号，而且这些符号必须具备两个前提：</p>
<ul>
<li>可以输入到计算机中。</li>
<li>能被计算机程序处理。</li>
</ul>
<p>对于整型、实型等数值类型，可以进行数值计算。</p>
<p>对于字符数据类型，就需要进行非数值的处理。而声音、图像、视频等其实是可以通过编码的手段编程字符数据来处理的。</p>
<h4 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h4><p><strong>组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</strong></p>
<p>比如，在人类中，什么是数据元素呀？当然是人了。</p>
<p>畜类呢？牛、马、羊、狗等动物就是禽类的数据元素。</p>
<h4 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h4><p><strong>一个数据元素可以由若干个数据项组成。</strong></p>
<p>比如人这样的数据元素，可以有眼、耳、鼻、嘴、手等这些数据项，也可以有姓名、年龄、性别等数据项，具体有哪些数据项，要视你做的系统来决定。</p>
<p><strong>数据项是数据不可分割的最小单位</strong>。把数据项定义为最小单位是为了更好地解决问题。但真正讨论问题是，数据元素才是数据结构中建立数据模型的着眼点。就像讨论一部电影是，是讨论这部电影角色这样的“数据元素”，而不是针对这个角色的姓名或年龄这样的“数据项”去研究分析。</p>
<h4 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h4><p><strong>是性质相同的数据元素的集合，是数据的子集。</strong></p>
<p>性质相同指数据元素具有相同数量和类型的数据项，比如，人都有姓名、生日、性别等相同的数据项。</p>
<p>既然数据对象是数据的子集，在实际应用中，处理的数据元素通常具有相同性质，在不产生混淆的情况下，我们豆浆数据对象简称为数据。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>结构，简单的理解就是关系，比如分子结构，就是说组成分子的原子之间的排列方式。严格点说，结构是指各个组成部分相互搭配和排列的方式。在现实世界中，<strong>不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构。</strong></p>
<blockquote>
<p>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</p>
</blockquote>
<p>在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。</p>
<h3 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h3><p>按照视点的不同，把数据结构分为逻辑结构和物理结构。</p>
<h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p><strong>是指数据对象中数据元素之间的相互关系</strong>。逻辑结构分为以下四种：</p>
<ol>
<li><p>集合结构</p>
<p> <strong>集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系</strong>。各个数据元素是“平等”的，它们的共同属性是“同属于一个集合”。数据结构中的集合关系就类似于数学中的集合。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84.png" alt="集合结构"></p>
</li>
<li><p>线性结构</p>
<p> <strong>线性结构中的数据元素之间是一对一的关系</strong>。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.png" alt="线性结构"></p>
</li>
<li><p>树形结构</p>
<p> <strong>树形结构中的数据元素之间存在一种一对多的层次关系</strong>。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.png" alt="树形结构"></p>
</li>
<li><p>图形结构</p>
<p> <strong>图形结构的数据元素是多对多的关系</strong>。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%9B%BE%E5%BD%A2%E7%BB%93%E6%9E%84.png" alt="图形结构"></p>
</li>
</ol>
<p>在用示意图表示数据的逻辑结构时，要注意两点：</p>
<ul>
<li>将每个数据元素看作一个结点，用圆圈表示。</li>
<li>元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，那么用带箭头的连线表示。</li>
</ul>
<h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p><strong>也叫存储结构，是指数据的逻辑结构在计算机中的存储形式</strong>。</p>
<p>数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。存储器主要是针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。</p>
<p>数据的存储结构应正确反应数据元素之间的逻辑关系，这才是最为关键的，如何存储数据元素之间的逻辑关系，是实现物理结构的重点和难点。</p>
<p>数据元素的存储结构形式有两种：顺序结构和链式结构。</p>
<ol>
<li><p>顺序存储结构</p>
<p> <strong>是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的</strong>。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="顺序存储结构"></p>
<p> 这种存储结构其实很简单，就是排队占位。大家都按顺序排好，每个人站一段空间，大家谁也别插谁的队。数组就是这样的顺序存储结构。当你告诉计算机，你要建立一个有9个整型数据的数组时，计算机就在内存中找了片空地，按照一个整型所站位置的大小乘9，开辟一段连续的空间，于是第一个数组数据就放在第一个位置，第二个数据放在第二个，这样一次摆放。</p>
</li>
<li><p>链式存储结构</p>
<p> 但是并不是一直都像顺序存储结构这样简单和有规律，实际上，总会有人插队，也会有人要上厕所、有人会放弃排队。所以这个队伍当中会添加新成员，也有可能会去掉老元素，整个结构时刻都处于变化中。显然，面对这样时常要变化的结构，顺序存储结构是不科学的。</p>
<p> 现在如银行、医院等地方，设置了排队系统，也就是每个人去了，先领一个号，等着叫号，叫到时去办理业务或看病。在等待的时候，你爱在哪就在哪，可以坐着、站着或者走动，甚至出去逛一圈，只要及时回来就行。你关注的是前一个号有没有被叫到，叫到了，下一个就轮到了。、</p>
<p> <strong>链式存储结构是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的</strong>。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关数据元素的位置。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="链式存储结构"></p>
<p> 显然，链式存储结构灵活多了，数据存在哪里不重要，只要有一个指针存放了相应的地址就能找到它了。</p>
<p> 逻辑结构是面向问题的，而物理结构就是面向计算机的，其基本的目标就是将数据及其逻辑关系存储到计算机的内存中。</p>
</li>
</ol>
<h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><strong>是指一组性质相同的值的集合及定义在此集合上的一些操作的总称</strong>。</p>
<p>数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。</p>
<p>在计算机中，内存也不是无限大的，如果要计算一个如 1 + 1 &#x3D; 2、3 + 5 &#x3D; 8 这样的整型数字的加减乘除运算，显然不需要开辟很大的适合小数甚至字符运算的内存空间。于是计算机的研究者们就考虑，要对数据进行分类，分出来多种数据类型。</p>
<p>在C语言中，按照取值的不同，数据类型可以分为两类：</p>
<ul>
<li>原子类型：是<strong>不可以再分解的基本类型</strong>，包括整型、实型、字符型等。</li>
<li>结构类型：由<strong>若干个类型组合而成，是可以再分解的</strong>。例如，整型数组是由若干整型数据组成。</li>
</ul>
<p>比如，在C语言中变量声明 int a, b, 这就意味着，再给变量 a 和 b 赋值时不能超出 int 的取值范围，变量 a 和 b 之间的运算只能是 int 类型所允许的运算。</p>
<p>因为不同的计算机又不同的硬件系统，这就要求程序语言最终通过编译器或解释器转换成底层语言，如汇编语言甚至是通过机器语言的数据类型来实现的。可事实上，高级语言的编程者不管最终程序运行在什么计算机上，他的目的就是为了实现两个整型数字的运算，如 a + b、a - b、 a × b、a &#x2F; b 等，他才不关心在计算机内部是如何表示的，也不想知道 CPU 为了实现 1 + 2 进行几次开关操作，这些操作是如何实现的，对高级语言开发者来讲根本不重要。于是我们就会考虑，无论什么计算机、什么计算机语言，大都会面临着如整数运算、实数运算、字符运算等操作，我们可以考虑把它们都抽象出来。</p>
<p><strong>抽象是指抽取出事物具有的普遍性的本质</strong>。它是抽出问题的特征而忽略非本质的细节，是对具体事务的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。</p>
<h4 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><p>对已有的数据类型进行抽象，就有了抽象数据类型。</p>
<p><strong>抽象数据类型(Abstract Data Type, ADT)：是指一个数字模型及定义在该模型上的一组操作</strong>。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</p>
<p>比如，各个计算机，不管是大型机、小型机、PC、平板电脑、PDA，甚至智能手机都拥有“整数”类型，也需要整数间的运算，那么整型其实就是一个抽象数据类型，尽管它在上面提到的这些在不同计算机中实现方法上可能不一样，但由于其定义的数学特性相同，在计算机编程者看来，他们都是相同的。因此，<strong>“抽象”的意义在于数据类型的数学抽象特性</strong>。</p>
<p>而且，抽象数据类型不仅仅指那些已经定义并实现的数据类型，还可以是计算机编程者在设计软件程序时自己定义的数据类型，比如我们编写关于计算机绘图或者地图类的软件系统，经常都会用到坐标。也就是说，总是有成对出现的 x 和 y ，在 3D 系统中还有 z 出现，既然这三个整型数字始终在一起出现，我们就定义一个叫 ponit 的抽象数据类型，它有 x、y、z 三个整型变量，这样我们很方便地操作一个 point 数据变量就能知道这一点的坐标了。</p>
<p>事实上，<strong>抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性</strong>。抽象数据类型把实际生活中的问题分解为多个规模小且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。</p>
<p>抽象数据类型的标准格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名</span><br><span class="line">Data</span><br><span class="line">  	抽象元素之间逻辑关系的定义</span><br><span class="line">Operation</span><br><span class="line">  	操作 <span class="number">1</span></span><br><span class="line">  			初始条件</span><br><span class="line">  			操作结果描述</span><br><span class="line">  	操作 <span class="number">2</span></span><br><span class="line">  			……</span><br><span class="line">  	操作 n</span><br><span class="line">  			……</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>用图表示数据结构的相关概念</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5.png" alt="数据结构概念"></p>
<p>由这些概念，给出了数据结构的定义：数据结构是相互之间存在一种或多种特定关系的数据元素的集合。同样是结构，从不同的角度来讨论，会有不同的分类。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88.png" alt="数据元素集合"></p>
<p>最后，还介绍了抽象数据类型及它的描述方法。		</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote>
<p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p>
</blockquote>
<h3 id="两种算法的比较"><a href="#两种算法的比较" class="headerlink" title="两种算法的比较"></a>两种算法的比较</h3><p>要求写一个求 1 + 2 + 3 + …… + 100 结果的程序。</p>
<p>常规方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  	sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br></pre></td></tr></table></figure>

<p>伟大数学家高斯童年方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;</span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br></pre></td></tr></table></figure>

<p>高斯所用方法相当于另一种等差数列的算法，不仅仅可以用于计算 1 到 100，就是加到 一千，一万（需要更改整型变量类型为长整型，否则会溢出），也很快速。但是用常规循环方式，计算机要循环一千，一万次的加法运算。</p>
<h3 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h3><p>如今普遍认可的对算法的定义是：<strong>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</strong></p>
<p>算法定义中，提到了指令，指令能被人或机器等计算装置执行。它可以是计算机指令，也可以是我们平时的语言文字。</p>
<p>为了解决某个或某类问题，需要把指令表示成一定的操作序列，操作序列包括一组操作，每一个操作都完成特定的功能，这就是算法了。</p>
<h3 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h3><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>输入和输出特性比较容易理解，<strong>算法具有零个或多个输入</strong>。尽管对于绝大多数算法来说，输入参数都是必要的，但对于个别情况，如打印“Hello World”这样的代码，不需要任何输入参数，因此算法的输入可以是零个。<strong>算法至少有一个或多个输出</strong>，算法是一定需要输出的，不需要输出，你用这个算法干嘛？输出的形式可以是打印输出，也可以是返回一个或多个值等。</p>
<h4 id="有穷性"><a href="#有穷性" class="headerlink" title="有穷性"></a>有穷性</h4><p><strong>指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成</strong>。现实中经常会写出死循环的代码，这就是不满足有穷性。当然这里有穷的概念并不是纯数学意义的，而是在实际应用当中合理的、可以接受的“有边界”。</p>
<h4 id="确定性"><a href="#确定性" class="headerlink" title="确定性"></a>确定性</h4><p><strong>算法的每一步骤都具有确定的含义，不会出现二义性</strong>。算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义。</p>
<h4 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h4><p><strong>算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成</strong>。可行性意味着算法可以转换为程序上机运行，并得到正确的结果。尽管在目前计算机界也存在那种没有实现的极为复杂的算法，不是说理论上不能实现，而是因为过于复杂，我们当前的编程方法、工具和大脑限制了这个工作，不过这都是理论研究领域的问题，不属于我们现在要考虑的范围。</p>
<h3 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h3><h4 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h4><p><strong>算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案</strong>。</p>
<p>但是算法的“正确”通常在用法上有很大的差别，大体分为以下四个层次。</p>
<ol>
<li>算法程序没有语法错误。</li>
<li>算法程序对于合法的输入数据能够产生满足要求的输出结果。</li>
<li>算法程序对于非法的输入数据能够得出满足规格说明的结果。</li>
<li>算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。</li>
</ol>
<p>对于这四层含义，层次 1 要求最低，但是仅仅没有语法错误实在谈不上是好算法。而层次 4 是最困难的，我们几乎不可能逐一验证所有的输入都得到正确的结果。</p>
<p>因此算法的正确性在大部分情况下都不可能用程序来证明，而是用数学方法证明的。证明一个复杂算法在所有层次上都是正确的，代价非常昂贵。所以一般情况下，我们把层次 3 作为一个算法是否正确的标准。</p>
<h4 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h4><p><strong>算法设计的另一目的就是为了便于阅读、理解和交流</strong>。</p>
<p>可读性高有助于人们理解算法，晦涩难懂的算法往往隐含错误，不易被发现，并且难于调试和修改。我们写代码的目的，一方面是为了让计算机执行，但还有一个重要的目的是为了便于他人阅读，让人理解和交流，自己将来也可能阅读，如果可读性不好，时间长了自己都不知道写了些什么。可读性是算法好坏很重要的标志。</p>
<h4 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h4><p>一个好的算法还应该能对输入数据不合法的情况做合适的处理。比如输入的时间或者距离不应该是负数等。</p>
<p><strong>当输入数据不合法时，算法也能做出相关处理，而不是产生异常或命名奇妙的结果</strong>。</p>
<h4 id="时间效率高和存储量低"><a href="#时间效率高和存储量低" class="headerlink" title="时间效率高和存储量低"></a>时间效率高和存储量低</h4><p>好的算法还应该具备时间效率高和存储量低的特点。</p>
<p>时间效率指的是算法的执行时间，对于同一个问题，如果有多个算法能够解决，执行时间短的算法效率高，执行时间长的效率低。存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间。<strong>设计算法应该尽量满足时间效率高和存储量低的需求</strong>。在生活中，人们都希望花最少的钱，用最短的时间，办最大的事，算法也是一样的思想，最好用最少的存储空间，花最少的时间，办成同样的事就是好的算法。</p>
<p>综上，好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征。</p>
<h3 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h3><h4 id="事后统计方法"><a href="#事后统计方法" class="headerlink" title="事后统计方法"></a>事后统计方法</h4><p><strong>这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低</strong>。</p>
<p>缺点：</p>
<ul>
<li>必须依据算法事先编制好程序，这通常需要花费大量的时间和精力。</li>
<li>时间的比较依赖计算机硬件和软件等环境因素，有时会掩盖算法本身的优劣。</li>
<li>算法的测试数据设计困难，并且程序的运行时间往往还与测试数据的规模有很大关系，效率高的算法在小的测试数据面前往往得不到提现。</li>
</ul>
<h4 id="事前分析估算法"><a href="#事前分析估算法" class="headerlink" title="事前分析估算法"></a>事前分析估算法</h4><p><strong>在计算机程序编制前，依据统计方法对算法进行估算</strong>。</p>
<p>一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：</p>
<ol>
<li>算法采用的策略、方法。</li>
<li>编译产生的代码质量。</li>
<li>问题的输入规模。</li>
<li>机器执行指令的速度。</li>
</ol>
<p>第 1 条时算法好坏的根本，第 2 条要由软件来支持，第 4 条要看硬件性能。抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间，<strong>依赖于算法的好坏和问题的输入规模</strong>。所谓<strong>问题输入规模是指输入量的多少</strong>。</p>
<p>比较两种求和算法：</p>
<p>第一种：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;	<span class="comment">// 执行 1 次</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;	<span class="comment">// 执行了 n + 1 次</span></span><br><span class="line">  	sum = sum + i;			<span class="comment">// 执行 n 次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);			<span class="comment">// 执行 1 次</span></span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;	<span class="comment">// 执行 1 次</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;		<span class="comment">// 执行 1 次</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);			<span class="comment">// 执行 1 次</span></span><br></pre></td></tr></table></figure>

<p>显然，第一种算法，执行了 1 + (n + 1) + n + 1 &#x3D; 2n + 3 次；而第二种算法，是 1 + 1 + 1 &#x3D; 3 次。事实上，两个算法的第一条和最后一条语句是一样的，所以我们关注的代码其实是中间的那部分，我们把循环看做一个整体，忽略头尾循环判断的开销，那么这两个算法其实就是 n 次与 1 次的差距。算法好坏显而易见。</p>
<p>我们不关心编写程序所用的程序设计语言是什么，也不关心这些程序将跑在什么样的计算机中，我们只关心它所实现的算法。这样，不计那些循环索引的递增和循环终止条件、变量声明、打印结果等操作，<strong>最终，在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤</strong>。</p>
<h3 id="函数的渐近增长"><a href="#函数的渐近增长" class="headerlink" title="函数的渐近增长"></a>函数的渐近增长</h3><p>判断算法 A 和算法 B 哪个更好。假设两个算法的输入规模都是 n，算法 A 要做 2n + 3 次操作，你可以理解为先有一个 n 次的循环，执行完成后，再有一个 n 次循环，最后有三次赋值或运算，共 2n + 3 次操作。算法 B 要做 3n + 1 次操作。</p>
<table>
<thead>
<tr>
<th align="center">次数</th>
<th align="center">算法 A (2n + 3)</th>
<th align="center">算法A’ (2n)</th>
<th align="center">算法 B (3n + 1)</th>
<th align="center">算法 B’ (3n)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">n &#x3D; 1</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">n &#x3D; 2</td>
<td align="center">7</td>
<td align="center">4</td>
<td align="center">7</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">n &#x3D; 3</td>
<td align="center">9</td>
<td align="center">6</td>
<td align="center">10</td>
<td align="center">9</td>
</tr>
<tr>
<td align="center">n &#x3D; 10</td>
<td align="center">23</td>
<td align="center">20</td>
<td align="center">31</td>
<td align="center">30</td>
</tr>
<tr>
<td align="center">n &#x3D; 100</td>
<td align="center">203</td>
<td align="center">200</td>
<td align="center">301</td>
<td align="center">300</td>
</tr>
</tbody></table>
<p>当 n &#x3D; 1 时，算法 A 效率不如算法 B (次数比算法 B 要多一次)。而当 n &#x3D; 2 时，两者效率相同；当 n &gt; 2 时，算法 A 就开始优于算法 B 了，随着 n 的增加，算法 A比算法 B 越来越好了(执行的次数比 B 要少)。于是可以得出结论，算法 A 总体上要好过算法 B。</p>
<p>输入规模 n 在没有限制的情况下，只要超过一个数值 N，这个函数就总是大于另一个函数，我们称函数时渐近增长的。</p>
<blockquote>
<p>函数的渐近增长：给定两个函数 f(n) 和 g(n)，如果存在一个整数 N, 使得对于所有的 n &gt; N，f(n) 总是比 g(n) 大，那么，就说 f(n) 的增长渐近快于 g(n)。</p>
</blockquote>
<p>从中可以发现，随着 n 的增大，后面的 +3 还是 +1 其实是不影响最重的算法变化的，例如算法 A’ 与算法 B’，所以，<strong>可以忽略这些加法常数</strong>。</p>
<p>第二个例子，算法 C 是 4n + 8，算法 D 是 2n<sup>2</sup> + 1</p>
<table>
<thead>
<tr>
<th align="center">次数</th>
<th align="center">算法 C (4n + 8)</th>
<th align="center">算法C’ (n)</th>
<th align="center">算法 D (2n<sup>2</sup> + 1)</th>
<th align="center">算法 D’ (n<sup>2</sup>)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">n &#x3D; 1</td>
<td align="center">12</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">n &#x3D; 2</td>
<td align="center">16</td>
<td align="center">2</td>
<td align="center">9</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">n &#x3D; 3</td>
<td align="center">20</td>
<td align="center">3</td>
<td align="center">19</td>
<td align="center">9</td>
</tr>
<tr>
<td align="center">n &#x3D; 10</td>
<td align="center">48</td>
<td align="center">10</td>
<td align="center">201</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">n &#x3D; 100</td>
<td align="center">408</td>
<td align="center">100</td>
<td align="center">20001</td>
<td align="center">10000</td>
</tr>
<tr>
<td align="center">n &#x3D; 1000</td>
<td align="center">4008</td>
<td align="center">1000</td>
<td align="center">2000001</td>
<td align="center">1000000</td>
</tr>
</tbody></table>
<p>当 n ≤ 3 的时候，算法 C 要差于算法 D (因为算法 C 次数比较多)，但当 n &gt; 3后，算法 C 的优势就越来越优于算法 D 了，到后来更是远远胜过。而当后面的常数去掉后，我们发现其实结果没有发生改变。甚至哪怕去掉与 n 相乘的常数，这样的结果也没发生改变，算法 C’ 的次数随着 n 的增长，还是远小于算法 D’。也就是说，<strong>与最高次项相乘的常数并不重要</strong>。</p>
<p>第三个例子。算法 E 是 2n<sup>2</sup> + 3n + 1，算法 F 是 2n<sup>3</sup> + 3n + 1。</p>
<table>
<thead>
<tr>
<th align="center">次数</th>
<th align="center">算法 E (2n<sup>2</sup> + 3n + 1)</th>
<th align="center">算法E’ (n<sup>2</sup>)</th>
<th align="center">算法 F (2n<sup>3</sup> + 3n + 1)</th>
<th align="center">算法 F’ (n<sup>3</sup>)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">n &#x3D; 1</td>
<td align="center">6</td>
<td align="center">1</td>
<td align="center">6</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">n &#x3D; 2</td>
<td align="center">15</td>
<td align="center">4</td>
<td align="center">23</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">n &#x3D; 3</td>
<td align="center">28</td>
<td align="center">9</td>
<td align="center">64</td>
<td align="center">27</td>
</tr>
<tr>
<td align="center">n &#x3D; 10</td>
<td align="center">231</td>
<td align="center">100</td>
<td align="center">2031</td>
<td align="center">1000</td>
</tr>
<tr>
<td align="center">n &#x3D; 100</td>
<td align="center">20301</td>
<td align="center">10000</td>
<td align="center">2000301</td>
<td align="center">1000000</td>
</tr>
</tbody></table>
<p>当 n &#x3D; 1的时候，算法 E 与算法 F 结果相同，但当 n &gt; 1后，算法 E 的优势就要开始优于算法 F，随着 n 的增大，差异非常明显。通过观察发现，<strong>最高次项的指数大的，函数随着 n 的增大，结果也会变得增长特别快</strong>。</p>
<p>最后一个例子，算法 G 是 2n<sup>2</sup>，算法 H 是 3n + 1，算法 I 是 2n<sup>2</sup> + 3n + 1 。</p>
<table>
<thead>
<tr>
<th align="center">次数</th>
<th align="center">算法 G (2n<sup>2</sup>)</th>
<th align="center">算法H (3n + 1)</th>
<th align="center">算法 I (2n<sup>2</sup> + 3n + 1)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">n &#x3D; 1</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">n &#x3D; 2</td>
<td align="center">8</td>
<td align="center">7</td>
<td align="center">15</td>
</tr>
<tr>
<td align="center">n &#x3D; 5</td>
<td align="center">50</td>
<td align="center">16</td>
<td align="center">66</td>
</tr>
<tr>
<td align="center">n &#x3D; 10</td>
<td align="center">200</td>
<td align="center">31</td>
<td align="center">231</td>
</tr>
<tr>
<td align="center">n &#x3D; 100</td>
<td align="center">20000</td>
<td align="center">301</td>
<td align="center">20301</td>
</tr>
<tr>
<td align="center">n &#x3D; 1000</td>
<td align="center">2000000</td>
<td align="center">3001</td>
<td align="center">2003001</td>
</tr>
<tr>
<td align="center">n &#x3D; 10000</td>
<td align="center">200000000</td>
<td align="center">30001</td>
<td align="center">200030001</td>
</tr>
<tr>
<td align="center">n &#x3D; 100000</td>
<td align="center">20000000000</td>
<td align="center">300001</td>
<td align="center">20000300001</td>
</tr>
<tr>
<td align="center">n &#x3D; 1000000</td>
<td align="center">2000000000000</td>
<td align="center">3000001</td>
<td align="center">2000003000001</td>
</tr>
</tbody></table>
<p>当 n 的值越来越大时，3n + 1 已经没法和 2n<sup>2</sup> 的结果相比较，最终几乎可以忽略不计。也就是说，随着 n 值变得非常大以后，算法 G 其实已经很趋近于算法 I。于是我们可以得到这样一个结论，<strong>一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项(最高阶项)的阶数</strong>。</p>
<p>判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的。根据几个例子，如果可以对比这几个算法的关键执行次数函数的渐近增长性，基本就可以分析出：<strong>某个算法，随着 n 的增大，它会越来越优于另一个算法，或者越来越差于另一算法</strong>。这其实就是事前估算方法的理论依据，通过算法时间复杂度来估算算法时间效率。</p>
<h3 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h3><h4 id="算法时间复杂度定义"><a href="#算法时间复杂度定义" class="headerlink" title="算法时间复杂度定义"></a>算法时间复杂度定义</h4><blockquote>
<p>在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间量度，计作：T(n) &#x3D; O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函数。</p>
</blockquote>
<p>这样用大写 O() 来体现算法时间复杂度的方法，我们称之为大 O 记法。</p>
<p>一般情况下，随着 n 的增大，T(n) 增长最慢的算法为最优算法。</p>
<p>显然，由此算法时间复杂度的定义可知，我们的三个求和算法的时间复杂度分别为 O(n)，O(1)，O(n<sup>2</sup>)。O(1) 叫作常数阶、O(n) 叫作线性阶、O(n<sup>2</sup>)叫作平方阶。</p>
<h4 id="推导大-O-阶方法"><a href="#推导大-O-阶方法" class="headerlink" title="推导大 O 阶方法"></a>推导大 O 阶方法</h4><ol>
<li>用常数 1 取代运行时间中的所有加法常数。</li>
<li>在修改后的运行次数函数中，只保留最高阶项。</li>
<li>如果最高阶项存在且不是 1，则去除与这个项相乘的常数。得到的结果就是大 O 阶。</li>
</ol>
<h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4><p>首先顺序结构的时间复杂度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;	<span class="comment">// 执行 1 次</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;		<span class="comment">// 执行 1 次</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);			<span class="comment">// 执行 1 次</span></span><br></pre></td></tr></table></figure>

<p>这个算法的运行次数是 f(n) &#x3D; 3。根据推到大 O 阶的方法，第一步就是把常数项 3 改为 1。在保留最高阶项时，发现更本没有最高阶项，所以这个算法的时间复杂度为 O(1)。</p>
<p>对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着 n 的变大而发生改变，所以单纯的分支结构(不包含在循环结构中)，其时间复杂度也是 O(1)。</p>
<h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><p>线性阶的循环结构会复杂很多。要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集运行的次数。因此，我们要<strong>分析算法的复杂度，关键就是要分析循环结构的运行情况</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码，它的循环的时间复杂度为 O(n)，因为循环体中的代码需要执行 n 次。</p>
<h4 id="常数阶-1"><a href="#常数阶-1" class="headerlink" title="常数阶"></a>常数阶</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt; n) &#123;</span><br><span class="line">  count = count * <span class="number">2</span>;</span><br><span class="line">  <span class="comment">/* 时间复杂度为 O(1) 的程序步骤序列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于每次 count 乘以 2 之后，就距离 n 更近了一分。也就是说，有多少个 2 相乘后大于 n，则会退出循环。由 2<sup>x</sup> &#x3D; n 得到 x &#x3D; log<sub>2</sub>n。所以这个循环的时间复杂度为O(logn)。</p>
<h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个循环嵌套，它的内循环的时间复杂度为 O(n)，外层的循环，不过是内部这个时间复杂度为 O(n) 的语句，在循环 n 次。所以这段代码的时间复杂度为 O(n<sup>2</sup>)。</p>
<p>如果外循环的循环次数改为了 m，时间复杂度就变为 O(m × n)。</p>
<h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><table>
<thead>
<tr>
<th align="center">执行次数函数</th>
<th align="center">阶</th>
<th align="center">非正式术语</th>
</tr>
</thead>
<tbody><tr>
<td align="center">12</td>
<td align="center">O(1)</td>
<td align="center">常数阶</td>
</tr>
<tr>
<td align="center">2n + 3</td>
<td align="center">O(n)</td>
<td align="center">线性阶</td>
</tr>
<tr>
<td align="center">3n<sup>2</sup> + 2n + 1</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">平方阶</td>
</tr>
<tr>
<td align="center">5log<sub>2</sub>n + 20</td>
<td align="center">O(logn)</td>
<td align="center">对数阶</td>
</tr>
<tr>
<td align="center">2n + 3nlog<sub>2</sub>n + 19</td>
<td align="center">O(nlogn)</td>
<td align="center">nlogn阶</td>
</tr>
<tr>
<td align="center">6n<sup>3</sup> + 2n<sup>2</sup> + 3n + 4</td>
<td align="center">O(n<sup>3</sup>)</td>
<td align="center">立方阶</td>
</tr>
<tr>
<td align="center">2<sup>n</sup></td>
<td align="center">O(2<sup>n</sup>)</td>
<td align="center">指数阶</td>
</tr>
</tbody></table>
<p>常用的时间复杂度所含飞的时间从小到大依次是：</p>
<p><strong>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</strong></p>
<blockquote>
<p>O(n<sup>3</sup>)，过大的 n 会使得结果变得不现实。O(2<sup>n</sup>) 和 O(n!) 等除非是很小的 n 值，否则哪怕 n 只是 100，都是噩梦般的运行时间。所以这种不切实际的算法时间复杂度，一般不讨论。</p>
</blockquote>
<h3 id="最坏情况与平均情况"><a href="#最坏情况与平均情况" class="headerlink" title="最坏情况与平均情况"></a>最坏情况与平均情况</h3><p>查找一个有 n 个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度为 O(1)，但也有可能这个数字就在最后一个位置上待着，那么算法的时间复杂度就是O(n)，这是最坏的一种情况了。</p>
<p><strong>最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间</strong>。</p>
<p>而平均运行时间也就是从概率的角度看，这个数字在每一个位置的可能性是相同的，所以平均的查找时间为 n &#x2F; 2 次后发现这个目标元素。</p>
<p><strong>平均运行时间是所有情况中最有意义的，因为它是期望的运行时间</strong>。也即是说，我们运行一段程序代码时，是希望看到平均运行时间。可现实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。</p>
<p>对算法的分析，一种方法时计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。另一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。<strong>一般在没有特殊说明的情况下，都是指最坏时间复杂度</strong>。</p>
<h3 id="算法空间复杂度"><a href="#算法空间复杂度" class="headerlink" title="算法空间复杂度"></a>算法空间复杂度</h3><p>我们在写代码时，完全可以用空间来换取时间，比如说，要判断某某年是不是闰年，你可能会花一点心思写了一个算法，而且由于是一个算法，也就意味着，每次给一个年份，都是要通过计算得到是否是闰年的结果。还有另一个办法就是，事先建立一个有 2050 个元素的数组(年数略比现实多一点)，然后把所有的年份按下标的数字对应，如果是闰年，此数组项的值就是 1，如果不是值为 0。这样，所谓的判断某一年是否是闰年，就变成了查找这个数组的某一项的值是多少的问题。此时，我们运算是最小化了，但是硬盘上或者内存中需要存储这个 2050 个 0 和 1。</p>
<p>这是通过一笔空间上的开销来换取计算时间的小技巧。到底哪一个好，其实要看用在什么地方。</p>
<p><strong>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) &#x3D; O(f(n))，其中，n 为问题的规模，f(n) 为语句所占存储空间的函数。</strong></p>
<p>一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为 O(1)。</p>
<p>通常，我们都使用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求。当不用限定词地使用“复杂度”时，通常都是指时间复杂度。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>算法的定义：算法时解决特定问题求解步骤的描述，在计算机中为指令的有限序列，并且每条指令表示一个或多个操作。</p>
<p>算法的特性：有穷性、确定性、可行性、输入、输出</p>
<p>算法的设计的要求：正确性、可读性、健壮性、高效率和低存储量需求</p>
<p>算法的度量方法：事后统计方法(不科学、不准确)、事前分析估算方法</p>
<p>函数的渐近增长：给定两个函数 f(n) 和 g(n)，如果存在一个整数 N, 使得对于所有的 n &gt; N，f(n) 总是比 g(n) 大，那么，就说 f(n) 的增长渐近快于 g(n)。于是我们可以得出一个结论，判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的，如果我们可以对比算法的关键执行次数函数的渐近增长性，基本就可以分析出：某个算法，随着 n 的变大，它会越来越优于另一算法，或者越来越差于另一算法。</p>
<p>推导大 O 阶：</p>
<ol>
<li>用常数 1 取代运行时间中的所有加法常数。</li>
<li>在修改后的运行次数函数中，只保留最高阶项。</li>
<li>如果最高阶项存在且不是 1，则去除与这个项相乘的常数。得到的结果就是大 O 阶。</li>
</ol>
<p>常见的时间复杂度所耗时间的大小排列：</p>
<p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</p>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><blockquote>
<p>零个或多个数据元素的有限序列。</p>
</blockquote>
<p>首先它是一个序列。也就是说，元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继。</p>
<p>然后，线性表强调是有限的，元素个数当然也是有限的。事实上，在计算机中处理的对象都是有限的，那种无限的数据，只存在于数学的概念中。</p>
<p>用数学语言来进行定义：<strong>若将线性表记为 (a<sub>1</sub>, ···, a<sub>i-1</sub>, a<sub>i</sub>, a<sub>i+1</sub>, ···, a<sub>n</sub>), 则表中  a<sub>i-1</sub> 领先于 a<sub>i</sub>，a<sub>i</sub> 领先于 a<sub>i+1</sub>，称 a<sub>i+1</sub> 是 a<sub>i</sub> 的直接前驱元素，a<sub>i+1</sub> 是 a<sub>i</sub> 的直接后继元素。当 i &#x3D; 1，2，……，n-1 时，a<sub>i</sub> 有且仅有一个直接后继，当 i &#x3D; 2，3，……，n 时，a<sub>i</sub> 有且仅有一个直接前驱。</strong> 。</p>
<p><strong>所以线性表元素的个数 n (n ≥ 0) 定义为线性表的长度，当 n &#x3D; 0 时，称为空表</strong>。</p>
<p>在非空表中的每个数据元素都有一个确定的位置，如 a<sub>i</sub> 是第一个数据元素，a<sub>n</sub> 是最后一个数据元素，a<sub>i</sub> 是第 i 个数据元素，称 i 为数据元素 a<sub>i</sub> 在线性表中的位序。</p>
<h3 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT	线性表(<span class="built_in">list</span>)</span><br><span class="line">Data</span><br><span class="line">  	线性表的数据对象集合为&#123;a₁, a₂, ···, an&#125;，每个元素的类型均为 DataType。其中，除第一个元素 a₁ 外，每一个元素有且只有一个直接前驱元素，除了最后一个元素 an 外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。</span><br><span class="line">Operation</span><br><span class="line">  	<span class="title function_">InitList</span><span class="params">(*L)</span>:	初始化操作，建立一个空的线性表L</span><br><span class="line">  	ListEmpty（L):	若线性表为空，返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span></span><br><span class="line">    <span class="title function_">ClearList</span><span class="params">(*L)</span>:	将线性表清空</span><br><span class="line">    <span class="title function_">GetElem</span><span class="params">(L, i, *e)</span>:	将线性表 L 中的第 i 个位置元素值返回给 e</span><br><span class="line">    <span class="title function_">LocateElem</span><span class="params">(L, e)</span>:	在线性表 L 中查找于给定值 e 相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回 0 表示失败</span><br><span class="line">    <span class="title function_">ListInsert</span><span class="params">(*L, i, e)</span>:	在线性表 L 中的第 i 个位置插入新元素 e</span><br><span class="line">    <span class="title function_">ListDelete</span><span class="params">(*L, i, *e)</span>:	删除线性表 L 中第 i 个位置元素，并用 e 返回其值</span><br><span class="line">    <span class="title function_">ListLength</span><span class="params">(L)</span>:	返回线性表 L 的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>

<p>对于不同的应用，线性表的基本操作是不同的，上述操作是最基本的，对于实际问题中涉及的关于线性表的更复杂操作，完全可以用这些基本操作的组合来实现。</p>
<h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3><h4 id="顺序存储定义"><a href="#顺序存储定义" class="headerlink" title="顺序存储定义"></a>顺序存储定义</h4><blockquote>
<p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p>
</blockquote>
<p>线性表 (a<sub>1</sub>, a<sub>1</sub>, ……, a<sub>n</sub>) 的顺序存储结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/dsa/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png" alt="顺序存储"></p>
<h4 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h4><p>线性表的顺序存储结构，就是在内存中找了块区域，通过占位的形式，把一定的内存空间给占了，然后把相同数据类型的数据元素一次存放在这块空地种。既然线性表的每个数据元素的类型都相同，所以可以用 C 语言(其他语言也相同)的一维数组来实现顺序存储结构，即把第一个数据元素存到数组下标为 0 的位置中，接着把线性表相邻的元素存储在数组中相邻的位置。</p>
<p>线性表顺序存储的结构代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20			<span class="comment">// 存储空间初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;		<span class="comment">// ElemType 类型根据实际情况而定，这里假设为 int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> 	ElemType data[MAXSIZE];	<span class="comment">// 数组存储数据元素，最大值为MAXSIZE</span></span><br><span class="line">  <span class="type">int</span> length;				<span class="comment">// 线性表当前长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p>顺序存储结构需要三个属性：</p>
<ul>
<li>存储空间的起始位置：数据 data，它的存储位置就是存储空间的存储位置</li>
<li>线性表的最大存储容量：数组长度 MaxSize</li>
<li>线性表的当前长度</li>
</ul>
<h4 id="数据长度于线性表长度区别"><a href="#数据长度于线性表长度区别" class="headerlink" title="数据长度于线性表长度区别"></a>数据长度于线性表长度区别</h4><p>数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。</p>
<p>在任一时刻，线性表的长度应该小于等于数组的长度。</p>
<h4 id="地址计算方法"><a href="#地址计算方法" class="headerlink" title="地址计算方法"></a>地址计算方法</h4><p>由于我们数数都是从 1 开始开始数的，线性表的定义起始也是 1，在程序设计中，数组的小表是从 0 开始的，所以线性表的第 i 个元素要存储在数组下标为 i-1 的位置，即数据元素的序号和存放它的数组下标之间存在对应关系。</p>
<p>用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，因此分配的数组空间要大于等于当前线性表的长度。</p>
<p><strong>存储器中的每个存储单元都有自己的编号，这个编号称为地址</strong>。由于每个数据元素，不管它是整型、实型还是字符型，它都是需要占用一定的存储单元空间的。假设占用的是 c 个存储单元，那么线性表中第 i+1 个数据元素的存储位置和第 i 个数据元素的存储位置满足下列关系(LOC 表示获得存储位置的函数)。</p>
<blockquote>
<p>LOC(a<sub>i+1</sub>) &#x3D; LOC(a<sub>i</sub>) + c</p>
</blockquote>
<p>所以对于第 i 个数据元素 a<sub>i</sub> 的存储位置可以由 a<sub>1</sub> 推算得出：</p>
<blockquote>
<p>LOC(a<sub>i</sub>) &#x3D; LOC(a<sub>1</sub>) + (i - 1) * c</p>
</blockquote>
<p>通过这个公式，随时可以算出线性表中任意位置的地址，不管它是第一个还是最后一个，都是相同的时间。那么对每个线性表位置的存入或者取出数据，对于计算机来说都是相等的时间，也就是一个常数，因此从时间复杂度的概念来看，它的存取时间性能为 O(1)。通常把具有这一特点的存储结构称为随机存取结构。</p>
<h3 id="顺序存储结构的插入和删除"><a href="#顺序存储结构的插入和删除" class="headerlink" title="顺序存储结构的插入和删除"></a>顺序存储结构的插入和删除</h3><h4 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h4><p>对于线性表的顺序存储结构来说，如果我们要实现 GetElem 操作，即将线性表 L 中第 i 个位置元素值返回，其实是非常简单的。只要 i 的数值在数组下标范围内，就是把数组第 i-1 下标的值返回即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line">Status <span class="title function_">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i, ElemType *e)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(L.length == <span class="number">0</span> || i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e = L.data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps: 这里的返回值类型 Status 是一个整数，返回 OK 代表 1，ERROR 代表 0。**时间复杂度为O(1)**。</p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>插入算法的思路：</p>
<ul>
<li>如果插入位置不合理，抛出异常；</li>
<li>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；</li>
<li>从最后一个元素开始向前遍历到第 i 歌位置，分别将它们都向后移动一个位置；</li>
<li>将要插入元素填入位置 i 处；</li>
<li>表长加 1。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(SqList *L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  <span class="keyword">if</span>(L -&gt; length == MAXSIZE)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L -&gt; length + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span>(i &lt;= L -&gt; length) &#123;</span><br><span class="line">    <span class="keyword">for</span>(k = L -&gt; length - <span class="number">1</span>; k &gt;= i <span class="number">-1</span>; k--)</span><br><span class="line">      L -&gt; data[k + <span class="number">1</span>] = L -&gt; data[k];</span><br><span class="line">  &#125;</span><br><span class="line">  L -&gt; data[i - <span class="number">1</span>] = e;</span><br><span class="line">  L -&gt; length++;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>删除算法的思路：</p>
<ul>
<li>如果删除位置不合理，抛出异常；</li>
<li>取出删除元素；</li>
<li>从删除元素位置开始便利到最后一个元素位置，分别将它们都向前移动一个位置；</li>
<li>表长减1。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(SqList *L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  <span class="keyword">if</span>(L -&gt; length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L -&gt; length)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  *e = L -&gt; data[i - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span>(i &lt; L -&gt; length) &#123;</span><br><span class="line">    <span class="keyword">for</span>(k = i;k &lt; L -&gt; length; k++)</span><br><span class="line">      L -&gt; data[k<span class="number">-1</span>] = L -&gt; data[k];</span><br><span class="line">  &#125;</span><br><span class="line">  L -&gt; length--;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入和删除操作的时间复杂度：</p>
<p>最好的情况是，如果元素要插入到最后一个位置，或者删除最后一个元素，此时时间复杂度为 O(1)，因为不需要移动元素。</p>
<p>最坏的情况是，如果元素要插入到第一个位置或者删除第一个元素，那就意味着要移动所有的元素向后或者向前，所以这个时间复杂度为 O(n)。</p>
<p>至于平均的情况，由于元素插入到第 i 个位置，或删除第 i 个元素，需要移动 n-1 个元素。根据概率原理，每个位置插入或删除的可能性是相同的，也就说位置靠前，移动元素多，位置靠后，移动元素少。最终平均移动次数和最中间的那个元素的移动次数相等，为 (n-1)&#x2F;2。根据时间复杂度的推导，平均时间复杂度还是 O(n)。</p>
<p>这说明线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是 O(1)；而插入或删除时，时间复杂度都是 O(n)。</p>
<h4 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h4><p>优点：</p>
<ul>
<li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间</li>
<li>可以快速地存取表中任一位置的元素</li>
</ul>
<p>缺点：</p>
<ul>
<li>插入和删除操作需要移动大量元素</li>
<li>当线性表长度变化较大时，难以确定存储空间的容量</li>
<li>造成存储空间的“碎片”</li>
</ul>
<h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h3><h4 id="线性表链式存储结构定义"><a href="#线性表链式存储结构定义" class="headerlink" title="线性表链式存储结构定义"></a>线性表链式存储结构定义</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="链式存储结构"></p>
<p>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。意味着，这些数据元素可以存在内存未被占用的任意位置。</p>
<p>顺序存储结构每个元素之需要存数据元素信息就可以了。链式存储结构除了要存数据元素信息外，还要存储他的后继元素的存储地址。</p>
<p>因此， <strong>为了表示每个数据元素 a<sub>i</sub> 与其直接后继数据元素 a<sub>i+1</sub> 之间的逻辑关系，对数据元素 a<sub>i</sub> 来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素 a<sub>i</sub> 的存储映像，称为结点(Node)。</strong></p>
<p><strong>n 个结点(a<sub>i</sub> 的存储映像)链结成一个链表，即为线性表 (a<sub>1</sub>, a<sub>2</sub>, ···, a<sub>n</sub>) 的链式存储结构，因为此链表的每个节点中只包含一个指针域，所以叫做单链表</strong>。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起。</p>
<p>对于线性表来说，总得有个头有个尾，链表也不例外。把<strong>链表中第一个结点的存储位置叫做头指针</strong>，那么整个链表的存取就必须是从头指针开始进行了。之后的每一个结点，其实就是上一个的后继指针指向的位置。最后一个，当然就意味着直接后继不存在了，所以规定，线性链表的最后一个结点指针为“空” (通常用 NULL 或 “^” 符号表示)。</p>
<p>有时为了更加方便地对链表进行操作，会在<strong>单链表的第一个结点前附设一个结点，称为头结点</strong>。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针。</p>
<h4 id="头指针域头结点的异同"><a href="#头指针域头结点的异同" class="headerlink" title="头指针域头结点的异同"></a>头指针域头结点的异同</h4><p>头指针：</p>
<ul>
<li>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针；</li>
<li>头指针具有标识作用，所以常用头指针冠以链表的名字</li>
<li>无论链表是否为空，头指针均不为空。头指针是链表的必要元素</li>
</ul>
<p>头结点：</p>
<ul>
<li>头结点是为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义(也可存放链表的长度)</li>
<li>有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了</li>
<li>头结点不一定是链表必须要素</li>
</ul>
<h4 id="线性表链式存储结构代码描述"><a href="#线性表链式存储结构代码描述" class="headerlink" title="线性表链式存储结构代码描述"></a>线性表链式存储结构代码描述</h4><p>单链表中，在 C 语言中可用结构指针来描述。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure>

<p>从这个结构定义中，<strong>结点由存放数据元素的数据域存放后继结点地址的指针域组成</strong>。假设 p 是指向线性表第 i 个元素的指针，则该结点 a<sub>i</sub> 的数据域可以用 p -&gt; data 来表示，p -&gt; data 的值是一个数据元素，结点 a<sub>i</sub> 的指针域可以用 p -&gt; next 来表示，p -&gt; next 的值是一个指针。指向第 i+1 个元素，即指向 a<sub>i+1</sub> 的指针。也就是说，如果 p -&gt; data &#x3D; a<sub>i</sub>，那么 p -&gt; next -&gt; data &#x3D; a<sub>i+1</sub>。</p>
<h3 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h3><p>获得链表第 i 个数据的算法思路：</p>
<ul>
<li>声明一个结点 p 指向链表第一个结点，初始化 j 从 1 开始；</li>
<li>当 j &lt; i 时，就遍历链表，让 P 的指针向后移动，不断指向下一结点，j 累加 1；</li>
<li>若到链表末尾 p 为空，则说明第 i 个元素不存在；</li>
<li>否则查找成功，返回结点 p 的数据。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i, ElemType *e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  LinkList p;					<span class="comment">// 声明一结点 p</span></span><br><span class="line">  p = L -&gt; next;				<span class="comment">// 让 p 指向链表 L 的第一个结点</span></span><br><span class="line">  j = <span class="number">1</span>;						<span class="comment">// j 为计数器</span></span><br><span class="line">  <span class="keyword">while</span>(p &amp;&amp; j &lt; i) &#123;			<span class="comment">// p 不为空或者计数器 j 还没有等于 i 时，循环继续</span></span><br><span class="line">    p = p -&gt; next;				<span class="comment">// 让 p 指向下一个结点</span></span><br><span class="line">    ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!p || j &gt; i)</span><br><span class="line">    <span class="keyword">return</span> ERROR;				<span class="comment">// 第 i 个元素不存在</span></span><br><span class="line">  *e = p -&gt; data;				<span class="comment">// 取第 i 个元素的数据</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简而言之就是从头开始找，知道第 i 个元素为止。这个算法的时间复杂度取决于 i 的位置，当 i &#x3D; 1 时，则不需要遍历，第一个取出数据；当 i &#x3D; n 时则遍历 n - 1 次才可以。因此最坏情况的时间复杂度时 O(n)。</p>
<p>由于单链表的结构中没有定义表长，所以不能事先知道要循环多少次，因此就不方便使用 for 循环来控制循环。主要核心思想就是“<strong>工作指针后移</strong>“。</p>
<h3 id="单链表的插入和删除"><a href="#单链表的插入和删除" class="headerlink" title="单链表的插入和删除"></a>单链表的插入和删除</h3><h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><p>假设存储元素 e 的结点为 s，要实现结点 p、p -&gt; next 和 s 之间逻辑关系的变化，只需将结点 s 插入到结点 p 和 p -&gt; next 之间即可。只需要让 s -&gt; next 和 p -&gt; next 的指针做一点改变即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s -&gt; next = p -&gt; next;</span><br><span class="line">p -&gt; next = s;</span><br></pre></td></tr></table></figure>

<p>这两句代码就是让 p 的后继结点改成 s 的 后继结点，再把结点 s 变成 p 的后继结点</p>
<p>单链表第 i 个数据插入结点的算法思路：</p>
<ol>
<li>声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始；</li>
<li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1；</li>
<li>若到链表末尾 p 为空，则说明第 i 个元素不存在；</li>
<li>否则查找成功，在系统中生成一个空结点 s；</li>
<li>将数据元素 e 赋值给 s -&gt; data；</li>
<li>单链表的插入标准语句 s -&gt; next &#x3D; p -&gt; next; p -&gt; next &#x3D; s;</li>
<li>返回成功。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(LinkList *L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  LinkList p, s;</span><br><span class="line">  p = *L;</span><br><span class="line">  j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(p &amp;&amp; j &lt; i) &#123;</span><br><span class="line">    p = p -&gt; next;								<span class="comment">// 寻找第 i 个结点</span></span><br><span class="line">    ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!p || j&gt; i) </span><br><span class="line">    <span class="keyword">return</span> ERROR;								<span class="comment">// 第 i 个元素不存在</span></span><br><span class="line">  s = (LinkList) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(Node));			<span class="comment">// 生成新结点（C 标准函数）</span></span><br><span class="line">  s -&gt; data = e;</span><br><span class="line">  s -&gt; next = P -&gt; next;						<span class="comment">// 将 p 的后继结点赋值给 s 的后继</span></span><br><span class="line">  p -&gt; next = s;								<span class="comment">// 将 s 赋值给 p 的后继</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mallloc 标准函数的作用是生成一个新的结点，其类型与 Node 是一样，其实质就是在内存中找了一块空地，准备用来存放 e 数据 s 结点。</p>
<h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><p>单链表第 i 个数据删除结点的算法思路：</p>
<ol>
<li>声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始；</li>
<li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一个结点，j 累加 1；</li>
<li>若到链表末尾 p 为空，则说明第 i 个元素不存在；</li>
<li>否则查找成功，将欲删除的结点 p -&gt; next 赋值给 q；</li>
<li>单链表的删除标准语句 p -&gt; next &#x3D; q -&gt; next；</li>
<li>将 q 结点中的数据赋值给 e，作为返回；</li>
<li>释放 q 结点；</li>
<li>返回成功。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(LinkList *L, <span class="type">int</span> i, ElemType *e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  LinkList p, q;</span><br><span class="line">  p = *L;</span><br><span class="line">  j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(p -&gt; next &amp;&amp; j &lt; i) &#123;		<span class="comment">// 遍历寻找第 i 个元素</span></span><br><span class="line">    p = p -&gt; next;</span><br><span class="line">    ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!(p -&gt;next) || j &gt; i)</span><br><span class="line">    <span class="keyword">return</span> ERROR;					<span class="comment">// 第 i 个元素不存在</span></span><br><span class="line">  q = p -&gt; next;</span><br><span class="line">  p -&gt; next = q -&gt; next;			<span class="comment">// 将 q 的后继赋值给 p 的后继</span></span><br><span class="line">  *e = q -&gt; next;					<span class="comment">// 将 q 结点中的数据给 e</span></span><br><span class="line">  <span class="built_in">free</span>(q);							<span class="comment">// 让系统回收此结点，释放内存</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>free 标准函数的作用是让系统回收一个 Node 结点，释放内存。</p>
<p>不管是单链表插入还是删除算法，其实都是由两个部分组成：遍历查找第 i 个元素；插入和删除元素。</p>
<p>从整个算法来看，它们的时间复杂度都是 O(n)。如果在不知道第 i 个元素的指针位置，单链表数据结构在插入和删除操作上，与线性表的顺序存储结构没有太大优势。但是如果知道第 i 个元素为止，对于顺序存储结构来说，每一次插入或删除都需要移动 n - i 个元素，每次都是 O(n)。而单链表，只需要在第一次时，找到第 i 个位置的指针，此时为 O(n)，接下来只是简单地通过赋值移动指针而已，时间复杂度都是 O(1)。所以，<strong>对于插入或删除数据越频繁的操作，单链表的效率优势越明显</strong>。</p>
<h3 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h3><p>顺序存储结构的创建，其实就是一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。而单链表和顺序存储结构就不一样，它不像顺序存储结构这么集中，它可以很散，是一种动态结构。对于每个链表来说，它所占空间的大小和位置是不需要预先分配划定的，可以根据系统的情况和实际的需求及时生成。</p>
<p>创建单链表的过程就是一个动态生成链表的过程。即从“空表”的初始状态起，一次建立各元素结点，并逐个插入链表。</p>
<p>单链表整表创建的算法思路：</p>
<ol>
<li>声明一结点 p 和计数器变量 i；</li>
<li>初始化一空链表 L；</li>
<li>让 L 的头结点的指针指向 NULL，即建立一个带头结点的单链表；</li>
<li>循环：<ul>
<li>生成一个新结点赋值给 p；</li>
<li>随机生成一数字赋值给 p 的数据域 p -&gt; data;</li>
<li>将 p 插入到头结点与前一新结点之间。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateListHead</span><span class="params">(LinkList *L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  LinkList p;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  srand(time(<span class="number">0</span>));							<span class="comment">// 初始化随机数种子</span></span><br><span class="line">  *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">  (*L) -&gt; next = <span class="literal">NULL</span>;						<span class="comment">// 先建立一个带头结点的单链表</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));		<span class="comment">// 生成新结点</span></span><br><span class="line">    p -&gt; data = rand() % <span class="number">100</span> + <span class="number">1</span>;			<span class="comment">// 随机生成 100 以内的数字</span></span><br><span class="line">    p -&gt; next = (*L) -&gt; next;</span><br><span class="line">    (*L) -&gt; next = p;						<span class="comment">// 插入到表头</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种算法用的是插队的方法，就是始终让新结点在第一的位置。称为头插法。</p>
<p>也可以把新结点放到最后，称为尾插法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateListTail</span><span class="params">(LinkList *L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  LinkList p, r;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  srand(time(<span class="number">0</span>));							<span class="comment">// 初始化随机数种子</span></span><br><span class="line">  *L (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));		<span class="comment">// 为整个线性表</span></span><br><span class="line">  r = *L;									<span class="comment">// r 为指向尾部的结点</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));		<span class="comment">// 生成新结点</span></span><br><span class="line">    p -&gt; data = rand() % <span class="number">100</span> + <span class="number">1</span>;			<span class="comment">// 随机生成 100 以内的数字</span></span><br><span class="line">    r -&gt; next = p;							<span class="comment">// 将表尾终端结点的指针指向新结点</span></span><br><span class="line">    r = p;									<span class="comment">// 将当前的新结点定义为表尾终端结点</span></span><br><span class="line">  &#125;</span><br><span class="line">  r -&gt; next = <span class="literal">NULL</span>;							<span class="comment">// 表示当前链表结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>L 与 r 的关系，L 是指整个单链表，而 r 是指向尾结点的变量，r 会随着循环不断地变化结点，而 L 则是随着循环增长为一个多结点的链表。</p>
<h3 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h3><p>单链表整表删除的算法思路：</p>
<ol>
<li>声明一结点 p 和 q；</li>
<li>降低一个结点赋值给 P；</li>
<li>循环：<ul>
<li>将下一结点赋值给 q；</li>
<li>释放 p；</li>
<li>将 q 赋值给 p。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ClearList</span><span class="params">(LinkList *L)</span> &#123;</span><br><span class="line">  LinkList p,q;</span><br><span class="line">  p = (*L) -&gt; next;			<span class="comment">// p 指向第一个结点</span></span><br><span class="line">  <span class="keyword">while</span>(p) &#123;				<span class="comment">// 没到表尾</span></span><br><span class="line">    q = p -&gt; next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = q;</span><br><span class="line">  &#125;</span><br><span class="line">  (*L) -&gt; next = <span class="literal">NULL</span>;		<span class="comment">// 头结点指针域为空</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h3><p>单链表结构和顺序存储结构对比：</p>
<ul>
<li>存储分配方式<ul>
<li>顺序存储结构用一段连续的存储单元依次存储线性表的数据元素</li>
<li>单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素</li>
</ul>
</li>
<li>时间性能<ul>
<li>查找<ul>
<li>顺序存储结构 O(1)</li>
<li>单链表 O(n)</li>
</ul>
</li>
<li>插入和删除<ul>
<li>顺序存储结构需要平均移动表长一半的元素，时间为 O(n)</li>
<li>单链表在现出某位置的指针后，插入和删除时间仅为 O(1)</li>
</ul>
</li>
</ul>
</li>
<li>空间性能<ul>
<li>顺序存储结构需要与分配存储空间，分大了，浪费，分小了易发生上溢</li>
<li>单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制</li>
</ul>
</li>
</ul>
<p>结论：</p>
<ul>
<li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。</li>
<li>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。</li>
</ul>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>让数组的元素都是由两个数据域组成，data 和 cur。也就是说，数组的每个下标都对应一个 data 和一个 cur。数据域 data，用来存放数据元素，也就是通常要处理的数据；而游标 cur 相当于单链表中的 next 指针，存放该元素的后继在数组中的下标。称这种<strong>用数组描述的链表叫做静态链表</strong>，这种描述方法叫做游标实现法。</p>
<p>为了我们方便插入数据，可以把数组建立得大一些，以便有一些空闲空间可以便于插入时不至于溢出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>			<span class="comment">// 假设链表的最大长度是 1000</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="type">int</span> cur;					<span class="comment">// 游标(Cursor)，为 0 时表示无指向</span></span><br><span class="line">&#125; Component, StaticLinkList[MAXSIZE]</span><br></pre></td></tr></table></figure>

<p>另外对数组第一个和最后一个元素作为特殊元素处理，不存数据。把未被使用的数组元素称为备用链表。而数组第一个元素，即下标为 0 的元素的 cur 就存放备用链表的第一个结点的下标；而数组的最后一个元素的 cur 则存放第一个有数值的元素的下标，相当于单链表中的头结点作用，当整个链表为空时，则为 O<sup>2</sup>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// space[0].cur 为头指针，“0” 表示空指针</span></span><br><span class="line">Status <span class="title function_">InitList</span><span class="params">(StaticLinkList space)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)</span><br><span class="line">    space[i].cur = i + <span class="number">1</span>;</span><br><span class="line">  space[MAXSIZE - <span class="number">1</span>].cur = <span class="number">0</span>;		<span class="comment">// 目前静态链表为空，最后一个元素的 cur 为 0</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态链表的插入操作"><a href="#静态链表的插入操作" class="headerlink" title="静态链表的插入操作"></a>静态链表的插入操作</h4><p>静态链表中要解决的是如何用静态模拟动态链表结构的存储空间的分配，需要时申请，无用时释放。</p>
<p>动态链表中，结点的申请和释放分别用 malloc() 和 free() 两个函数来实现。在静态链表中，操作的是数组，不存在像动态链表的结点申请和释放问题，要自己实现两个函数，才能做插入和删除的操作。</p>
<p>为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若备用空间链表非空，则返回分配的结点下标，否则返回 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Malloc_SLL</span><span class="params">(StaticLinkList space)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = space[<span class="number">0</span>].cur;					<span class="comment">// 当前数组第一个元素的 cur 存的值，就是要返回的第一个备用空闲的下标</span></span><br><span class="line">  <span class="keyword">if</span>(space[<span class="number">0</span>].cur)</span><br><span class="line">    space[<span class="number">0</span>].cur = space[i].cur;		<span class="comment">// 由于要拿出一个分量来使用了，所以我们就得把它的下一个分量用来做备用</span></span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码一方面它的作用就是返回一个下标值，这个值就是数组头元素的 cur 存的空闲的下标。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 L 中第 i 个元素之前插入新的数据元素 e</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(StaticLinkList L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j, k, l;</span><br><span class="line">  k = MAX_SIZE - <span class="number">1</span>；					<span class="comment">// 注意 k 首先是最后一个元素的下标</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; ListLength(L) + <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> ERROR;</span><br><span class="line">  j = Malloc_SSL(L);					<span class="comment">// 获得空闲分量的下标</span></span><br><span class="line">  <span class="keyword">if</span>(j) &#123;</span><br><span class="line">    L[j].data = e;						<span class="comment">// 将数据赋值给此分量的 data</span></span><br><span class="line">    <span class="keyword">for</span>(l = <span class="number">1</span>; l &lt;= i - <span class="number">1</span>; l++)			<span class="comment">// 找到第 i 个元素之前的位置</span></span><br><span class="line">      k = L[k].cur;</span><br><span class="line">    L[j].cur = L[k].cur;				<span class="comment">// 把第 i 个元素之前的 cur 赋值给新元素的 cur</span></span><br><span class="line">    L[k].cur = j;						<span class="comment">// 把新元素的下标赋值给第 i 个元素之前元素的 cur</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态链表的删除操作"><a href="#静态链表的删除操作" class="headerlink" title="静态链表的删除操作"></a>静态链表的删除操作</h4><p>删除元素是，原来需要释放结点的函数 free()，也由自己实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除在 L 中第 i 个数据元素 e</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(StaticLinkList L, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j, k;</span><br><span class="line">  <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; ListLength(L))</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  k = MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)</span><br><span class="line">    k = L[k].cur;</span><br><span class="line">  j = L[k].cur;</span><br><span class="line">  L[k].cur = L[j].cur;</span><br><span class="line">  Free_SSL(L, j);</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将下标为 k 的空闲结点回收到备用链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Free_SSL</span><span class="params">(StaticLinkList space, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">  space[k].cur = space[<span class="number">0</span>].cur;		<span class="comment">//把第一个元素 cur 值赋给要删除的分量</span></span><br><span class="line">  space[<span class="number">0</span>].cur = k;					<span class="comment">// 把要删除的分量下标赋值给第一个元素的 cur</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始条件：静态链表 L 已存在。操作结果：返回 L 中数据元素个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(StaticLinkList L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = L[MAXSIZE - <span class="number">1</span>].cur;</span><br><span class="line">  <span class="keyword">while</span>(i) &#123;</span><br><span class="line">    i = L[i].cur;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态链表的优缺点"><a href="#静态链表的优缺点" class="headerlink" title="静态链表的优缺点"></a>静态链表的优缺点</h4><p>优点：</p>
<ul>
<li>在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。</li>
</ul>
<p>缺点：</p>
<ul>
<li>没有解决连续存储分配带来的表长难以确定的问题</li>
<li>失去了顺序存储结构随机存取的特性</li>
</ul>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>**将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linked list)**。</p>
<p>其实循环链表和单链表的主要差异在于循环的判断条件上，原来是判断 p -&gt; next 是否为空，现在则是 p -&gt; next 不等于头结点，则循环未结束。</p>
<p>在单链表中，有了头结点时，可以用 O(1) 的时间访问第一个结点，但对于要访问到最后一个结点，却需要 O(n) 时间，因为需要将单链表全部扫描一遍。</p>
<p>有没有可能用 O(1) 的时间由链表指针访问到最后一个结点呢？</p>
<p>需要改造一下循环链表，不用头指针，而是用指向终端结点的为指针来表示循环链表。终端结点用尾指针 rear 指示，则查找终端结点是 O(1)，而开始结点，其实就是 rear -&gt; next -&gt; next，其时间复杂度也为 O(1)。</p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>在单链表中，有了 next 指针，这使得要查找下一结点的时间复杂度为 O(1)。可是如果要查找的是上一结点的话，那最坏的时间复杂度就是 O(n)了，因为每次都要从头开始遍历查找。为了克服单一性这一缺点，设计了双向链表。<strong>双向链表 (double linked list) 是在单链表的每个结点中，在设置一个指向其前驱结点的指针域</strong>。所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性表的双向链表存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> &#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">prior</span>;</span>		<span class="comment">// 直接前驱指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">next</span>;</span>			<span class="comment">// 直接后继指针</span></span><br><span class="line">&#125; DulNode, *DuLinkList;</span><br></pre></td></tr></table></figure>

<p>双向链表是单链表中扩展出来的结构，所以它的很多操作是和单链表相同的，比如求长度 ListLength，查找元素的 GetElem，获得元素位置的 LocateElem 等，这些操作都只要涉及一个方向的指针即可，另一个指针多了也不能提供什么帮助。</p>
<p>插入操作时，假设存储元素 e 的结点为 s，要实现将结点 s 插入到结点 p 和 p -&gt; next 之间需要以下几步：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s -&gt; prior = p;				<span class="comment">// 把 p 赋值给 s 的前驱</span></span><br><span class="line">s -&gt; next = p -&gt; next;		<span class="comment">// 把 p -&gt; next 赋值给 s 的后继</span></span><br><span class="line">p -&gt; next -&gt; prior = s;		<span class="comment">// 把 s 赋值给 p -&gt; next 的前驱</span></span><br><span class="line">p -&gt; next = s;				<span class="comment">// 把 s 赋值给 p 的后继</span></span><br></pre></td></tr></table></figure>

<p>删除操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; prior -&gt; next = p -&gt; next;		<span class="comment">// 把 p -&gt; next 赋值给 p -&gt; prior 的后继</span></span><br><span class="line">p -&gt; next -&gt; prior = p -&gt; prior;	<span class="comment">// 把 p -&gt; prior 赋值给 p -&gt; next 的前驱</span></span><br><span class="line"><span class="built_in">free</span>(p);							<span class="comment">// 释放结点</span></span><br></pre></td></tr></table></figure>

<p>双向链表对于单链表来说，多了 prior 指针。另外它由于每个结点都需要记录两份指针，所以在空间上是要占用略多一些的。不过由于它良好的对称性，使得对某个结点的前后结点的操作，带来了方便，可以有效提高算法的时间性能。也就是用空间来换时间。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>线性表：是零个或多个相同类型的数据元素的有限序列。</p>
<p>由与顺序存储结构的插入和删除操作不方便，引出了链式存储结构，它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点。、</p>
<p>链式存储结构的不同形式：单链表、循环链表和双向链表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%88%86%E7%B1%BB.png" alt="线性表分类"></p>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><blockquote>
<p>栈与队列：</p>
<p>栈是限定仅在表尾进行插入和删除操作的线性表。</p>
<p>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。</p>
</blockquote>
<h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><h4 id="栈的定义-1"><a href="#栈的定义-1" class="headerlink" title="栈的定义"></a>栈的定义</h4><blockquote>
<p>栈 (stack) 是限定仅在表尾进行插入和删除操作的线性表。</p>
</blockquote>
<p>把允许插入和删除的一端称为栈顶 (top)，另一端称为栈底 (bottom)，不含任何数据元素的栈称为空栈。栈又称为后进先出 (Last In First Out) 的线性表，简称 LIFO 结构。</p>
<p>栈是一个线性表，也就是说栈元素具有线性关系，即前驱后继关系。只不过它是一种特殊的线性表而已。定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。</p>
<p><strong>栈的插入操作，叫作进栈，也成压栈、入栈。栈的删除操作，叫作出栈，也有的叫作弹栈。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E8%BF%9B%E6%A0%88%E5%87%BA%E6%A0%88.png" alt="进栈出栈"></p>
<h4 id="进栈出栈变化形式"><a href="#进栈出栈变化形式" class="headerlink" title="进栈出栈变化形式"></a>进栈出栈变化形式</h4><blockquote>
<p>是不是最先进栈的元素就只能是最后出栈呢？</p>
</blockquote>
<p>在不是所有元素都进栈的情况下，事先进去的元素也可以出栈，只要保证栈顶元素出栈即可。</p>
<p>例如有 3 个整型数字 1、2、3 一次进栈，会有一下几种出栈次序。</p>
<ul>
<li>1、2、3 进，再 3、2、1 出。出栈顺序为 321。</li>
<li>1 进，1 出，2 进，2 出，3 进，3 出。出栈顺序为 123。</li>
<li>1 进，2 进，2 出，1 出，3 进，3 出。出栈顺序为 213。</li>
<li>1 进，1 出，2 进，3 进，3 出，2 出。出栈顺序为 132。</li>
<li>1 进，2 进，2 出，3 进，3 出，1 出。出栈顺序为 231。</li>
</ul>
<p>没有可能出现 312 这种出栈顺序，因为 3 先出栈，说明 3 曾经进栈，意味着 1 和 2 已经进栈了，此时 2 一定在 1 的上面。</p>
<h3 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h3><p>对于栈来讲，理论上线性表的操作特性他都具备，可由于它的特殊性，所以针对它在操作上会有些变化。特别是插入和删除操作，push 和 pop，一般叫作进栈和出栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 栈(<span class="built_in">stack</span>)</span><br><span class="line">Data</span><br><span class="line">  同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">  <span class="title function_">InitStack</span><span class="params">(*S)</span>: 初始化操作，建立一个空栈 S。</span><br><span class="line">  <span class="title function_">DestroyStack</span><span class="params">(*S)</span>: 若栈存在，则销毁它。</span><br><span class="line">  <span class="title function_">ClearStack</span><span class="params">(*S)</span>: 将栈清空。</span><br><span class="line">  <span class="title function_">StackEmpty</span><span class="params">(S)</span>: 若栈为空，返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line">  <span class="title function_">GetTop</span><span class="params">(S, *e)</span>: 若栈存在且为空，用 e 返回 S 的栈顶元素。</span><br><span class="line">  <span class="title function_">Push</span><span class="params">(*S, e)</span>: 若栈 s 存在，插入新元素 e 到栈 S 中并成为栈顶元素。</span><br><span class="line">  <span class="title function_">Pop</span><span class="params">(*S, *e)</span>: 删除栈 S 中栈顶元素，并用 e 返回其值。</span><br><span class="line">  <span class="title function_">StackLength</span><span class="params">(S)</span>: 返回栈 S 的元素个数。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>

<p>栈本身就是线性表，所以线性表的顺序存储和链式存储对于栈来说，也是同样适用的。</p>
<h3 id="栈的顺序存储结构及实现"><a href="#栈的顺序存储结构及实现" class="headerlink" title="栈的顺序存储结构及实现"></a>栈的顺序存储结构及实现</h3><h4 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h4><blockquote>
<p>线性表使用数组实现的，但是栈只能一头插入删除，所以要考虑用数组的哪一端作为栈顶和栈底比较好。</p>
</blockquote>
<p>下标为 0 的一端作为栈底比较好，因为首元素都存在栈底，变化最小，所以让它做栈底。</p>
<p>定义一个 top 变量来指示栈顶元素在数组中的位置，这 top 就如同中学物理学过的游标卡尺的游标，可以来回移动，意味着栈顶的 top 可以变大变小，但无论如何游标不能超出尺的长度。同理，若存储栈的长素为 StackSize，则栈顶位置 top 必须小于 StackSize。当栈存在一个元素时，top 等于 0，因此通常把空栈的判定条件定为 top 等于 -1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;		<span class="comment">// 	SElemType 类型根据实际情况而定，这里假设为 int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  SElemType data[MAXSIZE];</span><br><span class="line">  <span class="type">int</span> top;					<span class="comment">// 用于栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>

<h4 id="栈的顺序存储结构——进栈操作"><a href="#栈的顺序存储结构——进栈操作" class="headerlink" title="栈的顺序存储结构——进栈操作"></a>栈的顺序存储结构——进栈操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入元素 e 为新的栈顶元素</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqStack *S, SElemType e)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(S -&gt; top == MAXSIZE - <span class="number">1</span>) &#123;		<span class="comment">// 栈满</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">  S -&gt; top++;						<span class="comment">// 栈顶指针增加 1</span></span><br><span class="line">  S -&gt; data[S -&gt; top] = e;			<span class="comment">// 将新元素赋值给栈顶空间</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="栈的顺序存储结构——出栈操作"><a href="#栈的顺序存储结构——出栈操作" class="headerlink" title="栈的顺序存储结构——出栈操作"></a>栈的顺序存储结构——出栈操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若栈不空，则删除 S 的栈顶元素，用 e 返回其值，并返回 OK；否则返回 ERROR</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqStack *S, SElemType *e)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(S -&gt; top == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  *e = S -&gt; data[S -&gt; top];			<span class="comment">// 将要删除的栈顶元素赋值给 e</span></span><br><span class="line">  S -&gt; top--;						<span class="comment">// 栈顶指针减 1</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入栈和出栈操作都没有涉及到任何循环语句，时间复杂度均是 O(1)。</p>
<h3 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h3><p>如果有两个相同类型的栈，为它们各自开辟了数组空间，极有可能是第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。可以用一个数组来存储两个栈。数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为 0 处，另一个栈的栈底为数组的末端，即下标为为数组长度 n - 1 处。这样，两个栈如果增加元素，就是两端点向中间延伸。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4.png" alt="两栈共享空间"></p>
<p>它们在数组的两端，向中间靠拢。top1 和 top2 是栈 1 和 栈 2 的栈顶指针。当栈 1 为空时，就是 top1 &#x3D; -1 时；而当 top2 等于 n 时，即是栈 2 为空时。若栈 2 是空栈，栈 1 的 top1 &#x3D; n - 1 时，就是栈 1 满了。反之，当栈 1 为空栈时，top2  &#x3D; 0 时，为栈 2 满。但更多的情况是两个指针之间相差 1 时，即 top1 + 1 &#x3D;&#x3D; top2 为栈满。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两栈共享空间结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  SElemType data[MAXSIZE];</span><br><span class="line">  <span class="type">int</span> top1;		<span class="comment">// 栈 1 栈顶指针</span></span><br><span class="line">  <span class="type">int</span> top2;		<span class="comment">// 栈 2 栈顶指针</span></span><br><span class="line">&#125;SqDoubleStack;</span><br></pre></td></tr></table></figure>

<p>对于两栈共享空间的 push 方法，除了要插入元素值参数外，还需要有一个判断是栈 1 还是栈 2 的栈号 stackNumber。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入元素 e 为新的栈顶元素</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqDoubleStack *S, SElemType e, <span class="type">int</span> stackNumber)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(S -&gt; top1 + <span class="number">1</span> == S -&gt; top2)		<span class="comment">// 栈已满，不能再 push 新元素了</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span>(stackNumber == <span class="number">1</span>)					<span class="comment">// 栈 1 有元素进栈</span></span><br><span class="line">    S -&gt; data[++S -&gt; top1] = e;			<span class="comment">// 若栈 1 则先 top1 + 1 后给数组元素赋值</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(stackNumber == <span class="number">2</span>)				<span class="comment">// 栈 2 有元素进栈</span></span><br><span class="line">    S -&gt; data[--S -&gt; top2] = e;			<span class="comment">// 若栈 2 则先 top2 - 1 后给数组元素赋值</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在开始已经判断了是否有栈满的情况，所以后面的 top1 + 1 或 top2 -1 是不担心溢出问题的。</p>
<p>对于两栈共享空间的 pop方法，参数就只是判断栈 1 栈 2 的参数 stackNumber。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若栈不空，则删除 S 的栈顶元素，用 e 返回其值，并返回 OK；否则返回 ERROR</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqDoubleStack *S, SElemType *e, <span class="type">int</span> stackNumber)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(stackNumber == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(S -&gt; top1 == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">return</span> ERROR;						<span class="comment">// 说明栈 1 已经是空栈，溢出</span></span><br><span class="line">    *e = S -&gt; data[S -&gt; top1--];		<span class="comment">// 将栈 1 的栈顶元素出栈</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(stackNumber == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(S -&gt; top2 == MAXSIZE)</span><br><span class="line">      <span class="keyword">return</span> ERROR;						<span class="comment">// 说明栈 2 已经是空栈，溢出</span></span><br><span class="line">    *e = S -&gt; data[S -&gt; top2++];		<span class="comment">// 将栈 2 的栈顶元素出栈</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，使用这样的数据结构，通常都是当两个栈的空间需求有相反的关系时，也就是一个栈增长时另一个栈在缩短的情况。当然，这只是针对两个具有相同数据类型的栈的一个设计上的技巧，如果不是相同数据类型的栈，这种办法不但不能更好地处理问题，反而会使问题变得更复杂。</p>
<h3 id="栈的链式存储结构及实现"><a href="#栈的链式存储结构及实现" class="headerlink" title="栈的链式存储结构及实现"></a>栈的链式存储结构及实现</h3><h4 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h4><p><strong>栈的链式存储结构，简称链栈</strong>。对于链栈来说，栈顶是放在单链表的头部，栈顶在头部，单链表中的中结点也失去了意义，所以是不需要头结点的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E9%93%BE%E6%A0%88.png" alt="链栈"></p>
<p>对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间，如果真的发生，那此时的计算机操作系统已经面临司机崩溃的情况，而不是这个链栈是否溢出的问题。</p>
<p>但对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是 top &#x3D; NULL 的时候。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">  SElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode, *LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span> &#123;</span></span><br><span class="line">  LinkStackPtr top;</span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure>

<p>链栈的操作绝大部分都和单链表类似，指示在插入和删除上，特殊一些。</p>
<h4 id="栈的链式存储结构——进栈操作"><a href="#栈的链式存储结构——进栈操作" class="headerlink" title="栈的链式存储结构——进栈操作"></a>栈的链式存储结构——进栈操作</h4><p>对于链栈的进栈 push 操作，假设元素值为 e 的新结点是 s，top 为栈顶指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入元素 e 为新的栈顶元素</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(LinkStack *S, SElemType e)</span> &#123;</span><br><span class="line">  LinkStackPtr s = (LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">  s -&gt; data = e;</span><br><span class="line">  s -&gt; next = S -&gt; top;		<span class="comment">// 把当前的栈顶元素赋值给新结点的直接后继</span></span><br><span class="line">  S -&gt; top = s;				<span class="comment">// 将新的结点 s 赋值给栈顶指针</span></span><br><span class="line">  S -&gt; count++;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="栈的链式存储结构——出栈操作"><a href="#栈的链式存储结构——出栈操作" class="headerlink" title="栈的链式存储结构——出栈操作"></a>栈的链式存储结构——出栈操作</h4><p>至于链栈的出栈 pop操作，也是很简单的三句操作。假设变量 p 用来存储要删除的栈顶结点，将栈顶指针下移一位，最后释放 p 即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若栈不空，则删除 S 的栈顶元素，用 e 返回其值，并返回 OK；否则返回 ERROR</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(LinkStack *S, SElemType *e)</span> &#123;</span><br><span class="line">  LinkStackPtr p;</span><br><span class="line">  <span class="keyword">if</span>(StackEmpty(*S))</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  *e = S -&gt; top -&gt; data;</span><br><span class="line">  p = S -&gt; top;						<span class="comment">// 将栈顶结点赋值给 p</span></span><br><span class="line">  S -&gt; top = S -&gt; top -&gt; next;		<span class="comment">// 使得栈顶指针下移一位，指向后一结点</span></span><br><span class="line">  <span class="built_in">free</span>(p);							<span class="comment">// 释放结点 p</span></span><br><span class="line">  S -&gt; count--;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链栈的进栈 push 和出栈 pop操作都没有任何循环，时间复杂度都是 O(1)。</p>
<p>对比一下顺序栈和链栈，它们在时间复杂度上是一样的，均为 O(1)。对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。所以它们的区别和线性表中讨论的一样，<strong>如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些</strong>。</p>
<h3 id="栈的作用"><a href="#栈的作用" class="headerlink" title="栈的作用"></a>栈的作用</h3><p>栈的引入简化了程序设计的问题，划分了不同关注层次，是的思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。</p>
<p>所以现在的很多高级语言，比如 Java、C# 等都有对栈结构的封装，不用关心它的实现细节，就可以直接使用 Stack 的 push 和 pop 方法，很方便。</p>
<h3 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h3><blockquote>
<p>栈有一个很重要的应用：在程序设计语言中实现了递归。</p>
</blockquote>
<h4 id="斐波那契数列实现"><a href="#斐波那契数列实现" class="headerlink" title="斐波那契数列实现"></a>斐波那契数列实现</h4><table>
<thead>
<tr>
<th align="center">1</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">5</th>
<th align="center">8</th>
<th align="center">13</th>
<th align="center">21</th>
<th align="center">34</th>
<th align="center">55</th>
<th align="center">89</th>
<th align="center">144</th>
</tr>
</thead>
</table>
<p>表格中的数据特点：前两相邻两项之和，构成了后一项。</p>
<p>用数学函数定义：</p>
<p>F(n) &#x3D; 0，当 n &#x3D; 0；</p>
<p>F(n) &#x3D; 1，当 n &#x3D; 1；</p>
<p>F(n) &#x3D; F(n -1) + F(n - 2)，当 n &gt; 1</p>
<p>常用迭代方法实现，输出前 40 位：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">40</span>];</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    System.out.print(a[<span class="number">0</span>] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.print(a[<span class="number">1</span>] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">        a[i] = a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>];</span><br><span class="line">        System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契的递归函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fbi</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fbi(i - <span class="number">1</span>) + fbi(i - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">40</span>; j++)</span><br><span class="line">        System.out.print(fbi(j) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归的定义"><a href="#递归的定义" class="headerlink" title="递归的定义"></a>递归的定义</h4><p><strong>把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，乘坐递归函数。每个递归定义必须至少有一个条件，满足时递归不再进行，既不再引用自身而是返回值退出</strong>。</p>
<p>迭代和递归的区别：迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会消耗大量的时间和内存。迭代则不需要反复调用和占用额外的内存。因此应该视不同情况选择不同的代码实现方式。</p>
<h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><blockquote>
<p>队列 (queue) 是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p>
</blockquote>
<p><strong>队列是一种先进先出 (First In First Out) 的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E9%98%9F%E5%88%97.png" alt="队列"></p>
<h3 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h3><p>同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 队列(Queue)</span><br><span class="line">Data</span><br><span class="line">  同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">  <span class="title function_">InitQueue</span><span class="params">(*Q)</span>: 初始化操作，建立一个空队列 Q。</span><br><span class="line">  <span class="title function_">DestroyQueue</span><span class="params">(*Q)</span>: 若队列 Q 存在，则销毁它。</span><br><span class="line">  <span class="title function_">ClearQueue</span><span class="params">(*Q)</span>: 将队列 Q 清空。</span><br><span class="line">  <span class="title function_">QueueEmpty</span><span class="params">(Q)</span>: 若队列 Q 为空，返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line">  <span class="title function_">GetHead</span><span class="params">(Q, *e)</span>: 若队列 Q 存在且非空，用 e 返回队列 Q 的队头元素。</span><br><span class="line">  <span class="title function_">EndQueue</span><span class="params">(*Q, e)</span>: 若队列 Q 存在，插入新元素 e 到队列 Q 中并成为队尾元素。</span><br><span class="line">  <span class="title function_">DeQueue</span><span class="params">(*Q, *e)</span>: 删除队列 Q 中队头元素，并用 e 返回其值。</span><br><span class="line">  <span class="title function_">QueueLength</span><span class="params">(Q)</span>: 返回队列 Q 的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>

<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><h4 id="队列顺序存储的不足"><a href="#队列顺序存储的不足" class="headerlink" title="队列顺序存储的不足"></a>队列顺序存储的不足</h4><p>假设一个队列有 n 个元素，则顺序存储的队列需建立一个大于 n 的数组，并把队列的所有元素存储在数组的前 n 个单元，数组下标为 0 的一端即是队头。所谓的入队列操作，其实就是在队尾追加一个元素，不需要移动任何元素，因此时间复杂度为 O(1)。</p>
<p>与栈不同的是，队列元素的出列是在队头，即下标为 0 的位置，那也就意味着，队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为 0 的位置不为空，此时时间复杂度为 O(n)。</p>
<p>队列不限制元素必须存储在数组的前 n 个单元这一条件，出队的性能就会大大增加。也就是说，队头不需要一定在下标为 0 的位置。</p>
<p>为了避免当只有一个元素时，队头和队尾重合使得处理变得麻烦，所以引入两个指针，front 指针指向队头元素，rear 指针指向队尾元素的下一个位置，这样当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列。</p>
<p>假设是长度为 5 的数组，初始状态，front 与 rear 指针均指向下标为 0 的位置。然后入队 a1、a2、a3、a4，front 指针依然指向下标为 0 位置，而 rear 指针指向下标为 4 的位置。</p>
<p>出队 a1、a2，则 front 指针指向下标为 2 的位置，rear 不变，在入队 a5，此时 front 指针不变，rear 指针移动到数组之外。因为此时数组末尾元素已经占用，再向后加，就会产生数组越界的错误。可实际上，队列在下标为 0 和 1 的地方还是空闲的。这种现象叫做“假溢出”。</p>
<h4 id="循环队列定义"><a href="#循环队列定义" class="headerlink" title="循环队列定义"></a>循环队列定义</h4><p>解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。<strong>我们把队列的这种头尾相接的顺序存储结构称为循环队列</strong>。</p>
<p>继续上面的例子，入队 a5 时，rear 改为指向下标为 0 的位置，这样就不会造成指针指向不明的问题了。</p>
<p>接着入队 a6，将它放置于下标为 0 处，rear 指针指向下标为 1 处。若再入队a7，则 rear 指针就与 front 指针重合，同时指向下标为 2 的位置。</p>
<p>空队列时，front 等于 rear， 但是现在队列满时，也是 front 等于 rear，如何判断此时的队列究竟是空还是满呢？</p>
<ul>
<li>方法一：设置一个标志变量 flag，当 front &#x3D;&#x3D; rear，且 flag &#x3D; 0 时为空队列，当 front &#x3D;&#x3D; rear，且 flag &#x3D; 1 时为满队列。</li>
<li>方法二：当队列空时，条件就是 front &#x3D;&#x3D; rear，当队列满时，修改其条件，保留一个元素空间。队列满时，数组中还有一个空闲单元。</li>
</ul>
<p>方法二中，由于 rear 可能比 front 大，也可能比 front 小，所以尽管指向差一个位置时就是满的情况，但也可能是相差整整一圈。所以队列的最大尺寸为 QueueSize，那么<strong>队列满的条件是 (rear + 1) % QueueSize &#x3D;&#x3D; front</strong> (取模 “%” 的目的就是为了整合 rear 与 front 大小为一个问题)。</p>
<p>另外，当 rear &gt; front 时，此时队列的长度为 rear - front。但当 rear &lt; front 时，队列长度分为两段，一段是 QueueSize - front，另一段是 0 + rear，加在一起，队列长度为 rear - front + QueueSize。因此通用的计算队列长度公式为：</p>
<p><strong>(rear - front + QueueSize) % QueueSize</strong></p>
<p>循环队列的顺序存储结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;		<span class="comment">// QElemType 类型根据实际情况而定，这里假设为 int </span></span><br><span class="line"><span class="comment">// 循环队列的顺序存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  QElemType data[MAXSIZE];</span><br><span class="line">  <span class="type">int</span> front;				<span class="comment">// 头指针</span></span><br><span class="line">  <span class="type">int</span> rear;					<span class="comment">// 尾指针，若队列不空，指向队列尾元素的下一个位置</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>

<p>循环队列的初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个空队列</span></span><br><span class="line">Status <span class="title function_">InitQueue</span><span class="params">(SqQueue *Q)</span> &#123;</span><br><span class="line">  Q -&gt; front = <span class="number">0</span>;</span><br><span class="line">  Q -&gt; rear = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环队列求队列长度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 Q 的元素个数，也就是队列的当前长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueLength</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (Q.rear - Q.front + MAXSIZE) % MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环队列的入队列操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若队列未满，则插入元素 e 为 Q 新的队列元素</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(SqQueue *Q, QElemType e)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>((Q -&gt; rear + <span class="number">1</span>) % MAXSIZE == Q -&gt; front)		<span class="comment">// 队列满的判断</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  Q -&gt; data[Q -&gt; rear] = e;							<span class="comment">// 将元素 e 赋值给队尾</span></span><br><span class="line">  Q -&gt; rear = (Q -&gt; rear + <span class="number">1</span>) % MAXSIZE;			<span class="comment">// rear 指针向后移一位置，若到最后则转到数组头部</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环队列的出队操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(SqQueue *Q, QElemType *e)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(Q -&gt; front == Q -&gt; rear)					<span class="comment">// 队列空的判断</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  *e = Q -&gt; data[Q -&gt; front];					<span class="comment">// 将队列元素赋值给 e</span></span><br><span class="line">  Q -&gt; front = (Q -&gt; front + <span class="number">1</span>) % MAXSIZE;		<span class="comment">// front 指针向后移一位置，若到最后则转到数组头部</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列的链式存储结构及实现"><a href="#队列的链式存储结构及实现" class="headerlink" title="队列的链式存储结构及实现"></a>队列的链式存储结构及实现</h3><p><strong>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，把它称为链队列</strong>。为了操作上的方便，我们将队头指针指向链队列的头结点，而队列指针指向终端结点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0.png" alt="队列的链式存储结构及实现"></p>
<p>空队列时，front 和 rear 都指向头结点。</p>
<p>链队列的结构为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;		<span class="comment">// QElemType 类型根据实际情况而定，这里假设为 int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span>		<span class="comment">// 结点结构</span></span><br><span class="line">  QElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>				<span class="comment">// 队列的链表结构</span></span><br><span class="line">  QueuePtr front, rear;		<span class="comment">// 队头、队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>

<h4 id="队列的链式存储结构——入队操作"><a href="#队列的链式存储结构——入队操作" class="headerlink" title="队列的链式存储结构——入队操作"></a>队列的链式存储结构——入队操作</h4><p>入队操作就是在链表尾部插入结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入元素 e 为 Q 的新的队尾元素</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(LinkQueue *Q, QElemType e)</span> &#123;</span><br><span class="line">  QueuePtr s = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">  <span class="keyword">if</span>(!s)						<span class="comment">// 存储分配失败</span></span><br><span class="line">    <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">  s -&gt; data = e;</span><br><span class="line">  s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">  Q -&gt; rear -&gt; next = s;		<span class="comment">// 把拥有元素 e 新结点 s 赋值给原队尾结点的后继</span></span><br><span class="line">  Q -&gt; rear = s;				<span class="comment">// 把当前的 s 设置为队尾结点，rear 指向 s</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="队列的链式存储结构——出队操作"><a href="#队列的链式存储结构——出队操作" class="headerlink" title="队列的链式存储结构——出队操作"></a>队列的链式存储结构——出队操作</h4><p>出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素时，则需将 rear 指向头结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若队列不空，删除 Q 的队列元素，用 e 返回其值，并返回 OK，否则返回 ERROR</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(LinkQueue *Q, QElemType *e)</span> &#123;</span><br><span class="line">  QueuePtr p;</span><br><span class="line">  <span class="keyword">if</span>(Q -&gt; front == Q -&gt; rear)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  p = Q -&gt; front -&gt; next;				<span class="comment">// 将预删除的队头结点暂存给 p</span></span><br><span class="line">  *e = p -&gt; data;						<span class="comment">// 将预删除的队头结点的值赋值给 e</span></span><br><span class="line">  Q -&gt; front -&gt; next = p -&gt; next;		<span class="comment">// 将原队头结点后继 p -&gt; next 赋值给头结点后继</span></span><br><span class="line">  <span class="keyword">if</span>(Q -&gt; rear == p)					<span class="comment">// 若队头是队尾，则删除后将 rear 指向头结点</span></span><br><span class="line">    Q -&gt; rear = Q -&gt; front;</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于循环队列与链队列的比较，可以从两方面来考虑， 从时间上，其实它们的基本操作都是常数时间，即都为 O(1) 的，不过循环队列是实现申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。对于空间上来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵活。总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果无法预估队列的长度时，则用链队列。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>栈 (Stack) 是限定仅在表尾进行插入和删除操作的线性表。</p>
<p>队列 (queue) 是只允许在一段进行插入操作，而在另一端进行删除操作的线性表。</p>
<p>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。</p>
<p>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得插入和删除是 O(n) 的时间复杂度变成了 O(1)。</p>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h3><blockquote>
<p>串：是由零个或多个字符组成的有限序列，又名叫字符串。</p>
</blockquote>
<p><strong>一般记为 s &#x3D; “a<sub>1</sub>a<sub>2</sub> …… a<sub>n</sub>“ (n ≥ 0)<strong>，其中，s 是串的名称，用双引号括起来的字符序列是串的值，注意单引号不属于串的内容。a<sub>i</sub> (1 ≤ i ≤ n) 可以是字母、数字或其他字符，i 就是该字符在串中的位置。</strong>串中的字符数目 n 称为串的长度</strong>，定义中谈到的“有限”是指长度 n 是一个有限的数值。**零个字符的串称为空串 (null string)**，它的长度为零，可以直接用两双引号 “” 表示，也可以用希腊字母 𝛟 来表示。所谓的序列，说明串的相邻字符之间具有前驱和后继的关系。</p>
<p>空格串，是只包含空格的串。注意它与空串的区别，空格串是有内容长度的，而且可以不止一个空格。</p>
<p>子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。</p>
<p>子串在主串中的位置就是子串的第一个字符在主串中的序号。</p>
<p>“over”、“end“、”lie“ 其实可以认为是 ”lover“、”friend“、”believe“ 这些单词字符串的子串。</p>
<h3 id="串的比较"><a href="#串的比较" class="headerlink" title="串的比较"></a>串的比较</h3><p>两个数字，很容易比较大小。2 比 1 大，这完全正确，可是两个字符串如何比较？比如 ”silly“、”stupid“ 这样的同样表达”愚蠢的“的单词字符串，它们在计算机中的大小其实取决于它们挨个字母的前后顺序。它们的第一个字母都是 ”s”，我们认为不存在大小差异，而第二个字母，由于 “i” 字母比 “t” 字母要靠前，所以 “i“ &lt; “t”，于是我们说 “silly” &lt; “stupid”。</p>
<p>事实上，串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的是字符在对应字符集中的序号。</p>
<p>计算机中的常用字符是使用标准的 ASCII 编码，更准确一点，由 7 位二进制数表示一个字符，总共可以表示 128 个字符。后来发现一些特殊符号的出现，128 个不够用，于是扩展 ASCII 码由 8 位二进制数表示一个字符，总共可以表示 256 个字符，这已经足够满足以英语为主的语言和特殊符号进行输入、存储、输出等操作的字符需要了。可是，单我们国家就有除汉族外的满、回、藏、蒙古、维吾尔等多个少数民族文字，换作全世界估计要有成百上千种语言与文字，显然这 256 个字符是不够的，因此后来就有了 Unicode 编码，比较常用的是由 16 位二进制数表示一个字符，这样总共就可以表示 216 个字符，约是 65 万多个字符，足够表示世界上所有语言的所有字符了。当然，为了和 ASCII 码兼容，Unicode 的前 256 个字符与 ASCII 码完全相同。</p>
<p>所以如果在 C 语言中比较两个串是否相等，必须是它们串的长度以及它们各个对应位置的字符都相等时，才算是相等的。即给定两个串：s &#x3D; “a<sub>1</sub>a<sub>2</sub> …… a<sub>n</sub>“，t &#x3D; “b<sub>1</sub>b<sub>2</sub> …… b<sub>m</sub>“，当且仅当 n &#x3D; m，且 a<sub>1</sub> &#x3D; b<sub>1</sub>，a<sub>2</sub> &#x3D; b<sub>2</sub>，…… ，a<sub>n</sub> &#x3D; a<sub>m</sub> 时，我们认为 s &#x3D; t。</p>
<blockquote>
<p>那么对于两个串不相等时，如何判定它们的大小？</p>
</blockquote>
<p><strong>给定两个串：s &#x3D; “a<sub>1</sub>a<sub>2</sub> …… a<sub>n</sub>“，t &#x3D; “b<sub>1</sub>b<sub>2</sub> …… b<sub>m</sub>“，当满足一下条件之一时，s &lt; t。</strong></p>
<ol>
<li><p>**n &lt; m，且 a<sub>i</sub> &#x3D; b<sub>i</sub> (i &#x3D; 1, 2, …… , n)**。</p>
<p> 例如当 s &#x3D; “hap”，t &#x3D; “happy”，就有 s &lt; t。因为 t 比 s 多出了两个字母。</p>
</li>
<li><p>**存在某个 k ≤ min(m, n)，使得 <sub>i</sub> &#x3D; b<sub>i</sub> (i &#x3D; 1, 2, ……, k - 1)，且a<sub>k</sub> &lt; b<sub>k</sub>**。</p>
<p> 例如当 s &#x3D; “happen”，t &#x3D; “happy”，因为两串的前 4 个字母均相同，而两串第 5 个字母 (k 值)，字母 e 的 ASCII 码是 101，而字母 y 的 ASCII 码是 121，显然 e &lt; y，所以 s &lt; t。</p>
</li>
</ol>
<h3 id="串的抽象数据类型"><a href="#串的抽象数据类型" class="headerlink" title="串的抽象数据类型"></a>串的抽象数据类型</h3><p>串的逻辑结构和线性表很相似，不同之处在于串针对的是字符集，也就是串中的元素都是字符，哪怕串中的字符是 “123” 这样的数字组成，或者 “2022-08-08” 这样的日期组成，它们都只能理解为长度为 3 和长度为 10 的字符串，每个元素都是字符而已。</p>
<p>因此，对于串的基本操作与线性表是有很大差别的。线性表更关注的是单个元素的操作，比如查找一个元素，插入或删除一个元素，但串中更多的是查找子串位置、得到指定位置子串、替换子串等操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ADT 串(<span class="built_in">string</span>)</span><br><span class="line">Data</span><br><span class="line">  串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">  <span class="title function_">StrAssign</span><span class="params">(T, *chars)</span>: 生成一个其值等于字符串常量 chars 的串 T。</span><br><span class="line">  <span class="title function_">StrCopy</span><span class="params">(T, S)</span>: 串 S 存在，由串 S 复制得串 T。</span><br><span class="line">  <span class="title function_">ClearString</span><span class="params">(S)</span>: 串 S 存在，将串清空。</span><br><span class="line">  <span class="title function_">StringEmpty</span><span class="params">(S)</span>: 若串 S 为空，返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line">  <span class="title function_">StrCompare</span><span class="params">(S, T)</span>: 若 S &gt; T，返回值 &gt; 0，若 S = T，返回 <span class="number">0</span>，若 S &lt; T，返回值 &lt; <span class="number">0</span>。</span><br><span class="line">  StrLength(S): 返回串 S 的元素个数，即串的长度。</span><br><span class="line">  Concat(T, S1, S2): 用 T 返回由 S1 和 S2 连接而成的新串。</span><br><span class="line">  SubString(Sub, S, pos, len): 串 S 存在，<span class="number">1</span> ≤ pos ≤ StrLength(S)，且 <span class="number">0</span> ≤ len ≤ StrLength(S) - pos + <span class="number">1</span>，用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串。</span><br><span class="line">  Index(S, T, pos): 串 S 和 T 存在，T 是非空串，<span class="number">1</span> ≤ pos ≤ StrLength(S)。若主串 S 中存在和串 T 值相同的子串，则返回它在主串 S 中第 pos 个字符之后第一次出现的位置，否则返回 <span class="number">0</span>。</span><br><span class="line">  Replace(S, T, V): 串 S、T 和 V 存在，T 是非空串。用 V 替换主串 S 中出现的所有与 T 相等的不重叠的子串。</span><br><span class="line">  StrInsert(S, pos, T): 串 S 和 T 存在，<span class="number">1</span> ≤ pos ≤ StrLength(S) + <span class="number">1</span>。在串 S 的第 pos 个字符之前插入串 T。</span><br><span class="line">  StrDelete(S, pos, len): 串 S 存在，<span class="number">1</span> ≤ pos ≤StrLength(S) - len + <span class="number">1</span>。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>

<p>操作 Index 的实现算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 为非空串。若主串 S 中第 pos 个字符之后存在与 T 相等的子串，则返回第一个这样的子串在 S 中的位置，否则返回 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(String S, String T, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n, m, i;</span><br><span class="line">  String sub;</span><br><span class="line">  <span class="keyword">if</span>(pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    n = StrLength(S);					<span class="comment">// 得到主串 S 的长度</span></span><br><span class="line">    m = StrLength(T);					<span class="comment">// 得到子串 T 的长度</span></span><br><span class="line">    i = pos;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n - m + <span class="number">1</span>) &#123;</span><br><span class="line">      SubString(sub, S, i, m);			<span class="comment">// 取主串第 i 个位置，长度与 T 相等子串给 sub</span></span><br><span class="line">      <span class="keyword">if</span>(StrCompare(sub, T) != <span class="number">0</span>)		<span class="comment">// 如果两串不相等</span></span><br><span class="line">        ++i;</span><br><span class="line">      <span class="keyword">else</span>								<span class="comment">// 如果两串相等</span></span><br><span class="line">        <span class="keyword">return</span> i;						<span class="comment">// 则返回 i 值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;								<span class="comment">// 若无子串与 T 相等，返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h3><h4 id="串的顺序存储结构"><a href="#串的顺序存储结构" class="headerlink" title="串的顺序存储结构"></a>串的顺序存储结构</h4><p>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义。</p>
<p>既然是定长数组，就存在一个预定义的最大串长度，一般可以将实际的串长度值保存在数组的 0 下标位置 (也可以定义存储在数组的最后一个下标位置)。有些编程语言觉得存个数字占个空间麻烦。它规定在串值后面加一个不计入串长度的结束标记字符，比如 “\0“ 来表示串值的终结。但是，当遍历计算串长度时，会发现结束标记字符也是占用了一个空间的。</p>
<p>以上所说的串的顺序存储方式其实是有问题的，因为字符串的操作，比如两串的连接 Concat、新串的插入 StrInsert，以及字符串的替换 Replace，都有可能使得串序列的长度超过了数组的长度 MaxSize。</p>
<h4 id="串的链式存储结构"><a href="#串的链式存储结构" class="headerlink" title="串的链式存储结构"></a>串的链式存储结构</h4><p>对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用 “#” 或其它非串值字符补全。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E4%B8%B2%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="串的链式存储结构"></p>
<p>当然，这里一个结点存多少个字符才合适就变得很重要，这会直接影响着串处理的效率，需要根据实际情况做出选择。但串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。</p>
<h3 id="朴素的模式匹配算法"><a href="#朴素的模式匹配算法" class="headerlink" title="朴素的模式匹配算法"></a>朴素的模式匹配算法</h3><p><strong>子串的定位操作通常称做串的模式匹配</strong>。</p>
<p>假设要从下面的主串 S &#x3D; “goodgoogle” 中，找到 T &#x3D; “google” 这个子串的位置。步骤如下：</p>
<ol>
<li>主串 S 第一位开始，S 与 T 前三个字母都匹配成功，但 S 第四个字母是 d 而 T 的是 g。第一位匹配失败。</li>
<li>主串 S 第二位开始，主串 S 首字母是 o，要匹配的 T 首字母是 g，匹配失败。</li>
<li>主串 S 第三位开始，主串 S 首字母是 o，要匹配 T 首字母是 g，匹配失败。</li>
<li>主串 S 第四位开始，主串 S 首字母是 d，要匹配的 T 首字母是 g，匹配失败。</li>
<li>主串 S 第五位开始，S 与 T，6 个字母全匹配，匹配成功。</li>
</ol>
<p>简单的说，就是对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做 T 的长度的小循环，直到匹配成功或全部遍历完成为止。</p>
<p>假设主串 S 和要匹配的子串 T 的长度存在 S[0] 与 T[0] 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回子串 T 在主串中第 pos 个字符之后的位置。若不存在，则函数返回值为 0。T 非空，1 ≤ pos ≤ StrLength(S)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(String s, String T, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = pos;							<span class="comment">// i 用于主串 S 中当前位置下标，若 pos 不为 1，则从 pos 位置开始匹配</span></span><br><span class="line">  <span class="type">int</span> j = <span class="number">1</span>;							<span class="comment">// j 用于子串 T 中当前位置下标值</span></span><br><span class="line">  <span class="keyword">while</span>(i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) &#123;		<span class="comment">// 若 i 小于 S 长度且 j 小于 T 的长度时循环</span></span><br><span class="line">    <span class="keyword">if</span>(S[i] == T[j]) &#123;					<span class="comment">// 两字母相等则继续</span></span><br><span class="line">      ++i;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;								<span class="comment">// 指针后退重新开始匹配</span></span><br><span class="line">      i = i - j + <span class="number">2</span>;					<span class="comment">// i 退回到上次匹配首位的下一位</span></span><br><span class="line">      j = <span class="number">1</span>;							<span class="comment">// j 退回到子串 T 的首位</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(j &gt; T[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好的情况是一开始就匹配成功，比如 “googlegood” 中去找 “google”，时间复杂度为 O(1)。如果在 “abcdefgoogle” 中去找 “google”，那么时间复杂度为 O(n + m)，其中 n 为主串长度，m 为要匹配的子串长度。根据等概率原则，平均是 (n + m) &#x2F; 2 次查找，时间复杂度为 O(n + m)。</p>
<p>最坏的情况是每次不成功的匹配都发生在串 T 的最后一个字符。例如主串为 S &#x3D; “00000000000000000000000000000000000001”，而要匹配的子串为 T &#x3D; ”0000000001“，前者是有 49 个 ”0“ 和 1 个 ”1“ 的主串，后者是有 9 个 ”0“ 和 1 个 ”1“ 的子串。在匹配时，每次都得将 T 中字符循环到最后一位才发现它们不匹配。这样等于 T 串需要在 S 串 的前 40 个位置都需要判断 10 次，并得出不匹配的结论。</p>
<p>知道最后第 41 个位置，因为全部匹配相等，所以不需要再继续进行下去。如果最终没有课匹配的子串，比如是 T &#x3D; ”0000000002“，到了第 41 位置判断不匹配后同样不需要继续比对下去。因此最坏情况的时间复杂度为 O((n - m + 1) * m)。</p>
<p>对于计算机来说，处理的都是二进位的 0 和 1 的串，一个字符的 ASCII 码也可以看成是 8 位的二进位 01 串，当然，汉字等所有的字符也都可以看成是多个 0 和 1 串。再比如像计算机图形也可以理解为是由许许多多个 0 和 1 的串组成。所以在计算机的运算当中，模式匹配操作可说是随处可见，而刚才的这个算法，就显得太低效了。</p>
<h3 id="KMP-模式匹配算法"><a href="#KMP-模式匹配算法" class="headerlink" title="KMP 模式匹配算法"></a>KMP 模式匹配算法</h3><p>D.EKnuth、J.H.Morris 和 V.R.Pratt (其中 Knuth 和 Pratt 共同研究，Morris 独立研究) 发表了一个<strong>匹配模式算法，可以大大避免重复遍历的情况，称之为克努特——莫里斯——普拉特算法，简称 KMP 算法</strong>。</p>
<h4 id="KMP-模式匹配算法原理"><a href="#KMP-模式匹配算法原理" class="headerlink" title="KMP 模式匹配算法原理"></a>KMP 模式匹配算法原理</h4><p>如果主串 S &#x3D; “abcdefgab”，匹配 T &#x3D; “abcdex”，如果用朴素算法的话，前 5 个字母，两个串完全相等，知道第 6 个字母，”f“ 与 ”x“ 不等，如 ① 所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%951.png" alt="朴素模式匹配算法"></p>
<p>接下来，按照朴素模式匹配算法，应该是图中 ②③④⑤⑥的顺序。即主串 S 中当 i &#x3D; 2、3、4、5、6 时，首字符与子串 T 的首字符均不等。</p>
<p>对于要匹配的子串 T 来说，“abcdex” 首字母 “a“ 与后面的串 ”bcdex“ 中任意一个字符都不相等。也就是说，既然 ”a“ 不与自己后面的子串中任何一个字符相等，那么对于图中 ① 来说，前五位字符分别相等，意味着子串 T 的首字符 ”a“ 不可能与 S 串的第 2 位到第 5 位的字符相等。②③④⑤ 的判断都是多余的。</p>
<p>这是理解 KMP 算法的关键。如果 T 串中首字符 ”a” 与 T 中后面的字符均不相等。而 T 串的第二位的 “b” 与 S 串中第二位的 “b”在 ① 中已经判断是相等的，那么也就意味着，T 串中首字符 “a“ 与 S 串中的第二位 ”b“ 是不需要判断也知道它们是不可能相等了，这样 ② 这一步判断是可以省略的。</p>
<p>同样道理，在知道 T 串中首字符 ”a” 与 T 中后面的字符均不相等的前提下，T 串的 “a” 与 S 串后面的 “c”、“d”、“e” 也都可以在 ① 之后就可以确定是不相等的，所以这个算法当中 ②③④⑤ 没有必要，只保留 ①⑥ 即可。</p>
<p>之所以保留 ⑥ 中的判断是因为在 ① 中 T[6] ≠ S[6]，尽管已经知道 T[1] ≠ T[6]，但也不能判定 T[1] 一定不等于 S[6]，因此需要保留 ⑥ 这一步。</p>
<blockquote>
<p>如果 T 串后面也含有首字符 “a” 的字符怎么办？</p>
</blockquote>
<p>假设 S &#x3D; “abcabcabc”，T &#x3D; “abcabx”。对于开始的判断，前 5 个字符完全相等，第6个字符不等，如图中的 ①。此时，T 的首字符 “a” 与 T 的第二位字符 “b”、第三位字符 “c” 均不相等，所以不需要做判断，步骤 ②③ 都是多余的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%952.png" alt="朴素模式匹配算法2"></p>
<p>因为 T 的首位 “a” 与 T 第四位的 “a” 相等，第二位的 “b” 与第五位的 “b” 相等。而在 ① 时，第四位的 “a” 与 第五位的 “b” 已经与主串 S 中相应位置比较过了，是相等的，因此可以判定，T 的首字符 “a”、第二位的字符 “b” 与 S 的第四位字符和第五位字符也不需要比较了，肯定也是相等的。所以 ④⑤ 这两个比较得出字符相等的步骤也可以省略。</p>
<p>也就是说，对于在子串中有与首字符相等的字符，也是可以省略一部分不必要的判断步骤。省略掉 ⑥ 中 T 串前两位 “a” 与 “b” 同 S 串中的 4、5位置字符匹配操作。</p>
<p>对比这两个例子，会发现在 ① 时，我们的 i 值，也就是主串当前位置的下标是 6，②③④⑤，i 值是2、3、4、5，到了 ⑥，i 值才又回到了 6.即我们在朴素的模式匹配算法中，主串的 i 值是不断地回溯来完成的。而分析发现，这种回溯其实是可以不需要的，KMP 模式匹配算法就是为了让这没必要的回溯不发生。</p>
<p>既然 i 值不回溯，也就是不可以变小，那么要考虑的变化就是 j 值了。通过观察也发现，T 串的首字符与自身后面字符的比较，发现如果有相等字符，j 值的变化就会不相同。也就是说，这个 j 值的变化与主串起时没什么关系，关键就取决于 T 串的结构中是否有重复的问题。</p>
<p>第一个例子中，由于 T &#x3D; “abcdex”，当中没有任何重读的字符，所以 j 就由 6 变为 1。而第二个例子中 T &#x3D; “abcabx”，前缀的 “ab” 与最后 “x” 之前串的后缀 “ab” 是相等的。因此 j 就由 6 变为了 3。可以得出规律，j 值的多少取决于当前字符之前的串的前后缀的相似度。</p>
<p>把 T 串各个位置的 j 值的变化定义为一个数组 next，那么 next 的长度就是 T 串的长度。得出下面的函数定义：</p>
<p>next[j] &#x3D; 0，当 j &#x3D; 1 时，</p>
<p>next[j] &#x3D; Max{ k | 1 &lt; k &lt; j, 且 ‘p<sub>1 ··· k - 1</sub>‘ &#x3D; ‘p<sub>j - k + 1</sub> ··· p<sub>j - 1</sub>‘} 当集合和不空时，</p>
<p>next[j] &#x3D; 1，其他情况</p>
<h4 id="next-数组值推导"><a href="#next-数组值推导" class="headerlink" title="next 数组值推导"></a>next 数组值推导</h4><blockquote>
<p>具体如何推导出一个串的 next 数组值？</p>
</blockquote>
<ol>
<li><p>T &#x3D; “abcdex”</p>
<table>
<thead>
<tr>
<th align="center">j</th>
<th align="center">123456</th>
</tr>
</thead>
<tbody><tr>
<td align="center">模式串 T</td>
<td align="center">abcdex</td>
</tr>
<tr>
<td align="center">next[j]</td>
<td align="center">011111</td>
</tr>
</tbody></table>
<ul>
<li>当 j &#x3D; 1 时，next[1] &#x3D; 0；</li>
<li>当 j &#x3D; 2 时，j 由 1 到 j - 1 就只有字符 “a”，属于其他情况 next[2] &#x3D; 1；</li>
<li>当 j &#x3D; 3 时，j 由 1 到 j - 1 串是 “ab”，显然 ”a“ 与 ”b“ 不相等，属其他情况，next[3] &#x3D; 1；</li>
<li>以后同理，所以最终此 T 串的 next[j] &#x3D; 011111。</li>
</ul>
</li>
<li><p>T &#x3D; “abcabx”</p>
<table>
<thead>
<tr>
<th align="center">j</th>
<th align="center">123456</th>
</tr>
</thead>
<tbody><tr>
<td align="center">模式串 T</td>
<td align="center">abcabx</td>
</tr>
<tr>
<td align="center">next[j]</td>
<td align="center">011123</td>
</tr>
</tbody></table>
<ul>
<li>当 j &#x3D; 1 时，next[1] &#x3D; 0；</li>
<li>当 j &#x3D; 2 时，同上例说明，next[2] &#x3D; 1；</li>
<li>当 j &#x3D; 3 时，同上，next[3] &#x3D; 1；</li>
<li>当 j &#x3D; 4 时，同上，next[4] &#x3D; 1；</li>
<li>当 j &#x3D; 5 时，此时 j 由 j - 1 的串是 “abca”，前缀字符 “a” 与后缀字符 “a” 相等，因此可推算出 k 值为2 (由 p<sub>1 ··· k - 1</sub>‘ &#x3D; ‘p<sub>j - k + 1</sub> ··· p<sub>j - 1</sub>，得到 p<sub>1</sub> &#x3D; p<sub>4</sub>)，因此 next[5] &#x3D; 2；</li>
<li>当 j &#x3D; 6 时，j 由 1 到 j - 1 的串是 “abcab”，由于前缀字符 “ab” 与后缀 “ab” 相等，所以 next[6] &#x3D; 3。</li>
</ul>
<p> 我们可以根据经验得到如果前后缀一个字符相等，k 值是 2，两个字符 k 值是 3，n 个相等 k 值就是 n + 1。</p>
</li>
<li><p>T &#x3D; “ababaaaba”</p>
<table>
<thead>
<tr>
<th align="center">j</th>
<th align="center">123456789</th>
</tr>
</thead>
<tbody><tr>
<td align="center">模式串 T</td>
<td align="center">ababaaaba</td>
</tr>
<tr>
<td align="center">next[j]</td>
<td align="center">011234223</td>
</tr>
</tbody></table>
<ul>
<li>当 j &#x3D; 1 时，next[1] &#x3D; 0；</li>
<li>当 j &#x3D; 2 时，同上，next[2] &#x3D; 1；</li>
<li>当 j &#x3D; 3 时，同上，next[3] &#x3D; 1；</li>
<li>当 j &#x3D; 4 时，j 由 1 到 j - 1 的串是 “aba”，前缀字符 “a” 与后缀字符 “a“ 相等，next[4] &#x3D; 2；</li>
<li>当 j &#x3D; 5 时，此时 j 由 j - 1 的串是 “abab”，前缀字符 “ab” 与后缀字符 “ab” 相等，所以 next[5] &#x3D; 3；</li>
<li>当 j &#x3D; 6 时，j 由 1 到 j - 1 的串是 “ababa”，由于前缀字符 “aba” 与后缀 “aba” 相等，所以 next[6] &#x3D; 4；</li>
<li>当 j &#x3D; 7 时，j 由 1 到 j - 1 的串是 “ababaa”，由于前缀字符 “ab” 与后缀 “aa” 并不相等，只有 ”a“ 相等，所以 next[7] &#x3D; 2；</li>
<li>当 j &#x3D; 8 时，j 由 1 到 j - 1 的串是 “ababaaa”，只有 “a” 相等，所以 next[8] &#x3D; 2；</li>
<li>当 j &#x3D; 9 时，j 由 1 到 j - 1 的串是 “ababaaab”，由于前缀字符 “ab” 与后缀 “aba” 相等，所以 next[9] &#x3D; 3。</li>
</ul>
</li>
<li><p>T &#x3D; “aaaaaaaab”</p>
<table>
<thead>
<tr>
<th align="center">j</th>
<th align="center">123456789</th>
</tr>
</thead>
<tbody><tr>
<td align="center">模式串 T</td>
<td align="center">aaaaaaaab</td>
</tr>
<tr>
<td align="center">next[j]</td>
<td align="center">012345678</td>
</tr>
</tbody></table>
<ul>
<li>当 j &#x3D; 1 时，next[1] &#x3D; 0；</li>
<li>当 j &#x3D; 2 时，同上，next[2] &#x3D; 1；</li>
<li>当 j &#x3D; 3 时，j 由 1 到 j - 1 的串是 “aa”，前缀字符 “a” 与后缀字符 “a“ 相等，next[3] &#x3D; 2；</li>
<li>当 j &#x3D; 4 时，j 由 1 到 j - 1 的串是 “aaa”，前缀字符 “aa” 与后缀字符 “aa“ 相等，next[4] &#x3D; 3；</li>
<li>……</li>
<li>当 j &#x3D; 9 时，j 由 1 到 j - 1 的串是 “aaaaaaaa”，由于前缀字符 “aaaaaaa” 与后缀 “aaaaaaa” 相等，所以 next[9] &#x3D; 8。</li>
</ul>
</li>
</ol>
<h4 id="KMP-模式匹配算法实现"><a href="#KMP-模式匹配算法实现" class="headerlink" title="KMP 模式匹配算法实现"></a>KMP 模式匹配算法实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过计算返回子串的 next 数组。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(String T, <span class="type">int</span> *next)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i,j;</span><br><span class="line">  i = <span class="number">1</span>;</span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; T[<span class="number">0</span>]) &#123;						<span class="comment">// 此处 T[0] 表示串 T 的长度</span></span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">0</span> || T[i] == T[j]) &#123;		<span class="comment">// T[i] 表示后缀的单个字符；T[j] 表示前缀的单个字符</span></span><br><span class="line">      ++i;</span><br><span class="line">      ++j;</span><br><span class="line">      next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      j = next[j];						<span class="comment">// 若字符不相同，则 j 值回溯</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是为了计算出当前要匹配的串 T 的 next 数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回子串 T 在主串 S 中第 pos 个字符之后的位置。若不存在，则函数返回值为 0。T 非空，1 ≤ pos ≤ StrLength(S)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(String S, String T, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = pos;							<span class="comment">// i 用于主串 S 当前位置下标值，若 pos 不为 1，则从 pos 位置开始匹配</span></span><br><span class="line">  <span class="type">int</span> j = <span class="number">1</span>;							<span class="comment">// j 用于子串 T 中当前位置下标值</span></span><br><span class="line">  <span class="type">int</span> next[<span class="number">255</span>];						<span class="comment">// 定义一 next 数组</span></span><br><span class="line">  get_next(T, next);					<span class="comment">// 对串 T 作分析，得到 next 数组</span></span><br><span class="line">  <span class="keyword">while</span>(i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) &#123;		<span class="comment">// 若 i 小于 S 的长度且 j 小于 T 的长度时，循环继续</span></span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">0</span> || S[i] == T[j]) &#123;		<span class="comment">// 两字母相等则继续，与朴素算法增加了 j = 0 判断</span></span><br><span class="line">      ++i;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>								<span class="comment">// 指针后退重新开始匹配</span></span><br><span class="line">      j = next[j];						<span class="comment">// j 退回合适的位置，i 值不变</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(j &gt; T[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 get_next 函数来说，若 T 的长度为 m，因只涉及到简单的单循环，其时间复杂度为 O(m)，而由于 i 值的不回溯，是的 index_KMP 算法效率得到了提高，while 循环的时间复杂度为 O(n)。因此整个算法的时间复杂度为 O(n + m)。相较于朴素模式匹配算法的 O((n - m + 1) * m) 来说，好一些。KMP算法仅当模式与主串之间存在许多 “部分匹配” 的情况下才体现出它的优势，否则两者差异并不明显。</p>
<h4 id="KMP-模式匹配算法改进"><a href="#KMP-模式匹配算法改进" class="headerlink" title="KMP 模式匹配算法改进"></a>KMP 模式匹配算法改进</h4><p>KMP 算法是有缺陷的，比如当主串 S &#x3D; “aaaabcde”，子串 T &#x3D; “aaaaax”，其 next 数组分别为 012345，在开始时，当 i &#x3D; 5、j &#x3D; 5 时，发现 “b“ 与 “a” 不相等，如图中的 ①，因此 j &#x3D; next[5] &#x3D; 4，如图中的 ②，此时 “b” 与第 4 位置的 “a” 依然不相等，j &#x3D; next[4] &#x3D; 3，如果中的 ③，后依次是 ④⑤，直到 j &#x3D; next[1] &#x3D; 0 时，根据算法，此时 ++i、j++，得到 i &#x3D; 6、j &#x3D; 1，如图中的 ⑥。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/KMP%E7%AE%97%E6%B3%95.png" alt="KMP算法"></p>
<p>但是可以看出 ②③④⑤ 步骤其实是多余的的判断。由于 T 串的第二、三、四、五位置的字符都与首位 “a” 相等，那么可以用首位 next[1] 的值去取代与它相等的字符后续 next[j] 的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求模式串 T 的 next 函数修正值并存入数组 nextval</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_nextval</span><span class="params">(String T, <span class="type">int</span> *nextval)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  i = <span class="number">1</span>;</span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; T[<span class="number">0</span>]) &#123;						<span class="comment">// 此处 T[0] 表示串 T 的长度</span></span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">0</span> || T[i] == T[j]) &#123;		<span class="comment">// T[i] 表示后缀的单个字符，T[j] 表示前缀的单个字符</span></span><br><span class="line">      ++i;</span><br><span class="line">      ++j;</span><br><span class="line">      <span class="keyword">if</span>(T[i] != T[j])					<span class="comment">// 若当前字符与前缀字符不同</span></span><br><span class="line">        nextval[i] = j;					<span class="comment">// 则当前的 j 为 nextval 在 i 位置的值</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        nextval[i] = nextval[j];		<span class="comment">// 如果与前缀字符相同，则将前缀字符的 nextval值赋值给nextval 在 i 位置的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      j = nextval[i];					<span class="comment">// 若字符不相同，则 j 值回溯</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际匹配算法，只需要将 “get_next(T, next);” 改为 “get_nextval(T, next);” 即可。</p>
<h4 id="nextval-数组值推导"><a href="#nextval-数组值推导" class="headerlink" title="nextval 数组值推导"></a>nextval 数组值推导</h4><p>经过优化后，nextval 值与 next 值不完全相同了。</p>
<ol>
<li><p>T &#x3D; “ababaaaba”</p>
<table>
<thead>
<tr>
<th align="center">j</th>
<th align="center">123456789</th>
</tr>
</thead>
<tbody><tr>
<td align="center">模式串 T</td>
<td align="center">ababaaaba</td>
</tr>
<tr>
<td align="center">next[j]</td>
<td align="center">011234223</td>
</tr>
<tr>
<td align="center">nextval[j]</td>
<td align="center">010104210</td>
</tr>
</tbody></table>
<p> 先算出 next 数组的值分别为 001234223，然后再分别判断。</p>
<ul>
<li>当 j &#x3D; 1 时，nextval[1] &#x3D; 0；</li>
<li>当 j &#x3D; 2 时，因第二位字符 “b“ 的 next 值是 1，而第一位就是 ”a”，它们不相等，所以 nextval[2] &#x3D; next[1] &#x3D; 1；</li>
<li>当 j &#x3D; 3 时，因第三位字符 “a“ 的 next 值是 1，所以与第一位就是 ”a” 比较相等，所以 nextval[3] &#x3D; nextval[1] &#x3D; 0；</li>
<li>当 j &#x3D; 4 时，第四位的字符 “b” next 值为 2，所以与第二位的 “b” 相比较得到结果是相等，因此 nextval[4] &#x3D; nextval[2] &#x3D; 1；</li>
<li>当 j &#x3D; 5 时，next 值为 3，第五个字符 “a” 与第三个字符 ”a” 相等，所以 nextval[5] &#x3D; nextval[3] &#x3D; 0；</li>
<li>当 j &#x3D; 6 时，next 值为 4，第六个字符 “a” 与第四个字符 “b” 不相等，所以 nextval[6] &#x3D; 4；</li>
<li>当 j &#x3D; 7 时，next 值为 2，第七个字符 “a“ 与第二个字符 ”b“ 不相等，所以 nextval[7] &#x3D; 2；</li>
<li>当 j &#x3D; 8 时，next 值为 2，第八个字符 “b” 与第二个字符 ”b“ 相等，所以 nextval[8] &#x3D; nextval[2] &#x3D; 1；</li>
<li>当 j &#x3D; 9 时，next 值为 3，第九个字符 “a” 与第三个字符 ”a” 相等，所以 nextval[9] &#x3D; nextval[3] &#x3D; 1。</li>
</ul>
</li>
<li><p>T &#x3D; “aaaaaaaab”</p>
<table>
<thead>
<tr>
<th align="center">j</th>
<th align="center">123456789</th>
</tr>
</thead>
<tbody><tr>
<td align="center">模式串 T</td>
<td align="center">aaaaaaaab</td>
</tr>
<tr>
<td align="center">next[j]</td>
<td align="center">012345678</td>
</tr>
<tr>
<td align="center">Nextval[j]</td>
<td align="center">00000008</td>
</tr>
</tbody></table>
<p> 先算出 next 数组的值分别为 012345678，然后再分别判断。</p>
<ul>
<li>当 j &#x3D; 1 时，nextval[1] &#x3D; 0；</li>
<li>当 j &#x3D; 2 时，next 值为 1，第二个字符与第一个字符相等，所以 nextval[2] &#x3D; nextval[1] &#x3D; 0；</li>
<li>同样的道理，其后都为 0……</li>
<li>当 j &#x3D; 9，next 值为 8，第九个字符 “b” 与第八个字符 “a” 不相等，所以 nextval[9] &#x3D; 8。、</li>
</ul>
<p> 改进后的 KMP 算法，它是在计算出 next 值的同时，如果 a 位字符与它 next 值指向的 b 位字符相等，则该 a 位的 nextval 就指向 b 位的 nextval 值，如果不等，则该 a 位的 nextval 值就是它自己 a 位的next 的值。</p>
</li>
</ol>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>串 (string) 是由零个或多个字符组成的有限序列，又名叫字符串。本质上，它是一种线性表的扩展，但相对于线性表关注一个个元素来说说，串这种结构更多的是关注它子串的应用问题，如查找、替换等操作。KMP 算法的学习，要有效地去理解 index 函数当中的实现细节。</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><blockquote>
<p>树 (Tree) 是 n (n ≥ 0) 个结点的有限集。n &#x3D; 0 时称为空树。在任意一棵非空树中：(1) 有且仅有一个特定的称为根 (Root) 的结点； (2) 当 n &gt; 1 时，其余结点可分为 m (m &gt; 0) 个互不相交的有限集 T<sub>1</sub>、T<sub>2</sub>、······、T<sub>m</sub>，其中每个集合本身又是一棵树，并且称为根的子树 (SubTree)。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89.png" alt="树的定义"></p>
<ol>
<li>n &gt; 0 时根结点是唯一的，不可能存在多个根结点，别和现实中的大树混在一起，现实中的树有很多根须，那是真实的树，数据结构中的树是只能有一个根结点。</li>
<li>m &gt; 0 时，子树的个数没有限制，但它们一定是互不相交的。</li>
</ol>
<h4 id="结点分类"><a href="#结点分类" class="headerlink" title="结点分类"></a>结点分类</h4><p>树的结点包含一个数据元素及若干指向其子树的分支。<strong>结点拥有的子树称为结点的度 (Degree)。度为 0 的结点称为叶结点 (Leaf) 或终端结点；度不为 0 的结点称为非终端结点或分支结点。除根结点外，分支结点也称为内部结点。树的度是树内各结点的度的最大值</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E7%BB%93%E7%82%B9%E5%92%8C%E5%BA%A6.png" alt="结点和度"></p>
<h4 id="结点间关系"><a href="#结点间关系" class="headerlink" title="结点间关系"></a>结点间关系</h4><p><strong>结点的子树的根称为该结点的孩子 (Child)，相应地，该结点称为孩子的双亲 (Parent)。同一个双亲的孩子之间互称兄弟 (Sibling)。结点的祖先是从根到该结点所经分枝上的所有结点。以某结点为根的子树中的任一结点都称为该结点的子孙</strong>。</p>
<h4 id="树的其它相关概念"><a href="#树的其它相关概念" class="headerlink" title="树的其它相关概念"></a>树的其它相关概念</h4><p><strong>结点的层次 (Level) 从根开始定义起，根为第一层，跟的孩子为第二层。双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度 (Depth) 或高度。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1.png" alt="树的层次"></p>
<p><strong>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树</strong>。</p>
<p><strong>森林 (Forest) 是 m (m ≥ 0) 棵互不相交的树的集合</strong>。对树中每个结点而言，其子树的集合即为森林。</p>
<h3 id="树的抽象数据类型"><a href="#树的抽象数据类型" class="headerlink" title="树的抽象数据类型"></a>树的抽象数据类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ADT 树 (tree)</span><br><span class="line">Data</span><br><span class="line">  树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系。</span><br><span class="line">Operation</span><br><span class="line">  <span class="title function_">InitTree</span><span class="params">(*T)</span>: 构造空树 T。</span><br><span class="line">  <span class="title function_">DestroyTree</span><span class="params">(*T)</span>: 销毁树 T。</span><br><span class="line">  <span class="title function_">CreateTree</span><span class="params">(*T, definition)</span>: 按 definition 中给出树的定义来构造树。</span><br><span class="line">  <span class="title function_">ClearTress</span><span class="params">(*T)</span>: 若树 T 存在，则将树 T 清为空树。</span><br><span class="line">  <span class="title function_">TreeEmpty</span><span class="params">(T)</span>: 若 T 为空树，返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line">  <span class="title function_">TreeDepth</span><span class="params">(T)</span>: 返回 T 的深度。</span><br><span class="line">  <span class="title function_">Root</span><span class="params">(T)</span>: 返回 T 的根结点。</span><br><span class="line">  <span class="title function_">Value</span><span class="params">(T, cur_e)</span>: cur_e 是树 T 中一个结点，返回此结点的值。</span><br><span class="line">  <span class="title function_">Assign</span><span class="params">(T, cur_e, value)</span>: 给树 T 的结点 cur_e 赋值为 value。</span><br><span class="line">  <span class="title function_">Parent</span><span class="params">(T, cur_e)</span>: 若 cur_e 是树 T 的非根结点，则返回它的双亲，否则返回空。</span><br><span class="line">  <span class="title function_">LeftChild</span><span class="params">(T, cur_e)</span>: 若 cur_e 是树 T 的非叶结点，则返回它的最左孩子，否则返回空。</span><br><span class="line">  <span class="title function_">RightSibling</span><span class="params">(T, cur_e)</span>: 若 cur_e 有右兄弟，则返回它的右兄弟，否则返回空。</span><br><span class="line">  <span class="title function_">InsertChild</span><span class="params">(*T, *p, i, c)</span>: 其中 p 指向树 T 的某个结点，i 为所指结点 p 的度加上 1，非空树 c 与 T 不相交，操作结果为插入 c 为树 T 中 p 指结点的第 i 棵子树。</span><br><span class="line">  <span class="title function_">DeleteChild</span><span class="params">(*T, *p, i)</span>: 其中 p 指向树 T 的某个结点，i 为所指结点 p 的度，操作结果为删除 T 中 p 所指结点的第 i 棵子树。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>

<h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p>树这种结构，除了根结点外，其余每个结点，他不一定有孩子，但是一定有且仅有一个双亲。假设以一组连续空间存储树的结点，同时<strong>在每个结点中，附设一个指示器指示其双亲结点到链表中的位置</strong>。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。结点结构如下表所示。</p>
<table>
<thead>
<tr>
<th align="center">data</th>
<th align="center">parent</th>
</tr>
</thead>
</table>
<p>其中 data 是数据域，存储结点的数据信息。而 parent 是指针域，存储该结点的双亲在数组中的下标。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树的双亲表示法结点结构定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> TElemType;			<span class="comment">// 树结点的数据类型，目前暂定为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span> &#123;</span>			<span class="comment">// 结点结构</span></span><br><span class="line">  TElemType data;				<span class="comment">// 结点数据</span></span><br><span class="line">  <span class="type">int</span> parent;					<span class="comment">// 双亲位置</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>				<span class="comment">// 树结构</span></span><br><span class="line">  PTNode nodes[MAX_TREE_SIZE];	<span class="comment">// 结点数组</span></span><br><span class="line">  <span class="type">int</span> r, n;						<span class="comment">// 根的位置和结点数</span></span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure>

<p>由于根结点是没有双亲的，所以我们约定根结点的位置域设置为 -1，所有的结点都存有它双亲的位置。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89.png" alt="树的定义"></p>
<table>
<thead>
<tr>
<th align="center">下标</th>
<th align="center">data</th>
<th align="center">parent</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">A</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">B</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">C</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">D</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">E</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">F</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">G</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">H</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">I</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">J</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p>这样的存储结构，可以根据结点的 parent 指针很容易找到它的双亲结点，所用的时间复杂度为 O(1)，直到 parent 为 -1 时，表示找到了树结点的根。可是如果要知道结点的孩子是谁，就需要遍历整个结构才行。可以增加一个结点最左边孩子的域，这里叫作长子域，这样就很容易得到结点的孩子。如果没有孩子的结点，这个长子域就设置为 -1。</p>
<table>
<thead>
<tr>
<th align="center">下标</th>
<th align="center">data</th>
<th align="center">parent</th>
<th align="center">firstchild</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">A</td>
<td align="center">-1</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">B</td>
<td align="center">0</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">C</td>
<td align="center">0</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">D</td>
<td align="center">1</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">E</td>
<td align="center">2</td>
<td align="center">9</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">F</td>
<td align="center">2</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">G</td>
<td align="center">3</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">H</td>
<td align="center">3</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">I</td>
<td align="center">3</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">J</td>
<td align="center">4</td>
<td align="center">-1</td>
</tr>
</tbody></table>
<p>对于有 0 个或 1 个孩子结点来说，这样的结构是解决了要找结点孩子的问题了。甚至是有 2 个孩子，知道了长子是谁，另一个当然就是次子了。</p>
<p>另外一个问题场景，我们很关注各兄弟之间的关系，双亲表示法无法体现这样的关系，可以增加一个右兄弟域来体现兄弟关系，每一个结点如果它存在右兄弟，则记录下右兄弟的下标。如果右兄弟不存在，则复制为 -1。</p>
<table>
<thead>
<tr>
<th align="center">下标</th>
<th align="center">data</th>
<th align="center">parent</th>
<th align="center">rightsib</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">A</td>
<td align="center">-1</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">B</td>
<td align="center">0</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">C</td>
<td align="center">0</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">D</td>
<td align="center">1</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">E</td>
<td align="center">2</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">F</td>
<td align="center">2</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">G</td>
<td align="center">3</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">H</td>
<td align="center">3</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">I</td>
<td align="center">3</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">J</td>
<td align="center">4</td>
<td align="center">-1</td>
</tr>
</tbody></table>
<p>但如果结点的孩子很多，超过了 2 个。我们又关注结点的双亲、又关注结点的孩子、还关注结点的兄弟，而且对时间遍历要求还比较高，那么我们还可以把此结构扩展为有双亲域、长子域、再有右兄弟域。<strong>存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于给予该存储结构的运算是否适合、是否方便，时间复杂度好不好等</strong>。</p>
<h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><p>由于树中每个结点可能有多棵子树，可以考虑用多重链表，即<strong>每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫作多重表表示法</strong>。树的每个结点的度，也就是它的孩子个数是不同的。所以可以设计两种方案来解决。</p>
<ul>
<li><p>方案一</p>
<p>  一种是指针域的个数就等于树的度，树的度是树各个结点度的最大值。</p>
<table>
<thead>
<tr>
<th align="center">data</th>
<th align="center">child1</th>
<th align="center">child2</th>
<th align="center">child3</th>
<th align="center">……</th>
<th align="center">childd</th>
</tr>
</thead>
</table>
<p>  其中 data 是数据域。child1 到 childd 是指针域，用来指向该结点的孩子结点。</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%951.png" alt="孩子表示法1"></p>
<p>  这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。但是如果树的各结点度相差很小时，那就意味着开辟的空间被充分利用了，这时存储结构的缺点反而变成了优点。</p>
</li>
<li><p>方案二</p>
<p>  第二种方案每个结点指针域的个数等于该结点的度，专门取一个位置来存储结点指针域的个数，其结构如表。</p>
<table>
<thead>
<tr>
<th align="center">data</th>
<th align="center">degree</th>
<th align="center">child1</th>
<th align="center">child2</th>
<th align="center">……</th>
<th align="center">childd</th>
</tr>
</thead>
</table>
<p>  其中 data 为数据域，degree 为度域，也就是存储该结点的孩子结点的个数，child1 到 childd 为指针域，指向该结点的各个孩子的结点。</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%952.png" alt="孩子表示法2"></p>
<p>  这种方法克服了浪费空间的缺点，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上会带来时间上的损耗。</p>
<p>  为了要遍历整棵树，把每个结点放到一个顺序存储结构的数组中是合理的，但每个结点的孩子有多少是不确定的，所以我们再对每个结点的孩子建立一个单链表体现它们的关系。</p>
<p>  <strong>孩子表示法把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</strong>。</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%953.png" alt="孩子表示法3"></p>
<p>  孩子链表的孩子结点：</p>
<table>
<thead>
<tr>
<th align="center">child</th>
<th align="center">next</th>
</tr>
</thead>
</table>
<p>  其中 child 是数据域，用来存储某个结点在表头数组中的下标。next 是指针域，用来存储指向某结点的下一个孩子结点的指针。</p>
<p>  表头数组的表头结点：</p>
<table>
<thead>
<tr>
<th align="center">data</th>
<th align="center">firstchild</th>
</tr>
</thead>
</table>
<p>  其中 child 是数据域，存储某结点的数据信息。firstchild 是头指针域，存储该结点的孩子链表的头指针。</p>
<p>  孩子表示法的结构定义：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树的孩子表示法结构定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> &#123;</span>				<span class="comment">// 孩子结点</span></span><br><span class="line">  <span class="type">int</span> child;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>					<span class="comment">// 表头结构</span></span><br><span class="line">  TElemType data;</span><br><span class="line">  ChildPtr firstchild;</span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>					<span class="comment">// 树结构</span></span><br><span class="line">  CTBox nodes[MAX_TREE_SIZE];		<span class="comment">// 结点数组</span></span><br><span class="line">  <span class="type">int</span> r, n;							<span class="comment">// 根的位置和结点树</span></span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure>

<p>  这样的结构对于要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。</p>
<p>  但是也存在问题，如何知道某个结点的双亲是谁？将双亲表示法和孩子表示法综合一下。</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%954.png" alt="孩子表示法4"></p>
<p>  把这种算法称为双亲孩子表示法，是孩子表示法的改进。</p>
</li>
</ul>
<h4 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h4><p><strong>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</strong>。</p>
<table>
<thead>
<tr>
<th align="center">data</th>
<th align="center">firstchild</th>
<th align="center">rightsib</th>
</tr>
</thead>
</table>
<p>其中 data 是数据域，firstchild 为指针域，存储该结点的第一个孩子结点的存储地址，rightsib 是指针域，存储该结点的右兄弟结点的存储地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树的孩子兄弟表示法结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">  TElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">rightsib</span>;</span></span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure>

<p>示意图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%951.png" alt="孩子兄弟表示法1"></p>
<p>这种表示法，给查找某个结点的某个孩子带来了方便，只需要通过 firstchild 找到此结点的长子，然后再通过长子结点的 rightsib 找到它的二弟，接着一直下去，直到找到具体的孩子。当然想找某个结点的双亲，这个表示法也是有缺陷的。</p>
<p>其实这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%952.png" alt="孩子兄弟表示法2"></p>
<p>这样就可以充分利用二叉树的特性和算法来处理这棵树了。</p>
<h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><blockquote>
<p>二叉树 (Binary Tree) 是 n (n ≥ 0) 个结点的有限集合，该集合或者为空集 (称为空二叉树)，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树"></p>
<h4 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h4><p>特点：</p>
<ul>
<li>每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。</li>
<li>左子树和右子树是有顺序的，次序不能任意颠倒。</li>
<li>即是树中某结点只有一棵子树，也要区分它是左子树还是右子树。</li>
</ul>
<p>二叉树具有五种基本形态：</p>
<ol>
<li>空二叉树。</li>
<li>只有一个根结点。</li>
<li>根结点只有左子树。</li>
<li>根结点只有右子树。</li>
<li>根结点既有左子树又有右子树。</li>
</ol>
<h4 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h4><ul>
<li><p><strong>斜树</strong></p>
<p>  <strong>所有结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树</strong>。</p>
</li>
<li><p><strong>满二叉树</strong></p>
<p>  <strong>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树</strong>。</p>
<p>  满二叉树的特点有：</p>
<ul>
<li>叶子只能出现在最下一层。出现在其他层就不可能达成平衡。</li>
<li>非叶子结点的度一定是 2。</li>
<li>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</li>
</ul>
</li>
<li><p><strong>完全二叉树</strong></p>
<p>  <strong>对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i (1 ≤ i ≤ n) 的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树</strong>。</p>
<p>  完全二叉树的特点：</p>
<ul>
<li>叶子结点只能出现在最下两层。</li>
<li>最下层的叶子一定集中在左部连续位置。</li>
<li>倒数二层，若有叶子结点，一定都在右部连续位置。</li>
<li>如果结点度为 1，则该结点只有左孩子，既不存在只有右子树的情况。</li>
<li>同样结点树的二叉树，完全二叉树的深度最小。</li>
</ul>
</li>
</ul>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质 1"></a>性质 1</h4><p>**在二叉树的第 i 层上至多有 2<sup>i - 1</sup> 个结点 (i ≥ 1)**。</p>
<h4 id="性质-2"><a href="#性质-2" class="headerlink" title="性质 2"></a>性质 2</h4><p>**深度为 k 的二叉树至多有 2<sup>k</sup> - 1 个结点 (k ≥ 1)**。</p>
<h4 id="性质-3"><a href="#性质-3" class="headerlink" title="性质 3"></a>性质 3</h4><p><strong>对任何一棵二叉树 T，如果其终端结点数为 n<sub>0</sub>，度为 2 的结点树为 n<sub>2</sub>，则 n<sub>0</sub> &#x3D; n<sub>2</sub> + 1</strong>。</p>
<h4 id="性质-4"><a href="#性质-4" class="headerlink" title="性质 4"></a>性质 4</h4><p>**具有 n 个结点的完全二叉树的深度为 [log<sub>2</sub>n] + 1 ([x] 表示不大于 x 的最大整数)**。</p>
<h4 id="性质-5"><a href="#性质-5" class="headerlink" title="性质 5"></a>性质 5</h4><p><strong>如果对一棵有 n 个结点的完全二叉树 (其深度为 [log<sub>2</sub>n] + 1) 的结点按层序编号 (从第 1 层到第 [log<sub>2</sub>n] + 1 层，每层从左到右)，对任一结点 i (1 ≤ i ≤ n) 有：</strong></p>
<ol>
<li><strong>如果 i &#x3D; 1，则结点 i 是二叉树的根，无双亲；如果 i &gt; 1，则其双亲是结点 [i &#x2F; 2]。</strong></li>
<li><strong>如果 2i &gt; n，则结点 i 无左孩子 (结点 i 为叶子结点)；否则其左孩子是结点 2i。</strong></li>
<li><strong>如果 2i + 1 &gt; n，则结点 i 无右孩子；否则其右孩子是结点 2i + 1。</strong></li>
</ol>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="二叉树顺序存储结构"><a href="#二叉树顺序存储结构" class="headerlink" title="二叉树顺序存储结构"></a>二叉树顺序存储结构</h4><p>二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A81.png" alt="完全二叉树顺序存储1"></p>
<p>将这棵二叉树存入到数组中，相应的下标对应其同样的位置。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A82.png" alt="完全二叉树顺序存储2"></p>
<p>由于完全二叉树严格的定义，所以用顺序结构也可以表现出二叉树的结构。对于一般的二叉树，尽管层序编号不能反映逻辑关系，但是可以将其按完全二叉树编号，只不过，把不存在的结点设置为 “^” 而已。浅色结点表示不存在。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A83.png" alt="完全二叉树顺序存储3"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A84.png" alt="完全二叉树顺序存储4"></p>
<p>考虑一种极端的情况，一棵深度为 k 的右斜树，它只有 k 个结点，却需要分配 2<sup>k</sup> - 1 个存储单元空间，这显然是对存储空间的浪费。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A85.png" alt="完全二叉树顺序存储5"></p>
<p>所以顺序存储结构一般只用于完全二叉树。</p>
<h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p><strong>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域</strong>是比较自然的想法，<strong>称这样的链表叫作二叉链表</strong>。结点结构如图。</p>
<table>
<thead>
<tr>
<th align="center">lchild</th>
<th align="center">data</th>
<th align="center">child</th>
</tr>
</thead>
</table>
<p>其中 data 是数据域，lchild 和 rchild 都是指针域，分别存放指向左孩子和右孩子的指针。</p>
<p>二叉链表的结点结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的二叉链表结点结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span>				<span class="comment">// 结点结构</span></span><br><span class="line">  TElemType data;						<span class="comment">// 结点数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>		<span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125; BiTnode, *BiTree;</span><br></pre></td></tr></table></figure>

<p>结构示意图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8.png" alt="二叉链表"></p>
<h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><blockquote>
<p>二叉树的遍历 (traversing binary tree) 是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p>
</blockquote>
<h4 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a>二叉树遍历方法</h4><ol>
<li><p><strong>前序遍历</strong></p>
<p> <strong>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="前序遍历"></p>
</li>
<li><p><strong>中序遍历</strong></p>
<p> <strong>规则是若树为空，则空操作返回，否则从根结点开始 (注意并不是先访问根结点)，中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树</strong>。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="中序遍历"></p>
</li>
<li><p><strong>后序遍历</strong></p>
<p> <strong>规则是若树为空，则空操作返回，否则从左到右线叶子后结点的方式遍历访问左右子树，最后是访问根结点</strong>。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="后序遍历"></p>
</li>
<li><p><strong>层序遍历</strong></p>
<p> <strong>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问</strong>。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="层序遍历"></p>
</li>
</ol>
<h4 id="前序遍历算法"><a href="#前序遍历算法" class="headerlink" title="前序遍历算法"></a>前序遍历算法</h4><p>二叉树的定义是用递归的方式，所以，实现遍历算法也可以采用递归，而且极其简洁明了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的前序遍历递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraverse</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T -&gt; data);				<span class="comment">// 显示结点数据，可以更改为其它对结点操作</span></span><br><span class="line">  PreOrderTraverse(T -&gt; lchild);		<span class="comment">// 在先序遍历左子树</span></span><br><span class="line">  PreOrderTraverse(T -&gt; rchild);		<span class="comment">// 最后先序遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历算法"><a href="#中序遍历算法" class="headerlink" title="中序遍历算法"></a>中序遍历算法</h4><p>中序遍历算法和前序遍历算法仅仅只是在代码的顺序上的差异。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的中序遍历递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  InOrderTraverse(T -&gt; lchild);		<span class="comment">// 中序遍历左子树</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T -&gt; data);			<span class="comment">// 显示结点数据，可以更改为其它对结点操作</span></span><br><span class="line">  InOrderTraverse(T -&gt; rchild);		<span class="comment">// 最后中序遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后序遍历算法"><a href="#后序遍历算法" class="headerlink" title="后序遍历算法"></a>后序遍历算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的后序遍历递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderTraverse</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  PostOrderTraverse(T -&gt; lchild);		<span class="comment">// 先后序遍历左子树</span></span><br><span class="line">  PostOrderTraverse(T -&gt; rchild);		<span class="comment">// 再后序遍历右子树</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T -&gt; data);				<span class="comment">// 显示结点数据，可以更改为其它对结点操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="推导遍历结果"><a href="#推导遍历结果" class="headerlink" title="推导遍历结果"></a>推导遍历结果</h4><p>二叉树遍历的两个性质：</p>
<ul>
<li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li>
<li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li>
</ul>
<p><strong>已知前序和后序遍历，是不能确定一棵二叉树的</strong>。因为无法确定子结点是左还是右。</p>
<h3 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h3><p>要在内存中建议一个树，为了能让每个结点确认是否有左右孩子，将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值，比如 ‘#’。称这种处理后的二叉树为原二叉树的扩展二叉树。扩展二叉树就可以做到一个遍历序列确定一棵二叉树了。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按前序输入二叉树中结点的值 (一个字符)</span></span><br><span class="line"><span class="comment">// &#x27;#&#x27; 表示空树，构造二叉链表表示二叉树 T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree *T)</span> &#123;</span><br><span class="line">  TElemType ch;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">  <span class="keyword">if</span>(ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    *T = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    *T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">if</span>(!*T)</span><br><span class="line">      <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    (*T) -&gt; data = ch;					<span class="comment">// 生成根结点</span></span><br><span class="line">    CreateBiTree(&amp;(*T) -&gt; lchild);		<span class="comment">// 构造左子树</span></span><br><span class="line">    CreateBiTree(&amp;(*T) -&gt; rchild);		<span class="comment">// 构造右子树</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立二叉树也是利用了递归的原理。只不过在原来应该是打印结点的地方，改成了生成结点、给结点赋值的操作而已。</p>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h4 id="线索二叉树原理"><a href="#线索二叉树原理" class="headerlink" title="线索二叉树原理"></a>线索二叉树原理</h4><p><strong>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树 (Threaded Binary Tree)。对二叉树以某种次序遍历使其变为线索二叉树的过程称作是线索化</strong>。</p>
<p>结点结构：</p>
<table>
<thead>
<tr>
<th align="center">lchild</th>
<th align="center">ltag</th>
<th align="center">data</th>
<th align="center">rtag</th>
<th align="center">rchild</th>
</tr>
</thead>
</table>
<ul>
<li>ltag 为 0 时指向该结点的左孩子，为 1 时 指向该结点的前驱。</li>
<li>rtag 为 0 时指向该结点的右孩子，为 1 时 指向该结点的后继。</li>
</ul>
<h4 id="线索二叉树结构实现"><a href="#线索二叉树结构实现" class="headerlink" title="线索二叉树结构实现"></a>线索二叉树结构实现</h4><p>二叉树的线索存储结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的二叉线索存储结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>Link, Thread&#125; PointerTag;		<span class="comment">// Link == 0 表示指向左右孩子指针，Threed == 1 表示指向前驱或后继的线索</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode</span> &#123;</span>					<span class="comment">// 二叉线索存储结点结构</span></span><br><span class="line">  TElemType data;							<span class="comment">// 结点数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>		<span class="comment">// 左右孩子指针</span></span><br><span class="line">  PointerTag LTag;</span><br><span class="line">  PointerTag RTag;							<span class="comment">// 左右标志</span></span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure>

<p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以<strong>线索化的过程就是在遍历的过程中修改空指针的过程</strong>。</p>
<p>中序遍历线索化的递归函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BiThrTree pre;						<span class="comment">// 全局变量，始终指向刚刚访问过的结点</span></span><br><span class="line"><span class="comment">// 中序遍历进行中序线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThreading</span><span class="params">(BiThrTree p)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(p) &#123;</span><br><span class="line">    InThreading(p -&gt; lchild);		<span class="comment">// 递归左子树线索化</span></span><br><span class="line">    <span class="keyword">if</span>(!p -&gt; lchild) &#123;</span><br><span class="line">      p -&gt; LTag = Thread;			<span class="comment">// 前驱线索</span></span><br><span class="line">      p -&gt; lchild = pre;		  	<span class="comment">// 左孩子指针指向前驱</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!pre -&gt; rchild) &#123;</span><br><span class="line">      pre -&gt; RTag = Thread;			<span class="comment">// 后继线索</span></span><br><span class="line">      pre -&gt; rchild = p;			<span class="comment">// 前驱右孩子指针指向后继 (当前结点 p)</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre = p;						<span class="comment">// 保持 pre 指向 p 的前驱</span></span><br><span class="line">    InThreading(p -&gt; rchild); 	 	<span class="comment">// 递归右子树线索化</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 指向头结点，头结点左链 lchild 指向根结点，头结点右链 rchild 指向中序遍历的最后一个结点。中序遍历二叉线索链表表示的二叉树 T</span></span><br><span class="line">Status <span class="title function_">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span> &#123;</span><br><span class="line">  BiThrTree p;</span><br><span class="line">  p = T -&gt; lchild;					<span class="comment">// p 指向根结点</span></span><br><span class="line">  <span class="keyword">while</span>(p != T) &#123;					<span class="comment">// 空树或遍历结束时</span></span><br><span class="line">    <span class="keyword">while</span>(p -&gt; LTag == Link)		<span class="comment">// 当 LTag == 0 时循环到中序序列第一个结点</span></span><br><span class="line">      p = p -&gt; lchild;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p -&gt; data);		<span class="comment">// 显示结点数据，可以更改为其它对结点操作</span></span><br><span class="line">    <span class="keyword">while</span>(p -&gt; RTag == Thread &amp;&amp; p -&gt; rchild != T) &#123;</span><br><span class="line">      p = p -&gt; rchild;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p -&gt; data);</span><br><span class="line">    &#125;</span><br><span class="line">    p = p -&gt; rchild;				<span class="comment">// p 进至其右子树根</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</p>
<h3 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h3><h4 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h4><p>将树转换为二叉树的步骤如下：</p>
<ol>
<li>加线。在所有兄弟结点之间加一条连线。</li>
<li>去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其它孩子结点之间的连线。</li>
<li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。</li>
</ol>
<h4 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h4><p>森林是由若干树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。</p>
<ol>
<li>把每个树转换为二叉树。</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。</li>
</ol>
<h4 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h4><p>二叉树转换为树是树转换为二叉树的逆过程，也就是反过来做而已。</p>
<ol>
<li>加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……，反正就是左孩子的 n 个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。、</li>
<li>去线。删除原二叉树中所有结点与其右孩子结点的连线。</li>
<li>层次调整。使之结构层次分明。</li>
</ol>
<h4 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h4><p>判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。</p>
<ol>
<li>从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。</li>
<li>再将每棵分离后的二叉树转换为树即可。</li>
</ol>
<h4 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h4><p>树的遍历分为两种方式</p>
<ol>
<li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。</li>
<li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。</li>
</ol>
<p>森林的遍历也分为两种方式：</p>
<ol>
<li><strong>前序遍历</strong>：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。</li>
<li><strong>后序遍历</strong>：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。</li>
</ol>
<h3 id="赫夫曼树及其应用"><a href="#赫夫曼树及其应用" class="headerlink" title="赫夫曼树及其应用"></a>赫夫曼树及其应用</h3><h4 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h4><p>例子：对于老师来讲，对试卷评分的时候，根据统一的标准换算得出五级分制的成绩。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &lt; <span class="number">60</span>)</span><br><span class="line">  b = <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a &lt; <span class="number">70</span>)</span><br><span class="line">  b = <span class="string">&quot;及格&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a &lt; <span class="number">80</span>)</span><br><span class="line">  b = <span class="string">&quot;中等&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a &lt; <span class="number">90</span>)</span><br><span class="line">  b = <span class="string">&quot;良好&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  b = <span class="string">&quot;优秀&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上面的程序，使得所有的成绩都需要先判断是否及格，再逐级而上得到结果。输入量很大的时候，其实算法是有效率问题的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%912.png" alt="赫夫曼树2"></p>
<p>如果在实际的学习生活中，学生的成绩在 5 个等级上的分布规律如表所示</p>
<table>
<thead>
<tr>
<th align="center">分数</th>
<th align="center">0 ~ 59</th>
<th align="center">60 ~ 69</th>
<th align="center">70 ~ 79</th>
<th align="center">80 ~ 89</th>
<th align="center">90 ~ 100</th>
</tr>
</thead>
<tbody><tr>
<td align="center">所占比例</td>
<td align="center">5%</td>
<td align="center">15%</td>
<td align="center">40%</td>
<td align="center">30%</td>
<td align="center">10%</td>
</tr>
</tbody></table>
<p>那么 70 分以上大约占总数 80% 的成绩都需要经过 3 次以上的判断才可以得到结果，这很不合理。中等成绩 (70 ~ 79 分之间) 比例最高，其次是良好成绩，不及格的所占比例最小。重新把这棵二叉树进行分配：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%913.png" alt="赫夫曼树3"></p>
<h4 id="赫夫曼树定义与原理"><a href="#赫夫曼树定义与原理" class="headerlink" title="赫夫曼树定义与原理"></a>赫夫曼树定义与原理</h4><p>把上面两棵二叉树简化成叶子结点带权的二叉树。其中 A 表示不及格、B 表示及格、C 表示中等、D 表示良好、E 表示优秀。每个叶子的分支线上的数字就是5级分制的成绩所占比例数。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%911.png" alt="赫夫曼树1"></p>
<p><strong>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度</strong>。上图二叉树 a 中，根结点到结点 D 的路径长度为 4，二叉树 b 中根结点到结点 D 的路径长度为 2。<strong>树的路径长度就是从树根到每一结点的路径长度之和</strong>。二叉树 a 的树路径长度就为 1 + 1 + 2 + 2 + 3 + 3 +4 + 4 &#x3D; 20。二叉树 b 的树路径长度就为 1 + 2 +3 + 3 + 2 + 1 + 2 + 2 &#x3D; 16。</p>
<p>如果考虑到带权的结点，结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。假设有 n 个权值 {W<sub>1</sub>, W<sub>2</sub>, ……, W<sub>n</sub>}，构造一棵有 n 个叶子结点的二叉树，每个叶子结点带权 W<sub>k</sub>，每个叶子的路径长度为 1k，通常记作，则其中<strong>带权路径长度 WPL 最小的二叉树称作赫夫曼树</strong>。</p>
<p>赫夫曼算法描述：</p>
<ol>
<li>根据给定的 n 个权值 {W<sub>1</sub>, W<sub>2</sub>, ……, W<sub>n</sub>} 构成 n 棵二叉树的集合 F &#x3D; {T<sub>1</sub>, T<sub>2</sub>, ……, T<sub>n</sub>}，其中每棵二叉树 T<sub>i</sub> 中只有一个带权为 W<sub>i</sub> 根结点，其左右子树均为空。</li>
<li>在 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</li>
<li>在 F 中删除这两棵树，同时将新得到的二叉树加入 F 中。</li>
<li>重复 2 和 3 步骤，知道 F 只含一棵树为止。这棵树便是赫夫曼树。</li>
</ol>
<h4 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h4><p>赫夫曼树更大的目的是为了解决当年远距离通信 (主要是电报) 的数据传输的最优化问题。</p>
<p>比如有一段文字内容为 “BADCADFEED“ 要网络传输给别人，显然用二进制的数字 (0 和 1) 来表示是很自然的想法。这段文字只有六个字母 ABCDEF，可以用相应的二进制数据表示。</p>
<table>
<thead>
<tr>
<th align="center">字母</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">E</th>
<th align="center">F</th>
</tr>
</thead>
<tbody><tr>
<td align="center">二进制字符</td>
<td align="center">000</td>
<td align="center">001</td>
<td align="center">010</td>
<td align="center">011</td>
<td align="center">100</td>
<td align="center">101</td>
</tr>
</tbody></table>
<p>这样真正传输的数据就是编码后的 “001000011010000011101100100011”，对方接收时可以按照 3 位 一分来译码。如果一篇文章很长，这样的二进制串也将非常的可怕。而且事实上，不管是英文、中文或是其它语言，字母或汉字的出现频率是不相同的，比如英语中的几个元音字母 “a e i o u”，中文中的 “的 了 有 在” 等汉字都是频率极高。</p>
<p>假设六个字母的频率为 A 27，B 8，C 15，D 15，E 30，F 5，合起来正好是 100%。那就意味着，可以完全重新按照赫夫曼树来规划它们。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%914.png" alt="赫夫曼树4"></p>
<p>左图为构造赫夫曼树的过程的权值显示，右图为将权值左分支改为 0，右分支改为 1 后的赫夫曼树。</p>
<p>对这六个字母用其从树根到叶子所经过路径的 0 或 1 来编码，可以得到如表所示的定义。</p>
<table>
<thead>
<tr>
<th align="center">字母</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">E</th>
<th align="center">F</th>
</tr>
</thead>
<tbody><tr>
<td align="center">二进制字符</td>
<td align="center">01</td>
<td align="center">1001</td>
<td align="center">101</td>
<td align="center">00</td>
<td align="center">11</td>
<td align="center">1000</td>
</tr>
</tbody></table>
<p>将文字内容为 “BADCADFEED” 再次编码，对比可以发现结果串变小了。</p>
<ul>
<li>原编码二进制串：001000011010000011101100100011 ( 共 30 个字符 )</li>
<li>新编码二进制串：1001010010101001000111100 ( 共 25 个字符 )</li>
</ul>
<p>也就是说，数据被压缩了，节约了大约 17% 的存储或传输成本。随着字符的增多和多字符权重的不同，这种压缩会更加显出其优势。</p>
<p>当接收到 1001010010101001000111100 这样压缩过的新编码时，应该怎么解码？</p>
<p>编码中非 0 即 1，长短不等的话其实是很容易混淆的，所以<strong>若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称作前缀编码</strong>。</p>
<p>在解码时，要用到赫夫曼树，己发送发和接收方必须要约定好同样的复合曼编码规则。</p>
<p>当接收到 1001010010101001000111100 时，由约定好的赫夫曼树可知，1001 得到第一个字母是 B，接下来 01 意味着第二个字符是 A。其余的也相应的可以得到，从而成功解码。</p>
<p><strong>一般地，设需要编码的字符集为 { d<sub>1</sub>, d<sub>2</sub>, …… , d<sub>n</sub> }，各个字符在电文中出现的次数或频率集合为  { w<sub>1</sub>, w<sub>2</sub>, …… , w<sub>n</sub> }，以 d<sub>1</sub>, d<sub>2</sub>, …… , d<sub>n</sub> 作为叶子结点，以 w<sub>1</sub>, w<sub>2</sub>, …… , w<sub>n</sub> 作为相应叶子结点的权值来构造一颗赫夫曼树。规定赫夫曼树的左右分支代表 0，右分支代表 1，则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码</strong>。</p>
<h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>树的相关概念：子树、结点、度、叶子、分支结点、双亲、孩子、层次、深度、森林。</p>
<p>树的存储结构：双亲表示法、孩子表示法、孩子兄弟表示法。</p>
<p>二叉树每个结点最多两棵子树，有左右之分，提到了斜树、满二叉树、完全二叉树等。</p>
<p>二叉树的存储结构由于其特殊性是的既可以用顺序存储结构又可以用链式存储结构表示。</p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p>在线性表中， 数据元素之间是被串起来的，仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继。在树形结构中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关。折合一对父母可以有多个孩子，但每个孩子却只能有一对父母是一个道理。在图形结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。</p>
<blockquote>
<p>图 (Graph) 是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为: G (V, E)，其中 G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。</p>
</blockquote>
<p>对于图的定义，需要明确几个注意的地方：</p>
<ul>
<li>线性表中我们把数据元素叫元素，树中将数据元素叫结点，**在图中数据元素，称之为顶点 (Vertex)**。</li>
<li>线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。在图结构中，不允许没有丁点。在定义中，若 V 是顶点的集合，则强调了顶点集合 V 有穷非空。</li>
<li>线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而<strong>图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示</strong>，边集可以是空的。</li>
</ul>
<h4 id="各种图定义"><a href="#各种图定义" class="headerlink" title="各种图定义"></a>各种图定义</h4><p><strong>无向边：若顶点 v<sub>i</sub> 到 v<sub>j</sub> 之间的边没有方向，则称这条边为无向边 (Edge)，用无序偶对 (v<sub>i</sub>, v<sub>j</sub>)来表示</strong>。如果图中任意两个顶点之间的边都是无向边，则称该图为**无向图 (Undirected graphs)**。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%97%A0%E5%90%91%E8%BE%B9.png" alt="无向边"></p>
<p>由于是无向的，连接顶点 A 与 D 的边，可以表示成无序对 (A, D)，也可以写成 (D, A)。对于图中无向图 G<sub>1</sub> 来说，G<sub>1</sub>  &#x3D; (V<sub>1</sub>, {E<sub>1</sub>})，其中顶点集合 V<sub>1</sub> &#x3D; {A, B, C, D}；边集合 E<sub>1</sub> &#x3D; {(A, B), {B, C}, (C, D), (D, A), (A, C)}。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%9C%89%E5%90%91%E8%BE%B9.png" alt="有向边"></p>
<p>**有向边：若从顶点 V<sub>i</sub> 到V<sub>j</sub> 的边有方向，则称这条边为有向边，也称为弧 (Arc)<strong>。用有序偶 &lt;V<sub>i</sub>, V<sub>j</sub>&gt; 来表示，V<sub>i</sub> 称为弧尾 (Tail)，V<sub>j</sub> 称为弧头 (Head)。如果图中任意两个顶点之间的边都是有向边，则称该图为</strong>有向图 (Directed graphs)<strong>。上图是一个有向图，</strong>连接顶点 A 到 D 的有向边就是弧，A 是弧尾，D 是弧头，&lt;A, D&gt; 表示弧，注意不能写成&lt;D, A&gt;**。对于图中的有向图 G<sub>2</sub> 来说，G<sub>2</sub> &#x3D; (V<sub>2</sub>, {E<sub>2</sub>})，其中顶点集合 V<sub>2</sub> &#x3D; {A, B, C, D}；弧集合 E<sub>2</sub> &#x3D; {&lt;A, D&gt;, &lt;B, A&gt;, &lt;C, A&gt;, &lt;B, C&gt;}。</p>
<p><strong>无向边有小括号 “( )” 表示，而有向边则是用尖括号 “&lt;&gt;”表示</strong>。</p>
<p><strong>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图</strong>。</p>
<p><strong>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图</strong>。含有 n 个顶点的无向完全图有 n*(n-1)&#x2F;2 条边。</p>
<p><strong>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图</strong>。含有 n 个顶点的有向完全图有 n*(n-1) 条边。<br>从这里也可以得到结论，对于具有 n 个顶点和 e 条边数的图，无向图 0 ≤ e ≤ n(n-1)&#x2F;2，有向图 0 ≤ e ≤ n(n-1)。</p>
<p><strong>又很少条边或弧的图称为稀疏图，反之称为稠密图</strong>。这里稀疏和稠密是模糊的概念，都是相对而言的。</p>
<p>有些图的边或弧具有与它相关的数字，这种**与图的边或弧相关的数叫做权 (weight)<strong>。这些权可以表示从一个顶点到另一个顶点的距离或耗费。</strong>这种带权的图通常称为网 (Network)**。</p>
<p>**假设有两个图 G &#x3D; (V, {E}) 和 G’ &#x3D; (V’, {E’})，如果 V’⊆ V 且 E’ ⊆ E，则称 G’ 为 G 的子图 (Subgraph)**。</p>
<h4 id="图的顶点与边间关系"><a href="#图的顶点与边间关系" class="headerlink" title="图的顶点与边间关系"></a>图的顶点与边间关系</h4><p>**对于无向图 G &#x3D; (V, {E})，如果边 (v, v’) ∈ E，则称顶点 v 和 v’ 互为邻接点 (Adjacent)，即 v 和 v’ 相邻接。边 (v, v’) 依附 (incident) 与顶点 v 和 v’，或者说 (v, v’) 与顶点 v 和 v’ 相关联。顶点 v 的度 (Degree) 是和 v 相关联的边的数目，记为TD(v)**。</p>
<p>**对于有向图 G &#x3D; (V, {E})，如果弧 &lt;v, v’&gt; ∈ E，则称顶点 v 邻接到顶点 v’，顶点 v’ 邻接自顶点 v。弧 &lt;v, v’&gt; 和顶点 v，v’相关联。以顶点 v 为头的弧的数目称为 v 的入度 (InDegree)，记为 ID(v)；以 v 为尾的弧的数目称为 v 的出度 (OutDegree)，记为OD(v)；顶点 v 的度为 TD(v) &#x3D; ID(v) + OD(v)**。</p>
<p><strong>无向图 G &#x3D; (V, {E}) 中从顶点 v 到顶点 v’ 的路径 (Path) 是一个顶点序列 (v&#x3D;v<sub>i,0</sub>, v<sub>i,1</sub>, ···, v<sub>i,m</sub>)，其中 (v<sub>i,j-1</sub>) ∈ E，1 ≤ j ≤ m</strong>。</p>
<p><strong>路径的长度是路径上的边或弧的数目。第一个顶点到最后一个顶点相同的路径称为回路或环 (Cycle)。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环</strong>。</p>
<h4 id="连通图相关术语"><a href="#连通图相关术语" class="headerlink" title="连通图相关术语"></a>连通图相关术语</h4><p>**图中任意两个顶点 v<sub>i</sub>、v<sub>j</sub> ∈ E，v<sub>i</sub> 和 v<sub>j</sub> 都是连通的，则称 G 是连通图 (Connected Graph)**。</p>
<p><strong>无向图中的极大连通子图称为连通分量</strong>。注意连通分量的概念，它强调：</p>
<ul>
<li>要是子图；</li>
<li>子图要是连通的；</li>
<li>连通子图含有极大顶点数；</li>
<li>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</li>
</ul>
<p><strong>在有向图 G 中，如果对于每一对 v<sub>i</sub>、v<sub>j</sub> ∈ V、v<sub>i</sub> ≠ v<sub>j</sub>，从 v<sub>i</sub> 到 v<sub>j</sub> 和从v<sub>j</sub> 到 v<sub>i</sub> 都存在路径，则称 G 是强连通图。有向图中的极大强连通子图称做有向图的强连通分量</strong>。</p>
<p>所谓的<strong>一个连通图的生成树是一个极小的连通子图，它含有图中全部的 n 个顶点，但只有足以构成一棵树的 n-1 条边。如果一个有向图恰有一个顶点的入度为 0，其余顶点的入度均为 1，则是一颗有向树</strong>。对有向树的理解比较容易，所谓入度为 0 其实就是相当于树中的根结点，其余顶点入度为 1 就是说树的非根结点的双亲只有一个。<strong>一个有向图的生成森林由若干棵有向数组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧</strong>。</p>
<h4 id="图的定义与术语总结"><a href="#图的定义与术语总结" class="headerlink" title="图的定义与术语总结"></a>图的定义与术语总结</h4><p><strong>图</strong>按照有无方向分为<strong>无向图</strong>和<strong>有向图</strong>。无向图由<strong>顶点</strong>和<strong>边</strong>构成，有向图由<strong>顶点</strong>和<strong>弧</strong>构成。弧有<strong>弧尾</strong>和<strong>弧头</strong>之分。</p>
<p>图按照边或弧的多少分<strong>稀疏图</strong>和<strong>稠密图</strong>。如果任意两个顶点之间都存在边叫<strong>完全图</strong>，有向的叫<strong>有向完全图</strong>。若无重复的边或顶点到自身的边则叫<strong>简单图</strong>。</p>
<p>图中顶点之间有<strong>邻接点</strong>、<strong>依附</strong>的概念。无向图顶点的边数叫做<strong>度</strong>，有向图顶点分为<strong>入度</strong>和<strong>出度</strong>。</p>
<p>图上的边或弧上带权则称为<strong>网</strong>。</p>
<p>图中顶点间存在<strong>路径</strong>，两顶点存在路径则说明是<strong>连通</strong>的，如果路径最终回到起始点则称为<strong>环</strong>，当中不重复叫<strong>简单路径</strong>。若任意两顶点都是连通的，则图就是<strong>连通图</strong>，有向则称<strong>强连通图</strong>。图中有子图，若子图极大连通则就是<strong>连通分量</strong>，有向的则称<strong>强连通分量</strong>。</p>
<p>无向图中连通且 n 个顶点 n - 1 条边叫<strong>生成树</strong>。有向图中一顶点入度为 0 其余顶点入度为 1 的叫<strong>有向树</strong>。一个有向图由若干棵有向树构成生成<strong>森林</strong>。</p>
<h3 id="图的抽象数据类型"><a href="#图的抽象数据类型" class="headerlink" title="图的抽象数据类型"></a>图的抽象数据类型</h3><p>图作为一种数据结构，它的抽象数据类型带有自己特点，正因为它的复杂，运用广泛，使得不同的应用需要不同的运算集合，构成不同的抽象数据操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ADT 图 (Graph)</span><br><span class="line">Data</span><br><span class="line">  顶点的有穷非空集合和边的集合</span><br><span class="line">Operation</span><br><span class="line">  <span class="title function_">CreateGraph</span><span class="params">(*G, V, VR)</span>: 按照顶点集合 V 和边弧集 VR 的定义构造图 G。</span><br><span class="line">  <span class="title function_">DestroyGraph</span><span class="params">(*G)</span>: 图 G 存在则销毁。</span><br><span class="line">  <span class="title function_">LocateVex</span><span class="params">(G, u)</span>: 若图 G 中存在顶点 u，则返回图中的位置。</span><br><span class="line">  <span class="title function_">GetVex</span><span class="params">(G, v)</span>: 返回图 G 中顶点 v 的值。</span><br><span class="line">  <span class="title function_">PutVex</span><span class="params">(G, v, value)</span>: 将图 G 中顶点 v 赋值 value。</span><br><span class="line">  <span class="title function_">FirstAdjVex</span><span class="params">(G, *v)</span>: 返回顶点 v 的一个邻接点，若顶点在 G 中无邻接顶点返回空。</span><br><span class="line">  <span class="title function_">NextAdVex</span><span class="params">(G, v, *w)</span>: 返回顶点 v 相对于顶点 w 的下一个邻接顶点，若 w 是 v 的最后一个邻接点则返回“空”。</span><br><span class="line">  <span class="title function_">InsertVex</span><span class="params">(*G, v)</span>: 在图 G 中增添新顶点 v。</span><br><span class="line">  <span class="title function_">DeleteVex</span><span class="params">(*G, v)</span>: 删除图 G 中顶点 v 及其相关的弧。</span><br><span class="line">  <span class="title function_">InsertArc</span><span class="params">(*G, v, w)</span>: 在图 G 中增添弧 &lt;v, w&gt;，若 G 是无向图，还需要增添对称弧 &lt;w, v&gt;。</span><br><span class="line">  <span class="title function_">DeleteArc</span><span class="params">(*G, v, w)</span>: 在图 G 中删除弧 &lt;v, w&gt;，若 G 是无向图，则还删除对称弧 &lt;w, v&gt;。</span><br><span class="line">  <span class="title function_">DFSTraverse</span><span class="params">(G)</span>: 对图 G 中进行深度优先遍历，在遍历过程对每个顶点调用。</span><br><span class="line">  <span class="title function_">HFSTraverse</span><span class="params">(G)</span>: 对图 G 中进行广度优先遍历，在遍历过程对每个顶点调用。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>

<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><p>图的存储结构相较线性表与树来说就复杂了，平时所说的“顶点的位置”或“邻接点的位置”只是一个相对的概念。其实从图的逻辑结构定义来看，图上任何一个顶点都可被看成是第一个顶点，任一顶点的临界点之间也不存在次序关系。正由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在内存中的物理位置来表示元素之间的关系，也就是说，图不可能用简单的顺序存储结构来表示。而多重链表的方式，即以一个数据域和多个指针域组成的结点表示图中的一个顶点，尽管可以实现图结构。如果各顶点的度数相差很大，按度数最大的顶点设计结点结构会造成很多存储单元的浪费，而若按每个顶点自己的度数设计不同的顶点结构，又带来操作的不变。</p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>考虑到图是顶点和边或弧两部分组成。合在一起比较困难，那就很自然地考虑到分两个结构来分别存储。顶点不分大小、主次，所以用一个一维数组来存储是很不错的选择。而边或弧由于是顶点与顶点之间的关系，一维搞不定，那就考虑用一个二维数组来存储。</p>
<p><strong>图的邻接矩阵 (Adjacency Matrix) 存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组 (称为邻接矩阵) 存储图中的边或弧的信息</strong>。</p>
<p>设图 G 有 n 个顶点，则邻接矩阵是一个 n*n 的方阵，定义为：</p>
<p>Arc[i][j] &#x3D; 1, 若 (v<sub>i</sub>, v<sub>j</sub>) ∈ E 或 &lt; v<sub>i</sub>, v<sub>j</sub> &gt;∈ E</p>
<p>Arc[i][j] &#x3D; 0，反之</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%97%A0%E5%90%91%E5%9B%BE.png" alt="无向图"></p>
<p>可以设置两个数组，顶点数组为 vertex[4] &#x3D; {v<sub>0</sub>, v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>}，边数组 arc[4][4] 为上面右图中的一个矩阵。对于矩阵的主对角线的值，即 arc[0][0] 、arc[1][1]、arc[2][2]、arc[3][3]，全为 0 是因为不存在顶点到自身的边，比如 v<sub>0</sub> 到 v<sub>0</sub>。arc[0][1] &#x3D; 1 是因为 v<sub>0</sub> 到 v<sub>1</sub> 的边存在，而 arc[1][3] &#x3D; 0 是因为 v<sub>1</sub> 到 v<sub>3</sub> 的边不存在。并且由于是无向图， v<sub>1</sub> 到 v<sub>3</sub> 的边不存在，意味着 v<sub>3</sub> 到 v<sub>1</sub> 的边也不存在。所以无向图的边数组是一个对称矩阵。</p>
<p>要知道某个顶点的度，其实就是这个顶点 v<sub>i</sub> 在邻接矩阵中第 i 行 (或第 i 列) 的元素之和。求顶点 v<sub>i</sub> 的所有邻接点就是将矩阵中第 i 行元素扫描一遍，arc[i][j] 为 1 就是邻接点。</p>
<p>邻接矩阵的创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;			<span class="comment">// 顶点类型应由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;				<span class="comment">// 边上的权值类型应由用户定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVEX 100					<span class="comment">// 最大顶点数，应由用户定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 65535				<span class="comment">// 用 65535 来代表 ∞</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  VertexType vexs[MAXVEX];			<span class="comment">// 顶点表</span></span><br><span class="line">  EdgeType arc[MAXVEX][MAXVEX];		<span class="comment">// 邻接矩阵，可看作边表</span></span><br><span class="line">  <span class="type">int</span> numVertexes, numEdges;		<span class="comment">// 图中当前的顶点数和边数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>

<p>无向网图的创建代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立无向网图的邻接矩阵表示</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateMGraph</span><span class="params">(MGraph *G)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j, k, w;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输入顶点数和边数:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d, %d&quot;</span>, &amp;G -&gt; numVertexes, &amp;G -&gt; numEdges);		<span class="comment">// 输入顶点数和边数</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G -&gt; numVertexes; i++)						<span class="comment">// 读入顶点信息，建立顶点表</span></span><br><span class="line">    <span class="built_in">scanf</span>(&amp;G -&gt; vexs[i]);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G -&gt; numVertexes; i++)</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G -&gt; numVertexes; j++)</span><br><span class="line">      G -&gt; arc[i][j] = INFINITY;							<span class="comment">// 邻接矩阵初始化</span></span><br><span class="line">  <span class="keyword">for</span>(k = <span class="number">0</span>; k -&gt; numEdges; k++) &#123;							<span class="comment">// 读入 numEdges条边，建立邻接矩阵</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入边 (vi, vj) 上的下标 i，下标 j 和权 w: \n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d, %d, %d&quot;</span>, &amp;i, &amp;j, &amp;w);						<span class="comment">// 输入边 (vi, vj) 上的权 w</span></span><br><span class="line">    G -&gt; arc[i][j] = w;</span><br><span class="line">    G -&gt; arc[i][j] = G -&gt; arc[i][j];						<span class="comment">// 因为是无向图，矩阵对称</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中也可以得到，n 个顶点和 e 条边的无向网图的创建，时间复杂度为 O(n + n<sup>2</sup> + e)，其中对邻接矩阵 Garc 的初始化耗费了 O(n<sup>2</sup>) 的时间。</p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>邻接矩阵是不错的一种图存储结构，对于边数相对顶点较少的图，这种结构是存在对存储空间的极大浪费的。</p>
<p>**数组与链表相结合的存储方法称为邻接表 (Adjacency List)**。</p>
<p>邻接表的处理办法：</p>
<ol>
<li>图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个令结点的指针，以便于查找该顶点的边信息。</li>
<li>图中每个顶点 v<sub>i</sub> 的所有令结点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点 v<sub>i</sub> 的边表，有向图则称为顶点 v<sub>i</sub> 作为弧尾的出边表。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="无向图的邻接表结构"></p>
<p>上图是一个无向图的邻接表结构。从图中知道，顶点表的各个结点由 data 和 firstedge 两个域表示，data 是数据域，存储顶点的信息，firstedge 是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。边表结点由 adjvex 和 next 两个域组成。adjvex 是临界点域，存储某顶点的临接点在顶点表中的下标，next 则存储指向边表中下一个结点的指针。比如 v<sub>1</sub> 顶点与 v<sub>0</sub>、v<sub>2</sub> 互为邻接点，则在 v<sub>1</sub> 的边表中，adjvex 分别为 v<sub>0</sub> 的 0 和 v<sub>2</sub> 的 2。</p>
<p>这样的结构，对于要获得图的相关信息也是很方便的。比如想要知道某个顶点的度，就去查找这个顶点的边表中结点的个数。若要判断顶点 v<sub>ℹ</sub> 到 v<sub>j</sub> 是否存在边，只需要测试顶点 v<sub>i</sub> 的边表中 adjvex 是否存在结点 v<sub>j</sub>的下标 j 就行了。若求顶点的所有邻接点，其实就是对此顶点的边表进行遍历，得到 adjvex 域对应的顶点就是邻接点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E9%80%86%E9%82%BB%E6%8E%A5%E8%A1%A8.png" alt="有向图的逆邻接表"></p>
<p>若是有向图，邻接表结构是类似的，比如上图中第一幅图的邻接表就是第二幅图。但要注意的是有向图由于有方向，是以顶点为弧尾来存储边表的，这样很容易就可以得到每个顶点的出度。但也有时为了便于确定顶点的入度或以顶点为弧头的弧，可以建立<strong>一个有向图的逆邻接表，即对每个顶点 v<sub>1</sub> 都建立一个链接为 v<sub>i</sub> 为弧头的表</strong>。如上图的第三幅图。</p>
<p>此时很容易就可以算出某个顶点的入度和出度是多少，判断两顶点是否存在弧也很容易实现。</p>
<p>对于带权值的网图，可以在边表结点定义中再增加一个 weight 的数据域，存储权值信息即可。</p>
<p>结点定义的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;			<span class="comment">// 顶点类型应由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;				<span class="comment">// 边上的权值类型应由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span>			<span class="comment">// 边表结点</span></span><br><span class="line">  <span class="type">int</span> adjvex;						<span class="comment">// 临界点域，存储该顶点对应的下标</span></span><br><span class="line">  EdgeType weight;					<span class="comment">// 用于存储权值，对于非网图可以不需要</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span>			<span class="comment">// 链域，指向下一个邻接点</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> &#123;</span>			<span class="comment">// 顶点表结点</span></span><br><span class="line">  VertexType data;					<span class="comment">// 顶点域，存储顶点信息</span></span><br><span class="line">  EdgeNode *firstedge;				<span class="comment">// 边表头指针</span></span><br><span class="line">&#125;VertexNode, AdjList[MAXVEX];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  AdjList adjList;</span><br><span class="line">  <span class="type">int</span> numVertexes, numEdges;		<span class="comment">// 图中当前顶点数和边数</span></span><br><span class="line">&#125;GraphAdjList;</span><br></pre></td></tr></table></figure>

<p>无向图的邻接表创建代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立图的邻接表结构</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateALGraph</span><span class="params">(GraphAdjList *G)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j, k;</span><br><span class="line">  EdgeNode *e;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输入顶点数和边数:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;G -&gt; numVertexes, &amp;G -&gt; numEdges);		<span class="comment">// 输入顶点数和边数</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G -&gt; numVertexes; i++) &#123;					<span class="comment">// 读入顶点信息，建立顶点表</span></span><br><span class="line">    <span class="built_in">scanf</span>(&amp;G -&gt; adjList[i].data);							<span class="comment">// 输入顶点信息</span></span><br><span class="line">    G -&gt; adjList[i].firstedge = <span class="literal">NULL</span>;						<span class="comment">// 将边表置为空表</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G -&gt; numEdges; k++) &#123;						<span class="comment">// 建立边表</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输入边（vi, vj) 上的顶点序号: \n&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d, %d&quot;</span>, &amp;i, &amp;j);									<span class="comment">// 输入边 (vi, vj) 上的顶点序号</span></span><br><span class="line">  e = (EdgeNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));				<span class="comment">// 向内存中申请空间，生成边表结点</span></span><br><span class="line">  e -&gt; adjvex = j;			<span class="comment">// 邻接序号为 j</span></span><br><span class="line">  e -&gt; next = G -&gt; adjList[i].firstedge = e;				<span class="comment">// 将 e 指针指向当前顶点指向的结点</span></span><br><span class="line">  G -&gt; adjList[i].firstedge = e;							<span class="comment">// 将当前顶点的指针指向 e</span></span><br><span class="line">  e = (EdgeNode *)nalloc(<span class="keyword">sizeof</span>(EdgeNode));					<span class="comment">// 向内存申请空间，生成边表结点</span></span><br><span class="line">  e -&gt; adjvex = i;			<span class="comment">// 邻接序号为 i</span></span><br><span class="line">  e -&gt; next = G -&gt; adjList[j].firstedge;					<span class="comment">// 将 e 指针指向当前顶点指向的结点</span></span><br><span class="line">  G -&gt; adjList[j].firstedge = e;							<span class="comment">// 将当前顶点的指针指向 e</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>15 开始的代码是应用了在单链表创建中的头插法，由于对于无向图，一条边对应都是两个顶点，所以在循环中，一次就针对 i 和 j 分别进行了插入。本算法的时间复杂度，对于 n 个顶点 e 条边来说，很容易得出是 O(n+e)。</p>
<h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><p><strong>把邻接表与逆邻接表结合起来的存储方法叫做十字链表</strong>。</p>
<p>重新定义顶点表结点结构。</p>
<table>
<thead>
<tr>
<th align="center">data</th>
<th align="center">firstin</th>
<th align="center">firstout</th>
</tr>
</thead>
</table>
<p>其中 first 表示入边表头指针，指向该顶点的入边表中第一个结点，firstout 表示出边表头指针，指向该顶点的出边表中的第一个结点。</p>
<p>重新定义的边表结点结构。</p>
<table>
<thead>
<tr>
<th align="center">tailvex</th>
<th align="center">headvex</th>
<th align="center">headlink</th>
<th align="center">taillink</th>
</tr>
</thead>
</table>
<p>其中 tailvex 是指起点在顶点表的下标，headvex 是指弧终点在顶点表中的下标，headlink 是指入边表指针域，指向终点相同的下一条边，taillink 是指边表指针域，指向起点相同的下一条边。如果是网，还可以再增加一个 weight 域来存储权值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8.png" alt="十字链表"></p>
<p>上图顶点依然是存入一个一位数组 {v<sub>0</sub>, v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>}，实线箭头指针的图示完全与之前的邻接表相同。就以顶点 v<sub>0</sub> 来说，firstout 指向的是出边表中的第一个结点 v<sub>3</sub>。所以 v<sub>0</sub> 边表结点的 headvex &#x3D; 3，而 tailvex 其实就是当前顶点 v<sub>0</sub> 的下标 0，由于 v<sub>0</sub> 只有一个出边顶点，所以 headlink 和 taillink 都是空。</p>
<p>图中虚线箭头的含义，它其实就是此图的逆邻接表的表示。对于 v<sub>0</sub> 来说，它有两个顶点 v<sub>1</sub> 和 v<sub>2</sub> 的入边。因此 v<sub>0</sub> 的 firstin 指向顶点 v<sub>1</sub> 的边表结点中 headvex 为 0 的结点，如图中的 ①。接着由入边结点的 headlink 指向下一个入边顶点 v<sub>2</sub>，如图中的 ②。对于顶点 v<sub>1</sub>，它有一个入边顶点 v<sub>2</sub>，所以它的 firstin 指向顶点 v<sub>2</sub> 的边表结点中 headvex 为 1 的结点，如图中的 ③。顶点 v<sub>2</sub> 和 v<sub>3</sub> 也是同样有一个入边顶点，如图中 ④ 和 ⑤。</p>
<p>十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以 v<sub>i</sub> 为尾的弧，也容易找到以 v<sub>i</sub> 为头的弧，因而容易求得顶点的出度和入度。而且它除了结构复杂一点外，其实创建图算法的时间复杂度和邻接表相同，因此，在有向图的应用中，十字链表是非常好的数据结构模型。</p>
<h4 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A81.png" alt="邻接多重表"></p>
<p>若要删除左图的 (v<sub>0</sub>, v<sub>2</sub>) 这条边，需要对邻接表结构中右边表的阴影两个结点进行删除操作，显然这是比较繁琐的。所以仿照十字链表的方式，对边表结点的结构进行一些改造，也许就可以避免刚才提到的问题。</p>
<p>重新定义的边表结点结构：</p>
<table>
<thead>
<tr>
<th align="center">ivex</th>
<th align="center">ilink</th>
<th align="center">jvex</th>
<th align="center">jlink</th>
</tr>
</thead>
</table>
<p>其中 <strong>ivex 和 jvex 是与某条边依附的两个顶点表中下标。ilink 指向依附顶点 ivex 的下一条边，jlink 指向依附顶点 jvex 的下一条边。这就是邻接多重表结构</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A82.png" alt="邻接多重表"></p>
<p>左图中有 4 个顶点和 5 条边，显然，应该先将 4 个顶点和 5 条边的边表结点画出来。由于是无向图，所以 ivex 是 0、jvex 是1 还是反过来都是无所谓的，不过为了绘图方便，都将 ivex 值设置得与一旁的顶点下标相同。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A83.png" alt="邻接多重表"></p>
<p>首先连线的 ①②③④ 就是将顶点的 firstedge 指向一条边，顶点下标要与 ivex 的值相同，这很好理解。接着，由于顶点 v<sub>0</sub> 的 (v<sub>0</sub>, v<sub>1</sub>) 边的邻边有 (v<sub>0</sub>, v<sub>3</sub>) 和 (v<sub>0</sub>, v<sub>2</sub>)。因此 ⑤⑥ 的连线就是满足指向下一条依附于顶点 v<sub>0</sub> 的边的目标，注意 ilink 指向的结点的 jvex 一定要和它本身的 ivex 的值相同。同样的道理，连线 ⑦ 就是指 (v<sub>1</sub>, v<sub>0</sub>) 这条边，它是相当于顶点 v<sub>1</sub> 指向 (v<sub>1</sub>, v<sub>2</sub>) 边后的下一条。v<sub>2</sub> 有三条边依附，所以在 ③ 之后就有了 ⑧⑨。连线 ⑩ 的就是顶点 v<sub>3</sub> 在连线 ④ 之后的下一条边。左图一共有 5 条边，所以右图有 10 条连线，完全符合预期。</p>
<p>邻接多重边与邻接表的差别，仅仅是在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。这样对边的操作就方便多了，若要删除左图的 (v<sub>0</sub>, v<sub>2</sub>) 这条边，只需要将右图的 ⑥⑨ 的链接指向改为 ^ 即可。</p>
<h4 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h4><p><strong>边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标 (begin)、终点下标 (end) 和权 (weight) 组成</strong>。显然边集数组关注的是边的集合，在边集数组中要查找一个顶点的度需要扫描整个边数组，效率并不高。因此它更适合对边依次进行处理的操作，而不适合对顶点相关的操作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E8%BE%B9%E9%9B%86%E6%95%B0%E7%BB%84.png" alt="边集数组"></p>
<p>定义的边数组结构如表</p>
<table>
<thead>
<tr>
<th align="center">begin</th>
<th align="center">end</th>
<th align="center">weight</th>
</tr>
</thead>
</table>
<p>其中 begin 是存储起点下标，end 是存储终点下标，weight 是存储权值。</p>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>图的遍历和树的遍历类似，**从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历 (Traversing Graph)**。</p>
<h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p><strong>深度优先遍历 (Depth_First_Search)，也有称为深度优先搜索，简称 DFS</strong>。深度优先遍历其实就是一个递归的过程，其实就像一棵树的前序遍历。<strong>它从图中某个顶点 v 出发，访问此顶点，然后从 v 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 v 有路径相通的顶点都被访问到</strong>。事实上，这是连通图，对于非连通图，只需要对它的连通分量分别进行深度优先遍历，即在先前一个顶点进行一次深度优先遍历后，<strong>若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点做起始点，重复上述过程，直至图中所有顶点都被访问到为止</strong>。</p>
<p>邻接矩阵方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Boolean;					<span class="comment">// Boolean 是布尔类型，其值是 TRUE 或 FALSE</span></span><br><span class="line">Boolean visited[MAX];					<span class="comment">// 访问标志的数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(MGraph G, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  visited[i] = TRUE;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G.vexs[i]);				<span class="comment">// 打印顶点，也可以其它操作</span></span><br><span class="line">  <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.numVertexes; j++) </span><br><span class="line">    <span class="keyword">if</span>(G.arc[i][j] == <span class="number">1</span> &amp;&amp; !visited[j])</span><br><span class="line">      DFS(G, j);						<span class="comment">// 对未访问的邻接顶点递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 邻接矩阵的深度遍历操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(MGraph G)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++)</span><br><span class="line">    visited[i] = FALSE;					<span class="comment">// 初始所有顶点状态都是未访问过状态</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++)</span><br><span class="line">    <span class="keyword">if</span>(!visited[i])						<span class="comment">// 对未访问过的顶点调用 DFS， 若是连通图，只会执行一次</span></span><br><span class="line">      DFS(G, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果图结构是邻接表结构，其 DFSTraverse 函数的代码是几乎相同的，只是在递归函数中因为将数组换成了链表而有不同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接表的深度优先递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphAdjList GL, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  EdgeNode *p;</span><br><span class="line">  visited[i] = TRUE;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, GL -&gt; adjList[i].data);		<span class="comment">// 打印顶点，也可以其它操作</span></span><br><span class="line">  p = GL -&gt; adjList[i].firstedge;</span><br><span class="line">  <span class="keyword">while</span>(p) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[p -&gt; adjvex])</span><br><span class="line">      DFS(GL, p -&gt; adjvex);					<span class="comment">// 对未访问的邻接点递归调用</span></span><br><span class="line">    p = p -&gt; next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 邻接表的深度遍历操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(GraphAdjList GL)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL -&gt; numVertexes; i++) </span><br><span class="line">    visited[i] = FALSE;						<span class="comment">// 初始所有顶点状态都是未访问过状态</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL -&gt; numVertexes; i++)  		</span><br><span class="line">    <span class="keyword">if</span>(!visited[i])							<span class="comment">// 对未访问过的顶点调用 DFS，若是连通图，只会执行一次</span></span><br><span class="line">    	DFS(GL, i);				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比两个不同存储结构的深度优先遍历算法，对于 n 个顶点 e 条边的图来说，邻接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此都需要 O(n<sup>2</sup>) 的时间。而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是 O(n + e)。显然对于点多少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。</p>
<p>对于有向图而言，由于它只是对通道存在可行或不可行，算法上没有变化，是完全可以通用的。</p>
<h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p><strong>广度优先遍历 (Breadth_First_Search)，又称为广度优先搜索，简称 BFS</strong>。</p>
<p>如果说图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似于树的层序遍历了。将下图的第一幅图稍微变形，变形原则是顶点 A 放置在最上第一层，让与它有边的顶点 B、F 为第二层，再让与 B 和 F 有边的顶点 C、I、G、E 为第三层，再将这四个顶点有边的 D、H 放在第四层，如第二幅图所示。此时在视觉上感觉图的形状发生了变化，其实顶点和边的关系是完全相同的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.png" alt="广度优先遍历"></p>
<p>邻接矩阵结构的广度优先遍历算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵的广度遍历算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(MGraph G)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  Queue Q ;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++) </span><br><span class="line">    visited[i] = FALSE;</span><br><span class="line">  InitQueue(&amp;Q);								<span class="comment">// 初始化一辅助用的队列</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++) &#123;			<span class="comment">// 对每一个顶点做循环</span></span><br><span class="line">    <span class="keyword">if</span>(!visited[i]) &#123;							<span class="comment">// 若是未访问过就处理</span></span><br><span class="line">      visited[i] = TRUE;						<span class="comment">// 设置当前顶点访问过</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G.vexs[i]);					<span class="comment">// 打印顶点，也可以其它操作</span></span><br><span class="line">      EnQueue(&amp;Q, i);							<span class="comment">// 将此顶点如队列</span></span><br><span class="line">      <span class="keyword">while</span>(!QueueEmpty(Q)) &#123;					<span class="comment">// 若当前队列不为空</span></span><br><span class="line">        DeQueue(&amp;Q, &amp;i);						<span class="comment">// 将队中元素出队列，赋值给 i</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.numVertexes;j++) &#123;</span><br><span class="line">          <span class="comment">// 判断其他顶点若与当前顶点存在边且未访问过</span></span><br><span class="line">          <span class="keyword">if</span>(G.arc[i][j] == <span class="number">1</span> ** !visited[j]) &#123;</span><br><span class="line">            visited[j] = TRUE;					<span class="comment">// 将找到的此顶点标记为已访问</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G.vexs[j]);			<span class="comment">// 打印顶点</span></span><br><span class="line">            EnQueue(&amp;Q, j);						<span class="comment">// 将找到的此顶点入队列</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于邻接表的广度优先遍历，代码与邻接矩阵差异不大。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接表的广度遍历算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(GraphAdjList GL)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  EdgeNode *p;</span><br><span class="line">  Queue Q;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL -&gt; numVertexes; i++)</span><br><span class="line">    visited[i] = FALSE;</span><br><span class="line">  InitQueue(&amp;Q);</span><br><span class="line">  <span class="keyword">for</span>(i= <span class="number">0</span>; i &lt; GL -&gt; numVertexes; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">      visited[i] = TRUE;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, GL -&gt; adjList[i].data);			<span class="comment">// 打印顶点，也可以其它操作</span></span><br><span class="line">      EnQueue(&amp;Q, i);</span><br><span class="line">      <span class="keyword">while</span>(!QueueEmpty(Q)) &#123;</span><br><span class="line">        DeQueue(&amp;Q, &amp;i);</span><br><span class="line">        p = GL -&gt; adjList[i].firstedge;				<span class="comment">// 找到当前顶点边表链表头指针</span></span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">          <span class="keyword">if</span>(!visited[p -&gt; adjvex]) &#123;				<span class="comment">// 若此顶点未被访问</span></span><br><span class="line">            visited[p -&gt; adjvex] = TRUE;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, GL - &gt; adjList[p -&gt; adjvex].data);</span><br><span class="line">            EnQueue(&amp;Q, p -&gt; adjvex);				<span class="comment">// 将此顶点入队列</span></span><br><span class="line">          &#125;</span><br><span class="line">          p = p -&gt; next;							<span class="comment">// 指针指向先一个邻接点</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比图的深度优先遍历与广度优先遍历算法，它们在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同。可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。不过如果图顶点和边非常多，不能在短时间内遍历完成，遍历的目的是为了寻找合适的顶点，那么选择哪种遍历就要仔细斟酌了。深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况。</p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>**把构造连通网的最小代价生成树称为最小生成树 (Minimum Cost Spanning Tree)**。</p>
<h4 id="普里姆-Prim-算法"><a href="#普里姆-Prim-算法" class="headerlink" title="普里姆 (Prim) 算法"></a>普里姆 (Prim) 算法</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Prim-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png" alt="Prim-邻接矩阵"></p>
<p>构造邻接矩阵，一个存储结构为 MGraph 的 G。G 有 9 个顶点，它的 arc 二维数组如右图所示。数组中的65535 用 ∞ 表示。</p>
<p>于是普里姆 (Prim) 算法代码如下，左侧数字为行号。其中 INFINITY 为权值极大值，不妨是 65535，MAXVEX 为顶点个数最大值，此处大于等于 9 即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prim 算法生成最小生成树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MiniSpanTree_Prim</span><span class="params">(MGraph G)</span> &#123;</span><br><span class="line">  <span class="type">int</span> min, i, j, k;</span><br><span class="line">  <span class="type">int</span> adjvex[MAXVEX];									<span class="comment">// 保存相关顶点下标</span></span><br><span class="line">  <span class="type">int</span> lowcost[MAXVEX];									<span class="comment">// 保存相关顶点间边的权值</span></span><br><span class="line">  lowcost[<span class="number">0</span>] = <span class="number">0</span>;										<span class="comment">// 初始化第一个权值为 0，即 v0加入生成树，lowcost 的值为 0，在这里就是此下标的顶点已经加入生成树</span></span><br><span class="line">  adjvex[<span class="number">0</span>] = <span class="number">0</span>;										<span class="comment">// 初始化第一个顶点下标为 0 </span></span><br><span class="line">  <span class="keyword">for</span>(i = i; i &lt; G.numVertexes; i++) &#123;					<span class="comment">// 循环除下标为 0 外的全部顶点</span></span><br><span class="line">    lowcost[i] = G.arc[<span class="number">0</span>][i];							<span class="comment">// 将 v0 顶点与之有边的权值存入数组</span></span><br><span class="line">    adjvex[i] = <span class="number">0</span>;										<span class="comment">// 初始化都为 v0 的下标</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; G.numVertexes; i++) &#123;</span><br><span class="line">    min = INFINITY;										<span class="comment">// 初始化最小权值为 ∞，通常设置为不可能的大数字入 32767、65535 等</span></span><br><span class="line">    j = <span class="number">1</span>; k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; G.numVertexes) &#123;							<span class="comment">// 循环全部顶点</span></span><br><span class="line">      <span class="keyword">if</span>(lowcost[j] != <span class="number">0</span> &amp;&amp; lowcost[j] &lt; min) &#123;			<span class="comment">// 如果权值不为 0 且权值小于 min</span></span><br><span class="line">        min = lowcost[j];								<span class="comment">// 则让当前权值称为最小值</span></span><br><span class="line">        k = j;											<span class="comment">// 将当前最小值的下标存入 k</span></span><br><span class="line">      &#125;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)&quot;</span>, adjvex[k], k);					<span class="comment">// 打印当前顶点边中权值最小边</span></span><br><span class="line">    lowcost[k] = <span class="number">0</span>;										<span class="comment">// 将当前顶点的权值设置为 0，表示此顶点已经完成任务</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; G.numVertexes; j++) &#123;				<span class="comment">// 循环所有顶点</span></span><br><span class="line">      <span class="keyword">if</span>(lowcost[j] != <span class="number">0</span> &amp;&amp; G.arc[k][j] &lt; lowcost[j]) &#123;	<span class="comment">// 若下标为 k 顶点各边权值小于此前这些顶点未被加入生成树权值</span></span><br><span class="line">        lowcost[j] = G.arc[k][j];						<span class="comment">// 将较小权值存入 lowcost</span></span><br><span class="line">        adjvex[j] = k;									<span class="comment">// 将下标为 k 的顶点存入 adjvex</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>程序开始运行，由 4～5 行，创建了两个一维数组 lowcost 和 adjvex，长度都为顶点个数 9。</p>
</li>
<li><p>第 6～7 行分别给这两个数组的第一个下标位赋值为 0，arjvex[0] &#x3D; 0 其实意思就是现在从顶点 v<sub>0</sub> 开始 (事实上，最小生成树从哪个顶点开始计算都无所谓，假定从 v<sub>0</sub> 开始)，lowcost[0] &#x3D; 0 就表示 v<sub>0</sub> 已经被纳入到最小生成树中，之后凡是 lowcost 数组中的值被设置为 0 就是表示此下标的顶点被纳入最小生成树。</p>
</li>
<li><p>第 8～11 行表示读取右图邻接矩阵的第一行数据。将数值赋值给 lowcost 数组，所以此时 lowcost 数组值为{0, 10, 65535, 65535, 65535, 11,65535, 65535, 65535}，而 arjvex 则全部为 0。此时，我们已经完成了整个初始化的工作，准备开始生成。</p>
</li>
<li><p>第 12～31 行，整个循环过程就是构造最小生成树的过程。</p>
</li>
<li><p>第 13～14 行，将 min 设置为了一个极大值 65535，它的目的是为了之后找到一定范围内的最小权值。j 是用来做顶点下标循环的变量，k 是用来存储最小权值的顶点下标。</p>
</li>
<li><p>第 15～21行，循环中不断修改 min 为当前 lowcost 数组中最小值，并用 k 保留此最小值的顶点下标。经过循环后，min &#x3D; 10，k &#x3D; 1。 注意16行 if 判断的lowcost[j] !&#x3D; 0 表示已经是生成树的顶点不参与最小权值的查找。</p>
</li>
<li><p>第 22 行，因 k &#x3D; 1，adjvex[1] &#x3D; 0，所以打印结果为 (0, 1)，表示 v<sub>0</sub> 至 v<sub>1</sub> 边为最小生成树的第一条边。如下图</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Prim-2.png" alt="Prim-2"></p>
</li>
<li><p>第 23 行，此时因 k &#x3D; 1 将 lowcost[k] &#x3D; 0 就是说顶点 v<sub>1</sub> 纳入到最小生成树中。此时 lowcost 数组值为 {0, 0, 65535, 65535, 65535, 11, 65535, 65535, 65535}。</p>
</li>
<li><p>第 24～30 行，j 循环由 1 至 8，因 k &#x3D; 1，查找邻接矩阵的第 v<sub>1</sub> 行的各个权值，与 lowcost 的对应值比较，若更小则修改 lowcost 值，并将 k 值存入 adjvex 数组中。因第 v<sub>1</sub> 行有 18、16、12 均比 65535 小，所以最终 lowcost 数组的值为：{0, 0, 18, 65535, 65535, 11, 16, 655365, 12}。adjvex 数组的值为：{0, 0, 1, 0, 0, 0, 1, 0, 1}。这里第 25 行 if 判断的 lowcost[j] !&#x3D; 0 也说明 v<sub>0</sub> 和 v<sub>1</sub> 已经是生成树的顶点不参与最小权值的比对了。</p>
</li>
<li><p>再次循环，由第 13～22 行，此时 min &#x3D; 11，k &#x3D; 5，adjvex[5] &#x3D; 0。因此打印结构为 (0, 5)。表示 v<sub>0</sub> 至 v<sub>5</sub> 边为最小生成树的第二条边，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Prim-3.png" alt="Prim-3"></p>
</li>
<li><p>接下来执行到 31 行，lowcost 数组的值为：{0, 0, 18, 65535, 26, 0, 16, 65535, 12}。adjvex 数组的值为：{0, 0, 1, 0, 5, 0, 1, 0, 1}。</p>
</li>
<li><p>之后，通过不断的转换，构造的过程如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Prim-4.png" alt="Prim-4"></p>
</li>
</ol>
<p>普里姆 (Prim) 算法定义：假设 N &#x3D; (P, {E}) 是连通网，TE 是 N 上最小生成树中边的集合。算法从 U &#x3D; {u<sub>0</sub>} (u<sub>0</sub> ∈ V)，TE &#x3D; {} 开始。重复执行下述操作。在所有 u ∈ U，v ∈ V - U 的边(u, v) ∈ E 中找一条代价最小的边(u<sub>0</sub>, v<sub>0</sub>) 并入集合 TE，同时 v<sub>0</sub> 并入 U，直至 U &#x3D; V 为止。此时 TE 中必有 n - 1 条边，则 T &#x3D; (V, {TE}) 为 N 的最小生成树。</p>
<p>由算法代码中的循环嵌套可得知此算法的时间复杂度为 O(n<sup>2</sup>)。</p>
<h4 id="克鲁斯卡尔-Kruskal-算法"><a href="#克鲁斯卡尔-Kruskal-算法" class="headerlink" title="克鲁斯卡尔 (Kruskal) 算法"></a>克鲁斯卡尔 (Kruskal) 算法</h4><p>直接以边为目标去构建，因为权值是在边上，直接去找最小权值的边来构建生成树也是很自然的想法，只不过构建时要考虑是否会形成环流而已。此时就用到了图的存储结构中的边集数组结构。以下是 edge 边集数组结构的定义代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对边集数组 Edge 结构的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> begin;</span><br><span class="line">  <span class="type">int</span> end;</span><br><span class="line">  <span class="type">int</span> weight;</span><br><span class="line">&#125;Edge;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Kruskal-1.png" alt="Kruskal-1"></p>
<p>将在普里姆算法构建的邻接矩阵通过程序转化为上图的右图的边集数组，并且对它们安全值从小到大排序。</p>
<p>克鲁斯卡尔算法代码如下。其中 MAXEDGE 为边数量的极大值，此处大于等于 15 即可，MAXVEX 为顶点个数最大值，此处大于等于 9 即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kruskal 算法生成最小生成树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MiniSpanTree_Kruskal</span><span class="params">(MGraph G)</span> &#123;		<span class="comment">// 生成最小生成树</span></span><br><span class="line">  <span class="type">int</span> i, n, m;</span><br><span class="line">  Edge edges[MAXEDGE];						<span class="comment">// 定义边集数组</span></span><br><span class="line">  <span class="type">int</span> parent[MAXVEX];						<span class="comment">// 定义一数组用来判断边与边是否形成环路</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++) </span><br><span class="line">    parent[i] = <span class="number">0</span>;							<span class="comment">// 初始化数组值为 0</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++) &#123;		<span class="comment">// 循环每一条边</span></span><br><span class="line">    n = Find(parent, edges[i].begin);</span><br><span class="line">    m = Find(parent, edges[i].end);</span><br><span class="line">    <span class="keyword">if</span>(n != m) &#123;							<span class="comment">// 假如 n 与 m 不等，说明此边没有与现有生成树形成环路</span></span><br><span class="line">      parent[n] = m;						<span class="comment">// 将此边的结尾顶点放入下标为起点的 parent 中，表示此顶点已经在生成树集合中</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d) %d&quot;</span>, edges[i].begin, edges[i].end, edges[i].weight);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> *parent, <span class="type">int</span> f)</span> &#123;				<span class="comment">// 查找连线顶点的尾部下标</span></span><br><span class="line">  <span class="keyword">while</span>(parent[f] &gt; <span class="number">0</span>)</span><br><span class="line">    f = parent[f];</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>程序开始运行，第 5 行之后，省略掉颇占篇幅但却很容易实现的将邻接矩阵转换为边集数组，并按权值从小到大排序的代码，也就是说，从第 5 行开始，已经有了结构为 edge，数据内容是上图有边的一维数组 edges。</p>
</li>
<li><p>第 5～7 行，生命一个数组 parent，并将它的值都初始化为 0。</p>
</li>
<li><p>第 8～15 行，开始对边集数组做循环遍历，开始时，i &#x3D; 0。</p>
</li>
<li><p>第 9 行，调用了第 17～21 行的函数 Find，传入的参数是数组 parent 和当前权值最小边 (v<sub>4</sub>, v<sub>7</sub>) 的 begin：4。因为 parent 中全都是 0 所以传出值使得 n &#x3D; 4。</p>
</li>
<li><p>第 10 行，传入 (v<sub>4</sub>, v<sub>7</sub>) 的 end：7。传出值使得 m &#x3D; 7。</p>
</li>
<li><p>第 11～14 行，很显然 n 与 m 不等，因此 parent[4] &#x3D; 7。此时 parent 数组值为 {0, 0, 0, 0, 7, 0, 0, 0, 0}，并且打印得到 “(4, 7) 7”。此时已经将边  (v<sub>4</sub>, v<sub>7</sub>) 纳入到最小生成树中。如下图。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Kruskal-2.png" alt="Kruskal-2"></p>
</li>
<li><p>循环返回，执行 9～14 行，此时 i &#x3D; 1，edge[1] 得到边 (v<sub>2</sub>, v<sub>8</sub>)，n &#x3D; 2，m &#x3D; 8，parent[2] &#x3D; 8，打印结果为 “(2, 8) 8”，此时 parent 数组值为 {0, 0, 8, 0, 7, 0, 0, 0, 0}，这也就表示边 (v<sub>4</sub>, v<sub>7</sub>) 和 边 (v<sub>2</sub>, v<sub>8</sub>) 已经纳入到最小生成树。如下图。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Kruskal-3.png" alt="Kruskal-3"></p>
</li>
<li><p>再次执行 9～14 行，此时 i &#x3D; 2，edge[2] 得到边 (v<sub>0</sub>, v<sub>1</sub>)，n &#x3D; 0，m &#x3D; 1，parent[0] &#x3D; 1，打印结果为 “(0, 1) 10”，此时 parent 数组值为 {1, 0, 8, 0, 7, 0, 0, 0, 0}，此时边 (v<sub>4</sub>, v<sub>7</sub>)、(v<sub>2</sub>, v<sub>8</sub>) 和 (v<sub>0</sub>, v<sub>1</sub>) 已经纳入到最小生成树，如图。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Kruskal-4.png" alt="Kruskal-4"></p>
</li>
<li><p>当 i &#x3D; 3、4、5、6 时，分别将边 (v<sub>0</sub>, v<sub>5</sub>)、(v<sub>1</sub>, v<sub>8</sub>)、(v<sub>3</sub>, v<sub>7</sub>) 和 (v<sub>1</sub>, v<sub>6</sub>) 纳入到最小生成树中。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Kruskal-5.png" alt="Kruskal-5"></p>
<p> 从上图的最右图 i &#x3D; 6 的粗线连线可以得到，其实是有两个连通的边集合 A 与 B 中纳入到最小生成树中的。如下图所示。当 parent[0] &#x3D; 1，表示 v<sub>0</sub> 和 v<sub>1</sub> 已经在生成树的边集合 A 中。此时将 parent[0] &#x3D; 1 的 1 改为下标，由 parent[1] &#x3D; 5, 表示 v<sub>1</sub> 和 v<sub>5</sub> 在边集合 A 中，parent[5] &#x3D; 8 表示 v<sub>5</sub> 与 v<sub>8</sub> 在边集合 A 中，parent[8] &#x3D; 6 表示 v<sub>8</sub> 与v<sub>6</sub> 在边集合 A 中，parent[6] &#x3D; 0 表示集合 A 暂时到头，此时边集合 A 有 v<sub>0</sub>、v<sub>1</sub>、v<sub>5</sub>、v<sub>8</sub>、v<sub>6</sub>。查看 parent 中没有查看的值，parent[2] &#x3D; 8 表示 v<sub>2</sub> 与v<sub>8</sub> 在一个集合中，因此 v<sub>2</sub> 也在边集合 A 中。再由 parent[3] &#x3D; 7、parent[4] &#x3D; 7 和 parent[7] &#x3D; 0 可知 v<sub>3</sub>、v<sub>4</sub>、v<sub>7</sub> 在另一个边集合 B 中。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Kruskal-6.png" alt="Kruskal-6"></p>
</li>
<li><p>当 i &#x3D; 7 时，第 10 行，调用 Find 函数，会传入参数 edges[7].begin &#x3D; 5。此时第 18 行，parent[5] &#x3D; 8 &gt; 0，所以 f &#x3D; 8，再循环得 parent[8] &#x3D; 6。因 parent[6] &#x3D; 0 所以 Find 返回后第 10 行得到 n &#x3D; 6.而此时第 11 行，传入参数 edges[7].end &#x3D; 6 得到 m &#x3D; 6。此时 n &#x3D; m，不再打印，继续下一循环。这就告诉我们，因为边 (v<sub>5</sub>, v<sub>6</sub>) 使得边集合 A 形成了环路。因此不能将它纳入到最小生成树中，如上图所示。</p>
</li>
<li><p>当 i &#x3D; 8 时，与上面相同，由于边 (v<sub>1</sub>, v<sub>2</sub>) 使得边集合 A 形成了环路。因此不能将它纳入到最小生成树中。</p>
</li>
<li><p>当 i &#x3D; 9 时，边 (v<sub>6</sub>, v<sub>7</sub>)，第 10 行得到 n &#x3D; 6，第 11 行得到 m &#x3D; 7，因此 parent[6] &#x3D; 7，打印 “(6, 7) 19”。此时 parent 数组值为 {1, 5, 8, 7, 7, 8, 7, 0, 6}，如下图。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Kruskal-7.png" alt="Kruskal-7"></p>
</li>
<li><p>此后边的循环均造成环路，最终最小生成树即为上图。</p>
</li>
</ol>
<p>克鲁斯卡尔 (Kruskal) 算法的定义：假设 N &#x3D; (V, {E}) 是连通图，则令最小生成树的初始状态为只有 n 个顶点而无边的非连通图 T &#x3D; {V, {}}，图中每个顶点自成一个连通分量。在 E 中选择代价最小的边，若该边依附的顶点落在 T 中不同的连通分量上，则将此边加入到 T 中，否则舍去此边而选择下一条代价最小的边。以此类推，直至 T 中所有顶点都在同一连通分量上为止。</p>
<p>此算法的 Find 函数由边数 e 决定，时间复杂度为 O(loge)，而外面有一个 for 循环 e 次。所以克鲁斯卡尔算法的时间复杂度为 O(eloge)。</p>
<p>对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以对于稀疏图有很大优势；而普里姆算法对于稠密图，即边数非常多的情况会更好一些。</p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>在网图和非网图中，最短路径的含义是不同的。由于非网图它没有边上的权值，所谓的最短路径，其实就是指两顶点之间经过的边数最少的路径；而<strong>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点</strong>。显然，研究网图更有实际意义，就地图来说，距离就是两顶点间的权值之和。而非网图完全可以理解为所有的边的权值都为 1 的网。</p>
<h4 id="迪杰斯特拉-Dijkstra-算法"><a href="#迪杰斯特拉-Dijkstra-算法" class="headerlink" title="迪杰斯特拉 (Dijkstra) 算法"></a>迪杰斯特拉 (Dijkstra) 算法</h4><p>这是一个按路径长度递增的次序产生最短路径的算法。它的思路大体是这样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVEX 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 65535</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Pathmatirx[MAXVEX];				<span class="comment">// 用于存储最短路径下标的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ShortPathTable[MAXVEX];			<span class="comment">// 用于存储到各点最短路径的权值和</span></span><br><span class="line"><span class="comment">// Dijkstra 算法，求有向网 G 的 v0 顶点到其余顶点 v 最短路径 P[v] 及带权长度 D[v], P[v] 的值为前驱顶点下标，D[v] 表示 v0 到 v 的最短路径长度和。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath_Dijkstra</span><span class="params">(MGraph G, <span class="type">int</span> v0, Pathmatirx *P, ShortPathTable *D)</span> &#123;</span><br><span class="line">  <span class="type">int</span> v, w, k, min;</span><br><span class="line">  <span class="type">int</span> final[MAXVEX];						<span class="comment">// final[w] = 1 表示求得顶点 v0 至 vw 的最短路径</span></span><br><span class="line">  <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.numVertexes; v++) &#123;		<span class="comment">// 初始化数据</span></span><br><span class="line">    final[v] = <span class="number">0</span>;							<span class="comment">// 全部顶点初始化为未知最短路径状态</span></span><br><span class="line">    (*D)[v] = G.matirx[v0][v];				<span class="comment">// 将与 v0 点有连线的顶点加上权值</span></span><br><span class="line">    (*P)[v] = <span class="number">0</span>;							<span class="comment">// 初始化路径数组 p 为 0</span></span><br><span class="line">  &#125;</span><br><span class="line">  (*D)[v0] = <span class="number">0</span>;								<span class="comment">// v0 至 v0 路径为 0</span></span><br><span class="line">  final[v0] = <span class="number">1</span>;							<span class="comment">// v0 至 v0 不需要求路径</span></span><br><span class="line">  <span class="comment">// 开始主循环，每次求得 v0 到某个 v 顶点的最短路径</span></span><br><span class="line">  <span class="keyword">for</span>(v = <span class="number">1</span>; v &lt; G.numVertexes; v++) &#123;</span><br><span class="line">    min = INFINITY;							<span class="comment">// 当前所知离 v0 顶点的最近距离</span></span><br><span class="line">    <span class="keyword">for</span>(w = <span class="number">0</span>;w &lt; G.numVertexes; w++) &#123;		<span class="comment">// 寻找离 v0 最近的顶点</span></span><br><span class="line">      <span class="keyword">if</span>(!final[w] &amp;&amp; (*D)[w] &lt; min) &#123;</span><br><span class="line">        k = w;</span><br><span class="line">        min = (*D)[w];						<span class="comment">// w 顶点离 v0 顶点更近</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    final[k] = <span class="number">1</span>;							<span class="comment">// 将目前找到的最近的顶点位置为 1</span></span><br><span class="line">    <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.numVertexes; w++) &#123;	<span class="comment">// 修正当前最短路径及距离</span></span><br><span class="line">      <span class="comment">// 如果经过 v 顶点的路径比现在这条路径的长度短的话</span></span><br><span class="line">      <span class="keyword">if</span>(!final[w] &amp;&amp; (min + G.matirx[k][w] &lt; (*D)[w])) &#123;</span><br><span class="line">        <span class="comment">// 说明找到了更短的路径，修改 D[w] 和 P[w]</span></span><br><span class="line">        (*D)[w] = min + G.matirx[k][w];		<span class="comment">// 修改当前路径长度</span></span><br><span class="line">        (*P)[w] = k;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用此函数前，需要为下图中的左图准备邻接矩阵 MGraph 的 G，如右图，并且定义参数 v<sub>0</sub> 为 0。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Dijkstra-1.png" alt="Dijkstra"></p>
<ol>
<li><p>程序开始运行，第 4 行final 数组是为了 v<sub>0</sub> 到某顶点是否已经求得最短路径的标记，如果 v<sub>0</sub> 到 v<sub>w</sub> 已经有结果，则 final[w] &#x3D; 1。</p>
</li>
<li><p>第 9～13 行，是在对数据进行初始化的工作。此时 final 数组值均为 0，表示所有的点都未求得最短路径。D 数组为 {65535, 1, 5, 65535, 65535, 65535, 65535, 65535, 65535}。因为 v<sub>0</sub> 到 v<sub>1</sub> 和 v<sub>2</sub> 的边权值为 1 和 5。P 数组全为0，表示目前没有路径。</p>
</li>
<li><p>第 14 行，表示 v<sub>0</sub> 到 v<sub>0</sub> 自身，权值和结果为 0。D 数组为 {0, 1, 5, 65535, 65535, 65535, 65535, 65535, 65535}。第 15 行，表示 v<sub>0</sub> 点算是已经求得最短路径，因此 final[0] &#x3D; 1。此时 final 数组为 {1, 0, 0, 0, 0, 0, 0, 0, 0}。此时整个初始化工作完成。</p>
</li>
<li><p>第 17～35 行，为主循环，每次循环求得 v<sub>0</sub> 与一个顶点的最短路径。因此 v 从 1 而不是 0 开始。</p>
</li>
<li><p>第 18～24 行，先令 min 为 65535 的极大值，通过 w 循环，与 D[w] 比较找到最小值 min &#x3D; 1, k &#x3D; 1。</p>
</li>
<li><p>第 25 行，由 k &#x3D; 1，表示与 v<sub>0</sub> 最近的顶点是 v<sub>1</sub>，并且由 D[1] &#x3D; 1，知道此时 v<sub>0</sub> 到 v<sub>1</sub> 的最短距离是 1。因此将 v<sub>1</sub> 对应的 final[1] 设置为 1。此时 final 数组为 {1, 1, 0, 0, 0, 0, 0, 0, 0}。</p>
</li>
<li><p>第 26～34 行是一循环，此循环甚为关键。它的目的是在刚才已经找到 v<sub>0</sub> 与 v<sub>1</sub> 的最短路径的基础上，对 v<sub>1</sub> 与其他顶点的边进行计算，得到 v<sub>0</sub> 与它们的当前最短距离，如下图。因为 min &#x3D; 1，所以本来 D[2] &#x3D; 5，现在 v<sub>0</sub> → v<sub>1</sub> → v<sub>2</sub> &#x3D; D[2] &#x3D; min + 3 &#x3D; 4，v<sub>0</sub> → v<sub>1</sub> → v<sub>3</sub> &#x3D; D[3] &#x3D; min + 7 &#x3D; 8，v<sub>0</sub> → v<sub>1</sub> → v<sub>4</sub> &#x3D; D[4] &#x3D; min + 5 &#x3D; 6，因此，D 数组当前值为 {0, 1, 4, 8, 6, 65535, 65535, 65535, 65535}。而 P[2] &#x3D; 1，P[3] &#x3D; 1，P[4] &#x3D; 1，它表示的意思是 v<sub>0</sub> 到 v<sub>2</sub>、v<sub>3</sub>、v<sub>4</sub> 点的最短路径它们的前驱均是 v<sub>1</sub>。此时 P 数组值为：{0, 0, 1, 1, 1, 0, 0, 0, 0}。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Dijkstra-2.png" alt="Dijkstra-2"></p>
</li>
<li><p>重新开始循环，此时 i &#x3D; 2。第 18～24 行，对 w 循环，注意因为 final[0] &#x3D; 1 和final[1] &#x3D; 1，由第 20 行的 !final[w] 可知，v<sub>0</sub> 与 v<sub>1</sub> 并不参与最小值的获取。通过循环比较，找到最小值 min &#x3D; 4，k &#x3D; 2。</p>
</li>
<li><p>第 25 行，由 k &#x3D; 2，表示已经求出 v<sub>0</sub> 与 v<sub>2</sub> 的最短路径，并且由 D[2] &#x3D; 4，知道最短距离是 4。因此将 v<sub>2</sub> 对应的 final[2] 设置为 1，此时 final 数组为：{1, 1, 1, 0, 0, 0, 0, 0, 0}。</p>
</li>
<li><p>第 26～34 行。在刚才已经找到 v<sub>0</sub> 与 v<sub>2</sub> 的最短路径的基础上，对 v<sub>2</sub> 与其它顶点的边，进行计算，得到 v<sub>0</sub> 与它们的当前最短距离，如下图。因为 min &#x3D; 4，所以本来 D[4] &#x3D; 6，现在 v<sub>0</sub> → v<sub>2</sub> → v<sub>4</sub> &#x3D; D[4] &#x3D; min + 1 &#x3D; 5，v<sub>0</sub> → v<sub>2</sub> → v<sub>5</sub> &#x3D; D[5] &#x3D; min + 7 &#x3D; 11，因此，D 数组当前值为：{0, 1, 3, 8, 5, 11, 65535, 65535, 65535}。而原本 P[4] &#x3D; 1，此时 P[4] &#x3D; 2，P[5] &#x3D; 2，它表示 v<sub>0</sub> 到 v<sub>4</sub>、v<sub>5</sub> 点的最短路径它们的前驱均是 v<sub>2</sub>。此时 P 数组值为：{0, 0, 1, 1, 2, 2, 0, 0, 0}。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Dijkstra-3.png" alt="Dijkstra"></p>
</li>
<li><p>重新开始循环，此时 i &#x3D; 3。第 18～24 行，通过对 w 循环比较找到最小值 min &#x3D; 5， k &#x3D; 4。</p>
</li>
<li><p>第 25 行，由 k &#x3D; 4，表示已经求出 v<sub>0</sub> 到 v<sub>4</sub> 的最短路径，并且由 D[4] &#x3D; 5，知道最短距离是 5。因此将 v<sub>4</sub> 对应的 final[4] 设置为 1。此时 final 数组为：{1, 1, 1, 0, 1, 0, 0, 0, 0}。</p>
</li>
<li><p>第 26～24 行。对 v<sub>4</sub> 与其他顶点的边进行计算，得到 v<sub>0</sub> 与它们的当前最短距离，如下图所示。因为 min &#x3D; 5，所以本来 D[3] &#x3D; 8，现在 v<sub>0</sub> → v<sub>4</sub> → v<sub>3</sub> &#x3D; D[3] &#x3D; min + 2 &#x3D; 7，本来 D[5] &#x3D; 11，现在 v<sub>0</sub> → v<sub>4</sub> → v<sub>5</sub> &#x3D; D[5] &#x3D; min + 3 &#x3D; 8，另外 v<sub>0</sub> → v<sub>4</sub> → v<sub>6</sub> &#x3D; D[6] &#x3D; min + 6 &#x3D; 11，v<sub>0</sub> → v<sub>4</sub> → v<sub>7</sub> &#x3D; D[7] &#x3D; min + 9 &#x3D; 14，因此，D 数组当前值为：{0, 1, 4, 7, 5, 8, 11, 14, 65535}。而原本 P[3] &#x3D; 1，此时 P[3] &#x3D; 4，原本 P[5] &#x3D; 2，此时 P[5] &#x3D;  4，另外 P[6] &#x3D; 4，P[7] &#x3D; 4，它表示 v<sub>0</sub> 到 v<sub>3</sub>、v<sub>5</sub>、v<sub>6</sub>、v<sub>7</sub> 点的最短路径它们的前驱均是 v<sub>4</sub>。此时 P 数组值为：{0, 0, 1, 4, 2, 4, 4, 4, 0}。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Dijkstra-4.png" alt="Dijkstra"></p>
</li>
<li><p>之后的循环就完全类似了。得到最终的结果，如下图。此时 final 数组为：{1, 1, 1, 1, 1, 1, 1, 1, 1}，它表示所有的顶点均完成了最短路径的查找工作。此时D数组为：{0, 1, 4, 7, 5, 8, 10, 12, 16}，它表示 v<sub>0</sub> 到各个顶点的最短路径数，比如 D[8]-1+3+1+2+3+2+4 &#x3D; 16。此时的 P 数组为：{0, 0, 1, 4, 2, 4, 3, 6, 7}，这串数字可能略为难理解一些。比如 P[8] &#x3D; 7，它的意思是 v<sub>0</sub> 到 v<sub>8</sub> 的最短路径，顶点 v<sub>8</sub> 的前驱顶点是 v<sub>7</sub>，再由 P[7] &#x3D; 6 表示 v<sub>7</sub> 的前驱是 v<sub>6</sub>， P[6] &#x3D; 3，表示 v<sub>6</sub> 的前驱是 v<sub>3</sub>。这样就可以得到，v<sub>0</sub>到 v<sub>8</sub> 的最短路径为v<sub>8</sub> ← v<sub>7</sub> ← v<sub>6</sub> ← v<sub>3</sub> ← v<sub>4</sub> ← v<sub>2</sub> ← v<sub>1</sub> ← v<sub>0</sub>。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Dijkstra-5.png" alt="Dijkstra"></p>
</li>
</ol>
<p>其实最终返回的数组 D 和数组 P，是可以得到 v<sub>0</sub> 到任意一个顶点的最短路径和路径长度的。例如 v<sub>0</sub> 到 v<sub>8</sub> 的最短路径并没有经过 v<sub>5</sub>，但我们已经知道 v<sub>0</sub> 到 v<sub>5</sub> 的最短路径了。由 D[5] &#x3D; 8 可知它的路径长度为 8，由P[5] &#x3D; 4 可知 v<sub>5</sub> 的前驱顶点是 v<sub>4</sub>，所以 v<sub>0</sub> 到 v<sub>5</sub> 的最短路径是 v<sub>0</sub> → v<sub>1</sub> → v<sub>2</sub> → v<sub>4</sub> → v<sub>5</sub>。</p>
<p>也就是说，我们通过迪杰斯特拉（Dijkstra）算法解决了从某个源点到其余各顶点的最短路径问题。从循环嵌套可以很容易得到此算法的时间复杂度为 0(n<sup>2</sup>)，尽管有同学觉得，可不可以只找到从源点到某一个特定终点的最短路径，其实这个问题和求源点到其他所有顶点的最短路径一样复杂，时间复杂度依然是 0(n<sup>2</sup>)。</p>
<h4 id="佛洛依德-Floyd-算法"><a href="#佛洛依德-Floyd-算法" class="headerlink" title="佛洛依德 (Floyd) 算法"></a>佛洛依德 (Floyd) 算法</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Floyd-1.png" alt="Floyd"></p>
<p>上图是一个最简单的 3 个顶点连通网图。先定义两个二维数组 D[3][3] 和 P[3][3]，D 代表顶点到顶点的最短路径权值和的矩阵。P 代表 对应顶点的最小路径的前驱矩阵。在未分析任何顶点之前，将 D 命名为 D<sup>-1</sup>，其实他就是初始的图的邻接矩阵。将 P 命名为 P<sup>-1</sup>，初始化为图中所示的矩阵。</p>
<p>首先，所有的顶点经过 v<sub>0</sub> 后到达另一顶点的最短路径。因为只有三个顶点，因此需要查看 v<sub>1</sub> → v<sub>0</sub> → v<sub>2</sub>， 得到 D<sup>-1</sup>[1][0] + D<sup>-1</sup>[0][2] &#x3D; 2 + 1 &#x3D; 3。D<sup>-1</sup>[1][2] 表示的是 v<sub>1</sub> → v<sub>2</sub> 的权值为 5，发现 D<sup>-1</sup>[1][2] &gt; D<sup>-1</sup>[1][0] + D<sup>-1</sup>[0][2]，通俗的话讲就是 v<sub>1</sub> → v<sub>0</sub> → v<sub>2</sub> 比直接 v<sub>1</sub> → v<sub>2</sub> 距离还要近。所以让 D-1[1][2] &#x3D; D<sup>-1</sup>[1][0] + D<sup>-1</sup>[0][2] &#x3D; 3，同样的 D<sup>-1</sup>[2][1] &#x3D; 3，于是就有了 D<sup>0</sup> 的矩阵。因为有变化，所以 P 矩阵对应的 P<sup>-1</sup>[1][2] 和 P<sup>-1</sup>[2][1] 也修改为当前中转的顶点 v<sub>0</sub> 的下标 0，于是就有了 P<sup>0</sup>。也就是说 D<sup>0</sup>[v][w] &#x3D; min{D<sup>-1</sup>[v][w], D<sup>-1</sup>[v][0] + D<sup>-1</sup>[0][w]}。</p>
<p>接下来，其实也就是在 D<sup>0</sup> 和 P<sup>0</sup> 的基础上继续处理所有顶点经过 v<sub>1</sub> 和 v<sub>2</sub> 后到达另一顶点的最短路径，得到 D<sup>1</sup> 和 P<sup>1</sup>，D<sup>2</sup> 和 P<sup>2</sup> 完成所有顶点到所有顶点的最短路径计算工作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Floyd-2.png" alt="Floyd"></p>
<p>首先针对上图的做网图准备两个矩阵 D<sup>-1</sup> 和 P<sup>-1</sup> ，D<sup>-1</sup> 就是网图的邻接矩阵，P<sup>-1</sup> 初设为 P[i][j] &#x3D; j 这样的矩阵，它主要用来存储路径。</p>
<p>求所有顶点到所有顶点的最短路径代码如下，Pathmatirx 和 ShortPathTable 都是二维数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Pathmatirx[MAXVEX][MAXVEX];</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ShortPathTable[MAXVEX][MAXVEX];</span><br><span class="line"><span class="comment">// Floyd 算法，求网图 G 中个顶点 v 到其余顶点 w 最短路径 P[v][w] 及带权长度 D[v][w]</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath_Floyd</span><span class="params">(MGraph G, Pathmatirx *P, ShortPathTable *D)</span> &#123;</span><br><span class="line">  <span class="type">int</span> v, w, k;</span><br><span class="line">  <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.numVertexes; ++v) &#123;</span><br><span class="line">    <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.numVertexes; ++w) &#123;</span><br><span class="line">      (*D)[v][w] = G.matirx[v][w];			<span class="comment">// (*D)[v][w] 值即为对应点间的权值</span></span><br><span class="line">      (*P)[v][w] = w;						<span class="comment">// 初始化 P</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.numVertexes; ++k) &#123;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.numVertexes; ++v) &#123;</span><br><span class="line">      <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.numVertexes; ++w) &#123;</span><br><span class="line">        <span class="keyword">if</span>((*D)[v][w] &gt; (*D)[v][k] + (*D)[k][w]) &#123;</span><br><span class="line">          <span class="comment">// 如果经过下标为 k 顶点路径比原来两点间路径更短，将当前两点间权值设为更小的一个</span></span><br><span class="line">          (*D)[v][w] &gt; (*D)[v][k] + (*D)[k][w];</span><br><span class="line">          (*P)[v][w] &gt; (*P)[v][k];			<span class="comment">// 路径设置经过下标为 k 的顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>程序开始运行，第 6～11 行就是初始化了 D 和 P，使得它们称为上图的两个矩阵。从矩阵也得到，v<sub>0</sub> → v<sub>1</sub> 路径权值是 1，v<sub>0</sub> → v<sub>2</sub> 路径权值是 5，v<sub>0</sub> → v<sub>3</sub> 无边连线，所以路径权值为极大值 65535。</p>
</li>
<li><p>第 12～22 行，是算法的主循环，一共三层嵌套，k 代表的就是中转顶点的下标。v 代表起始顶点，w 代表结束顶点。</p>
</li>
<li><p>当 K &#x3D; 0 时，也就是所有的顶点都经过 v<sub>0</sub> 中转，计算是否有最短路径的变化。可惜结果是，没有任何变化，如下图。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Floyd-3.png" alt="Floyd"></p>
</li>
<li><p>当 K &#x3D; 1 时，也就是所有的顶点都经过 v<sub>1</sub> 中转。此时，当 v &#x3D; 0 时，原本D[0][2] &#x3D; 5，现在由于 D[0][1] + D[1][2] &#x3D; 4。因此由第 17 行代码，二者取其最小值，得到 D[0][2] &#x3D; 4，同理可得 D[0]p3] &#x3D; 8、D[0][4] &#x3D; 6，当 v &#x3D; 2、3、4 时，也修改了一些数据，如下左图虚线框数据。由于这些最小权值的修正，所以在路径矩阵 P 上，也要做处理，将它们都改为当前的 P[v][k] 值，如代码的 18 行。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Floyd-4.png" alt="Floyd"></p>
</li>
<li><p>接下来就是 k &#x3D; 2 一直到 8 结束，表示针对每个顶点做中转得到的计算结果，当然，D<sup>0</sup> 是以 D<sup>1</sup> 为基础，D<sup>1</sup> 是以 D<sup>0</sup> 为基础，……，D<sup>8</sup> 是以 D<sup>7</sup> 为基础。最终当 k &#x3D; 8 时，两矩阵数据如下图所示。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/Floyd-5.png" alt="Floyd"></p>
</li>
</ol>
<p>​	至此，最短路就算是完成了，可以看到矩阵第 v<sub>0</sub> 行的数值与迪杰斯特拉 (Dijkstra) 算法求得的 D 数组的数值是完全相同，都是 {0, 1, 4, 7, 5, 8, 10, 12, 16}。而且这里是所有顶点到所有顶点的最短路径权值和都可以计算出。</p>
<p>如何由 P 这个路径数组的出具体的最短路径？以 v<sub>0</sub> 到 v<sub>8</sub> 为例，从上图的右图第 v<sub>8</sub> 列，P[0][8] &#x3D; 1，得到要经过顶点 v<sub>1</sub>，然后将 1 取代 0 得到 P[1][8] &#x3D; 2，说明要经过 v<sub>2</sub>，然后将 2 取代 1 得到 P[2][8] &#x3D; 4，说明要经过 v<sub>4</sub>，然后将 4 取代 2 得到 P[4][8] &#x3D; 3，说明要经过 v<sub>3</sub>，……，这样很容易就推导出最终的最短路径值为 v<sub>0</sub> → v<sub>1</sub> → v<sub>2</sub> → v<sub>4</sub> → v<sub>3</sub> → v<sub>6</sub> → v<sub>7</sub> → v<sub>8</sub>。</p>
<p>求最短路径的显示代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(v = <span class="number">0</span>;v &lt; G.numVertexes; ++v) &#123;</span><br><span class="line">  <span class="keyword">for</span>(w = v + <span class="number">1</span>; w &lt; G.numVertexes; w++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;v%d-v%d weight: %d &quot;</span>, v, w, D[v][w]);</span><br><span class="line">    k = P[v][w];					<span class="comment">// 获得第一个路径顶点下标</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; path: %d&quot;</span>, v);			<span class="comment">// 打印源点</span></span><br><span class="line">    <span class="keyword">while</span>(k != w) &#123;					<span class="comment">// 如果路径顶点下标不是终点</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot; -&gt; %d&quot;</span>, k);			<span class="comment">// 打印路径顶点</span></span><br><span class="line">      k = P[k][w];					<span class="comment">// 获得下一个路径顶点下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; -&gt; %d\n&quot;</span>, w);			<span class="comment">// 打印终点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果面临需要求所有顶点致所有顶点的最短路径问题时，弗洛伊德 (Floyd) 算法应该是不错的选择。</p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><h4 id="拓扑排序介绍"><a href="#拓扑排序介绍" class="headerlink" title="拓扑排序介绍"></a>拓扑排序介绍</h4><p>**在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为 AOV 网 (Activity On Vertex Network)**。AOV 网中的弧表示活动之间存在的某种制约关系。另外就是 AOV 网中不能存在回路。</p>
<p><strong>设 G &#x3D; (V, E) 是一个具有 n 个顶点的有向图，V 中的顶点序列 v<sub>1</sub>，v<sub>2</sub>，……，v<sub>n</sub>，满足若从顶点 v<sub>i</sub> 到 v<sub>j</sub> 有一条路径，则在顶点序列中顶点 v<sub>i</sub> 必在顶点 v<sub>j</sub> 之前。则称这样的顶点序列为一个拓扑序列</strong>。</p>
<p>所谓<strong>拓扑排序，其实就是对一个有向图构造拓扑序列的过程</strong>。构造时会有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环 (回路) 的 AOV 网；如果输出顶点数少了，哪怕是少了一个，也说明这个网存在环 (回路)，不是 AOV 网。</p>
<p>一个不存在回路的 AOV 网，可以将它应用在各种各样的工程或项目的流程图中，满足各种应用场景的需要，所以实现拓扑排序的算法就很有价值了。</p>
<h4 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h4><p>对 AOV 网进行拓扑排序的基本思路是：从 AOV 网中选择一个入度为。的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者 AOV 网中不存在入度为 0 的顶点为止。</p>
<p>首先我们需要确定一下这个图需要使用的数据结构。前面求最小生成树和最短路径时，我们用的都是邻接矩阵，但由于拓扑排序的过程中，需要删除顶点，显然用邻接表会更加方便。因此我们需要为 A0V 网建立一个邻接表。考虑到算法过程中始终要查找入度为 0 的顶点，我们在原来顶点表结点结构中，增加一个入度域 in，结构如下表所示，其中 in 就是入度的数字。</p>
<table>
<thead>
<tr>
<th align="center">in</th>
<th align="center">data</th>
<th align="center">firstedge</th>
</tr>
</thead>
</table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-1.png" alt="拓扑排序"></p>
<p>因此对于上图的 AOV 网，可以得到下图的邻接表数据结构。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-2.png" alt="拓扑排序"></p>
<p>在拓扑排序算法中，涉及的结构代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span>			<span class="comment">// 边表结点</span></span><br><span class="line">  <span class="type">int</span> adjvex;						<span class="comment">// 邻接点域，存储该顶点对应的下标</span></span><br><span class="line">  <span class="type">int</span> weight;						<span class="comment">// 用于存储权值，对于非网图可以不需要</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span>			<span class="comment">// 链域，指向下一个邻接点</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> &#123;</span>			<span class="comment">// 顶点表结点</span></span><br><span class="line">  <span class="type">int</span> in;							<span class="comment">// 顶点入度</span></span><br><span class="line">  <span class="type">int</span> data;							<span class="comment">// 顶点域，存储顶点信息</span></span><br><span class="line">  EdgeNode *firstedge;				<span class="comment">// 边表头指针</span></span><br><span class="line">&#125;VertexNode, AdjList[MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  AdjList adjList;</span><br><span class="line">  <span class="type">int</span> numVertexes, numEdges;		<span class="comment">// 图中当前顶点数和边数</span></span><br><span class="line">&#125;graphAdjList, *GraphAdjList;</span><br></pre></td></tr></table></figure>

<p>在算法中，还需要辅助的数据结构——栈，用来存储处理过程中入度为 0 的顶点，木的是为了避免每个查找时都要去遍历顶点表找有没有入度为 0 的顶点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序，若 GL 无回路，则输出拓扑排序序列并返回 OK，若有回路返回 ERROR</span></span><br><span class="line">Status <span class="title function_">TopologicalSort</span><span class="params">(GraphAdjList GL)</span> &#123;</span><br><span class="line">  EdgeNode *e;</span><br><span class="line">  <span class="type">int</span> i, k, gettop;</span><br><span class="line">  <span class="type">int</span> top = <span class="number">0</span>;																<span class="comment">// 用于栈指针下标</span></span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;															<span class="comment">// 用于统计输出顶点的个数</span></span><br><span class="line">  <span class="type">int</span> *<span class="built_in">stack</span>;																<span class="comment">// 建栈存储入度为 0 的顶点</span></span><br><span class="line">  <span class="built_in">stack</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(GL -&gt; numVertexes * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL -&gt; numVertexes; i++)</span><br><span class="line">    <span class="keyword">if</span>(GL -&gt; adjList[i].in == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">stack</span>[++top] = i;														<span class="comment">// 将入度为 0 的顶点入栈</span></span><br><span class="line">  <span class="keyword">while</span>(top != <span class="number">0</span>) &#123;</span><br><span class="line">    gettop = <span class="built_in">stack</span>[top--];													<span class="comment">// 出栈</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, GL -&gt; adjList[gettop].data);							<span class="comment">// 打印此顶点</span></span><br><span class="line">    count++;																<span class="comment">// 统计输出顶点数</span></span><br><span class="line">    <span class="keyword">for</span>(e = GL -&gt; adjList[gettop].firstedge; e; e = e -&gt; next) &#123;			<span class="comment">// 对此顶点弧表遍历</span></span><br><span class="line">      k = e -&gt; adjvex;</span><br><span class="line">      <span class="keyword">if</span>(!(--GL -&gt; adjList[k].in))											<span class="comment">// 将 k 号顶点邻接点的入度减 1</span></span><br><span class="line">        <span class="built_in">stack</span>[++top] = k;													<span class="comment">// 若为 0 则入栈，以便于下次循环输出</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(count &lt; GL -&gt; numVertexes)												<span class="comment">// 如果 count 小于顶点数，说明存在环</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>程序开始运行，第 3～7 行都是变量的定义，其中 stack 是一个栈，用来存储整型的数字。</p>
</li>
<li><p>第 8～10 行，作了一个循环判断，把入度为 0 的顶点下标都入栈，如下右图邻接表可知，此时 stack 应该为：{0, 1, 3}，即 v<sub>0</sub>、v<sub>1</sub>、v<sub>3</sub> 的顶点入度为 0，如下图。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-3.png" alt="拓扑排序"></p>
</li>
<li><p>第 12～21 行，while 循环，当栈中有数据元素时，始终循环。</p>
</li>
<li><p>第 13～15 行，v<sub>3</sub> 出栈得到 gettop &#x3D; 3。并打印此顶点，然后 count 加 1。</p>
</li>
<li><p>第 16～20 行，循环其实是对 v<sub>3</sub> 顶点对应的弧链表进行遍历，即下图中的灰色部分，找到 v<sub>3</sub> 连结的两个顶点 v<sub>2</sub> 和 v<sub>13</sub>，并将它们的入度减少一位，此时 v<sub>2</sub> 和 v<sub>13</sub> 的 in 值都为 1。它的目的是为了将 v<sub>3</sub> 顶点上的弧删除。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-4.png" alt="拓扑排序"></p>
</li>
<li><p>再次循环，第 12～21 行。此时处理的是顶点 v<sub>1</sub>。经过出栈、打印、count &#x3D; 2 后，我们对 v<sub>1</sub> 到 v<sub>2</sub>、v<sub>4</sub>、v<sub>8</sub> 的弧进行了遍历。并同样减少了它们的入度数，此时， v<sub>2</sub> 入度为 0，于是由第 18～19 行知，v<sub>2</sub> 入栈，如下图所示。试想，如果没有在顶点表中加入 in 这个入度数据域，18 行的判断就必须要是循环，这显然是要消耗时间的，利用空间换取了时间。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-5.png" alt="拓扑排序"></p>
</li>
<li><p>接下来就是同样的处理方式了。下图展示了 v<sub>2</sub>、v<sub>6</sub>、v<sub>5</sub>、v<sub>8</sub> 的打印删除过程，后面还剩几个顶点都类似。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-6.png" alt="拓扑排序">   <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-7.png" alt="拓扑排序"></p>
</li>
<li><p>最终拓扑排序打印结果为 3 -&gt; 1 -&gt; 2 -&gt; 6-&gt; 0 -&gt; 4 -&gt; 5 -&gt; 8 -&gt; 7 -&gt; 12 -&gt; 9 -&gt; 10 -&gt; 13 -&gt; 11。当然这结果并不是唯一的一种拓扑排序方案。</p>
</li>
</ol>
<p>分析整个算法，对一个具有 n 个顶点 e 条弧的 AOV 网来说，第 8～10 行扫描顶点表，将入度为 0 的顶点入栈的时间复杂度为 O(n)，而之后的 while 循环中，每个顶点进一次栈，出一次栈，入度减 1 的操作共执行了 e 次，所以整个算法的时间复杂度为 O(n + e)。</p>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>**在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，称之为 AOE 网 (Acticity On Edge Network)**。把 AOE 网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点。由于一个工程，总有一个开始，一个结束，所以正常情况下，AOE 网只有一个源点一个汇点。</p>
<p>AOE 网时表示工程流程的，所以它就具有明显的工程的特性。如有在某顶点所代表的事件发生后，从该顶点出发的各活动才能开始。只有在进入某点的各活动都已结束，该顶点代表的事件才能发生。</p>
<p>尽管 AOE 网与 AOV 网都是用来对工程建模的，但他们还是有很大的不同，主要体现在 AOV 网是顶点表示活动的网，他只描述活动之际拿的制约关系，而 AOE 网是用边表示活动的网，边上的权值表示活动持续的时间。</p>
<p><strong>路径上各个活动所持续的时间之河称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动</strong>。</p>
<h4 id="关键路径算法原理"><a href="#关键路径算法原理" class="headerlink" title="关键路径算法原理"></a>关键路径算法原理</h4><p>定义如下几个参数：</p>
<ol>
<li>时间的最早发生时间 etv (earliest time of vertex)：即顶点 v<sub>k</sub> 的最早发生时间。</li>
<li>时间的最晚发生时间 ltv (latest time of vertex)：即顶点 v<sub>k</sub> 的最晚发生时间。也就是每个顶点对应的事件最晚需要开始的时间，超出此事件将会延误整个工期。</li>
<li>活动的最早开工时间 ete (earliest time of edge)：即弧 a<sub>k</sub> 的最早发生时间。</li>
<li>活动的最晚开工时间 lte (latest time of edge)：即弧 a<sub>k</sub> 的最晚发生时间，也就是不推迟工期的最晚开工时间。</li>
</ol>
<p>由 1 和 2 可以求得 3 和 4，然后再根据 ete[k] 是否与 lte[k] 相等来判断 a<sub>k</sub> 是否是关键活动。</p>
<h4 id="关键路径算法"><a href="#关键路径算法" class="headerlink" title="关键路径算法"></a>关键路径算法</h4><p>将下图的 AOE 网转化为邻接表结构，注意与拓扑排序时邻接表结构不同的地方在于，这里弧链表增加了 weight 域，用来存储弧的权值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-1.png" alt="关键路径算法"></p>
<p>求事件的最早发生时间 etv 的过程，就是从头至尾找拓扑序列的过程，因此，在求关键路径之前，需要先调用一次拓扑序列算法的代码来计算 etv 和拓扑序列列表。为此，在程序开始处声明几个全局变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *etv, *ltv;				<span class="comment">// 事件最早发生时间和最迟发生时间数组</span></span><br><span class="line"><span class="type">int</span> *stack2;				<span class="comment">// 用于存储拓扑序列的栈</span></span><br><span class="line"><span class="type">int</span> top2;					<span class="comment">// 用于 stack2 的指针</span></span><br></pre></td></tr></table></figure>

<p>其中 stack2 用来存储拓扑序列，以便后面求关键路径时使用。</p>
<p>改进过的求拓扑序列算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序，用于关键路径计算</span></span><br><span class="line">Status <span class="title function_">TopologicalSort</span><span class="params">(GraphAdjList GL)</span> &#123;</span><br><span class="line">  EdgeNode *e;</span><br><span class="line">  <span class="type">int</span> i, k, gettop;</span><br><span class="line">  <span class="type">int</span> top = <span class="number">0</span>;												<span class="comment">// 用于栈指针下标</span></span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;											<span class="comment">// 用于统计输出顶点的个数</span></span><br><span class="line">  <span class="type">int</span> *<span class="built_in">stack</span>;												<span class="comment">// 建栈将入度为 0 的顶点入栈</span></span><br><span class="line">  <span class="built_in">stack</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(GL -&gt; numVertexes * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL -&gt; adjList[i].in)</span><br><span class="line">    <span class="built_in">stack</span>[++top] = i;</span><br><span class="line">  top2 = <span class="number">0</span>;													<span class="comment">// 初始化为 0</span></span><br><span class="line">  etv = (<span class="type">int</span> *)<span class="built_in">malloc</span>(GL -&gt; numVertexes * <span class="keyword">sizeof</span>(<span class="type">int</span>));		<span class="comment">// 事件最早发生时间</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; GL -&gt; numVertexes; i++)</span><br><span class="line">    etv[i] = <span class="number">0</span>;												<span class="comment">// 初始化为 0</span></span><br><span class="line">  stack2 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(GL -&gt; numVertexes * <span class="keyword">sizeof</span>(<span class="type">int</span>));	<span class="comment">// 初始化</span></span><br><span class="line">  <span class="keyword">while</span>(top != <span class="number">0</span>) &#123;</span><br><span class="line">    gettop = <span class="built_in">stack</span>[top--];</span><br><span class="line">    count++;</span><br><span class="line">    stack2[++top2] = gettop;								<span class="comment">// 将弹出的顶点序号压入拓扑序列的栈</span></span><br><span class="line">    <span class="keyword">for</span>(e = GL -&gt; adkList[gettop].firstedge; e; e = e -&gt; next) &#123;</span><br><span class="line">      k = e -&gt; adjvex;</span><br><span class="line">      <span class="keyword">if</span>(!(--GL -&gt; adjList[k].in))</span><br><span class="line">        <span class="built_in">stack</span>[++top] = k;</span><br><span class="line">      <span class="keyword">if</span>((etv[gettop] + e -&gt; weigth) &gt; etv[k])				<span class="comment">// 求各顶点事件最早发生时间值</span></span><br><span class="line">        etv[k] = etv[gettop] + e -&gt; weight;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(count &lt; GL -&gt; numVertexes)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 10～14 行为初始化全局变量 etv 数组、top2 和 stack2 的过程。第 19 行就是将本是要输出的拓扑序列压入全局栈 stack2 中。第 24～25 行很关键，它是求 etv 数组的每一个元素的值。比如，加入已经求得顶点 v<sub>0</sub> 对应的 etv[0] &#x3D; 0，顶点 v<sub>1</sub> 对应的 etv[1] &#x3D; 3，顶点 v<sub>2</sub> 对应的 etv[2] &#x3D; 4，现在我们需要求顶点 v<sub>3</sub> 对应的 etv[3]，其实就是求 etv[1] + len&lt;v<sub>1</sub>, v<sub>3</sub>&gt; 与 etv[2] + len&lt;v<sub>2</sub>, v<sub>3</sub>&gt; 的较大值。显然 3 + 5 &lt; 4 +8，得到 etv[3] &#x3D; 12，如下图。在代码中 e -&gt; weight 就是当前弧的长度。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-2.png" alt="关键路径算法"></p>
<p>由此得出计算顶点 v<sub>k</sub> 即求 etv[k] 的最早发生时间的公式是：</p>
<p>etc[k] &#x3D; 0, 当 k &#x3D; 0 时；</p>
<p>etc[k] &#x3D; max{etc[i] + len&lt;v<sub>i</sub>, v<sub>k</sub>&gt;}，当 k ≠ 0 且 &lt;v<sub>i</sub>, v<sub>k</sub>&gt; ∈ P[k] 时</p>
<p>其中 P[K] 表示所有到达顶点 v<sub>k</sub> 的弧的集合。</p>
<p>求关键路径的算法代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求关键路径，GL 为有向图，输出 GL 的各项关键活动</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CriticalPath</span><span class="params">(GraphAdjList GL)</span> &#123;</span><br><span class="line">  EdgeNode *e;</span><br><span class="line">  <span class="type">int</span> i, gettop, k, j;</span><br><span class="line">  <span class="type">int</span> ete, lte;													<span class="comment">// 声明活动最早发生时间和最迟发生时间变量</span></span><br><span class="line">  TopologicalSort(GL);											<span class="comment">// 求拓扑序列，计算数组 etv 和 stack2 的值</span></span><br><span class="line">  ltv = (<span class="type">int</span> *)<span class="built_in">malloc</span>(GL -&gt; numVertexes * <span class="keyword">sizeof</span>(<span class="type">int</span>));			<span class="comment">// 事件最晚发生时间</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Gl -&gt; numVertexes; i++)</span><br><span class="line">    ltv[i] = tev[GL -&gt; numVertexes - <span class="number">1</span>];						<span class="comment">// 初始化 ltv</span></span><br><span class="line">  <span class="keyword">while</span>(top2 != <span class="number">0</span>) &#123;											<span class="comment">// 计算 ltv</span></span><br><span class="line">    gettop = stack2[top2--];									<span class="comment">// 将拓扑序列出栈，后进先出</span></span><br><span class="line">    <span class="keyword">for</span>(e = GL -&gt; adjList[gettop].firstedge; e; e = e -&gt; next) &#123; <span class="comment">// 求各顶点事件的最迟发生时间 ltv 值</span></span><br><span class="line">      k = e -&gt; adjvex;</span><br><span class="line">      <span class="keyword">if</span>(ltv[k] - e -&gt; weight &lt; ltv[gettop])					<span class="comment">// 求各顶点事件最晚发生时间 ltv</span></span><br><span class="line">        ltv[gettop] = ltv[k] - e -&gt; weight;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; Gl -&gt; numVertexes; j++) &#123;						<span class="comment">// 求 ete，lte 和关键活动</span></span><br><span class="line">    <span class="keyword">for</span>(e = GL -&gt; adjList[j].firstedge; e; e = e -&gt; next) &#123;</span><br><span class="line">      k = e -&gt; adjvex;</span><br><span class="line">      ete = etv[j];												<span class="comment">// 活动最早发生时间</span></span><br><span class="line">      lte = ltv[k] - e -&gt; weight;								<span class="comment">// 活动最迟发生时间</span></span><br><span class="line">      <span class="keyword">if</span>(ete == lte)											<span class="comment">// 两者相等即在关键路径上</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;v%d, v%d&gt; length: %d , &quot;</span>, GL - adjList[j].data, GL -&gt; adjList[k].data, e -&gt; weight);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>程序开始执行。第 5 行 声明了 ete 和 lte 两个活动最早最晚发生时间变量。</p>
</li>
<li><p>第 6 行，调用求拓扑序列的函数。执行完毕后，全局变量数组 etv 和 栈 stack 的值如下图所示，top2 &#x3D; 10。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-3.png" alt="关键路径算法"></p>
</li>
<li><p>第 7～9 行为初始化全局变量 ltv 数组，因为 etv[9] &#x3D; 27，所以数组 ltv 当前的值为：{27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27}</p>
</li>
<li><p>∈第 10～17 行为 ltv 的循环。第 11 行，先讲 stack2 的栈头出栈，由后进先出得到 gettop &#x3D; 9。根据邻接表中，v<sub>9</sub> 没有弧表，所以 12～16 行循环体未执行。</p>
</li>
<li><p>再次来到 11 行，gettop &#x3D; 8，在第 12～16 行的循环中，v<sub>8</sub> 的弧表只有一条 &lt;v<sub>8</sub>, v<sub>9</sub>&gt;，第 13 行得到 k &#x3D; 9，因为 ltv[9] - 3 &lt; ltv[8]，所以 ltv[8] &#x3D; ltv[9] - 3 &#x3D; 24，如下图。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-4.png" alt="关键路径算法"></p>
</li>
<li><p>再次循环，当 gettop &#x3D; 7、5、6 时，同理可算出 ltv 相对应的值为19、25、13，此时 ltv 值为：{27, 27, 27, 27, 27, 13, 25, 19, 24, 27}</p>
</li>
<li><p>当 gettop &#x3D; 4 时，由邻接表可得到 v<sub>4</sub> 有两条弧 &lt;v<sub>4</sub>, v<sub>6</sub>&gt;、&lt;v<sub>4</sub>, v<sub>7</sub>&gt;，通过第 12～16 行的循环，可以得到 ltv[4] &#x3D; min(ltv[7] - 4, ltv[6] - 9) &#x3D; min(19 - 4, 25 - 9) &#x3D; 15，如下图所示。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-5.png" alt="关键路径算法"></p>
<p> 得出计算顶点 v<sub>k</sub> 即求 ltv[k] 的最晚发生的公式是：</p>
<p> ltv[k] &#x3D; etc[k]，当 k &#x3D; n - 1；</p>
<p> ltv[k] &#x3D; min{ltv[j] + len &lt; &lt;v<sub>k</sub>, v<sub>j</sub>&gt;}，当 k &lt; n - 1 且 &lt;v<sub>k</sub>, v<sub>j</sub>&gt; ∈ S[k] 时</p>
<p> 其中 S[K] 表示所有从顶点 v<sub>k</sub> 出发的弧的集合。</p>
</li>
<li><p>第 18～26 行是来求另两个变量活动最早开始事件 ete 和活动最晚开始事件 lte，并对相同下标的它们做比较。两重循环嵌套是对邻接表的顶点和每个顶点的弧表遍历。</p>
</li>
<li><p>当 j &#x3D; 0，从 v<sub>0</sub> 点开始，有 &lt;v<sub>0</sub>, v<sub>2</sub>&gt; 和 &lt;v<sub>0</sub>, v<sub>1</sub>&gt; 两条弧。当 k &#x3D; 2 时，ete &#x3D; etv[j] &#x3D; etv[0] &#x3D; 0。lte &#x3D; ltv[k] - e -&gt; weight &#x3D; ltv[2] -len &lt;v<sub>0</sub>, v<sub>2</sub>&gt; &#x3D; 4 - 4 &#x3D; 0，此时 ete &#x3D; lte，表示弧 &lt;v<sub>0</sub>, v<sub>2</sub>&gt; 是关键活动，因此打印。当 k &#x3D; 1时，ete &#x3D; etv[j] &#x3D; etv[0] &#x3D; 0。lte &#x3D; liv[k] -e -&gt; weight &#x3D; ltv[1] -len&lt;v<sub>0</sub>, v<sub>1</sub>&gt; &#x3D; 7 - 3 &#x3D; 4，此时 ete ≠ lte，因此 &lt;v<sub>0</sub>, v<sub>1</sub>&gt; 并不是关键活动，如下图。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-6.png" alt="关键路径算法"></p>
</li>
<li><p>j &#x3D; 1 一直到 j &#x3D; 9 为止，做法是完全相同的，关键路径打印结果为 “&lt;v<sub>0</sub>, v<sub>2</sub>&gt; 4，&lt;v<sub>2</sub>, v<sub>3</sub>&gt; 8， &lt;v<sub>3</sub>, v<sub>4</sub>&gt; 3，&lt;v<sub>4</sub>, v<sub>7</sub>&gt; 4，&lt;v<sub>7</sub>, v<sub>8</sub>&gt; 5， &lt;v<sub>8</sub>, v<sub>9</sub>&gt; 3，”，最终关键路径如下图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-7.png" alt="关键路径算法"></p>
</li>
</ol>
<p>分析整个求关键路径的算法，第 6 行诗 拓扑排序，时间复杂度为 O(n + e)，第 8～9 行时间复杂度为 O(n) ，第 10～17 行时间复杂度为 O(n + e)，第 18～ 26 行时间复杂度也为 O(n + e)，最终求关键路径算法的时间复杂度依然是 O(n + e)。</p>
<h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>图的存储结构一种阐述了 五种，其中比较重要的是邻接矩阵和邻接表，它们分别代表着边集是用数组还是链表的方式存储。十字链表是邻接矩阵的一种升级，而邻接多重表则是邻接表的升级。边集数组更多考虑的是对边的关注。用什么存储结构需要具体问题具体分析，通常稠密图，或读存数据较多，结构修改较少的图，用邻接矩阵要更合适，反之则应该考虑邻接表。</p>
<p>图的遍历分为深度和广度两种，各有优缺点。图的三种应用：最小生成树、最短路径和有向无环图的应用。</p>
<p>最小生成树，两种算法：普里姆 (Prim) 算法和克鲁斯卡尔 (Kruskal) 算法。普里姆算法像是走一步看一步的思维方式，逐步生成最小生成树。而克鲁斯卡尔算法则更有全局意识，直接从图中最短权值的边入手，找寻最后的答案。</p>
<p>最短路径的显示应用非常多。迪杰斯特拉 (Dijkstra) 算法更强调单源顶点查找路径的方式，比较符合我们正常的思路，容易理解原理，但算法代码相对复杂。而弗洛伊德 (Floyd) 算法则完全抛开了单点的局限思维方式，巧妙地应用矩阵的变换，用最清爽的代码实现了多顶点间最短路径求解的方案，原理理解有难度，但算法编写很简洁。</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="查找概论"><a href="#查找概论" class="headerlink" title="查找概论"></a>查找概论</h3><p><strong>查找表 (Search Table) 是由同一类型的数据元素 (或记录) 构成的集合。关键字 (Key) 是数据元素中某个数据项的值</strong>，又称为键值，用它可以标识一个数据元素。也可以标识一个记录的某个数据项 (字段)，称为关键码。**若此关键字可以唯一地标识一个记录，则称此关键字为主关键字 (Primary Key)<strong>。注意这也意味着，对不同的记录，其主关键字均不相同。主关键字所在的数据项称为主关键码。</strong>对于那些可以识别多个数据元素 (或记录) 的关键字，称为次关键字 (Secondary Key)。次关键字也可以理解为是不以唯一标识一个数据元素或记录的关键字，它对应的数据项就是次关键码。</p>
<blockquote>
<p>查找 (Searching) 就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素 (或记录)。</p>
</blockquote>
<p>查找表按照操作方式来分有两大种：静态查找表和动态查找表。<br><strong>静态查找表 (Static Search Table)：只作查找操作的查找表</strong>。它的主要操作有：</p>
<ol>
<li>查询某个“特定的”数据元素是否在查找表中。</li>
<li>检索某个“特定的”数据元素和各种属性。</li>
</ol>
<p><strong>动态查找表 (Dynamic Search Table)：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素</strong>。显然动态查找表的操作就是两个：</p>
<ol>
<li>查找时插入数据元素。</li>
<li>查找时删除数据元素。</li>
</ol>
<h3 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h3><p><strong>顺序查找 (Sequential Search) 又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个或最后一个记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果知道最后一个或第一个记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功</strong>。</p>
<h4 id="顺序表查找算法"><a href="#顺序表查找算法" class="headerlink" title="顺序表查找算法"></a>顺序表查找算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序查找，a 为数组，n 为要查找的数组个数，key 为要查找的关键字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sequential_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i] == key)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码非常简单，就是在数组 a (注意元素值从下标 1 开始) 中查看有没有关键字 (key)，当需要查找复杂表结构的记录时，只需要把数组 a 与关键字 key 定义成需要的表结构和数据类型即可。</p>
<h4 id="顺序表查找优化"><a href="#顺序表查找优化" class="headerlink" title="顺序表查找优化"></a>顺序表查找优化</h4><p>到这里并非足够完美，因为每次循环时都需要对 i 是否越界，即是否小于等于 n 做判断。事实上，还可以有更好一点的办法，设置一个哨兵，可以解决不需要每次让 i 与 n 做比较。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有哨兵顺序查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sequential_Search2</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  a[<span class="number">0</span>] = key;		<span class="comment">// 设置 a[0] 为关键字值，称之为哨兵</span></span><br><span class="line">  i = n;			<span class="comment">// 循环从数组尾部开始</span></span><br><span class="line">  <span class="keyword">while</span>(a[i] != key) &#123;</span><br><span class="line">    i--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;			<span class="comment">// 返回 0 则说明查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时代码是从尾部开始查找，由于 a[0] &#x3D; key，也就是说，如果在 a[i] 中有 key 则返回 i 值，查找成功。否则一定在最终的 a[0] 处等于 key，此时返回的是 0，即说明 a[1]~a[n] 中没有关键字 key，查找失败。</p>
<p>这种在查找方向的尽头放置哨兵面去了在查找过程中每一次比较后都要判断查找位置是否越界的小技巧，看似与原先差别不大，但在总数据较多时，效率提高很大，是非常好的编码技巧。当然，哨兵也不一定就一定要在数组开始，也可以在末端。</p>
<p>对于这种顺序查找算法来说，查找成功最好的情况就是在第一个位置就找到了，算法时间复杂度为 O(1)，最坏的情况是在最后一位置才找到，需要 n 次比较，时间复杂度为 O(n)，当查找不成功时，需要 n+1 次比较，时间复杂度为 O(n)。所以最终的时间复杂度还是 O(n)。</p>
<p>很显然，顺序查找技术是有很大缺点的，n 很大时，查找效率极为低下，不过优点也是有的，这个算法非常简单，对静态查找表的记录没有任何要求，在一些小型数据的查找时，是可以适用的。另外，也正由于查找概率的不同，完全可以将容易查找到的记录放在前面，而不常用的记录放置在后面，效率就可以有大幅提高。</p>
<h3 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h3><h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><p><strong>折半查找 (Binary Search) 技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序 (通常从小到大有序)，线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止</strong>。</p>
<p>假如在一个有序表数组 {0, 1, 16, 24, 35, 47, 59, 62, 73, 88, 99} 中查找是否存在 62 这个数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 折半查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> low, high, mid;</span><br><span class="line">  low = <span class="number">1</span>;							<span class="comment">// 定义最低下标为记录首位</span></span><br><span class="line">  high = n;							<span class="comment">// 定义最高下标为记录末位</span></span><br><span class="line">  <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">    mid = (low + high) / <span class="number">2</span>;			<span class="comment">// 折半</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; a[mid])				<span class="comment">// 若查找值比中值小</span></span><br><span class="line">      high = mid - <span class="number">1</span>;				<span class="comment">// 最高下标调整到中位下标小一位</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; a[mid])			<span class="comment">// 若查找值比中值大</span></span><br><span class="line">      low = mid + <span class="number">1</span>;				<span class="comment">// 最低下标调整到中位下标大一位</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> mid;					<span class="comment">// 若相等则说明 mid 即为查找到的位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>折半查找算法的时间复杂度为 O(logn)，它显然远远好于顺序查找的 O(n) 时间复杂度了。</p>
<h4 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h4><p>**插值查找 (Interpolation Search) 是根据要查找的关键字 key 与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式 <code>(key - a[low])/(a[high] - a[low])</code>**。只需要将查办查找算法代码中第 7 行更改成以下就可以了<code>mid = low + (high -low) * (key - a[low]) / (a[high] - a[low]);</code>。应该说，从时间复杂度来看，他也是 O(logn)，但对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多。</p>
<h4 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h4><p>斐波那契查找 (Fibonacci Search) 利用了黄金分割原理来实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契数列</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fibonacci_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> low, high, mid, i, k;</span><br><span class="line">  low = <span class="number">1</span>;								<span class="comment">// 定义最低下标为记录首位</span></span><br><span class="line">  high = n;								<span class="comment">// 定义最高下标为记录末位</span></span><br><span class="line">  k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n &gt; F[k] - <span class="number">1</span>)					<span class="comment">// 计算 n 位于斐波那契数列的位置</span></span><br><span class="line">    k++;</span><br><span class="line">  <span class="keyword">for</span>(i = n; i &lt; F[k] - <span class="number">1</span>; i++)			<span class="comment">// 将不满的数值补全</span></span><br><span class="line">    a[i] = a[n];</span><br><span class="line">  <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">    mid = low + F[k - <span class="number">1</span>] - <span class="number">1</span>;			<span class="comment">// 计算当前分割的下标</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; a[mid]) &#123;					<span class="comment">// 若查找记录小于当前分割记录</span></span><br><span class="line">      high = mid <span class="number">-1</span>;					<span class="comment">// 最高下标调整到分割下标 mid - 1 处</span></span><br><span class="line">      k = k - <span class="number">1</span>;						<span class="comment">// 斐波那契数列下标减一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; a[mid]) &#123;				<span class="comment">// 若查找记录大于当前分割记录</span></span><br><span class="line">      low = mid + <span class="number">1</span>;					<span class="comment">// 最低下标调整到分割下标 mid + 1 处</span></span><br><span class="line">      k = k - <span class="number">2</span>;						<span class="comment">// 斐波那契数列下标减两位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(mid &lt;= n)</span><br><span class="line">        <span class="keyword">return</span> mid;						<span class="comment">// 若相等则说明 mid 即为查找到的位置</span></span><br><span class="line">      <span class="keyword">else</span>		</span><br><span class="line">        <span class="keyword">return</span> n;						<span class="comment">// 若 mid &gt; n 说明是补全数值，返回 n</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>斐波那契查找算法的核心在于：</p>
<ol>
<li>当 key &#x3D; a[mid] 时，查找就成功；</li>
<li>当 key &lt; a[mid] 时，新范围是第 low 个到 mid - 1 个，此时范围个数为 F[k - 1] - 1 个；</li>
<li>当 key &gt; a[mid] 时，新范围是第 m + 1 个到第 high 个，此时范围个数为 F[k - 2] - 1个。</li>
</ol>
<p>也就是说，如果要查找的记录在右侧，则左侧的数据都不用再判断了，不断反复进行下去，对处于当中的大部分数据，其工作效率要高一些。所以尽管斐波那契查找的时间复杂也为 O(logn)，但就平均性能来说，斐波那契查找要优于折半查找。可惜如果是最坏情况，比如这里 key &#x3D; 1，那么始终都处于左侧长半区在查找，则查找效率要低于折半查找。</p>
<p>还有比较关键的一点，折半查找是进行加法于除法运算 (mid &#x3D; (low + high) &#x2F; 2)，插值查找进行复杂的四则运算 (mid &#x3D; low + (high - low) * (key - a[low]) &#x2F; (a[high] - a[low]))，而斐波那契查找只是最简单加减法运算 (mid &#x3D; low + F[k - 1] - 1)，在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率。</p>
<h3 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h3><p>以上几种比较高效的查找方法都是基于有序的基础之上的，但事实上，很多数据集可以增长非常快，如果要保证记录全部是按照当中某个关键字有序，其时间代价是非常昂贵的，所以这种数据通常都是按先后顺序存储。</p>
<p>数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构。<strong>索引就是把一个关键字与它对应的记录相关联的过程</strong>，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。</p>
<p>索引按照结构可以分为线性索引、树形索引和多级索引。<strong>所谓线性索引就是将索引项集合组织为线性结构，也称为索引表</strong>。</p>
<h4 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h4><p><strong>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项</strong>，如下图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E7%A8%A0%E5%AF%86%E7%B4%A2%E5%BC%95.png" alt="稠密索引"></p>
<p><strong>对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列</strong>。</p>
<p>索引项有序也就意味着，要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高了效率。这显然是稠密索引有点，但是如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说，可能就需要反复去访问磁盘，查找性能反而大大下降了。</p>
<h4 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h4><p><strong>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件</strong>：</p>
<ul>
<li><strong>块内无序</strong>，即每一块内的记录不要求有序。当然，如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间的代价，因此通常不要求块内有序。</li>
<li><strong>块间有序</strong>，例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字……因为只有块间有序，才有可能在查找时带来效率。</li>
</ul>
<p>对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。如下图。定义的分块索引结构分三个数据项：</p>
<ul>
<li>最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块的关键字要大；</li>
<li>存储了块中的记录个数，以便于循环时使用；</li>
<li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%88%86%E5%9D%97%E7%B4%A2%E5%BC%95.png" alt="分块索引"></p>
<p>在分块索引表查找，就是分两步进行：</p>
<ol>
<li>在分块索引表中查找要查关键字所在的块。由于分块索引表是块间有序的，因此很容易利用折半、插值等算法得到结果。</li>
<li>根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查找。</li>
</ol>
<p>分析一下分块索引的平均查找长度。设 n 个记录的数据集被平均分成 m 块，每个块中有 t 条记录，显然 n &#x3D; m * t，或者说 m &#x3D; n &#x2F; t。再假设 L<sub>b</sub> 为查找索引表的平均查找长度，因最好于最差的等概率原则，所以 L<sub>b</sub> 的平均长度为 (m + 1) &#x2F; 2。L<sub>w</sub> 为块中查找记录的平均查找长度，同理可知它的平均查找长度为 (t + 1) &#x2F; 2。</p>
<p>这样分块索引查找的平均查找长度为：</p>
<p>ASL<sub>w</sub> &#x3D; L<sub>b</sub> + L<sub>w</sub> &#x3D; (m + 1) &#x2F; 2 + (t + 1) &#x2F; 2 &#x3D; 1 &#x2F; 2(m + t) + 1 &#x3D; 1 &#x2F; 2(n &#x2F; t + t) + 1</p>
<p>注意上面这个式子的推导是为了让整个分块索引查找长度依赖 n 和 t 两个变量。从这里我们也就得到，平均长度不仅仅取决于数据集的总记录数 n，还和每一块的记录个数 t 相关。最佳的情况就是分的块数 m 与块中的记录数 t 相同，此时意味着 n &#x3D; m * t &#x3D; t<sup>2</sup>，即 ASL<sub>w</sub> &#x3D; 1 &#x2F; 2(n &#x2F; t + t) + 1 &#x3D; t + 1 &#x3D; √n + 1</p>
<p>可见，分块索引的效率比之顺序查找的 O(n) 是高了不少，不过显然它与折半查找的 O(long) 相比还有不小的差距。因此在确定所在块的过程中，由于块间有序，所以可以应用折半、插值等手段来提高效率。</p>
<p>总的来说，分块索引在兼顾了对细分块不需要有序的情况下，大大增加了整体查找的速度，所以普遍被用于数据库表查找等技术的应用当中。</p>
<h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>索引项的通用结构是：</p>
<ul>
<li>次关键码</li>
<li>记录号表</li>
</ul>
<p>**其中记录号表存储具有相同次关键字的所有记录的记录号 (可以是指向记录的指针或者是该记录的主关键字)。这样的索引方法就是倒排索引 (inverted index)**。倒排索引源于实际应用中需要根据属性或字段、次关键码的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因为称为倒排索引。</p>
<p>倒排索引的优点显然就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果。但它的缺点是这个记录号不定长。</p>
<h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p><strong>二叉排序树 (Binary Sort Tree)，又称为二叉查找树。它或者是一颗空树，或者是具有下列性质的二叉树</strong>。</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树。</li>
</ul>
<p>从二叉排序树的定义可以知道，它前提是二叉树，然后它采用了递归的定义方法，再者，它的结点间满足一定的次序关系，左子树结点一定比其双亲结点小，右子树结点一定比其双亲结点大。</p>
<p>构造一棵二叉排序树的目的，其实并不是为了排序，而是为了提高查找和插入删除关键字的速度。不管怎么说，在一个有序数据集上的查找，速度总是要快于无序的数据集的，而二叉排序树这种非线性的结构，也有利于插入和删除的实现。</p>
<h4 id="二叉排序树查找操作"><a href="#二叉排序树查找操作" class="headerlink" title="二叉排序树查找操作"></a>二叉排序树查找操作</h4><p>提供一个二叉树的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的二叉链表结点结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span>				<span class="comment">// 结点结构</span></span><br><span class="line">  <span class="type">int</span> data;								<span class="comment">// 结点数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>		<span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<p>二叉排序树的查找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归查找二叉排序树 T 中是否存在 key，指针 f 指向 T 的双亲，其初始调用值为 NULL。若查找成功，则指针 p 指向查找路径上访问的最后一个结点并返回 FALSE</span></span><br><span class="line">Status <span class="title function_">SearchBST</span><span class="params">(BiTree T, <span class="type">int</span> key, BiTree f, BiTree *p)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!T) &#123;												<span class="comment">// 查找不成功</span></span><br><span class="line">    *p = f;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(key == T -&gt; data) &#123;							<span class="comment">// 查找成功</span></span><br><span class="line">    *p = T;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T -&gt; data)</span><br><span class="line">    <span class="keyword">return</span> SearchBST(T -&gt; lchild, key, T, p);			<span class="comment">// 在左子树继续查找</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> SearchBST(T -&gt; rchild, key, T, p);			<span class="comment">// 在右子树继续查找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉排序树插入操作"><a href="#二叉排序树插入操作" class="headerlink" title="二叉排序树插入操作"></a>二叉排序树插入操作</h4><p>有了二叉排序树的查找函数，那么所谓的二叉排序树的插入，其实也就是将关键字放到树中的合适位置而已。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当二叉排序树 T 中不存在关键字等于 key 的数据元素时，插入 key 并返回 TRUE，否则返回 FALSE</span></span><br><span class="line">Status <span class="title function_">InsertBST</span><span class="params">(BiTree *T, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  BiTree p, s;</span><br><span class="line">  <span class="keyword">if</span>(!SearchBST(*T, key, <span class="literal">NULL</span>, &amp;p)) &#123;		<span class="comment">// 查找不成功</span></span><br><span class="line">    s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    s -&gt; data = key;</span><br><span class="line">    s -&gt; lchild = s -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">      *T = s;								<span class="comment">// 插入 s 为新的根结点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; p -&gt; data)</span><br><span class="line">      p -&gt; lchild = s;						<span class="comment">// 插入 s 为左孩子</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      p -&gt; rchild = s;						<span class="comment">// 插入 s 为右孩子</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;							<span class="comment">// 树中已有关键字相同的结点，不再插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了二叉排序树的插入代码，是心啊二叉排序树的构建就非常容易了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">62</span>, <span class="number">88</span>, <span class="number">58</span>, <span class="number">47</span>, <span class="number">35</span>, <span class="number">73</span>, <span class="number">51</span>, <span class="number">99</span>, <span class="number">37</span>, <span class="number">93</span>&#125;;</span><br><span class="line">BiTree T = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  InsertBST(&amp;T, a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉排序树删除操作"><a href="#二叉排序树删除操作" class="headerlink" title="二叉排序树删除操作"></a>二叉排序树删除操作</h4><p>对删除结点三种情况的分析：</p>
<ul>
<li>叶子结点；</li>
<li>仅有左或右子树的结点；</li>
<li>左右子树都有的结点。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若二叉排序树 T 中存在关键字等于 key 的数据元素时，则删除该数据元素结点，并返回 TRUE；否则返回 FALSE</span></span><br><span class="line">Status <span class="title function_">DeleteBST</span><span class="params">(BiTree *T, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!*T)							<span class="comment">// 不存在关键字等于 key 的数据元素</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(key == (*T) -&gt; data)			<span class="comment">// 找到关键字等于 key 的数据元素</span></span><br><span class="line">      <span class="keyword">return</span> Delete(T);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; (*T) -&gt; data)</span><br><span class="line">      <span class="keyword">return</span> DeleteBST(&amp;(*T) -&gt; lchild, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> DeleteBST(&amp;(*T) -&gt; rchild, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码和前面的二叉排序树查找几乎完全相同，唯一的区别在于第 7 行，此时执行的是 Delete 方法，对当前结点进行删除操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从二叉排序树中删除结点 p，并重接它的左或右子树。</span></span><br><span class="line">status <span class="title function_">Delete</span><span class="params">(BiTree *p)</span> &#123;</span><br><span class="line">  BiTree q, s;</span><br><span class="line">  <span class="keyword">if</span>((*p) -&gt; rchild == <span class="literal">NULL</span>) &#123;			<span class="comment">// 右子树空则只需重接它的左子树</span></span><br><span class="line">    q = *p; </span><br><span class="line">    *p = (*p) -&gt; lchild; </span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((*p) -&gt; lchild == <span class="literal">NULL</span>) &#123;		<span class="comment">// 只需重接它的右子树</span></span><br><span class="line">    q = *p;</span><br><span class="line">    *p = (*p) -&gt; rchild;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;								<span class="comment">// 左右子树均不空</span></span><br><span class="line">    q = *p;</span><br><span class="line">    s = (*p) -&gt; lchild;</span><br><span class="line">    <span class="keyword">while</span>(s -&gt; rchild) &#123;				<span class="comment">// 转左，然后向右到尽头 (找待删结点的前驱)</span></span><br><span class="line">      q = s;</span><br><span class="line">      s = s -&gt; rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    (*p) -&gt; data = s -&gt; data;			<span class="comment">// s 指向被删结点的直接前驱</span></span><br><span class="line">    <span class="keyword">if</span>(q != *p)</span><br><span class="line">      q -&gt; rchild = s -&gt; lchild;		<span class="comment">// 重接 q 的右子树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      q -&gt; lchild = s -&gt; lchild;		<span class="comment">// 重接 q 的左子树</span></span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> TRUE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉排序树总结"><a href="#二叉排序树总结" class="headerlink" title="二叉排序树总结"></a>二叉排序树总结</h4><p>总之，二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可。插入删除的时间性能比较好。而对于二叉排序树的查找，走的就是从根结点到要查找的结点的路径，其比较次数等于给定值的结点在二叉排序树的层数。极端情况，最少为 1 次，几根结点就是要找的结点，最多也不会超过树的深度。也就是说，二叉排序树的查找性能取决于二叉树排序树的形状。可问题在于，二叉排序树的形状是不确定的。</p>
<p>也就是说，希望二叉排序树是比较平衡的，即其深度与完全二叉树相同，均为 log<sub>2</sub>n + 1，那么查找的时间复杂度也就为 O(logn)，近似于折半查找。因此希望对一个集合按二叉排序树查找，最好是把它构建成一棵平衡二叉树。</p>
<h3 id="平衡二叉树-AVL-树"><a href="#平衡二叉树-AVL-树" class="headerlink" title="平衡二叉树 (AVL 树)"></a>平衡二叉树 (AVL 树)</h3><p><strong>平衡二叉树 (Self-Balancing Binary Search Tree 或 Height-Balanced Binary Search Tree)，是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于 1</strong>。</p>
<p>从平衡二叉树的英文名，可以体会到，它是<strong>一种高度平衡的二叉排序树</strong>。那什么叫做高度平衡呢？意思是说，要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过 1。**将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子 BF (Balance Factor)**，那么平衡二叉树上所有结点的平衡因子只可能是 -1， 0 和 1。只要二叉树上有一个结点的平衡因子的绝对值大于 1，则该二叉树就是不平衡的。</p>
<p><strong>距离插入结点最近的，且平衡因子的绝对值大于 1 的结点为根的子树，称为最小不平衡子树</strong>。</p>
<h4 id="平衡二叉树实现原理"><a href="#平衡二叉树实现原理" class="headerlink" title="平衡二叉树实现原理"></a>平衡二叉树实现原理</h4><p>平衡二叉树构建的基本思想就是在构建二叉树排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。</p>
<h4 id="平衡二叉树的实现算法"><a href="#平衡二叉树的实现算法" class="headerlink" title="平衡二叉树的实现算法"></a>平衡二叉树的实现算法</h4><p>改进二叉排序树的结点结构，增加一个 bf，用来存储平衡因子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的二叉链表结点结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span>				<span class="comment">// 结点结构</span></span><br><span class="line">  <span class="type">int</span> data;								<span class="comment">// 结点数据</span></span><br><span class="line">  <span class="type">int</span> bf;								<span class="comment">// 结点的平衡因子</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>		<span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<p>然后，对于右旋操作，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对以 p 为根的二叉排序树作右旋处理，处理之后 p 指向新的树根结点，即旋转处理之前的左子树的根结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">R_Rotate</span><span class="params">(BiTree *P)</span> &#123;</span><br><span class="line">  BiTree L;</span><br><span class="line">  l = (*P) -&gt; lchild;					<span class="comment">// L 指向 p 的左子树根结点</span></span><br><span class="line">  (*P) -&gt; lchild = L -&gt; rchild;			<span class="comment">// L 的右子树挂接为 p 的左子树</span></span><br><span class="line">  L -&gt; rchild = (*p);</span><br><span class="line">  *p = L;								<span class="comment">// p 指向新的根结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数代码的意思是说，当传入一个二叉排序树 p，将它的左孩子结点定义为 L，将 L 的右子树变成 p 的左子树，再将 p 改成 L 的右子树，最后将 L 替换 P 成为根结点。这样就完成了一次右旋操作。</p>
<p>左旋操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对以 p 为根的二叉排序树作左旋处理，处理之后 p 指向新的树根结点，即旋转处理之前的右子树的根结点 0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">L_Rotate</span><span class="params">(BiTree *p)</span> &#123;</span><br><span class="line">  BiTree R;</span><br><span class="line">  R = (*p) -&gt; rchild;				<span class="comment">// R 指向 p 的右子树根结点</span></span><br><span class="line">  (*p) -&gt; rchild = R -&gt; lchild;		<span class="comment">// R 的左子树挂接为 P 的右子树</span></span><br><span class="line">  R -&gt; lchild = (*p);</span><br><span class="line">  *p = R;							<span class="comment">// P 指向新的根结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>左平衡旋转处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LH +1			<span class="comment">/* 左高 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EH 0			<span class="comment">/* 等高 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RH -1			<span class="comment">/* 右高 */</span></span></span><br><span class="line"><span class="comment">/* 对以指针 T 所指结点为根的二叉树作左平衡旋转处理，本算法结束时，指针 T 指向新的根结点 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LeftBalance</span><span class="params">(BiTree *T)</span> &#123;</span><br><span class="line">  BiTree L, Lr;</span><br><span class="line">  L = (*T) -&gt; lchild;						<span class="comment">// L 指向 T 的左子树的根结点</span></span><br><span class="line">  <span class="keyword">switch</span>(L -&gt; bf) &#123;							<span class="comment">// 检查 T 的左子树的平衡度，并做相应平衡处理</span></span><br><span class="line">    <span class="keyword">case</span> LH:								<span class="comment">// 新结点插入在 T 的左孩子的左子树上，要做单右旋处理</span></span><br><span class="line">      (*T) -&gt; bf = L -&gt; bf = EH;</span><br><span class="line">      R_Rotate(T);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RH:			     				<span class="comment">// 新结点插入在 T 的左孩子的右子树上，要做双旋处理</span></span><br><span class="line">      Lr = L -&gt; rchild;						<span class="comment">// Lr 指向 T 的左孩子的右子树根</span></span><br><span class="line">      <span class="keyword">switch</span>(Lr -&gt; bd) &#123;					<span class="comment">// 修改 T 及其左孩子的平衡因子</span></span><br><span class="line">        <span class="keyword">case</span> LH:</span><br><span class="line">          (*T) -&gt; bf = RH;</span><br><span class="line">          L -&gt; bf = EH;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EH:</span><br><span class="line">          (*T) -&gt; bf = L -&gt; bf = EH;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RH:</span><br><span class="line">          (*T) -&gt; bf = EH;</span><br><span class="line">          L -&gt; bf = LH;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Lr -&gt; bf = EH;</span><br><span class="line">      L_Rotate(&amp;(*T) -&gt; lchild);			<span class="comment">// 对 T 的左子树作左旋平衡处理</span></span><br><span class="line">      R_Rotate(T);							<span class="comment">// 对 T 作右旋平衡处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若在平衡的二叉排序树 T 中不存在和 e 有相同关键字的结点，则插入一个数据元素为 e 的新结点并返回 1，否则返回 0。 */</span></span><br><span class="line"><span class="comment">/* 若因插入而使二叉排序树失去平衡，则作平衡旋转处理，布尔变量 taller 反应 T 长高与否 */</span></span><br><span class="line">Status <span class="title function_">InsertAVL</span><span class="params">(BiTree *T, <span class="type">int</span> e, Status *taller)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!*T) &#123;											<span class="comment">// 插入新结点，树“长高”，置 taller 为 TRUE</span></span><br><span class="line">    *T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T) -&gt; data = e;</span><br><span class="line">    (*T) -&gt; lchild = (*T) -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">    (*T) -&gt; bf = EH;</span><br><span class="line">    *taller = TRUE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(e == (*T) -&gt; data) &#123;							<span class="comment">// 树中已存在和 e 有相同关键字的结点则不再插入</span></span><br><span class="line">      *taller = FALSE;</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(e &lt; (*T) -&gt; data) &#123;							<span class="comment">// 应继续在 T 的左子树中进行搜索</span></span><br><span class="line">      <span class="keyword">if</span>(!InsertAVL(&amp;(*T) -&gt; lchild, e, taller))	<span class="comment">// 未插入</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">      <span class="keyword">if</span>(taller) &#123;									<span class="comment">// 已插入到 T 的左子树中且左子树“长高”</span></span><br><span class="line">        <span class="keyword">switch</span>((*T) -&gt; bf) &#123;						<span class="comment">//检查 T 的平衡度</span></span><br><span class="line">          <span class="keyword">case</span> LH:									<span class="comment">// 原本左子树比右子树高，需要作左平衡处理</span></span><br><span class="line">            LeftBalance(T);</span><br><span class="line">            *taller = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> EH:									<span class="comment">// 原本左右子树等高，现因左子树增高而树增高</span></span><br><span class="line">            (*T) -&gt; bf = LH;</span><br><span class="line">            *taller = TRUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> RH:									<span class="comment">// 原本右子树比左子树高，现左右子树等高</span></span><br><span class="line">            (*T) -&gt; bf = EH;</span><br><span class="line">            *taller = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;											<span class="comment">// 应继续在 T 的右子树中进行搜索</span></span><br><span class="line">      <span class="keyword">if</span>(!InsertAVL(&amp;(*T) -&gt; rchild, e, taller))	<span class="comment">// 未插入</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">      <span class="keyword">if</span>(*taller) &#123;									<span class="comment">// 已插入到 T 的右子树且右子树“长高”</span></span><br><span class="line">        <span class="keyword">switch</span>((*T) -&gt; bf) &#123;						<span class="comment">// 检查 T 的平衡度</span></span><br><span class="line">          <span class="keyword">case</span> LH:									<span class="comment">// 原本左子树比右子树高，现左、右子树等高</span></span><br><span class="line">            (*T) -&gt; bf = EH;</span><br><span class="line">            *taller = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> EH:									<span class="comment">// 原本右右子树等高，现因右子树增高而树增高</span></span><br><span class="line">            (*T) -&gt; bf = RH;</span><br><span class="line">            *taller = TRUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> RH:									<span class="comment">// 原本右子树比左子树高，需要作右平衡处理</span></span><br><span class="line">            RightBalance(T);</span><br><span class="line">            *taller = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成一棵平衡二叉树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>,  <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">BiTree T = <span class="literal">NULL</span>;</span><br><span class="line">Status taller;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  InsertAVL(&amp;T, a[i], &amp;taller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要查找的集合本身没有顺序，在频繁查找的同时也需要经常的插入和删除操作，显然需要构建一棵二叉排序树，但是不平衡的二叉排序树，查找效率是非常低的，因此需要在构建时，就让这棵二叉排序树是平衡二叉树，此时的查找时间复杂度就为 O(logn)，而插入和删除也为 O(logn)。显然这是比较理想的一种动态查找表算法。</p>
<h3 id="多路查找树-B-树"><a href="#多路查找树-B-树" class="headerlink" title="多路查找树 (B 树)"></a>多路查找树 (B 树)</h3><p><strong>多路查找树 (muitl-way search tree)，其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素</strong>。由于它是查找树，所有元素之间存在某种特定的排序关系。</p>
<h4 id="2-3-树"><a href="#2-3-树" class="headerlink" title="2-3 树"></a>2-3 树</h4><p>**2-3 树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子 (称它为 2 结点) 或三个孩子 (称它为 3 结点)**。</p>
<p><strong>一个 2 结点包含一个元素和两个孩子或没有孩子</strong>，且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。不过，与二叉排序树不同的是，这个 2 结点要么没有孩子，要有就有两个，不能只有一个孩子。</p>
<p><strong>一个 3 结点包含一小一大两个元素和三个孩子或没有孩子</strong>，一个 3 结点要么没有孩子，要么具有 3 个孩子。如果某个 3 结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。</p>
<p>并且 2-3 树中所有的叶子都在同一层次上。事实上，2-3 树复杂的地方就在于新结点的插入和已有结点的删除。毕竟，每个结点可能是 2 结点也可能是 3 结点，要保证所有叶子都在同一层次，是需要进行一番复杂操作的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/2-3%E6%A0%91.png" alt="2-3树"></p>
<ul>
<li><p><strong>2-3树的插入实现</strong></p>
<p>  对于 2-3 树的插入来说，与二叉排序树相同，插入操作一定是发生在叶子结点上。可与二叉排序树不同的是，2-3 树插入一个元素的过程有可能会对该树的其余结构产生连锁反应。</p>
<p>  2-3 树插入可分为三种情况：</p>
<ol>
<li>对于空树，插入一个 2 结点即可。</li>
<li>插入结点到一个 2 结点的叶子上。应该说，由于其本身就只有一个元素，所以只需要将其升级为 3 结点即可。</li>
<li>要往 3 结点中插入一个新元素。因为 3 结点本身已经是 2-3 树的结点最大容量 (已经有两个元素)，因此就需要将其拆分，且将树中两元素或插入元素的三者中选择其一向上移动一层。复杂的情况也正在于此。</li>
</ol>
</li>
<li><p><strong>2-3 树的删除实现</strong></p>
<p>  2-3 树的删除也分为三种情况</p>
<ol>
<li>所删除元素位于一个 3 结点的叶子结点上，只需要在该结点处删除该元素即可，不会影响到整棵树的其他结点结构。</li>
<li>所删除的元素位于一个 2 结点上，即要删除的是一个只有一个元素的结点。对于删除叶子是 2 结点的情况，需要分四种情形来处理。<ul>
<li>此结点的双亲也是 2 结点，且拥有一个 3 结点的右孩子。</li>
<li>此结点的双亲是 2 结点，它的右孩子也是 2 结点。</li>
<li>此结点的双亲是一个 3 结点。</li>
<li>如果当前树是一个满二叉树的情况，此时删除任何一个叶子都会使得整棵树不能满足 2-3 树的定义。</li>
</ul>
</li>
<li>所删除的元素位于非叶子的分支结点。 通常是将树按中序遍历后得到此元素的前驱或后继元素，考虑让它们来补位即可。</li>
</ol>
</li>
<li><p><strong>2-3-4 树</strong></p>
<p>  <strong>2-3-4 树就是 2-3 树的概念扩展，包括了 4 结点的使用。一个 4 结点包含小中大三个元素和四个孩子或没有孩子</strong>，一个 4 结点要么没有孩子，要么具有 4 个孩子。如果某个 4 结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素。</p>
</li>
</ul>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h4><p><strong>B 树 (B Tree) 是一种平衡的多路查找树，2-3 树和 2-3-4 树都是 B 树的特例。结点最大的孩子数目称为 B 树的阶 (order)，因此，2-3 树是 3 阶 B 树，2-3-4 树是 4 阶 B 树。</strong></p>
<p>一个 m 阶的 B 树具有如下属性：</p>
<ul>
<li>如果根结点不是叶结点，则其至少有两棵子树。</li>
<li>每一个非根的分支结点都有 k - 1 个元素和 k 个孩子，其中 (m &#x2F; 2) ≤ k ≤ m。每一个叶子结点 n 都有 k - 1 个元素，其中 (m &#x2F; 2) ≤ k ≤ m。</li>
<li>所有叶子结点都位于同一层次。</li>
<li>所有分支结点包含下列信息数据 (n, A<sub>0</sub>, K<sub>1</sub>, A<sub>1</sub>, K<sub>2</sub>, A<sub>2</sub>, ···, K<sub>n</sub>, A<sub>n</sub>)，其中：K<sub>i</sub> (i &#x3D; 1, 2, ……, n) 为关键字，且 K<sub>i</sub> &lt; K<sub>i + 1</sub> (i &#x3D; 1, 2, ···， n-1)；A<sub>i</sub> (i &#x3D; 0, 2, ···, n-1)；A<sub>i</sub> (i &#x3D; 0, 2, ···, n) 为指向子树根结点的指针，且指针 A<sub>i - 1</sub> 所指子树中所有结点的关键字均小于 K<sub>i</sub> (i &#x3D; 1, 2, ……, n)，A<sub>n</sub> 所指子树中所有结点的关键字均大于 K<sub>n</sub>，n · ((m &#x2F; 2) - 1 ≤ n ≤ m - 1) 为关键字的个数或 n + 1 为子树的个数。</li>
</ul>
<h4 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h4><p>B+ 树适应文件系统所需而出的一种 B 树的变形树。在 B 树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在 B+ 树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者 (叶子结点) 中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针。</p>
<p>一棵 m 阶的 B+ 树和 m 阶的 B 树的差异在于：</p>
<ul>
<li>有 n 棵子树的结点中包含有 n 个关键字；</li>
<li>所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接；</li>
<li>所有分支结点可以看成是索引，结点中仅含有其子树中的最大或最小关键字。</li>
</ul>
<p>这样的数据结构最大的好处就在于，如果是要随机查找，就从根结点出发，与 B 树的查找方式相同，只不过即使在分支结点找到了待查找的关键字，它也只是用来索引的，不能提供实际记录的访问，还是需要到达包含此关键字的终端结点。</p>
<p>如果是需要从最小关键字进行从小到大的顺序查找，就可以从最左侧的叶子结点出发，不经过分子结点，而是延着指向下一叶子的指针就可遍历所有的关键字。</p>
<p>B+ 树的结构特别适合带有范围的查找。B+ 树的插入、删除过程也都与 B 树类似，只不过插入和删除的元素都是在叶子结点上进行而已。</p>
<h3 id="散列表查找-哈希表-概述"><a href="#散列表查找-哈希表-概述" class="headerlink" title="散列表查找 (哈希表) 概述"></a>散列表查找 (哈希表) 概述</h3><h4 id="散列表查找定义"><a href="#散列表查找定义" class="headerlink" title="散列表查找定义"></a>散列表查找定义</h4><p>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得每个关键字 key 对应一个存储位置 f(key)。查找时，根据这个确定的对应关系找到给定值 key 的映射 f(key)，若查找集合中存在这个记录，则必定在 f(key) 的位置上。</p>
<p>这里把这种对应<strong>关系 f 称为散列函数，又称为哈希 (Hash) 函数</strong>。按这个思想，**采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表 (Hash Table)**。那么关键字对应的记录存储位置称为散列地址。</p>
<h4 id="散列表查找步骤"><a href="#散列表查找步骤" class="headerlink" title="散列表查找步骤"></a>散列表查找步骤</h4><p>整个散列过程其实就是两步。</p>
<ol>
<li>在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。</li>
<li>当查找记录时，通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。</li>
</ol>
<p>所以说，<strong>散列技术即是一种存储方法，也是一种查找方法</strong>。然而它与线性表、树、图等结构不同的是，前面几种结构，数据元素之间都存在某种逻辑关系，可以用连线图示表示出来，而散列技术的记录之间不存在什么逻辑关系，它只与关键字有关联。因此，散列主要是面向查找的存储结构。</p>
<p><strong>散列技术最适合的求解问题是查找与给定值相等的记录</strong>。对于查找来说，简化了比较过程，效率就会大大提高。</p>
<p>在理想情况下，每一个关键字，通过散列函数计算出来的地址都是不一样的，可现实中，这只是一个理想。时长会碰到**两个关键字 key<sub>1</sub> ≠ key<sub>2</sub>，但是却有 f(key<sub>1</sub>) &#x3D; f(key<sub>2</sub>)，这种现象称为冲突 (collision)，并把 key<sub>1</sub> 和 key<sub>2</sub> 称为这个散列函数的同义词 (synonym)**。出现了冲突当然非常糟糕，那将造成数据查找错误。</p>
<h3 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h3><p>什么才算是好的散列函数？</p>
<ol>
<li><p><strong>计算简单</strong></p>
<p> 设计一个算法可以保证所有的关键字都不会产生冲突，但是这个算法需要很复杂的计算，会耗费很多时间，这对于需要频繁地查找来说，就会大大降低查找的效率了。因此散列函数的计算时间不应超过其他查找技术与关键字比较的时间。</p>
</li>
<li><p><strong>散列地址分布均匀</strong></p>
<p> 解决冲突最好的办法就是尽量让散列地址均匀地分布在存储空间中，这样可以保证存储空间的有效利用，并减少为处理冲突而耗费的时间。</p>
</li>
</ol>
<p>几种常用的散列函数构造方法：</p>
<h4 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h4><p><strong>取关键字的某个线性函数值为散列地址</strong>。即</p>
<p><code>f(key) = a × key + b (a、b 为常数)</code></p>
<p>这样的散列函数优点就是检点、均匀，也不会产生冲突，但问题是这需要事先知道此关键字的分布情况，适合查找表较小且连续的情况。由于这样的限制，在显示应用中，此方法虽然简单，但却并不常用。</p>
<h4 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h4><p>如果关键字是位数较多的数字，比如 11 位手机号 “131xxxx1234”，其中前三位是接入号，一般对应不同运营商公司的子品牌，如 130 是连通如意通、136 是移动神州行、153 是电信等；中间四位是 HLR 识别号，表示用户号的归属地；后四位才是真正的用户号。</p>
<p>若现在要存储某家公司员工登记表，如果用手机号作为关键字，那么极有可能前 7 位都是相同的。那么选择后面的四位称为散列地址就是不错的选择。如果这样的抽取工作还是容易出现冲突，还可以对抽取出来的数字在进行反转 (如 1234 改成 4321)、右环位移 (如 1234 改成 4123)、左环位移、甚至前两数与后两数叠加 (如 1234 改成 12 + 34 &#x3D; 46) 等方法。总的目的就是为了提供一个散列函数，能能够合理地将关键字分配到散列表的各位置。</p>
<p>这里提到了一个关键词——抽取。抽取方法是使用关键字的一部分来计算散列存储位置的方法，这在散列函数中是常常用到的手段。</p>
<p>数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干分布比较均匀，就可以考虑用这个方法。</p>
<h4 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h4><p>这个方法计算很简单，假设关键字是 1234，那么它的平方就是 1522756，再抽取中间的 3 位就是 227，用做散列地址。再比如关键字是 4321，那么它的平方就是 18671041，抽取中间的 3 位就可以是 671，也可以是 710，用做散列地址。平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况。</p>
<h4 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h4><p>折叠法是将关键字从左到右分割成位数相等的几部分 (注意最后一部分位数不够时可以短些)，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。</p>
<p>比如关键字是 9876543210，散列表表长为三位，将它分为四组，987｜654｜321｜0，然后将它们叠加求和 987 + 654 + 321 + 0 &#x3D; 1962，在求后 3 位得到散列地址为 962。</p>
<p>有时可能这还不能保证分布均匀，不妨从一端向另一端来回折叠后对齐相加。比如将 987 和 321 反转，再与 654 和 0 相加，变成 789 + 654 + 123 + 0 &#x3D; 1566，此时散列地址为 566。</p>
<p>折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。</p>
<h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><p>此方法为最常用的构造散列函数方法。对于散列表长为 m 的散列函数公式为：</p>
<p><code>f(key) = key mod p (p ≤ m)</code></p>
<p>mod 是取模 (求余数) 的意思。事实上，这方法不仅可以对关键字直接取模，也可以在折叠、平方取中后再取模。</p>
<p>很显然，本方法的关键就在于选择合适的 p，p如果选得不好，就可能会容易产生同义词。</p>
<p>根据经验，若散列表表长为 m，通常 p 为小于或等于表长 (最好接近 m) 的最小质数或不包含小于 20 质因子的合数。</p>
<h4 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h4><p>选择一个随机数，取关键字的随机函数值为它的散列地址。也就是 f(key) &#x3D; random(key)。这里 random 是随机函数。当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。</p>
<p>总之，现实中，应该视不同的情况采用不同的散列函数。通过综合以下因素，可以决策选择哪种散列函数更合适。</p>
<ol>
<li>计算散列地址所需的时间。</li>
<li>关键字的长度。</li>
<li>散列表的大小。</li>
<li>关键字的分布情况。</li>
<li>记录查找的频率。</li>
<li>……</li>
</ol>
<h3 id="处理散列冲突的方法"><a href="#处理散列冲突的方法" class="headerlink" title="处理散列冲突的方法"></a>处理散列冲突的方法</h3><h4 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h4><p>所谓的<strong>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入</strong>。</p>
<p>它的公式是：</p>
<p><code>fi(key) = (f(key) + di) MOD m (di = 1, 2, 3, ……, m - 1)</code></p>
<p>解决冲突的开放定址法称为线性探测法。有时还会出现本来都不是同义词却需要争夺一个地址的情况，称这种现象为堆积。很显然，堆积的出现，使得我们需要不断处理冲突，无论是存入还是查找效率都会大大降低。</p>
<p><strong>增加平方运算的目的是为了不让关键字都聚集在某一块区域。称这种方法为二次探测法</strong>。</p>
<p><code>fi(key) = (f(key) + di) MOD m (di = 1, 1, 4, 4, ……, q^2, -q^2, q ≤ m / 2)</code></p>
<p>还有一种方法是，<strong>在冲突时，对于位移量 d<sub>i</sub> 采用随机函数计算得到，称之为随机探测法</strong>。</p>
<p>既然是随机，那么查找的时候不也随机生成 d<sub>i</sub> 吗？如果可以获得相同的地址？这里的随机其实是伪随机数。伪随机数是说，如果设置随机种子相同，则不断调用随机函数可以生成不会重复的数列，在查找时，用同样的随机种子，他每次得到的数列是相同的，相同的 d<sub>i</sub> 当然可以得到相同的散列地址。</p>
<p><code>fi(keyi) = (f(key) + di) MOD m (di 是一个随机数列)</code></p>
<p>总之，开放定址法只要在散列表未填满时，总是能找到不发生冲突的地址，是我们常用的解决冲突的方法。</p>
<h4 id="再散列函数法"><a href="#再散列函数法" class="headerlink" title="再散列函数法"></a>再散列函数法</h4><p>用买房子来举例，如果看房时的选择标准总是以市中心、交通便利、价格适中为指标，这样的房子凤毛麟角，基本上当你看到时，都已经被人买去了。</p>
<p>换一种思维，选择市郊的房子，交通尽管要差一些，但价格便宜很多，也许房子还可以买得大一些、质量好一些，并且由于更换了选房的想法，很快就找到了你需要的房子了。</p>
<p>对于散列表来说，事先准备多个散列函数。</p>
<p><code>fi(key) = RHi(key) (i = 1, 2, ···， k)</code></p>
<p>这里 RH<sub>i</sub> 就是不同的散列函数，可以把前面说的什么除留余数、折叠、平方取中全部用上。每当发生散列地址冲突时，就换一个散列函数计算，相信总会有一个可以把冲突解决掉。这种方法能够使得关键字不产生聚集，当然，相应地也增加了计算的时间。</p>
<h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>将所有关键字为同义词的记录存储在一个单链表中，称这种表为同义词字表，在散列表中只存储所有同义词字表的头指针。对于关键字集合 {12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34}，用 12 为除数，进行除留余数法，可得到如下图所示结构，此时，已经不存在什么冲突换址的问题，无论有多少个冲突，都只是在当前位置给单链表增加结点的问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95.png" alt="链地址法"></p>
<p>链地址法给予可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保障。当然，这也就带来了查找时需要遍历单链表的性能损耗。</p>
<h4 id="公共溢出区法"><a href="#公共溢出区法" class="headerlink" title="公共溢出区法"></a>公共溢出区法</h4><p>这个方法其实就更好即理解，凡是冲突的都跟我走，我给你们这些冲突找个地呆着。这就如同孤儿院收留所有无家可归的孩子一样，我们为所有冲突的关键字建立了一个公共的溢出区来存放。</p>
<p>就前面的例子而言，共有三个关键字 {37, 48, 34} 与之前的关键字位置有冲突，那么就将它们存储到溢出表中，如下图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%85%AC%E5%85%B1%E6%BA%A2%E5%87%BA%E5%8C%BA%E6%B3%95.png" alt="公共溢出区法"></p>
<p>在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功；如果不相等，则到溢出表去进行顺序查找。如果相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还时非常高的。</p>
<h3 id="散列表查找实现"><a href="#散列表查找实现" class="headerlink" title="散列表查找实现"></a>散列表查找实现</h3><h4 id="散列表查找算法实现"><a href="#散列表查找算法实现" class="headerlink" title="散列表查找算法实现"></a>散列表查找算法实现</h4><p>首先需要定义一个散列表的结构以及一些相关的常数。其中 HashTable 就是散列表结构。结构当中的 elem 为一个动态数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASHSIZE 12			<span class="comment">// 定义散列表长为数组的长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULLKEY -32768</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> *elem;				<span class="comment">// 数据元素存储基址，动态分配数组</span></span><br><span class="line">  <span class="type">int</span> count;				<span class="comment">// 当前数据元素个数</span></span><br><span class="line">&#125;HashTable;</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;					<span class="comment">// 散列表表长，全局变量</span></span><br></pre></td></tr></table></figure>

<p>有了结构的定义，可以对散列表进行初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化散列表 */</span></span><br><span class="line">Status <span class="title function_">InitHashTable</span><span class="params">(HashTable *H)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  m = HASHSIZE;</span><br><span class="line">  H -&gt; count = m;</span><br><span class="line">  H -&gt; elem = (<span class="type">int</span> *)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    H -&gt; elem[i] = NULLKEY;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了插入时计算地址，需要定义散列函数，散列函数可以根据不同情况更改算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 散列函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> key % m;			<span class="comment">// 除留余数法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化完成后，可以对散列表进行插入操作。设计插入的关键字集合就是前面的 {12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34}。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入关键字进行散列表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertHash</span><span class="params">(HashTable *H, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> addr = Hash(key);					<span class="comment">// 求散列地址</span></span><br><span class="line">  <span class="keyword">while</span>(H -&gt; elem[addr] != NULLKEY)		<span class="comment">// 如果不为空，则冲突</span></span><br><span class="line">    addr = (addr + <span class="number">1</span>) % m;				<span class="comment">// 开放定址法的线性探测</span></span><br><span class="line">  H -&gt; elem[addr] = key;				<span class="comment">// 直到有空位后插入关键字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中插入关键字时，首先算出散列地址，如果当前地址不为空关键字，则说明有冲突。此时应用开放定址法的线性探测进行重新寻址，此处也可更改为链地址法等其它解决冲突的办法。</p>
<p>散列表存在后，在需要时就可以通过散列表查找要的记录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 散列表查找关键字 */</span></span><br><span class="line">Status <span class="title function_">SearchHash</span><span class="params">(HashTable H, <span class="type">int</span> key, <span class="type">int</span> *addr)</span> &#123;</span><br><span class="line">  *addr = Hash(key);				<span class="comment">// 求散列地址</span></span><br><span class="line">  <span class="keyword">while</span>(H.elem[*addr] != key) &#123;		<span class="comment">// 如果不为空，则冲突</span></span><br><span class="line">    *addr = (*addr + <span class="number">1</span>) % m;		<span class="comment">// 开放定址法的线性探测</span></span><br><span class="line">    <span class="keyword">if</span>(H.elem[*addr] == NULLKEY || *addr == Hash(key)) &#123;			</span><br><span class="line">      <span class="keyword">return</span> UNSUCCESS;				<span class="comment">// 则说明关键字不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找的代码与插入的代码非常相似，只需做一个不存在关键字的判断而已。</p>
<h4 id="散列表查找性能分析"><a href="#散列表查找性能分析" class="headerlink" title="散列表查找性能分析"></a>散列表查找性能分析</h4><ol>
<li><p><strong>散列函数是否均匀</strong></p>
<p> 散列函数的好坏直接影响着出现冲突的频繁程度，不过，由于不同的散列函数对同一组随机的关键字，产生冲突的可能性是相同的，因此我们可以不考虑它对平均查找长度的影响。</p>
</li>
<li><p><strong>处理冲突的方法</strong></p>
<p> 相同的关键字、相同的散列函数，但处理冲突的方法不同，会是的平均查找长度不同。比如线性探测处理冲突可能会产生堆积，显然就没有二次探测法好，而链地址法处理冲突不会产生任何堆积，因而具有更佳的平均查找性能。</p>
</li>
<li><p><strong>散列表的装填因子</strong></p>
<p> 所谓的装填因子 𝛂 &#x3D; 填入表中的记录个数 &#x2F; 散列表长度。𝛂 标志着散列表的装满的程度。当填入表中的记录越多，𝛂 就越大，产生冲突的可能性就越大。比如前面的例子，如果你的散列表长度是 12，而填入表中的记录个数为 11，那么此时的装填因子 𝛂 &#x3D; 11 &#x2F; 12 &#x3D; 0.9167，再填入最后一个关键字产生冲突的可能性就非常之大。也就是说，散列表的平均查找长度取决于装填因子，而不是取决于查找集合中的记录个数。</p>
<p> 不管记录个数 n 有多大，我们总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围之内，此时我们散列查找的时间复杂度就真的是 O(1) 了。为了做到这一点，通常我们都是将散列表的空间设置得比查找集合大，此时虽然是浪费了一定的空间，但换来的是查找效率的大大提升，总的来说，还是非常值得的。</p>
</li>
</ol>
<h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><p>这一章的主题是 “查找” 。</p>
<p>首先，弄清楚查找表、记录、关键字、主关键字、静态查找表、动态查找表等概念。</p>
<p>然后，对于顺序表查找来说，尽管很简单，但它却是后面很多查找的基础，注意设置“哨兵”的技巧，可以使得本已经很难提升的算法里还是提高了性能。</p>
<p>有序查找，着重折半查找的思想，它在性能上比原来的顺序查找有了质的飞跃，由 O(n) 变成了 O(logn)。接着映出了两种优秀的有序查找：插值查找和斐波那契查找，它们三者各有优缺点。</p>
<p>线性索引查找，介绍了稠密索引、分块索引和倒排索引。索引技术被广泛的用于文件检索、数据库和搜索引擎等技术领域，是进一步学习这些技术的基础。</p>
<p>二叉排序树是动态查找最重要的数据结构，他可以在兼顾查找性能的基础上，让插入和删除也变得效率较高。不过为了达到最优的状态，二叉排序树是构造成平衡的二叉树才最佳。因此需要在学习关于平衡二叉树的数据结构，了解 AVL 树是如何处理平衡性的问题。</p>
<p>B 树这种数据结构是针对内存与外存之间的存取而专门设计的。由于内外存的查找性能更多取决于读取的次数，因此在设计中要考虑 B 树的平衡和层次。先通过最简单的 2-3 树来理解如果构建、插入、删除元素的操作，再通过 2-3-4 树的深化，最终来理解 B 树的原理，之后 介绍了 B+ 树的设计思想。</p>
<p>散列表是一种非常搞笑的查找数据结构，在原理上也与前面的查找不尽相同，它回避了关键字之间反复比较的繁琐，而是直接一步到位查找结果。当然，这也就带来了记录之间没有任何关联的弊端。应该说，散列表对于那种查找性能要求高，记录之间关系无要求的数据有非常好的适用性。在学习中要注意的是散列函数的选择和处理冲突的方法。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="排序的基本概念与分类"><a href="#排序的基本概念与分类" class="headerlink" title="排序的基本概念与分类"></a>排序的基本概念与分类</h3><blockquote>
<p>假设含有 n 个记录的序列为 {r<sub>1</sub>, r<sub>2</sub>, ···, r<sub>n</sub>}，其相应的关键字分别为 {k<sub>1</sub>, k<sub>2</sub>, ···, k<sub>n</sub>}，需确定 1，2，……，n 的一种排列 p<sub>1</sub>, p<sub>2</sub>, ···, p<sub>n</sub>，使其相应的关键字满足 k<sub>p1</sub> ≤ k<sub>p2</sub> ≤ …… ≤ k<sub>pn</sub> (非递减或递增) 关系，即使得序列成为一个按关键字有序的序列{r<sub>p1</sub>, r<sub>p2</sub>, ···, r<sub>pn</sub>}，这样的操作就称为排序。</p>
</blockquote>
<p>注意在排序问题中，通常将数据元素成为记录。显然输入的是一个记录集合，输出的也是一个记录集合，所以说，可以将排序看成是线性表的一种操作。</p>
<p>排序的一句是关键字之间的大小关系，那么，对于一个记录集合，针对不同的关键字进行排序，可以得到不同序列。</p>
<h4 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h4><p>也正是由于排序不仅是针对主关键字，那么对于次关键字，因为待排序的记录序列中可能存在两个或两个以上的关键字相等的记录，排序结果可能会存在不唯一的情况，给出了稳定与不稳定排序的定义。</p>
<p><strong>假设 k<sub>i</sub> &#x3D; k<sub>j</sub> (1 ≤ i ≤n, 1 ≤ j ≤ n, i ≠ j)，且在排序前的序列中 r<sub>i</sub> 领先于 r<sub>j</sub> (即 i &lt; j)。如果排序后 r<sub>i</sub> 仍领先于 r<sub>j</sub>，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中 r<sub>j</sub> 领先 r<sub>i</sub> ，则称所用的排序方法是不稳定的</strong>。</p>
<h4 id="内排序与外排序"><a href="#内排序与外排序" class="headerlink" title="内排序与外排序"></a>内排序与外排序</h4><p>根据在排序过程中待排序的记录是否全部被放置在内存中，排序分为：内排序和外排序。</p>
<p><strong>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行</strong>。</p>
<p>对于内排序来说，排序算法的性能主要是受 3 个方面影响：</p>
<ol>
<li><p><strong>时间性能</strong></p>
<p> 排序是数据处理中经常执行的一种操作，往往属于系统的核心部分，因此排序算法的时间开销是衡量其好坏的最重要的标志。在内排序中，主要进行两种操作：比较和移动。比较指关键字之间的比较，这是要做排序最起码的操作。移动指记录从一个位置移动到另一个位置，事实上，移动可以通过改变记录的存储方式来予以避免。总之，搞笑路的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。</p>
</li>
<li><p><strong>辅助空间</strong></p>
<p> 评价排序算法的另一个主要标准是执行算法所需要的辅助存储空间。辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。</p>
</li>
<li><p><strong>算法的复杂性</strong></p>
<p> 注意这里指的是算法本身的复杂度，而不是指算法的时间复杂度。显然算法过于复杂也会影响排序的性能。</p>
<p> 根据排序过程中截住的主要操作，把<strong>内排序分为：插入排序、交换排序、选择排序和归并排序</strong>。可以说，这些都是比较成熟的排序技术，已经被广泛地应用于许多的程序语言或数据库当中，甚至他们都已经封装了关于排序算法的实现代码。因此，学习这些排序算法的目的更多并不是为了去在现实中编程排序算法，而是通过学习来提升我们编写算法的能力，以便于去解决更多复杂和灵活的应用性问题。</p>
</li>
</ol>
<h4 id="排序用到的结构与函数"><a href="#排序用到的结构与函数" class="headerlink" title="排序用到的结构与函数"></a>排序用到的结构与函数</h4><p>为了讲清楚排序算法的代码，先提供一个用于排序用的顺序表结构，此结构也将用于之后的所有排序算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 10			<span class="comment">// 用于要排序数组个数最大值，可根据需要修改</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> r[MAXSIZE + <span class="number">1</span>];		<span class="comment">// 用于存储要排序数组，r[0] 用作哨兵或临时变量</span></span><br><span class="line">  <span class="type">int</span> length;				<span class="comment">// 用于记录顺序表的长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p>另外，由于排序最长用到的操作是数组两元素的交换，将它写成函数，在之后会大量用到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 交换 L 中数组 r 的下标为 i 和 j 的值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(SqList *L, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">  <span class="type">int</span> temp = L -&gt; r[i];</span><br><span class="line">  L -&gt; r[i] = L -&gt; r[j];</span><br><span class="line">  L -&gt; r[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="最简单排序实现"><a href="#最简单排序实现" class="headerlink" title="最简单排序实现"></a>最简单排序实现</h4><p><strong>冒泡排序 (Bubble Sort) 一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止</strong>。冒泡的视线在细节上可以有很多变化，我们将分别就 3 中不同的冒泡实现代码，来讲解冒泡排序的思想。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作交换排序 (冒泡排序初级版) */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort0</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; L -&gt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt;= L -&gt; length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(L -&gt;r[i] &gt; L -&gt; r[j]) &#123;</span><br><span class="line">        swap(L, i, j);		<span class="comment">// 交换 L -&gt; r[i] 与 L -&gt; r[j] 的值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort1</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; L -&gt; length; i++) &#123;			</span><br><span class="line">    <span class="keyword">for</span>(j = L -&gt; length - <span class="number">1</span>; j &gt;= i; j--) &#123;			<span class="comment">// 注意 j 是从后往前循环</span></span><br><span class="line">      <span class="keyword">if</span>(L -&gt; r[j] &gt; L -&gt; r[j +<span class="number">1</span>]) &#123;				<span class="comment">// 若前者大于后者 (注意这里与上一算法差异)</span></span><br><span class="line">        swap(L, j, j + <span class="number">1</span>);							<span class="comment">// 交换 L -&gt; r[j] 与 L -&gt; r[j + 1] 的值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="冒泡排序优化"><a href="#冒泡排序优化" class="headerlink" title="冒泡排序优化"></a>冒泡排序优化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作改进冒泡算法 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort2</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  Status flag = TRUE;								<span class="comment">// flag 用来作为标记</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; L -&gt; length &amp;&amp; flag; i++) &#123;		<span class="comment">// 若 flag 为 true 则退出循环</span></span><br><span class="line">    flag = FLASE;									<span class="comment">// 初始化为 false</span></span><br><span class="line">    <span class="keyword">for</span>(j = L -&gt; length - <span class="number">1</span>; j &gt;= i; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span>(L -&gt; r[j] &gt; L -&gt; r[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(L, j, j + <span class="number">1</span>);							<span class="comment">// 交换 L -&gt; r[j] 与 L -&gt; r[j + 1] 的值</span></span><br><span class="line">        flag = TRUE;								<span class="comment">// 如果有数据交换，则 flag 为 true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码改动的关键就是在 i 变量的 for 循环中，增加了对 flag 是否为 true 的判断。经过这样的改进，冒泡排序在性能上就有了一些提升，可以避免因已经有序的情况下的无意义循环判断。</p>
<h4 id="冒泡排序复杂度分析"><a href="#冒泡排序复杂度分析" class="headerlink" title="冒泡排序复杂度分析"></a>冒泡排序复杂度分析</h4><p>分析一下他的时间复杂度。当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据最后改进的代码，可以推断出就是 n - 1 次的比较，没有数据交换，时间复杂度为 O(n)。当最坏的情况，即待排序表是逆序的情况，此时需要比较n(n - 1) &#x2F; 2 次，并作等数量级的记录移动。因此，总的时间复杂度为 O(n<sup>2</sup>)。</p>
<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><h4 id="简单选择排序算法"><a href="#简单选择排序算法" class="headerlink" title="简单选择排序算法"></a>简单选择排序算法</h4><p><strong>简单选择排序法 (Simple Selection Sort) 就是通过 n - i 次关键字间的比较，从 n - i + 1 个记录中选出关键字最小的记录，并和第 i (1 ≤ i ≤ n) 个记录交换之</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作简单选择排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j, min;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; L -&gt; length; i++) &#123;</span><br><span class="line">    min = i;									<span class="comment">// 将当前下标定义为最小值下标</span></span><br><span class="line">    <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; L -&gt; length; j++) &#123;		<span class="comment">// 循环之后的数据</span></span><br><span class="line">      <span class="keyword">if</span>(L -&gt; r[min] &gt; L -&gt; r[j])				<span class="comment">// 如果有小于当前最小值的关键字</span></span><br><span class="line">        min = j;								<span class="comment">// 将此关键字的下标赋值给 min</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i != min)								<span class="comment">// 若 min 不等于 i，说明找到最小值，交换</span></span><br><span class="line">      swap(L, i, min);							<span class="comment">// 交换 L -&gt; r[i] 与 L -&gt; r[min] 的值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="简单选择排序复杂度分析"><a href="#简单选择排序复杂度分析" class="headerlink" title="简单选择排序复杂度分析"></a>简单选择排序复杂度分析</h4><p>从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，第 i 躺排序需要进行 n - i 次关键字的比较，此时需要比较 n(n - 1) &#x2F; 2 次。而对于交换次数而言，当最好的时候，交换为 0 次，最差的时候，也就初始降序时，交换次数为 n - 1 次，基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为 O(n<sup>2</sup>)。</p>
<p>应该说，尽管与冒泡排序同为 O(n<sup>2</sup>)，但简单选择排序的性能上还是要优于冒泡排序。</p>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><h4 id="直接插入排序算法"><a href="#直接插入排序算法" class="headerlink" title="直接插入排序算法"></a>直接插入排序算法</h4><p><strong>直接插入排序 (Straight Insertion Sort) 的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增 1 的有序表</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作直接插入排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= L -&gt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(L -&gt; r[i] &lt; L -&gt; r[i - <span class="number">1</span>]) &#123;			<span class="comment">// 需将 L -&gt; r[i] 插入有序子表</span></span><br><span class="line">      L -&gt; r[<span class="number">0</span>] = L -&gt; r[i];				<span class="comment">// 设置哨兵</span></span><br><span class="line">      <span class="keyword">for</span>(j = i - <span class="number">1</span>; L -&gt; r[j] &gt; L -&gt; r[<span class="number">0</span>]; j--)</span><br><span class="line">        L -&gt; r[j + <span class="number">1</span>] = L -&gt; r[j];			<span class="comment">// 记录后移</span></span><br><span class="line">      L -&gt; r[j + <span class="number">1</span>] = L -&gt; r[<span class="number">0</span>];			<span class="comment">// 插入到正确位置</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="直接插入排序复杂度分析"><a href="#直接插入排序复杂度分析" class="headerlink" title="直接插入排序复杂度分析"></a>直接插入排序复杂度分析</h4><p>从空间上看，它只需要一个记录的辅助空间，因此关键是看它的时间复杂度。</p>
<p>当最好的情况下，也就是要排序的表本身就是有序的，因此没有移动的记录，时间复杂度为 O(n)。最坏的情况是待排序表是逆序的情况，此时需要比较(n + 2)(n - 1) &#x2F; 2 次，而记录的移动次数也达到最大值 (n + 4)(n - 1) &#x2F; 2 次。</p>
<p>如果排序记录是随机的，那么根据概率相同的原则，平均比较和移动次数约为 n<sup>2</sup> &#x2F; 4 次。因此，得出直接插入排序法的时间复杂度为 O(n<sup>2</sup>)。从这里也看出，同样的 O(n<sup>2</sup>) 时间复杂度，直接插入排序比冒泡和简单选择排序性能要好一些。</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>在这之前的排序算法的时间复杂度基本都是 O(n<sup>2</sup>) 的，希尔排序算法是突破这个时间复杂度的第一批算法之一。</p>
<p>直接插入排序的效率在某些时候是很高的，比如，记录本身就是基本有序的，只需要少量的插入操作，就可以完成整个记录集的排序工作，此时直接插入很高效。还有就是记录数比较少时，直接插入的优势也比较明显。可问题在于，两个条件本身就过于苛刻，现实中记录少或者基本有序都属于特殊情况。</p>
<p>科学家希尔研究出一种排序算法，对直接插入排序改进后可以增加效率。为了让待排序的记录个数较少？将原本有大量记录数的记录进行分组。分割成若干个字序列，此时每个字序列待排序的记录个数就比较少了，然后在这些字序列内分别进行直接插入排序，当整个序列都基本有序时，注意只是基本有序时，再对全体记录进行一次直接插入排序。<strong>所谓基本有序，就是小的关键字基本在前，大的基本在后面，不大不小的基本在中间，像{2, 1, 3, 6 ,4, 7, 5, 8, 9}</strong> 这样可以成为基本有序。问题其实也在这里，分割待排序记录的目的是为了减少待排序记录的个数，并使整个序列项基本有序发展。然后有些时候分完组后就各自排序的方法达不到要求。因此，需要采取跳跃分割的策略：<strong>将相距某个”增量“的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序</strong>。</p>
<h4 id="希尔排序算法"><a href="#希尔排序算法" class="headerlink" title="希尔排序算法"></a>希尔排序算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作希尔排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="type">int</span> increment = L -&gt; length;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    increment = increment / <span class="number">3</span> + <span class="number">1</span>;						<span class="comment">// 增量序列</span></span><br><span class="line">    <span class="keyword">for</span>(i = increment + <span class="number">1</span>; i &lt;= L -&gt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(L -&gt; r[i] &lt; L -&gt; r[i - increment]) &#123;			<span class="comment">// 需将 L -&gt; r[i] 插入有序增量字表</span></span><br><span class="line">        L -&gt; r[<span class="number">0</span>] = L -&gt; r[i];							<span class="comment">// 暂存在 L -&gt; r[0]</span></span><br><span class="line">        <span class="keyword">for</span>(j = i - increment; j &gt; <span class="number">0</span> &amp;&amp; L -&gt; r[<span class="number">0</span>] &lt; L -&gt; r[j]; j -= increment)</span><br><span class="line">          L -&gt; r[j + increment] = L -&gt; r[j];			<span class="comment">// 记录后移，查找插入位置</span></span><br><span class="line">        L -&gt; r[j + increment] = L -&gt; r[<span class="number">0</span>];				<span class="comment">// 插入</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(increment &gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序复杂度分析"><a href="#希尔排序复杂度分析" class="headerlink" title="希尔排序复杂度分析"></a>希尔排序复杂度分析</h4><p>通过这段代码的剖析，希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个字序列，实现跳跃式的移动，使得排序的效率提高。</p>
<p>这里的“增量”的选取就非常关键了。可究竟应该选取什么样的增量才是最好的，目前还是一个数学难题，迄今为止还没有人找到一个最好的增量序列。不过大量的研究表明，当增量序列为 dlta[k] &#x3D; 2<sup>t - k + 1</sup> - 1 (0 ≤ k ≤ t ≤ log<sub>2</sub>(n + 1)) 时，可以获得不错的效率，其时间复杂度为 O(n<sup>3 &#x2F; 2</sup>)，要好于直接排序的 O(n<sup>2</sup>)。需要注意的是，<strong>增量序列的最后一个增量值必须等于 1 才行</strong>。另外由于记录是跳跃式的移动，希尔排序并不是一种稳定的排序算法。</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>简单选择排序，它在待排序的的 n 个记录中选择最小的记录需要比较 n - 1 次。可惜的是，这样的操作并没有把每一趟的比较结果保存下来，在后一趟的比较中，有许多比较在前一趟已经做过了，但由于前一趟排序时未保存这些比较结果，所以以后一趟排序时又重复执行了这些比较操作，因而记录的比较次数较多。</p>
<p>如果可以做到每次在选择到最小记录的同时，并根据比较结果对其他记录做出相应的调整，那样排序的总体效率就会非常高了。而堆排序 (Heap Sort)，就是对简单选择排序进行的一种改进，这种改进的效果是非常明显的。堆排序算法是 Floyd 和 Williams 在 1964 年共同发明的，同时，他们发明了 ”堆“ 这样的数据结构。</p>
<p><strong>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</strong>。</p>
<h4 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h4><p><strong>堆排序 (Heap Sort)</strong> 就是利用堆 (假设利用大顶堆) 进行排序的方法。它的基本思想是，<strong>将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走 (其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的 n - 1 个序列重新构造成一个堆，这样就会得到 n 个元素中的次小值。如果反复执行，便能得到一个有序序列了</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 进行堆排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = L -&gt; length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)			<span class="comment">// 把 L 中的 r 构建成一个大顶堆</span></span><br><span class="line">    HeapAdjust(L, i, L -&gt; length);</span><br><span class="line">  <span class="keyword">for</span>(i = L -&gt; length; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">    swap(L, <span class="number">1</span>, i);								<span class="comment">// 将堆顶记录和当前未经排序字序列的最后一个记录交换</span></span><br><span class="line">    HeapAdjust(L, <span class="number">1</span>, i - <span class="number">1</span>);					<span class="comment">// 将 L -&gt; r[1..i - 1] 重新调整为大顶堆</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，整个排序过程分为两个 for 循环。第一个循环要完成的就是将现在的待排序序列构建成一个大顶堆。第二个循环要完成的就是逐步将每个最大值的根结点与末尾元素交换，并且再调整其成为大顶堆。</p>
<p>假设要排序的序列是 {50, 10, 90, 30, 70, 40, 80, 60, 20}，那么 L.length &#x3D; 9，第一个 for 循环，代码第 4 行，i 是从 9 &#x2F; 2 &#x3D; 4 开始，4 → 3 → 2 → 1 的变量变化。为什么不是从 1 到 9 或者从 9 到 1，而是从 4 到 1 呢？看了下图就明白了，他们都是有孩子的结点。注意灰色结点的下标编号就是 1、2、3、4。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%A0%86%E6%8E%92%E5%BA%8F.png" alt="堆排序"></p>
<p>所谓的将待排序的序列构建称为一个大顶堆，其实就是从下往上、从右到左，将每个非终端结点 (非叶结点) 当作根结点，将其和其子树调整成大顶堆。i 的 4 → 3 → 2 → 1 的变量变化，其实也就是 30，90，10，50 的结点调整过程。</p>
<p>既然已经弄清楚 i 的变化是在调整哪些元素了，现在来看关键的 HeadAdjust (堆调整) 函数是如何实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 已知 L -&gt; r[s..m] 中记录的关键字除 L -&gt;r[s] 之外均满足堆的定义 */</span></span><br><span class="line"><span class="comment">/* 本函数调整 L -&gt; r[s] 的关键字，使 L -&gt; r[s..m] 成为一个大顶堆 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapAdjust</span><span class="params">(SqList *L, <span class="type">int</span> s, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">  <span class="type">int</span> temp, j;</span><br><span class="line">  temp = L -&gt; r[s];</span><br><span class="line">  <span class="keyword">for</span>(j = <span class="number">2</span> * s; j &lt;= m; j *= <span class="number">2</span>) &#123;				<span class="comment">// 沿关键字较大的孩子结点向下筛选</span></span><br><span class="line">    <span class="keyword">if</span>(j &lt; m &amp;&amp; L -&gt; r[j] &lt; L -&gt; r[j + <span class="number">1</span>])</span><br><span class="line">      ++j;										<span class="comment">// j 为关键字中较大的记录的下标</span></span><br><span class="line">    <span class="keyword">if</span>(temp &gt;= L -&gt; r[j])</span><br><span class="line">      <span class="keyword">break</span>;									<span class="comment">// rc 应插入在位置 s 上</span></span><br><span class="line">    L -&gt; r[s] = L -&gt; r[j];</span><br><span class="line">    s = j;</span><br><span class="line">  &#125;</span><br><span class="line">  L -&gt; r[s] = temp;								<span class="comment">// 插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆排序复杂度分析"><a href="#堆排序复杂度分析" class="headerlink" title="堆排序复杂度分析"></a>堆排序复杂度分析</h4><p>它的运行时间主要是消耗在初始构建堆和在重建堆时的反复筛选上。在构建堆的过程中，因为是完全二叉树从最下层最右边的非终端结点开始构建，将它与其孩子进行比较和若有必要的互换，对于每个非终端结点来说，其实最多进行两次比较和互换操作，因此整个构建堆的时间复杂度为 O(n)。</p>
<p>在正式排序时，第 i 次取堆顶记录重建堆需要用 O(logi) 的时间 (完全二叉树的某个结点到根结点的距离为 log<sub>2</sub>i + 1)，并且须要取 n - 1 次堆顶记录，因此，重建堆的时间复杂度为 O(nlogn)。</p>
<p>所以总体来说，堆排序的时间复杂度为 O(nlogn)。由于堆排序对原始记录的排序状态并不敏感，因此它无论是最好、最坏和平均时间复杂度均为 O(nlogn)。这在性能上显然要远远好过于冒泡、简单选择、直接插入的 O(n<sup>2</sup>) 的时间复杂度了。</p>
<p>空间复杂度上，它只有一个用来交换的暂存单元，也非常不错。不过由于记录的比较与交换是跳跃式进行，因此堆排序也是一种不稳定的排序方法。另外，由于初始构建堆所需的比较次数较多，因此，它并不适合待排序序列个数较少的情况。</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="归并排序算法"><a href="#归并排序算法" class="headerlink" title="归并排序算法"></a>归并排序算法</h4><p>“归并” 一词的中文含义就是合并、并入的意思，而在数据结构中的定义是将两个或两个以上的有序表组合成一个新的有序表。</p>
<p><strong>归并排序 (Merging Sort)</strong> 就是利用归并的思想实现的排序方法。它的原理是<strong>假设初始序列含有 n 个记录，则可与看成是 n 个有序的字序列，每个字序列的长度为 1，然后两两归并，得到 ⎡n&#x2F;2⎤ (⎡x⎤ 表示不小于 x 的最小整数) 个长度为 2 或 1 的有序字序列；再两两归并，……，如此重复，直至得到一个长度为 n 的有序序列为止，这种排序方法称为 2 路归并排序</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作归并排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  MSort(L -&gt; r, L -&gt; r, <span class="number">1</span>, L -&gt; length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了与前面的排序算法同意，用了同样的参数定义 SqList *L，由于归并排序实现需要用到递归调用，因此在外封装了一个函数。假设现在要对数组 {50, 10, 90, 30, 70, 40, 80, 60, 20}  进行排序，L.length &#x3D; 9。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将 SR[s..t] 归并排序为 TR1[s..t] */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MSort</span><span class="params">(<span class="type">int</span> SR[], <span class="type">int</span> TR1[], <span class="type">int</span> s, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">  <span class="type">int</span> m;</span><br><span class="line">  <span class="type">int</span> TR2[MAXSIZE + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span>(s == t)</span><br><span class="line">    TR1[s] = SR[s];</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    m = (s + t) / <span class="number">2</span>;				<span class="comment">// 将 SR[s..t] 平分为 SR[s..m] 和 SR[m + 1..t]</span></span><br><span class="line">    MSort(SR, TR2, s, m);			<span class="comment">// 递归将 SR[s..m] 归并为有序的 TR2[s..m]</span></span><br><span class="line">    MSort(SR, TR2, m + <span class="number">1</span>, t);		<span class="comment">// 递归将 SR[m + 1..t] 归并为有序 TR2[m + 1..t]</span></span><br><span class="line">    Merge(TR2, TR1, s, m, t);		<span class="comment">// 将 TR2[s..m] 和 TR2[m + 1..t] 归并到 TR1[s..t]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Merge 函数实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将有序的 SR[i..m] 和 SR[m + 1..n] 归并为有序的 TR[i..n] */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> SR[], <span class="type">int</span>. TR[], <span class="type">int</span> i, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j, k, l;</span><br><span class="line">  <span class="keyword">for</span>(j = m + <span class="number">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++) &#123;	<span class="comment">// 将 SR 中记录由小到大并入 TR</span></span><br><span class="line">    <span class="keyword">if</span>(SR[i] &lt; SR[j])</span><br><span class="line">      TR[k] = SR[i++];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      TR[k] = SR[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i &lt;= m) &#123;</span><br><span class="line">    <span class="keyword">for</span>(l = <span class="number">0</span>; l &lt; = m - <span class="number">1</span>; l++) </span><br><span class="line">      TR[k + <span class="number">1</span>] = SR[i + <span class="number">1</span>];						<span class="comment">// 将剩余的 SR[i..m] 复制到 TR</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(j &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">for</span>(l = <span class="number">0</span>; l &lt;= n - j; l++)</span><br><span class="line">      TR[k + l] = SR[j + l];						<span class="comment">// 将剩余的 SR[j..n] 复制到 TR</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归并排序复杂度分析"><a href="#归并排序复杂度分析" class="headerlink" title="归并排序复杂度分析"></a>归并排序复杂度分析</h4><p>分析归并排序的时间复杂度，一趟归并需要将 SR[1]<del>SR[n] 中相邻的长度为 h 的有序序列进行两两归并。并将结果放到 TR1[1]</del>TR1[n] 中，这需要将待排序序列中的所有记录扫描一遍，因此耗费 O(n) 时间，而由完全二叉树的深度可知，整个归并排序需要进行 ⎡log<sub>2</sub>n⎤次，因此，总的时间复杂度为 O(nlogn)，而且这是归并排序算法中最好、最坏、平均的时间性能。</p>
<p>由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为 log<sub>2</sub>n 的栈空间，因此空间复杂度 O(n + logn)。</p>
<p>另外，对代码进行仔细研究，发现 Merge 函数中有 if(SR[i] &lt; SR[j]) 语句，这就说明它需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。</p>
<p>也就是说，归并排序是一种比较占用内存，但却效率高且稳定的算法。</p>
<h4 id="非递归实现归并排序"><a href="#非递归实现归并排序" class="headerlink" title="非递归实现归并排序"></a>非递归实现归并排序</h4><p>归并排序大量引用了递归，尽管在代码上比较清晰，容易理解，但这会造成时间和空间上的性能损耗。排序追求的就是效率，有没有可能将递归转化成迭代呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作归并非递归排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort2</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span>* TR = (<span class="type">int</span>*)<span class="built_in">malloc</span>(L -&gt; length * <span class="keyword">sizeof</span>(<span class="type">int</span>));	<span class="comment">// 申请额外空间</span></span><br><span class="line">  <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(k &lt; L -&gt; length) &#123;</span><br><span class="line">    MergePass(L -&gt; r, TR, k, L -&gt; length);</span><br><span class="line">    k = <span class="number">2</span> * k;											<span class="comment">// 字序列长度加倍</span></span><br><span class="line">    MergePass(TR, L -&gt; r, k, L -&gt; length);</span><br><span class="line">    k = <span class="number">2</span> * k;											<span class="comment">// 字序列长度加倍</span></span><br><span class="line">  &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MergePass 实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将 SR[] 中相邻长度为 s 的子序列两两归并到 TR[] */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergePass</span><span class="params">(<span class="type">int</span> SR[], <span class="type">int</span> TR[], <span class="type">int</span> s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  <span class="keyword">while</span>(i &lt;= n - <span class="number">2</span> * s + <span class="number">1</span>) &#123;</span><br><span class="line">    Merge(SR, TRk i, i + s - <span class="number">1</span>, i + <span class="number">2</span> * s - <span class="number">1</span>);		<span class="comment">// 两两归并</span></span><br><span class="line">    i = i + <span class="number">2</span> * s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i &lt; n -s + <span class="number">1</span>)									<span class="comment">// 归并最后两个序列</span></span><br><span class="line">    Merge(SR, TR, i, i + s - <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">else</span>												<span class="comment">// 若最后只剩下单个子序列</span></span><br><span class="line">    <span class="keyword">for</span>(j = i; j &lt;= n; j++)		</span><br><span class="line">      TR[j] = SR[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>快速排序 (Quick Sort) 的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的</strong>。</p>
<p>假设现在要对数组 {50, 10, 90, 30, 70, 40, 80, 60, 20} 进行排序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对顺序表 L 作快速排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  QSort(L, <span class="number">1</span>, L -&gt; length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QSort</span><span class="params">(SqList *L, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pivot;</span><br><span class="line">  <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">    pivot = Partition(L, low, high);	<span class="comment">// 将 L -&gt; r[low..high] 一分为二，算出枢轴值 pivot</span></span><br><span class="line">    QSort(L, low, pivot - <span class="number">1</span>);			<span class="comment">// 对低子表递归排序</span></span><br><span class="line">    QSort(L, pivot + <span class="number">1</span>, high);			<span class="comment">// 对高子表递归排序</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这里的 <code>QSort(L, 1, L -&gt; length);</code> 中 1 和 L -&gt; length 相当于当前待排序的序列最小下标值 low 和最大下标值 high。</p>
<p>这一段代码的核心是<code>pivot = Partition(L, low, high);</code> 在执行它之前，L.r 的数组值为 {50, 10, 90, 30, 70, 40, 80, 60, 20} 。<strong>Partition 函数要做的，就是先选取当中的一个关键字</strong>，比如选择第一个关键字 50，然后**想尽办法将它放到一个位置，使得它左边的值都比它小，右边的值比它大，将这样的关键字称为枢轴 (pivot)**。</p>
<p>Partition 函数实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 交换顺序表 L 中子表的记录，使枢轴记录到位，并返回其所在位置。此时在它之前 (后) 的记录均不大 (小) 于它 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(SqList *L, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pivotkey;</span><br><span class="line">  pivotkey = L -&gt; r[low];		<span class="comment">// 用子表的第一个记录作枢轴记录</span></span><br><span class="line">  <span class="keyword">while</span>(low &lt; high) &#123;			<span class="comment">// 从表的两端交替向中间扫描</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; L -&gt; r[high] &gt;= pivotkey)</span><br><span class="line">      high--;</span><br><span class="line">    swap(L, low, high);			<span class="comment">// 将比枢轴记录小的记录交换到低端</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; L -&gt; r[low] &lt;= pivotkey)</span><br><span class="line">      low++;</span><br><span class="line">    swap(L, low, high);			<span class="comment">// 将比枢轴记录大的记录交换到高端</span></span><br><span class="line">  &#125;		</span><br><span class="line">  <span class="keyword">return</span> low;					<span class="comment">// 返回枢轴所在位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序复杂度分析"><a href="#快速排序复杂度分析" class="headerlink" title="快速排序复杂度分析"></a>快速排序复杂度分析</h4><p>快速排序的时间性能取决于快速排序递归的深度，可以用递归树来描述递归算法的执行情况。{50, 10, 90, 30, 70, 40, 80, 60, 20} 在快速排序过程中，第一个关键字是 50，正好是待排序的序列的中间值，因此递归树是平衡的，此时性能也比较好。如下图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.png" alt="快速排序复杂度分析"></p>
<p>在最优情况下，Partition 每次都划分得很均匀，如果排序 n 个关键字，其递归树的深度就为 ⎣log<sub>2</sub>n⎦+ 1 (⎣x⎦表示不大于 x 的最大整数)，即仅需递归 log<sub>2</sub>n 次，需要时间为 T(n) 的话，第一次 Partition 应该是需要对整个数组扫描一遍，作 n 次比较。然后，获得的枢轴将数组一分为二，那么各自还需要 T(n &#x2F; 2) 的时间 (注意是最好情况，所以平分两半)。于是不断地划分下去。也就是说，在最优的情况下，快速排序算法的时间复杂度为 O(nlogn)。</p>
<p>在最坏的情况下，待排序的序列为正序或逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。如果递归树画出来，他就是一棵斜树。此时需要执行 n - 1 次递归调用，且第 i 次划分需要经过 n - 1 次关键字的比较才能找到第 i 个记录，也就是枢轴的位置，因此比较次数为 n(n - 1) &#x2F; 2，最终其时间复杂度为 O(n<sup>2</sup>)。</p>
<p>平均的情况，设枢轴的关键字应该在第 k 的位置 (1 ≤ k ≤ n)，由数学归纳法可证明，其数量级为 O(nlogn)。</p>
<p>就空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归树的深度为 log<sub>2</sub>n，其空间复杂度也就为 O(logn)，最坏情况，需要进行 n - 1 递归调用，其空间复杂度为 O(n)，平均情况，空间复杂度也为 O(logn)。</p>
<p>可惜的是，由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。</p>
<h4 id="快速排序优化"><a href="#快速排序优化" class="headerlink" title="快速排序优化"></a>快速排序优化</h4><ol>
<li><p><strong>优化选取枢轴</strong></p>
<p> 三数取中 (median-of-three) 法。即取三个关键字先进性排序，将中间数作为枢轴，一般是取左端、右端和中间三个数，也可以随机选取。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pivotkey;</span><br><span class="line"><span class="type">int</span> m = low + (high - low) / <span class="number">2</span>;		<span class="comment">// 计算数组中间的元素的下标</span></span><br><span class="line"><span class="keyword">if</span>(L -&gt; r[low] &gt; L -&gt; r[high])</span><br><span class="line">  swap(L, low, high);				<span class="comment">// 交换左端与右端数据，保证左端较小</span></span><br><span class="line"><span class="keyword">if</span>(L -&gt; r[m] &gt; L -&gt; r[high])</span><br><span class="line">  swap(L, high, m);					<span class="comment">// 交换中间与右端数据，保证中间较小</span></span><br><span class="line"><span class="keyword">if</span>(L -&gt; r[m] &gt; L -&gt; r[low])</span><br><span class="line">  swap(L, m, low);					<span class="comment">// 交换中间与左端数据，保证左端较小。此时 L.r[low] 已经为整个序列左中右三个关键字的中间值</span></span><br><span class="line">piovtkey = L -&gt; r[low];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优化不必要的交换</strong></p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 快速排序优化算法 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition1</span><span class="params">(SqList *L, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pivotkey;</span><br><span class="line">  <span class="comment">// 这里省略三数取中代码</span></span><br><span class="line">  piovtkey = L -&gt; r[low];			<span class="comment">// 用子表的第一个记录作枢轴记录</span></span><br><span class="line">  L -&gt; r[<span class="number">0</span>] = pivotkey;				<span class="comment">// 将枢轴关键字备份到 L -&gt; r[0]</span></span><br><span class="line">  <span class="keyword">while</span>(low &lt; high) &#123;				<span class="comment">// 从表的两端交替向中间扫描</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; L -&gt; r[high] &gt;= pivotkey)</span><br><span class="line">      high--;</span><br><span class="line">    L -&gt; r[low] = L -&gt; r[high];		<span class="comment">// 采用替换而不是交换的方式进行操作</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; L -&gt; r[low] &lt;= pivotkey)</span><br><span class="line">      low++;</span><br><span class="line">    L -&gt; r[high] = L -&gt; r[low];		<span class="comment">// 采用替换而不是交换的方式进行操作</span></span><br><span class="line">  &#125;</span><br><span class="line">  L -&gt; r[low] = L -&gt; r[<span class="number">0</span>];			<span class="comment">// 将枢轴数值替换回 L.r[low]</span></span><br><span class="line">  <span class="keyword">return</span> low;						<span class="comment">// 返回枢轴所在位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优化小数组时的排序方案</strong></p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LENGTH_INSERT_SORT 7				<span class="comment">// 数组长度阀值</span></span></span><br><span class="line"><span class="comment">/* 对顺序表 L 中的子序列 L.r[low..high] 作快速排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pivot;</span><br><span class="line">  <span class="keyword">if</span>((high - low) &gt; MAX_LENGTH_INSERT_SORT) &#123;	<span class="comment">// 当 high - low 大于常数时用快速排序</span></span><br><span class="line">    pivot = Partition(L, low, high);			<span class="comment">// 将 L.r[low..high] 一分为二，并算出枢轴值 pivot</span></span><br><span class="line">    QSort(L, low, pivot - <span class="number">1</span>);					<span class="comment">// 对低子表递归排序</span></span><br><span class="line">    QSort(L, pivot + <span class="number">1</span>, high);					<span class="comment">// 对高子表递归排序</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>											<span class="comment">// 当 high - low 小于等于常数时用直接插入排序</span></span><br><span class="line">    InsertSort(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 增加了一个判断，当 high - low 不大于某个常数时，就用直接插入排序，这样就能保证最大化地利用两种排序的优势来完成排序工作。</p>
</li>
<li><p><strong>优化递归操作</strong></p>
<p> 递归对性能是有一定影响的，SQort 函数在其尾部有两次递归操作。如果待排序的序列划分极端不平衡，递归深度将趋近于 n，而不是平衡时的 log<sub>2</sub>n，这就不仅仅是速度快慢的问题了。栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。因此如果能减少递归，将会大大提高性能。</p>
<p> 对 QSort 实施<strong>尾递归</strong>优化：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 中的子序列 L.r[low..high] 作快速排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Qsort1</span><span class="params">(SqList *L, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pivot；</span><br><span class="line">  <span class="keyword">if</span>((high - low) &gt; MAX_LENGTH_INSERT_SORT) &#123;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">      pivot = Partition1(L, low, high);		<span class="comment">// L.r[low..high] 一分为二，算出枢轴值 pivot</span></span><br><span class="line">      QSort1(L, low, pivot - <span class="number">1</span>);				<span class="comment">// 对低子表递归排序</span></span><br><span class="line">      low = pivot + <span class="number">1</span>;						<span class="comment">// 尾递归</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    InsertSort(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 当将 if 改成 while 后，因为第一次递归后，变量 low 就没有用处了，所以可以讲 pivot + 1 赋值给 low，再循环后，来一次 <code>Partition(L, low, hith)</code>，其效果等同于 <code>QSort(L, pivot + 1, high)</code>。结果相同，但因采用迭代而不是递归的方法可以缩减堆栈深度，从而提高了整体性能。</p>
</li>
<li><p><strong>了不起的排序算法</strong></p>
<p> 以上算法中，有按照实现方法分类命名的，如简单选择排序、直接插入排序、归并排序，有按照其排序的方式类比现实世界命名的，比如冒泡排序、堆排序，还有用人命命名的，比如希尔排序。但是快速排序却用“快速”命名，也就意味着只要再有人找到更好的排序法，此“快速”就会名不符实，不过，至少今天，TonyHoare 发明的快速排序法经过多次的优化后，在整体性能上，依然是排序算法王者。</p>
</li>
</ol>
<h3 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h3><p>首先根据排序的定义，提到了排序的稳定性，排序稳定对于某些特殊需求来说是至关重要的，因此在排序算法中国呢，需要关注此算法的稳定性如何。</p>
<p>根据将排序记录是否全部被放置在内存中，将排序分为内排序与外排序两种，外排序需要在内外存之间多次交换数据才能进行。</p>
<p>根据排序过程中借助的主要操作，将内排序分为：插入排序、交换排序、选择排序和归并排序四类。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/dsa/%E6%8E%92%E5%BA%8F.png" alt="排序"></p>
<p>事实上，目前还没有十全十美的排序算法，有优点就会有缺点，即使是快速排序法，也只是在整体性能上优越了，它也存在排序不稳定、需要大量辅助空间、对少量数据排序无优势等不足。</p>
<p>将 7 中算法的各种指标进行对比，如下表。</p>
<table>
<thead>
<tr>
<th align="center">排序方法</th>
<th align="center">平均情况</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">辅助空间</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">简单选择排序</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">直接插入排序</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">O(nlogn)~O(n<sup>2</sup>)</td>
<td align="center">O(n<sup>13</sup>)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(n)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(nlogn)</td>
<td align="center">O(nlogn)</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(logn)~O(n)</td>
<td align="center">不稳定</td>
</tr>
</tbody></table>
<p>从算法的简单性来看，将 7 种算法分为两类：</p>
<ul>
<li>简单算法：冒泡、简单选择、直接插入</li>
<li>改进算法：希尔、堆、归并、快速</li>
</ul>
<p>从平均情况来看，显然最后 3 种改进算法要胜过希尔排序，并远远胜过前 3 种简单算法。</p>
<p>从最好情况看，反而冒泡和直接插入排序要更胜一筹，也就是说，如果待排序序列总是基本有序，反而不应该考虑 4 种复杂的改进算法。</p>
<p>从最坏情况看，堆排序与归并排序又强过快速排序以及其它简单排序。</p>
<p>从这三组时间复杂度的数据对比中，可以得出这样一个人时。堆排序和归并排序就像两个参加奥数考试的优等生，心理素质强，发挥稳定。而快速排序像是很情绪化的天才，心情好时表现极佳，碰到较糟糕环境会变得差强人意。但是他们如果都来比赛计算个位数的加减法，他们反而算不过成绩普通的冒泡和直接插入。</p>
<p>从空间复杂度来说，归并排序强调要马跑得快，就得给马吃个饱。快速排序也有相应的空间要求，反而堆排序等却都是少量索取，大量付出，对空间要求是 O(1)。如果执行算法的软件所处的环境非常在乎内存使用量的多少，选择归并排序和快速排序就不是一个较好的决策了。</p>
<p>从稳定性来看，归并排序独占鳌头，对于非常在乎排序稳定性的应用中，归并排序是个好算法。</p>
<p>从待排序记录的个数上来说，待排序的个数 n 越小，采用简单排序方法越合适。反之，n 越大，采用改进排序方法越合适。这也就是为什么对快速排序优化时，增加了一个阀值，低于阀值时换作直接插入排序的原因。</p>
<p>从下表的数据中，似乎简单选择排序在 3 种简单排序中性能最差，其实也不完全是，比如，如果记录的关键字本身信息量比较大 (例如，关键字都是数十位的数字)，此时表明占用存储空间很大，这样移动记录所花费的时间也越多。下表是 3 中简单排序算法的移动次数比较。</p>
<table>
<thead>
<tr>
<th align="center">排序方法</th>
<th align="center">平均情况</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">0</td>
<td align="center">O(n<sup>2</sup>)</td>
</tr>
<tr>
<td align="center">简单选择排序</td>
<td align="center">O(n)</td>
<td align="center">0</td>
<td align="center">O(n)</td>
</tr>
<tr>
<td align="center">直接插入排序</td>
<td align="center">O(n<sup>2</sup>)</td>
<td align="center">O(n)</td>
<td align="center">O(n<sup>2</sup>)</td>
</tr>
</tbody></table>
<p>会发现，此时简单选择排序就变得非常有优势，原因在于它是通过大量比较厚选择明确记录进行移动，有的放矢。因此对于数据量不是很大而记录的关键字信息量较大的排序要求，简单排序算法是占优的。另外，记录的关键字信息量大小对那四个改进算法影响不大。</p>
<p>总之，从综合各项指标来说，经过优化的快速排序是性能最好的排序算法，但是不同的场合也应该考虑使用不同的算法来应对。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="/img/cover.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/25/mysql-basic/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL 基础</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/31/operatingSystem/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">数据结构绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念和术语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.1.</span> <span class="toc-text">数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.2.</span> <span class="toc-text">数据元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B9"><span class="toc-number">1.1.3.</span> <span class="toc-text">数据项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.4.</span> <span class="toc-text">数据对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.5.</span> <span class="toc-text">数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">逻辑结构与物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">逻辑结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">物理结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">抽象数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">抽象数据类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.1.</span> <span class="toc-text">两种算法的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.</span> <span class="toc-text">算法的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">2.3.</span> <span class="toc-text">算法的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">2.3.1.</span> <span class="toc-text">输入输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%A9%B7%E6%80%A7"><span class="toc-number">2.3.2.</span> <span class="toc-text">有穷性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%80%A7"><span class="toc-number">2.3.3.</span> <span class="toc-text">确定性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A1%8C%E6%80%A7"><span class="toc-number">2.3.4.</span> <span class="toc-text">可行性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">2.4.</span> <span class="toc-text">算法设计的要求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="toc-number">2.4.1.</span> <span class="toc-text">正确性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%AF%BB%E6%80%A7"><span class="toc-number">2.4.2.</span> <span class="toc-text">可读性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%A5%E5%A3%AE%E6%80%A7"><span class="toc-number">2.4.3.</span> <span class="toc-text">健壮性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%95%88%E7%8E%87%E9%AB%98%E5%92%8C%E5%AD%98%E5%82%A8%E9%87%8F%E4%BD%8E"><span class="toc-number">2.4.4.</span> <span class="toc-text">时间效率高和存储量低</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">算法效率的度量方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%90%8E%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.1.</span> <span class="toc-text">事后统计方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%89%8D%E5%88%86%E6%9E%90%E4%BC%B0%E7%AE%97%E6%B3%95"><span class="toc-number">2.5.2.</span> <span class="toc-text">事前分析估算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E6%B8%90%E8%BF%91%E5%A2%9E%E9%95%BF"><span class="toc-number">2.6.</span> <span class="toc-text">函数的渐近增长</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.7.</span> <span class="toc-text">算法时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AE%9A%E4%B9%89"><span class="toc-number">2.7.1.</span> <span class="toc-text">算法时间复杂度定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E5%A4%A7-O-%E9%98%B6%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.2.</span> <span class="toc-text">推导大 O 阶方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E6%95%B0%E9%98%B6"><span class="toc-number">2.7.3.</span> <span class="toc-text">常数阶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E9%98%B6"><span class="toc-number">2.7.4.</span> <span class="toc-text">线性阶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E6%95%B0%E9%98%B6-1"><span class="toc-number">2.7.5.</span> <span class="toc-text">常数阶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E6%96%B9%E9%98%B6"><span class="toc-number">2.7.6.</span> <span class="toc-text">平方阶</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.8.</span> <span class="toc-text">常见的时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E4%B8%8E%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5"><span class="toc-number">2.9.</span> <span class="toc-text">最坏情况与平均情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.10.</span> <span class="toc-text">算法空间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">2.11.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">线性表的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">线性表的抽象数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text">线性表的顺序存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9A%E4%B9%89"><span class="toc-number">3.3.1.</span> <span class="toc-text">顺序存储定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.2.</span> <span class="toc-text">顺序存储方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6%E4%BA%8E%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%95%BF%E5%BA%A6%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.3.</span> <span class="toc-text">数据长度于线性表长度区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.4.</span> <span class="toc-text">地址计算方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">3.4.</span> <span class="toc-text">顺序存储结构的插入和删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.1.</span> <span class="toc-text">获得元素操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.2.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.3.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.4.4.</span> <span class="toc-text">线性表顺序存储结构的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.5.</span> <span class="toc-text">线性表的链式存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.5.1.</span> <span class="toc-text">线性表链式存储结构定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%8C%87%E9%92%88%E5%9F%9F%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">3.5.2.</span> <span class="toc-text">头指针域头结点的异同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81%E6%8F%8F%E8%BF%B0"><span class="toc-number">3.5.3.</span> <span class="toc-text">线性表链式存储结构代码描述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-number">3.6.</span> <span class="toc-text">单链表的读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">3.7.</span> <span class="toc-text">单链表的插入和删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">3.7.1.</span> <span class="toc-text">单链表的插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">3.7.2.</span> <span class="toc-text">单链表的删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E5%88%9B%E5%BB%BA"><span class="toc-number">3.8.</span> <span class="toc-text">单链表的整表创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E5%88%A0%E9%99%A4"><span class="toc-number">3.9.</span> <span class="toc-text">单链表的整表删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.10.</span> <span class="toc-text">单链表结构与顺序存储结构优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">3.11.</span> <span class="toc-text">静态链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">3.11.1.</span> <span class="toc-text">静态链表的插入操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">3.11.2.</span> <span class="toc-text">静态链表的删除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.11.3.</span> <span class="toc-text">静态链表的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">3.12.</span> <span class="toc-text">循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">3.13.</span> <span class="toc-text">双向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">3.14.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.</span> <span class="toc-text">栈的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89-1"><span class="toc-number">4.1.1.</span> <span class="toc-text">栈的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E6%A0%88%E5%87%BA%E6%A0%88%E5%8F%98%E5%8C%96%E5%BD%A2%E5%BC%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">进栈出栈变化形式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">栈的抽象数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.</span> <span class="toc-text">栈的顺序存储结构及实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.1.</span> <span class="toc-text">栈的顺序存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.2.</span> <span class="toc-text">栈的顺序存储结构——进栈操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.3.</span> <span class="toc-text">栈的顺序存储结构——出栈操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4"><span class="toc-number">4.4.</span> <span class="toc-text">两栈共享空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.5.</span> <span class="toc-text">栈的链式存储结构及实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.5.1.</span> <span class="toc-text">栈的链式存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%BF%9B%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-number">4.5.2.</span> <span class="toc-text">栈的链式存储结构——进栈操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-number">4.5.3.</span> <span class="toc-text">栈的链式存储结构——出栈操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.6.</span> <span class="toc-text">栈的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E9%80%92%E5%BD%92"><span class="toc-number">4.7.</span> <span class="toc-text">栈的应用——递归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.7.1.</span> <span class="toc-text">斐波那契数列实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.7.2.</span> <span class="toc-text">递归的定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.8.</span> <span class="toc-text">队列的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.9.</span> <span class="toc-text">队列的抽象数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.10.</span> <span class="toc-text">循环队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="toc-number">4.10.1.</span> <span class="toc-text">队列顺序存储的不足</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%AE%9A%E4%B9%89"><span class="toc-number">4.10.2.</span> <span class="toc-text">循环队列定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.11.</span> <span class="toc-text">队列的链式存储结构及实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C"><span class="toc-number">4.11.1.</span> <span class="toc-text">队列的链式存储结构——入队操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C"><span class="toc-number">4.11.2.</span> <span class="toc-text">队列的链式存储结构——出队操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">4.12.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2"><span class="toc-number">5.</span> <span class="toc-text">串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">串的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">5.2.</span> <span class="toc-text">串的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.</span> <span class="toc-text">串的抽象数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.</span> <span class="toc-text">串的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.1.</span> <span class="toc-text">串的顺序存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.2.</span> <span class="toc-text">串的链式存储结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">5.5.</span> <span class="toc-text">朴素的模式匹配算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KMP-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">5.6.</span> <span class="toc-text">KMP 模式匹配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KMP-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">5.6.1.</span> <span class="toc-text">KMP 模式匹配算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#next-%E6%95%B0%E7%BB%84%E5%80%BC%E6%8E%A8%E5%AF%BC"><span class="toc-number">5.6.2.</span> <span class="toc-text">next 数组值推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KMP-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.6.3.</span> <span class="toc-text">KMP 模式匹配算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KMP-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E6%94%B9%E8%BF%9B"><span class="toc-number">5.6.4.</span> <span class="toc-text">KMP 模式匹配算法改进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nextval-%E6%95%B0%E7%BB%84%E5%80%BC%E6%8E%A8%E5%AF%BC"><span class="toc-number">5.6.5.</span> <span class="toc-text">nextval 数组值推导</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-number">5.7.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.</span> <span class="toc-text">树的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%E5%88%86%E7%B1%BB"><span class="toc-number">6.1.1.</span> <span class="toc-text">结点分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-number">6.1.2.</span> <span class="toc-text">结点间关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%85%B6%E5%AE%83%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.3.</span> <span class="toc-text">树的其它相关概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">树的抽象数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.3.</span> <span class="toc-text">树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">6.3.1.</span> <span class="toc-text">双亲表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">6.3.2.</span> <span class="toc-text">孩子表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">6.3.3.</span> <span class="toc-text">孩子兄弟表示法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.4.</span> <span class="toc-text">二叉树的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">6.4.1.</span> <span class="toc-text">二叉树的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.4.2.</span> <span class="toc-text">特殊二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">6.5.</span> <span class="toc-text">二叉树的性质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8-1"><span class="toc-number">6.5.1.</span> <span class="toc-text">性质 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8-2"><span class="toc-number">6.5.2.</span> <span class="toc-text">性质 2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8-3"><span class="toc-number">6.5.3.</span> <span class="toc-text">性质 3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8-4"><span class="toc-number">6.5.4.</span> <span class="toc-text">性质 4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8-5"><span class="toc-number">6.5.5.</span> <span class="toc-text">性质 5</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.6.</span> <span class="toc-text">二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.6.1.</span> <span class="toc-text">二叉树顺序存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="toc-number">6.6.2.</span> <span class="toc-text">二叉链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.7.</span> <span class="toc-text">遍历二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-number">6.7.1.</span> <span class="toc-text">二叉树遍历方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">6.7.2.</span> <span class="toc-text">前序遍历算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">6.7.3.</span> <span class="toc-text">中序遍历算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">6.7.4.</span> <span class="toc-text">后序遍历算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C"><span class="toc-number">6.7.5.</span> <span class="toc-text">推导遍历结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">6.8.</span> <span class="toc-text">二叉树的建立</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.9.</span> <span class="toc-text">线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8E%9F%E7%90%86"><span class="toc-number">6.9.1.</span> <span class="toc-text">线索二叉树原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.9.2.</span> <span class="toc-text">线索二叉树结构实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.10.</span> <span class="toc-text">树、森林与二叉树的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.10.1.</span> <span class="toc-text">树转换为二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.10.2.</span> <span class="toc-text">森林转换为二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A0%91"><span class="toc-number">6.10.3.</span> <span class="toc-text">二叉树转换为树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A3%AE%E6%9E%97"><span class="toc-number">6.10.4.</span> <span class="toc-text">二叉树转换为森林</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">6.10.5.</span> <span class="toc-text">树与森林的遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="toc-number">6.11.</span> <span class="toc-text">赫夫曼树及其应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">6.11.1.</span> <span class="toc-text">赫夫曼树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-number">6.11.2.</span> <span class="toc-text">赫夫曼树定义与原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">6.11.3.</span> <span class="toc-text">赫夫曼编码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="toc-number">6.12.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">7.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">7.1.</span> <span class="toc-text">图的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%9B%BE%E5%AE%9A%E4%B9%89"><span class="toc-number">7.1.1.</span> <span class="toc-text">各种图定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%A1%B6%E7%82%B9%E4%B8%8E%E8%BE%B9%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-number">7.1.2.</span> <span class="toc-text">图的顶点与边间关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="toc-number">7.1.3.</span> <span class="toc-text">连通图相关术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%9C%AF%E8%AF%AD%E6%80%BB%E7%BB%93"><span class="toc-number">7.1.4.</span> <span class="toc-text">图的定义与术语总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.2.</span> <span class="toc-text">图的抽象数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">7.3.</span> <span class="toc-text">图的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">7.3.1.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">7.3.2.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="toc-number">7.3.3.</span> <span class="toc-text">十字链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="toc-number">7.3.4.</span> <span class="toc-text">邻接多重表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E9%9B%86%E6%95%B0%E7%BB%84"><span class="toc-number">7.3.5.</span> <span class="toc-text">边集数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">7.4.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">7.4.1.</span> <span class="toc-text">深度优先遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">7.4.2.</span> <span class="toc-text">广度优先遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">7.5.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%87%8C%E5%A7%86-Prim-%E7%AE%97%E6%B3%95"><span class="toc-number">7.5.1.</span> <span class="toc-text">普里姆 (Prim) 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94-Kruskal-%E7%AE%97%E6%B3%95"><span class="toc-number">7.5.2.</span> <span class="toc-text">克鲁斯卡尔 (Kruskal) 算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">7.6.</span> <span class="toc-text">最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89-Dijkstra-%E7%AE%97%E6%B3%95"><span class="toc-number">7.6.1.</span> <span class="toc-text">迪杰斯特拉 (Dijkstra) 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9B%E6%B4%9B%E4%BE%9D%E5%BE%B7-Floyd-%E7%AE%97%E6%B3%95"><span class="toc-number">7.6.2.</span> <span class="toc-text">佛洛依德 (Floyd) 算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">7.7.</span> <span class="toc-text">拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.7.1.</span> <span class="toc-text">拓扑排序介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">7.7.2.</span> <span class="toc-text">拓扑排序算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">7.8.</span> <span class="toc-text">关键路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">7.8.1.</span> <span class="toc-text">关键路径算法原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-number">7.8.2.</span> <span class="toc-text">关键路径算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-6"><span class="toc-number">7.9.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">8.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%A6%82%E8%AE%BA"><span class="toc-number">8.1.</span> <span class="toc-text">查找概论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE"><span class="toc-number">8.2.</span> <span class="toc-text">顺序表查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">8.2.1.</span> <span class="toc-text">顺序表查找算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE%E4%BC%98%E5%8C%96"><span class="toc-number">8.2.2.</span> <span class="toc-text">顺序表查找优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE"><span class="toc-number">8.3.</span> <span class="toc-text">有序表查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">8.3.1.</span> <span class="toc-text">折半查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="toc-number">8.3.2.</span> <span class="toc-text">插值查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE"><span class="toc-number">8.3.3.</span> <span class="toc-text">斐波那契查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE"><span class="toc-number">8.4.</span> <span class="toc-text">线性索引查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%A0%E5%AF%86%E7%B4%A2%E5%BC%95"><span class="toc-number">8.4.1.</span> <span class="toc-text">稠密索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E7%B4%A2%E5%BC%95"><span class="toc-number">8.4.2.</span> <span class="toc-text">分块索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95"><span class="toc-number">8.4.3.</span> <span class="toc-text">倒排索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">8.5.</span> <span class="toc-text">二叉排序树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="toc-number">8.5.1.</span> <span class="toc-text">二叉排序树查找操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">8.5.2.</span> <span class="toc-text">二叉排序树插入操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">8.5.3.</span> <span class="toc-text">二叉排序树删除操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E6%80%BB%E7%BB%93"><span class="toc-number">8.5.4.</span> <span class="toc-text">二叉排序树总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-AVL-%E6%A0%91"><span class="toc-number">8.6.</span> <span class="toc-text">平衡二叉树 (AVL 树)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">8.6.1.</span> <span class="toc-text">平衡二叉树实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95"><span class="toc-number">8.6.2.</span> <span class="toc-text">平衡二叉树的实现算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91-B-%E6%A0%91"><span class="toc-number">8.7.</span> <span class="toc-text">多路查找树 (B 树)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%A0%91"><span class="toc-number">8.7.1.</span> <span class="toc-text">2-3 树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">8.7.2.</span> <span class="toc-text">B 树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91-1"><span class="toc-number">8.7.3.</span> <span class="toc-text">B+ 树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE-%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%A6%82%E8%BF%B0"><span class="toc-number">8.8.</span> <span class="toc-text">散列表查找 (哈希表) 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%E5%AE%9A%E4%B9%89"><span class="toc-number">8.8.1.</span> <span class="toc-text">散列表查找定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%E6%AD%A5%E9%AA%A4"><span class="toc-number">8.8.2.</span> <span class="toc-text">散列表查找步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">8.9.</span> <span class="toc-text">散列函数的构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="toc-number">8.9.1.</span> <span class="toc-text">直接定址法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">8.9.2.</span> <span class="toc-text">数字分析法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95"><span class="toc-number">8.9.3.</span> <span class="toc-text">平方取中法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%8F%A0%E6%B3%95"><span class="toc-number">8.9.4.</span> <span class="toc-text">折叠法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95"><span class="toc-number">8.9.5.</span> <span class="toc-text">除留余数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%B3%95"><span class="toc-number">8.9.6.</span> <span class="toc-text">随机数法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">8.10.</span> <span class="toc-text">处理散列冲突的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="toc-number">8.10.1.</span> <span class="toc-text">开放定址法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%8D%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E6%B3%95"><span class="toc-number">8.10.2.</span> <span class="toc-text">再散列函数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="toc-number">8.10.3.</span> <span class="toc-text">链地址法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E6%BA%A2%E5%87%BA%E5%8C%BA%E6%B3%95"><span class="toc-number">8.10.4.</span> <span class="toc-text">公共溢出区法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.11.</span> <span class="toc-text">散列表查找实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.11.1.</span> <span class="toc-text">散列表查找算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">8.11.2.</span> <span class="toc-text">散列表查找性能分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-7"><span class="toc-number">8.12.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">9.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-number">9.1.</span> <span class="toc-text">排序的基本概念与分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">9.1.1.</span> <span class="toc-text">排序的稳定性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%A4%96%E6%8E%92%E5%BA%8F"><span class="toc-number">9.1.2.</span> <span class="toc-text">内排序与外排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%94%A8%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.3.</span> <span class="toc-text">排序用到的结构与函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">9.2.</span> <span class="toc-text">冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.2.1.</span> <span class="toc-text">最简单排序实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">9.2.2.</span> <span class="toc-text">冒泡排序算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-number">9.2.3.</span> <span class="toc-text">冒泡排序优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">9.2.4.</span> <span class="toc-text">冒泡排序复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">9.3.</span> <span class="toc-text">简单选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">9.3.1.</span> <span class="toc-text">简单选择排序算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">9.3.2.</span> <span class="toc-text">简单选择排序复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">9.4.</span> <span class="toc-text">直接插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">9.4.1.</span> <span class="toc-text">直接插入排序算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">9.4.2.</span> <span class="toc-text">直接插入排序复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">9.5.</span> <span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">9.5.1.</span> <span class="toc-text">希尔排序算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">9.5.2.</span> <span class="toc-text">希尔排序复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">9.6.</span> <span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">9.6.1.</span> <span class="toc-text">堆排序算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">9.6.2.</span> <span class="toc-text">堆排序复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">9.7.</span> <span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">9.7.1.</span> <span class="toc-text">归并排序算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">9.7.2.</span> <span class="toc-text">归并排序复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">9.7.3.</span> <span class="toc-text">非递归实现归并排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">9.8.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">9.8.1.</span> <span class="toc-text">快速排序复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-number">9.8.2.</span> <span class="toc-text">快速排序优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-8"><span class="toc-number">9.9.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Zhang Jian</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'd8ef7a65db7c4006a56ac333e3160913';
  var gaud_map_key = 'b08b224a212eea586a32bbcc5605bbe4';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 570px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 480px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(/img/cover1.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Spring/&quot;);" href="javascript:void(0);">Spring</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">Spring 全家桶</span></li><li class="categoryBar-list-item" style="background:url(/img/cover2.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Linux/&quot;);" href="javascript:void(0);">Linux</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">Linux 操作系统</span></li><li class="categoryBar-list-item" style="background:url(/img/cover3.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机网络/&quot;);" href="javascript:void(0);">计算机网络</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">计算机网络知识体系</span></li><li class="categoryBar-list-item" style="background:url(/img/cover4.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/其他/&quot;);" href="javascript:void(0);">其他</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">其他文档集合</span></li><li class="categoryBar-list-item" style="background:url(/img/cover6.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java/&quot;);" href="javascript:void(0);">Java</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr">Java 知识</span></li><li class="categoryBar-list-item" style="background:url(/img/cover4.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/中间件/&quot;);" href="javascript:void(0);">中间件</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">数据结构与算法</span></li><li class="categoryBar-list-item" style="background:url(/img/cover5.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据结构与算法/&quot;);" href="javascript:void(0);">数据结构与算法</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">海量中间件</span></li><li class="categoryBar-list-item" style="background:url(/img/cover6.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据库/&quot;);" href="javascript:void(0);">数据库</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">关系型数据库和非关系型数据库</span></li><li class="categoryBar-list-item" style="background:url(/img/cover5.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/操作系统/&quot;);" href="javascript:void(0);">操作系统</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">操作系统知识</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/12/12/Spring/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../img/spring/spring.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-12-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/12/12/Spring/&quot;);" href="javascript:void(0);" alt="">Spring</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/12/12/Spring/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/11/28/kafka/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../img/kafka/封面.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-28</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/11/28/kafka/&quot;);" href="javascript:void(0);" alt="">Kafka</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/11/28/kafka/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/about/'|| '/about/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar.fomal.cc/api?zhangjianGorilla",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'zhangjianGorilla')
    }
  </script><!-- hexo injector body_end end --></body></html>