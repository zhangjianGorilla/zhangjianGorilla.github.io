<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>MySQL 进阶 | 个人文档</title><meta name="author" content="Zhang Jian"><meta name="copyright" content="Zhang Jian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="一、用户与权限管理1. 用户管理MySQL 用户可以分为普通 用户和 root 用户。root 用户是超级管理员，拥有所有权限，包括创建用户、删除用户和修改用户的密码等管理权限；普通用户只拥有被授予的各种权限。 MySQL 提供了许多语句用来管理用户账号，这些语句可以用来管理包括登录和退出 MySQL 服务器、创建用户、删除用户、密码管理和权限管理等内容。 1.1 登录 MySQL 服务器启动 M">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL 进阶">
<meta property="og:url" content="http://example.com/2022/10/31/mysql-advanced/index.html">
<meta property="og:site_name" content="个人文档">
<meta property="og:description" content="一、用户与权限管理1. 用户管理MySQL 用户可以分为普通 用户和 root 用户。root 用户是超级管理员，拥有所有权限，包括创建用户、删除用户和修改用户的密码等管理权限；普通用户只拥有被授予的各种权限。 MySQL 提供了许多语句用来管理用户账号，这些语句可以用来管理包括登录和退出 MySQL 服务器、创建用户、删除用户、密码管理和权限管理等内容。 1.1 登录 MySQL 服务器启动 M">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://1.117.162.142:9000/blog/cover.jpeg">
<meta property="article:published_time" content="2022-10-31T01:58:40.000Z">
<meta property="article:modified_time" content="2023-02-01T03:53:58.636Z">
<meta property="article:author" content="Zhang Jian">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://1.117.162.142:9000/blog/cover.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/10/31/mysql-advanced/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL 进阶',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-01 11:53:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/avatar.jpg%2020-56-02-100.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://1.117.162.142:9000/blog/cover.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">个人文档</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL 进阶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-31T01:58:40.000Z" title="发表于 2022-10-31 09:58:40">2022-10-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-01T03:53:58.636Z" title="更新于 2023-02-01 11:53:58">2023-02-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">160k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>532分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL 进阶"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一、用户与权限管理"><a href="#一、用户与权限管理" class="headerlink" title="一、用户与权限管理"></a>一、用户与权限管理</h2><h3 id="1-用户管理"><a href="#1-用户管理" class="headerlink" title="1. 用户管理"></a>1. 用户管理</h3><p>MySQL 用户可以分为普通 用户和 root 用户。root 用户是超级管理员，拥有所有权限，包括创建用户、删除用户和修改用户的密码等管理权限；普通用户只拥有被授予的各种权限。</p>
<p>MySQL 提供了许多语句用来管理用户账号，这些语句可以用来管理包括登录和退出 MySQL 服务器、创建用户、删除用户、密码管理和权限管理等内容。</p>
<h4 id="1-1-登录-MySQL-服务器"><a href="#1-1-登录-MySQL-服务器" class="headerlink" title="1.1 登录 MySQL 服务器"></a>1.1 登录 MySQL 服务器</h4><p>启动 MySQL 服务器后，可以通过 mysql 命令来登录服务器。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h hostname<span class="operator">|</span>hostIP <span class="operator">-</span>P port <span class="operator">-</span>u username <span class="operator">-</span>p DatabaseName <span class="operator">-</span>e &quot;SQL语句&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-h 参数</code> 后面接主机名或主机 IP，hostname 为主机，hostIP 为主机 IP。</li>
<li><code>-P 参数</code> 后面接 MySQL服务器的端口，通过该参数连接到指定的端口。MySQL 服务的默认端口是 3306，不使用该参数时自动连接到 3306 端口，port 为连接的端口号。</li>
<li><code>-u 参数</code> 后面接用户名，username 为用户名。</li>
<li><code>-p 参数</code> 会提示输入密码。</li>
<li><code>DatabaseName 参数</code> 知名登录到哪一个数据库中。如果没有该参数，就会直接登录到 MySQL 数据库中，然后可以使用 USE 命令来选择数据库。</li>
<li><code>-e 参数</code> 后面可以直接加 SQL 语句。登录 MySQL 服务器以后即可执行这个 SQL 语句，然后退出 MySQL 服务器。</li>
</ul>
<h4 id="1-2-创建用户"><a href="#1-2-创建用户" class="headerlink" title="1.2 创建用户"></a>1.2 创建用户</h4><p>在 MySQL 数据库中，官方推荐使用 <code>CREATE USER</code> 语句来创建新用户。MySQL 8 版本移除了 PASSWORD 加密方法，因此不再推荐使用 INSERT 语句直接操作 MySQL 中的 user 表来增加用户。</p>
<p>使用 <code>CREATE USER</code> 语句来创建新用户时，必须拥有 CREATE USER 权限。每添加一个用户，CREATE USER 语句会在 MySQL.user 表中添加一条新记录，但是新创建的账户没有任何权限。如果添加的账户已经存在，CREATE USER 语句就会返回一个错误。</p>
<p>CREATE USER 语句的基本语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> 用户名 [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>][, 用户名 [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>]];</span><br></pre></td></tr></table></figure>

<ul>
<li>用户名参数表示新建用户的账户，由用户 (User) 和 主机名 (Host) 构成；</li>
<li>“[]”表示可选，也就是说，可以指定用户登录时需要密码验证，也可以不指定密码验证，这样用户可以直接登录。不过，不指定密码的方式不安全，不推荐使用。如果指定密码值，这里需要使用 IDENTIFIED BY 指定明文密码值。</li>
<li>CREATE USER 语句可以同时创建多个用户。</li>
</ul>
<h4 id="1-3-修改用户"><a href="#1-3-修改用户" class="headerlink" title="1.3 修改用户"></a>1.3 修改用户</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 修改用户名</span><br><span class="line"><span class="keyword">UPDATE</span> mysql.user <span class="keyword">SET</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">USER</span> <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-删除用户"><a href="#1-4-删除用户" class="headerlink" title="1.4 删除用户"></a>1.4 删除用户</h4><p>在 MySQL 数据库中，可以使用 <code>DROP USER</code> 语句来删除普通用户，也可以直接在 mysql.user 表中删除用户。</p>
<p><strong>方式一：使用 DROP 方式删除 (推荐)</strong></p>
<p>使用 DROP USER 语句来删除用户时，必须拥有 DROP USER 权限。DROP USER 语句的基本语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="keyword">user</span>[, <span class="keyword">user</span>] ...; # 默认删除的是<span class="keyword">user</span>@<span class="operator">%</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="keyword">user</span>@<span class="string">&#x27;host&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其中，user 参数是需要删除的用户，由用户的用户名 (User) 和主机名 (Host) 组成。DROP USER 语句可以同事删除多个用户，各用户之间用逗号隔开。</p>
<p><strong>方式二：使用 DELETE 方式删除</strong></p>
<p>可以使用 DELETE 语句直接将用户的信息从 mysql.user 表中删除，但必须拥有对 mysql.user 表的 DELETE 权限。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mysql.user <span class="keyword">WHERE</span> Host<span class="operator">=</span><span class="string">&#x27;hostname&#x27;</span> <span class="keyword">AND</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;username&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>Host 字段和 User 字段是 user 表的联合主键，因此两个字段的值才能唯一确定一条记录。</p>
<p>执行完 DELETE 命令后要使用 FLUSH 命令来使用户生效，命令如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>:::tip</p>
<p>不推荐通过 <code>DELETE FROM USER u WHERE USER=&#39;&#39;;</code> 进行删除，系统会有残留信息保留。而 <code>DROP user</code> 命令会删除用户以及对应的权限，执行命令 mysql.user 表和 mysql.db 表的相应记录都消失了。</p>
<p>:::</p>
<h4 id="1-5-设置当前用户密码"><a href="#1-5-设置当前用户密码" class="headerlink" title="1.5 设置当前用户密码"></a>1.5 设置当前用户密码</h4><p>适用于 root 用户修改自己的密码，以及普通用户登录后修改自己的密码。</p>
<p>root 用户拥有很高的权限，因此必须保证 root 用户的密码安全。root 用户可以通过多种方式来修改密码，使用 ALTER USER 修改用户密码是 MySQL 官方推荐的方式。此外，也可以通过 SET 语句修改密码。由于 MySQL 8 中已移除了 PASSWORD() 函数，因此不再使用 UPDATE 语句直接操作用户表修改密码。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 旧的写法 (MySQL <span class="number">5.7</span> 测试有效)</span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="operator">=</span> PASSWORD(<span class="string">&#x27;密码&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 使用 <span class="keyword">ALTER</span> <span class="keyword">USER</span> 命令来修改当前用户密码 (推荐使用)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">USER</span>() IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;NEW_PASSWORD&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 使用 <span class="keyword">SET</span> 语句来修改当前用户密码，该语句会自动将密码加密后再赋给当前用户</span><br><span class="line"><span class="keyword">SET</span> PASSWORD<span class="operator">=</span><span class="string">&#x27;new_password&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-修改其它用户密码"><a href="#1-6-修改其它用户密码" class="headerlink" title="1.6 修改其它用户密码"></a>1.6 修改其它用户密码</h4><p>root 用户不仅可以修改自己的密码，还可以修改其它普通用户的密码。root 用户登录 MySQL 服务器后，可以通过 ALTER 语句和 SET 语句来修改普通用户的密码。由于 PASSWORD() 函数已移除，因此使用 UPDATE 直接操作用户表的方式已不再使用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 使用 <span class="keyword">ALTER</span> 语句来修改普通用户的密码</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">user</span> [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>][, <span class="keyword">user</span> [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>]];</span><br><span class="line"></span><br><span class="line"># 使用 <span class="keyword">SET</span> 命令来修改普通用户的密码</span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span><span class="operator">=</span><span class="string">&#x27;new_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 使用 <span class="keyword">UPDATE</span> 语句修改普通用户密码 (不推荐)</span><br><span class="line"><span class="keyword">UPDATE</span> MySQL.user <span class="keyword">SET</span> authentication_string<span class="operator">=</span>PASSWORD(<span class="string">&#x27;new_password&#x27;</span>) </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;username&#x27;</span> <span class="keyword">AND</span> Host<span class="operator">=</span><span class="string">&#x27;hostname&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="1-7-MySQL-8-密码管理"><a href="#1-7-MySQL-8-密码管理" class="headerlink" title="1.7 MySQL 8 密码管理"></a>1.7 MySQL 8 密码管理</h4><p>MySQL 中记录使用过的历史密码，目前包含如下密码管理功能：</p>
<ul>
<li>密码过期：要求定期修改密码。</li>
<li>密码重用限制：不允许使用旧密码。</li>
<li>密码强度评估：要求使用高强度密码。</li>
</ul>
<blockquote>
<p>提示</p>
<p>MySQL 密码管理功能只针对使用基于 MySQL 授权插件的账号，这些插件有 mysql_native_password、sha256_password 和 caching_sha2_password。</p>
</blockquote>
<p><strong>密码过期策略</strong></p>
<ul>
<li>在 MySQL 中，数据库管理员可以手动设置账号密码过期，也可以建一个自动密码过期策略。</li>
<li>过期策略可以是全局的，也可以为每个账号设置单独的过期策略。</li>
</ul>
<p><strong>手动设置立马过期</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">user</span> PASSWORD EXPIRE;</span><br></pre></td></tr></table></figure>

<p>该语句将密码设置为过期后，用户仍然可以登录数据库，但是无法进行查询，只有在重置了密码后，才可进行查询。</p>
<p><strong>手动设置指定时间过期：全局</strong></p>
<p>如果密码使用的时间大于允许的时间，服务器会自动设置为过期，不需要手动设置。</p>
<p>MySQL 使用 <code>default_password_lifetime</code> 系统变量建立全局密码过期策略。</p>
<ul>
<li>它的默认值是 0，表示禁用自动密码过期。</li>
<li>它允许的值是正整数 N，表示允许的密码生存期。密码必须每隔 N 天进行修改。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用 <span class="keyword">SQL</span> 语句更改该变量的值并持久化</span><br><span class="line"><span class="keyword">SET</span> PERSIST default_password_lifetime <span class="operator">=</span> <span class="number">180</span>; # 建立全局策略，设置密码每隔 <span class="number">180</span> 天过期</span><br><span class="line"></span><br><span class="line"># 配置文件my.cnf(或my.ini)中进行维护</span><br><span class="line">[mysqld]</span><br><span class="line">default_password_lifetime<span class="number">-180</span> # 建立全局策略，设置密码每隔 <span class="number">180</span> 天过期</span><br></pre></td></tr></table></figure>

<p><strong>手动设置指定时间过期：单独设置</strong></p>
<p>每隔账号既可延用全局密码过期策略，也可单独设置策略。在 CREATE USER 和 ALTER USER 语句上加入 PASSWORD EXPIRE 选项可实现单独设置策略。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 设置 rose 账号密码每<span class="number">90</span>天过期；</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE <span class="type">INTERVAL</span> <span class="number">90</span> <span class="keyword">DAY</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE <span class="type">INTERVAL</span> <span class="number">90</span> <span class="keyword">DAY</span>;</span><br><span class="line"></span><br><span class="line"># 设置密码永不过期；</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE NAVER;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE NAVER;</span><br><span class="line"></span><br><span class="line"># 延用全局密码过期策略</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE <span class="keyword">DEFAULT</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE <span class="keyword">DEFAULT</span>;</span><br></pre></td></tr></table></figure>

<p><strong>密码重用策略</strong></p>
<p>MySQL 限制使用已用过的密码。重用限制策略基于密码更改的数量和使用的时间。重用策略可以是全局的，也可以为每个账号设置单独的策略。</p>
<ul>
<li><p>账号的历史密码包含过去该账号所使用的密码。MySQL 基于以下规则来限制密码重用：</p>
<ul>
<li>如果账号的密码限制<strong>基于密码更改的数量</strong>，那么新密码不能从最近限制的密码数量中选择。例如，如果密码更改的最小值为 3，那么新密码不能与最近 3 个密码中任何一个相同。</li>
<li>如果账号密码限制<strong>基于时间</strong>，那么新密码不能从规定时间内选择。例如，如果密码重用周期为 60 天，那么新密码不能从最近 60 天内使用的密码中选择。</li>
</ul>
</li>
<li><p>MySQL 使用 password_history 和 password_reuser_interval 系统变量设置密码重用策略。</p>
<ul>
<li><code>password_history</code>：规定密码重用的数量</li>
<li><code>password_reuser_interval</code>: 规定密码重用的周期</li>
</ul>
</li>
<li><p>这两个值可在服务器的配置文件中进行维护，也可在运行期间使用 SQL 语句更改该变量的值并持久化。</p>
</li>
<li><p>手动设置密码重用方式一：全局</p>
<ul>
<li><p>使用 SQL</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 设置不能选择最近使用过的 <span class="number">6</span> 个密码</span><br><span class="line"><span class="keyword">SET</span> PERSIST password_history <span class="operator">=</span> <span class="number">6</span>;	</span><br><span class="line"></span><br><span class="line">#	设置不能选择最近一年内的密码</span><br><span class="line"><span class="keyword">SET</span> PERSIST password_reuse_interval <span class="operator">=</span> <span class="number">365</span>;	</span><br></pre></td></tr></table></figure>
</li>
<li><p>my.cnf (或 my.ini) 配置文件</p>
  <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">password_history</span>=<span class="string">6</span></span><br><span class="line"><span class="attr">password_reuser_interval</span>=<span class="string">365</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>手动设置密码重用方式二：单独设置</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 不能使用最近 <span class="number">5</span> 个密码</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD HISTORY <span class="number">5</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD HISTORY <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"># 不能使用最近 <span class="number">365</span> 天内的密码</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD REUSE <span class="type">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD REUSE <span class="type">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br><span class="line"></span><br><span class="line"># 既不能使用最近 <span class="number">5</span> 个密码，也不能使用 <span class="number">365</span> 天内的密码</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> </span><br><span class="line">PASSWORD HISTORY <span class="number">5</span></span><br><span class="line">PASSWORD REUSE <span class="type">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> </span><br><span class="line">PASSWORD HISTORY <span class="number">5</span></span><br><span class="line">PASSWORD REUSE <span class="type">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br><span class="line"></span><br><span class="line"># 延用全局策略</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> </span><br><span class="line">PASSWORD HISTORY <span class="keyword">DEFAULT</span></span><br><span class="line">PASSWORD REUSE <span class="type">INTERVAL</span> <span class="keyword">DEFAULT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> </span><br><span class="line">PASSWORD HISTORY <span class="keyword">DEFAULT</span></span><br><span class="line">PASSWORD REUSE <span class="type">INTERVAL</span> <span class="keyword">DEFAULT</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2. 权限管理"></a>2. 权限管理</h3><p>关于 MySQL 的权限简单的理解就是 MySQL 允许你做你权力以内的事情，不可以越界。比如只允许你执行 SELECT 操作，那么你就不能执行 UPDATE 操作。只允许你从某台机器上连接 MySQL，那么就不能从除那台机器外的其它机器连接 MySQL。</p>
<h4 id="2-1-权限列表"><a href="#2-1-权限列表" class="headerlink" title="2.1 权限列表"></a>2.1 权限列表</h4><p>使用 <code>show privileges;</code> 查看权限列表</p>
<ul>
<li><code>CREATE 和 DROP 权限</code>，可以创建新的数据库和表，或删除 (移掉) 已有的数据库和表。如果将 MySQL 数据库中的 DROP 权限授予某用户，用户就可以删除 MySQL 访问权限保存的数据库。</li>
<li><code>SELECT、INSERT、UPDATE 和 DELETE 权限 </code>允许在一个数据库现有的表上实施操作。</li>
<li><code>SELECT 权限 </code>只有在它们真正从一个表中检索行时才被用到。</li>
<li><code>INDEX 权限</code> 允许创建或删除索引，INDEX 适用于已有的表。如果具有某个表的 CREATE 权限，就可以在 CREATE TABLE 语句中包括索引定义。</li>
<li><code>ALTER 权限</code> 可以使用 ALTER TABLE 来更改表的结构和重新命名表。</li>
<li><code>CREATE ROUTINE 权限</code> 用来创建保存的程序 (函数和程序)，ALTER ROUTINE 权限用来更改和删除保存的程序，<code>EXECUTE 权限</code> 用来执行保存的程序。</li>
<li><code>GRANT 权限</code> 允许授权给其它用户，可用于数据库、表和保存的程序。</li>
<li><code>FILE 权限</code> 是用户可以使用 <code>LOAD DATA INFILE</code> 和 <code>SELECT ... INTO OUTFILE</code> 语句读或写服务器上的文件，任何被授予 FILE 权限的用户都能读或写 MySQL 服务器上的任何文件 (说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件)。</li>
</ul>
<p>MySQL 的权限如何分布：</p>
<table>
<thead>
<tr>
<th>权限分布</th>
<th>可能的设置的权限</th>
</tr>
</thead>
<tbody><tr>
<td>表权限</td>
<td><code>Select</code>, <code>Insert</code>, <code>Update</code>, <code>Delete</code>, <code>Create</code>, <code>Drop</code>, <code>Grant</code>, <code>References</code>, <code>Index</code>, <code>Alter</code></td>
</tr>
<tr>
<td>列权限</td>
<td><code>Select</code>, <code>Insert</code>, <code>Update</code>, <code>References</code></td>
</tr>
<tr>
<td>过程权限</td>
<td><code>Execute</code>, <code>Alter Routine</code>, <code>Grant</code></td>
</tr>
</tbody></table>
<h4 id="2-2-授予权限的原则"><a href="#2-2-授予权限的原则" class="headerlink" title="2.2 授予权限的原则"></a>2.2 授予权限的原则</h4><p>权限控制主要是出于安全因素，因此需要遵循以下几个经验原则：</p>
<ol>
<li>只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给 select 权限就可以了，不要给用户赋予 update、insert 或者 delete 权限。</li>
<li>创建用户的时候限制用户的登录主机，一般是限制成指定 IP 或者内网 IP 段。</li>
<li>为每个用户设置满足密码复杂度的密码。</li>
<li>定期清理不需要的用户，回收权限或者删除用户。</li>
</ol>
<h4 id="2-3-授予权限"><a href="#2-3-授予权限" class="headerlink" title="2.3 授予权限"></a>2.3 授予权限</h4><p>给用户授权的方式有两种，分别是通过把角色赋予用户给用户授权和直接给用户授权。用户是数据库的使用者，我们可以通过给用户授予访问数据库中资源的权限，来控制使用者对数据库的访问，消除安全隐患。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限<span class="number">1</span>, 权限<span class="number">2</span>, ..., 权限n <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> 用户名@用户地址 [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码口令&#x27;</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>该权限如果发现没有该用户，则会直接新建一个用户。 </li>
<li>如果要给所有权限，可以使用 ALL PRIVILEGES，但不包括 GRANT 权限。</li>
<li>如果要赋予包括 GRANT 的权限，添加参数 <code>WITH GRANT OPTION</code> 这个选项即可，表示该用户可以将自己拥有的权限授权给别人。经常有人在创建操作用户的时候不指定 <code>WITH GRANT OPTION</code> 选项导致后来该用户不能使用 GRANT 命令创建用户或者给其它用户授权。</li>
<li>可以使用 GRANT 重复给用户添加权限，权限叠加，比如你先给用户添加一个 SELECT 权限，然后又给用户添加一个 INSERT 权限，那么该用户就同时拥有了 SELECT 和 INSERT 权限。</li>
</ul>
<blockquote>
<p>在开发应用的时候，经常会遇到一种需求，就是要根据用户的不同，对数据进行横向和纵向的分组。</p>
<ul>
<li>所谓横向的分组，就是指用户可以接触到的数据范围，比如可以看到那些表的数据；</li>
<li>所谓纵向的分组，就是指用户对接触到的数据能访问到什么程度，比如能看、能改，甚至是删除。</li>
</ul>
</blockquote>
<h4 id="2-4-查看权限"><a href="#2-4-查看权限" class="headerlink" title="2.4 查看权限"></a>2.4 查看权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前用户权限</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANT</span>;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="built_in">CURRENT_USER</span>;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="built_in">CURRENT_USER</span>();</span><br><span class="line"></span><br><span class="line"># 查看某用户的全局权限</span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;主机地址&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-收回权限"><a href="#2-5-收回权限" class="headerlink" title="2.5 收回权限"></a>2.5 收回权限</h4><p>收回全新啊就是取消已经赋予用户的某些权限。收回用户不必要的权限可以在一定程度上保证系统的安全性。MySQL 中使用 <code>REVOKE 语句</code> 取消用户的某些权限。使用 REVOKE 收回权限之后，用户账户的记录将从 db、host、tables_priv 和 column_priv 表中删除，但是用户账户记录仍然在 user 表中保存 (删除 user 表中的账户记录使用 DROP USER 语句)。</p>
<p><strong>注意：再将用户账户从 user 表删除之前，应该收回相应用户的所有权限</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限<span class="number">1</span>, 权限<span class="number">2</span>, ..., 权限n <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">FROM</span> 用户名@用户地址;</span><br></pre></td></tr></table></figure>

<p><strong>注意：须用户重新登录后才能生效</strong>。</p>
<blockquote>
<p>总结</p>
<p>有一些程序员喜欢使用 Root 超级用户来访问数据库，完全把权限控制放在应用层面实现。这样当然也是可以的。但建议大家，尽量使用数据库自己的角色和用户机制来控制访问权限，不要轻易用 Root 账号。因为 Root 账号密码放在代码里面不安全，一旦泄露，数据库就会完全失去保护。</p>
<p>而且，MySQL 的权限控制功能十分完善，应该尽量利用，可以提高效率，而且安全可靠。</p>
</blockquote>
<h3 id="3-权限表"><a href="#3-权限表" class="headerlink" title="3. 权限表"></a>3. 权限表</h3><p>MySQL 服务器通过权限表来控制用户对数据库的访问，权限表存放在 mysql 数据库中。MySQL 数据库系统会根据这些权限表的内容为每个用户赋予相应的权限。这些权限表中最重要的是 <code>user表</code>、<code>db表</code>。除此之外，还有 <code>tables_priv 表</code> 、<code>columns_priv 表</code> 和 <code>procs_priv 表</code> 等。在 MySQL 启动时，服务器将这些数据库表中权限信息的内容读入内存。</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>user</td>
<td>用户账号及权限信息</td>
</tr>
<tr>
<td>global_grants</td>
<td>动态全局授权</td>
</tr>
<tr>
<td>db</td>
<td>数据库层级的权限</td>
</tr>
<tr>
<td>tables_priv</td>
<td>表层级的权限</td>
</tr>
<tr>
<td>columns_priv</td>
<td>列层级的权限</td>
</tr>
<tr>
<td>procs_priv</td>
<td>存储的过程和函数权限</td>
</tr>
<tr>
<td>proxies_priv</td>
<td>代理用户的权限</td>
</tr>
<tr>
<td>default_roles</td>
<td>账号连接并认证后默认授予的角色</td>
</tr>
<tr>
<td>role_edges</td>
<td>角色子图的边界</td>
</tr>
<tr>
<td>password_history</td>
<td>密码更改信息</td>
</tr>
</tbody></table>
<h3 id="4-访问控制"><a href="#4-访问控制" class="headerlink" title="4. 访问控制"></a>4. 访问控制</h3><p>连接请求来时，会匹配 mysql 数据库中 user 表里的 user、host 和 password，全部匹配成功才连接成功，这是连接核实阶段。接下来访问数据库、表、字段时，会去 db、tables_priv、columns_priv 表里匹配当前用户的权限。这是请求核实阶段。</p>
<h3 id="5-角色管理"><a href="#5-角色管理" class="headerlink" title="5. 角色管理"></a>5. 角色管理</h3><p>角色是在 MySQL 8.0 中引入的新功能。在 MySQL 中，角色是权限的集合，可以为角色添加或移除权限。用户可以被赋予角色，同时也被授予角色包含的权限。对角色进行操作需要较高的权限。并且向用户账户一样，角色可以游泳授予和撤销的权限。</p>
<p>引入角色的目的是方便管理拥有相同权限的用户。恰当的权限设定，可以确保数据的安全性，这是至关重要的。</p>
<h4 id="5-1-创建角色"><a href="#5-1-创建角色" class="headerlink" title="5.1 创建角色"></a>5.1 创建角色</h4><p>在实际应用中，为了安全性，需要给用户授予权限。当用户数量较多时，为了避免单独给每一个用户授予多个权限，可以先讲权限集合放入角色中，再赋予用户相应的角色。</p>
<p>创建角色使用 <code>CREATE ROLE</code> 语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>][, <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>]]...</span><br></pre></td></tr></table></figure>

<p>角色名称的命名规则和用户名类似。如果 host_name 省略，默认为 %，role_name 不可省略，不可为空。</p>
<h4 id="5-2-给角色赋予权限"><a href="#5-2-给角色赋予权限" class="headerlink" title="5.2 给角色赋予权限"></a>5.2 给角色赋予权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privileges <span class="keyword">ON</span> table_name <span class="keyword">TO</span> <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>Privileges 代表权限的命你在，多个权限用逗号隔开。</li>
</ul>
<h4 id="5-3-查看角色的权限"><a href="#5-3-查看角色的权限" class="headerlink" title="5.3 查看角色的权限"></a>5.3 查看角色的权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;role_name&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>只要创建了一个角色，系统就会自动给一个 USAGE 权限，意思是连接登录数据库的权限。</li>
</ul>
<h4 id="5-4-回收角色的权限"><a href="#5-4-回收角色的权限" class="headerlink" title="5.4 回收角色的权限"></a>5.4 回收角色的权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> privileges <span class="keyword">ON</span> table_name <span class="keyword">FROM</span> <span class="string">&#x27;role_name&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-删除角色"><a href="#5-5-删除角色" class="headerlink" title="5.5 删除角色"></a>5.5 删除角色</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> ROLE role [, role2]...</span><br></pre></td></tr></table></figure>

<h4 id="5-6-给用户赋予角色"><a href="#5-6-给用户赋予角色" class="headerlink" title="5.6 给用户赋予角色"></a>5.6 给用户赋予角色</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> role [, role2, ...] <span class="keyword">TO</span> <span class="keyword">user</span> [, user2, ...];</span><br></pre></td></tr></table></figure>

<h4 id="5-7-激活角色"><a href="#5-7-激活角色" class="headerlink" title="5.7 激活角色"></a>5.7 激活角色</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 方式一：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">DEFAULT</span> ROLE <span class="keyword">ALL</span> <span class="keyword">TO</span> <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;host_name&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 方式二：将 active_all_roles_on_login 设置为 <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> activate_all_roles_on_login<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line"># 上面这条<span class="keyword">SQL</span>的意思是对所有角色永久激活。</span><br><span class="line"></span><br><span class="line"># 查看当前已激活的角色</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_ROLE</span>();</span><br></pre></td></tr></table></figure>

<h4 id="5-8-撤销用户的角色"><a href="#5-8-撤销用户的角色" class="headerlink" title="5.8 撤销用户的角色"></a>5.8 撤销用户的角色</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> role <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h4 id="5-9-设置强制角色-mandatory-role"><a href="#5-9-设置强制角色-mandatory-role" class="headerlink" title="5.9 设置强制角色 (mandatory role)"></a>5.9 设置强制角色 (mandatory role)</h4><p>强制角色是给每个创建账户的默认角色，不需要手动设置，强制角色无法被 REVOKE 或者 DROP。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 方式一：服务启动前设置</span><br><span class="line">[mysqld]</span><br><span class="line">mandatory_roles<span class="operator">=</span><span class="string">&#x27;role1,role2@localhost,...&#x27;</span></span><br><span class="line"></span><br><span class="line"># 方式二：运行时设置</span><br><span class="line"><span class="keyword">SET</span> PERSIST mandatory_roles <span class="operator">=</span> <span class="string">&#x27;role1,role2@localhost,...&#x27;</span>;	# 系统重启后仍然有效</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> mandatory_roles <span class="operator">=</span> <span class="string">&#x27;role1,role2@localhost,...&#x27;</span>;	# 系统重启后失效</span><br></pre></td></tr></table></figure>

<h4 id="5-10-小结"><a href="#5-10-小结" class="headerlink" title="5.10 小结"></a>5.10 小结</h4><p>MySQL 主要管理角色的语句如下：</p>
<table>
<thead>
<tr>
<th align="center">语句</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CREATE ROLE and DROP ROLE</td>
<td align="center">创建和删除角色</td>
</tr>
<tr>
<td align="center">GRANT and REVOKE</td>
<td align="center">给角色或者用户分配&#x2F;撤销权限</td>
</tr>
<tr>
<td align="center">SHOW GRANTS</td>
<td align="center">显示用户&#x2F;角色所拥有的权限或者角色</td>
</tr>
<tr>
<td align="center">SET DEFAULT ROLE</td>
<td align="center">设置账户默认使用什么角色</td>
</tr>
<tr>
<td align="center">SET ROLE</td>
<td align="center">改变当前会话的角色</td>
</tr>
<tr>
<td align="center">CURRENT_ROLE()</td>
<td align="center">显示当前会话的角色</td>
</tr>
<tr>
<td align="center">Mandatory_roles 和 activate_all_roles_on_login 系统变量</td>
<td align="center">允许定义用户登录时强制的或者激活授权的角色</td>
</tr>
</tbody></table>
<h2 id="二、逻辑架构"><a href="#二、逻辑架构" class="headerlink" title="二、逻辑架构"></a>二、逻辑架构</h2><h3 id="1-逻辑架构剖析"><a href="#1-逻辑架构剖析" class="headerlink" title="1. 逻辑架构剖析"></a>1. 逻辑架构剖析</h3><h4 id="1-1-服务器处理客户端请求"><a href="#1-1-服务器处理客户端请求" class="headerlink" title="1.1 服务器处理客户端请求"></a>1.1 服务器处理客户端请求</h4><p>首先 MySQL 是典型的 C&#x2F;S 架构，即 Client &#x2F; Server 架构，服务器端程序使用的 mysqld。不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：**客户端进程向服务器进程发送一段文本 (SQL 语句)，服务器进程处理后再向客户端进程发送一段文本 (处理结果)**。</p>
<p>下图为服务器处理客户端进程发送的查询请求的示例图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82.png" alt="服务器处理客户端请求"></p>
<p>具体结构：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.png" alt="mysql逻辑架构"></p>
<h4 id="1-2-Connectors"><a href="#1-2-Connectors" class="headerlink" title="1.2 Connectors"></a>1.2 Connectors</h4><p>Connectors，指的是不同语言中与 SQL 的交互。MySQL 首先是一个网络程序，在 TCP 之上定义了自己的应用层协议。所以要使用 MySQL，我们可以编写代码，跟 MySQL Server 建立 TCP 连接，之后按照其定义好的协议进行交互。或者比较方便的办法是调用 SDK，比如 Native C API、JDBC、PHP等各语言 MySQL Connector，或者通过 ODBC。但<strong>通过 SDK 来访问 MySQL，本质上还是在 TCP 连接上通过 MySQL 协议跟 MySQL 进行交互</strong>。</p>
<p>MySQL Server 结构可以分为三层：</p>
<h4 id="1-3-第一层：连接层"><a href="#1-3-第一层：连接层" class="headerlink" title="1.3 第一层：连接层"></a>1.3 第一层：连接层</h4><p>系统 (客户端) 访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。</p>
<p>经过三次握手建立连接成功后，MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。</p>
<ul>
<li>用户名或密码不对，会收到一个 Access denied for user 错误，客户端程序结束执行。</li>
<li>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖此时读到的权限。</li>
</ul>
<blockquote>
<p>一个系统只会和 MySQL 服务器建立一个连接吗？只能有一个系统和 MySQL 服务器建立连接吗？</p>
</blockquote>
<p>当然不是，多个系统都可以和 MySQL 服务器建立连接，每个系统建立的连接肯定不止一个。所以，为了解决 TCP 无限创建与 TCP频繁创建销毁带来的资源耗尽、性能下降问题。MySQL 服务器里有专门的 <strong>TCP 连接池</strong>限制连接数，采用<strong>长连接模式</strong>复用 TCP 连接，来解决上述问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0.png" alt="mysql连接池"></p>
<p>TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p>
<p>所以连接管理的职责是负责认证、管理连接、获取权限信息。</p>
<h4 id="1-4-第二层：服务层"><a href="#1-4-第二层：服务层" class="headerlink" title="1.4 第二层：服务层"></a>1.4 第二层：服务层</h4><p>第二层架构主要完成大多数的核心服务功能，如 SQL 接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p>
<p>在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化：如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。</p>
<p>如果是 SELECT 语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>
<ul>
<li><p><strong>SQL Interface：SQL 接口</strong></p>
<ul>
<li>接收用户的 SQL 命令，并且返回用户需要查询的结果。比如 SELECT … FROM 就是调用 SQL Interface</li>
<li>MySQL 支持 DML (数据操作语言)、DDL (数据定义语言)、存储过程、视图、触发器、自定义函数等多种 SQL 语言接口</li>
</ul>
</li>
<li><p><strong>Parser：解析器</strong></p>
<ul>
<li>在解析器中对 SQL 语句进行语法分析、语义分析。将 SQL 语句分解成数据结构，并将这个结构传递到后续步骤，以后 SQL 语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个 SQL 语句是不合理的。</li>
<li>在 SQL 命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL 还会对 SQL 查询进行语法上的优化，进行查询重写。</li>
</ul>
</li>
<li><p><strong>Optimizer：优化器</strong></p>
<ul>
<li><p>SQL 语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划。</p>
</li>
<li><p>这个执行计划表明应该使用哪些索引进行查询 (全表检索还是使用索引检索)，表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</p>
</li>
<li><p>它使用 <code>选取-投影-连接</code> 策略进行查询。例如</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>  这个 SELECT 查询先根据 WHERE 语句进行选取，而不是将表全部查询出来以后再进行 gender 过滤。</p>
<p>  这个 SELECT 查询先根据 id 和 name 进行属性投影，而不是将属性全部取出来以后再进行过滤，将这两个查询条件连接起来生成最终查询结果。</p>
</li>
</ul>
</li>
<li><p><strong>Caches &amp; Buffers：查询缓存组件</strong></p>
<ul>
<li>MySQL 内部维持着一些 Cache 和 Buffer，比如 Query Cache 用来缓存一条 SELECT 语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</li>
<li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存，权限缓存等。</li>
<li>这个查询缓存可以在不同客户端之间共享。</li>
<li>从 MySQL 5.7.20 开始，不推荐使用查询缓存，并在 MySQL 8.0 中删除。</li>
</ul>
</li>
</ul>
<h4 id="1-5-第三层：引擎层"><a href="#1-5-第三层：引擎层" class="headerlink" title="1.5 第三层：引擎层"></a>1.5 第三层：引擎层</h4><p>和其它数据库相比，MySQL 有点与众不同，它的架构可以在多种场景中应用并发挥良好作用，主要体现在存储引擎的架构上，插件式的存储引擎结构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。同时开源的 MySQL 还允许开发人员设置自己的存储引擎。</p>
<p>这种高效的模块化结构为那些希望专门针对特定应用程序需求 (例如数据仓库、事务处理或高可用性情况) 的人提供了巨大的好处，同时享受使用一组独立于任何借口和服务的优势存储引擎。</p>
<p>插件式存储引擎层 (Storage Engines)，<strong>真正的负责了 MySQL 中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</strong>，服务器通过 API 于存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p>
<p>MySQL 8.0.27 默认支持的存储引擎如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> engines;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> Engine             <span class="operator">|</span> Support <span class="operator">|</span> Comment                                                        <span class="operator">|</span> Transactions <span class="operator">|</span> XA   <span class="operator">|</span> Savepoints <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> ARCHIVE            <span class="operator">|</span> YES     <span class="operator">|</span> Archive storage engine                                         <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLACKHOLE          <span class="operator">|</span> YES     <span class="operator">|</span> <span class="operator">/</span>dev<span class="operator">/</span><span class="keyword">null</span> storage engine (anything you write <span class="keyword">to</span> it disappears) <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MRG_MYISAM         <span class="operator">|</span> YES     <span class="operator">|</span> Collection <span class="keyword">of</span> identical MyISAM tables                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FEDERATED          <span class="operator">|</span> <span class="keyword">NO</span>      <span class="operator">|</span> Federated MySQL storage engine                                 <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MyISAM             <span class="operator">|</span> YES     <span class="operator">|</span> MyISAM storage engine                                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> PERFORMANCE_SCHEMA <span class="operator">|</span> YES     <span class="operator">|</span> Performance Schema                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> InnoDB             <span class="operator">|</span> <span class="keyword">DEFAULT</span> <span class="operator">|</span> Supports transactions, <span class="type">row</span><span class="operator">-</span>level locking, <span class="keyword">and</span> <span class="keyword">foreign</span> keys     <span class="operator">|</span> YES          <span class="operator">|</span> YES  <span class="operator">|</span> YES        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MEMORY             <span class="operator">|</span> YES     <span class="operator">|</span> Hash based, stored <span class="keyword">in</span> memory, useful <span class="keyword">for</span> temporary tables      <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CSV                <span class="operator">|</span> YES     <span class="operator">|</span> CSV storage engine                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br></pre></td></tr></table></figure>

<h4 id="1-6-存储层"><a href="#1-6-存储层" class="headerlink" title="1.6 存储层"></a>1.6 存储层</h4><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存在的，并完成于存储引擎的交互。当然有些存储引擎比如 InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的使用是的这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用 DAS、NAS、SAN 等各种存储系统。</p>
<h4 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7 小结"></a>1.7 小结</h4><p>简化 SQL 执行流程：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="简化sql执行流程"></p>
<p>简化为三层结构：</p>
<ol>
<li>连接层：客户端和服务端建立连接，客户端发送 SQL 至服务器端；</li>
<li>SQL 层 (服务层)：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</li>
<li>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</li>
</ol>
<h3 id="2-SQL-执行流程"><a href="#2-SQL-执行流程" class="headerlink" title="2. SQL 执行流程"></a>2. SQL 执行流程</h3><h4 id="2-1-MySQL-中的-SQL-执行流程"><a href="#2-1-MySQL-中的-SQL-执行流程" class="headerlink" title="2.1 MySQL 中的 SQL 执行流程"></a>2.1 MySQL 中的 SQL 执行流程</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="sql执行流程"></p>
<p>MySQL 的查询流程：</p>
<ol>
<li><p><strong>查询缓存</strong>：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL 8.0 之后就抛弃了这个功能。</p>
<p> MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被肢解缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被肢解返回给客户端。如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。所以，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p>
<blockquote>
<p>大多数情况查询缓存就是个鸡肋，为什么呢？</p>
</blockquote>
<p> 查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的鲁棒性大大降低，只有相同的查询操作才会命中查询缓存。两个查询请求在任何字符上的不同 (如空格、注释、大小写)，都会导致缓存不会命中。因此 MySQL 的查询缓存命中率不高。</p>
<p> 同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql、information_schema、performance_schema 数据库中的表，那这个查询就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数 NOW，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的。</p>
<p> 此外，既然时缓存，那就有它缓存失效的时候。MySQL 的缓存系统会监测涉及到的每张表，只要该表的结果或者数据被修改，如对该表使用了 INSERT、UPDATE、DELETE、TRUNCATE TABLE、ALTER TABLE、DROP TABLE 或 DROP DATABASE 语句，那使用该表的所有高速缓存存储都将变为无效并从高速缓存中删除。对于更新压力大的数据库来说，查询缓存的命中率会非常低。</p>
<p> <strong>总之，因为查询缓存往往弊大于利，查询缓存的失效非常频繁</strong>。</p>
<p> 一般建议大家在静态表里使用查询缓存，什么叫静态表呢？就是一般我们极少更新的表。比如，一个系统配置表、字典表、这种表上的查询才适合使用查询缓存。好在 MySQL 也提供了这种“按需使用”的方式。你可以将 my.cnf 参数 query_cache_type 设置成 DEMAND，代表当 SQL 语句中有 SQL_CACHE 关键词时才缓存。</p>
</li>
<li><p><strong>解析器</strong>：在解析器中对 SQL 语句进行语法分析、语义分析。</p>
<p> 如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。SQL 语句的分析分为词法分析与语法分析。</p>
<p> 分析器先做词法分析。你输入的是由多少个字符串和空格组成的一条 SQL 语句，MySLQ 需要识别出里面的字符串分别是什么，代表什么。</p>
<p> MySLQ 从你输入的 “select” 这个关键字识别出来，这是一个查询语句。它也要把字符串 “T” 识别成”表名 T“，把字符串 “ID” 识别成 “列ID”。</p>
<p> 接着，要做语法分析。根据词法分析的结果，语法分析器 (比如：Bison) 会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p>
<p> 如果你的 语句不对，就会收到 “You have an error in you SQL syntax” 的错误提醒。 </p>
<p> sql词法分析过程：</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/sql%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B.png" alt="sql词法分析过程"></p>
</li>
<li><p><strong>优化器</strong>：在优化器中会确定 SQL 语句的执行路径，比如时根据全表检索，还是根据索引检索等。</p>
<p> 经过了解析器，MySQL 就知道要做什么了。在开始执行之前，还要先经过优化器的处理。<strong>一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划</strong>。</p>
<p> 比如：优化器是在表里面有多个索引的时候，决定使用那个索引；或者在一个语句有多表关联 (join) 的时候，决定各个表的连接顺序，还有表达式简化、子查询转为连接、外连接转为内连接等。</p>
<p> 在查询优化器中，可以分为逻辑查询优化阶段和物理查询优化阶段。</p>
<p> 逻辑查询优化就是通过改变 SQL 语句的内容来时的 SQL 查询更高效，同时为物理查询优化提供更多的候选执行计划。通常采用的方式是对 SQL 语句进行等价变换，对查询进行重写，而查询重写的数学基础就是关系代数。对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等。</p>
<p> 物理查询优化是基于关系代数进行的查询重写，而关系代数的每一步都对应着无力计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。在这个阶段里，对于单表和多表连接的操作，需要高效地使用索引，提升查询效率。</p>
</li>
<li><p><strong>执行器</strong>：</p>
<p> 截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了执行器阶段。在执行之前需要判断该用户是否具备权限。如果没有，就会返回权限错误。如果具备权限，就执行 SQL 查询并返回结果。在 MySQL 8.0 以下的版本，如果设置了查询缓存，这是会讲查询结果进行缓存。</p>
<p> 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，调用存储引擎 API 对表进行读写。存储引擎 API 只是抽象接口，下面还有个存储引擎层，具体实现还是要看表选择的存储引擎。</p>
</li>
</ol>
<p>SQL 语句在 MySQL 中的执行流程是：<code>SQL 语句 → 查询缓存 → 解析器 → 优化器 → 执行器</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B2.png" alt="sql执行流程2"></p>
<h4 id="2-2-MySQL-8-中-SQL-执行原理"><a href="#2-2-MySQL-8-中-SQL-执行原理" class="headerlink" title="2.2 MySQL 8 中 SQL 执行原理"></a>2.2 MySQL 8 中 SQL 执行原理</h4><p>前面的结构图很复杂，我们需要抓取最核心的部分：SQL 的执行原理。不同 DBMS 的 SQL 的执行原理是相通的，只是在不同的软件中，各有各的实现路径。</p>
<p>既然一条 SQL 语句会经历不同的模块，那接下来看下在不同的模块中，SQL 执行所使用的资源 (时间) 是怎样的。如何在 MySQL 中对一条 SQL 语句的执行时间进行分析。</p>
<ol>
<li><p>确认 profiling 是否开启</p>
<p> 了解查询语句底层执行的过程：<code>select @@profiling;</code> 或者 <code>show variables like &#39;%profiling&amp;&#39;;</code> 查看是否开启计划。开启它可以让 MySQL 收集在 SQL 执行时所使用的资源情况。</p>
<p> profiling&#x3D;0 代表关闭，将其改为 1，<code>set profiling=1;</code>。Profiling 功能由 MySQL 会话变量：profiling 控制。默认是 OFF。</p>
</li>
<li><p>多次执行相同 SQL 查询</p>
</li>
<li><p>查看 profiles</p>
<p> <code>SHOW profiles;</code> 和 <code>SHOW profile;</code> 语句可以展示当前会话 (退出 session 后，profiling 重置为 0) 中执行语句的资源使用情况。</p>
</li>
</ol>
<h3 id="3-数据库缓冲池-buffer-pool"><a href="#3-数据库缓冲池-buffer-pool" class="headerlink" title="3. 数据库缓冲池 (buffer pool)"></a>3. 数据库缓冲池 (buffer pool)</h3><p>InnoDB 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面 (包括读页面、写页面、创建新页面等操作)。而磁盘 I&#x2F;O需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请占用内存来作为数据缓冲池，在真正访问页面之前，需要把磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访问。</p>
<p>这样做的好处是可以让磁盘活动最小化，从而减少与磁盘直接进行 I&#x2F;O 的时间。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里面，那么访问的成本就会降低很多。</p>
<h4 id="3-1-缓冲池-vs-查询缓存"><a href="#3-1-缓冲池-vs-查询缓存" class="headerlink" title="3.1 缓冲池 vs 查询缓存"></a>3.1 缓冲池 vs 查询缓存</h4><ul>
<li><p>缓冲池</p>
<p>  在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，如下图：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%BC%93%E5%86%B2%E6%B1%A0.png" alt="缓冲池"></p>
<p>  从图中，可以看到 InnoDB 缓冲池包括了数据页、索引页、插入缓存、锁信息、自适应 Hash 和数据字典信息等。</p>
<p>  <strong>缓冲池的重要性</strong>：</p>
<p>  对于使用 InnoDB 作为存储引擎的表来说，不管是用于存储用户数据的索引 (包括聚簇索引和二级索引)，还是各种系统数据，都是以页的形式存放在表空间中的，而所谓的表空间只不过是 InnoDB 对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。但是各位也都知道，磁盘的速度慢得跟乌龟一样，怎么能配得上 CPU 呢。这里，缓冲池可以帮助我们消除 CPU 和磁盘之间的鸿沟。所以 InnoDB 存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，也就是说即使我们只需要访问一夜的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘 I&#x2F;O 的开销了。</p>
<p>  <strong>缓存原则</strong>：</p>
<p>  <code>为止 * 频次</code> 这个原则，可以帮我们对 I&#x2F;O 访问效率进行优化。</p>
<p>  首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。</p>
<p>  其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会优先对使用频次高的热数据进行加载。</p>
<p>  <strong>缓冲池的预读特性</strong>：</p>
<p>  了解了缓冲池的作用之后，我们还需要了解缓冲池的另一个特性：<strong>预读</strong>。</p>
<p>  缓冲池的作用就是提升 I&#x2F;O 效率，而我们进行读取数据的时候存在一个局部性原理，也就是说我们使用了一些数据，大概率还会使用它周围的一些数据，因此采用预读的机制提前加载，可以减少未来可能的磁盘 I&#x2F;O 操作。</p>
</li>
<li><p>查询缓存</p>
<p>  那么什么是查询缓存呢？</p>
<p>  查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</p>
<p>  缓冲池服务于数据库整体的 I&#x2F;O 操作，它们的共同点都是通过缓存的机制来提升效率。</p>
</li>
</ul>
<h4 id="3-2-缓冲池如何读取数据"><a href="#3-2-缓冲池如何读取数据" class="headerlink" title="3.2 缓冲池如何读取数据"></a>3.2 缓冲池如何读取数据</h4><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p>
<p>缓存在数据库中的结构和作用：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%BC%93%E5%AD%98%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E4%BD%9C%E7%94%A8.png" alt="缓存在数据库中的结构和作用"></p>
<p>如果我们执行 SQL 语句的时候更新了缓冲池中的数据，那么这些数据会马上同步到磁盘上吗？</p>
<p>实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会以一定的频率刷新到磁盘上。注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做 <code>checkpoint</code> 的机制将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。</p>
<p>比如，当缓冲池不够用时，需要释放掉一些不常用的页，此时就可以强行采用 checkpoint 的方式，将不常用的脏页回写到磁盘上，然后再从缓冲池中将这些页释放掉。这里脏页指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。</p>
<h4 id="3-3-查看-x2F-设置缓冲池的大小"><a href="#3-3-查看-x2F-设置缓冲池的大小" class="headerlink" title="3.3 查看&#x2F;设置缓冲池的大小"></a>3.3 查看&#x2F;设置缓冲池的大小</h4><p>如果你使用的是 MySQL MyISAM 存储引擎，它只缓存索引，不缓存数据，对应的键缓存参数为 <code>key_buffer-size</code>，你可以用它进行查看。</p>
<p>如果你使用的是 InnoDB 存储引擎，可以通过查看 <code>innodb_buffer_pool_size</code> 变量来查看缓冲池的大小。命令如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看缓冲池大小</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_size&#x27;</span>; # 单位是 B</span><br><span class="line"></span><br><span class="line"># 修改缓冲池大小</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_buffer_pool_size <span class="operator">=</span> xxxxx;</span><br><span class="line">或</span><br><span class="line">[mysqld]</span><br><span class="line">innodb_buffer_pool_size <span class="operator">=</span> xxxxxx</span><br></pre></td></tr></table></figure>

<h4 id="3-4-多个-Buffer-Pool-实例"><a href="#3-4-多个-Buffer-Pool-实例" class="headerlink" title="3.4 多个 Buffer Pool 实例"></a>3.4 多个 Buffer Pool 实例</h4><p>Buffer Pool 本质是 InnoDB 向操作系统申请的一块连续的内存空间，再多线程环境下，访问 Buffer Pool 中的数据都需要加锁处理。在 Buffer Pool 特别大而且多线程并发访问特别高的情况下，单一的 Buffer Pool 可能会影响请求的处理速度。所以在 Buffer Pool 特别大的时候，我们可以把它们拆分成若干个小的 Buffer Pool，每个 Buffer Pool 都称为一个实例，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。</p>
<p>我们可以在服务器启动的时候通过设置 <code>innodb_buffer_pool_instances</code> 的值来修改 Buffer Pool 实例的个数。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[server]</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_instances</span> = <span class="string">2</span></span><br></pre></td></tr></table></figure>

<p>这样就表明我们要创建两个 Buffer Pool 实例。</p>
<p>查看缓冲池的个数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_instances&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>每个 Buffer Pool实例实际占多少内存空间公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size / innodb_buffer_pool_instances</span><br></pre></td></tr></table></figure>

<p>也就是总共的大小除以实例的个数，结果就是每个 Buffer Pool 实例占用的大小。</p>
<p>不过也不是说 Buffer Pool 实例创建的越多越好，分别管理各个 Buffer Pool 也是需要性能开销的，InnoDB 规定：当 innodb_buffer_pool_size 的值小于 1G 的时候设置多个实例是无效的，InnoDB 会默认把 innodb_buffer_pool_instances 的值改为 1。而我们鼓励在 Buffer Pool 大于或等于 1G 的时候设置多个 Buffer Pool 实例。</p>
<h4 id="3-5-引申问题"><a href="#3-5-引申问题" class="headerlink" title="3.5 引申问题"></a>3.5 引申问题</h4><p>Buffer Pool 是MySQL 内存结构中十分核心的一个组成，可以把它想象成一个黑盒子。</p>
<p><strong>黑盒下的更新数据流程</strong></p>
<p>当我们查询数据的时候，会先去把 Buffer Pool 中查询。如果 Buffer Pool 中不存在，存储引擎会先将数据从磁盘加载到 Buffer Pool 中，然后将数据返回给客户端；同理，当我们更新某个数据的时候，如果这个数据不存在于 Buffer Pool，同样会先将数据加载进来，然后修改内存的数据。被修改过的数据会在之后统一刷入磁盘。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E9%BB%91%E7%9B%92%E4%B8%8B%E7%9A%84%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B.png" alt="黑盒下的更新数据流程"></p>
<p>这个过程看似没啥问题，实则是有问题的。假设我们修改 Buffer Pool 中的数据成功，但是还没来得及讲数据刷入磁盘 MySQL 就挂了怎么办？按照上图的逻辑，此时更新之后的数据只存在于 Buffer Pool 中，如果此时 MySQL 服务宕机了，这部分数据将会永久地消失。</p>
<p>再者，我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回滚都做不到还谈什么崩溃恢复？</p>
<p>利用 <code>Redo Log &amp; Undo Log</code>。</p>
<h2 id="三、存储引擎"><a href="#三、存储引擎" class="headerlink" title="三、存储引擎"></a>三、存储引擎</h2><p>为了管理方便，人们把连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存储的功能划分为MySQL Server 的功能，把真实存取数据的功能划分为存储引擎的功能。所以在MySQL Server 完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</p>
<p>MySQL 中提到了存储引擎的概念。简而言之，存储引擎就是指表的类型。其实存储引擎以前叫做表处理器，后来改名为存储引擎，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。</p>
<h3 id="1-查看存储引擎"><a href="#1-查看存储引擎" class="headerlink" title="1. 查看存储引擎"></a>1. 查看存储引擎</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> engines;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> Engine             <span class="operator">|</span> Support <span class="operator">|</span> Comment                                                        <span class="operator">|</span> Transactions <span class="operator">|</span> XA   <span class="operator">|</span> Savepoints <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> ARCHIVE            <span class="operator">|</span> YES     <span class="operator">|</span> Archive storage engine                                         <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLACKHOLE          <span class="operator">|</span> YES     <span class="operator">|</span> <span class="operator">/</span>dev<span class="operator">/</span><span class="keyword">null</span> storage engine (anything you write <span class="keyword">to</span> it disappears) <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MRG_MYISAM         <span class="operator">|</span> YES     <span class="operator">|</span> Collection <span class="keyword">of</span> identical MyISAM tables                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FEDERATED          <span class="operator">|</span> <span class="keyword">NO</span>      <span class="operator">|</span> Federated MySQL storage engine                                 <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MyISAM             <span class="operator">|</span> YES     <span class="operator">|</span> MyISAM storage engine                                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> PERFORMANCE_SCHEMA <span class="operator">|</span> YES     <span class="operator">|</span> Performance Schema                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> InnoDB             <span class="operator">|</span> <span class="keyword">DEFAULT</span> <span class="operator">|</span> Supports transactions, <span class="type">row</span><span class="operator">-</span>level locking, <span class="keyword">and</span> <span class="keyword">foreign</span> keys     <span class="operator">|</span> YES          <span class="operator">|</span> YES  <span class="operator">|</span> YES        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MEMORY             <span class="operator">|</span> YES     <span class="operator">|</span> Hash based, stored <span class="keyword">in</span> memory, useful <span class="keyword">for</span> temporary tables      <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CSV                <span class="operator">|</span> YES     <span class="operator">|</span> CSV storage engine                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Engine 参数</code> 表示存储引擎名称。</li>
<li><code>Support 参数</code> 表示 MySQL 数据库管理系统是否支持该存储引擎：YES 表示支持，NO 表示不支持。</li>
<li><code>DEFAULT</code> 表示系统默认支持的存储引擎。</li>
<li><code>Comment 参数</code> 表示对存储引擎的评论。</li>
<li><code>Transactions 参数</code> 表示存储引擎是否支持事务：YES 表示支持，NO 表示不支持。</li>
<li><code>XA 参数</code> 表示存储引擎所支持的分布式是否符合 XA 规范：YES 表示支持，NO 表示不支持。代表着该存储引擎是否支持分布式事务。</li>
<li><code>Saverpoints 参数</code> 表示存储引擎是否支持事务处理的保存点：YES 表示支持，NO 表示不支持。也就是说，该存储引擎是否支持部分事务回滚。</li>
</ul>
<h3 id="2-设置系统默认的存储引擎"><a href="#2-设置系统默认的存储引擎" class="headerlink" title="2. 设置系统默认的存储引擎"></a>2. 设置系统默认的存储引擎</h3><ul>
<li><p>查看默认的存储引擎</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span>;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@default</span>_storage_engine;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改默认的存储引擎</p>
<p>  如果在创建表的语句中没有显示指定表的存储引擎的话，那就会默认使用 InnoDB 作为表的存储引擎。如果我们想改变表的默认存储引擎的话，可以这样可启动服务器的命令行：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> DEFAULT_STORAGE_ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure>

<p>  或者修改 my.cnf (Windows 系统叫 my.ini) 文件：</p>
  <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">default_storage_engine</span>=<span class="string">MyISAM</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">restart mysqld.service</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-设置表的存储引擎"><a href="#3-设置表的存储引擎" class="headerlink" title="3. 设置表的存储引擎"></a>3. 设置表的存储引擎</h3><p>存储引擎室负责对表中的数据进行提取和写入工作的，我们可以为不同的表设置不同的存储引擎，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。</p>
<h4 id="3-1-创建表时指定存储引擎"><a href="#3-1-创建表时指定存储引擎" class="headerlink" title="3.1 创建表时指定存储引擎"></a>3.1 创建表时指定存储引擎</h4><p>我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎 InnoDB。如果我们想显式的指定一下表的存储引擎，那可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">	建表语句;</span><br><span class="line">) ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-修改表的存储引擎"><a href="#3-2-修改表的存储引擎" class="headerlink" title="3.2 修改表的存储引擎"></a>3.2 修改表的存储引擎</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure>

<h3 id="4-引擎介绍"><a href="#4-引擎介绍" class="headerlink" title="4. 引擎介绍"></a>4. 引擎介绍</h3><h4 id="4-1-InnoDB-引擎：具备外键支持功能的事务存储引擎"><a href="#4-1-InnoDB-引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="4.1 InnoDB 引擎：具备外键支持功能的事务存储引擎"></a>4.1 InnoDB 引擎：具备外键支持功能的事务存储引擎</h4><ul>
<li>MySQL 从 3.23.34a 开始就包含 InnoDB 存储引擎。大于等于 5.5 之后，默认采用 InnoDB 引擎。</li>
<li>InnoDB 是 MySQL 的默认事务型引擎，它被设计用来处理大量的短期 (short-lived) 事务。可以确保事务的完整提交 (Commit) 和 回滚 (Rollback)。</li>
<li>除了增加和查询外，还需要更新、删除操作，那么，应优先选择 InnoDB 存储引擎。</li>
<li>除非有非常特别的原因需要使用其它的存储引擎，否则应该优先考虑 InnoDB 引擎。</li>
<li>数据文件结构：<ul>
<li>表名.frm 存储表结构 (MySQL 8.0 时，合并在表名.ibd 中)</li>
<li>表名.ibd 存储数据和索引</li>
</ul>
</li>
<li>InnoDB 是为处理巨大数据量的最大性能设计。<ul>
<li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如 <code>.frm</code>，<code>.par</code>， <code>.trn</code>，<code>.isl</code>，<code>.db</code>，<code>.opt</code> 等都在MySQL 8.0 中不存在了。</li>
</ul>
</li>
<li>对比 MyISAM 的存储引擎，InnoDB 写的处理效率差一些，并且会占用更多的磁盘空间以保存数据和索引。</li>
<li>MyISAM 只缓存索引，不缓存真实数据；InnoDB 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响。</li>
</ul>
<h4 id="4-2-MyISAM-引擎：主要的非事务处理存储引擎"><a href="#4-2-MyISAM-引擎：主要的非事务处理存储引擎" class="headerlink" title="4.2 MyISAM 引擎：主要的非事务处理存储引擎"></a>4.2 MyISAM 引擎：主要的非事务处理存储引擎</h4><ul>
<li>MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数 (GIS) 等，但 MyISAM 不支持事务、行级锁、外键，有一个毫无疑问的缺陷就是崩溃后无法安全回复。</li>
<li>5.5 之前默认的存储引擎。</li>
<li>优势是访问的速度快，对事物完整性没有要求或者以 SELECT、INSERT 为主的应用。</li>
<li>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高。</li>
<li>数据文件结构：<ul>
<li>表名.frm 存储表结构</li>
<li>表名.MYD 存储数据 (MYData)</li>
<li>表名.MYI 存储索引 (MYIndex)</li>
</ul>
</li>
<li>应用场景：只读应用或者以读为主的业务。</li>
</ul>
<h4 id="4-3-Archive-引擎：用于数据存档"><a href="#4-3-Archive-引擎：用于数据存档" class="headerlink" title="4.3 Archive 引擎：用于数据存档"></a>4.3 Archive 引擎：用于数据存档</h4><ul>
<li><p><code>archive</code> 是归档的意思，仅仅支持插入和查询两种功能 (行被插入后不能再修改)。</p>
</li>
<li><p>在 MySQL 5.5 以后支持索引的功能。</p>
</li>
<li><p>拥有很好的压缩机制，使用 zlib 压缩裤，在记录请求的时候实时的进行压缩，经常被用来作为仓库使用。</p>
</li>
<li><p>创建 ARCHIVE 表时，存储引擎会创建名称以表名开头的文件。数据文件的扩展名为 <code>.ARZ</code>。</p>
</li>
<li><p>根据英文的测试结论来看，同样数据量下，Archive 表比 MyISAM 表要小大约 75%，比支持事务处理的 InnoDB 表小大约 83%。</p>
</li>
<li><p>ARCHIVE 存储引擎采用了行级锁。该 ARCHIVE 引擎支持 AUTO_INCREMENT 列属性。AUTO_INCREMENT 列可以具有唯一索引或非唯一索引。尝试在任何其它列上创建索引会导致错误。</p>
</li>
<li><p>ARCHIVE 表适合日志和数据采集 (归档) 类应用；适合存储大量的独立 的作为历史记录的数据。拥有很高的插入速度，但是对查询的支持较差。</p>
</li>
<li><p>ARCHIVE 存储引擎功能</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>支持</th>
</tr>
</thead>
<tbody><tr>
<td>B 树索引</td>
<td>不支持</td>
</tr>
<tr>
<td>备份&#x2F;时间点恢复 (在服务器中实现，而不是在存储引擎中)</td>
<td>支持</td>
</tr>
<tr>
<td>集群数据库支持</td>
<td>不支持</td>
</tr>
<tr>
<td>聚集索引</td>
<td>不支持</td>
</tr>
<tr>
<td>压缩数据</td>
<td>支持</td>
</tr>
<tr>
<td>数据缓存</td>
<td>不支持</td>
</tr>
<tr>
<td>加密数据 (加密功能在服务器中实现)</td>
<td>支持</td>
</tr>
<tr>
<td>外键支持</td>
<td>不支持</td>
</tr>
<tr>
<td>全文检索索引</td>
<td>不支持</td>
</tr>
<tr>
<td>地理空间数据类型支持</td>
<td>支持</td>
</tr>
<tr>
<td>地理空间索引支持</td>
<td>不支持</td>
</tr>
<tr>
<td>哈希索引</td>
<td>不支持</td>
</tr>
<tr>
<td>索引缓存</td>
<td>不支持</td>
</tr>
<tr>
<td>锁粒度</td>
<td>行锁</td>
</tr>
<tr>
<td>MVCC</td>
<td>不支持</td>
</tr>
<tr>
<td>存储限制</td>
<td>没有任何限制</td>
</tr>
<tr>
<td>交易</td>
<td>不支持</td>
</tr>
<tr>
<td>更新数据字典的统计信息</td>
<td>支持</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="4-4-Blackhole-引擎：丢弃写操作，读操作会返回空内容"><a href="#4-4-Blackhole-引擎：丢弃写操作，读操作会返回空内容" class="headerlink" title="4.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容"></a>4.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容</h4><ul>
<li>Blackhole 引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。</li>
<li>但服务器会记录 Blackhole 表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。</li>
</ul>
<h4 id="4-5-CSV-引擎：存储数据时，以逗号分隔各个数据项"><a href="#4-5-CSV-引擎：存储数据时，以逗号分隔各个数据项" class="headerlink" title="4.5 CSV 引擎：存储数据时，以逗号分隔各个数据项"></a>4.5 CSV 引擎：存储数据时，以逗号分隔各个数据项</h4><ul>
<li>CSV 引擎可以将普通的 CSV 文件作为 MySQL 的表来处理，但不支持索引。</li>
<li>CSV 引擎可以作为一种数据交换的机制，非常有用。</li>
<li>CSV 存储的数据直接可以在操作系统里，用文本编辑器，或者 excel 读取。</li>
<li>对于数据的快速导入、导出是有明显优势的。</li>
</ul>
<p>创建 CSV 表时，服务器会创建一个纯文本数据文件，其名称以表名开头并带有 .CSV 扩展名。当你将数据存储到表中时，存储引擎将其以逗号分隔值格式保存到数据文件中。</p>
<h4 id="4-6-Memory-引擎：置于内存的表"><a href="#4-6-Memory-引擎：置于内存的表" class="headerlink" title="4.6 Memory 引擎：置于内存的表"></a>4.6 Memory 引擎：置于内存的表</h4><p>概述：</p>
<p>Memory 采用的逻辑介质是内存，响应速度很快，但是当 mysqld 守护进程崩溃的时候数据会丢失。另外，要求存储的数据是数据长度不变的格式，比如，Blob 和 Text 类型的数据不可用 (长度不固定的)。</p>
<p>主要特征：</p>
<ul>
<li>Memory 同时支持哈希索引和 B+ 树索引。<ul>
<li>哈希索引相等的比较快，但是对于范围的比较慢很多。</li>
<li>默认使用哈希索引，其速度要比使用 B 型树索引快。</li>
<li>如果希望使用 B 树索引，可以在创建索引时选择使用。</li>
</ul>
</li>
<li>Memory 表至少比 MyISAM 表要快一个数量级。</li>
<li>Memory 表的大小是受限制的。表的大小主要取决于两个参数，分别是 max_rows 和 max_heap_table_size。其中，max_rows 可以在创建表时指定；max_heap_table_size 的大小默认为 16MB，可以按需要进行扩大。</li>
<li>数据文件与索引文件分开存储。<ul>
<li>每个基于 Memory 存储引擎的表实际对应一个磁盘文件，该文件的文件名与表名相同，类型为 frm 类型，该文件中只存储表的结构，而其数据文件都是存储在内存中的。</li>
<li>这样有利于数据的快速处理，提供整个表的处理效率。</li>
</ul>
</li>
<li>缺点：其数据易丢失，生命周期短。基于这个缺陷，选择 Memory 存储引擎时需要特别小心。</li>
</ul>
<p>使用 Memory 存储引擎的场景：</p>
<ol>
<li>目标数据比较小，而且非常频繁的进行访问，在内存中存放数据，如果太大的数据会造成内存溢出。可以通过参数 max_heap_table_size 控制 Memory 表的大小，限制 Memory 表的最大的大小。</li>
<li>如果数据是临时的，而且必须立即可用得到，那么就可以放在内存中。</li>
<li>存储在 Memory 表中的数据如果突然间丢失的话也没有太大的关系。</li>
</ol>
<h4 id="4-7-Federated-引擎：访问远程表"><a href="#4-7-Federated-引擎：访问远程表" class="headerlink" title="4.7 Federated 引擎：访问远程表"></a>4.7 Federated 引擎：访问远程表</h4><ul>
<li>Federated 引擎是访问其他 MySQL 服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</li>
</ul>
<h4 id="4-8-Merge-引擎：管理多个-MyISAM-表构成的表集合"><a href="#4-8-Merge-引擎：管理多个-MyISAM-表构成的表集合" class="headerlink" title="4.8 Merge 引擎：管理多个 MyISAM 表构成的表集合"></a>4.8 Merge 引擎：管理多个 MyISAM 表构成的表集合</h4><h4 id="4-9-NDB-引擎：MySQL-集群专用存储引擎"><a href="#4-9-NDB-引擎：MySQL-集群专用存储引擎" class="headerlink" title="4.9 NDB 引擎：MySQL 集群专用存储引擎"></a>4.9 NDB 引擎：MySQL 集群专用存储引擎</h4><p>也叫作 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。</p>
<h3 id="5-MyISAM-和-InnoDB"><a href="#5-MyISAM-和-InnoDB" class="headerlink" title="5. MyISAM 和 InnoDB"></a>5. MyISAM 和 InnoDB</h3><blockquote>
<p>很多人对 InnoDB 和 MyISAM 的取舍存在疑问，到底选择哪个比较好呢？</p>
</blockquote>
<p>MySQL 5.5 之前的默认存储引擎是 MyISAM，5.5 之后改为了 InnoDB。</p>
<p>首先对于 InnoDB 存储引擎，提供了良好的事务管理、崩溃修改能力和并发控制。因为 InnoDB 存储引擎支持事务，所以对于要求事务完整性的场合需要选择 InnoDB，比如数据操作出了插入和查询意外还包含很多更新和删除操作，像财务系统等对数据准确性要求较高的系统。缺点是其读写效率稍差，占用的数据空间相对比较大。</p>
<p>其次对于 MyISAM 存储引擎，如果是小型应用，系统以读操作和插入操作为主，只有很少的更新、删除操作，并且对事务的要求没有那么高，则可以选择这个存储引擎。MyISAM 存储引擎的优势在于占用空间小，处理速度快；缺点是不支持事务的完整性和并发性。</p>
<p>这两种存储引擎各有特点，当然也可以在 MySQL 中，针对不同的数据表，可以选择不同的存储引擎。</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
<td>行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响。</td>
</tr>
<tr>
<td>自带系统表使用</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>关注点</td>
<td>性能：节省资源、消耗少、简单业务</td>
<td>事务：并发写、事务、更大资源</td>
</tr>
<tr>
<td>默认安装</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>默认使用</td>
<td>N</td>
<td>Y</td>
</tr>
</tbody></table>
<h3 id="6-阿里巴巴、淘宝用哪个"><a href="#6-阿里巴巴、淘宝用哪个" class="headerlink" title="6. 阿里巴巴、淘宝用哪个"></a>6. 阿里巴巴、淘宝用哪个</h3><table>
<thead>
<tr>
<th>产品</th>
<th>价格</th>
<th>目标</th>
<th>主要功能</th>
<th>是否可投入生产？</th>
</tr>
</thead>
<tbody><tr>
<td>Percona Server</td>
<td>免费</td>
<td>提供 XtraDB 存储引擎的包装器和其它分析工具</td>
<td>XtraDB</td>
<td>是</td>
</tr>
<tr>
<td>MariaDB</td>
<td>免费</td>
<td>扩展 MySQL 以包含 XtraDB 和其他性能改进</td>
<td>XtraDB</td>
<td>是</td>
</tr>
<tr>
<td>Drizzle</td>
<td>免费</td>
<td>提供比 MySQL 更强大的可扩展性和性能改进</td>
<td>高可用性</td>
<td>是</td>
</tr>
</tbody></table>
<ul>
<li>Percona 为 MySQL 数据库服务器进行了改进，在功能和性能上较 MySQL 有很显著的提升。</li>
<li>该版本提升了在高负载情况下的 InnoDB 的性能、为 DBA 提供一些非常有用的性能诊断工具；另外有更多的参数和命令来控制服务器行为。</li>
<li>该公司新建了一款存储引擎较 XtraDB 完全可以替代 InnoDB，并且在性能和并发上做的更好。</li>
<li>阿里巴巴大部分 MySQL 数据库其实使用的 percona 的原型加以修改。</li>
</ul>
<h3 id="7-补充"><a href="#7-补充" class="headerlink" title="7. 补充"></a>7. 补充</h3><h4 id="7-1-InnoDB-表的优势"><a href="#7-1-InnoDB-表的优势" class="headerlink" title="7.1 InnoDB 表的优势"></a>7.1 InnoDB 表的优势</h4><p>InnoDB 存储引擎在实际应用中拥有诸多优势，比如操作便利、提高了数据库的性能、维护成本低等。如果由于硬件或软件的原因导致服务器崩溃，那么在重启服务器之后不需要进行额外的操作。InnoDB 崩溃恢复功能自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。</p>
<p>InnoDB 存储引擎在主内存中维护缓冲池，高频率使用的数据将在内存中直接被处理。这种缓存方式应用于多种信息，加速了处理进程。</p>
<p>在专用服务器上，物理內存中高达 80% 的部分被应用于缓冲池。如果需要将数据插入不同的表中，可以设置外键加强数据的完整性。更新或者删除数据，关联数据将会被自动更新或删除。如果试图将数据插入从表，但在主表中没有对应的数据，插入的数据将被自动移除。如果磁盘或內存中的数据出现崩溃，在使用脏数据之前，校验和机制会发出警告。当每个表的主键都设置合理时，与这些列有关的操作会被自动优化。插入、更新和删除操作通过做改变缓冲自动机制进行优。InnoDB 不仅支持当前读写，也会缓冲改变的数据到数据流磁盘。</p>
<p>InnoDe的性能优势不只存在于长时运行查询的大型表。在同一列多次被查询时，自适应哈希索引会提高查询的速度，使用 InnoDB 可以压缩表和相关的索引，可以在不影响性能和可用性的情况下创建或删除索引，对干大型文本和 BLOB 数据，使用动态行形式，这种存储布局更高效。通过查询 INFORMATION_SCHEMA 库中的表可以监控存储引擎的内部工作。在同一个语句中，InnoDB 表可以与其他存储引擎表混用。即使有些操作系统限制文件大小为 2GB，InnoDB 仍然可以处理。当处理大数据量时，InnoDB 兼顾 CPU，以达到最大性能。</p>
<h4 id="7-2-InnoDB-和-ACID-模型"><a href="#7-2-InnoDB-和-ACID-模型" class="headerlink" title="7.2 InnoDB 和 ACID 模型"></a>7.2 InnoDB 和 ACID 模型</h4><p>ACID 模型是一系列数据库设计规则，这些规则着重强调可靠性，而可靠性对于商业数据和任务关键型应用非常重要。MySQL 包含类似 InnoDB 存储引擎的组件，与 ACID 模型紧密相连，这样出现意外时，数据不会崩溃，结果不会失真。如果依赖 ACID 模型，可以不使用一致性检查和崩溃恢复机制。如果拥有额外的软件保护，极可靠的硬件或者应用可以容忍一小部分的数据丢失和不一致，可以将 MySQL 设置调整为只依赖部分 ACID 特性，以达到更高的性能。</p>
<p>InnoDB 存储引擎与 ACID 模型相同作用的四个方面。</p>
<ol>
<li><p>原子方面</p>
<p> ACID 的原子方面主要涉及 InnoDB 事务，与 MySQL 相关的特性主要包括：</p>
<ul>
<li>自动提交设置</li>
<li>COMMIT 语句</li>
<li>ROLLBACK 语句</li>
<li>操作 INFORMATION_SCHEMA 库中的表数据。</li>
</ul>
</li>
<li><p>一致性方面</p>
<p> ACID 模型的一致性主要涉及保护数据不崩溃的内部 InnoDB 处理过程，与 MySQL 相关的特性主要包括：</p>
<ul>
<li>InnoDB 双写缓存</li>
<li>InnoDB 崩溃恢复</li>
</ul>
</li>
<li><p>隔离方面</p>
<p> 隔离是应用于事务的级别，与 MySQL 相关的特性主要包括：</p>
<ul>
<li>自动提交设置</li>
<li><code>SET ISOLATION LEVEL</code> 语句</li>
<li>InnoDB 锁的低级别信息</li>
</ul>
</li>
<li><p>耐久性方面</p>
<p> ACID 模型的耐久性主要涉及与硬件配置相互影响的 MySQL 软件特性。由于硬件复杂多样化，耐久性方面没有具体的规则可循，与 MySQL 相关的特性有：</p>
<ul>
<li>InnoDB 双写缓存，通过 innodb_doublewrite 配置项配置</li>
<li>配置项 innodb_flush_log_at_trx_commit </li>
<li>配置项 sync_binlog</li>
<li>配置项 innodb_file_per_table</li>
<li>存储设备的写入缓存</li>
<li>存储设备的备用电池缓存</li>
<li>运行 MySQL 的操作系统</li>
<li>持续的电力供应</li>
<li>备份策略</li>
<li>对分布式或托管的应用，最主要的在于硬件设备的地点以及网络情况</li>
</ul>
</li>
</ol>
<h4 id="7-3-InnoDB-架构"><a href="#7-3-InnoDB-架构" class="headerlink" title="7.3 InnoDB 架构"></a>7.3 InnoDB 架构</h4><ul>
<li><p>缓冲池</p>
<p>  缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的数据能够直接在内存中获得，从而提高速度。</p>
</li>
<li><p>更改缓存</p>
<p>  更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索引页的更改。索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁盘。更新缓存合并期间，可能会大大降低查询的性能。在内存中，更新缓存占用一部分 InnoDB 缓冲池。在磁盘中，更新缓存是系统表空间的一部分。更新缓存的数据类型由 innodb_change_buffering 配置项管理。</p>
</li>
<li><p>自适应哈希索引</p>
<p>  自适应哈希索引将负载和足够的内存结合起来，使得 InnoDB 像内存数据库一样运行，不需要降低事务上的性能或可靠性。这个特性通过 innodb_adaptive_hash_index 选项配置，或者通过 –skip-innodb_adaptive_hash_index 命令行在服务启动时关闭。</p>
</li>
<li><p>重做日志缓存</p>
<p>  重做日志缓存存放要放入重做日志的数据。重做日志缓存大小通过 innodb_log_buffer_size 配置项配置。重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存是的大型事务能够正常运行而不需要写入磁盘。</p>
</li>
<li><p>系统表空间</p>
<p>  系统表空间包括 InnoDB 数据字典、双写缓存、更新缓存和撤销日志，同时也包括表和索引数据。多表共享，系统表空间被视为共享表空间。</p>
</li>
<li><p>双写缓存</p>
<p>  双写缓存位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存后，InnoDB 才会将数据页写入合适的位置。</p>
</li>
<li><p>撤销日志</p>
<p>  撤销日志是一系列与事务相关的插销记录的集合，包含如何撤销事务最近的更改。如果其它事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。插销日志存在于撤销日志片段中，这些片段包含于回滚片段中。</p>
</li>
<li><p>每个表一个文件的表空间</p>
<p>  每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中，而不是系统表空间中。这个功能通过 innodb_file_per_table 配置项开启。每个表空间由一个单独的 .ibd 数据文件代表，该文件默认被创建在数据库目录中。</p>
</li>
<li><p>通用表空间</p>
<p>  使用 CREATE TABLESPACE 语法创建共享的 InnoDB 表空间。通过表空间可以创建在 MySQL 数据目录之外能够管理多个表并支持所有行格式的表。</p>
</li>
<li><p>撤销表空间</p>
<p>  撤销表空间由一个或多个包含撤销日志的文件组成。撤销表空间的数量由 innodb_undo_tablespaces 配置项配置。</p>
</li>
<li><p>临时表空间</p>
<p>  用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。innodb_temp_data_file_path 配置项定义了相关的路径、名称、大小和属性。如果该值为空，默认会在 innodb_data_home_dir 变量指定的目录下创建一个自动扩展的数据文件。</p>
</li>
<li><p>重做日志</p>
<p>  重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据。正常操作期间，重做日志会将请求数据进行编码，这些请求会改变 InnoDB 表数据。遇到意外崩溃后，未完成的更改会自动在初始化期间重新进行。</p>
</li>
</ul>
<h2 id="四、索引的数据结构"><a href="#四、索引的数据结构" class="headerlink" title="四、索引的数据结构"></a>四、索引的数据结构</h2><h3 id="1-为什么使用索引"><a href="#1-为什么使用索引" class="headerlink" title="1. 为什么使用索引"></a>1. 为什么使用索引</h3><p>索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL 中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%B4%A2%E5%BC%95-1.png" alt="索引-1"></p>
<p>如上图所示，数据库没有索引的情况下，数据分布在硬盘的不同的位置上面，读取数据时，摆臂需要前后摆动查找数据，这样操作非常消耗时间。如果数据顺序摆放，那么也需要从 1 到 6 行按顺序读取，这样就相当于进行了 6 次 IO 操作，依旧非常耗时。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找 Col2 &#x3D; 89 这条记录，就要逐行去查找、去比较。从 Col2 &#x3D; 34 开始，进行比较，发现不是，继续下一行。我们当前的表只有不到 10 行数据，但如果表很大的话，有上千万条数据，就意味着要做很多很多次磁盘 I&#x2F;O 才能找到。现在要查找 Col2 &#x3D; 89 这条记录。CPU 必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最消耗时间的就是磁盘 I&#x2F;O (涉及到磁盘的旋转时间 (速度较快)、磁头的寻道时间 (速度慢、耗时))。</p>
<p>假如给数据使用二叉树这样的数据结构进行存储，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%B4%A2%E5%BC%95-2.png" alt="索引-2"></p>
<p>对字段 Col2 添加了索引，就相当于在硬盘上为 Col2 维护了一个索引的数据结构，即这个二叉搜索树。二叉搜索树的每个结点存储的是 (K, V) 结构，key 是 Col2，value 是该 key 所在行的文件指针 (地址) 。比如：该二叉搜索树的根结点就是：(34，0x07)。现在对 Col2 添加了索引，这时再去查找 Col2 &#x3D; 89 这条记录的时候会先去查找该二叉搜索树 (二叉树的遍历查找)。读 34 到内存，89 &gt; 34；继续右侧数据，读 89 到内存，89 &#x3D;&#x3D; 89；找到数据返回。找到之后就根据当前结点的 value 快速定位到要查找的记录对应的地址。我们可以发现，只需要查找两次就可以定位到记录的地址，查询速度就提高了。</p>
<p>这就是我们为什么要建索引，目的就是为了<strong>减少磁盘 I&#x2F;O 的次数</strong>，加快查询速率。</p>
<h3 id="2-索引及其优缺点"><a href="#2-索引及其优缺点" class="headerlink" title="2. 索引及其优缺点"></a>2. 索引及其优缺点</h3><h4 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h4><p>MySQL 官方对索引的定义为：<strong>索引 (index) 是帮助 MySQL 高效获取数据的数据结构</strong>。</p>
<p>索引的本质：索引是数据结构。可以简单理解为排好序的快速查找数据结构，满足特定查找算法。这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法。</p>
<p>索引是在存储引擎中实现的，因此没中存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的最大索引数和最大索引长度。所有存储引擎支持每个表至少 16 个索引，总索引长度至少为 256 字节。有些存储引擎支持更多的索引数和更大的索引长度。</p>
<h4 id="2-2-优点"><a href="#2-2-优点" class="headerlink" title="2.2 优点"></a>2.2 优点</h4><ol>
<li>类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的 IO 成本，这也是创建索引最主要的原因。</li>
<li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。</li>
<li>在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间，降低了 CPU 的消耗。</li>
</ol>
<h4 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h4><p>增加索引也有许多不利的方面，主要表现在如下几个方面：</p>
<ol>
<li>创建索引和维护索引要消耗时间，并且随着数据量的增加，所耗费的时间也会增加。</li>
<li>索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</li>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</li>
</ol>
<p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p>
<blockquote>
<p>提示：</p>
<p>索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p>
</blockquote>
<h3 id="3-InnoDB-中索引的推演"><a href="#3-InnoDB-中索引的推演" class="headerlink" title="3. InnoDB 中索引的推演"></a>3. InnoDB 中索引的推演</h3><h4 id="3-1-索引之前的查找"><a href="#3-1-索引之前的查找" class="headerlink" title="3.1 索引之前的查找"></a>3.1 索引之前的查找</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [列名列表] <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="operator">=</span> xxx;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在一个页中查找</p>
<p>  假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p>
<ul>
<li>以主键为搜索条件。可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li>
<li>以其他列作为搜索条件。因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然这种查找的效率是非常低的。</li>
</ul>
</li>
<li><p>在很多页中查找</p>
<p>  大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：</p>
<ul>
<li>定位到记录所在的页。</li>
<li>从所在的页内中查找相应的记录。</li>
</ul>
<p>  在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是超级耗时的。如果一个表有一亿条记录呢？此时索引应运而生。</p>
</li>
</ul>
<h4 id="3-2-设计索引"><a href="#3-2-设计索引" class="headerlink" title="3.2 设计索引"></a>3.2 设计索引</h4><p>建一个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line">	c1 <span class="type">INT</span>,</span><br><span class="line">  c2 <span class="type">INT</span>,</span><br><span class="line">  c3 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(c1)</span><br><span class="line">) ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure>

<p>这个新建的 index_demo 表中有两个 INT 类型的列，一个 CHAR(1) 类型的列，而且规定了 c1 列为主键，这个表使用 Compact 行格式来实际存储记录的。这里简化了index_demo 表的行格式示意图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-1.png" alt="简化行格式示意图"></p>
<p>只在示意图里展示记录的这几个部分：</p>
<ul>
<li>record_type：记录头信息的一项属性，表示记录的类型，0 表示普通记录，2 表示最小记录，3 表示最大记录，1 后文再描述。</li>
<li>next_record：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，用箭头来表明下一条记录是谁。</li>
<li>各个列的值：这里指记录在 index_demo 表中的三个列，分别是 c1、c2、c3。</li>
<li>其他信息：除了上述三种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li>
</ul>
<p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-2.png" alt="简化行格式示意图"></p>
<p>把一些记录放到页里的示意图就是：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-3.png" alt="简化行格式示意图"></p>
<p><strong>一个简单的索引设计方案：</strong></p>
<p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？ 我们可以为快速定位记录所在的数据页而建立一个目录，建这个目录必须完成下边这些事：</p>
<ul>
<li><p>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</p>
<p>  假设：每个数据页最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。有了这个假设之后我们向 index_demo 表插入 3 条记录：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> index_demo <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="string">&#x27;u&#x27;</span>), (<span class="number">3</span>, <span class="number">9</span>, <span class="string">&#x27;d&#x27;</span>), (<span class="number">5</span>, <span class="number">3</span>, <span class="string">&#x27;y&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>  那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-4.png" alt="简化行格式示意图"></p>
<p>  从图中可以看出来，index_demo 表中的 3 条记录都被插入到了编号为 10 的数据页中。此时我们再来插一条记录：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> index_demo <span class="keyword">VALUES</span>(<span class="number">4</span>, <span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>  因为页 10 最多只能放 3 条记录，所以我们不得不再分配一个新页：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-5.png" alt="简化行格式示意图"></p>
<p>  注意，新分配的数据页编号可能并不是连续的。它们只是通过维护着上个页和下一个页的编号而建立了链表关系。另外，页 10 中用户记录最大的主键值是 5，而页 28 中有一条记录的主键值是 4，因为 5 ＞ 4，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为 4 的记录的时候需要伴随着一次记录移动，也就是把主键值为 5 的记录移动到页 28 中，然后再把主键值为 4 的记录插入到页 10 中，这个过程的示意图如下：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-6.png" alt="简化行格式示意图"></p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../.vuepress/public/mysql/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-7.png" alt="简化行格式示意图"></p>
<p>  这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：下一个数据页的用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程称为<strong>页分裂</strong>。</p>
</li>
<li><p>给所有的页建立一个目录项。</p>
<p>  由于数据页的编号可能是不连续的，所以在向 index_demo 表中插入许多条记录后，可能是这样的效果：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-8.png" alt="简化行格式示意图"></p>
<p>  因为这些 16KB 的页在物理存储上是不连续的，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给他们做个目录，每个页对应一个目录项，每个目录项包括下边两部分：</p>
<ul>
<li>页的用户记录中最小的主键值，用 key 表示。</li>
<li>页号，用 page_no 表示。</li>
</ul>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-9.png" alt="简化行格式示意图"></p>
<p>  以页 28 为例，它对应目录项 2，这个目录项中国呢包含着该页的页号 28 以及该页中用户记录的最小主键值 5。只需要把几个目录项在物理存储器上连续存储 (比如：数组)，就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：</p>
<ul>
<li>先从目录项中根据二分法快速确定出主键值为 20 的记录在目录项 3 中 (因为 12 &lt; 20 &lt; 209)，它对应的页是页 9。</li>
<li>再根据在页中查找记录的方式去页 9 中定位具体的记录。</li>
</ul>
</li>
</ul>
<p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为索引。</p>
<p><strong>InnoDB 中的索引方案</strong></p>
<ul>
<li><p>迭代 1 次：目录项记录的页</p>
<p>  上边称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用二分法快速定位具体的目录项而假设所有目录项都可以在物理存储器上连续存储，但是这样做有几个问题：</p>
<ul>
<li>InnoDB 是使用页来作为管理存储空间的基本单位，最多能保证 16KB 的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</li>
<li>我们时常会对记录进行增删，假设我们把页 28 中的记录都删除了，那意味着目录项 2 也就没有存在的必要了，这就需要吧目录项 2 后的目录项都向前移动一下，这样牵一发而动全身的操作效率很差。</li>
</ul>
<p>  所以，我们需要一种可以灵活管理所有目录项的方式。我们发现目录项其实长得跟我们的用户记录差不多，只不过目录项中的两个列是主键和页号而已，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录。那 InnoDB 怎么区分一条记录是普通的用户记录还是目录项记录呢？使用记录头信息里的 record_type 属性，它的各个取值代表的意思如下：</p>
<ul>
<li>0：普通的用户记录</li>
<li>1：目录项记录</li>
<li>2：最小记录</li>
<li>3：最大记录</li>
</ul>
<p>  我们把前边使用到的目录项放到数据页中的样子就是这样：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-10.png" alt="简化行格式示意图"></p>
<p>  从图中可以看出来，我们新分配了一个编号为 30 的页来专门存储目录项记录。这里再次强调目录项记录和普通用户记录的不同点：</p>
<ul>
<li>目录项记录的 record_type 值是 1，而普通用户记录的 record_type 值是 0。</li>
<li>目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有 InnoDB 自己添加的隐藏列。</li>
<li>了解：记录头信息里还有一个叫 min_rec_mask 的属性，只有在存储目录项记录的页中的主键值最小的目录项记录的 min_rec_mask 值为 1，其它别的记录的 min_rec_mask 值都是 0。</li>
</ul>
<p>  <strong>相同点</strong>：两者用的是一样的数据页，都会为主键值生成 Page Directory (页目录)，从而在按照主键值进行查找时可以使用二分法来加快查询速度。</p>
<p>  现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p>
<ul>
<li>先到存储目录项记录的页，也就是页 30 中通过二分法快速定位到对应目录项，因为 12 &lt; 20 &lt; 209，所以定位到对应的记录所在的页就是页 9。</li>
<li>再到存储用户记录的页 9 中根据二分法快速定位到主键值为 20 的用户记录。</li>
</ul>
</li>
<li><p>迭代 2 次：多个目录项记录的页</p>
<p>  虽然说目录项记录中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有 16KB 大小，能存放的目录项记录也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的目录项记录，如何处理呢？</p>
<p>  这里假设一个存储目录项记录的页最多只能存放 4 条目录项记录，所以如果此时再向上图中插入一条主键值为 320 的用户记录的话，那就需要分配一个新的存储目录项记录的页：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-11.png" alt="简化行格式示意图"></p>
<p>  从图中可以看出，插入了一条主键值为 320 的用户记录之后需要两个新的数据页：</p>
<ul>
<li>为存储该用户记录而新生成了页 31。</li>
<li>因为原先存储目录项记录的页 30 的容量已满 (假设只能存储 4 条目录项记录)，所以不得不需要一个新的页 32 来存放页 31 对应的目录项。</li>
</ul>
<p>  现在因为存储目录项记录的页不止一个，所以如果想根据主键值查找一条用户记录大致需要 3 个步骤，以查找主键值为 20 的记录为例：</p>
<ul>
<li>确定目录项记录页。现在的存储目录项记录的页有两个，即页 30 和 页 32，又因为页 30 表示的目录项的主键值的范围是 [1, 320)，页 32 表示的目录项的主键值不小于 320，所以主键值为 20 的记录对应的目录项记录在页 30 中。</li>
<li>通过目录项记录页确定用户记录真实所在的页。在一个存储目录项记录的页中通过主键值定位一条目录项记录的方式说过了。</li>
<li>在真实存储用户记录的页中定位到具体的记录。</li>
</ul>
</li>
<li><p>迭代 3 次：目录项记录页的目录页</p>
<p>  问题来了，在这个查询步骤的第一步中我们需要定位存储目录项记录的页，但是这些页是不连续的，如果我们表中的数据非常多则会产生很多存储目录项记录的页，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-12.png" alt="简化行格式示意图"></p>
<p>  如图，我们生成了一个存储更高级目录项的页 33，这个页中的两条记录分别代表页 30 和页 32，如果用户记录的主键值在 [1, 320) 之间，则到页 30 中查找更详细的目录项记录，如果主键值不小于 320 的话，就到页 32 中查找更详细的目录项记录。</p>
<p>  随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用瞎编的这个图来描述它：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/B+%E6%A0%91-1.png" alt="B+树-1"></p>
<p>  这个数据结构，它的名称是 B+ 树。</p>
</li>
<li><p>B+ Tree</p>
<p>  不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到 B+ 树这个数据结构中了，所以我们也称这些数据页为节点。从图中可以看出，我们的实际用户记录其实都存放在 B+ 树的最底层的节点上，这些节点也被称为叶子结点，其余用来存放目录项的节点称为非叶子节点或者内节点，其中 B+ 树最上边的那个节点也称为根结点。</p>
<p>  一个 B+ 树的结点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页最多存放 3 条记录，存放目录项记录的页最多存放 4 条记录。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放 100 条用户记录，所有存放目录项记录的内节点代表的数据页可以存放 1000 条目录项记录，那么：</p>
<ul>
<li>如果 B+ 树只有一层，也就是只有一个用于存放用户记录的节点，最多能存放 100 条记录。</li>
<li>如果 B+ 树有两层，最多能存放 1000 * 100 &#x3D; 100 000 条记录。</li>
<li>如果 B+ 树有三层，最多能存放 1000 * 1000 * 100 &#x3D; 100 000 000 条记录。</li>
<li>如果 B+ 树有四层，最多能存放 1000 * 1000 * 1000 * 100 &#x3D; 100 000 000 000 条记录。</li>
</ul>
<p>  你的表里能存放 100000000000 条记录吗？所以<strong>一般情况下，我们用到的 B+ 树都不会超过 4 层</strong>，那我们通过主键值去查找某条记录最多只需要做 4 个页面内的查找 (查找 3 个目录项页和一个用户记录页)，又因为在每个页面内有所谓的 Page Directory (页目录)，所以在页面内也可以通过二分法实现快速定位记录。</p>
</li>
</ul>
<h4 id="3-3-常见索引概念"><a href="#3-3-常见索引概念" class="headerlink" title="3.3 常见索引概念"></a>3.3 常见索引概念</h4><p>索引按照物理实现方式，索引可以分为 2 种：聚簇索引和非聚簇索引。我们也把非聚簇索引称为二级索引或者辅助索引。</p>
<ul>
<li><p><strong>聚簇索引</strong></p>
<p>  聚簇索引并不是一种单独的索引类型，而是一种数据存储方式 (所有的用户记录都存储在了叶子节点)，也就是所谓的<strong>索引即数据，数据即索引</strong>。</p>
<blockquote>
<p>术语“聚簇”表示数据行和相邻的键值聚簇的存储在一起。</p>
</blockquote>
<p>  特点：</p>
<ul>
<li>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：<ul>
<li>页内的记录是按照主键的大小顺序排成一个单向链表。</li>
<li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</li>
<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li>
</ul>
</li>
<li>B+ 树的叶子节点存储的是完整的用户记录。所谓完整的用户记录，就是指这个记录中存储了所有列的值 (包括隐藏列)。</li>
</ul>
<p>  我们把具有这两种特性的 B+ 树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子结点处。这种聚簇索引并不需要我们在 MySQL 语句中显式的使用 INDEX 语句去创建，InnoDB 存储引擎会自动的为我们创建聚簇索引。</p>
<p>  优点：</p>
<ul>
<li>数据访问更快，因为聚簇索引将索引和数据保存在同一个 B+ 树中，因此从聚簇索引中获取数据比非聚簇索引更快。</li>
<li>聚簇索引对于主键的排序查找和范围查找速度非常快。</li>
<li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的 I&#x2F;O 操作。</li>
</ul>
<p>  缺点：</p>
<ul>
<li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主键。</li>
<li>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义主键为不可更新。</li>
<li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</li>
</ul>
<p>  限制：</p>
<ul>
<li>对于 MySQL 数据库目前只有 InnoDB 数据引擎支持聚簇索引，而 MyISAM 并不支持聚簇索引。</li>
<li>由于数据物理存储排序方式只能有一种，所以每个 MySQL 的表只能有一个聚簇索引。一般情况下就是该表的主键。</li>
<li>如果没有定义主键，InnoDB 会选择非空的唯一索引代替。如果没有这样的索引，InnoDB 会隐式的定义一个主键来作为聚簇索引。</li>
<li>为了充分利用聚簇索引的聚簇的特性，所以 InnoDB 表的主键列尽量选用有序的顺序 ID，而不建议用无需的id，比如 UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。</li>
</ul>
</li>
<li><p><strong>二级索引 (辅助索引、非聚簇索引)</strong></p>
<p>  上边介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用，因为 B+ 树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办呢？肯定不能是从头到位沿着链表依次遍历记录一遍。</p>
<p>  答案：我们可以多建几棵 B+ 树，不同的 B+ 树中的数据采用不同的排序规则。比方说我们用 c2 列的大小作为数据页、页中巨鹿的排序规则，再建一棵 B+ 树，效果如下图所示：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png" alt="二级索引"></p>
<p>  这个 B+ 树与上边介绍的聚簇索引有几处不同：</p>
<ul>
<li>使用记录 c2 列的大小进行记录和页的排序，这包括三方面的含义：<ul>
<li>页内的记录是按照 c2 列的大小顺序排成一个单向链表。</li>
<li>各个存放用户记录的页也是根据页中记录的 c2 列大小顺序排成一个双向链表。</li>
<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的 c2 列大小顺序排成一个双向链表。</li>
</ul>
</li>
<li>B+ 树的叶子节点存储的并不是完整的用户记录，而只是 c2 列 + 主键这两个列的值。</li>
<li>目录项记录中不再是主键 + 页号的搭配，而变成了 c2 列 + 页号的搭配。</li>
</ul>
<p>  所以如果我们想再想通过 c2 列的值查找某些记录的话就可以使用我们刚刚建好的这个 B+ 树了。以查找 c2 列的值为 4 的记录为例，查找过程如下：</p>
<ul>
<li>确定目录项记录页。根据跟页面，也就是页 44，可以快速定位到目录项记录所在的页为页 42 (因为 2 &lt; 4 &lt; 9)。</li>
<li>通过目录项记录页确定用户记录真实所在的页。在页 42 中可以快速定位到实际存储用户记录的页，但是由于 c2 列并没有唯一性约束，所以 c2 列值为 4 的记录可能分布在多个数据页中，又因为 2 &lt; 4 ≤ 4，所以确定实际存储用户记录的页在页 34 和页 35 中。</li>
<li>在真实存储用户记录的页中定位到具体的记录。到页 34 和页 35 中定位到具体的记录。</li>
<li>但是这个 B+树的叶子节点中的记录只存储了 c2 和 c1 (也就是主键) 两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</li>
</ul>
<p>  <strong>概念：回表</strong></p>
<p>  我们根据这个以 c2 列大小排序的 B+ 树只能确定我们要查找记录的主键值，所以如果我们想根据 c2 列的值查找到完整的用户记录的话，仍然需要到聚簇索引中再查找一遍，这个过程称为回表。也就是根据 c2 列的值查询一条完整的用户记录需要使用到两棵 B+ 树。</p>
<p>  <strong>问题</strong>：为什么我们还需要一次回表操作呢？直接把完整的用户记录放到叶子节点不行吗？</p>
<p>  <strong>回答</strong>：如果把完整的用户记录放到叶子节点是不用回表。但是 太占地方了，相当于每建立一棵 B+ 树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。</p>
<p>  因为这种按照非主键列建立的 B+ 树需要一次回表操作才可以定位到完整的用户记录，所以这种 B+ 树也被称为二级索引 (英文名 secondary index)，或者辅助索引。由于我们使用的是 c2 列的大小作为 B+ 树的排序规则，所以我们也称这个 B+ 树是为 c2 列建立的索引。</p>
<p>  非聚簇索引的存在不影响数据在聚簇索引中的组织，索引一张表可以有多个非聚簇索引。</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E5%A4%9A%E4%B8%AA%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt="多个非聚簇索引"></p>
<p>  <strong>小结</strong>：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：</p>
<ul>
<li>聚簇索引的叶子节点存储的就是我们的数据记录，非聚簇索引的叶子节点存储的是数据位置。非聚簇索引不会影响数据表的物理存储顺序。</li>
<li>一个表只能有一个聚簇索引，因为只能有一种排序存储的方式，但可以有多个非聚簇索引，也就是多个索引目录提供数据检索。</li>
<li>使用聚簇索引的时候，数据的查询效率高，但如果对数据进行插入、删除、更新等操作，效率会比非聚簇索引低。</li>
</ul>
</li>
<li><p><strong>联合索引</strong></p>
<p>  我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让 B+ 树按照 c2 和 c3 列的大小进行排序，这个包含两层含义：</p>
<ul>
<li>先把各个记录和页按照 c2 列进行排序。</li>
<li>在记录的 c2 列相同的情况下，采用 c3 列进行排序。</li>
</ul>
<p>  为 c2 和 c3 列建立的索引的示意图如下：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.png" alt="联合索引"></p>
<p>  如图所示，我们需要注意以下几点：</p>
<ul>
<li>每条目录项记录都由 c2、c3、页号这三个部分组成，各条记录先按照 c2 列的值进行排序，如果记录的 c2 列相同，则按照 c3 列的值进行排序。</li>
<li>B+ 树叶子节点处的用户记录由 c2、c3 和主键 c1 列组成。</li>
</ul>
<p>  注意一点，以 c2 和 c3 列的大小为排序规则建立的 B+ 树称为联合索引，本质上也是一个二级索引。它的意思与分别为 c2 和 c3 列分别建立索引的表述是不同的，不同点如下：</p>
<ul>
<li>建立联合索引只会建立如上图一样的一棵 B+ 树。</li>
<li>为 c2 和 c3 列分别建立索引会分别以 c2 和 c3 列的大小为排序规则建立两棵 B+ 树。</li>
</ul>
</li>
</ul>
<h4 id="3-4-InnoDB-的-B-树索引的注意事项"><a href="#3-4-InnoDB-的-B-树索引的注意事项" class="headerlink" title="3.4 InnoDB 的 B+ 树索引的注意事项"></a>3.4 InnoDB 的 B+ 树索引的注意事项</h4><p><strong>根页面位置万年不动</strong></p>
<p>前面介绍 B+ 树索引的时候，为了理解方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上 B+ 树的形成过程是这样的：</p>
<ul>
<li>每当为某个表创建一个 B+ 树索引 (聚簇索引不是人为创建的，默认就有) 的时候，都会为这个索引创建一个根结点页面。最开始表中没有数据的时候，每个 B+ 树索引对应的根结点中既没有用户记录，也没有目录项记录。</li>
<li>随后向表中插入用户记录时，先把用户记录存储到这个根结点中。</li>
<li>当根结点中的可用空间用完时继续插入记录，此时会将根结点中的所有记录复制到一个新分配的页，比如页 a 中，然后对这个新页进行页分裂的从左，得到另一个新页，比如页 b。这时新插入的记录根据键值 (也就是聚簇索引中的主键值，二级索引中对应的索引列的值) 的大小就会被分配到页 a 或者页 b 中，而根结点便升级为存储目录项记录的页。</li>
</ul>
<p>这个过程特别注意的是：一个 B+ 树索引的根结点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根结点的页号便会被记录到某个地方，然后凡是 InnoDB 存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根结点的页号，从而来访问这个索引。</p>
<p><strong>内节点中目录项记录的唯一性</strong></p>
<p>我们知道 B+ 树索引的内节点中目录项记录的内容是索引列 + 页号的搭配，但是这个搭配对于耳机索引来说有点不严谨。以 index_demo 为例，假设这个表中的数据是这样的：</p>
<table>
<thead>
<tr>
<th>c1</th>
<th>c2</th>
<th>c3</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>‘u’</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>‘d’</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>‘y’</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td>‘a’</td>
</tr>
</tbody></table>
<p>如果二级索引中目录项记录的内容只是索引列 + 页号的搭配的话，那么为 c2 列建立索引后的 B+ 树应该长这样：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/index_demoB+%E6%A0%91.png" alt="index_demoB+树"></p>
<p>如果我们相信插入一行记录，其中 c1、c2、c3 的值分别是：9、1、’c’，那么在修改这个 c2 列建立的二级索引对应的 B+ 树时碰到了个大问题：由于页 3 中存储的目录项记录是由 c2 列 + 页号的值构建成的，页 3 中的两条目录项记录对应的 c2 列的值都是 1，而我们新插入的这条记录的 c2 列的值也是 1，那我们这条新插入的记录到底应该放到页 4 中，还是应该放到页 5 中啊？</p>
<p>为了让新插入记录能找到自己在哪个页里，我们需要保证在 B+ 树的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于耳机索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>
<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号</li>
</ul>
<p>也就是把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证 B+ 树每一层中各条目录项记录除页号这个字段外是唯一的，所以我们为 c2 列建立二级索引后的示意图实际上应该是这样子的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/index_demoB+%E6%A0%912.png" alt="index_demoB+树"></p>
<p>这样我们再插入记录 (9, 1, ‘c’) 时，由于页 3 中存储的目录项记录是由 c2 列 + 主键 + 页号的值构成的，可以先把新纪录的 c2 列的值和页 3中各目录项记录的 c2 列的值做比较，如果 c2 列的值相同的话，可以接着比较主键值，因为 B+ 树同一层中不同目录项记录的 c2 列 + 主键值 的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新纪录应该被插入到页 5 中。</p>
<p><strong>一个页面最少存储两条记录</strong></p>
<p>一个 B+ 树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为 B+ 树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉很多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是啥效果呢？那就是目录层级非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半条劲只能存放一条真实的用户记录？所以 InnoDB 的一个数据页至少可以存放两条记录。</p>
<h3 id="4-MyISAM-中的索引方案"><a href="#4-MyISAM-中的索引方案" class="headerlink" title="4. MyISAM 中的索引方案"></a>4. MyISAM 中的索引方案</h3><p>B 树索引适用存储引擎如表所示：</p>
<table>
<thead>
<tr>
<th>索引 &#x2F; 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>B-Tree 索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>即使多个存储引擎支持同一种类型的索引，但是她们的实现原理也是不同的。InnoDB 和 MyISAM 默认的索引是 BTree 索引；而 Memory 默认的索引是 Hash 索引。</p>
<p>MyISAM 引擎使用 B+ 树作为索引结构，叶子节点的 data 域存放的是数据记录的地址。</p>
<h4 id="4-1-MyISAM-索引的原理"><a href="#4-1-MyISAM-索引的原理" class="headerlink" title="4.1 MyISAM 索引的原理"></a>4.1 MyISAM 索引的原理</h4><p>InnoDB 中索引即数据，也就是聚簇索引的那棵 B+ 树的叶子节点中已经把所有完整的用户记录都包含了，而 MyISAM 的索引方案虽然也适用树形结构，但是却将索引和数据分开存储：</p>
<ul>
<li>将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为数据文件。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。</li>
<li>使用 MyISAM 存储引擎的表会把索引信息另外存储到一个称为索引文件的另一个文件中。MyISAM 会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是主键值 + 数据记录地址的组合。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/MyISAM%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84-1.png" alt="MyISAM索引结构-1"></p>
<p>这里设表一共有三列，假设我们以 col1 为主键，上图是一个 MyISAM 表的主索引 (Primary key) 示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。在 MyISAM 中，主键索引和二级索引 (Secondary key) 在结构上没有任何区别，只是主键索引要求 key 是唯一的，而二级索引的 key 可以重复。如果我们在 col2 上建立一个二级索引，则此索引的结构如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/MyISAM%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84-2.png" alt="MyISAM索引结构-2"></p>
<p>同样也是一棵 B+ 树，data 域保存数据记录的地址。因为，MyISAM 中索引检索的算法为：首先按照 B+ 树搜索算法搜索索引，如果指定的 key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。</p>
<h4 id="4-2-MyISAM-与-InnoDB-对比"><a href="#4-2-MyISAM-与-InnoDB-对比" class="headerlink" title="4.2 MyISAM 与 InnoDB 对比"></a>4.2 MyISAM 与 InnoDB 对比</h4><p>MyISAM 的索引方式都是非聚簇的，与 InnoDB 包含 1 个聚簇索引是不同的。小结两种引擎索引的区别：</p>
<ul>
<li>在 InnoDB 存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次回表操作，意味着 MyISAM 中建立的索引相当于全部都是二级索引。</li>
<li>InnoDB 的数据文件本身就是索引文件，而 MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</li>
<li>InnoDB 的非聚簇索引 data 域存储相应记录主键的值，而 MyISAM 索引记录的是地址。换句话说，InnoDB 的所有非聚簇索引都引用主键作为 data 域。</li>
<li>MyISAM 的回表操作是十分快速的，因为是拿地址偏移量直接到文件中取数据的，反观 InnoDB 是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</li>
<li>InnoDB 要求表必须有主键 (MyISAM 可以没有)。如果没有显示指定，则 MySQL 系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整型。</li>
</ul>
<p><strong>小结</strong>：</p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助。比如：</p>
<ul>
<li>知道了 InnoDB 的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。</li>
<li>用非单调的字段作为主键在 InnoDB 中不是好主意，因为 InnoDB 数据文件本身是一棵 B+ 树，非单调的主键会造成在插入新纪录时，数据文件为了维持 B+ 树的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</li>
</ul>
<h3 id="5-索引的代价"><a href="#5-索引的代价" class="headerlink" title="5. 索引的代价"></a>5. 索引的代价</h3><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p>
<ul>
<li><p>空间上的代价</p>
<p>  每建立一个索引都要为它建立一棵 B+ 树，每一棵 B+ 树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的 B+ 树由许多数据页组成，那就是很大的一片存储空间。</p>
</li>
<li><p>时间上的代价</p>
<p>  每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+ 树索引。而且 B+ 树每层节点都是按照索引列的值从小到大的顺序排列而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录 (也就是不论是用户记录还是目录项记录) 都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的 B+ 树都要进行相关的维护操作，会给性能拖后腿。</p>
</li>
</ul>
<blockquote>
<p>一个表上索引建得越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们得学学这些索引在哪些条件下起作用的。</p>
</blockquote>
<h3 id="6-MySQL-数据结构选择的合理性"><a href="#6-MySQL-数据结构选择的合理性" class="headerlink" title="6. MySQL 数据结构选择的合理性"></a>6. MySQL 数据结构选择的合理性</h3><p>从 MySQL 的角度讲，不得不考虑一个现实问题就是磁盘 IO。如果我们能让索引的数据结构尽量减少硬盘的 I&#x2F;O 操作，所消耗的时间也越小。可以说，磁盘的 I&#x2F;O 操作次数对索引的使用效率至关重要。</p>
<p>查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个 G 甚至更多，为了减少索引在内存的占用，数据库索引是存储在外部磁盘上的。当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载，那么 MySQL 衡量查询效率的标准就是磁盘 IO 次数。</p>
<h4 id="6-1-全表遍历"><a href="#6-1-全表遍历" class="headerlink" title="6.1 全表遍历"></a>6.1 全表遍历</h4><p>略</p>
<h4 id="6-2-Hash-结构"><a href="#6-2-Hash-结构" class="headerlink" title="6.2 Hash 结构"></a>6.2 Hash 结构</h4><p>Hash 本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。</p>
<p>Hash 算法是通过某种确定性的算法 (比如 MD5、SHA1、SHA2、SHA3) 将输入转变为输出。相同的输入永远可以得到相同的输出，假设输入内容有微小偏差，在输出中通常会有不同的结果。</p>
<p>举例：如果你想要验证两个文件是否相同，那么你不需要把两份文件直接拿来比对，只需要让对方把 Hash 函数计算得到的结果告诉你即可，然后在本地同样对文件进行 Hash 函数的运算，最后通过比较这两个 Hash 函数的结果是否相同，就可以知道这两个文件是否相同。</p>
<p><strong>加速查找速度的数据结构，常见的有两类</strong>：</p>
<ul>
<li>树，例如平衡二叉搜索树，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是 O(log<sub>2</sub>N)。</li>
<li>哈希，例如 HashMap，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是 O(1)。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%951.png" alt="哈希算法"></p>
<p>采用 Hash 进行检索效率非常高，基本上一次检索就可以找到数据，而 B+ 树需要自顶向下依次查找，多次访问节点才能找到数据，中间需要多次 I&#x2F;O 操作，从效率来说 Hash 比 B+ 树更快。</p>
<p>在哈希的方式下，一个元素 k 处于 h(k) 中，即利用哈希函数 h，根据关键字 k 计算出槽的位置。函数 h 将关键字域映射到哈希表 T[0 ··· m - 1] 的槽位上。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%952.png" alt="哈希算法2"></p>
<p>上图中哈希函数 h 有可能将两个不同的关键字映射到相同的位置，这叫做碰撞，在数据库中一般采用链接法来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%953.png" alt="哈希算法3"></p>
<p>实验：体会数组和 hash 表的查找方面的效率区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法复杂度为 O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">in</span>[<span class="number">100000</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100000</span>; j++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(temp == arr[i]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  System.out.println(<span class="string">&quot;time: &quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法复杂度为 O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">  HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">100000</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    set.add(i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> j;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> set.contains(temp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  System.out.println(<span class="string">&quot;time: &quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Hash 结构效率高，那为什么索引结构要设计成树型呢</strong>？</p>
<ul>
<li>Hash 索引仅能满足 &#x3D; 、&lt;&gt; 和 IN 查询。如果进行范围查询，哈希型的索引，时间复杂度会退化为 O(n)；而树型的有序特性，依然能够保持 O(log<sub>2</sub>N) 的高效率。</li>
<li>Hash 索引还有一个缺陷，数据的存储是没有顺序的，在 ORDER BY 的情况下，使用 Hash 索引还需要对数据重新排序。</li>
<li>对于联合索引的情况，Hash 值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。</li>
<li>对于等值查询来说，通常 Hash 索引的效率更高，不过也存在一种情况，就是索引列的重复值如果很多，效率就会降低。这是因为遇到 Hash 冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以，Hash 索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。</li>
</ul>
<p><strong>Hash 索引适用存储引擎如表所示</strong>：</p>
<table>
<thead>
<tr>
<th>索引 &#x2F; 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>Hash 索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p><strong>Hash 索引的适用性</strong>：</p>
<p>Hash 索引存在着很多限制，相比之下在数据库中 B+ 树索引的使用面会更广，不过也有一些场景采用 Hash 索引效率更高，比如在键值型 (Key-Value) 数据库中，Redis 存储的核心就是 Hash 表。</p>
<p>MySQL 中的 Memory 存储引擎支持 Hash 存储，如果我们需要用到查询的临时表时，就可以选择 Memory 存储引擎，把某个字段设置为 Hash 索引，比如字符串类型的字段，进行 Hash 计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要等值查询的时候，采用 Hash 索引是个不错的选择。</p>
<p>另外，InnoDB 本身不支持 Hash 索引，但是提供自适应 Hash 索引 (Adaptive Hash Index)。什么情况下才会使用自适应 Hash 索引呢？如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到 Hash 表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让 B+ 树也具备了 Hash 索引的优点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95.png" alt="自适应哈希索引"></p>
<p> 采用自适应 Hash 索引的目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。</p>
<p>可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%adaptive_hash_index&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-二叉搜索树"><a href="#6-3-二叉搜索树" class="headerlink" title="6.3 二叉搜索树"></a>6.3 二叉搜索树</h4><p>如果我们利用二叉树作为索引结构，那么磁盘的 IO 次数和索引树的高度是相关的。</p>
<p><strong>二叉搜索树的特点</strong></p>
<ul>
<li>一个节点只能有两个子节点，也就是一个节点度不能超过 2</li>
<li>左子节点 &lt; 本节点；右子节点 &gt; 本节点，比我大的向右，比我小的向左</li>
</ul>
<p><strong>查找规则</strong></p>
<p>最基础的二叉搜索树 (Binary Search Tree)，搜索某个节点和插入节点的规则一样，假设搜索插入的数值为 key：</p>
<ul>
<li>如果 key 大于根结点，则在右子树中进行查找；</li>
<li>如果 key 小雨根结点，则在左子树中进行查找；</li>
<li>如果 key 等于根结点，也就是找到了这个节点，返回根结点即可。</li>
</ul>
<p>举个例子，对数列 (34, 22, 89, 5, 23, 77, 91) 创造出来的二分查找树如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-1.png" alt="二叉搜索树"></p>
<p>但是存在特俗的情况，就是有时候二叉树的深度非常大。比如我们给出的数据顺序是 (5, 22, 23, 34, 77, 89, 91)，创造出来的二分搜索树如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-2.png" alt="二叉搜索树"></p>
<p>上面第二棵树也属于二分查找树，但是性能上已经退化成了一条链表，查找数据的时间复杂度变成了 O(n)。能看出来第一个树的深度是 3，也就是说最多只需 3 次比较，就可以找到结点，而第二个树的深度是 7，最多需要 7 次比较才能找到结点。</p>
<p>为了提高查询效率，就需要减少磁盘 IO 数。为了减少磁盘 IO 的次数，就需要尽量降低树的高度，需要把原来高瘦的树结构变得矮胖，树的每层的分叉越多越好。</p>
<h4 id="6-4-AVL-树"><a href="#6-4-AVL-树" class="headerlink" title="6.4 AVL 树"></a>6.4 AVL 树</h4><p>为了解决上面二叉搜索树退化成链表的问题，人们提出了平衡二叉搜索树 (Balanced Binary Tree)，又称为 AVL 树，它在二叉搜索树的基础上增加了约束，具有以下性质：</p>
<p><strong>它是一棵空树或他的左右两个紫薯的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树</strong>。</p>
<p>这里说一下，常见的平衡二叉树有很多种，包括了平衡二叉搜索树、红黑树、数堆、伸展树。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到了平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就属于平衡二叉搜索树，搜索时间复杂度就是 O(log<sub>2</sub>n)。</p>
<p>数据查询的时间主要依赖于磁盘 I&#x2F;O 的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改进，树的深度也是 O(log<sub>2</sub>n)，当 n 比较大时，深度也是比较高的，比如下图的情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/avl%E6%A0%91.png" alt="avl树"></p>
<p>每访问一次节点就需要进行一次磁盘 I&#x2F;O 操作，对于上面的树来说，我们需要进行 5 次 I&#x2F;O 操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘 I&#x2F;O 操作次数多，会影响整体数据查询的效率。</p>
<p>针对同样的数据，如果我们把二叉树改成 M 叉树 (M &gt; 2) 呢？当 M &#x3D; 3 时，同样的 31 个节点可以由下面的三叉树来进行存储：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E5%B9%B3%E8%A1%A1%E4%B8%89%E5%8F%89%E6%A0%91.png" alt="平衡三叉树"></p>
<p>能看到此时树的高低降低了，当数据量 N 大的时候，以及树的分叉数 M 大的时候，M 叉树的高度会远小于二叉树的高度 (M &gt; 2)。所以，我们需要把树丛高瘦变矮胖。</p>
<h4 id="6-5-BTree"><a href="#6-5-BTree" class="headerlink" title="6.5 BTree"></a>6.5 BTree</h4><p>B 树的英文是 Balance Tree，也就是多路平衡查找树。简写为 B-Tree。它的高度远小于平衡二叉树的高度。</p>
<p>B 树的结构如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/B%E6%A0%91.png" alt="B树"></p>
<p>B 树作为多路平衡查找树，它的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶。每个磁盘块包括了关键字和子节点的指针。如果一个磁盘块中包括了 x 个关键字，那么指针数就是 x+1。对于一个 100 阶的 B 树来说，如果有 3 层的话最多可以存储约 100 万的索引数据。对于大量的索引数据来说，采用 B 树的结构是非常适合的，因为树的高度要远小于二叉树的高度。</p>
<p>一个 M 阶的 B 树 (M &gt; 2) 有以下的特性：</p>
<ul>
<li>根结点的儿子树的范围是 [2, M]。</li>
<li>每个中间节点包含 k - 1 个关键字和 k 个孩子，孩子的数量 &#x3D; 关键字的数量 +1，k 的取值范围为 [ceil(M &#x2F; 2), M]。</li>
<li>叶子节点包括 k - 1 个关键字 (叶子节点没有孩子)，k 的取值范围为 [ceil(M &#x2F; 2), M]。</li>
<li>假设中间节点的关键字为：Key[1], Key[2], …, Key[k - 1]，且关键字按照升序排序，即 Key[i] &lt; Key[i + 1]。此时 k - 1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i - 1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k - 1] 的子树。</li>
<li>所有叶子节点位于同一层。</li>
</ul>
<p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。可以看下磁盘块 2，里面的关键字为 (8, 12)，它有 3 个孩子 (3, 5)，(9, 10)， (13, 15)，能看到 (3, 5) 小于 8，(9, 10) 在 8 和 12 之间，而 (13, 15) 大于 12，刚好符合刚才给出的特征。</p>
<p>然后看下如何用 B 树进行查找。假设想要查找的关键字是 9，那么步骤可以分为以下几步：</p>
<ul>
<li>与根结点的关键字 (17, 35) 进行比较，9 小于 17 纳米得到指针 P1；</li>
<li>按照指针 P1 找到磁盘块 2，关键字为 (8, 12)，因为 9 在 8 和 12 之间，所以得到指针 P2；</li>
<li>按照指针 P2 找到磁盘块 6，关键字为 (9, 10)，然后找到了关键字 9。</li>
</ul>
<p>能看出来在 B 树的搜索过程中，比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I&#x2F;O 操作，消耗的时间比在内存中进行比较所需的时间要多，是数据查找用时的重要因素。<strong>B 树相比于平衡二叉树来说磁盘 I&#x2F;O 操作要少</strong>，在数据查询中比平衡二叉树效率要高。所以<strong>只要树的高度足够低，IO 次数足够少，就可以提高查询性能</strong>。</p>
<p><strong>小结</strong>：</p>
<ul>
<li>B 树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li>
<li>关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束。</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找。</li>
</ul>
<p>例子：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/B%E6%A0%91%E4%BE%8B%E5%AD%90.png" alt="B树例子"></p>
<h4 id="6-6-B-Tree"><a href="#6-6-B-Tree" class="headerlink" title="6.6 B + Tree"></a>6.6 B + Tree</h4><p>B+ 树也是一种多路搜索树，基于 B 树做出了改进，主流的 DBMS 都支持 B+ 树的索引方式，比如 MySQL。相比于 B-Tree，B+Tree 适合文件索引系统。</p>
<p><strong>B+ 树和 B 树的差异在于以下几点</strong>：</p>
<ul>
<li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字树 + 1。</li>
<li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大或最小。</li>
<li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中，非叶子节点及保存索引，也保存数据记录。</li>
<li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</li>
</ul>
<p>下图就是一棵 B+ 树，阶数为 3，根节点中的关键字 1、18、35 分别是子节点 (1, 8, 14)，(18, 24,31) 和 (35, 41, 53) 中的最小值。每一层父节点的关键字都会出现在下一层的子节点的关键字中，因此在叶子节点中包括了所有的关键字信息，并且每一个叶子节点都有一个只想下一个节点的指针，这样就形成了一个链表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/B+%E6%A0%91.png" alt="B+树"></p>
<p>如果，想要查找关键字 16，B+ 树会自顶向下逐层进行查找：</p>
<ul>
<li>与根结点的关键字 (1, 18, 35) 进行比较，16 在 1 和 18 之间，得到指针 P1 (指向磁盘块 2)</li>
<li>找到磁盘块 2，关键字为 (1, 8, 14)，因为 16 大于 14，所以得到指针 P3 (指向磁盘块 7)</li>
<li>找到磁盘块 7，关键字为 (14, 16, 17)，然后找到了关键字 16，所以可以找到关键字 16 所对应的数据。</li>
</ul>
<p>整个过程一共进行了 3 次 IO 操作，看起来 B+ 树和 B 树的查询过程差不多，但是 B+ 树和 B 树有根根本的差异在于，<strong>B+ 树的中间节点并不直接存储数据</strong>。这样的好处都有什么？</p>
<p>首先，<strong>B+ 树查询效率更稳定</strong>。因为 B+ 树每次只有访问到叶子节点才能找到对应的数据，而在 B 树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。</p>
<p>其次，<strong>B+ 树的查询效率更高</strong>。这是因为通常 B+ 树比 B 树更矮胖 (阶数更大，深度更低)，查询所需要的磁盘 I&#x2F;O 也会更少。同样的磁盘页大小，B+ 树可以存储更多的节点关键字。</p>
<p>不仅是对单个关键字的查询上，<strong>在查询范围上，B+ 树的效率也比 B 树高</strong>。这里因为所有关键字都出现在 B+ 树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在 B 树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</p>
<blockquote>
<p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。</p>
<p>但 B 树和 B+ 树各有自己的应用场景，不能说 B+ 树完全比 B 树好，反之亦然。</p>
</blockquote>
<p><strong>思考题：为了减少 IO，索引树会一次性加载吗</strong>？</p>
<blockquote>
<p>1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个 G。</p>
<p>2、当我们利用索引查询的时候，是不可能将全部几个 G 的索引都加载进内存的，能做的只能是：逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</p>
</blockquote>
<p><strong>思考题：B+ 树的存储能力如何？为何说一般查找行记录，最多只需要 1～3 次磁盘 IO</strong>？</p>
<blockquote>
<p>InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT (占用 4 个字节) 或BIGINT (占用 8 个字节)，指针类型也一般为 4 或 8 个字节，也就是说一个页 (B+ 树中的一个节点) 中大概存储 16KB &#x2F; (8B + 8B) &#x3D; 1K 个键值 (因为是估值，为方便计算，这里的 K 取值为 10<sup>3</sup>。也就是说一个深度为 3 的 B+ 树索引可以维护 10<sup>3</sup> * 10<sup>3</sup> * 10<sup>3</sup> &#x3D; 10 亿条记录。这里假定一个数据页也存储 10<sup>3</sup> 条行记录数据了)。</p>
<p>实际情况中每个节点可能不能填充满，因此在数据库中，B+ 树的高度一般都在 2～4 层。MySQL 的 InnoDB 存储引擎在设计时是将根结点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1～3 次磁盘 I&#x2F;O 操作。</p>
</blockquote>
<p><strong>思考：为什么说 B+ 树比 B 树更适合实际应用中操作系统的文件索引和数据库索引</strong>？</p>
<blockquote>
<p>1、B+ 树的磁盘读写代价更低</p>
<p>B+ 树的内部节点并没有指向关键字具体信息的指针。因此其内部节点相对 B 树更小。如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了。</p>
<p>2、B+ 树的查询效率更加稳定</p>
<p>由于非终结点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</blockquote>
<p><strong>思考题：Hash 索引与 B+ 树索引的区别</strong></p>
<blockquote>
<p>1、Hash 索引不能进行范围查询，而 B+ 树可以。这是因为 Hash 索引指向的数据是无序的，而 B+ 树的叶子节点是个有序的链表。</p>
<p>2、Hash 索引不支持联合索引的最左侧原理 (即联合索引的部分索引无法使用)，而 B+ 树可以。对于联合索引来说，Hash 索引在计算 Hash 值的时候是将索引键合并后再一起计算 Hash 值，所以不会针对每个索引单独计算 Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</p>
<p>3、Hash 索引不支持 ORDER BY 排序，因为 Hash 索引指向的数据是无序的，因此无法起到排序优化的作用，而 B+ 树索引数据是有序的，可以起到对该字段 ORDER BY 排序优化的作用。同理，也无法用 Hash 索引进行模糊查询，而 B+ 树使用 LIKE 进行模糊查询的时候，LIKE 后面模糊查询 (比如 % 结尾) 的话就可以起到优化作用。</p>
<p>4、I浓浓DB 不支持 哈希索引。</p>
</blockquote>
<p><strong>思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗</strong>？</p>
<blockquote>
<p>如果使用的是 MySQL 的话，我们需要了解 MySQL 的存储引擎都支持哪些索引结构，如下表</p>
<table>
<thead>
<tr>
<th>Storage Engine</th>
<th>Permissible Index Types</th>
</tr>
</thead>
<tbody><tr>
<td>InnoDB</td>
<td>BTREE</td>
</tr>
<tr>
<td>MyISAM</td>
<td>BREEE</td>
</tr>
<tr>
<td>MEMORY&#x2F;HEAP</td>
<td>HASH，BTREE</td>
</tr>
<tr>
<td>NDB</td>
<td>HASH，BTREE</td>
</tr>
</tbody></table>
<p>能看到，针对 InnoDB 和 MyISAM 存储引擎，都会默认采用 B+ 树索引，无法使用 Hash 索引。InnoDB 提供的自适应 Hash 是不需要手动指定的。如果是 Memory&#x2F;Heap 和 NDB 引擎，是可以进行选择 Hash 索引的。</p>
</blockquote>
<h4 id="6-7-R-树"><a href="#6-7-R-树" class="headerlink" title="6.7 R 树"></a>6.7 R 树</h4><p>R- Tree 在 MySQL 很少使用，仅支持 geometry 数据类型，支持该类型的存储引擎只有 MyISAM、BDB、InnoDB、NDB、Archive 集中。举个 R 树在现实领域中能够解决的例子：查找 20 英里以内所有的餐厅。如果没有 R 树你会怎么解决？一般情况下我们会把餐厅的坐标 (x, y) 分为两个字段存放在数据库中，一个字段记录精度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满足要求。如果一个地区有 100 家餐厅的话，我们就需要进行 100 次位置计算了，如果应用到谷歌、百度地图这种超级大数据库中，这种方法便必定不可行了。R 树就很好的解决了这种高维空间搜索问题。它把 B 树的思想很好的扩展到了多维空间，采用了 B 树分割空间的思想，并在添加、删除操作时采用合并、分解节点的方法，保证树的平衡性。因此，R 树就是一棵用来存储高维数据的平衡树。相对于 B-Tree，R-Tree 的优势在于范围查找。</p>
<table>
<thead>
<tr>
<th>索引 &#x2F; 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>R-Tree 索引</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h4 id="6-8-小结"><a href="#6-8-小结" class="headerlink" title="6.8 小结"></a>6.8 小结</h4><p>使用索引可以帮助我们从海量的数据中快速定位想要查找的数据，不过索引也存在一些不足，比如占用存储空间、降低数据库写操作的性能等，如果有多个索引还会增加索引选择的时间。当我们使用索引时，需要平衡索引的利 (提升查询效率) 和弊(维护索引所需的代价)。</p>
<p>在实际工作中，我们还需要基于需求和数据本身的分布情况来确定是否使用索引，尽管索引不是万能的，但数据量大的时候不使用索引是不可想象的，毕竟索引的本质，是帮助我们提升数据检索的效率。</p>
<h2 id="五、InnoDB-数据存储结构"><a href="#五、InnoDB-数据存储结构" class="headerlink" title="五、InnoDB 数据存储结构"></a>五、InnoDB 数据存储结构</h2><h3 id="1-数据库的存储结构：页"><a href="#1-数据库的存储结构：页" class="headerlink" title="1. 数据库的存储结构：页"></a>1. 数据库的存储结构：页</h3><p>索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都是保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL 服务器上的存储引擎负责对表中数据的读取和写入工作。不同存储引擎中存放的格式一般是不同的，甚至有的存储引擎比如 Memory 都不用磁盘来存储数据。</p>
<p>由于 InnoDB 是 MySQL 的默认存储引擎，所以本章剖析 InnoDB 存储引擎的数据存储结构。</p>
<h4 id="1-1-磁盘与内存交互基本单位：页"><a href="#1-1-磁盘与内存交互基本单位：页" class="headerlink" title="1.1 磁盘与内存交互基本单位：页"></a>1.1 磁盘与内存交互基本单位：页</h4><p>InnoDB 将数据划分为若干个页，InnoDB 中页的大小默认为 16KB。</p>
<p>以页作为磁盘和内存之间交互的基本单位，也就是一次最少丛磁盘中读取 16KB 的内容到内存中，一次最少把内存中的 16KB 内容刷新到磁盘中。也就是说，<strong>在数据库中，不论读一行，还是读多行，都是将这些所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页 (Page)，数据库 I&#x2F;O 操作的最小单位是页</strong>。一个页中可以存储多个行记录。</p>
<blockquote>
<p>记录是按照行来存储的，但是数据库的读取并不是以行为单位，否则一次读取 (也就是一次 I&#x2F;O 操作) 只能处理一行数据，效率会非常低。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E9%A1%B5.png" alt="数据页"></p>
<h4 id="1-2-页结构概述"><a href="#1-2-页结构概述" class="headerlink" title="1.2 页结构概述"></a>1.2 页结构概述</h4><p>页 a、页 b、页 c … 页 n 这些页可以不再物理结构上相连，只要通过双向链表相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页都会为存储在它里边的记录生成一个页目录，再通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，啊啊然后再便利该槽对应分组中的记录即可快速找到指定的记录。</p>
<h4 id="1-3-页的大小"><a href="#1-3-页的大小" class="headerlink" title="1.3 页的大小"></a>1.3 页的大小</h4><p>不同的数据库管理系统的页大小不同。比如在 MySQL 的 InnoDB 存储引擎中，默认页的大小是 16KB，我们可以通过下面的命令来进行查看：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_page_size%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>SQL Server 中页的大小为 8KB，而在 Oracle 中我们用术语“块” (Block) 来代表“页”，Oracle 支持的块的大小为 2KB、4KB、8KB、16KB、32KB 和 64KB。</p>
<h4 id="1-4-页的上层结构"><a href="#1-4-页的上层结构" class="headerlink" title="1.4 页的上层结构"></a>1.4 页的上层结构</h4><p>另外在数据库中，还存在着区 (Extent)、段 (Segment) 和表空间 (Tablespace) 的概念。行、页、区、段、表空间的关系如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E8%A1%8C%E9%A1%B5%E5%8C%BA%E6%AE%B5%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="行页区段表空间的关系"></p>
<p>区 (Extent) 是比页大一级的存储结构，在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64 * 16KB &#x3D; 1MB。</p>
<p>段 (Segment) 由一个或多个区组成，区在文件系统中是一个连续分配的空间 (在 InnoDB 中是连续的 64 个页)，不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p>
<p>表空间 (Tablespace) 是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。</p>
<h3 id="2-页的内部结构"><a href="#2-页的内部结构" class="headerlink" title="2. 页的内部结构"></a>2. 页的内部结构</h3><p>页如果按类型划分的话，常见的有数据页 (保存 B+ 树节点)、系统页、Undo 页 和 事物数据页等。数据页是我们最常使用的页。</p>
<p>数据页的 16KB 大小的存储空间被划分为七个部分，分别是文件头 (File Header)、页头 (Page Header)、最大最小记录 (Infimum + supremum)、用户记录 (User Records)、空闲空间 (Free Space)、页目录 (Page Directory) 和文件尾 (File Tailer)。</p>
<p>页结构的示意图如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E9%A1%B5%E7%BB%93%E6%9E%84%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="页结构的示意图"></p>
<p>这 7 个部分作用分别如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>File Header</td>
<td>38 字节</td>
<td>文件头，描述页的信息</td>
</tr>
<tr>
<td>Page Header</td>
<td>56 字节</td>
<td>页头，页的状态信息</td>
</tr>
<tr>
<td>Infimum + Supremum</td>
<td>26 字节</td>
<td>最大和最小记录，这时两个虚拟的行记录</td>
</tr>
<tr>
<td>User Records</td>
<td>不确定</td>
<td>用户记录，存储行记录内容</td>
</tr>
<tr>
<td>Free Space</td>
<td>不确定</td>
<td>空闲记录，页中还没有被使用的空间</td>
</tr>
<tr>
<td>Page Directory</td>
<td>不确定</td>
<td>页目录，存储用户记录的相对位置</td>
</tr>
<tr>
<td>File Trailer</td>
<td>8 字节</td>
<td>文件尾，校验页是否完整</td>
</tr>
</tbody></table>
<p>我们可以把这 7 个结构分成 3 个部分。</p>
<h4 id="2-1-File-Header-文件头部-和-File-Trailer-文件尾部"><a href="#2-1-File-Header-文件头部-和-File-Trailer-文件尾部" class="headerlink" title="2.1 File Header (文件头部) 和 File Trailer (文件尾部)"></a>2.1 File Header (文件头部) 和 File Trailer (文件尾部)</h4><p>首先是文件通用部分，也就是文件头和文件尾。</p>
<p><strong>文件头部信息</strong></p>
<p>不同类型的页都会以 File Header 作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁等，所有的数据页会组成一个双链表。这个部分占用固定的 38 个字节，是由下边这些内容组成的：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FIL_PAGE_SPACE_OR_CHKSUM</td>
<td>4 字节</td>
<td>页的校验和 (checksum 值)</td>
</tr>
<tr>
<td>FIL_PAGE_OFFSET</td>
<td>4 字节</td>
<td>页号</td>
</tr>
<tr>
<td>FIL_PAGE_PREV</td>
<td>4 字节</td>
<td>上一个页的页号</td>
</tr>
<tr>
<td>FIL_PAGE_NEXT</td>
<td>4 字节</td>
<td>下一个页的页号</td>
</tr>
<tr>
<td>FIL_PAGE_LSN</td>
<td>8 字节</td>
<td>页面被最后修改时对应的日志序列位置 (英文名是：Log Sequence Number)</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE</td>
<td>2 字节</td>
<td>该页的类型</td>
</tr>
<tr>
<td>FIL_PAGE_FILE_FLUSH_LSN</td>
<td>8 字节</td>
<td>尽在系统表空间的一个页中定义，代表文件至少被刷新到了对应的 LSN 值</td>
</tr>
<tr>
<td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td>4 字节</td>
<td>页属于哪个表空间</td>
</tr>
</tbody></table>
<p>其中：</p>
<ul>
<li><p>FIL_PAGE_OFFSET</p>
<p>  每一个页都有一个单独的页号，InnoDB通过页号可以唯一定位一个页。</p>
</li>
<li><p>FIL_PAGE_TYPE</p>
<p>  这个代表当前页的类型。InnoDB 为了不同的目的而把页分为不同的类型，上面介绍的都是存储记录的数据页，还有很多其它的类型的页：</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>十六进制</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FIL_PAGE_TYPE_ALLOCATED</td>
<td>0x0000</td>
<td>最新分配，还没使用</td>
</tr>
<tr>
<td>FIL_PAGE_UNDO_LOG</td>
<td>0x0002</td>
<td>Undo 日志页</td>
</tr>
<tr>
<td>FIL_PAGE_INODE</td>
<td>0x0003</td>
<td>段信息节点</td>
</tr>
<tr>
<td>FIL_PAGE_IBUF_FREE_LIST</td>
<td>0x0004</td>
<td>Insert Buffer 空闲列表</td>
</tr>
<tr>
<td>FIL_PAGE_IBUF_BITMAP</td>
<td>0x0005</td>
<td>Insert Buffer 位图</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_SYS</td>
<td>0x0006</td>
<td>系统页</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_TRX_SYS</td>
<td>0x0007</td>
<td>事务系统数据</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_FSP_HDR</td>
<td>0x0008</td>
<td>表空间头部信息</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_XDES</td>
<td>0x0009</td>
<td>扩展描述页</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_BLOB</td>
<td>0x000A</td>
<td>溢出页</td>
</tr>
<tr>
<td>FIL_PAGE_INDEX</td>
<td>0x45BF</td>
<td>索引页，也就是数据页</td>
</tr>
</tbody></table>
<p>  我们存放记录的数据页的类型其实是 FIL_PAGE_INDEX，也就是所谓的索引页。</p>
</li>
</ul>
<p><strong>数据页的链接实现</strong></p>
<p>在文件头部内容中有两个属性：FIL_PAGE_PREV 和 FIL_PAGE_NEXT</p>
<p>InnoDB 都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV 和 FIL_PAGE_NEXT 就跟别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间不需要是物理上的连续，而是逻辑上的连续。</p>
<p>数据页之间组成的双向链表：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%BB%84%E6%88%90%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="数据页之间组成的双向链表"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%BB%84%E6%88%90%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A82.png" alt="数据页之间组成的双向链表"> </p>
<p><strong>检验页的完整性</strong></p>
<p>文件头部和文件尾部都有属性：FIL_PAGE_SPACE_OR_CHKSUM</p>
<p>代表当前页面的检验和 (checksum)。</p>
<blockquote>
<p>什么是校验和？</p>
<p>就是对于一个很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为检验和。</p>
<p>在比较两个很长的字节串之前，先比较这两个长字节串的校验和，如果校验和都不一样，则两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。</p>
</blockquote>
<p>InnoDB 存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候断电了，造成了该页传输的不完整性。</p>
<p>为了检测一个页是否完整 (也就是在同步的时候有没有发生只同步一半的尴尬情况)，这时可以通过文件尾的检验和 (checksum 值) 与文件头的检验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。</p>
<p><strong>文件尾部</strong></p>
<p>文件尾部总共占用 8 个字节</p>
<ul>
<li>前 4 个字节代表页的校验和：这个部分适合 File Header 中的校验和相对应的。</li>
<li>后 4 个字节代表页面被最后修改时对应的日志序列位置 (LSN)。</li>
</ul>
<p>这个部分也是为了校验页的完整性的，如果首部和尾部的 LSN 值校验不成功的话，就说明同步过程出现了问题。</p>
<h4 id="2-2-User-Records-用户记录-、最大最小记录、Free-Space-空闲空间"><a href="#2-2-User-Records-用户记录-、最大最小记录、Free-Space-空闲空间" class="headerlink" title="2.2 User Records (用户记录)、最大最小记录、Free Space (空闲空间)"></a>2.2 User Records (用户记录)、最大最小记录、Free Space (空闲空间)</h4><p>第二部分是记录部分，页的主要作用是存储记录，所以”最大和最小记录“和“用户记录”部分占了页结构的主要空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E9%A1%B5%E7%BB%93%E6%9E%84%E7%A9%BA%E9%97%B4%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="页结构空间示意图"></p>
<p><strong>空闲空间 (Free Space)</strong></p>
<p>我们自己存储的记录会按照指定的行格式存储到 User Records 部分。但是在一开始生成页的时候，其实并没有 User Records 这个部分，每当我们插入一条记录，都会从 Free Space 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到 User Records 部分，当 Free Space 部分的空间全部被 User Records 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。</p>
<p><strong>用户记录 (User Records)</strong></p>
<p>User Records 中的这些记录按照指定的行格式一条一条摆在 User Records 部分，相互之间形成单链表。用户记录里的</p>
<p><strong>最小最大记录 (Infimum + Supremum)</strong></p>
<p>记录可以比较大小吗？</p>
<p>记录可以比大小，对于一条完整的记录来说，比较就的大小就是比较主键的大小。比方说我们插入的 4 行记录的主键值分别是：1、2、3、4，这就意味着这 4 条记录是从小到大依次递增。</p>
<p>InnoDB 规定的最小记录与最大记录这两条记录的构造十分简单，都是由 5 个字节大小的记录头信息和 8 字节大小的一个固定的部分组成的，如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E8%AE%B0%E5%BD%95.png" alt="最小最大记录"></p>
<p>这两条记录不是我们自己定义的记录，所以她们并不存放在页的 User Records 部分，她们被单独放在一个称为 Infimum + Supremum 的部分，如图：</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E8%AE%B0%E5%BD%952.png" alt="最小最大记录"></p>
<h4 id="2-3-Page-Directory-页目录-、Page-Header-页面头部"><a href="#2-3-Page-Directory-页目录-、Page-Header-页面头部" class="headerlink" title="2.3 Page Directory (页目录)、Page Header (页面头部)"></a>2.3 Page Directory (页目录)、Page Header (页面头部)</h4><p><strong>页目录</strong></p>
<p>在页中，记录是以单向链表的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了目录页这个模块，专门给记录做一个目录，通过二分查找法的方式进行检索提升效率。</p>
<p><strong>页目录是如何构成的</strong></p>
<p>需求：根据主键值查找页中的某条记录，如何实现快速查找呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> page_demo <span class="operator">=</span> <span class="keyword">WHERE</span> c1 <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>最笨的办法：顺序查找</p>
<p>从 Infimum 记录 (最小记录) 开始，沿着链表一直往后找，总有一天会找到或者找不到，在找的时候还能投机取巧，因为链表中哥哥记录的值是按照从小到大的顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值是，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。</p>
<p>如果一个页中存储了非常多的记录，这么查找性能很差。</p>
<p>好办法：使用目录，二分查找法</p>
<ul>
<li>将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。</li>
<li>第一组，也就是最小记录所在的分组只有一个记录；最后一组，就是最大记录所在的分组，会有 1～8 条记录；其余的组记录数量在 4～8 条之间。这样做的好处是，除了第一组以外，其余组的记录树会尽量平分。</li>
<li>在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。</li>
<li>页目录用来存储魅族最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，魅族的地址偏移量也被称之为槽 (slot)，每个槽相当于指针指向了不同组的最后一个记录。</li>
</ul>
<p>页目录分组的个数如何确定？</p>
<p>为什么最小记录的 n_owned 值为 1，而最大记录的 n_owned 值为 5 呢？</p>
<p>InnoDB 规定：对于最小记录所在的分组只能有一条记录，最大记录所在的分组拥有的记录条数只能在 1～8 之间，剩下的分组中记录的条数范围只能在 4～8 之间。</p>
<p>分组是按照下面的步骤进行的：</p>
<ul>
<li>初始情况下一个数据页里只有最小记录和最大记录两条记录，她们分属于两个分组。</li>
<li>之后没插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的 n_owned 值加 1，表示本组内又添加了一条记录，知道该组中的记录数等于 8 个。</li>
<li>在一个组中的记录数等于 8 个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中 4 条记录，另一个 5 条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li>
</ul>
<p><strong>页面头部</strong></p>
<p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫 Page Header 的部分，这个部分占用固定的 56 个字节，专门存储各种状态信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td>2 字节</td>
<td>在页目录中的槽数量</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td>2 字节</td>
<td>还未使用的空间最小地址，也就是说从该地址之后就是 Free Space</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td>2 字节</td>
<td>本页中的记录的数量 (包括最小和最大记录以及标记为删除的记录)</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td>2 字节</td>
<td>第一个已经标记为删除的记录地址 (各个已删除的记录通过 next_record 也会组成一个单链表，这个单链表中的记录可以被重新利用)</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td>2 字节</td>
<td>已删除记录占用的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td>2 字节</td>
<td>最后插入记录的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td>2 字节</td>
<td>记录插入的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td>2 字节</td>
<td>一个方向连续插入的记录数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td>2 字节</td>
<td>该页中记录的数量 (不包括最小和最大记录以及被标记为删除的记录)</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td>8 字节</td>
<td>修改当前页的最大事务 ID，该值尽在二级索引中定义</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td>2 字节</td>
<td>当前页在 B+ 树中所处的层级</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td>8 字节</td>
<td>索引 ID，表示当前页属于哪个索引</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td>10 字节</td>
<td>B+ 树叶子段的头部信息，仅在 B+ 树的 Root 页定义</td>
</tr>
</tbody></table>
<h4 id="2-4-从数据页的角度看-B-树如何查询"><a href="#2-4-从数据页的角度看-B-树如何查询" class="headerlink" title="2.4 从数据页的角度看 B+ 树如何查询"></a>2.4 从数据页的角度看 B+ 树如何查询</h4><p>一棵 B+ 树按照节点类型可以分成两部分：</p>
<ul>
<li>叶子节点，B+ 树最底层的节点，节点的高度为 0，存储行记录。</li>
<li>非叶子节点，节点的高度大于 0，存储索引键和页面指针，并不存储记录本身。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/B+%E6%A0%91%E6%9F%A5%E8%AF%A2.png" alt="B+树查询"></p>
<p>当我们从页结构来理解 B+ 树的时候，可以帮我们理解一些通过索引进行检索的原理：</p>
<p><strong>B+ 树是如何进行记录检索的</strong>？</p>
<p>如果通过 B+ 树的索引查询行记录，首先是从 B+ 树的根开始，逐层检索，知道找到叶子节点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽 (slot) 采用二分查找的方式先找到一个粗略的记录分组，然后再在分组中通过链表遍历的方式查找记录。</p>
<p><strong>普通索引和唯一索引在存储效率上有什么不同</strong>？</p>
<p>我们创建索引的时候可以是普通索引，也可以是唯一索引，那么这两个索引在查询效率上有什么不同呢？</p>
<p>唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索。而普通索引，可能会存储在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是单独将这条记录从磁盘中读出去，而是将这个记录所在的页加载到内存中进行读取。InnoDB 存储引擎的页大小为 16KB，在一个页中可能存储着上千个记录，因此在普通索引的字段上进行查找也就是在内存中多几次判断下一条记录的操作，对于 CPU 来说，这些操作所消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本没有差别。</p>
<h3 id="3-InnoDB-行格式-或记录格式"><a href="#3-InnoDB-行格式-或记录格式" class="headerlink" title="3. InnoDB 行格式 (或记录格式)"></a>3. InnoDB 行格式 (或记录格式)</h3><p>平时的数据以行为单位来向表中插入数据，这些记录在磁盘上的存放方式也被称为行格式或记录格式。InnoDB 存储引擎设计了 4 种不同类型的行格式，分别是 Compact、Redundant、Dynamic 和 Compressed 行格式。</p>
<p>查看 MySQL8 的默认行格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@innodb</span>_default_row_format;</span><br></pre></td></tr></table></figure>

<p>也可以使用如下语法查看具体表使用的行格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">like</span> 表名\G</span><br></pre></td></tr></table></figure>

<h4 id="3-1-指定行格式的语法"><a href="#3-1-指定行格式的语法" class="headerlink" title="3.1 指定行格式的语法"></a>3.1 指定行格式的语法</h4><p>在创建或修改表的语句中指定行格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (列信息) ROW_FORMAT<span class="operator">=</span>行格式名称;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ROW_FORMAT<span class="operator">=</span>行格式名称;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> record_test_table(</span><br><span class="line">	col1 <span class="type">VARCHAR</span>(<span class="number">8</span>),</span><br><span class="line">  col2 <span class="type">VARCHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  col3 <span class="type">char</span>(<span class="number">8</span>),</span><br><span class="line">  col4 <span class="type">VARCHAR</span>(<span class="number">8</span>)</span><br><span class="line">) CHARSET<span class="operator">=</span>ascii ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> record_test_table(col1, col2, col3, col4)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="string">&#x27;wangwu&#x27;</span>,<span class="string">&#x27;laji&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;xiaoming&#x27;</span>,<span class="string">&#x27;xiaohong&#x27;</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-COMPACT-行格式"><a href="#3-2-COMPACT-行格式" class="headerlink" title="3.2 COMPACT 行格式"></a>3.2 COMPACT 行格式</h4><p>在 MySQL 5.1 版本中，默认设置为 Compact 行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/compact%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="compact行格式示意图"></p>
<p><strong>变长字段长度列表</strong></p>
<p>MySQL 支持一些变长的数据类型，比如 VARCHAR(M)、VARBINARY(M)、TEXT 类型，BLOB 类型，这些数据类型修饰列称为变长字段，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。在 Compact 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。</p>
<blockquote>
<p>注意：这里面存储的变长长度和字段顺序是反过来的。比如两个 varchar 字段在表结构的顺序是 a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是 15，10，是反过来的。</p>
</blockquote>
<p>以 record_test_table 表中的第一条记录举例：因为 record_test_table 表的 col1、col2、col4 都是 VARCHAR(8) 类型的，所以这三个列的值的长度都需要保存在记录开头处，注意 record_test_table 表中的各个列都使用的是 ascii 字符集 (每个字符只需要 1 字节来进行编码)。</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>存储内容</th>
<th>内容长度 (十进制表示)</th>
<th>内容长度 (十六进制表示)</th>
</tr>
</thead>
<tbody><tr>
<td>col1</td>
<td>‘zhangsan’</td>
<td>8</td>
<td>0x88</td>
</tr>
<tr>
<td>col2</td>
<td>‘lisi’</td>
<td>4</td>
<td>0x04</td>
</tr>
<tr>
<td>col4</td>
<td>‘laji’</td>
<td>6</td>
<td>0x06</td>
</tr>
</tbody></table>
<p>又因为这些长度值需要按照列的逆序存放，所以最后变长字段长度列表的字节串用十六进制表示的效果就是 (各个字节之间实际上没有空格，用空格隔开只是方便理解)：06 04 08</p>
<p>把这个字节串组成的变长字段长度列表填入上边的示意图中的效果就是：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/compact%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-1.png" alt="compact行格式示意图"></p>
<p><strong>NULL 值列表</strong></p>
<p>Compact 行格式会把可以为 NULL 的列统一管理起来，存在一个标记为 NULL 值列表中。如果表中没有允许存储 NULL 的列，则 NULL 值列表也不存在了。</p>
<p>为什么定义 NULL 值列表？</p>
<p>之所以要存储 NULL 是因为数据都是需要对齐的，如果没有标注出来 NULL 值的位置，就有可能在查询数据的时候出现混乱。如果使用一个特定的符号放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据的头部开辟出一块空间专门用来记录改行数据哪些是非空数据，哪些是空数据，格式如下：</p>
<ul>
<li>二进制位的值为 1 时，代表该列的值为 NULL。</li>
<li>二进制位的值为 0 时，代表该列的值不为 NULL。</li>
</ul>
<p>例如：字段 a、b、c，其中 a 是主键，在某一行中存储的数依次是 a &#x3D; 1、b &#x3D; null、c &#x3D; 2。那么 Compact 行格式中的 NULL 值列表中存储：01。第一个 0 表示 c 不为 null，第二个 1 表示 b 是 null。这里之所以没有 a 是因为数据库会自动跳过主键，因为主键肯定是非 NULL 且唯一的，在 NULL 值列表的数据中就会自动跳过主键。</p>
<p>record_test_table 的两条记录的 NULL 值列表就如下：</p>
<p>第一条记录：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%AC%AC%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95.png" alt="第一条记录"></p>
<p>第二条记录：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%AC%AC%E4%BA%8C%E6%9D%A1%E8%AE%B0%E5%BD%95.png" alt="第二条记录"></p>
<p><strong>记录头信息</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> page_demp(</span><br><span class="line">	c1 <span class="type">INT</span>,</span><br><span class="line">  c2 <span class="type">INT</span>,</span><br><span class="line">  c3 <span class="type">VARCHAR</span>(<span class="number">10000</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> kEY(c1)</span><br><span class="line">)CHARSET<span class="operator">=</span>ascii ROW_FORMAT<span class="operator">=</span>Compact;</span><br></pre></td></tr></table></figure>

<p>这个表中的记录的行格式示意图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="行格式示意图"></p>
<p>这些记录头信息中各个属性如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小 (单位：bit)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>预留位 1</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>预留位 2</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>B+ 树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表示当前记录的类型，0 表示普通记录，1 表示 B+ 树非叶子节点记录，2 表示最小记录，3 表示最大记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>表示下一条记录的相对位置</td>
</tr>
</tbody></table>
<p>简化后的行格式示意图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E5%90%8E%E7%9A%84%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="简化后的行格式示意图"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demp</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">100</span>, <span class="string">&#x27;song&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;tong&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="number">300</span>, <span class="string">&#x27;zhan&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="number">400</span>, <span class="string">&#x27;lisi&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/page_demo%E6%95%B0%E6%8D%AE.png" alt="page_demo数据"></p>
<ul>
<li><p>delete_mask</p>
<p>  这个属性标记着当前记录是否被删除，占用 1 个二进制位。</p>
<ul>
<li>值为 0：代表记录并没有被删除</li>
<li>值为 1:代表记录被删除</li>
</ul>
<p>  被删除的记录为什么还在页中存储呢？</p>
<p>  你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其它的记录在磁盘上需要重新排列，导致性能消耗。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为可重用空间，之后如果有新纪录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</p>
</li>
<li><p>min_rec_mask</p>
<p>  B+ 树的每层非叶子节点中最小记录都会添加该标记，min_rec_mask 值为 1。我们自己插入的四条记录 min_rec_mask 值都是 0，意味着他们都不是 B+ 树的非叶子节点中的最小记录。</p>
</li>
<li><p>record_type</p>
<p>  这个属性表示当前记录的类型，一共有 4 种类型的记录：</p>
<p>  0：表示普通记录</p>
<p>  1：表示 B+ 树非叶子节点记录</p>
<p>  2：表示最小记录</p>
<p>  3：表示最大记录</p>
<p>  从图中我们可以看出来，我们自己插入的记录就是普通记录，它们的 record_type 值都是 0，而最小记录和最大记录的 record_type 值分别为 2 和 3。</p>
</li>
<li><p>heap_no</p>
<p>  这个属性表示当前记录在本页中的位置。</p>
<p>  从图中可以看出来，我们插入的 4 条记录在本页中的位置分别是：2、3、4、5。</p>
<p>  怎么不见 heap_no 值为 0 和 1 的记录呢？</p>
<p>  MySQL 会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录。最小记录和最大记录的 heap_no 值分别是 0 和 1，也就是说它们的位置最靠前。</p>
</li>
<li><p>n_owned</p>
<p>  页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。</p>
</li>
<li><p>next_record</p>
<p>  记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。</p>
<p>  比如：第一条记录的 next_record 值为 32，意味着从第一条记录的真实数据的地址处向后找 32 个字节便是下一条记录的真实数据。</p>
<p>  注意，下一条记录指的并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 Infimum 记录 (也就是最小记录) 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum 记录 (也就是最大记录)。下图用箭头代替偏移量表示 next_record。</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/next_record%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="next_record示意图"></p>
<ul>
<li><p>删除操作</p>
<p>  从表中删除掉一条记录，这个链表也是会跟着变化：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> page_demo <span class="keyword">WHERE</span> c1 <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>  删掉第二条记录后的示意图就是：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="删除操作示意图"></p>
<p>  从图中可以看出来，删除第二条记录前后主要发生了这些变化：</p>
<ul>
<li>第二条记录并没有从存储空间中移除，而是把该记录的 delete_mask 值设置为 1。</li>
<li>第二条记录的 next_record 值变为了 0，意味着该记录没有下一条记录了。</li>
<li>第一条记录的 next_record 指向了第三条记录。</li>
<li>最大记录的 n_owned 值从 5 变成了 4。</li>
</ul>
<p>  所以，不论我们怎么对页中的记录做增删改操作，InnoDB 始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。</p>
</li>
<li><p>添加操作</p>
<p>  主键值为 2 的记录被我们删掉了，但是存储空间却没有回收，如果再次把这条记录插入到表中，会发生什么事呢？</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;tong&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>  看一下记录的存储情况：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="添加操作示意图"></p>
<p>  直接服用了原来被删除记录的存储空间。</p>
<p>  说明：</p>
<p>  当数据页中存在多条被删掉的记录时，这些记录的 next_record 属性将会把这些被删除的记录组成一个垃圾链表，以备之后重用这部分存储空间。</p>
</li>
</ul>
</li>
</ul>
<p><strong>记录的真实数据</strong></p>
<p>记录的真实数据除了我们自己定义的列的数据以外，还会有三个隐藏列：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>是否必须</th>
<th>占用空间</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>row_id</td>
<td>否</td>
<td>6 字节</td>
<td>行 ID，唯一标识一条记录</td>
</tr>
<tr>
<td>transaction_id</td>
<td>是</td>
<td>6 字节</td>
<td>事务 ID</td>
</tr>
<tr>
<td>roll_pointer</td>
<td>是</td>
<td>7 字节</td>
<td>回滚指针</td>
</tr>
</tbody></table>
<p>实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR。</p>
<ul>
<li>一个表没有手动定义主键，则会选取一个 Unique 键作为主键，如果连 Unique 键都没有定义的话，则会为表默认添加一个名为 row_id 的隐藏列作为主键。所以 row_id 是在没有自定义主键以及 Unique 键的情况下才会存在的。</li>
<li>事务 ID 和回滚指针在后面描述</li>
</ul>
<h4 id="3-3-Dynamic-和-Compressed-行格式"><a href="#3-3-Dynamic-和-Compressed-行格式" class="headerlink" title="3.3 Dynamic 和 Compressed 行格式"></a>3.3 Dynamic 和 Compressed 行格式</h4><p><strong>行溢出</strong></p>
<p>InnoDB 存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。</p>
<p>很多 DBA 喜欢 MySQL 数据库提供的 VARCHAR(M) 类型，认为可以存放 65535 字节。这是真的吗？如果我们使用 ascii 字符集的话，一个字符就代表一个字节，我们看看 VARCHAR(65535) 是否可用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> varchar_size_demo(c <span class="type">VARCHAR</span>(<span class="number">65535</span>)) CHARSET <span class="operator">=</span> ascii ROW_FORMAT <span class="operator">=</span> Compact;</span><br><span class="line"># 结果如下：</span><br><span class="line">ERROR <span class="number">1118</span> (<span class="number">42000</span>): <span class="type">Row</span> size too large.</span><br></pre></td></tr></table></figure>

<p>报错的信息表达的意思是：MySQL 对一条记录占用的最大存储空间是有限制的，除 BLOB 或 TEXT 类型的列之外，其他所有的列 (不包含隐藏列和记录头信息) 占用的字节长度加起来不能超过 65535 个字节。</p>
<p>这个 65535 个字节除了列本身的数据之外，还包括一些其它的数据，以 Compact 行格式为例，比如我们为了存储一个 VARCHAR(M) 类型的列，除了真实数据占有空间以外，还需要记录的额外信息。</p>
<p>如果该 VARCHAR 类型的列没有 NOT NULL 属性，那最多只能存储 65532 个字节的数据， 因为变长字段的长度占用 2 个字节，NULL 值标识需要占用 1 个字节。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> varchar_size_demo(c <span class="type">VARCHAR</span>(<span class="number">65532</span>)) CHARSET <span class="operator">=</span> ascii ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure>

<p>如果有 NOT NULL 属性，那么就不需要 NULL 值标识，也就可以多存储一个字节，即 65533 个字节。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> varchar_size_demo(c <span class="type">VARCHAR</span>(<span class="number">65533</span>) <span class="keyword">not</span> <span class="keyword">null</span>) CHARSET <span class="operator">=</span> ascii ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure>

<p>通过上面的案例，我们可以知道一个页的大小一般是 16KB，也就是 16384 字节，而一个 VARCHAR(M) 类型的列就最多可以存储 65533 个字节，这样就可能出现一个页存放不了一条记录，这种现象称为行溢出。</p>
<p>在 Compact 和 Redundant 行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行分也存储，然后记录的真实数据处用 20 个字节存储指向这些页的地址 (当然这 20 个字节中国呢还包括这些分散在其他页面中的数据的占用的字节数)，从而可以找到剩余数据所在的页。这称为页的扩展，举例如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E9%A1%B5%E7%9A%84%E6%89%A9%E5%B1%95.png" alt="页的扩展"></p>
<p>在 MySQL 8.0 中，默认行格式就是 Dynamic，Dynamic、Compressed 行格式和 Compact 行格式挺像，只不过在处理行溢出数据时有分歧：</p>
<ul>
<li>Compressed 和 Dynamic 两种记录格式对于存放在 BLOB 中的数据采用了完全的行溢出的方式。如图，在数据页中只存放 20 个字节的指针 (溢出页的地址)，实际的数据都存放在 Off Page (溢出页) 中。</li>
<li>Compact 和 Redundant 两种格式会在记录的真实数据处存储一部分数据 (存放 768 个前缀字节)。</li>
</ul>
<p>Compressed 行记录格式的另一个功能就是，存储在其中的行数据会以 zlib 的算法进行压缩，因此对于 BLOB、TEXT、VARCHAR 这类大长度类型的数据能够进行非常有效的存储。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/Compressed%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F.png" alt="Compressed行记录格式"></p>
<h4 id="3-4-Redundant-行格式"><a href="#3-4-Redundant-行格式" class="headerlink" title="3.4 Redundant 行格式"></a>3.4 Redundant 行格式</h4><p>Redundant 是 MySQL 5.0 版本之前 InnoDB 的行记录存储方式，MySQL 5.0 支持 Redundant 是为了兼容之前版本的页格式。</p>
<p>现在我们把表 record_test_table 的行格式修改为 Redundant：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> recoord_test_table ROW_FORMAT <span class="operator">=</span> Redundant;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/Redundant%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Redundant行格式示意图"></p>
<p>从上图可以看到，不同于 Compact 行记录格式，Redundant 行格式的首部是一个字段长度偏移列表，同样是按照列的顺序逆序放置的。</p>
<h3 id="4-区、段与碎片区"><a href="#4-区、段与碎片区" class="headerlink" title="4. 区、段与碎片区"></a>4. 区、段与碎片区</h3><h4 id="4-1-为什么要有区？"><a href="#4-1-为什么要有区？" class="headerlink" title="4.1 为什么要有区？"></a>4.1 为什么要有区？</h4><p>B+ 树的每一层中的页都会形成一个双向链表，如果是以页为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。我们介绍 B+ 树索引的使用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的随机 I&#x2F;O。再一次强调，磁盘的速度和内存的速度差了好几个数量级，随机 I&#x2F;O 是非常慢的，所以我们应该尽量让链表中相邻的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的顺序 I&#x2F;O。</p>
<p>引入区的概念，一个区就是在物理位置上连续的 64 个页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB&#x3D;1MB。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费 (数据不足以填充满整个区)，但是从性能角度看，可以消除很多的随机 I&#x2F;O，功大于过。</p>
<h4 id="4-2-为什么要有段？"><a href="#4-2-为什么要有段？" class="headerlink" title="4.2 为什么要有段？"></a>4.2 为什么要有段？</h4><p>对于范围查询，其实是对 B+ 树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以 InnoDB 对 B+ 树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点由自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段 (segment)，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成两个段，一个叶子节点段，一个非叶子节点段。</p>
<p>除了索引的叶子节点段和非叶子节点段之外，InnoDB 中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段友数据段、索引段、回滚段。数据段即为 B+ 树的叶子节点，索引段即为 B+ 树的非叶子节点。</p>
<p>在 InnoDB 存储引擎中，对段的管理都是由引擎自身所完成的，DBA 不能也没有必要对其进行控制。这从一定程度上简化了 DBA 对于段的管理。</p>
<p>段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p>
<h4 id="4-3-为什么要有碎片区？"><a href="#4-3-为什么要有碎片区？" class="headerlink" title="4.3 为什么要有碎片区？"></a>4.3 为什么要有碎片区？</h4><p>默认情况下，一个使用 InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成两个段，而段是以区为单位申请存储空间的，一个区默认占用 1M (64 * 16KB&#x3D; 1024KB) 存储空间，所以默认情况下一个只存了几条记录的小表也需要 2M 的存储空间么？以后每次添加一个索引都要多申请 2M 的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常纯粹的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。</p>
<p>为了考虑以完整的区为单位分配给某个段对于数据量小的表太浪费存储空间的情况，InnoDB 提出了一个碎片 (fragment) 区的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段 A，有些页用于段 B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。</p>
<p>所以此后为某个段分配存储空间的策略是这样的：</p>
<ul>
<li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li>
<li>当某个段已经占用了 32 个碎片区页面之后，就会申请以完整的区为单位来分配存储空间。</li>
</ul>
<p>所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。</p>
<h4 id="4-4-区的分类"><a href="#4-4-区的分类" class="headerlink" title="4.4 区的分类"></a>4.4 区的分类</h4><p>区大体上可以分为四种类型：</p>
<ul>
<li>空闲的区 (FREE)：现在还没有用到这个区中的任何页面。</li>
<li>有剩余空间的碎片区 (FREE_FRAG)：表示碎片区中还有可用的页面。</li>
<li>没有剩余空间的碎片区 (FULL_FRAG)：表示碎片区中的所有页面都被使用，没有空闲页面。</li>
<li>附属于某个段的区 (FSEG)：每一个索引都可以分为叶子节点段和非叶子节点段。</li>
</ul>
<p>处于 FREE、FREE_FRAG 以及 FULL_FRAG 这三种状态的区都是独立的，直属于表空间。而处于 FSEG 状态的区市附属于某个段的。</p>
<blockquote>
<p>如果把表空间比作是一个集团军，段就相当于师，区就相当于团。一般的团都是隶属于某个师的，就像是处于 FSEG 的区全都隶属于某个段，而处于 FREE、FREE_FRAG 和 FULL_FRAG 这三种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样。</p>
</blockquote>
<h3 id="5-表空间"><a href="#5-表空间" class="headerlink" title="5. 表空间"></a>5. 表空间</h3><p>表空间可以看做是 InnoDB 存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。</p>
<p>表空间是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。表空间数据库有一个或多个表空间组成，表空间从管理上可以划分为系统表空间 (System tablespace)、独立表空间 (File-per-table tablespace)、撤销表空间 (Undo Tablespace) 和临时表空间 (Temporary Tablespace) 等。</p>
<h4 id="5-1-独立表空间"><a href="#5-1-独立表空间" class="headerlink" title="5.1 独立表空间"></a>5.1 独立表空间</h4><p>独立表空间，即每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间 (即：单表) 可以在不同的数据库之间进行迁移。</p>
<p>空间可以回收 (DROP TABLE 操作可以自动回收表空间；其他情况，表空间不能自己回收)。如果对于统计分析或事日志表，删除大量数据后可以通过：<code>alter table TableName engine=innodb</code>；回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。</p>
<p><strong>独立表空间结构</strong></p>
<p>独立表空间由段、区、页组成。</p>
<p><strong>真实表空间对应的文件大小</strong></p>
<p>我们到数据目录里看，会发现一个新建的表对应的 <code>.ibd</code> 文件只占用了 96k，才 6 个页面大小 (MySQL 5.7中)，这是因为一开始表空间占用的空间很小，因为表里边都没有数据。不过别忘了这些 .ibd 文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。</p>
<p><strong>查看 InnoDB 的表空间类型：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_file_per_table&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>你能看到 innodb_file_per_table&#x3D;ON，这就意味着每张表都会单独保存为一个 .ibd 文件。</p>
<h4 id="5-2-系统表空间"><a href="#5-2-系统表空间" class="headerlink" title="5.2 系统表空间"></a>5.2 系统表空间</h4><p>系统表空间的结构和独立表空间基本类似，只不过由于整个 MySQL 进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。</p>
<p><strong>InnoDB 数据字典</strong></p>
<p>每当我们向一个表中插入一条记录的时候，MySQL 检验过程如下：</p>
<p>先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的 B+ 树中。所以说，MySQL 除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说：</p>
<ul>
<li>某个表属于哪个表空间，表里边有多少列</li>
<li>表对应的每一个列的类型是什么</li>
<li>该表有多少索引，每个索引对应哪几个字段，该索引对应的跟页面在哪个表空间的哪个页面</li>
<li>该表有哪些外键，外键对应哪个表的哪些列</li>
<li>某个表空间对应文件系统上文件路径是什么</li>
<li>……</li>
</ul>
<p>上述这些数据并不是我们使用 INSERT 语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为元数据。InnoDB存储引擎特意定义了一些列的内部系统表 (internal system table) 来记录这些元数据：</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SYS_TABLES</td>
<td>整个 InnoDB 存储引擎中所有的表的信息</td>
</tr>
<tr>
<td>SYS_COLUMNS</td>
<td>整个 InnoDB 存储引擎中所有的列的信息</td>
</tr>
<tr>
<td>SYS_INDEXES</td>
<td>整个 InnoDB 存储引擎中所有的索引的信息</td>
</tr>
<tr>
<td>SYS_FIELDS</td>
<td>整个 InnoDB 存储引擎中所有的索引对应的列的信息</td>
</tr>
<tr>
<td>SYS_FOREIGN</td>
<td>整个 InnoDB 存储引擎中所有的外键的信息</td>
</tr>
<tr>
<td>SYS_FOREIGN_COLS</td>
<td>整个 InnoDb 存储引擎中所有的外键对应的信息</td>
</tr>
<tr>
<td>SYS_TABLESPACES</td>
<td>整个 InnoDB 存储引擎中所有的表空间信息</td>
</tr>
<tr>
<td>SYS_DATAFILES</td>
<td>整个 InnoDB 存储引擎中所有的表空间对应文件系统的文件路径信息</td>
</tr>
<tr>
<td>SYS_VIPTUAL</td>
<td>整个 InnoDB 存储引擎中所有的虚拟生成列的信息</td>
</tr>
</tbody></table>
<p>这些系统表也被称为数据字典，它们都是以 B+ 树的形式保存在系统表空间的某些页面中，其中SYS_TABLES、SYS_COLUMNS、SYS_INDEXES、SYS_FIELDS 这四个表尤其重要，称之为基本系统表 (basic system tables)，我们先看看这四个表的结构：</p>
<p><strong>SYS_TABLES 表结构</strong></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>NAME</td>
<td>表的名称。主键</td>
</tr>
<tr>
<td>ID</td>
<td>InnoDB 存储引擎中每个表都有一个唯一的ID。(二级索引)</td>
</tr>
<tr>
<td>N_COLS</td>
<td>该表拥有列的个数</td>
</tr>
<tr>
<td>TYPE</td>
<td>表的类型，记录了一些文件格式、行格式、压缩等信息</td>
</tr>
<tr>
<td>MIX_ID</td>
<td>已过时，忽略</td>
</tr>
<tr>
<td>MIX_LEN</td>
<td>表的一些额外的属性</td>
</tr>
<tr>
<td>CLUSTER_ID</td>
<td>未使用，忽略</td>
</tr>
<tr>
<td>SPACE</td>
<td>该表所属表空间的ID</td>
</tr>
</tbody></table>
<p><strong>SYSCOLUMNS 表结构</strong></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>TABLE_ID</td>
<td>该列所属表对应的 ID。</td>
</tr>
<tr>
<td>POS</td>
<td>该列在表中是第几列</td>
</tr>
<tr>
<td>NAME</td>
<td>该列的名称</td>
</tr>
<tr>
<td>MTYPE</td>
<td>main data type，主数据类型，就是那堆 INT、CHAR、VARCHAR、FLOAT、DOUBLE 之类的东东</td>
</tr>
<tr>
<td>PRTYPE</td>
<td>precise type，精确数据类型，就是修饰主数据类型的那堆东东，比如是否允许 NULL 值，是否允许负数啥的</td>
</tr>
<tr>
<td>LEN</td>
<td>该列最多占用存储空间的字节数</td>
</tr>
<tr>
<td>PREC</td>
<td>该列的精度，不过这列貌似都没有使用，默认值都是 0</td>
</tr>
</tbody></table>
<p><strong>SYS_INDEXES 表结构</strong></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>TABLE_ID</td>
<td>该索引所属表对应的ID</td>
</tr>
<tr>
<td>ID</td>
<td>InnoDB 存储引擎中每个索引都有一个唯一的 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>该索引的名称</td>
</tr>
<tr>
<td>M_FIELDS</td>
<td>该索引包含列的个数</td>
</tr>
<tr>
<td>TYPE</td>
<td>该索引的类型，比如聚簇索引、唯一索引、更改缓冲区的索引、全文索引、普通的二级索引等等各种类型</td>
</tr>
<tr>
<td>SPACE</td>
<td>该索引根页面所在的表空间</td>
</tr>
<tr>
<td>PAGE_NO</td>
<td>该索引根页面所在的页面号</td>
</tr>
<tr>
<td>MERGE_THRESHOLD</td>
<td>如果页面中的记录被删除到某个比列，就把该页面和相邻页面合并，这个值就是这个比例</td>
</tr>
</tbody></table>
<p><strong>SYS_FIELDS 表结构</strong></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>INDEX_ID</td>
<td>该索引列所属的索引的ID</td>
</tr>
<tr>
<td>POS</td>
<td>该索引列在某个索引中是第几列</td>
</tr>
<tr>
<td>COL_NAME</td>
<td>该索引列的名称</td>
</tr>
</tbody></table>
<p>注意：用户是不能直接访问 InnoDB 的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。不过考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库 information_schema 中提供了一些以 innodb_sys 开头的表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use information_schema;</span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">like</span> <span class="string">&#x27;innodb_sys%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在 information_schema 数据库中的这些以 INNODB_SYS 开头的表并不是真正的内部系统表 (内部系统表就是我们上边以 SYS 开头的那些表)，而是在存储引擎启动时读取这些以 SYS 开头的系统表，然后填充到这些以 INNODB_SYS 开头的表中。以 INNODB_SYS 开头的表和以 SYS 开头的表中的字段并不完全一样，但供参考已经足矣。</p>
<h3 id="附录：数据页加载的三种方式"><a href="#附录：数据页加载的三种方式" class="headerlink" title="附录：数据页加载的三种方式"></a>附录：数据页加载的三种方式</h3><p>InnoDB 从磁盘中读取数据的最小单位是数据页。而你想得到的 id &#x3D; xxx 的数据，就是这个数据页众多行中的一行。对于 MySQL 存放的数据，逻辑概念上我们称之为表，在磁盘等物理层面而言是按数据页形式进行存放的，当其加载到 MySQL 中我们称之为缓存页。</p>
<p>如果缓冲池中没有该页数据，那么缓冲池有以下三种读取数据的方式，每种方式的读取效率都是不同的：</p>
<h4 id="内存读取"><a href="#内存读取" class="headerlink" title="内存读取"></a>内存读取</h4><p>如果该数据存在于内存中，基本上执行时间在 1ms 左右，效率还是很高的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E5%86%85%E5%AD%98%E8%AF%BB%E5%8F%96.png" alt="内存读取"></p>
<h4 id="随机读取"><a href="#随机读取" class="headerlink" title="随机读取"></a>随机读取</h4><p>如果数据没有在内存中，就需要在磁盘上对该页进行查找，整体时间预估在 10ms 左右，这 10ms 中有 6ms 是磁盘的实际繁忙时间 (包括了寻到和半圈旋转时间)，有 3ms 是对可能发生的排队时间的估计值，另外还有 1ms 的传输时间，将页从磁盘服务缓冲区传输到数据缓冲区中。这 10ms 看起来很快，但实际上对于数据库来说消耗的时间已经非常长了，因为这还只是一个页的读取时间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%8F%96.png" alt="随机读取"></p>
<h4 id="顺序读取"><a href="#顺序读取" class="headerlink" title="顺序读取"></a>顺序读取</h4><p>顺序读取其实是一种批量读取的方式，因为我们请求的数据在磁盘上往往都是相邻存储的，顺序读取可以帮我们批量读取页面，这样的话，一次性加载到缓冲池中就不需要再对其他页面单独进行磁盘 I&#x2F;O 操作了。如果一个磁盘的吞吐量是 40MB&#x2F;S，那么对于一个 16KB 大小的页来说，一次可以顺序读取 2560 (40MB&#x2F;16KB) 个页，相当于一个页的读取时间为 0.4ms。采用批量读取的方式，即使是从磁盘上进行读取，效率也比从内存中只单独读取一个页的效率要高。</p>
<h2 id="六、索引的创建与设计原则"><a href="#六、索引的创建与设计原则" class="headerlink" title="六、索引的创建与设计原则"></a>六、索引的创建与设计原则</h2><h3 id="1-索引的生命与使用"><a href="#1-索引的生命与使用" class="headerlink" title="1. 索引的生命与使用"></a>1. 索引的生命与使用</h3><h4 id="1-1-索引的分类"><a href="#1-1-索引的分类" class="headerlink" title="1.1 索引的分类"></a>1.1 索引的分类</h4><p>MySQL 的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p>
<ul>
<li>从功能逻辑上说，索引主要有四种，分别是普通索引、唯一索引、主键索引、全文索引。</li>
<li>按照物理实现方式，索引可以分为两种：聚簇索引和非聚簇索引。</li>
<li>按照作用字段个数进行划分，分成单列索引和联合索引。</li>
</ul>
<p><strong>普通索引</strong>：</p>
<p>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在任何数据类型中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表 student 的字段 name 上建立一个普通索引，查询记录时就可以根据该索引进行查询。</p>
<p><strong>唯一性索引</strong>：</p>
<p>使用 UNIQUE 可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里可以有多个唯一索引。</p>
<p>例如，在表 student 的字段 email 中创建唯一性索引，那么字段 email 的值就必须是唯一的。通过唯一性索引，可以更快速地确定某条记录。</p>
<p><strong>主键索引</strong></p>
<p>主键索引就是一种特殊的 唯一性索引，在唯一索引的基础上增加了不为空的约束，也就是 NOT NULL + UNIQUE，一张表里最多只有一个主键索引。这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</p>
<p><strong>单列索引</strong></p>
<p>在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。</p>
<p><strong>多列 (组合、联合) 索引</strong></p>
<p>多列索引是在表的多个字段组合上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段 id、name 和 gender 上建立一个多列索引 idx_id_name_gender，只有在查询条件中使用了字段 id 时该索引才会被使用。使用组合索引时遵循最左前缀集合。</p>
<p><strong>全文索引</strong></p>
<p>全文索引 (也称全文检索) 是目前搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</p>
<p>使用参数 FULL TEXT 可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引只能创建在 CHAR、VARCHAR 或 TEXT 类型及其系列类型的字段上，<strong>查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度</strong>。例如，表 student 的字段 information 是 TEXT 类型，该字段包含了很多文字信息。在字段 information 上建立全文索引后，可以提高查询字段 information 的速度。</p>
<p>全文索引典型的两种类型：自然语言的全文索引和布尔全文索引。</p>
<ul>
<li>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。<strong>在整个索引中出现次数越少的词语，匹配时的相关度就越高</strong>。相反，非常常见的单词将不会被搜索，如果一个词语的在超过 50% 的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。</li>
</ul>
<p>MySQL 数据库从 3.23.23 版本开始支持全文索引，但 MySQL 5.6.4 以前只有 MyISAM 支持，5.6.4 版本以后 InnoDB 才支持，但是官方版本不支持中文分词，需要第三方分词插件。在 5.7.6 版本，MySQL 内置了 ngram 全文解析器，用来支持亚洲语种的分词。测试或使用全文索引时，要先看一下自己的 MySQL 版本、存储引擎和数据类型是否支持全文索引。</p>
<p>随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被 solr、ElasticSearch 等专门的搜索引擎所替代。</p>
<p><strong>空间索引</strong></p>
<p>使用参数 SPATIAL 可以设置索引为空间索引。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL 中的空间数据类型包括 GEOMETRY、POINT、LINESTRING 和 POLYGON 等。目前只有 MyISAM 存储引擎支持空间检索，而且索引的字段不能为空值。对于初学者来说，这类索引很少会用到。</p>
<p><strong>小结</strong>：</p>
<ul>
<li>InnoDB：支持 B-Tree、Full-text 等索引，不支持 Hash 索引；</li>
<li>MyISAM：支持 B-Tree、Full-text 等索引，不支持 Hash 索引；</li>
<li>Memory：支持 B-Tree、Hash 等索引，不支持 Full-text 索引；</li>
<li>NDB：支持 Hash 索引，不支持 B-Tree、Full-text 等索引；</li>
<li>Archive：不支持 B-Tree、Hash、Full-text 等索引。</li>
</ul>
<h4 id="1-2-创建索引"><a href="#1-2-创建索引" class="headerlink" title="1.2 创建索引"></a>1.2 创建索引</h4><p>MySQL 支持多种 方法在单个或多个列上创建索引：在创建表的定义语句 CREATE TABLE 中指定索引列，使用 ALTER TABLE 语句在存在的表上创建索引，或者使用 CREATE INDEX 语句在已存在的表上添加索引。</p>
<p><strong>创建表的时候创建索引</strong></p>
<p>使用 CREATE TABLE 创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外键约束或者唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">	dept_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">	emp_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  emp_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">  dept_id <span class="type">INT</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> emp_dept_id_fk <span class="keyword">FOREIGN</span> KEY(dept_id) <span class="keyword">REFERENCES</span> dept(dept_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>但是，如果现实创建表时创建索引的话，基本语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name [col_name data_type]</span><br><span class="line">[<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY] [index_name] (col_name [length]) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>UNIQUE、FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引；</li>
<li>INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引；</li>
<li>index_name 指定索引的名称，为可选参数，如果不指定，那么 MySQL 默认 col_name 为索引名；</li>
<li>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</li>
<li>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</li>
<li>ASC 或 DESC 指定生序或者降序的索引值存储。</li>
</ul>
<p><strong>创建普通索引</strong></p>
<p>在 book 表中的 year_publication 字段上建立普通索引，SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book(</span><br><span class="line">	book_id <span class="type">INT</span>,</span><br><span class="line">  book_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  authors <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  info <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  comment <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  year_publication <span class="keyword">YEAR</span>,</span><br><span class="line">  INDEX(year_publication)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>通过命令查看索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>

<p>使用 EXPLAIN 语句查看索引是否正在使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> year_publication <span class="operator">=</span> <span class="string">&#x27;1997&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>EXPLAIN 语句输出结果：</p>
<ul>
<li>possible_keys 行给出了 MySQL 在搜索数据记录时可选用的各个索引</li>
<li>key 行是 MySQL 实际选用的索引。</li>
</ul>
<p>可以看到，possible_keys 和 key 的值都为 year_publication，查询时使用了索引。</p>
<p><strong>创建唯一索引</strong></p>
<p>创建唯一索引的目的也是减少查询索引列操作的执行时间，尤其是对比较庞大的数据表。它与前面的普通索引类似，不同的是，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX idx_id(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用 <code>SHOW CREATE TABLE</code> 查看表结构。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure>

<p>其中各个主要参数的含义为：</p>
<ul>
<li>Table 表示创建索引的表</li>
<li>Non_unique 表示索引非唯一，1 代表非唯一索引，0 代表唯一索引。</li>
<li>Key_name 表示索引的名字。</li>
<li>Seq_in_index 表示该字段在索引中的位置，单列索引该值为 1，组合索引为每个字段在索引定义中的顺序。</li>
<li>Column_name 表示定义索引的列字段。</li>
<li>Sub_part 表示索引的长度。</li>
<li>Null 表示该字段是否能为空值。</li>
<li>Index_type 表示索引类型</li>
</ul>
<p>由结果可以看到，id 字段上已经成功建立了一个名为 idx_id 的唯一索引。</p>
<p><strong>主键索引</strong></p>
<p>设定为主键后数据库会自动建立索引，innodb 为聚簇索引，语法：</p>
<ul>
<li><p>随表一起建索引：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">	id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED AUTO_INCREMENT,</span><br><span class="line">  student_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  student_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除主键索引</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主键索引：必须先删除掉 (drop) 原索引，再新建 (add) 索引</p>
</li>
</ul>
<p><strong>创建单列索引</strong></p>
<p>单列索引是在数据表中的某一个字段上创建的索引，一个表中可以创建多个单列索引，前面例子中创建的索引都为单列索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  INDEX aingle_idx_name(name(<span class="number">20</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用 <code>SHOW CREATE TABLE</code> 查看表结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure>

<p>由结果可以看到，id 字段上已经成功建立了一个名为 single_idx_name 的单列索引。索引长度为 20。</p>
<p><strong>创建组合索引</strong></p>
<p>组合索引是在多个字段上创建一个索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(</span><br><span class="line">	id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  INDEX mul_idx(id, name, age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用 SHOW INDEX 查看：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure>

<p>由结果可以看到，id、name 和 age 字段上已经成功建立了一个名为 mul_idx 的组合索引。</p>
<p>组合索引可起几个索引的作用，但是使用时并不是随便查询哪个字段都可以使用索引，而是遵从“最左前缀”。例如，索引可以搜索的字段组合为：(id, name, age)、(id, name) 或者 id。而 age 或者 (name, age) 组合不能使用索引查询。</p>
<p>在 test 表中，查询 id 和 name 字段，使用 EXPLAIN 语句查看索引的使用情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> name <span class="operator">=</span> <span class="string">&#x27;zhangsan&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到，查询 id 和 name 字段时，使用了名称为 mul_idx 的索引，如果查询 (name, age) 组合或者单独查询 name 和 age 字段，会发现结果中 possible_keys 和 key 值为 NULL，并没有使用在 test 表中创建的索引进行查询。</p>
<p><strong>创建全文索引</strong></p>
<p>FULLTEXT 全文索引可以用于全文搜索，并且只为 CHAR、VARCHAR 和 TEXT 列创建索引。索引总是对整个列进行，不支持局部 (前缀) 索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  age <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  FULLTEXT INDEX futxt_idx_info(info)</span><br><span class="line">)ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 MySQL 5.7 及之后版本中可以不指定最后的 ENGINE 了，因为在此版本中 InnoDB 支持全文索引。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure>

<p>由结果可以看到，info 字段上已经成功建立了一个名为 futxt_idx_info 的 FULLTEXT 索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles(</span><br><span class="line">	id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  title <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  body TEXT,</span><br><span class="line">  FULLTEXT index(title, body)</span><br><span class="line">)ENGINE <span class="operator">=</span> INNODB;</span><br></pre></td></tr></table></figure>

<p>创建了一个给 title 和 body 字段添加全文索引的表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> papers(</span><br><span class="line">	id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  title <span class="type">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  content text,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  FULLTEXT KEY title (title, content)</span><br><span class="line">)ENGINE<span class="operator">=</span>MyISAM <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>不同于 like 方式的查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> content <span class="keyword">LIKE</span> <span class="string">&#x27;%查询字符串%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>全文索引用 match + against 方式查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, content) AGAINST (<span class="string">&#x27;查询字符串&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>明显的提高查询效率。</p>
<blockquote>
<p>注意点</p>
<ul>
<li>使用全文索引前，搞清楚版本支持情况；</li>
<li>全文索引比 like + % 快 N 倍，但是可能存在精度问题；</li>
<li>如果需要全文索引的是大量数据，建议先添加数据，再创建索引。</li>
</ul>
</blockquote>
<p><strong>创建空间索引</strong></p>
<p>空间索引创建中，要求空间类型的字段必须为非空。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(</span><br><span class="line">	geo GEOMETRY <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  SPATIAL INDEX spa_idx_geo(geo)</span><br><span class="line">)ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用 SHOW CREATE TABLE 查看表结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure>

<p>可以看到，test 表的 geo 字段上创建了名为 spa_idx_geo 的空间索引。注意创建时指定空间类型字段值的非空约束，并且表的存储引擎为MyISAM。</p>
<p><strong>使用 ALTER TABLE 语句创建索引</strong></p>
<p>ALTER TABLE 语句创建索引的基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY]</span><br><span class="line">[index_name] (col_name[length], ...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<p>与创建表时创建索引的语法不同的是，在这里使用了 ALTER TABLE 和 ADD 关键字，ADD 表示向表中添加索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">ADD</span> INDEX idx_bkname(book_name(<span class="number">30</span>));</span><br></pre></td></tr></table></figure>

<p><strong>使用 CREATE INDEX 创建索引</strong></p>
<p>CREATE INDEX 语句可以在意境存在的表上添加索引，在 MySQL 中，CREATE INDEX 被映射到一个 ALTER TABLE 语句上，基本语法结构为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span>SPATIAL] INDEX index_name </span><br><span class="line"><span class="keyword">ON</span> table_name (col_name[length], ...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_cmt <span class="keyword">ON</span> book(COMMENT);</span><br></pre></td></tr></table></figure>

<h4 id="1-3-删除索引"><a href="#1-3-删除索引" class="headerlink" title="1.3 删除索引"></a>1.3 删除索引</h4><p>MySQL 中删除索引使用 ALTER TABLE 或者 DROP INDEX 语句，两者可实现相同的功能，DROP INDEX 语句在内部被映射到一个 ALTER TABLE 语句中。</p>
<p><strong>使用 ALTER TABLE 删除索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示</p>
<p>添加 AUTO_INCREMENT 约束字段的唯一索引不能被删除。</p>
</blockquote>
<p><strong>使用 DROP INDEX 语句删除索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示</p>
<p>删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。</p>
</blockquote>
<h3 id="2-MySQL-8-0-索引新特性"><a href="#2-MySQL-8-0-索引新特性" class="headerlink" title="2. MySQL 8.0 索引新特性"></a>2. MySQL 8.0 索引新特性</h3><h4 id="2-1-支持降序索引"><a href="#2-1-支持降序索引" class="headerlink" title="2.1 支持降序索引"></a>2.1 支持降序索引</h4><p>降序索引以降序存储键值。虽然在语法上，从 MySQL 4 版本开始就已经支持降序索引的语法了，但实际上 DESC 定义是被忽略的，直到MySQL 8.x 版本才开始真正支持降序索引 (仅限于 InnoDB 存储引擎)。</p>
<p>MySQL 在 8.0 版本之前创建的仍然是生序索引，使用时进行反向扫描，这大大降低了数据库的效率。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。</p>
<p>分别在 MySQL 5.7 版本和 MySQL 8.0 版本中创建数据表 ts1</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ts1(a <span class="type">int</span>, b <span class="type">int</span>, index idx_a_b(a, b <span class="keyword">desc</span>));</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> ts1;</span><br></pre></td></tr></table></figure>

<p>从结果中可以看出，MySQL 5.7 版本中，索引仍然是默认的生序。而 MySQL 8.0 版本中，索引可以降序。分别插入 800 条随机数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ts_insert()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">	WHILE i <span class="operator">&lt;</span> <span class="number">800</span></span><br><span class="line">	DO</span><br><span class="line">		<span class="keyword">insert</span> <span class="keyword">into</span> ts1 <span class="keyword">select</span> rand() <span class="operator">*</span> <span class="number">80000</span>, rand() <span class="operator">*</span> <span class="number">80000</span>;</span><br><span class="line">		<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">END</span> WHILE;</span><br><span class="line">		<span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line"><span class="keyword">CALL</span> ts_insert();</span><br></pre></td></tr></table></figure>

<p>在 MySQL 5.7 版本中查看数据表 ts1 的执行计划，结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ts1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a, b <span class="keyword">DESC</span> LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，执行计划中扫描数为 799，而且使用了 Using filesort。</p>
<blockquote>
<p>提示</p>
<p>Using filesort 是 MySQL 中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员可以通过优化索引尽量避免出现 Using filesort，从而提高数据库执行速度。</p>
</blockquote>
<p>在 MySQL 8.0 版本中查看数据表 ts1 的执行计划。从结果可以看出，执行计划中扫描数为 5，而且没有使用 Using filesort。</p>
<blockquote>
<p>注意</p>
<p>降序索引支队查询中特定的排序顺序有效，如果使用不当，反而查询效率更低。例如，上述查询排序条件改为order by a desc, b desc，MySQL 5.7 的执行计划要明显好于 MySQL 8.0。</p>
</blockquote>
<p>将排序条件修改为 order by a desc, b desc 后，下面来对比不同版本中执行计划的效果。</p>
<p>在 MySQL 5.7 版本中查看数据表 ts1 的执行计划，结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ts1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a DEDC, b <span class="keyword">DESC</span> LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>在 MySQL 8.0 版本中查看数据表 ts1 的执行计划。</p>
<p>从结果可以看出，修改后 MySQL 5.7 的执行计划要明显好于 MySQL 8.0。</p>
<h4 id="2-2-隐藏索引"><a href="#2-2-隐藏索引" class="headerlink" title="2.2 隐藏索引"></a>2.2 隐藏索引</h4><p>在 MySQL 5.7 版本之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，有智能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。</p>
<p>从 MySQL 8.x 开始支持隐藏索引 (invisible indexes)，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引 (即使使用 force index (强制使用索引)，优化器也不会使用该索引)，确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。这种通过现将索引设置为隐藏索引，再删除索引的方式就是软删除。</p>
<p>同时，如果你想验证某个索引删除之后的查询性能影响，就可以暂时先隐藏该索引。</p>
<blockquote>
<p>注意：</p>
<p>主键不能被设置为隐藏索引。当表中没有显示主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引。</p>
</blockquote>
<p>索引默认是可见的，在使用 CREATE TABLE，CREATE INDEX 或 ALTER TABLE 等语句时可以通过 VISIBLE 或者 INVISIBLE 关键词设置索引的可见性。</p>
<p><strong>创建表时直接创建</strong></p>
<p>在 MySQL 中创建隐藏索引通过 SQL 语句 INVISIBLE 来实现，其语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename(</span><br><span class="line">	propname1 type1[CONSTRAINT1],</span><br><span class="line">	propname2 type2[CONSTRAINT2],</span><br><span class="line">	......</span><br><span class="line">	propname typen,</span><br><span class="line">  INDEX [indexname](propname1 [(length)] INVISIBLE)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上述语句比普通索引多了一个关键字 INVISIBLE，用来标记索引为不可见索引。</p>
<p><strong>在已经存在的表上创建</strong></p>
<p>可以为已经存在的表设置隐藏索引，其语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX indexname</span><br><span class="line"><span class="keyword">ON</span> tablename(propname[(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>

<p><strong>通过 ALTER TABLE 语句创建</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename</span><br><span class="line"><span class="keyword">ADD</span> INDEX indexname (propname [(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>

<p><strong>切换索引可见状态</strong></p>
<p>已存在的索引可通过如下语句切换可见状态：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> INDEX index_name INVISIBLE; # 切换成隐藏索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> INDEX index_name VISIBLE; # 切换成非隐藏索引</span><br></pre></td></tr></table></figure>

<p>如果将 index_cname 索引切换成可见状态，通过 explain 查看执行计划，发现优化器选择了 index_cname 索引。</p>
<blockquote>
<p>注意</p>
<p>当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p>
</blockquote>
<p>通过设置隐藏索引的可见性可以查看索引对调优的帮助。</p>
<p><strong>使隐藏索引对查询优化器可见</strong></p>
<p>在 MySQL 8.x 版本中，为索引提供了一种新的方式，可以通过查询优化器的一个开关 (use_invisible_indexes) 来打开某个设置，使隐藏索引对查询优化器可见。如果 use_invisible_indexes 设置为 off (默认)，优化器会忽略隐藏索引。如果设置为 on，即使隐藏索引不可见，优化器在生成执行计划时仍然会考虑使用隐藏索引。</p>
<ul>
<li><p>在 MySQL 命令执行如下命令查看查询优化器的开关设置</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@optimizer</span>_switch \G</span><br></pre></td></tr></table></figure>

<p>  在输出的结果信息中找到如下属性配置。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_invisible_indexes<span class="operator">=</span>off</span><br></pre></td></tr></table></figure>

<p>  此属性配置值为 off，说明隐藏索引默认为对查询优化器不可见。</p>
</li>
<li><p>使隐藏索引对查询优化器可见，需要在 MySQL 命令执行如下命令：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION optimizer_switch<span class="operator">=</span>&quot;use_invisible_indexes=on&quot;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-索引的设计原则"><a href="#3-索引的设计原则" class="headerlink" title="3. 索引的设计原则"></a>3. 索引的设计原则</h3><p>为了使索引的使用效率更高，再创建索引时，必须考虑在那些字段上创建索引和创建什么类型的索引。<strong>索引设计不合理或缺少索引都会对数据库和应用程序的性能造成障碍</strong>。高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑相应准则。</p>
<h4 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE indextest;</span><br><span class="line">USE indextest;</span><br><span class="line">#创建学生表和课程表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_info(</span><br><span class="line">	id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  student_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  course_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  class_id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  create_time DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> course(</span><br><span class="line">	id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  course_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  course_name <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 函数<span class="number">1</span>:创建随机产生字符串函数</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>)</span><br><span class="line">	<span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>)	# 该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span></span><br><span class="line">	<span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line">		<span class="keyword">SET</span> return_str <span class="operator">=</span> CONCAT(return_str, <span class="built_in">SUBSTRING</span>(chars_str, <span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> RAND() <span class="operator">*</span> <span class="number">52</span>), <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">END</span> WHILE;</span><br><span class="line">	<span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建随机数函数</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num(from_num <span class="type">INT</span>, to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span> RAND() <span class="operator">*</span> (to_num <span class="operator">-</span> from_num <span class="operator">+</span> <span class="number">1</span>));</span><br><span class="line"><span class="keyword">RETURN</span> i;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p> 创建函数，假如报错：</p>
<p><code>This function has none of DETERMINISTIC......</code></p>
<p>由于开启过慢查询日志 bin-log，我们就必须为我们的 function 指定一个参数。<br>主从复制，主机会将写操作记录在 bin-log 日志中。从机读取 bin-log 日志，执行语句来同步数据。如果使用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，mysql 不开启创建函数设置。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看 mysql 是否允许创建函数</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_bin_trust_function_creators&#x27;</span>;</span><br><span class="line"># 命令开启：允许创建函数设置：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>;	# 不加 <span class="keyword">global</span> 只是当前窗口有效</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 创建插入模拟数据的存储过程</span><br><span class="line"># 存储过程<span class="number">1</span>: 创建插入课程表存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="keyword">insert</span> course(max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>; # 设置手动提交事务</span><br><span class="line">	REPEAT	# 循环</span><br><span class="line">	<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;	# 赋值</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> course (course_id, course_name) <span class="keyword">VALUES</span> (rand_num(<span class="number">10000</span>, <span class="number">10100</span>), rand_string(<span class="number">6</span>));</span><br><span class="line">	UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">	<span class="keyword">END</span> REPEAT;</span><br><span class="line">	<span class="keyword">COMMIT</span>;	# 提交事物</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 存储过程<span class="number">2</span>:创建插入学生信息表存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_stu(max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	REPEAT</span><br><span class="line">	<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> student_info (course_id, class_id, student_id, NAME) <span class="keyword">VALUES</span></span><br><span class="line">	(rand_num(<span class="number">10000</span>, <span class="number">10100</span>), rand_num(<span class="number">10000</span>,<span class="number">10200</span>), rand_num(<span class="number">1</span>, <span class="number">200000</span>), rand_string(<span class="number">6</span>));</span><br><span class="line">	UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">	<span class="keyword">END</span> REPEAT;</span><br><span class="line">	<span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 调用存储过程</span><br><span class="line"><span class="keyword">CALL</span> insert_course(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">CALL</span> insert_stu(<span class="number">1000000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-哪些情况适合创建索引"><a href="#3-2-哪些情况适合创建索引" class="headerlink" title="3.2 哪些情况适合创建索引"></a>3.2 哪些情况适合创建索引</h4><ul>
<li><p>字段的数值有唯一性的限制</p>
<p>  索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中，如果某个字段是唯一性的，就可以直接创建唯一性索引，或者主键索引。这样可以更快速地通过该索引来确定某条记录。</p>
<p>  例如，学生表中学好是具有唯一性的字段，为该字段建立唯一性索引可以很快确定某个学生的信息，如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p>
<blockquote>
<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。</p>
<p>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p>
</blockquote>
</li>
<li><p>频繁作为 WHERE 查询条件的字段</p>
<p>  某个字段在 SELECT 语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p>
<p>  比如 student_info 数据表 (含 100 万条数据)，假设我们想要查询 student_id&#x3D;123110 的用户信息。</p>
<p>  如果我们没有对 student_id 字段创建索引，进行如下查询：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> course_id, class_id, name, create_time, student_id</span><br><span class="line"><span class="keyword">FROM</span> student_info</span><br><span class="line"><span class="keyword">WHERE</span> student_id <span class="operator">=</span> <span class="number">123110</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 耗时：<span class="number">251</span>ms</span><br></pre></td></tr></table></figure>

<p>  为 student_id 添加索引</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_sid(student_id);</span><br><span class="line"># 耗时<span class="number">1</span>ms。</span><br></pre></td></tr></table></figure>
</li>
<li><p>经常 GROUP BY 和 ORDER BY 的列</p>
<p>  索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要对分组或者排序的字段进行索引。如果待排序的列有多个，那么可以在这些列上建立组合索引。</p>
<p>  比如，按照 student_id 对学生选修的课程进行分组，现是不同的 student_id 和课程数量，显式 100 个即可。如果我们不对 student_id 创建索引，执行下面的 SQL 语句：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num <span class="keyword">FROM</span> student_info <span class="keyword">GROUP</span> <span class="keyword">BY</span> student_id LIMIT <span class="number">100</span>;</span><br><span class="line">耗时<span class="number">1</span>ms。</span><br></pre></td></tr></table></figure>

<p>  删除索引 (<code>DROP INDEX idx_sid ON student_info;</code>) 后运行时间: 1273ms。</p>
<p>  同样，如果是 ORDER BY，也需要对字段创建索引。</p>
<p>  如果同时有 GROUP BY 和 ORDER BY 的情况：比如我们按照 student_id 进行分组，同时按照创建时间降序的方式进行排序，这时我们就需要同时进行 GROUP BY 和 ORDER BY，那么是不是需要单独创建 student_id 的索引和 create_time 的索引呢？</p>
<p>  当我们对 student_id 和 create_time 分别创建索引，执行下面的 SQL 查询：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num <span class="keyword">FROM</span> student_info</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> student_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>  当对 student_id 和 create_time 分别创建索引时，sql 执行顺序是先执行 GROUP BY，所以只会使用 student_id 的索引。要想提高效率需要创建联合索引 <code>ALTER TABLE student_info ADD INDEX idx_sid_create_time(student_id, create_time DESC);</code>。但是如果创建索引时，student_id 和 create_time 顺序交换，执行上面的 sql，也不会用到该索引。</p>
</li>
<li><p>UPDATE、DELTET 的 WHERE 条件列</p>
<p>  当我们对某条数据进行 UPDATE 或者 DELETE 操作的时候，是否也需要对 WHERE 的条件列创建索引呢？</p>
<p>  想要把 name 为 IWIDRA 对应的 student_id 修改为 10002，当我们没有对 name 进行索引的时候，执行 SQL 语句：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> student_info <span class="keyword">SET</span> student_id <span class="operator">=</span> <span class="number">10002</span></span><br><span class="line"><span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;IWIDRA&#x27;</span>;</span><br><span class="line"># 耗时 <span class="number">356</span>ms</span><br></pre></td></tr></table></figure>

<p>  看一看到效率不高，但如果对 name 字段创建了索引，在执行类似 SQL </p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_name(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> student_info <span class="keyword">SET</span> student_id <span class="operator">=</span> <span class="number">10003</span></span><br><span class="line"><span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;qStmgT&#x27;</span>;</span><br><span class="line"># 耗时 <span class="number">3</span>ms</span><br></pre></td></tr></table></figure>

<p>  同样的，对 DELETE 语句 WHERE 条件后的字段创建索引，也会大幅提升效率。</p>
<p>  对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段时非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护</strong>。</p>
</li>
<li><p>DISTINCT 字段需要创建索引</p>
<p>  有时我门需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。比如，想要查询课程表中不同的 student_id 都有哪些，如果没有对 student_id 创建索引，执行 SQL 语句：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(student_id) <span class="keyword">FROM</span> student_info;</span><br><span class="line"># 耗时：<span class="number">553</span>ms</span><br></pre></td></tr></table></figure>

<p>  如果对 student_id 创建索引，在执行 SQL：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_sid(student_id);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(student_id) <span class="keyword">FROM</span> student_info;</span><br><span class="line"># 耗时：<span class="number">12</span>ms</span><br></pre></td></tr></table></figure>

<p>  能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照递增的顺序进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。</p>
</li>
<li><p>多表 JOIN 连接操作时，创建索引注意事项</p>
<p>  首先，连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套循环，数量级增长会非常快，严重影响查询的效率。</p>
<p>  其次，对 WHERE 条件创建索引，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p>
<p>  最后，对用于连接的字段创建索引，并且该字段再多张表中的类型必须一致。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。</p>
<p>  执行下面的 SQL，如果只对 student_id 创建索引</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> course.course_id, name, student_info.student_id, course_name</span><br><span class="line"><span class="keyword">FROM</span> student_info <span class="keyword">JOIN</span> course</span><br><span class="line"><span class="keyword">ON</span> student_info.course_id<span class="operator">=</span>course.course_id</span><br><span class="line"><span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;qStmgT&#x27;</span>;</span><br><span class="line"># 耗时：<span class="number">186</span>ms</span><br></pre></td></tr></table></figure>

<p>  对 name 创建索引，再次执行耗时：3ms</p>
</li>
<li><p>使用列的类型小的创建索引</p>
<p>  我们这里说的类型大小指的就是该类型表示的数据范围的大小。</p>
<p>  我们在定义表结构的时候要显式的指定列的类型，以整数类型为列，有 TINYINT、MEDIUMINT、INT、BIGINT 等，它们占用的存储空间一次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引使用较小的类型，比如我们能使用 INT 就不要使用 BIGINT，能使用 MEDIUMINT 就不要使用 INT。这是因为：</p>
<ul>
<li>数据类型越小，在查询时进行的比较操作越快</li>
<li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I&#x2F;O 到来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li>
</ul>
<p>  这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I&#x2F;O。</p>
</li>
<li><p>使用字符串前缀创建索引</p>
</li>
<li><p>假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的 B+ 树中有那么两个问题：</p>
<ul>
<li>B+ 树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在索引中占用的存储空间越大。</li>
<li>如果 B+ 树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。</li>
</ul>
<p>  我们可以通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既节约空间，又减少了字符串的比较时间，还大体能解决排序的问题。</p>
<p>  例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间，如果只检索字段前面的若干字符，这样可以提高检索速度。</p>
<p>  创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> shop(address <span class="type">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> shop <span class="keyword">ADD</span> INDEX(address(<span class="number">12</span>));</span><br></pre></td></tr></table></figure>

<p>  问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的，截取得少了，重复内容太多，字段的散列度会降低。怎么计算不同的长度的选择性呢？</p>
<p>  先看一下字段在全部数据中的选择度：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">distinct</span> address) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> shop;</span><br></pre></td></tr></table></figure>

<p>  通过不同长度去计算，与全表的选择性对比：</p>
<p>  公式：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(列名, 索引长度)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br></pre></td></tr></table></figure>

<p>  例如：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address, <span class="number">10</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub10, <span class="comment">-- 截取前 10 个字符的选择度</span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address, <span class="number">15</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub11, <span class="comment">-- 截取前 15 个字符的选择度</span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address, <span class="number">20</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub12, <span class="comment">-- 截取前 20 个字符的选择度</span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address, <span class="number">25</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub13, <span class="comment">-- 截取前 25 个字符的选择度</span></span><br></pre></td></tr></table></figure>

<p>  <strong>引申另一个问题：索引列前缀对排序的影响</strong></p>
<p>  如果使用了索引列前缀，比方说前边只把 address 列的前 12 个字符放到了二级索引中，下边这个查询可能就有点尴尬了：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> shop</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> address</span><br><span class="line">LIMIT <span class="number">12</span>;</span><br></pre></td></tr></table></figure>

<p>  因为二级索引中不包含完整的 address 列信息，所以无法对前 12 个字符相同，后边不同的记录进行排序，也就是使用索引列前缀的方式无法支持使用索引排序，只能使用文件排序。</p>
<p>  <strong>拓展：Alibaba《Java 开发手册》</strong></p>
<p>  【强制】在 varchar 字段上建立索引时，必须制定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</p>
<p>  说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上，可以使用  <code>count(distinct left(列名, 索引长度)) / count(*)</code> 的区分度来确定。</p>
</li>
<li><p>区分度高 (散列性高) 的列适合作为索引</p>
<p>  列的基数指的是某一列中不重复数据的个数，比方说某个列包含值 2，5，8，2，5，8，2，5，8，虽然有 9 条记录，但该列的基数却是 3.也就是说，在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</p>
<p>  可以使用公式 <code>SELECT COUNT(distinct a) / count(*) FROM t1</code> 计算区分度，越接近 1 越好，一般超过 33% 就算是比较高效的索引了。</p>
<p>  拓展：联合索引把区分度高 (散列性高) 的列放在前面。</p>
</li>
<li><p>使用最频繁的列放到联合索引的左侧</p>
<p>  这样也可以较少的建立一些索引。同时，由于“最左前缀原则”，可以增加联合索引的使用率。</p>
</li>
<li><p>在多个字段都要创建索引的情况下，联合索引由于单值索引</p>
</li>
</ul>
<h4 id="3-3-限制索引的数目"><a href="#3-3-限制索引的数目" class="headerlink" title="3.3 限制索引的数目"></a>3.3 限制索引的数目</h4><p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量不超过 6 个。原因：</p>
<ul>
<li>每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。</li>
<li>索引会影响 INSERT、DELETE、UPDATE 等语句的性能，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</li>
<li>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加 MySQL 优化器生成执行计划时间，降低查询性能。</li>
</ul>
<h4 id="3-4-哪些情况不适合创建索引"><a href="#3-4-哪些情况不适合创建索引" class="headerlink" title="3.4 哪些情况不适合创建索引"></a>3.4 哪些情况不适合创建索引</h4><ol>
<li><p>在 WHERE 中使用不到的字段，不要设置索引</p>
<p> WHERE 条件 (包括 GROUP BY、ORDER BY) 里用不到的字段不需要创建索引，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的。</p>
</li>
<li><p>数据量小的表最好不要使用索引</p>
<p> <strong>如果表记录太少，比如少于 1000 个，那么是不需要创建索引的</strong>。表记录太少，是否创建索引对查询效率的影响并不大。甚至说，查询话费的时间可能比遍历索引的时间还短，索引可能不会产生优化效果。</p>
</li>
<li><p>有大量重复数据的列上不需要建立索引</p>
<p> 在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。比如在学生表的“性别”字段上只有“男”与“女”两个不同值，因此无需建立索引。如果建立索引，不但不会提高查询效率，反而会严重降低数据更新速度。</p>
<blockquote>
<p>结论：当数据重复度大，比如高于 10% 的时候，也不需要对这个字段使用索引。</p>
</blockquote>
</li>
<li><p>避免对经常更新的表创建过多的索引</p>
<p> 第一层含义：频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。</p>
<p> 第二层含义：避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却会降低更新表的速度。</p>
</li>
<li><p>不建议用无序的值作为索引</p>
<p> 例如身份证、UUID (在索引比较时需要专为 ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p>
</li>
<li><p>删除不再使用或者很少使用的索引</p>
<p> 表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将他们删除，从而减少索引对更新操作的影响。</p>
</li>
<li><p>不要定义冗余或重复的索引</p>
<p> <strong>冗余索引</strong></p>
<p> 有时候有意或无意的就对同一个列创建了多个索引，比如：index(a, b, c) 相当于 index(a)、index(a, b)、index(a, b, c)。index(a, b, c) 索引就可以对 a 进行快速搜索，如果在对 a 列进行创建索引，就是一个冗余索引。</p>
<p> <strong>重复索引</strong></p>
<p> 在一个表中，col1 是主键，此时给他定义一个唯一索引，还定义了一个普通索引，但是主键本身就会生成聚簇索引，索引定义的唯一索引和普通索引是重复的，这种情况要避免。</p>
</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>索引是一把双刃剑，可提高查询效率，但也会降低插入和更新的速度并占用磁盘空间。</p>
<p>选择索引的最终目的是为了使查询的速度变快，上面给出的原则是最基本的准则，但不能拘泥于上面的准则，大家要在以后的学习和工作中进行不断的实践，根据应用的实际情况进行分析和判断，选择最合适的索引方式。</p>
<h2 id="七、性能分析工具的使用"><a href="#七、性能分析工具的使用" class="headerlink" title="七、性能分析工具的使用"></a>七、性能分析工具的使用</h2><p>在数据库调优中，我们的目标就是响应时间更快，吞吐量更大。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。</p>
<h3 id="1-数据库服务器的优化步骤"><a href="#1-数据库服务器的优化步骤" class="headerlink" title="1. 数据库服务器的优化步骤"></a>1. 数据库服务器的优化步骤</h3><p>当我们遇到数据库调优问题的时候，该如何思考呢？思考的的整个流程图分成了观察 Show status 和行动 Action 两个部分。字母 S 的部分代表观察 (会使用相应的分析工具)，字母 A 代表的部分是行动 (对应分析可以采取的行动)。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="数据库服务器的优化流程图"></p>
<p>我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的 SQL 都有哪些，查看具体的 SQL 执行计划，甚至是 SQL 执行中的每一步的成本代价，这样才能定位问题所在，找到了问题，再采取相应的行动。</p>
<p><strong>详细解释一下上图</strong>：</p>
<p>首先在 S1 部分，我们需要观察服务器的状态是否存在周期性的波动。如果存在周期性波动，有可能是周期性节点的原因，比如双十一、</p>
<p>促销活动等。这样的话，我们可以通过 A1 这一步骤解决，也就是加缓存，或者更改缓存失效策略。</p>
<p>如果缓存策略没有解决，或者不是周期性波动的原因，我们就需要进一步分析查询延迟和卡顿的原因。接下来进入 S2 这一步，我们需要开启慢查询。慢查询可以帮我们定位执行慢的 SQL 语句。我们可以通过设置 long_query_time 参数定义慢的阈值，如果 SQL 执行实际那超过了 long_query_time，则会认为是慢查询。当收集上来这些慢查询之后，我们就可以通过分析工具对慢查询日志进行分析。</p>
<p>在 S3 这一步骤中，我们就知道了执行慢的 SQL，这样就可以针对性地使用 EXPLAIN 查看对应 SQL 语句的执行计划，或者使用 show profile 查看 SQL 中每一个步骤的时间成本。这样我们就可以了解 SQL 查询慢是因为执行时间长，还是等待时间长。</p>
<p>如果是 SQL 等待时间长，我们进入 A2 步骤。在这一步骤中，我们可以调优服务器的参数，比如适当增加数据库缓冲池。如果是 SQL 执行时间长，就进入 A3 步骤，这一步中我们需要考虑是索引设计的问题？还是查询关联的数据表过多？还是因为数据表的字段设计问题导致了这一现象。然后在这些维度上进行对应的调整。</p>
<p>如果 A2 和 A3 都不能解决问题，我们需要考虑数据库自身的 SQL 查询性能是否已经达到了瓶颈，如果确认没有到达性能瓶颈，就需要重新检查，重复以上的步骤。如果已经到达了性能瓶颈，进入 A4 阶段，需要考虑增加服务器，采用读写分离的架构，或者考虑对数据库进行分库分表，比如垂直分库、垂直分表和水平分表等。</p>
<p>以上就是数据库调优的流程思路。如果我们发现执行 SQL 时存在不规则延迟或卡顿的时候，就可以采用分析工具帮我们定位有问题的 SQL，这三种分析工具你可以理解是 SQL 调优的三个步骤：慢查询、EXPLAIN 和 SHOW PROFILING。</p>
<p><strong>小结</strong>：</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.png" alt="性能分析"></p>
<h3 id="2-查看系统性能参数"><a href="#2-查看系统性能参数" class="headerlink" title="2. 查看系统性能参数"></a>2. 查看系统性能参数</h3><p>在 MySQL 中，可以使用 SHOW STATUS 语句查询一些 MySQL 数据库服务器的性能参数、执行效率。</p>
<p>SHOW STATUS 语句语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;参数&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>一些常用的性能参数如下：</p>
<ul>
<li>Connections：连接 MySQL 服务器的次数。</li>
<li>Uptime：MySQL 服务器上线时间。</li>
<li>Slow_queries：慢查询的次数。</li>
<li>Innodb_rows_read：Select 查询返回的行数。</li>
<li>Innodb_rows_inserted：执行 INSERT 操作插入的行数。</li>
<li>Innodb_rows_updated：执行 UPDATE 操作更新的行数。</li>
<li>Innodb_rows_deleted：执行 DELETED 擦欧总删除的行数。</li>
<li>Com_select：查询操作的次数。</li>
<li>Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。</li>
<li>Com_update：更新操作的次数。</li>
<li>Com_delete：删除操作的次数。</li>
</ul>
<h3 id="3-统计-SQL-的查询成本：last-query-cost"><a href="#3-统计-SQL-的查询成本：last-query-cost" class="headerlink" title="3. 统计 SQL 的查询成本：last_query_cost"></a>3. 统计 SQL 的查询成本：last_query_cost</h3><p>一条 SQL 查询语句在执行前需要确定查询执行计划，如果存在多种执行计划的话，MySQL 会计算每个执行计划所需要的成本，从中选择成本最小的一个座位最终执行的执行计划。</p>
<p>如果我们想要查看某条 SQL 语句的查询成本，可以在执行完这条 SQL 语句之后，通过查看当前会话中的last_query_cost 变量值来得到当前查询的成本。它通常也是我们评价一个查询的执行效率的一个常用指标。这个查询成本对应的是 SQL 语句所需要读取的页的数量。</p>
<p>例如：想要在 student 表中查询 id&#x3D;900001 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time <span class="keyword">FROM</span> student_info</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">900001</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果 (1 条记录，运行时间为 0.015s)</p>
<p>然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#结果</span><br><span class="line">last_query_cost <span class="operator">=</span> <span class="number">1.000000</span></span><br></pre></td></tr></table></figure>

<p>如果想要查询 id 在 900001 到 900100 之间的学生记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time <span class="keyword">FROM</span> student_info</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">900001</span> <span class="keyword">AND</span> <span class="number">900100</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果 (100 条记录，运行时间为 0.004s)</p>
<p>查看优化器成本</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#结果</span><br><span class="line">last_query_cost <span class="operator">=</span> <span class="number">20.290432</span></span><br></pre></td></tr></table></figure>

<p>能看到页的数量是刚才的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SQL 查询的时间基本上一样，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然页数量增加了不少，但是通过缓冲池的机制，并没有增加多少查询时间。</p>
<p>使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p>
<p>SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到一下两点结论：</p>
<ul>
<li><strong>位置决定效率</strong>。如果页就在数据库缓冲池中，那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li>
<li><strong>批量决定效率</strong>。如果我们从磁盘中对单一页进行随机读，那么效率是很低的 (差不多 10ms)，而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li>
</ul>
<p>所以说，遇到 I&#x2F;O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到缓冲池中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p>
<h3 id="4-定位执行慢的-SQL：慢查询日志"><a href="#4-定位执行慢的-SQL：慢查询日志" class="headerlink" title="4. 定位执行慢的 SQL：慢查询日志"></a>4. 定位执行慢的 SQL：慢查询日志</h3><p>MySQL 的慢查询日志，用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 long_query_time 值的 SQL，则会被记录到慢查询日志中。long_query_time 的默认值为 10，意思是运行 10 秒以上 (不包含 10 秒) 的语句，认为是超出了我们的最大忍耐时间值。</p>
<p>它的主要作用是，帮助我们发现那些执行时间特别长的 SQL 查询，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，对解决问题很有帮助。比如一条 SQL 执行超过 15s，我们就算慢 SQL，希望能收集超过 5s 的 SQL，结合 EXPLAIN 进行全面分析。</p>
<p>默认情况下，MySQL 数据库没有开启慢查询日志，需要我们手动来设置这个参数。如果不是条有需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持 将日志记录写入文件。</p>
<h4 id="4-1-开启慢查询日志参数"><a href="#4-1-开启慢查询日志参数" class="headerlink" title="4.1 开启慢查询日志参数"></a>4.1 开启慢查询日志参数</h4><p><strong>开启 slow_query_log</strong></p>
<p>在使用前，需要先看下慢查询是否已经开启 <code>show variables like &#39;%slow_query_log&#39;;</code> ，如果是 off 状态，使用 <code>set global slow_query_log=&#39;ON&#39;;</code> 开启。使用 <code>show variables like &#39;%slow_query_log%&#39;;</code> 查看慢查询日志文件的位置。</p>
<h4 id="4-2-修改-long-query-time-阈值"><a href="#4-2-修改-long-query-time-阈值" class="headerlink" title="4.2 修改 long_query_time 阈值"></a>4.2 修改 long_query_time 阈值</h4><p>使用 <code>show variables like &#39;%long_query_time%&#39;;</code> 查看慢查询的时间阈值设置，使用 <code>set global long_query_time = 1;</code> 修改慢查询的时间阈值。使用 <code>show global status like &#39;%slow_queries%&#39;;</code> 查看当前系统中有多少条慢查询记录。</p>
<h4 id="4-3-案例演示"><a href="#4-3-案例演示" class="headerlink" title="4.3 案例演示"></a>4.3 案例演示</h4><p><strong>分析</strong></p>
<p>除了上述变量，控制慢查询日志的还有一个系统变量：min_examined_row_limit。这个变量的意思是，查询扫描过的最少记录数。这个变量和查询执行时间，共同组成了判别一个查询是否是慢查询的条件。如果查询扫描过的记录数大于等于这个变量的值，并且查询执行时间超过 long_query_time 的值，那么，这个查询就被记录到慢查询日志中；反之，则不被记录到慢查询日志中。</p>
<p><code>show variables like &#39;min%&#39;;</code> 这个值默认是 0。与 long_query_time&#x3D;10 合在一起，表示只要查询的执行时间超过 10 秒钟，哪怕一个记录也没有扫描，都要被记录到慢查询日志中。你也可以根据需要，通过修改 my.ini 文件，来修改查询时长，或者通过 SET 命令，用 SQL 语句修改 min_examined_row_limit 的值。</p>
<h4 id="4-4-慢查询日志分析工具：mysqldumpslow"><a href="#4-4-慢查询日志分析工具：mysqldumpslow" class="headerlink" title="4.4 慢查询日志分析工具：mysqldumpslow"></a>4.4 慢查询日志分析工具：mysqldumpslow</h4><p>在生产环境中，如果要收工分析日志，查找、分析 SQL，显然是个体力活，MySQL 提供了日志分析工具 mysqldumpslow。</p>
<p>查看 mysqldumpslow 的帮助信息 <code>mysqldumpslow --help</code> </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">~</span><span class="operator">/</span> mysqldumpslow <span class="comment">--help</span></span><br><span class="line">Usage: mysqldumpslow [ OPTS... ] [ LOGS... ]</span><br><span class="line"></span><br><span class="line">Parse <span class="keyword">and</span> summarize the MySQL slow query log. Options <span class="keyword">are</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">--verbose    verbose</span></span><br><span class="line">  <span class="comment">--debug      debug</span></span><br><span class="line">  <span class="comment">--help       write this text to standard output</span></span><br><span class="line"></span><br><span class="line">  <span class="operator">-</span>v           verbose</span><br><span class="line">  <span class="operator">-</span>d           debug</span><br><span class="line">  <span class="operator">-</span>s <span class="keyword">ORDER</span>     what <span class="keyword">to</span> sort <span class="keyword">by</span> (al, <span class="keyword">at</span>, ar, c, l, r, t), <span class="string">&#x27;at&#x27;</span> <span class="keyword">is</span> <span class="keyword">default</span></span><br><span class="line">                al: average lock <span class="type">time</span></span><br><span class="line">                ar: average <span class="keyword">rows</span> sent</span><br><span class="line">                <span class="keyword">at</span>: average query <span class="type">time</span></span><br><span class="line">                 c: count</span><br><span class="line">                 l: lock <span class="type">time</span></span><br><span class="line">                 r: <span class="keyword">rows</span> sent</span><br><span class="line">                 t: query <span class="type">time</span>  </span><br><span class="line">  <span class="operator">-</span>r           reverse the sort <span class="keyword">order</span> (largest <span class="keyword">last</span> instead <span class="keyword">of</span> <span class="keyword">first</span>)</span><br><span class="line">  <span class="operator">-</span>t NUM       just <span class="keyword">show</span> the top n queries</span><br><span class="line">  <span class="operator">-</span>a           don<span class="string">&#x27;t abstract all numbers to N and strings to &#x27;</span>S<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  -n NUM       abstract numbers with at least n digits within names</span></span><br><span class="line"><span class="string">  -g PATTERN   grep: only consider stmts that include this string</span></span><br><span class="line"><span class="string">  -h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),</span></span><br><span class="line"><span class="string">               default is &#x27;</span><span class="operator">*</span><span class="string">&#x27;, i.e. match all</span></span><br><span class="line"><span class="string">  -i NAME      name of server instance (if using mysql.server startup script)</span></span><br><span class="line"><span class="string">  -l           don&#x27;</span>t subtract lock <span class="type">time</span> <span class="keyword">from</span> total <span class="type">time</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>mysqldumpslow -a -s t -t 5 /opt/homebrew/var/mysql/zhangjiandeMacBook-Pro-slow.log</code> 定位慢查询 SQL。</p>
<h4 id="4-5-关闭慢查询日志"><a href="#4-5-关闭慢查询日志" class="headerlink" title="4.5 关闭慢查询日志"></a>4.5 关闭慢查询日志</h4><ul>
<li><p>永久性方式</p>
<p>  修改 my.cnf 或 my.ini 文件，把 [mysqld] 组下的 slow_query_log 值设为 OFF，修改保存后，在重启 MySQL 服务，即可生效。</p>
</li>
<li><p>临时性方式</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log<span class="operator">=</span>OFF;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-6-删除慢查询日志"><a href="#4-6-删除慢查询日志" class="headerlink" title="4.6 删除慢查询日志"></a>4.6 删除慢查询日志</h4><p>使用 SHOW 语句显示慢查询日志信息，具体 SQL 语句如下：</p>
<p><code>SHOW VARIABLES LIKE &#39;slow_query_log%&#39;;</code></p>
<p>从执行结果可以看出慢查询日志的的目录，在该目录下手动删除慢查询日志文件即可。使用命令 <code>mysqladmin flush-logs</code> 来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p flush<span class="operator">-</span>logs slow</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示</p>
<p>慢查询日志都是使用 mysqladmin flush-logs 命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。</p>
</blockquote>
<h3 id="5-查看-SQL-执行成本：SHOW-PROFILE"><a href="#5-查看-SQL-执行成本：SHOW-PROFILE" class="headerlink" title="5. 查看 SQL 执行成本：SHOW PROFILE"></a>5. 查看 SQL 执行成本：SHOW PROFILE</h3><p>show profile 是 MySQL 提供的可以用来分析当前会话中 SQL 都做了什么、执行的资源消耗情况的工具，可用于 SQL 调优的测量。默认情况下处于关闭状态，并保存最近 15 次的运行结果。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看状态</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span>;</span><br><span class="line"># 开启</span><br><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"># 查看当前会话有哪些 profile</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"># 查看指定 query id</span><br><span class="line"><span class="keyword">show</span> profile cpu, block io <span class="keyword">for</span> query <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>show profile 的常用查询参数</strong>：</p>
<ul>
<li>ALL：显示所有的开销信息。</li>
<li>BLOCK IO：显示块 IO 开销。</li>
<li>CONTEXT SWITCHES：上下文切换开销。</li>
<li>CPU：显示 CPU 开销信息。</li>
<li>IPC：显示发送和接受开销信息。</li>
<li>MEMORY：显示内存开销信息。</li>
<li>PAGE FAULTS：显示页面错误开销信息。</li>
<li>SOURCE：显示和 Source_function，Source_file，Source_line 相关的开销信息。</li>
<li>SWAPS：显示交换次数开销信息。</li>
</ul>
<p><strong>日常开发需要注意的结论</strong>：</p>
<ul>
<li><code>concerting HEAP to MyISAM</code>：查询结果太大，内存不够，数据往磁盘上搬了。</li>
<li><code>Creating tmp table</code>：创建临时表，先拷贝数据到临时表，用完后再删除临时表。</li>
<li><code>Copying to tmp table on disk</code>：把内存中临时表复制到磁盘上，警惕！</li>
<li><code>locked</code>。</li>
</ul>
<p>如果在 show profile 诊断结果中出现了以上 4 条结果中的任何一条，则 SQL 语句需要优化。</p>
<blockquote>
<p>注意：</p>
<p>不过 show profile 命令将被弃用，可以从 information_schema 中 profiling 数据表进行查看。</p>
</blockquote>
<h3 id="6-分析查询语句：EXPLAIN"><a href="#6-分析查询语句：EXPLAIN" class="headerlink" title="6. 分析查询语句：EXPLAIN"></a>6. 分析查询语句：EXPLAIN</h3><h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h4><p><strong>定位了慢查询的 SQL 之后，我们就可以使用 EXPLAIN 或 DESCRIBE 工具做针对性的分析查询语句</strong>。DESCRIBE 语句的使用方法与 EXPLAIN 语句是一样的，并且分析结果也是一样的。</p>
<p>MySQL 中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的 Query 提供它认为最优的执行计划 (他认为最优的数据检索方式，但不见得是 DBA 认为是最优的，这部分最耗费时间)。</p>
<p>这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL 为我们提供了 EXPLAIN 语句来帮助我们查看某个查询语句的具体执行计划。</p>
<p><strong>能做什么</strong>？</p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li><strong>哪些索引被实际使用</strong></li>
<li>表之间的引用</li>
<li><strong>每张表有多少行被优化器查询</strong></li>
</ul>
<p><strong><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">官网介绍</a></strong></p>
<p><strong>版本情况</strong></p>
<ul>
<li>MySQL 5.6.3 以前只能 EXPLAIN SELECT；MySQL 5.6.3 以后就可以 EXPLAIN SELECT、UPDATE、DELETE</li>
<li>在 5.7 以前的版本中，想要显示 partitions 需要使用 explain partitions 命令；想要显示 filtered 需要使用 explain extended 命令。在 5.7 版本后，默认 explain 直接显示 partitions 和 filtered 中的信息。</li>
</ul>
<h4 id="6-2-基本语法"><a href="#6-2-基本语法" class="headerlink" title="6.2 基本语法"></a>6.2 基本语法</h4><p>EXPLAIN 或 DESCRIBE 语句的语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> select_options</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">SELECT</span> select_options</span><br></pre></td></tr></table></figure>

<p>如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 EXPLAIN，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">No</span> tables used <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br></pre></td></tr></table></figure>

<p>输出的上述信息就是所谓的执行计划。在这个执行计划的辅助下，我们需要知道应该怎么样改进自己的查询语句以使查询执行起来更高效。其实除了以 SELECT 开头的查询语句，其余的 DELETE、INSERT、REPLACE 以及 UPDATE 语句等都可以加上 EXPLAIN，用来查看这些语句的执行计划，只是平时我们对 SELECT 语句更感兴趣。</p>
<blockquote>
<p>注意：</p>
<p>执行 EXPLAIN 时并没有真正的执行该后面的语句，因此可以安全的查看执行计划。</p>
</blockquote>
<p>EXPLAIN 语句输出的各个列的作用如下：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id</td>
</tr>
<tr>
<td>select_type</td>
<td>SELECT 关键字对应的那个查询的类型</td>
</tr>
<tr>
<td>table</td>
<td>表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区信息</td>
</tr>
<tr>
<td>type</td>
<td>针对单表的访问方法</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际上使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>实际使用到的索引长度</td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td>rows</td>
<td>预估的需要读取的记录条数</td>
</tr>
<tr>
<td>filtered</td>
<td>某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>一些额外的信息</td>
</tr>
</tbody></table>
<h4 id="6-3-数据准备"><a href="#6-3-数据准备" class="headerlink" title="6.3 数据准备"></a>6.3 数据准备</h4><p><strong>建表</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s1 (</span><br><span class="line">	id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">  key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key2 <span class="type">INT</span>,</span><br><span class="line">  key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  INDEX idx_key1 (key1),</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX idx_key2 (key2),</span><br><span class="line">  INDEX idx_key3 (key3),</span><br><span class="line">  INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s2 (</span><br><span class="line">	id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">  key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key2 <span class="type">INT</span>,</span><br><span class="line">  key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  INDEX idx_key1 (key1),</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX idx_key2 (key2),</span><br><span class="line">  INDEX idx_key3 (key3),</span><br><span class="line">  INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p><strong>设置参数 log_bin_trust_function_creators</strong></p>
<p>创建函数，假如报错，需开启如下命令：允许创建函数设置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>;	# 不加 <span class="keyword">global</span> 只是当前窗口有效。</span><br></pre></td></tr></table></figure>

<p><strong>创建函数</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string1(n <span class="type">INT</span>)</span><br><span class="line">	<span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>)	#	该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line">		<span class="keyword">SET</span> return_str <span class="operator">=</span> CONCAT(return_str, <span class="built_in">SUBSTRING</span>(chars_str, <span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> RAND() <span class="operator">*</span> <span class="number">52</span>), <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">END</span> WHILE;</span><br><span class="line">	<span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><strong>创建存储过程</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_s1 (<span class="keyword">IN</span> min_num <span class="type">INT</span> (<span class="number">10</span>), <span class="keyword">IN</span> max_num <span class="type">INT</span> (<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	REPEAT</span><br><span class="line">	<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> s1 <span class="keyword">VALUES</span>(</span><br><span class="line">  (min_num <span class="operator">+</span> i),</span><br><span class="line">  rand_string1(<span class="number">6</span>),</span><br><span class="line">  (min_num <span class="operator">+</span> <span class="number">30</span> <span class="operator">*</span> i <span class="operator">+</span> <span class="number">5</span>),</span><br><span class="line">  rand_string1(<span class="number">6</span>),</span><br><span class="line">  rand_string1(<span class="number">10</span>),</span><br><span class="line">  rand_string1(<span class="number">5</span>),</span><br><span class="line">  rand_string1(<span class="number">10</span>),</span><br><span class="line">  rand_string1(<span class="number">10</span>));</span><br><span class="line">  UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">  <span class="keyword">END</span> REPEAT;</span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_s2 (<span class="keyword">IN</span> min_num <span class="type">INT</span> (<span class="number">10</span>), <span class="keyword">IN</span> max_num <span class="type">INT</span> (<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	REPEAT</span><br><span class="line">	<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> s2 <span class="keyword">VALUES</span>(</span><br><span class="line">  (min_num <span class="operator">+</span> i),</span><br><span class="line">  rand_string1(<span class="number">6</span>),</span><br><span class="line">  (min_num <span class="operator">+</span> <span class="number">30</span> <span class="operator">*</span> i <span class="operator">+</span> <span class="number">5</span>),</span><br><span class="line">  rand_string1(<span class="number">6</span>),</span><br><span class="line">  rand_string1(<span class="number">10</span>),</span><br><span class="line">  rand_string1(<span class="number">5</span>),</span><br><span class="line">  rand_string1(<span class="number">10</span>),</span><br><span class="line">  rand_string1(<span class="number">10</span>));</span><br><span class="line">  UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">  <span class="keyword">END</span> REPEAT;</span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><strong>调用存储过程</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> insert_s1(<span class="number">10001</span>, <span class="number">10000</span>);</span><br><span class="line"><span class="keyword">CALL</span> insert_s2(<span class="number">10001</span>, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="6-4-EXPLAIN-各列作用"><a href="#6-4-EXPLAIN-各列作用" class="headerlink" title="6.4 EXPLAIN 各列作用"></a>6.4 EXPLAIN 各列作用</h4><ul>
<li>table：表名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 查询的每一行记录都对应着一个单表</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line"># s1:驱动表  s2:被驱动表</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">join</span> buffer (hash <span class="keyword">join</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+</span></span><br><span class="line"># 执行计划中，记录在前的为驱动表，在后的为被驱动表，这里s2为驱动表，s1为被驱动表</span><br></pre></td></tr></table></figure>

<ul>
<li>id：在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2</span><br><span class="line"><span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key2</span><br><span class="line"><span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> idx_key1      <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> idx_key2      <span class="operator">|</span> idx_key2 <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> mysql_test.s1.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-----------------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key3 <span class="keyword">FROM</span> s2);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>       <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys       <span class="operator">|</span> key                 <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE       <span class="operator">|</span> s1          <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> idx_key1            <span class="operator">|</span> <span class="keyword">NULL</span>                <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE       <span class="operator">|</span> <span class="operator">&lt;</span>subquery2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="operator">&lt;</span>auto_distinct_key<span class="operator">&gt;</span> <span class="operator">|</span> <span class="operator">&lt;</span>auto_distinct_key<span class="operator">&gt;</span> <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> mysql_test.s1.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> MATERIALIZED <span class="operator">|</span> s2          <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index  <span class="operator">|</span> idx_key3            <span class="operator">|</span> idx_key3            <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> s2         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span> <span class="operator">|</span> <span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br></pre></td></tr></table></figure>

<p><strong>查询优化器可能对涉及子查询的查询语句进行重写，转变为多表查询的操作</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key2 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> idx_key1      <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> idx_key2      <span class="operator">|</span> idx_key2 <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> mysql_test.s1.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span>; <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p><strong>Union 去重</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> s2         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span> <span class="operator">|</span> <span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>       <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>id 如果相同，可以认为是一组，从上往下顺序执行</p>
</li>
<li><p>在所有组中，id 值越大，优先级越高，越先执行</p>
</li>
<li><p>关注点：id 号每个号码，表示一趟独立的查询，一个 SQL 的查询趟越少越好数</p>
</li>
</ul>
</blockquote>
<ul>
<li>select_type</li>
</ul>
<p>一条大的查询语句里边可以包含若干个 SELECT 关键字，每个 SELECT 关键字代表着一个小的查询语句，而每个 SELECT 关键字的 FROM 字句中都可以包含若干张表 (这些表用来做连接查询)，每一张表都对应着执行计划输出中的一条记录，对于在同一个 SELECT 关键字中的表来说，它们的 id 值是相同的。</p>
<p>MySQL 为每个 SELECT 关键字代表的小查询都定义了一个称之为 select_type 的属性，意思是我们只要知道了某个小查询的 select_type 属性，就知道了这个小查询在整个大查询中扮演的一个什么角色，select_type 能取的值：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>Simple SELECT (not using UNION or subqueries)</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>Outermost SELECT</td>
</tr>
<tr>
<td>UNION</td>
<td>Second or later SELECT statement in a UNION</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>Result of a UNION</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>FIRST SELECT in subquery</td>
</tr>
<tr>
<td>DEPENDENT SUBQUERY</td>
<td>First SELECT in subquery,dependent on outer query</td>
</tr>
<tr>
<td>DEPENDENT UNION</td>
<td>Second or later SELECT statement in a UNION, dependent on outer query</td>
</tr>
<tr>
<td>DERIVED</td>
<td>Derived table</td>
</tr>
<tr>
<td>MATERIALIZED</td>
<td>Materialized subquery</td>
</tr>
<tr>
<td>UNCACHEABLE SUBQUERY</td>
<td>A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td>
</tr>
<tr>
<td>UNCACHEABLE UNION</td>
<td>The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td>
</tr>
</tbody></table>
<p>select_type：SELECT 关键字对应的那个查询的类型，确定小查询在整个大查询中扮演了一个什么角色</p>
<p>具体分析：</p>
<ol>
<li><p>SIMPLE</p>
<p> 查询语句中不包含 UNION 或者子查询的查询都算是 SIMPLE 类型</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line"># 连接查询也算是 SIMPLE 类型</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">join</span> buffer (hash <span class="keyword">join</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>UNION RESULT</p>
<p> 对于包含 UNION 或者 UNION ALL 或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的 select_type 值就是 PRIMARY。</p>
<p> 对于包含 UNION 或者 UNION ALL 的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的 select_type 值就是 UNION。</p>
<p> MySQL 选择使用临时表来完成 UNION 查询的去重工作，针对该临时表的查询的 select_type 就是 UNION RESULT。</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> s2         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span> <span class="operator">|</span> <span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>       <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>SUBQUERY</p>
<p> 如果包含子查询的查询语句不能够专为对应的 semi-join 的形式，并且该子查询是不相关子查询。该子查询的第一个 SELECT 关键字代表的那个查询的 select_type 就是 SUBQUERY</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>​		如果包含子查询的查询语句不能够专为对应的 semi-join 的形式，并且该子查询是相关子查询，则该子查询的第一个 SELECT 关键字		代表的那个查询的 select_type 就是 DEPENDENT SUBQUERY</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1</span><br><span class="line"><span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> s1.key2 <span class="operator">=</span> s2.key2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+--------+-------------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type        <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys     <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+--------+-------------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>            <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> idx_key3          <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DEPENDENT SUBQUERY <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> idx_key2,idx_key1 <span class="operator">|</span> idx_key2 <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> mysql_test.s1.key2 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+--------+-------------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"># 注意的是，select_type 为 DEPENDENT SUBQUERY 的查询可能会被执行多次</span><br></pre></td></tr></table></figure>

<p>​		在包含 UNION 或者 UNION ALL 的大查询中，如果各个小查询都依赖于外层查询的话，拿出了最左边的那个小查询之外，其余的小		查询的 select_type 的值就是 DEPENDENT UNION。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1</span><br><span class="line"><span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type        <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>            <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DEPENDENT SUBQUERY <span class="operator">|</span> s2         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> DEPENDENT <span class="keyword">UNION</span>    <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span>       <span class="operator">|</span> <span class="operator">&lt;</span>union2,<span class="number">3</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span></span><br></pre></td></tr></table></figure>

<p>​		对于派生表的查询，该派生表对应的子查询的 select_type 就是 DERIVED。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> key1, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> c <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> key1) <span class="keyword">AS</span> derived_s1 <span class="keyword">WHERE</span> c <span class="operator">&gt;</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> <span class="operator">&lt;</span>derived2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<p>​		当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的 select_type 属性就		是 MATERALIZED。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2);	#	子查询被转化为物化表</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>       <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys       <span class="operator">|</span> key                 <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE       <span class="operator">|</span> s1          <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> idx_key1            <span class="operator">|</span> <span class="keyword">NULL</span>                <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE       <span class="operator">|</span> <span class="operator">&lt;</span>subquery2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="operator">&lt;</span>auto_distinct_key<span class="operator">&gt;</span> <span class="operator">|</span> <span class="operator">&lt;</span>auto_distinct_key<span class="operator">&gt;</span> <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> mysql_test.s1.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> MATERIALIZED <span class="operator">|</span> s2          <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index  <span class="operator">|</span> idx_key1            <span class="operator">|</span> idx_key1            <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>partitions：匹配的分区信息</p>
<p>  代表分区表中的命中情况，非分区表，该项为 NULL。一般情况下我们的查询语句的执行计划的 partitions 列的值都是 NULL。</p>
</li>
<li><p><strong>type</strong>：针对单表的访问方法</p>
<p>  执行计划的一条记录就代表着 MySQL 对某个表的执行查询时的访问方法，又称访问类型，其中的 type 列就表明了这个访问方法是啥，是较为重要的一个指标。比如，看到 type 列的值是 ref，表明 MySQL 即将使用 ref 访问方法来执行对 s1 表的查询。</p>
<p>  完整的访问方法如下：system, const, eq_ref, ref, fulltext, ref_or_null, index_merge, unique_subquery, index_subquery, range, index, ALL。</p>
<ul>
<li><p>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如 MyISAM、MEMORY，那么对该表的访问方法就是 system。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t(i <span class="type">INT</span>) ENGINE<span class="operator">=</span>MyISAM;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t     <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">system</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是 const</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10005</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> const <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key2 <span class="operator">=</span> <span class="number">10066</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> const <span class="operator">|</span> idx_key2      <span class="operator">|</span> idx_key2 <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在连接查询时，如果被驱动表时通过主键或者唯一二级索引列等值匹配的方式进行访问的 (如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较)，则对该被驱动表的访问方法就是 eq_ref。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>              <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> mysql_test.s2.id <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是 ref</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当对普通二级索引进行等值匹配查询，该索引列的值也可以是 NULL 值时，那么对该表的访问方法就可能是 ref_or_null</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key1 <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type        <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> ref_or_null <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>单表访问方法时在某些场景下可以使用 Intersection、Union、Sort-Union 这三种索引合并的方式来执行查询</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type        <span class="operator">|</span> possible_keys     <span class="operator">|</span> key               <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index_merge <span class="operator">|</span> idx_key1,idx_key3 <span class="operator">|</span> idx_key1,idx_key3 <span class="operator">|</span> <span class="number">303</span>,<span class="number">303</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">union</span>(idx_key1,idx_key3); <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>unique_subquery 是针对在一些包含 IN 子查询的查询语句中，如果查询优化器决定将 IN 子查询转换为 EXISTS 子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的 type 列的值就是 unique_subquery。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1</span><br><span class="line"><span class="keyword">WHERE</span> key2 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> s1.key1 <span class="operator">=</span> s2.key1) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type        <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type            <span class="operator">|</span> possible_keys    <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>            <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>             <span class="operator">|</span> idx_key3         <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DEPENDENT SUBQUERY <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> unique_subquery <span class="operator">|</span> <span class="keyword">PRIMARY</span>,idx_key1 <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> func <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果使用索引获取某些范围区间的记录，那么就可能使用到 range 访问方法</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是 index</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> key_part2 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> idx_key_part  <span class="operator">|</span> idx_key_part <span class="operator">|</span> <span class="number">909</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>全表扫描</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>小结</p>
<p>  结果值从最好到最坏依次是：</p>
<p>  <strong>system</strong> &gt; <strong>const</strong> &gt; <strong>eq_ref</strong> &gt; <strong>ref</strong> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <strong>range</strong> &gt; <strong>index</strong> &gt; <strong>ALL</strong></p>
<p>  其中比较重要的几个提取出来 (加粗的)。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts 级别。</p>
</li>
</ul>
</li>
<li><p>possible_keys 和 key (可能用到的索引和实际上使用的索引)</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys     <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1,idx_key3 <span class="operator">|</span> idx_key3 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>     <span class="number">5.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>key_len：实际使用到的索引长度 (即：字节数)</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10005</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> const <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ref：当使用索引列等值查询时，与索引列进行等值匹配的对象信息。</p>
<p>  比如知识一个常数或者是某个列。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>              <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> mysql_test.s2.id <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>rows：预估的需要读取的记录条数，值越小越好</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">366</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>filtered：某个表经过搜索条件过滤后剩余记录条数的百分比。</p>
<p>  如果使用的是索引执行的单表扫描，那么计算时需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">366</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span>; <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>   对于单表查询来说，这个 filtered 列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的 filtered 值，它决定了被驱动表要执行的次数 (即：rows * filtered)</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> mysql_test.s1.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Extra：一些额外的信息，更准确的理解 MySQL 到底将如何执行给定的查询语句。</p>
<p>  当查询语句没有 FROM 字句时将会提示该额外信息</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">No</span> tables used <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br></pre></td></tr></table></figure>

<p>  查询语句的 WHERE 字句永远为 FALSE 时将会提示该额外信息</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">!=</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> Impossible <span class="keyword">WHERE</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span></span><br></pre></td></tr></table></figure>

<p>  当我们使用全表扫描来执行对某个表的查询，并且该语句的 WHERE 字句中有针对该表的搜索条件时，在 Extra 列中会提示上述额外信息</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<p>  当查询列表处有 MIN 或者 MAX 聚合函数，但是并没有符合 WHERE 字句中国呢的搜索条件的记录时，将会提示该额外信息</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(key1) <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;abcdefg&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">No</span> matching min<span class="operator">/</span>max <span class="type">row</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+</span></span><br></pre></td></tr></table></figure>

<p>  当查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用覆盖索引的情况下，在 Extra 列将会提示该额外信息。比方说下边这个查询中只需要用到 idx_key1 而不需要回表操作：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<p>  有些搜索条件中虽然出现了索引列，但却不能使用到索引</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key1 <span class="keyword">LIKE</span> <span class="string">&#x27;%a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">366</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure>

<p>  在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL 一般会为其分配一块名叫 join buffer 的内存块来加快查询速度，也就是我们所说的基于块的嵌套循环算法</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.common_field <span class="operator">=</span> s2.common_field;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">join</span> buffer (hash <span class="keyword">join</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>  当我们使用左连接时，如果 WHERE 子句中包含要求被驱动表的某个列等于 NULL 值的搜索条件，而且那个列又是不允许存储 NULL 值的，那么在该表的执行计划的 Extra 列就会提示 Not exists 额外信息</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> mysql_test.s1.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Not</span> <span class="keyword">exists</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------------------+</span></span><br></pre></td></tr></table></figure>

<p>  如果执行计划的 Extra 列出现了 Using intersect(…) 提示，说明准备使用 Intersect 索引合并的方式执行查询，括号中的 … 表示需要进行索引合并的索引名称。如果出现了 Using union(…) 提示，说明准备使用 Union 索引合并的方式执行查询。出现了 Using sort union(…) 提示，说明准备使用 Sort-Union 索引合并的方式执行查询。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type        <span class="operator">|</span> possible_keys     <span class="operator">|</span> key               <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index_merge <span class="operator">|</span> idx_key1,idx_key3 <span class="operator">|</span> idx_key1,idx_key3 <span class="operator">|</span> <span class="number">303</span>,<span class="number">303</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">union</span>(idx_key1,idx_key3); <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>  当我们的 LIMIT 子句的参数为 0 时，表示压根不打算从表中读出任何记录，将会提示该额外信息</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 LIMIT <span class="number">0</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> Zero limit <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+</span></span><br></pre></td></tr></table></figure>

<p>  有一些情况对结果集中的记录进行排序是可以使用到索引的。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> key1 LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>

<p>  很多情况下排序操作无法使用到索引，只能在内存中 (记录较少的时候) 或者磁盘中 (记录较多的时候) 进行排序，MySQL 把这种在内存或者磁盘上进行排序的方式统称为文件排序 (英文名：filesort)</p>
<p>  如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的 Extra 列中显示 Using filesort 提示</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> common_field LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br></pre></td></tr></table></figure>

<p>  在许多查询的执行过程中，MySQL 可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含 DISTINCT、GROUP BY、UNION 等子句的查询过程中，如果不能有效利用索引来完成查询，MySQL 很有可能寻求通过建立内部临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的 Extra 列将会显示 Using temporary 提示。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> common_field <span class="keyword">FROM</span> s1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br></pre></td></tr></table></figure>

<p>  执行计划中出现 Using temporary 并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以我们最好能使用索引来替代掉使用临时表。比如：扫描指定的索引 idx_key1 即可。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> key1, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> amount <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> key1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>小结</p>
<ul>
<li>EXPLAIN 不考虑各种 cache</li>
<li>EXPLAIN 不能显示 MySQL 在执行查询时所作的优化工作</li>
<li>EXPLAIN 不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li>
<li>部分统计信息是估算的，并非精确值</li>
</ul>
</li>
</ul>
<h3 id="7-EXPLAIN-的进一步使用"><a href="#7-EXPLAIN-的进一步使用" class="headerlink" title="7. EXPLAIN 的进一步使用"></a>7. EXPLAIN 的进一步使用</h3><h4 id="7-1-EXPLAIN-四种输出格式"><a href="#7-1-EXPLAIN-四种输出格式" class="headerlink" title="7.1 EXPLAIN 四种输出格式"></a>7.1 EXPLAIN 四种输出格式</h4><ul>
<li><p>传统格式</p>
<p>  传统格式简单明了，输出是一个表格形式，概要说明查询计划。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> s1.key1, s2.key1 <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.common_field <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>    <span class="number">90.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> mysql_test.s2.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JSON 格式</p>
<p>  第一种格式中介绍的 EXPLAIN 语句输出中缺少了一个衡量执行计划好坏的重要属性——成本。而 JSON 格式是四种格式里面输出信息最详尽的格式，里面包含了执行的成本信息。</p>
<ul>
<li><p>JSON 格式：在 EXPLAIN 单词和真正的查询语句中间加上 FORMAT&#x3D;JSON。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT<span class="operator">=</span>JSON <span class="keyword">SELECT</span> ......</span><br></pre></td></tr></table></figure>
</li>
<li><p>EXPLAIN 的 Column 与 JSON 的对应关系</p>
<table>
<thead>
<tr>
<th>Column</th>
<th>JSON Name</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>select_id</td>
<td>The SELECT identifier</td>
</tr>
<tr>
<td>select_type</td>
<td>None</td>
<td>The SELECT type</td>
</tr>
<tr>
<td>table</td>
<td>table_name</td>
<td>The table for the output row</td>
</tr>
<tr>
<td>partitions</td>
<td>partitions</td>
<td>The matching partitions</td>
</tr>
<tr>
<td>type</td>
<td>access_type</td>
<td>The join type</td>
</tr>
<tr>
<td>possible_keys</td>
<td>possible_keys</td>
<td>The possible indexes to choose</td>
</tr>
<tr>
<td>key</td>
<td>key</td>
<td>The index actually chosen</td>
</tr>
<tr>
<td>ken_len</td>
<td>key_length</td>
<td>The length of the chosen key</td>
</tr>
<tr>
<td>ref</td>
<td>ref</td>
<td>The columns compared to the index</td>
</tr>
<tr>
<td>rows</td>
<td>rows</td>
<td>Estimate of rows to be examined</td>
</tr>
<tr>
<td>filtered</td>
<td>filtered</td>
<td>Percentage of rows filtered by table condition</td>
</tr>
<tr>
<td>Extra</td>
<td>None</td>
<td>Additional information</td>
</tr>
</tbody></table>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT<span class="operator">=</span>JSON <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key2 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">EXPLAIN: &#123;</span><br><span class="line">  &quot;query_block&quot;: &#123;</span><br><span class="line">    &quot;select_id&quot;: <span class="number">1</span>,</span><br><span class="line">    &quot;cost_info&quot;: &#123;</span><br><span class="line">      &quot;query_cost&quot;: &quot;1360.07&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;nested_loop&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;table&quot;: &#123;</span><br><span class="line">          &quot;table_name&quot;: &quot;s1&quot;,</span><br><span class="line">          &quot;access_type&quot;: &quot;ALL&quot;,</span><br><span class="line">          &quot;possible_keys&quot;: [</span><br><span class="line">            &quot;idx_key1&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;rows_examined_per_scan&quot;: <span class="number">9895</span>,</span><br><span class="line">          &quot;rows_produced_per_join&quot;: <span class="number">989</span>,</span><br><span class="line">          &quot;filtered&quot;: &quot;10.00&quot;,</span><br><span class="line">          &quot;cost_info&quot;: &#123;</span><br><span class="line">            &quot;read_cost&quot;: &quot;914.80&quot;,</span><br><span class="line">            &quot;eval_cost&quot;: &quot;98.95&quot;,</span><br><span class="line">            &quot;prefix_cost&quot;: &quot;1013.75&quot;,</span><br><span class="line">            &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;used_columns&quot;: [</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;key1&quot;,</span><br><span class="line">            &quot;key2&quot;,</span><br><span class="line">            &quot;key3&quot;,</span><br><span class="line">            &quot;key_part1&quot;,</span><br><span class="line">            &quot;key_part2&quot;,</span><br><span class="line">            &quot;key_part3&quot;,</span><br><span class="line">            &quot;common_field&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;attached_condition&quot;: &quot;((`mysql_test`.`s1`.`common_field` = &#x27;a&#x27;) and (`mysql_test`.`s1`.`key1` is not null))&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;table&quot;: &#123;</span><br><span class="line">          &quot;table_name&quot;: &quot;s2&quot;,</span><br><span class="line">          &quot;access_type&quot;: &quot;eq_ref&quot;,</span><br><span class="line">          &quot;possible_keys&quot;: [</span><br><span class="line">            &quot;idx_key2&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;key&quot;: &quot;idx_key2&quot;,</span><br><span class="line">          &quot;used_key_parts&quot;: [</span><br><span class="line">            &quot;key2&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;key_length&quot;: &quot;5&quot;,</span><br><span class="line">          &quot;ref&quot;: [</span><br><span class="line">            &quot;mysql_test.s1.key1&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;rows_examined_per_scan&quot;: <span class="number">1</span>,</span><br><span class="line">          &quot;rows_produced_per_join&quot;: <span class="number">989</span>,</span><br><span class="line">          &quot;filtered&quot;: &quot;100.00&quot;,</span><br><span class="line">          &quot;index_condition&quot;: &quot;(cast(`mysql_test`.`s1`.`key1` as double) = cast(`mysql_test`.`s2`.`key2` as double))&quot;,</span><br><span class="line">          &quot;cost_info&quot;: &#123;</span><br><span class="line">            &quot;read_cost&quot;: &quot;247.38&quot;,</span><br><span class="line">            &quot;eval_cost&quot;: &quot;98.95&quot;,</span><br><span class="line">            &quot;prefix_cost&quot;: &quot;1360.08&quot;,</span><br><span class="line">            &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;used_columns&quot;: [</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;key1&quot;,</span><br><span class="line">            &quot;key2&quot;,</span><br><span class="line">            &quot;key3&quot;,</span><br><span class="line">            &quot;key_part1&quot;,</span><br><span class="line">            &quot;key_part2&quot;,</span><br><span class="line">            &quot;key_part3&quot;,</span><br><span class="line">            &quot;common_field&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  s1 表的的成本计算：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">  &quot;read_cost&quot;: &quot;914.80&quot;,</span><br><span class="line">  &quot;eval_cost&quot;: &quot;98.95&quot;,</span><br><span class="line">  &quot;prefix_cost&quot;: &quot;1013.75&quot;,</span><br><span class="line">  &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>read_cost 是由下边这两部分组成的：</p>
<ul>
<li>IO 成本</li>
<li>检测 <code>rows * (1 - filter)</code> 条记录的 CPU 成本</li>
</ul>
<blockquote>
<p>rows 和 filter 都是前边介绍执行计划的输出列，在 JSON 格式的执行计划中，rows 相当于 rows_wxamined_per_scan，filtered 名称不变。</p>
</blockquote>
</li>
<li><p>eval_cost 是这样计算的：</p>
<p>  检测 <code>rows * filter</code> 条记录的成本</p>
</li>
<li><p>prefix_cost 就是单独查询 s1 表的成本，也就是：</p>
<p>  <code>read_cost + eval_cost</code></p>
</li>
<li><p>data_read_per_join 表示在此次查询中需要读取的数据量。</p>
</li>
</ul>
<p>  对于 s2 表的 cost_info 部分是这样的：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">  &quot;read_cost&quot;: &quot;247.38&quot;,</span><br><span class="line">  &quot;eval_cost&quot;: &quot;98.95&quot;,</span><br><span class="line">  &quot;prefix_cost&quot;: &quot;1360.08&quot;,</span><br><span class="line">  &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  由于 s2 表是被驱动表，所以可能被读取多次，这里的 read_cost 和 eval_cost 是访问多次 s2 表后累加起来的值，主要关注里边的 prefix_cost 的值代表的是整个连接查询预计的成本，也就是单词查询 s1 表和多次查询 s2 表后的成本的和，也就是：</p>
<p>  <code>247.38 + 98.95 + 1013.75 = 1360.08</code></p>
</li>
</ul>
</li>
<li><p>TREE 格式</p>
<p>  TREE 格式是 8.0.16 版本之后引入的新格式，主要根据查询的各个部分之间的关系和各部分的执行顺序来描述如何查询。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT<span class="operator">=</span>TREE <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key2 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>\G</span><br><span class="line">EXPLAIN: <span class="operator">-</span><span class="operator">&gt;</span> Nested loop <span class="keyword">inner</span> <span class="keyword">join</span>  (cost<span class="operator">=</span><span class="number">1360.08</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">990</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Filter</span>: ((s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>) <span class="keyword">and</span> (s1.key1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>))  (cost<span class="operator">=</span><span class="number">1013.75</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">990</span>)</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Table</span> scan <span class="keyword">on</span> s1  (cost<span class="operator">=</span><span class="number">1013.75</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">9895</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> Single<span class="operator">-</span><span class="type">row</span> index lookup <span class="keyword">on</span> s2 <span class="keyword">using</span> idx_key2 (key2<span class="operator">=</span>s1.key1), <span class="keyword">with</span> index <span class="keyword">condition</span>: (<span class="built_in">cast</span>(s1.key1 <span class="keyword">as</span> <span class="keyword">double</span>) <span class="operator">=</span> <span class="built_in">cast</span>(s2.key2 <span class="keyword">as</span> <span class="keyword">double</span>))  (cost<span class="operator">=</span><span class="number">0.25</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>可视化输出</p>
<p>  可视化输出，可以通过 MySQL Workbench 可视化查看 MySQL 的执行计划。通过点击 workbench 的放大镜图标，即可生成可视化的查询计划。</p>
</li>
</ul>
<h4 id="7-2-SHOW-WARNINGS-的使用"><a href="#7-2-SHOW-WARNINGS-的使用" class="headerlink" title="7.2 SHOW WARNINGS 的使用"></a>7.2 SHOW WARNINGS 的使用</h4><p>在使用 EXPLAIN 语句查看了某个查询的执行计划之后，紧接着还可以使用 SHOW WARNINGS 语句查看与这个查询的执行计划有关的一下扩展信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> s1.key1, s2.key1 <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.common_field <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>    <span class="number">90.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> mysql_test.s2.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> WARNINGS \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">  Level: Note</span><br><span class="line">   Code: <span class="number">1003</span></span><br><span class="line">Message: <span class="comment">/* select#1 */</span> <span class="keyword">select</span> `mysql_test`.`s1`.`key1` <span class="keyword">AS</span> `key1`,`mysql_test`.`s2`.`key1` <span class="keyword">AS</span> `key1` <span class="keyword">from</span> `mysql_test`.`s1` <span class="keyword">join</span> `mysql_test`.`s2` <span class="keyword">where</span> ((`mysql_test`.`s1`.`key1` <span class="operator">=</span> `mysql_test`.`s2`.`key1`) <span class="keyword">and</span> (`mysql_test`.`s2`.`common_field` <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>))</span><br></pre></td></tr></table></figure>

<p>可以看到 SHOW WARNINGS 展示出来的信息有三个字段：Level、Code、Message。最常见的就是 Code 为 1003 的信息，当 Code 为 1003 时，Message 字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。比如上边的查询本来是一个左外连接查询，但是有一个 s2.common_field IS NOT NULL 的条件，就会导致查询优化器把左外连接查询优化为内连接查询，从 SHOW WARNINGS 的 Message 字段也可以看出来，原本的 LEFT JOIN 已经变成了 JOIN。</p>
<h3 id="8-分析优化器执行计划：trace"><a href="#8-分析优化器执行计划：trace" class="headerlink" title="8. 分析优化器执行计划：trace"></a>8. 分析优化器执行计划：trace</h3><p>OPTIMIZER_TRACE 是 MySQL 5.6 引入的一项跟踪功能，它可以跟踪优化器做出的各种决策 (比如访问表的方法、各种开销计算、各种转换等)，并将跟踪结果记录到 INFORMATION_SCHEMA.OPTIMIZER_TRACE 表中。</p>
<p>此功能默认关闭。开启 trace，并设置格式为 JSON，同时设置 trace 最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enable=on&#x27;</span>,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">SET</span> optimizer_trace_max_mem_size<span class="operator">=</span><span class="number">1000000</span>;</span><br></pre></td></tr></table></figure>

<p>开启后，可分析如下语句：</p>
<ul>
<li>SELECT</li>
<li>INSERT</li>
<li>REPLACE</li>
<li>UPDATE</li>
<li>DELETE</li>
<li>EXPLAIN</li>
<li>SET</li>
<li>DECLARE</li>
<li>CASE</li>
<li>IF</li>
<li>RETURN</li>
<li>CALL</li>
</ul>
<p>执行 SQL 后执行 <code>SELECT * FROM information_schema.optimizer_trace \G</code></p>
<p>结果包括四部分：</p>
<ul>
<li>查询语句</li>
<li>QUERY 字段对应语句的跟踪信息</li>
<li>跟踪信息过长时，被截断的跟踪信息的字节数</li>
<li>执行跟踪语句的用户是否有查看对象的权限，当不具有权限时，该列信息为 1 且 TRACE 字段为空，一般在调用带有 SQL SECURITY DEFINER 的视图或者是存储过程的情况下，会出现此问题。</li>
</ul>
<h3 id="9-MySQL-监控分析视图-sys-schema"><a href="#9-MySQL-监控分析视图-sys-schema" class="headerlink" title="9. MySQL 监控分析视图 - sys schema"></a>9. MySQL 监控分析视图 - sys schema</h3><p>关于 MySQL 的性能监控和问题诊断，我们一般都从 performance_schema 中去获取想要的数据，在 MySQL 5.7.7 版本中新增 sys schema，它将 performance_schema 和 information_schema 中的数据以更容易理解的方式总结归纳为视图，其目的就是为了降低查询 performance_schema 的复杂度，让 DBA 能够快速的定位问题。</p>
<h4 id="9-1-Sys-schema-视图摘要"><a href="#9-1-Sys-schema-视图摘要" class="headerlink" title="9.1 Sys schema 视图摘要"></a>9.1 Sys schema 视图摘要</h4><ul>
<li>主机相关：以 host_summary开头，主要汇总了 IO 延迟的信息。</li>
<li>Innodb 相关：以 innodb 开头，汇总了 innodb buffer 信息和事务等待 innodb 锁的信息。</li>
<li>I&#x2F;O 相关：以 io 开头，汇总了等待 I&#x2F;O、I&#x2F;O 使用量情况。</li>
<li>内存使用情况：以 memory 开头，从主机、县城、事件等角度展示内存的使用情况。</li>
<li>连接与会话信息：processlist 和 session 相关视图，总结了会话相关信息。</li>
<li>表相关：以 schema_table 开头的视图，展示了表的统计信息。</li>
<li>索引信息：统计了索引的使用情况，包含冗余索引和未使用的索引情况。</li>
<li>语句相关：以 statement 开头，包含了执行全表扫描、使用临时表、排序等的语句信息。</li>
<li>用户相关：以 user 开头的视图，统计了用户使用的文件 I&#x2F;O、执行语句统计信息。</li>
<li>等待事件相关信息：以 wait 开头，展示等待事件的延迟情况。</li>
</ul>
<h4 id="9-2-Sys-schema-视图使用场景"><a href="#9-2-Sys-schema-视图使用场景" class="headerlink" title="9.2 Sys schema 视图使用场景"></a>9.2 Sys schema 视图使用场景</h4><p><strong>索引情况</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查询冗余索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_redundant_indexes;</span><br><span class="line"></span><br><span class="line"># 查询未使用过的索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_unused_indexes;</span><br><span class="line"></span><br><span class="line"># 查询索引的使用情况</span><br><span class="line"><span class="keyword">select</span> index_name, rows_selected, rows_inserted, rows_updated, rows_deleted <span class="keyword">from</span> sys.schema_index_statistics <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>表相关</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查询表的访问量</span><br><span class="line"><span class="keyword">select</span> table_schema, table_name, <span class="built_in">sum</span>(io_read_requests<span class="operator">+</span>io_write_requests) <span class="keyword">as</span> io <span class="keyword">from</span> sys.schema_table_statistics <span class="keyword">group</span> <span class="keyword">by</span> table_schema, table_name <span class="keyword">order</span> <span class="keyword">by</span> io <span class="keyword">desc</span>;</span><br><span class="line"># 查询占用 bufferpool 较多的表</span><br><span class="line"><span class="keyword">select</span> object_schema, object_name, allocated, data <span class="keyword">from</span> sys.innodb_buffer_stats_by_table <span class="keyword">order</span> <span class="keyword">by</span> allocated limit <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># 查看表的全表扫描情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.statements_with_full_table_scans <span class="keyword">where</span> db<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>语句相关</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 监控 <span class="keyword">SQL</span> 执行的频率</span><br><span class="line"><span class="keyword">select</span> db, exec_count, query <span class="keyword">from</span> sys.statement_analysis <span class="keyword">order</span> <span class="keyword">by</span> exec_count <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"># 监控使用了排序的 <span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db, exec_count, first_seen, last_seen, query <span class="keyword">from</span> sys.statements_with_sorting limit <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># 监控使用了临时表或磁盘临时表的 <span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db, exec_count, tmp_tables, tmp_disk_tables, query <span class="keyword">from</span> sys.statement_analysis <span class="keyword">where</span> tmp_tables <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">or</span> tmp_disk_tables <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">order</span> <span class="keyword">by</span> (tmp_tables <span class="operator">+</span> tmp_disk_tables) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p><strong>IO 相关</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看消耗磁盘 IO 的文件</span><br><span class="line"><span class="keyword">select</span> file, avg_read, avg_write, avg_read <span class="operator">+</span> avg_write <span class="keyword">as</span> avg_io <span class="keyword">from</span> sys.io_global_by_file_by_bytes <span class="keyword">order</span> <span class="keyword">by</span> avg_read limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Innodb 相关</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 行锁阻塞情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>风险提示：</p>
<p>通过 sys 库去查询时，MySQL 会消耗大量资源去收集相关信息，严重的可能会导致业务请求被阻塞，从而引起故障。建议生产上不要频繁的去查询 sys 或者 performance_schema、information_schema 来完成监控、巡检等工作。</p>
</blockquote>
<h2 id="八、索引优化与查询优化"><a href="#八、索引优化与查询优化" class="headerlink" title="八、索引优化与查询优化"></a>八、索引优化与查询优化</h2><p>都有哪些维度可以进行数据库调优？简言之：</p>
<ul>
<li>索引失效、没有充分利用到索引——索引建立</li>
<li>关联查询太多 JOIN (设计缺陷或不得已的需求) ——SQL 优化</li>
<li>服务器调优及各个参数设置 (缓冲、线程数等)——调整 my.cnf</li>
<li>数据过多——分库分表</li>
</ul>
<p>SQL 查询优化的技术大致可以分成物理查询优化和逻辑查询优化两大块。</p>
<ul>
<li>物理查询优化是通过索引和表连接方式等技术来进行优化，这里重点需要掌握索引的使用。</li>
<li>逻辑查询优化就是通过 SQL 等价变换提升查询效率，直白一点就是说，换一种查询写法执行效率可能更高。</li>
</ul>
<h3 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1. 数据准备"></a>1. 数据准备</h3><h4 id="1-1-建表"><a href="#1-1-建表" class="headerlink" title="1.1 建表"></a>1.1 建表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> class(</span><br><span class="line">	id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  className <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  address <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  monitor <span class="type">INT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">	id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  stuno <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  age <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  classId <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">  # <span class="keyword">CONSTRAINT</span> fk_class_id <span class="keyword">FOREIGN</span> KEY (classId) <span class="keyword">REFERENCES</span> t_class (id)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-设置参数"><a href="#1-2-设置参数" class="headerlink" title="1.2 设置参数"></a>1.2 设置参数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 开启允许创建函数设置：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-创建函数"><a href="#1-3-创建函数" class="headerlink" title="1.3 创建函数"></a>1.3 创建函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 生成随机字符串</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>)</span><br><span class="line">	<span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>)	#	该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line">		<span class="keyword">SET</span> return_str <span class="operator">=</span> CONCAT(return_str, <span class="built_in">SUBSTRING</span>(chars_str, <span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> RAND() <span class="operator">*</span> <span class="number">52</span>), <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">END</span> WHILE;</span><br><span class="line">	<span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 生成随机班级编号</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num(from_num <span class="type">INT</span>, to_num <span class="type">INT</span>)</span><br><span class="line">	<span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span> RAND() <span class="operator">*</span> (to_num <span class="operator">-</span> from_num <span class="operator">+</span> <span class="number">1</span>));</span><br><span class="line"><span class="keyword">RETURN</span> i;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 删除函数</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> 函数名;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-创建存储过程"><a href="#1-4-创建存储过程" class="headerlink" title="1.4 创建存储过程"></a>1.4 创建存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 创建往 stu 表中插入数据的存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_stu(<span class="keyword">START</span> <span class="type">INT</span>, max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;    # 设置手动提交事物</span><br><span class="line">	REPEAT      # 循环</span><br><span class="line">	<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;    # 赋值</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (stuno, name, age, classId) <span class="keyword">VALUES</span></span><br><span class="line">	((<span class="keyword">START</span> <span class="operator">+</span> i), rand_string(<span class="number">6</span>), rand_num(<span class="number">1</span>, <span class="number">50</span>), rand_num(<span class="number">1</span>, <span class="number">1000</span>));</span><br><span class="line">	UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">	<span class="keyword">END</span> REPEAT;</span><br><span class="line">	<span class="keyword">COMMIT</span>;			# 提交事物</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 往 class 表中插入数据的存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_class(max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;    # 设置手动提交事物</span><br><span class="line">	REPEAT      # 循环</span><br><span class="line">	<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;    # 赋值</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> class (classname, address, monitor) <span class="keyword">VALUES</span></span><br><span class="line">	(rand_string(<span class="number">8</span>), rand_string(<span class="number">10</span>), rand_num(<span class="number">1</span>, <span class="number">100000</span>));</span><br><span class="line">	UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">	<span class="keyword">END</span> REPEAT;</span><br><span class="line">	<span class="keyword">COMMIT</span>;			# 提交事物</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 删除存储过程</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> 存储过程名;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-调用存储过程"><a href="#1-5-调用存储过程" class="headerlink" title="1.5 调用存储过程"></a>1.5 调用存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 向 class 表中添加一万条数据</span><br><span class="line"><span class="keyword">CALL</span> insert_class(<span class="number">10000</span>);</span><br><span class="line"># 向 stu 表中添加 <span class="number">50</span> 万条数据</span><br><span class="line"><span class="keyword">CALL</span> insert_stu(<span class="number">100000</span>, <span class="number">500000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="1-6-删除某表上的索引"><a href="#1-6-删除某表上的索引" class="headerlink" title="1.6 删除某表上的索引"></a>1.6 删除某表上的索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc_drop_index(dbname <span class="type">VARCHAR</span>(<span class="number">200</span>), tablename <span class="type">VARCHAR</span>(<span class="number">200</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> ct <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> _index <span class="type">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> _cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> index_name <span class="keyword">FROM</span> information_schema.STATISTICS <span class="keyword">WHERE</span> table_schema<span class="operator">=</span>dbname <span class="keyword">AND</span> table_name<span class="operator">=</span>tablename <span class="keyword">AND</span> seq_in_index<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> index_name <span class="operator">&lt;&gt;</span> <span class="string">&#x27;PRIMARY&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">set</span> done <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">OPEN</span> _cur;</span><br><span class="line">    <span class="keyword">FETCH</span> _cur <span class="keyword">INTO</span> _index;</span><br><span class="line">    WHILE _index<span class="operator">&lt;&gt;</span><span class="string">&#x27;&#x27;</span> DO</span><br><span class="line">      <span class="keyword">SET</span> <span class="variable">@str</span> <span class="operator">=</span> CONCAT(&quot;drop index &quot;, _index, &quot; on &quot;, tablename);</span><br><span class="line">      <span class="keyword">PREPARE</span> sql_str <span class="keyword">FROM</span> <span class="variable">@str</span>;</span><br><span class="line">      <span class="keyword">EXECUTE</span> sql_str;</span><br><span class="line">      <span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> sql_str;</span><br><span class="line">      <span class="keyword">SET</span> _index<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="keyword">FETCH</span> _cur <span class="keyword">INTO</span> _index;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line">	<span class="keyword">CLOSE</span> _cur;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line"><span class="keyword">CALL</span> proc_drop_index(&quot;dbname&quot;, &quot;tablename&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="2-索引失效案例"><a href="#2-索引失效案例" class="headerlink" title="2. 索引失效案例"></a>2. 索引失效案例</h3><p>MySQL 中提高性能的一个最有效的方式是对数据表设计合理的索引。索引提供了高效访问数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。</p>
<ul>
<li>使用索引可以快速地定位表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。</li>
<li>如果查询时没有使用索引，查询语句就会扫描表中的所有记录。在数据量大的情况下，这样查询的速度会很慢。</li>
</ul>
<p>大多数情况下都 (默认) 采用 B+ 树来构建索引。只是空间列类型的索引使用 R-树，并且 MEMORY 表还支持 hash 索引。</p>
<p>其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？给予 cost 开销 (CostBaseOptimizer)，它不是基于规则 (Rule-BasedOptimizer)，也不是基于语义。怎么样开销小就怎么来。另外，SQL 语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</p>
<h4 id="2-1-全值匹配"><a href="#2-1-全值匹配" class="headerlink" title="2.1 全值匹配"></a>2.1 全值匹配</h4><p>系统中经常出现的 SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> classId <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> classId <span class="operator">=</span> <span class="number">4</span> <span class="keyword">AND</span> `NAME` <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>建立索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age <span class="keyword">ON</span> student(age);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid <span class="keyword">ON</span> student(age, classId);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student(age, classId, name);</span><br></pre></td></tr></table></figure>

<p>创建索引前的查询时间是 0.137s，创建索引后的查询时间是 0.001s。</p>
<h4 id="2-2-最佳左前缀法则"><a href="#2-2-最佳左前缀法则" class="headerlink" title="2.2 最佳左前缀法则"></a>2.2 最佳左前缀法则</h4><p>在 MySQL 建立联合索引时，会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> student.`name` <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.classId <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> student.`name` <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.classId <span class="operator">=</span> <span class="number">4</span> <span class="keyword">AND</span> student.age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> student.`name` <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>MySQL 可以为多个字段创建索引，一个索引可以包括 16 个字段。对于多列索引，<strong>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用</strong>。如果查询条件中没有使用这些字段中第一个字段时，多列或联合索引不会被使用。</p>
<blockquote>
<p>拓展：Alibaba《Java 开发手册》</p>
<p>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
</blockquote>
<h4 id="2-3-主键插入顺序"><a href="#2-3-主键插入顺序" class="headerlink" title="2.3 主键插入顺序"></a>2.3 主键插入顺序</h4><p>对于一个使用 InnoDB 存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在 1～100 之间，如果此时再插入一条主键值为 9 的记录，那它插入的位置在 8 和 10 之间，但是这个数据页已经满了，再插进来就需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着性能损耗。所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值一次递增，这样就不会发生这样的性能损耗了。所以建议：让主键具有 AUTO_INCREMENT，让存储引擎自己为表生成主键，而不是我们手动插入。</p>
<p>我们自定义的主键列 id 拥有 AUTO_INCREMENT 属性，再插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。</p>
<h4 id="2-4-计算、函数、类型转换到值索引失效"><a href="#2-4-计算、函数、类型转换到值索引失效" class="headerlink" title="2.4 计算、函数、类型转换到值索引失效"></a>2.4 计算、函数、类型转换到值索引失效</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.`name` <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(student.`name`, <span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> index idx_name <span class="keyword">ON</span> student(name);</span><br></pre></td></tr></table></figure>

<p>上面两个 SQL，第一个索引生效，第二个索引失效。</p>
<h4 id="2-5-类型转换到值索引失效"><a href="#2-5-类型转换到值索引失效" class="headerlink" title="2.5 类型转换到值索引失效"></a>2.5 类型转换到值索引失效</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="number">123</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_name      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_name      <span class="operator">|</span> idx_name <span class="operator">|</span> <span class="number">63</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>

<p>student 表中 name 字段是字符串类型，第一个 SQL 在执行时，会隐式将 name 转换成 整形，所以会导致索引失效。</p>
<blockquote>
<p>设计实体类属性时，一定要与数据库字段类型相对应。否则，就会出现类习惯转换的情况。</p>
</blockquote>
<h4 id="2-6-范围条件右边的列索引失效"><a href="#2-6-范围条件右边的列索引失效" class="headerlink" title="2.6 范围条件右边的列索引失效"></a>2.6 范围条件右边的列索引失效</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student(age, classId, name);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> classId <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">AND</span> `NAME` <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+-------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys        <span class="operator">|</span> key                  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+-------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_age_classid_name <span class="operator">|</span> idx_age_classid_name <span class="operator">|</span> <span class="number">10</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">19008</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+-------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure>

<p>根据 key_len 可以看出该 SQL 只用到了联合索引的 age 和 classId，name 并没有用到。范围条件：&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 和 between 等。</p>
<p>在实际开发中，将范围查询条件防止语句最后，建索引时，也将该字段放置在最后。</p>
<blockquote>
<p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置 where 语句最后。</p>
</blockquote>
<h4 id="2-7-不等于-x3D-或-lt-gt-索引失效"><a href="#2-7-不等于-x3D-或-lt-gt-索引失效" class="headerlink" title="2.7 不等于 (!&#x3D; 或 &lt;&gt;) 索引失效"></a>2.7 不等于 (!&#x3D; 或 &lt;&gt;) 索引失效</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> `NAME` <span class="operator">&lt;&gt;</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_name      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">50.15</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<h4 id="2-8-IS-NULL-可以使用索引，IS-NOT-NULL-无法使用索引"><a href="#2-8-IS-NULL-可以使用索引，IS-NOT-NULL-无法使用索引" class="headerlink" title="2.8 IS NULL 可以使用索引，IS NOT NULL 无法使用索引"></a>2.8 IS NULL 可以使用索引，IS NOT NULL 无法使用索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys        <span class="operator">|</span> key                  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_age_classid_name <span class="operator">|</span> idx_age_classid_name <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys        <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_age_classid_name <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">50.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：最好在设计数据表的时候就将字段设置为 NOT NULL 约束，比如你可以将 INT 类型的字段，默认值设置为 0。将字符类型的默认值设置为空字符串 (‘’)。</p>
<p>拓展：同理，在查询中使用 NOT LIKE 也无法使用索引，到值全表扫描。</p>
</blockquote>
<h4 id="2-9-like-以通配符-开头索引失效"><a href="#2-9-like-以通配符-开头索引失效" class="headerlink" title="2.9 like 以通配符 % 开头索引失效"></a>2.9 like 以通配符 % 开头索引失效</h4><p>在使用 LIKE 关键字进行查询的查询语句中，如果匹配字符串的第一个字符为 %，索引就不会起作用。只有 % 不在第一个位置，索引才会起作用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.`name` <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_name      <span class="operator">|</span> idx_name <span class="operator">|</span> <span class="number">63</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.`name` <span class="keyword">LIKE</span> <span class="string">&#x27;%abc&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">11.11</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>拓展：Alibaba《Java 开发手册》</p>
<p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p>
</blockquote>
<h4 id="2-10-OR-前后存在非索引的列，索引失效"><a href="#2-10-OR-前后存在非索引的列，索引失效" class="headerlink" title="2.10 OR 前后存在非索引的列，索引失效"></a>2.10 OR 前后存在非索引的列，索引失效</h4><p>在 WHERE 字句中，如果在 OR 前的条件列进行了索引，而在 OR 后的条件列没有进行索引，那么索引会失效。也就是说，OR 前后的两个条件中的列都是索引时，查询中才使用索引。</p>
<p>因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列进行了索引是没有意义的，只要有条件列没有进行索引，就会进行全表扫描，因此索引的条件列也会失效。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age <span class="keyword">ON</span> student(age);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">OR</span> classId <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_age       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">11.88</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> index idx_cid <span class="keyword">ON</span> student(classId);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------------+-----------------+-----------------+---------+------+-------+----------+-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type        <span class="operator">|</span> possible_keys   <span class="operator">|</span> key             <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------------+-----------------+-----------------+---------+------+-------+----------+-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index_merge <span class="operator">|</span> idx_age,idx_cid <span class="operator">|</span> idx_age,idx_cid <span class="operator">|</span> <span class="number">5</span>,<span class="number">5</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10232</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">union</span>(idx_age,idx_cid); <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------------+-----------------+-----------------+---------+------+-------+----------+-------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>当只在 age 字段上建立索引时，会导致索引失效。如果再给 classId 字段建立索引，此时就可以使用索引。</p>
<h4 id="2-11-数据库和表的字符集统一使用-utf8mb4"><a href="#2-11-数据库和表的字符集统一使用-utf8mb4" class="headerlink" title="2.11 数据库和表的字符集统一使用 utf8mb4"></a>2.11 数据库和表的字符集统一使用 utf8mb4</h4><p>统一使用 utf8mb4兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。</p>
<h4 id="2-12-建议"><a href="#2-12-建议" class="headerlink" title="2.12 建议"></a>2.12 建议</h4><ul>
<li>对于单列索引，尽量选择针对当前 query 过滤性更好的索引。</li>
<li>在选择组合索引的时候，当前 query 中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li>
<li>在选择组合索引的时候，尽量选择能够包含当前 query 中的 where 子句中更多字段的索引。</li>
<li>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。</li>
</ul>
<p>总之，书写 SQL 语句时，尽量避免造成索引失效的情况。 </p>
<h3 id="3-关联查询优化"><a href="#3-关联查询优化" class="headerlink" title="3. 关联查询优化"></a>3. 关联查询优化</h3><h4 id="3-1-数据准备-1"><a href="#3-1-数据准备-1" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 分类表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `type`(</span><br><span class="line">	id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  card <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"># 图书表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> book(</span><br><span class="line">	bookId <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  card <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (bookId)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 向分类表中插入 <span class="number">20</span> 条记录</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TYPE(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"></span><br><span class="line"># 向图书表中插入 <span class="number">20</span> 条记录</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br></pre></td></tr></table></figure>

<h4 id="3-2-采用左外连接"><a href="#3-2-采用左外连接" class="headerlink" title="3.2 采用左外连接"></a>3.2 采用左外连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> `type` <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card <span class="operator">=</span> book.card; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> type  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> book  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">join</span> buffer (hash <span class="keyword">join</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX x <span class="keyword">ON</span> book(card);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> type  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> book  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> x             <span class="operator">|</span> x    <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> mysql_test.type.card <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX y <span class="keyword">ON</span> `type`(card);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> type  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> y    <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> book  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> x             <span class="operator">|</span> x    <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> mysql_test.type.card <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-采用内连接"><a href="#3-3-采用内连接" class="headerlink" title="3.3 采用内连接"></a>3.3 采用内连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> `type` <span class="keyword">INNER</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card <span class="operator">=</span> book.card; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> type  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> book  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">join</span> buffer (hash <span class="keyword">join</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX y <span class="keyword">ON</span> `type`(card);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> book  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> type  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> y             <span class="operator">|</span> y    <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> mysql_test.book.card <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX x <span class="keyword">ON</span> book(card);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> book  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> x             <span class="operator">|</span> x    <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> type  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> y             <span class="operator">|</span> y    <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> mysql_test.book.card <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<p>从上述可以得出一下结论：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表。如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表。<strong>当表的连接条件中都没有索引 (或都有索引) 时，数据小的表驱动数据大的表</strong>。</p>
<h4 id="3-4-JOIN-语句原理"><a href="#3-4-JOIN-语句原理" class="headerlink" title="3.4 JOIN 语句原理"></a>3.4 JOIN 语句原理</h4><p>JOIN 方式连接多表，本质就是各个表之间数据的循环匹配。MySQL5.5 版本之前，MySQL 只支持一种表间关联方式，就是嵌套循环。如果关联表的数据量很大，则 JOIN 关联的执行时间会非常长。在 MySQL 5.5 以后的版本中，MySQL 通过引入 BNLJ 算法来优化嵌套执行。</p>
<p><strong>驱动表和被驱动表</strong></p>
<p>驱动表就是主表，被驱动表就是从表、非驱动表。</p>
<ul>
<li><p>对于内连接来说：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">JOIN</span> B <span class="keyword">ON</span> ...</span><br></pre></td></tr></table></figure>

<p>  对于内连接来说 A 不一定是驱动表，优化器会根据你查询语句做优化，决定先查哪张表。先查询的那张表就是驱动表，反之就是被驱动表。通过 explain 关键字可以查看。</p>
</li>
<li><p>对于外连接来说：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> ...</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> B <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> A <span class="keyword">ON</span> ...</span><br></pre></td></tr></table></figure>

<p>  通常，会认为 A 就是驱动表，B 就是被驱动表。但也未必。 对于外连接来说，查询优化器可能会将外连接修改为内连接，对于内连接，主从表就会不确定。</p>
</li>
</ul>
<p><strong>简单嵌套循环连接 (Simple Nested-Loop Join)</strong></p>
<p>算法相当简单，从表 A 中取出一条数据 1，遍历表 B，将匹配到的数据放到 result..以此类推，驱动表 A 中的每一条记录与被驱动表 B 的记录进行判断：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8D%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5.png" alt="简单嵌套循环连接"></p>
<p>可以看到这种方式效率是非常低的，以上述表 A 数据 100 条，表 B 数据 1000 条计算，则 A * B &#x3D; 10 万次。开销统计如下：</p>
<table>
<thead>
<tr>
<th>开销统计</th>
<th>SNLJ</th>
</tr>
</thead>
<tbody><tr>
<td>外表扫描次数</td>
<td>1</td>
</tr>
<tr>
<td>内表扫描次数</td>
<td>A</td>
</tr>
<tr>
<td>读取记录数</td>
<td>A + B * A</td>
</tr>
<tr>
<td>JOIN 比较次数</td>
<td>A * B</td>
</tr>
<tr>
<td>回表读取记录次数</td>
<td>0</td>
</tr>
</tbody></table>
<p>当然 MySQL 不会这么粗暴的区进行表的连接，所以就出现了后面的两种对 Nested-Loop Join 优化算法。</p>
<p><strong>索引嵌套循环连接 (Index Nested-Loop Join)</strong></p>
<p>Index Nested-Loop Join 其优化的思路主要是为了减少内层表数据的匹配次数，所以要求被驱动表上必须有索引才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去比较，这样极大的减少了对内层表的匹配次数。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%B4%A2%E5%BC%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5.png" alt="索引嵌套循环连接"></p>
<p>驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故 MySQL 优化器都倾向于使用记录数少的表作为驱动表。</p>
<table>
<thead>
<tr>
<th>开销统计</th>
<th>SNLJ</th>
<th>INLJ</th>
</tr>
</thead>
<tbody><tr>
<td>外表扫描次数</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>内表扫描次数</td>
<td>A</td>
<td>0</td>
</tr>
<tr>
<td>读取记录数</td>
<td>A + B * A</td>
<td>A + B(match)</td>
</tr>
<tr>
<td>JOIN 比较次数</td>
<td>A * B</td>
<td>A * Index(Height)</td>
</tr>
<tr>
<td>回表读取记录次数</td>
<td>0</td>
<td>B(match)(if possible)</td>
</tr>
</tbody></table>
<p>如果被驱动表家索引，效率是非常高的，但如果索引不是主键索引，所以还的进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高。</p>
<p><strong>块嵌套循环连接 (Block Nested-Loop Join)</strong></p>
<p>如果存在索引，那么会使用 index 的方式进行 join，如果 join 的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把驱动表的记录再加载到内存匹配，这样周而复始，大大增加了IO 的次数。为了减少被驱动表的 IO 次数，就出现了 Block Nested-Loop Join 的方式。</p>
<p>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了 join buffer 缓冲区，将驱动表 join 相关的部分数据列 (大小受 join buffer 的限制) 缓存到 join buffer 中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和 join buffer 中的所有驱动表记录进行匹配 (内存中操作)，将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</p>
<blockquote>
<p>注意：</p>
<p>这里缓存的不只是关联表的列，select 后面的列也会缓存起来。</p>
<p>在一个有 N 个 join 关联的 SQL 中会分配 N - 1 个 join buffer。所以查询的时候尽量减少不必要的字段，可以让 join buffer 中可以存放更多的列。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E5%9D%97%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5.png" alt="块嵌套循环连接"></p>
<table>
<thead>
<tr>
<th>开销统计</th>
<th>SNLJ</th>
<th>INLJ</th>
<th>BNLJ</th>
</tr>
</thead>
<tbody><tr>
<td>外表扫描次数</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>内表扫描次数</td>
<td>A</td>
<td>0</td>
<td>A * used_column_size &#x2F; join_buffer_size + 1</td>
</tr>
<tr>
<td>读取记录数</td>
<td>A + B * A</td>
<td>A + B(match)</td>
<td>A + B * (A * used_column_size &#x2F; join_buffer_size)</td>
</tr>
<tr>
<td>JOIN 比较次数</td>
<td>B * A</td>
<td>A * Index(Height)</td>
<td>B * A</td>
</tr>
<tr>
<td>回表读取记录次数</td>
<td>0</td>
<td>B(match)(if possible)</td>
<td>0</td>
</tr>
</tbody></table>
<p>参数设置：</p>
<ul>
<li><p>block_nested_loop</p>
<p>  通过 <code>show variables like &#39;%optimizer_switch%&#39;</code> 查看 <code>block_nested_loop</code> 状态。默认是开启的。</p>
</li>
<li><p>join_buffer_size</p>
<p>  驱动表能不能一次加载完，要看 join buffer 能不能存储所有的数据，默认情况下 <code>join_buffer_size=256k</code>。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%join_buffer%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> join_buffer_size <span class="operator">|</span> <span class="number">262144</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+--------+</span></span><br></pre></td></tr></table></figure>

<p>  Join_buffer_size 的最大值在 32 位系统可以申请 4G，而在 64 位操作系统下可以申请大于 4G 的 Join Buffer 空间 (64 位 Windows 除外，其大值会被截断位 4GB 并发出警告)。</p>
</li>
</ul>
<p><strong>Join 小结</strong></p>
<ul>
<li><p>整体效率比较：INLJ &gt; BNLJ &gt; SNLJ </p>
</li>
<li><p>永远用小结果集驱动大结果集 (其本质就是减少外层循环的数据数量) (小的度量单位指的是表行数 * 每行大小)</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.b, t2.<span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.b <span class="operator">=</span> t2.b) <span class="keyword">where</span> t2.id <span class="operator">&lt;=</span> <span class="number">100</span>;  # 推荐</span><br><span class="line"><span class="keyword">select</span> t1.b, t2.<span class="operator">*</span> <span class="keyword">from</span> t2 straight_join t1 <span class="keyword">on</span> (t1.b <span class="operator">=</span> t2.b) <span class="keyword">where</span> t2.id <span class="operator">&lt;=</span> <span class="number">100</span>;  # 不推荐</span><br></pre></td></tr></table></figure>
</li>
<li><p>为被驱动表匹配的条件增加索引 (减少内层表的循环匹配次数)</p>
</li>
<li><p>增大 join buffer size 的大小 (一次缓存的数据越多，那么内层包的扫表次数就越少)</p>
</li>
<li><p>减少驱动表不必要的字段查询 (字段越少，join buffer 所缓存的数据就越多)</p>
</li>
</ul>
<p><strong>Hash Join</strong></p>
<p>从 MySQL 的 8.0.20 版本开始将废弃 BNLJ，因为从 MySQL 8.0.18 版本开始就加入了 hash join 默认都会使用 hash join</p>
<ul>
<li><p>Nested Loop：</p>
<p>  对于被连接的数据子集较小的情况，Nested Loop 是个较好的选择。</p>
</li>
<li><p>Hash Join 是做大数据集连接时常用方式，优化器使用两个表中较小 (相对较小) 的表利用 Join Key 在内存中建立散列表，然后扫描较大的表并探测散列表，找出与 Hash 表匹配的行。</p>
<ul>
<li>这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。</li>
<li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高 I&#x2F;O 的性能。</li>
<li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是 Join 的重型升降机。Hash Join 只能应用于等值连接 (如 WHERE a .col1 &#x3D; b.col2)，这是由 Hash 的特点决定的。</li>
</ul>
<table>
<thead>
<tr>
<th>类别</th>
<th>Nested Loop</th>
<th>Hash Join</th>
</tr>
</thead>
<tbody><tr>
<td>使用条件</td>
<td>任何条件</td>
<td>等值连接 (&#x3D;)</td>
</tr>
<tr>
<td>相关资源</td>
<td>CPU、磁盘 I&#x2F;O</td>
<td>内存、临时空间</td>
</tr>
<tr>
<td>特点</td>
<td>当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果。</td>
<td>当缺乏索引或者索引条件模糊时，Hash Join 比 Nested Loop 有效。在数据仓库环境下，如果表的记录数多，效率高</td>
</tr>
<tr>
<td>缺点</td>
<td>当索引失去或者查询条件限制不够时，效率很低；当表的记录数多时，效率低。</td>
<td>为建立哈希表，需要大量内存。第一次的结果返回较慢。</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h4><ul>
<li>保证被驱动表的 JOIN 字段已经创建了索引</li>
<li>需要 JOIN 的字段，数据类型保持绝对一致</li>
<li>LEFT JOIN 时，选择小表作为驱动表，大表作为被驱动表。减少外层循环的次数。</li>
<li>INNER JOIN 时，MySQL 会自动将小结果集的表选为驱动表。选择相信 MySQL 优化策略。</li>
<li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</li>
<li>不建议使用子查询，建议将子查询 SQL 拆开结合程序多次查询或使用 JOIN 来代替子查询。</li>
<li>衍生表建不了索引</li>
</ul>
<h3 id="4-子查询优化"><a href="#4-子查询优化" class="headerlink" title="4. 子查询优化"></a>4. 子查询优化</h3><p>MySQL 从 4.1 版本开始支持子查询，使用子查询可以进行 SELECT 语句的嵌套查询，记一个 SELECT 查询的结果作为另一个 SELECT 语句的条件。子查询可以一次性完成很多逻辑上需要多个步骤才能完成的 SQL 操作。</p>
<p>子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子查询的执行效率不高。原因：</p>
<ul>
<li>执行子查询时，MySQL 需要为内层查询语句的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</li>
<li>子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引，索引查询性能会受到一定的影响。</li>
<li>对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</li>
</ul>
<p>在 MySQL 中，可以使用连接 (JOIN) 查询来替代子查询。连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引的话，性能就会更好。</p>
<blockquote>
<p>尽量不要使用 NOT IN 或者 NOT EXISTS，用 LEFT JOIN xxx ON xx WHERE xx IS NULL 替代。</p>
</blockquote>
<h3 id="5-排序优化"><a href="#5-排序优化" class="headerlink" title="5. 排序优化"></a>5. 排序优化</h3><p><strong>问题</strong>：在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？</p>
<p>在 MySQL 中，支持两种排序方式，分别是 FileSort 和 Index 排序。</p>
<ul>
<li>Index 排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高。</li>
<li>FileSort 排序规则一般在内存中进行排序，占用 CPU 较多。如果待排结果较大，会产生临时文件 I&#x2F;O 到磁盘进行排序的情况，效率较低。</li>
</ul>
<p><strong>优化建议</strong>：</p>
<ul>
<li>SQL 中。可以在 WHERE 字句和 ORDER BY 字句中使用索引，目的是在 WHERE 字句中避免全表扫描，在 ORDER BY 字句避免使用 FileSort 排序。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</li>
<li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。</li>
<li>无法使用 Index 时，需要对 FileSort 方式进行调优。</li>
</ul>
<p><strong>测试</strong></p>
<p>先删除 student 和 class 表创建的索引。<code>CALL proc_drop_index(&#39;mysql_test&#39;, &#39;student&#39;)</code>、<code>CALL proc_drop_index(&#39;mysql_test&#39;, &#39;class&#39;)</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 创建索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classId_name <span class="keyword">ON</span> student (age, classId, name);</span><br><span class="line"># <span class="keyword">ORDER</span> <span class="keyword">BY</span> 时不 LIMIT，索引失效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age, classId;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age, classId LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">ORDER</span> <span class="keyword">BY</span> 时顺序错误，索引失效</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classId_stuno <span class="keyword">ON</span> student (age, classId, stuno);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> classId LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> classId, `NAME` LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age, classId, stuno LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age, classId LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">ORDER</span> <span class="keyword">BY</span> 时规则不一致，索引失效 (顺序错，不索引；方向反，不索引)</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>, classId <span class="keyword">ASC</span> LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> classId <span class="keyword">DESC</span>, `NAME` <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span>, classId <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>, classId <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># 无过滤，不索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> classId;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> classId, `NAME`;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> classId <span class="operator">=</span> <span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> classId <span class="operator">=</span> <span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">INDEX a_b_c(a, b, c)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 能使用索引最左前缀</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a, b</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a, b, c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">DESC</span>, B <span class="keyword">DESC</span>, c <span class="keyword">DESC</span></span><br><span class="line"></span><br><span class="line">如果 <span class="keyword">WHERE</span> 使用索引的最左前缀定义为常量，则 <span class="keyword">order</span> <span class="keyword">by</span> 能使用索引</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">AND</span> b<span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">AND</span> b <span class="operator">&gt;</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c</span><br><span class="line"></span><br><span class="line">不能使用索引进行排序</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">ASC</span>, b <span class="keyword">DESC</span>, c <span class="keyword">DESC</span>	# 排序不一致</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> g <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c		# 丢失 a 索引</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> c 		# 丢失 b 索引</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> a, d		# d 不是索引的一部分</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="keyword">IN</span> (...) <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c		# 对于排序来说，多个相等条件也是范围查询</span><br></pre></td></tr></table></figure>

<p><strong>实战</strong></p>
<p>清空索引。查询年龄为 30 岁的，且学生编号小雨 101000 的学生，按用户名称排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span> <span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `NAME`; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>     <span class="number">3.33</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+</span></span><br></pre></td></tr></table></figure>

<p>结果是 type 为 ALL，Extra 还出现了 Using FIleSort，都是最坏的情况。所以必须优化。</p>
<p><strong>方案一：为了去掉 filesort 可以把所有建成</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_name <span class="keyword">ON</span> student(age, NAME);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span> <span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `NAME`; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+--------------+---------+-------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+--------------+---------+-------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_age_name  <span class="operator">|</span> idx_age_name <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> const <span class="operator">|</span> <span class="number">18544</span> <span class="operator">|</span>    <span class="number">33.33</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+--------------+---------+-------+-------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<p><strong>方案二：尽量让 WHERE 的过滤条件和排序使用上索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 建立一个三个字段的组合索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_stuno_name <span class="keyword">ON</span> student (age, stuno, NAME);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span> <span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `NAME`; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------------------------+--------------------+---------+------+------+----------+---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys                   <span class="operator">|</span> key                <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------------------------+--------------------+---------+------+------+----------+---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_age_name,idx_age_stuno_name <span class="operator">|</span> idx_age_stuno_name <span class="operator">|</span> <span class="number">9</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span>; <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------------------------+--------------------+---------+------+------+----------+---------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>现在发现 Using FileSort 依然存在，索引 name 并没有使用到索引，而且 type 还是 range，光看字面其实并不美好。原因是，因为 stuno 是一个范围过滤，所以索引后面的字段不会再使用索引了。</p>
<p>结果竟然有 filesort 的 SQL 运行速度，超过了已经优化掉 filesort 的 SQL，而且快了很多，几乎一瞬间就出现了结果。</p>
<p>原因：所有的排序都是在条件过滤之后才执行的。所以，如果条件过滤掉大部分数据的话，剩下几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序，但实际提升性能很有限。相对 stuno &lt; 101000 这个条件，如果没有用到索引的话，要对几万条的数据进行扫描，这时非常消耗性能的，索引放在这个字段上性价比最高，是最优选择。</p>
<blockquote>
<p>结论：</p>
<ul>
<li>两个索引同时存在，MySQL 自动选择最优方案。 (对于这个例子，MySQL 选择 idx_age_stuno_name)。但是，随着数据量的变化 ，选择的索引也会随之变化的。</li>
<li>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</li>
</ul>
</blockquote>
<p><strong>FileSort 算法</strong></p>
<p>排序的字段如果不在索引列上，则 FileSort 会有两种算法：双路排序和单路排序</p>
<ul>
<li><p>双路排序 (慢)</p>
<p>  MySQL 4.1 之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据，读取行指针和 order by 列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。从磁盘去排序字段，在 buffer 进行排序，再从磁盘去其他字段。取一批数据，要对磁盘进行两次扫描，总所周知，IO 是很耗时的，索引在 MySQL 4.1 之后，出现了第二种改进的算法，就是单路排序。</p>
</li>
<li><p>单路排序 (快)</p>
<p>  从磁盘读取查询需要的所有列，按照order by 列在 buffer 对他们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。</p>
</li>
</ul>
<p><strong>结果及引申出的问题</strong></p>
<ul>
<li>由于单路是后出，总体而言好过双路</li>
<li>但是用单路有问题<ul>
<li>在 sort_buffer 中，单路比多路要多占用很多空间，因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了 sort_buffer 的容量，导致每次只能取 sort_buffer 容量大小的数据，进行排序 (创建 tmp 文件，多路合并)，排完再取 sort_buffer 容量大小，再排……从而多次 I&#x2F;O。</li>
<li>单路本来想省一次 I&#x2F;O 操作，反而 导致了大量的 I&#x2F;O 操作，反而得不偿失。</li>
</ul>
</li>
</ul>
<p><strong>优化策略</strong></p>
<ul>
<li><p>尝试提高 sort_buffer_size</p>
<p>  不管用哪种算法，提高这个参数都会提高效率，要根据系统的能力去提高，因为这个参数是针对每个进程 (connection) 的 1M-8M 之间调整。MySQL 5.7，InnoDB 存储引擎默认值是 1048576 字节，1MB。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%sort_buffer_size%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name           <span class="operator">|</span> <span class="keyword">Value</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> innodb_sort_buffer_size <span class="operator">|</span> <span class="number">1048576</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> myisam_sort_buffer_size <span class="operator">|</span> <span class="number">8388608</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sort_buffer_size        <span class="operator">|</span> <span class="number">262144</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+---------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>尝试提高 max_length_for_sort_data</p>
<p>  提高这个参数，会增加用改进算法的概率。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%max_length_for_sort_data%&#x27;</span>;		# 默认 <span class="number">1024</span> 字节</span><br></pre></td></tr></table></figure>

<p>  但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大，明显症状是高的磁盘 I&#x2F;O 活动和低的处理器使用率。如果需要返回的列的总长度大于 max_length_for_sort_data，使用双路算法，否则使用单路算法。1024-8192 字节之间调整。</p>
</li>
<li><p>ORDER BY 时 SELECT * 是一个大忌。最好只 QUERY 需要的字段。</p>
<p>  当 QUERY 的字段大小总和小于 max_length_for_sort_data，而且排序字段不是 TEXT｜BLOB 类型时，会用改进后的算法——单路排序，否则用老算法——多路排序。</p>
<p>  两种算法的数据都有可能超出 sort_buffer_size 的容量，超出之后，会创建 tmp 文件进行合并排序，导致多次 I&#x2F;O，但是用单路排序算法的风险风大一些，所以要提高 sort_buffer_size。</p>
</li>
</ul>
<h3 id="6-GROUP-BY-优化"><a href="#6-GROUP-BY-优化" class="headerlink" title="6.GROUP BY 优化"></a>6.GROUP BY 优化</h3><ul>
<li>group by 使用索引的原则几乎跟 order by 一致，group by 即使没有过滤条件使用到索引，也可以直接使用索引。</li>
<li>group by 先排序再分组，遵照索引建的最佳左前缀原则</li>
<li>当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置</li>
<li>where 效率高于 having，能写在 where 限定的条件就不要写在 having 中了</li>
<li>减少使用 order by，和业务沟通能不排序就不排序，或将排序当道程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费 CPU，数据库的 CPU 资源是极其宝贵的</li>
<li>包含了 ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在 1000 行以内，否则 SQL 会很慢</li>
</ul>
<h3 id="7-优化分页查询"><a href="#7-优化分页查询" class="headerlink" title="7. 优化分页查询"></a>7. 优化分页查询</h3><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000，10，此时需要 MySQL 排序前 2000010 记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LIMIT <span class="number">2000000</span>, <span class="number">10</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------+</span></span><br></pre></td></tr></table></figure>

<p><strong>优化思路一</strong></p>
<p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student t, (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">2000000</span>, <span class="number">10</span>) a <span class="keyword">WHERE</span> t.id <span class="operator">=</span> a.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+--------+---------------+---------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+--------+---------------+---------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> <span class="operator">&lt;</span>derived2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> t          <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> a.id <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> student    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+--------+---------------+---------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<p><strong>优化思路二</strong></p>
<p>该方案适用于主键自增的表，可以把 LIMIT 查询转换成某个位置的查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">2000000</span> LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<h3 id="8-优先考虑覆盖索引"><a href="#8-优先考虑覆盖索引" class="headerlink" title="8. 优先考虑覆盖索引"></a>8. 优先考虑覆盖索引</h3><h4 id="8-1-什么是覆盖索引"><a href="#8-1-什么是覆盖索引" class="headerlink" title="8.1 什么是覆盖索引"></a>8.1 什么是覆盖索引</h4><ul>
<li><p>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。<strong>一个索引包含了满足查询结果的数据就叫做覆盖索引</strong>。</p>
</li>
<li><p>非聚簇复合索引的一种方式，它包括在查询里的 SELECT、JOIN 和 WHERE 子句用到的所有列 (即建索引的字段正好是覆盖查询条件中所涉及的字段)。简单说就是，<code>索引列 + 主键</code> 包含 <code>SELECT 到 FROM 之间查询的列</code>。</p>
<p>举例：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 删除原有索引并创建新索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_name <span class="keyword">ON</span> student(age, `NAME`);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&lt;&gt;</span> <span class="number">20</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_age_name  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> age, `NAME` <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&lt;&gt;</span> <span class="number">20</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> idx_age_name  <span class="operator">|</span> idx_age_name <span class="operator">|</span> <span class="number">68</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> `NAME` <span class="keyword">LIKE</span> <span class="string">&#x27;%abc&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">11.11</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> id, age <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> `NAME` <span class="keyword">LIKE</span> <span class="string">&#x27;%abc&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_age_name <span class="operator">|</span> <span class="number">68</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">11.11</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+</span></span><br></pre></td></tr></table></figure>

<h4 id="8-2-覆盖索引的利弊"><a href="#8-2-覆盖索引的利弊" class="headerlink" title="8.2 覆盖索引的利弊"></a>8.2 覆盖索引的利弊</h4><p>好处：</p>
<ul>
<li><p>避免 InnoDB 表进行索引的二次查询 (回表)</p>
<p>  InnoDB 是以聚簇索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键值后，还需通过主键进行二次查询才能获取真实所需要的数据。在覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询，减少了 IO 操作，提升了查询效率。</p>
</li>
<li><p>可以把随机 IO 变成顺序 IO 加快查询效率</p>
<p>  由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少得多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</p>
</li>
</ul>
<p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段</strong>。</p>
<p>弊端：</p>
<ul>
<li>索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务 DBA，或者成为业务数据架构师的工作。</li>
</ul>
<h3 id="9-如何给字符串添加索引"><a href="#9-如何给字符串添加索引" class="headerlink" title="9. 如何给字符串添加索引"></a>9. 如何给字符串添加索引</h3><h3 id="10-索引下推"><a href="#10-索引下推" class="headerlink" title="10. 索引下推"></a>10. 索引下推</h3><h4 id="10-1-使用前后对比"><a href="#10-1-使用前后对比" class="headerlink" title="10.1 使用前后对比"></a>10.1 使用前后对比</h4><p>Index Condition Pushdown (ICP) 是 MySQL 5.6 中新特性，是一种在存储引擎层使用过滤数据的优化方式。</p>
<ul>
<li>如果没有 ICP，存储引擎会遍历索引以定位基表中的行，并将它们返回给 MySQL 服务器，由 MySQL 服务器评估 WHERE 后面的条件是否保留行。</li>
<li>启用 ICP 后，如果部分 WHERE 条件可以仅使用索引中的列进行筛选，则 MySQL 服务器会把这部分 WHERE 条件放到存储引擎筛选。然后，存储引擎通过使用索引条目来筛选数据，并且只有在满足这一条件时才从表中读取行。<ul>
<li>好处：ICP 可以减少存储引擎必须访问基表的次数和 MySQL 服务器必须访问存储引擎的次数。</li>
<li>但是，ICP 的加速效果取决于在存储引擎内通过 ICP 筛选掉的数据的比例。</li>
</ul>
</li>
</ul>
<h4 id="10-2-ICP-的开启-x2F-关闭"><a href="#10-2-ICP-的开启-x2F-关闭" class="headerlink" title="10.2 ICP 的开启&#x2F;关闭"></a>10.2 ICP 的开启&#x2F;关闭</h4><ul>
<li>默认情况下启用索引条件下推。可以通过设置系统变量 optimizer_switch 控制：<code>index_condition_pushdown</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 打开索引下推</span><br><span class="line"><span class="keyword">SET</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;index_condition_pushdown=on&#x27;</span>;</span><br><span class="line"># 关闭索引下推</span><br><span class="line"><span class="keyword">SET</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;index_condition_pushdown=off&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>当使用索引条件下推时，EXPLAIN 语句输出结果中 Extra 列内容显示为 <code>Using index condition</code>。</li>
</ul>
<h4 id="10-3-ICP-使用案例"><a href="#10-3-ICP-使用案例" class="headerlink" title="10.3 ICP 使用案例"></a>10.3 ICP 使用案例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> people (</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">	zipcode <span class="type">VARCHAR</span> ( <span class="number">20</span> ) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	firstname <span class="type">VARCHAR</span> ( <span class="number">20</span> ) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	lastname <span class="type">VARCHAR</span> ( <span class="number">20</span> ) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	address <span class="type">VARCHAR</span> ( <span class="number">50</span> ) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY ( id ),</span><br><span class="line">KEY zip_last_first ( zipcode, lastname, firstname ) </span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB AUTO_INCREMENT <span class="operator">=</span> <span class="number">5</span> <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb3 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_bin;</span><br><span class="line"></span><br><span class="line"># 插入数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> people <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;000001&#x27;</span>, <span class="string">&#x27;三&#x27;</span>, <span class="string">&#x27;赵&#x27;</span>, <span class="string">&#x27;北京市&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;000002&#x27;</span>, <span class="string">&#x27;四&#x27;</span>, <span class="string">&#x27;钱&#x27;</span>, <span class="string">&#x27;重庆市&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;000003&#x27;</span>, <span class="string">&#x27;五&#x27;</span>, <span class="string">&#x27;孙&#x27;</span>, <span class="string">&#x27;南京市&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;000004&#x27;</span>, <span class="string">&#x27;六&#x27;</span>, <span class="string">&#x27;李&#x27;</span>, <span class="string">&#x27;天津市&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 知道一个人邮编，但是不确定这个人的姓氏</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> people <span class="keyword">WHERE</span> zipcode <span class="operator">=</span> <span class="string">&#x27;000001&#x27;</span> <span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span> <span class="keyword">AND</span> address <span class="keyword">LIKE</span> <span class="string">&#x27;%北京市%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys  <span class="operator">|</span> key            <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> people <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> zip_last_first <span class="operator">|</span> zip_last_first <span class="operator">|</span> <span class="number">63</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">25.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span>; <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>执行查看 SQL 的查询计划，Extra 中显示了 Using index condition，这表示使用了索引下推。另外，Using where 表示条件中包含需要过滤的非索引列数据，即 <code>address LIKE &#39;%北京市%&#39;</code> 这个条件并不是索引列，需要在服务端过滤掉。如果不想出现 Using where，把 <code>address LIKE &#39;%北京市%&#39;</code> 去掉即可。</p>
<h4 id="10-4-开启和关闭-ICP-的性能对比"><a href="#10-4-开启和关闭-ICP-的性能对比" class="headerlink" title="10.4 开启和关闭 ICP 的性能对比"></a>10.4 开启和关闭 ICP 的性能对比</h4><p>创建存储过程，主要目的就是插入很多 000001 的数据，这样查询的时候为了在存储引擎层做过滤，减少 IO，也为了减少缓冲池 (缓存数据页，没有 IO) 的作用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_people(max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	REPEAT</span><br><span class="line">	<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> people (zipcode, firstname, lastname, address) <span class="keyword">VALUES</span> (<span class="string">&#x27;000001&#x27;</span>, <span class="string">&#x27;六&#x27;</span>, <span class="string">&#x27;周&#x27;</span>, <span class="string">&#x27;天津市&#x27;</span>);</span><br><span class="line">	UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">	<span class="keyword">END</span> REPEAT;</span><br><span class="line">	<span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 调用存储过程</span><br><span class="line"><span class="keyword">CALL</span> insert_people(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line"># 打开 profiling</span><br><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># 执行 <span class="keyword">SQL</span> 语句，此时默认打开索引下推</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> people <span class="keyword">WHERE</span> zipcode <span class="operator">=</span> <span class="string">&#x27;000001&#x27;</span> <span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 再次执行 <span class="keyword">SQL</span> 语句，不使用索引下推</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ no_icp (people) */</span> <span class="operator">*</span> <span class="keyword">FROM</span> people <span class="keyword">WHERE</span> zipcode <span class="operator">=</span> <span class="string">&#x27;000001&#x27;</span> <span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 查看当前会话所产生的所有 profiles</span><br><span class="line"><span class="keyword">SHOW</span> profiles;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Query_ID <span class="operator">|</span> Duration   <span class="operator">|</span> Query                                                                                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span> <span class="number">0.17796400</span> <span class="operator">|</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> people <span class="keyword">WHERE</span> zipcode <span class="operator">=</span> <span class="string">&#x27;000001&#x27;</span> <span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span>                         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span> <span class="number">1.06563900</span> <span class="operator">|</span> <span class="keyword">SELECT</span> <span class="comment">/*+ no_icp (people) */</span> <span class="operator">*</span> <span class="keyword">FROM</span> people <span class="keyword">WHERE</span> zipcode <span class="operator">=</span> <span class="string">&#x27;000001&#x27;</span> <span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+------------------------------------------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> profile <span class="keyword">FOR</span> query <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Status                         <span class="operator">|</span> Duration <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> starting                       <span class="operator">|</span> <span class="number">0.000193</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Executing hook <span class="keyword">on</span> transaction  <span class="operator">|</span> <span class="number">0.000006</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> starting                       <span class="operator">|</span> <span class="number">0.000015</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> checking permissions           <span class="operator">|</span> <span class="number">0.000011</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Opening tables                 <span class="operator">|</span> <span class="number">0.000314</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> init                           <span class="operator">|</span> <span class="number">0.000011</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">System</span> lock                    <span class="operator">|</span> <span class="number">0.000019</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> optimizing                     <span class="operator">|</span> <span class="number">0.000024</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> statistics                     <span class="operator">|</span> <span class="number">0.000226</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> preparing                      <span class="operator">|</span> <span class="number">0.000046</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> executing                      <span class="operator">|</span> <span class="number">0.177033</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">end</span>                            <span class="operator">|</span> <span class="number">0.000014</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query <span class="keyword">end</span>                      <span class="operator">|</span> <span class="number">0.000003</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> waiting <span class="keyword">for</span> handler <span class="keyword">commit</span>     <span class="operator">|</span> <span class="number">0.000008</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> closing tables                 <span class="operator">|</span> <span class="number">0.000008</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> freeing items                  <span class="operator">|</span> <span class="number">0.000021</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cleaning up                    <span class="operator">|</span> <span class="number">0.000012</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> profile <span class="keyword">FOR</span> query <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Status                         <span class="operator">|</span> Duration <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> starting                       <span class="operator">|</span> <span class="number">0.001877</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Executing hook <span class="keyword">on</span> transaction  <span class="operator">|</span> <span class="number">0.000012</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> starting                       <span class="operator">|</span> <span class="number">0.000015</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> checking permissions           <span class="operator">|</span> <span class="number">0.000008</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Opening tables                 <span class="operator">|</span> <span class="number">0.000120</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> init                           <span class="operator">|</span> <span class="number">0.000007</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">System</span> lock                    <span class="operator">|</span> <span class="number">0.000015</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> optimizing                     <span class="operator">|</span> <span class="number">0.000030</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> statistics                     <span class="operator">|</span> <span class="number">0.000195</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> preparing                      <span class="operator">|</span> <span class="number">0.000041</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> executing                      <span class="operator">|</span> <span class="number">1.063250</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">end</span>                            <span class="operator">|</span> <span class="number">0.000015</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query <span class="keyword">end</span>                      <span class="operator">|</span> <span class="number">0.000004</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> waiting <span class="keyword">for</span> handler <span class="keyword">commit</span>     <span class="operator">|</span> <span class="number">0.000008</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> closing tables                 <span class="operator">|</span> <span class="number">0.000006</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> freeing items                  <span class="operator">|</span> <span class="number">0.000025</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cleaning up                    <span class="operator">|</span> <span class="number">0.000011</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br></pre></td></tr></table></figure>

<p>多次测试效率对比来看，使用 ICP 优化的查询效率会好一些。这里建议多存储一些数据效果更明显。</p>
<h4 id="10-5-ICP-的使用条件"><a href="#10-5-ICP-的使用条件" class="headerlink" title="10.5 ICP 的使用条件"></a>10.5 ICP 的使用条件</h4><ul>
<li>如果表访问的类型为 range、ref、eq_ref 和 ref_or_null 可以使用 ICP</li>
<li>ICP 可以用于 InnoDB 和 MyISAM 表，包括分区表 InnoDB 和 MyISAM 表</li>
<li>对于 InnoDB 表，ICP 仅用于二级索引。ICP 的目标是减少全行读取次数，从而减少 I&#x2F;O 操作。</li>
<li>当 SQL 使用覆盖索引时，不支持 ICP。因为这种情况下使用 ICP 不会减少 I&#x2F;O。</li>
<li>相关子查询的条件不能使用 ICP。</li>
</ul>
<h3 id="11-其他查询优化策略"><a href="#11-其他查询优化策略" class="headerlink" title="11. 其他查询优化策略"></a>11. 其他查询优化策略</h3><h4 id="11-1-EXISTS-和-IN-的区分"><a href="#11-1-EXISTS-和-IN-的区分" class="headerlink" title="11.1 EXISTS 和 IN 的区分"></a>11.1 EXISTS 和 IN 的区分</h4><p><strong>问题</strong>：</p>
<p>不太理解那种情况下应该使用 EXISTS，哪种情况下应该用 IN。选择的标准是看能否使用表的索引吗？</p>
<p><strong>回答</strong>：</p>
<p>索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为小表驱动大表。在这种方式下效率是最高的。</p>
<p>比如下面这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> cc <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> B);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> B <span class="keyword">WHERE</span> B.cc <span class="operator">=</span> A.cc);</span><br></pre></td></tr></table></figure>

<p>当 A 小于 B 时，用 EXISTS。因为 EXISTS 的实现，相当于外表循环，实现的逻辑类似于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> A</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> B</span><br><span class="line">		if j.cc <span class="operator">=</span><span class="operator">=</span> i.cc <span class="keyword">then</span> ...</span><br></pre></td></tr></table></figure>

<p>当 B 小于 A 时用 IN，因为实现的逻辑类似于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> B</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> A</span><br><span class="line">		if j.cc <span class="operator">=</span><span class="operator">=</span> i.cc <span class="keyword">then</span> ...</span><br></pre></td></tr></table></figure>

<p>哪个表小就用哪个表来驱动，A 表小就用 EXISTS，B 表小就用 IN。</p>
<h4 id="11-2-COUNT-与-COUNT-具体字段-效率"><a href="#11-2-COUNT-与-COUNT-具体字段-效率" class="headerlink" title="11.2 COUNT(*) 与 COUNT(具体字段) 效率"></a>11.2 COUNT(*) 与 COUNT(具体字段) 效率</h4><p><strong>问提</strong>：</p>
<p>在 MySQL 中统计数据表的行数，可以使用三种方式：<code>SELECT COUNT(*)</code>、<code>SELECT COUNT(1)</code> 和 <code>SELECT COUNT(具体字段)</code>，使用这三者之间的查询效率是怎样的？</p>
<p><strong>回答</strong>：</p>
<p>前提：如果要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才可以。</p>
<ul>
<li>COUNT(*) 和 COUNT(1) 都是对所有结果进行 COUNT，COUNT(*) 和 COUNT(1) 本质上并没有区别 (二者执行时间可能略有差别，不过还是可以把它两的执行效率看成是相等的)。如果有 WHERE 字句，则是对所有符合筛选条件的数据行进行统计；如果没有 WHERE 字句，则是对数据表的数据行数进行统计。</li>
<li>如果是 MyISAM 存储引擎，统计数据表的行数只需要 O(1) 的复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息存储了 row_count 值，而一致性则由表级锁来保证。如果是 InnoDB 存储引擎，因为 InnoDB 支持事物，采用行级锁和 MVCC 机制，所以无法像 MyISAM 一样，维护一个 row_count 变量，因此需要采用扫描全表，是 O(n) 的复杂度，进行循环 + 计数的方式来完成统计。</li>
<li>在 InnoDB 存储引擎中，如果采用 COUNT(具体字段) 来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引 (非聚簇索引)。对于 COUNT(*) 和 COUNT(1) 来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。如果有多个二级索引，会使用 key_len 小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</li>
</ul>
<h4 id="11-3-关于-SELECT"><a href="#11-3-关于-SELECT" class="headerlink" title="11.3 关于 SELECT(*)"></a>11.3 关于 SELECT(*)</h4><p>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用 SELECT &lt;字段列表&gt; 查询。原因：</p>
<ul>
<li>MySQL 在解析的过程中，会通过查询数据字典将 * 按序转换成所有列名，这会大大的耗费资源和时间。</li>
<li>无法使用覆盖索引。</li>
</ul>
<h4 id="11-4-LIMIT-1-对优化的影响"><a href="#11-4-LIMIT-1-对优化的影响" class="headerlink" title="11.4 LIMIT 1 对优化的影响"></a>11.4 LIMIT 1 对优化的影响</h4><p>针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上 LIMIT 1 的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p>
<p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上 LIMIT 1 了。</p>
<h4 id="11-5-多使用-COMMIT"><a href="#11-5-多使用-COMMIT" class="headerlink" title="11.5 多使用 COMMIT"></a>11.5 多使用 COMMIT</h4><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。</p>
<p>COMMIT 所释放的资源：</p>
<ul>
<li>回滚段上用于恢复数据的信息</li>
<li>被程序语句获得的锁</li>
<li>redo &#x2F; undo log buffer 中的空间</li>
<li>管理上述三种资源中的内部花费</li>
</ul>
<h3 id="12-淘宝数据库，主键如何设计的？"><a href="#12-淘宝数据库，主键如何设计的？" class="headerlink" title="12. 淘宝数据库，主键如何设计的？"></a>12. 淘宝数据库，主键如何设计的？</h3><p>数据库的主键如何设计，大多数人的回答都会是用 8 字节的 BIGINT 做主键，而不要用 INT。(错)</p>
<p>这样的回答，只站在了数据库着一层，而没有从业务的角度思考主键。主键就是自增 ID 吗？用自增做主键，架构设计上可能连及格都拿不到。</p>
<h4 id="12-1-自增-ID-的问题"><a href="#12-1-自增-ID-的问题" class="headerlink" title="12.1 自增 ID 的问题"></a>12.1 自增 ID 的问题</h4><p>自增 ID 做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增 ID 除了简单其他都是缺点，总体来看存在以下几方面的问题：</p>
<ul>
<li><p>可靠性不高</p>
<p>  存在自增 ID 回溯的问题，这个问题直到最新版本的 MySQL 8.0 才修复</p>
</li>
<li><p>安全性不高</p>
<p>  对外暴露的接口可以非常容易猜测对应的信息。比如：&#x2F;User&#x2F;1&#x2F; 这样的接口，可以非常容易猜测用户 ID 的值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。</p>
</li>
<li><p>性能差</p>
<p>  自增 ID 的性能较差，需要在数据库服务器端生成。</p>
</li>
<li><p>交互多</p>
<p>  业务还需要额外执行一次类似 last_insert_id() 的函数才能知道刚才插入的自增值，这需要多一次的网络交互。在海量并发的系统中，多一条 SQL，就多一次性能上的开销。</p>
</li>
<li><p>局部唯一性</p>
<p>  最重要的一点，自增 ID 是局部唯一，只在当前数据库实例中唯一，而不是全剧唯一，在任意服务期间都是唯一的。对于目前分布式系统来说，这简直就是噩梦。</p>
</li>
</ul>
<h4 id="12-2-业务字段做主键"><a href="#12-2-业务字段做主键" class="headerlink" title="12.2 业务字段做主键"></a>12.2 业务字段做主键</h4><p>为了能够唯一地标识一个会员的信息，需要为会员信息表设置一个主键。考虑业务字段做主键。</p>
<table>
<thead>
<tr>
<th>cardno</th>
<th>name</th>
<th>phone</th>
<th>pid</th>
<th>address</th>
<th>sex</th>
<th>birthday</th>
</tr>
</thead>
<tbody><tr>
<td>10000001</td>
<td>张三</td>
<td>13300000001</td>
<td>1101232000000007890</td>
<td>上海</td>
<td>女</td>
<td>2000-01-02</td>
</tr>
<tr>
<td>10000002</td>
<td>李四</td>
<td>13300000002</td>
<td>1101232000000007891</td>
<td>浙江</td>
<td>男</td>
<td>1999-02-03</td>
</tr>
</tbody></table>
<ul>
<li><p>选择卡号 (cardno)</p>
<p>  会员卡号看起来比较合适，因为会员卡号不能为空，而且有唯一性，可以用来标识一条会员记录。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo.membermaster(</span><br><span class="line">	cardno <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  name TEXT,</span><br><span class="line">  phone TEXT,</span><br><span class="line">  pid TEXT,</span><br><span class="line">  address TEXT,</span><br><span class="line">  sex TEXT,</span><br><span class="line">  birthday DATETIME</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>  不同的会员卡号对应不同的会员，字段 cardno 唯一地标识某一个会员。如果都是这样，会员卡号与会员一一对应，系统是可以正常运行的。</p>
<p>  但实际情况是，会员卡号可能存在重复使用的情况。比如，张三因为工作变动搬离了原来的地址，不再到商家的门店消费了 (退还了会员卡)，于是张三就不再是这个商家门店的会员了。但是，商家不想让这个会员卡空着，就把卡号 10000001 的会员卡发给了王五。</p>
<p>  从系统设计的角度看，这个变化只是修改了会员信息表中的卡号是 10000001 这个会员信息，并不会影响到数据一致性。也就是说，修改会员卡号是 10000001 的会员信息，系统的各个模块，都会获取到修改后的会员信息，不会出现有的模块获取到修改之前的会员信息，有些模块获取到修改后的会员信息，而导致系统内部数据不一致的情况。因此，从信息系统层面上看是没问题的。</p>
<p>  但是从使用系统的业务层面来看，就有很大的问题了，会对商家造成影响。</p>
<p>  比如，有一个销售流水表 (trans)，记录了所有的销售流水明细。2020-12-01，张三在门店购买了一本书，消费了 89 元。那么，系统中就有了张三买书的流水记录，如下所示：</p>
<table>
<thead>
<tr>
<th>transactionno</th>
<th>itemnumber</th>
<th>quantity</th>
<th>price</th>
<th>salesvalue</th>
<th>cardno</th>
<th>transdate</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>89</td>
<td>89</td>
<td>10000001</td>
<td>2020-12-01</td>
</tr>
</tbody></table>
<p>  接着，查询一下2020-12-01 的会员消费记录：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.name, c.goodsname, a.quantity, a.salesvalue, a.transdate</span><br><span class="line"><span class="keyword">FROM</span> demo.trans <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">JOIN</span> demo.membermaster <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">JOIN</span> demo.goodsmaster <span class="keyword">AS</span> c</span><br><span class="line"><span class="keyword">ON</span> (a.cardno <span class="operator">=</span> b.cardno <span class="keyword">AND</span> a.itemnumber <span class="operator">=</span> c.itemnumber);</span><br></pre></td></tr></table></figure>

<p>  如果会员卡 10000001 又发给了王五，我们会更改会员信息表。到值查询时得到的结果是王五在 2020-12-01 买了一本书，消费 89 元。所以不能将会员卡好当做主键。</p>
</li>
<li><p>选择会员电话或身份证号</p>
<p>  会员电话可以做主键吗？不行的。在实际操作中，手机号也存在被运营商收回，重新发给别人用的情况。</p>
<p>  那身份证号行不行呢？好像可以，因为身份证绝不会重复，身份证号与一个人存在一一对应的关系。可问题是，身份证号属于个人隐私，顾客不一定愿意给你。要是强制要求会员必须登记身份证号，会把很多客人赶跑的。其实，客户电话也有这个问题，这也是我们在设计会员信息表的时候，允许身份证号和电话都为空的原因。</p>
<p>  <strong>所以，建议尽量不要用跟业务有关的字段做主键。毕竟，作为项目设计的技术人员，我们谁也无法预测在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现</strong>。</p>
<blockquote>
<p>经验：</p>
<p>刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高。</p>
</blockquote>
</li>
</ul>
<h4 id="12-3-淘宝的主键设计"><a href="#12-3-淘宝的主键设计" class="headerlink" title="12.3 淘宝的主键设计"></a>12.3 淘宝的主键设计</h4><p>打开自己淘宝订单，会发现每个订单号的特征。例如：1713216900604568394、1696231922773568394</p>
<p>可以发现，订单号不是自增 ID。订单号长度为 19 位，且订单号的最后 6 位都是一样的，都是568394。且订单号的前面 13 位部分是单调递增的。</p>
<p>大胆猜测，淘宝的订单 ID 设计应该是：<code>订单 ID = 时间 + 去重字段 + 用户ID后6位尾号</code>。这样的设计能做到全剧唯一，且对分布式系统查询及其友好。</p>
<h4 id="12-4-推荐的主键设计"><a href="#12-4-推荐的主键设计" class="headerlink" title="12.4 推荐的主键设计"></a>12.4 推荐的主键设计</h4><p>非核心业务：对应表的主键自增 ID，如告警、日志、监控等信息。</p>
<p>核心业务：<strong>主键设计至少应该是全局唯一且是单调递增</strong>。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能。</p>
<p>这里推荐最简单的一种主键设计：UUID</p>
<p><strong>UUID 的特点</strong>：</p>
<p>全局唯一，占用 36 字节，数据无序，插入性能差。</p>
<p><strong>认识 UUID</strong>：</p>
<ul>
<li>为什么 UUID 是全局唯一的？</li>
<li>为什么 UUID 占用 36 个字节？</li>
<li>为什么 UUID 是无序的？</li>
</ul>
<p>MySQL 数据库的 UUID 组成如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID <span class="operator">=</span> 时间 <span class="operator">+</span> UUID版本(<span class="number">16</span>字节) <span class="operator">-</span> 时钟序列(<span class="number">4</span>字节) <span class="operator">-</span> MAC地址(<span class="number">12</span>字节)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/mysqluuid.png" alt="mysql-uuid"></p>
<p><strong>为什么 UUID 是全局唯一的</strong>？</p>
<p>在 UUID 中的时间部分占用 60 位，存储的类似 TIMESTAMP 的时间戳，但表示的是从 1582-10-15 00:00:00.00 到现在的 100ns 的计数。可以看到 UUID 存储的时间精度比 TIMESTAMP 更高，时间维度发生重复的概率降低到 1&#x2F;100ns。</p>
<p>时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC 地址用于全局唯一。</p>
<p><strong>为什么 UUID 占用 36 字节</strong>？</p>
<p>UUID 根据字符串进行存储，设计时还带有无用的 “-” 字符串，因此总共需要 36 字节。</p>
<p><strong>为什么 UUID 是随机无序的呢</strong>？</p>
<p>因为 UUID 的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</p>
<p><strong>改造 UUID</strong></p>
<p>若将时间高低位互换，则时间就是单调递增的了，也就变的单调递增了。MySQL 8.0 可以更换时间低位和时间高位的存储方式，这样 UUID 就是有序的 UUID 了。</p>
<p>MySQL 8.0 还解决了 UUID 存在的空间占用的问题，除去了 UUID 字符串中无意义的 ”-“ 字符串，并且将字符串用二进制类型保存，这样存储空间降低为了 16 字节。</p>
<p>可以通过 MySQL 8.0 提供的 uuid_to_bin 函数实现上述功能，同样的，MySQL 也提供了 bin_to_uuid 函数进行转化：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@uuid</span> <span class="operator">=</span> UUID();</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@uuid</span>, uuid_to_bin(<span class="variable">@uuid</span>), uuid_to_bin(<span class="variable">@uuid</span>, <span class="literal">TRUE</span>);</span><br></pre></td></tr></table></figure>

<p><strong>通过函数 uuid_to_bin(@uuid, true) 将 UUID 转化为有序 UUID</strong>了。全局唯一 + 单调递增。</p>
<p><strong>有序 UUID 性能测试</strong></p>
<p>16 字节的有序 UUID，相比之前 8 字节的自增 ID，性能和存储空间对比究竟如何呢？</p>
<p>插入 1 亿条数据，每条数据占用 500 字节，含有 3 个二级索引，最终的结果如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E6%9C%89%E5%BA%8Fuuid%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.png" alt="有序uuid性能测试"></p>
<p>从上图可以看到插入 1 亿条数据有序 UUID 是最快的，而且在实际业务使用中有序 UUID 在业务端就可以生成。还可以进一步减少 SQL 交互次数。</p>
<p>另外，虽然有序 UUID 相比自增 ID 多了 8 个字节，但是鸡只增大了 3g 的存储空间，还可以接受。</p>
<blockquote>
<p>在当今的互联网环境中，非常不推荐自增 ID 作为主键的数据库设计。更推荐类似有序 UUID 的全局唯一的实现。</p>
<p>另外，在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。这样的主键设计就更为考验架构师的水平了。</p>
</blockquote>
<p><strong>如果不是 MySQL 8.0 怎么办</strong>？</p>
<p>手动赋值字段做主键！</p>
<p>比如，设计各个分店的会员表的主键，因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题。</p>
<p>可以在总部 MySQL 数据库中，有一个管理信息表，在这个表中添加一个字段，专门用来记录当前会员编号的最大值。</p>
<h2 id="九、数据库的设计规范"><a href="#九、数据库的设计规范" class="headerlink" title="九、数据库的设计规范"></a>九、数据库的设计规范</h2><h3 id="1-为什么需要数据库设计"><a href="#1-为什么需要数据库设计" class="headerlink" title="1. 为什么需要数据库设计"></a>1. 为什么需要数据库设计</h3><p>我们在设计数据表的时候，要考虑很多问题。比如：</p>
<ul>
<li>用户都需要什么数据？需要在数据表中保存哪些数据？</li>
<li>如何保证数据表中数据的正确性，当插入、删除、更新的时候该进行怎样的约束检查？</li>
<li>如何降低数据表的数据冗余度，保证数据表不会因为用户量的增长而迅速扩张？</li>
<li>如何让负责数据维护的人员更方便地使用数据库？</li>
<li>使用数据库的应用场景也各不相同，可以说针对不同的情况，设计出来的数据表可能千差万别。</li>
</ul>
<p>现实情况中，面临的场景：</p>
<p>当数据库运行了一段时间之后，我们才发现数据表设计得有问题。重新调整数据表的结构，就需要做数据迁移，还有可能影响程序的业务逻辑，以及网站的正常访问。</p>
<p>如果是糟糕的数据库设计可能会造成以下问题：</p>
<ul>
<li>数据冗余、信息重复，存储空间浪费</li>
<li>数据更新、插入、删除的一场</li>
<li>无法正确表示信息</li>
<li>丢失有效信息</li>
<li>程序性能差</li>
</ul>
<p>良好的数据库设计则有以下优点：</p>
<ul>
<li>节省数据的存储空间</li>
<li>能够保证数据的完整性</li>
<li>方便进行数据库应用系统的开发</li>
</ul>
<p>总之，开始设置数据库的时候，我们就需要重视数据表的设计。为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。</p>
<h3 id="2-范式"><a href="#2-范式" class="headerlink" title="2. 范式"></a>2. 范式</h3><h4 id="2-1-范式简介"><a href="#2-1-范式简介" class="headerlink" title="2.1 范式简介"></a>2.1 范式简介</h4><p><strong>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式</strong>。可以理解为，一张数据表的设计结构需要满足的某种设计标准的级别。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p>
<p>范式的英文名称是 Mormal Form，简称 NF。它是英国人 E.F.Codd 在上个世纪 70 年代提出关系数据库模型后总结出来的。范式是关系数据库理论的基础，也是我们在设计数据库结构过程中所要遵循的规则和指导方法。</p>
<h4 id="2-2-范式都包括哪些"><a href="#2-2-范式都包括哪些" class="headerlink" title="2.2 范式都包括哪些"></a>2.2 范式都包括哪些</h4><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式 (1NF)、第二范式 (2NF)、第三范式 (3NF)、巴斯-科德范式 (BCNF)、第四范式 (4NF) 和第五范式 (5NF，又称完美范式)。</p>
<p>数据库的范式设计越高阶，冗余度就越低，同时高阶的范式一定符合低阶范式的要求，满足最低要求的范式是第一范式 (1NF)。在第一范式的基础上进一步满足更多规范要求的成为第二范式 (2NF)，其余范式以此类推。一般来说，在关系型数据库设计中，最高也就遵循到 BCNF，普遍还是 3NF。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是反规范化。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E8%8C%83%E5%BC%8F.png" alt="范式"></p>
<h4 id="2-3-键和相关属性的概念"><a href="#2-3-键和相关属性的概念" class="headerlink" title="2.3 键和相关属性的概念"></a>2.3 键和相关属性的概念</h4><p>范式的定义会使用到主键和候选键，数据库中的键  (Key) 由一个或者多个属性组成。数据表中常用的几种键和属性的定义：</p>
<ul>
<li>超键：能唯一标识元组的属性集叫做超键。</li>
<li>候选键：如果超键不包括多余的属性，那么这个超键就是候选键。</li>
<li>主键：用户可以从候选键中选择一个作为主键。</li>
<li>外键：如果数据表 R1 中的某属性集不是 R1 的主键，而是另一个数据表 R2 的主键，那么这个属性集就是数据表 R1 的外键。</li>
<li>主属性：包含在任一候选键中的属性称为主属性。</li>
<li>非主属性：与主属性相对，指的是不包含在任何一个候选键中的属性。</li>
</ul>
<p>通常，我们也将候选键称之为码，把主键也称为主码。因为键可能是由多个属性组成的，针对单个属性，我们还可以用主属性和非主属性来进行区分。</p>
<p>举例：</p>
<p>这里有两个表：</p>
<p>球员表 (player)：球员编号｜ 姓名｜身份证号｜年龄｜球队编号</p>
<p>球队表 (team)：球队编号｜主教练｜球队所在地</p>
<ul>
<li>超键：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如 (球员编号) (球员编号，姓名) (身份证号，年龄) 等。</li>
<li>候选键：就是最小的超键，对于球员表来说，候选键就是 (球员编号) 或者身份证号。</li>
<li>主键：我们自己选定，也就是从候选键中选择一个，比如 (球员编号)。</li>
<li>外键：球员表中的球队编号。</li>
<li>主属性、非主属性：在球员表中，主属性是 (球员编号) (身份证号)，其他的属性 (姓名) (年龄) (球队编号) 都是非主属性。</li>
</ul>
<h4 id="2-4-第一范式-1st-NF"><a href="#2-4-第一范式-1st-NF" class="headerlink" title="2.4 第一范式 (1st NF)"></a>2.4 第一范式 (1st NF)</h4><p>第一范式主要是确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值不可再次拆分的最小数据单元。</p>
<p>我们在设计某个字段的时候，对于字段 X 来说，不能把字段 X 拆分成字段 X-1 和字段 X-2。事实上，任何的 DBMS 都会满足第一范式的要求，不会将字段进行拆分。</p>
<h4 id="2-5-第二范式-2nd-NF"><a href="#2-5-第二范式-2nd-NF" class="headerlink" title="2.5 第二范式 (2nd NF)"></a>2.5 第二范式 (2nd NF)</h4><p>第二范式要求，在满足第一范式的基础上，还要<strong>满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分</strong>。如果指导主键的所有属性的值，就可以检索到任何元组 (行) 的任何属性的任何值。(要求中的主键，其实可以拓展替换为候选键)。</p>
<blockquote>
<p>小结：第二范式 (2NF) 要求实体的属性完全依赖主关键字。如果存在不完全依赖，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与元实体之间是一对多的关系。</p>
<p>1 NF 告诉我们字段属性需要是原子性的，而 2NF 告诉我们一张表就是一个独立的对象，一张表只表达一个意思。</p>
</blockquote>
<h4 id="2-6-第三范式-3rd-NF"><a href="#2-6-第三范式-3rd-NF" class="headerlink" title="2.6 第三范式 (3rd NF)"></a>2.6 第三范式 (3rd NF)</h4><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段和主键字段直接相关，也就是说，<strong>要求数据表中的所有非主键字段不能依赖于其他非主键字段</strong>。(即，不能存在非主属性 A 依赖于非主属性 B，非主属性 B 依赖于主键 C 的情况，即存在 A→B→C 的决定关系) 通俗地讲，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。</p>
<p>这里的主键可以拓展为候选键。</p>
<blockquote>
<p>符合 3NF 后的数据模型通俗地讲，2NF 和 3NF 通常以这句话概括：“每个非主键属性依赖于主键，依赖于整个主键，并且除了主键别无他物”。</p>
</blockquote>
<h4 id="2-7-小结"><a href="#2-7-小结" class="headerlink" title="2.7 小结"></a>2.7 小结</h4><p>关于数据表的设计，有三个范式要遵循。</p>
<ul>
<li>第一范式，确保每列保持原子性。数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。</li>
<li>第二范式，确保每列都和主键完全依赖。尤其在复合主键的情况下，非主键部分不应该依赖于部分主键。</li>
<li>第三范式，确保每列都和主键列直接相关，而不是间接相关。</li>
</ul>
<p>范式的优点：数据的标准化有助于消除数据库中的数据冗余，第三范式通常被认为在性能、扩展性和数据完整性方面达到了最好的平衡。</p>
<p>范式的缺点：范式的使用，可能降低查询的效率。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要关联多张表，这不但代价昂贵，也可能使一些索引策略无效。</p>
<p>范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式的原则，通过增加少量的冗余或重复的数据来提高数据库的读性能，减少关联查询，join 表的次数，实现空间换取时间的目的。因此在实际的设计过程中要理论结合实际，灵活运用。</p>
<blockquote>
<p>范式本身没有优劣之分，只有适用场景不同。没有完美的设计，只有合适的设计，我们在数据表的设计中，还需要根据需求将范式和反范式混合使用。</p>
</blockquote>
<h3 id="3-反范式化"><a href="#3-反范式化" class="headerlink" title="3. 反范式化"></a>3. 反范式化</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p>有的时候不能简单按照规范要求设计数据表，因为有的数据看似冗余，其实对业务来说十分重要。这个时候，我们就要遵循业务优先的原则，首先满足业务需求，再尽量尽量减少冗余。</p>
<p>如果数据库中的数据量比较大，系统的 UV 和 PV 访问频次比较高，则完全按照 MySQL 的三大范式设计数据表，读数据时会产生大量的关联查询，在一定程度上会影响数据库的读性能。如果我们想对查询效率进行优化，反范式优化也是一种优化思路。此时，可以通过在数据表中增加冗余字段来提高数据库的读性能。</p>
<p><strong>规范化 vs 性能</strong></p>
<blockquote>
<ul>
<li>为满足某种商业目标，数据库性能比规范化数据库更重要</li>
<li>在数据规范化的同时，要综合考虑数据库的性能</li>
<li>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</li>
<li>通过在给定的表中插入计算列，以方便查询</li>
</ul>
</blockquote>
<h4 id="3-2-应用举例"><a href="#3-2-应用举例" class="headerlink" title="3.2 应用举例"></a>3.2 应用举例</h4><p>例如客户表和评论表，如果要查询该条评论的评论人名称，就需要关联客户表去查询客户的名称。如果经常性的去查询评论人，我们就可以在评论表中，添加评论人名称字段，就不用每次进行关联查询了。</p>
<h4 id="3-3-反范式的新问题"><a href="#3-3-反范式的新问题" class="headerlink" title="3.3 反范式的新问题"></a>3.3 反范式的新问题</h4><p>反范式可以通过空间换时间，提升查询的效率，但是反范式也会带来一些新问题：</p>
<ul>
<li>存储空间变大了</li>
<li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则数据不一致</li>
<li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常消耗系统资源</li>
<li>在数据量小的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加复杂</li>
</ul>
<h4 id="3-4-反范式的适用场景"><a href="#3-4-反范式的适用场景" class="headerlink" title="3.4 反范式的适用场景"></a>3.4 反范式的适用场景</h4><p>当冗余信息有价值或者能大幅度提高查询效率的时候，我们才会采取反范式化的优化。</p>
<ul>
<li><p>增加冗余字段的建议‘</p>
<p>  增加冗余字段一定要符合如下两个条件。只有满足这两个条件，才可以考虑增加冗余字段。</p>
<ul>
<li>这个冗余字段不需要经常进行修改</li>
<li>这个冗余字段查询的时候不可或缺</li>
</ul>
</li>
<li><p>历史快照、历史数据的需要</p>
<p>  在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的订单收货信息都属于历史快照，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</p>
<p>  反范式优化也常用在数据仓库的设计中，因为数据仓库通常存储历史数据，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p>
<p>  简单总结下数据仓库和数据库在使用上的区别：</p>
<ul>
<li>数据库设计的目的在于捕获数据，而数据仓库设计的目的在于分析数据</li>
<li>数据库对数据的增删改实时性要求强，需要存储在线的用户数据，而数据仓库存储的一般是历史数据</li>
<li>数据库设计需要尽量避免冗余，单位了提高查询效率也允许一定的冗余度，而数据仓库在设计上更偏向采用反范式设计。</li>
</ul>
</li>
</ul>
<h3 id="4-BCNF-巴斯范式"><a href="#4-BCNF-巴斯范式" class="headerlink" title="4. BCNF (巴斯范式)"></a>4. BCNF (巴斯范式)</h3><p>人们在 3NF 的基础上进行了改进，提出了巴斯范式 (BCNF)，也叫做巴斯-科德范式 (Boyce-Codd Normal Form)。BCNF 被认为没有新的设计规范加入，只是对第三范式中设计规范要求更强，使得数据库冗余度更小。所以，称为是修正的第三范式，或扩充的第三范式，BCNF 不被称为第四范式。</p>
<p>若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到 BC 范式。一般来说，一个数据库设计符合 3NF 或 BCNF 就可以了。</p>
<h3 id="5-第四范式"><a href="#5-第四范式" class="headerlink" title="5. 第四范式"></a>5. 第四范式</h3><p>多值依赖的概念：</p>
<ul>
<li>多值依赖即属性之间的一对多关系，记为 K→→A。</li>
<li>函数依赖事实上是单值依赖，所以不能表达属性值之间的一对多关系。</li>
<li>平凡的多值依赖：全集 U &#x3D; K + A，一个 K 可以对应于多个 A，即 K→→A。此时整个表就是一组一对多关系。</li>
<li>非平凡的多值依赖：全集 U &#x3D; K + A + B，一个 K 可以对应于多个 A，也可以对应于多个 B，A 与 B 互相独立，即 K→→A，K→→B。整个表有多组一对多关系，且有：“一”部分是相同的属性集合，“多”部分是互相独立的属性集合。</li>
</ul>
<p>第四范式即在满足巴斯-科德范式 (BCNF) 的基础上，消除非平凡且非函数依赖的多值依赖 (即把同一表内的多对多关系删除)。</p>
<h3 id="6-第五范式"><a href="#6-第五范式" class="headerlink" title="6. 第五范式"></a>6. 第五范式</h3><p>除了第四范式外，还有更高级的第五范式 (又称完美范式) 和域键范式 (DKNF)。</p>
<p>在满足第四范式 (4NF) 的基础上，消除不是由候选键所蕴含的连接依赖。如果关系模式 R 中的每一个连接依赖均由 R 的候选键所隐含，则称此关系模式符合第五范式。</p>
<p>函数依赖是多值依赖的一种特殊的情况，而多值依赖实际上依赖的一种特殊情况。但连接依赖不像函数依赖和多值依赖可以由语义直接导出，而是在关系连接运算时才反映出来。存在连接依赖的关系模式仍可能遇到数据冗余及插入、修改、删除异常等问题。</p>
<p>第五范式处理的是无损连接问题，这个范式基本没有任何实际意义，因为无损连接很少出现，而且难以察觉。而域键范式试图定义一个终极范式，该范式考虑所有的依赖和约束类型，但是实际价值也是最小的，只存在理论研究中。</p>
<h3 id="7-ER-模型"><a href="#7-ER-模型" class="headerlink" title="7. ER 模型"></a>7. ER 模型</h3><p>数据库设计是牵一发而动全身的。那有没有什么办法提前看到数据库的全貌呢？比如需要哪些数据表、数据表中应该有哪些字段，数据表与数据表之间有什么关系、通过什么字段进行连接，等等。这样我们才能进行整体的梳理和设计。</p>
<p>其实，ER 模型就是一个这样的工具。ER 模型也叫作实体关系模型，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。<strong>在开发基于数据库的信息系统的设计阶段，通常使用 ER 模型来描述信息需求和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库</strong>。</p>
<h4 id="7-1-ER-模型包括哪些要素？"><a href="#7-1-ER-模型包括哪些要素？" class="headerlink" title="7.1 ER 模型包括哪些要素？"></a>7.1 ER 模型包括哪些要素？</h4><p><strong>ER 模型中有三个要素，分别是实体、属性和关系</strong>。</p>
<p><strong>实体</strong>，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用矩形来表示。实体分为两类，分别是强实体和弱实体。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。</p>
<p><strong>属性</strong>，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用 椭圆形来表示。</p>
<p><strong>关系</strong>，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模型中用菱形来表示。</p>
<p>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，<strong>可以独立存在的是实体，不可再分的是属性</strong>。也就是说，属性不能包含其他属性。</p>
<h4 id="7-2-关系的类型"><a href="#7-2-关系的类型" class="headerlink" title="7.2 关系的类型"></a>7.2 关系的类型</h4><p>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是一对一、一对多、多对多。</p>
<p>一对一：指实体之间的关系一一对应的，比如个人与身份证信息之间的关系就是一对一的关系。一个人只能有一个身份证信息，一个身份证信息也只属于一个人。</p>
<p>一对多：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体。比如说，我们新建一个班级表，而每个班级都有多个学生，每个学生则对应一个班级，班级对学生就是一对多的关系。</p>
<p>多对多：指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购商品。再比如一个选课表，有许多科目，每个科目有很多学生选，而每个学生又可以选择多个科目，这就是多对多的关系。</p>
<h4 id="7-3-建模分析"><a href="#7-3-建模分析" class="headerlink" title="7.3 建模分析"></a>7.3 建模分析</h4><p>ER 模型看起来比较麻烦，但是对我们把控项目整体非常重要。如果你只是开发一个小应用，或许简单设计几个表够用了，一旦要设计有一定规模的应用，在项目的初始阶段，建立完整的 ER 模型就非常关键了。开发应用项目的实质，其实就是建模。</p>
<p>我们设计的案例是电商业务，由于电商业务太过庞大且复杂，所以我们做了业务简化，比如针对 SKU (StockKeepingUnit，库存量单位) 和 SPU (Standard Product Unit，标准化产品单元) 的含义上，我们直接使用了 SKU，并没有提及 SPU 的概念。本次电商业务涉及总共有 8 个实体：</p>
<ul>
<li>地址实体</li>
<li>用户实体</li>
<li>购物车实体</li>
<li>评论实体</li>
<li>商品实体</li>
<li>商品分类实体</li>
<li>订单实体</li>
<li>订单详情实体</li>
</ul>
<p>其中，用户和商品分类是强实体，因为他们不需要依赖其他任何实体。而其他属于弱实体，因为他们虽然都可以独立存在，但是他们都依赖用户这个实体，因此都是弱实体。知道了这些要素，我们就可以给电商业务创建 ER 模型了，如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1ER%E6%A8%A1%E5%9E%8B-1.png" alt="电商业务ER模型-1"></p>
<p>在这个图中，地址和用户之间的添加关系，是一对多的关系，而商品和商品详情是一对一的关系，商品和订单是多对多的关系。这个 ER 模型，包括了 8 个实体之间的 8 种关系。</p>
<ul>
<li>用户可以在电商平台添加多个地址；</li>
<li>用户只能拥有一个购物车；</li>
<li>用户可以生成多个订单；</li>
<li>用户可以发表多条评论；</li>
<li>一件商品可以有多条评论；</li>
<li>每一个商品分类包含多种商品；</li>
<li>一个订单可以包含多个商品，一个商品可以在多个订单里。</li>
<li>订单中又包含多个订单详情，因为一个订单中可能包含不同种类的商品。</li>
</ul>
<h4 id="7-4-ER-模型的细化"><a href="#7-4-ER-模型的细化" class="headerlink" title="7.4 ER 模型的细化"></a>7.4 ER 模型的细化</h4><p>有了这个 ER 模型，我们就可以从整体上理解电商的业务了。刚刚的 ER 模型展示了电商业务的框架，但是只包括了订单，地址，用户，购物车，评论，商品，商品分类和订单详情这八个实体，以及它们之间的关系，还不能对应到具体的表，以及表于表之间的关联。我们需要把属性加上，用椭圆来表示，这样我们得到的 ER 模型就更加完整了。</p>
<p>因此，我们需要进一步去设计一下这个 ER 模型的各个局部，也就是细化下电商的业务流程，然后把它们综合到一起，形成一个完整的 ER 模型。这样可以帮助我们理清数据库的设计思路。</p>
<p>接下来分析一下各个实体都有哪些属性，如下所示。</p>
<ul>
<li><strong>地址实体</strong>包括用户编号、省、市、地区、收件人、联系电话、是否是默认地址。</li>
<li><strong>用户实体</strong>包括用户编号、用户名称、昵称、用户密码、手机号、邮箱、头像、用户级别。</li>
<li><strong>购物车实体</strong>包括购物车编号、用户编号、商品编号、商品数量、图片文件 URL。</li>
<li><strong>订单实体</strong>包括订单编号、收货人、收件人电话、总金额、用户编号、付款方式、送货地址、下单时间。</li>
<li><strong>订单详情实体</strong>包括订单详情编号、订单编号、商品名称、商品编号、商品数量。</li>
<li><strong>商品实体</strong>包括商品编号、价格、商品名称、分类编号、是否销售、规格、颜色。</li>
<li><strong>评论实体</strong>包括评论 ID、评论内容、评论时间、用户编号、商品编号。</li>
<li><strong>商品分类实体</strong>包括类别编号、类别名称、父类别编号。</li>
</ul>
<p>这样细分之后，我们就可以重新设计电商业务了，ER 模型如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1ER%E6%A8%A1%E5%9E%8B-2.png" alt="电商业务ER模型-2"></p>
<h4 id="7-5-ER-模型图转换成数据表"><a href="#7-5-ER-模型图转换成数据表" class="headerlink" title="7.5 ER 模型图转换成数据表"></a>7.5 ER 模型图转换成数据表</h4><p>通过绘制 ER 模型，我们已经理清了业务逻辑，现在，我们就要进行非常重要的一步了：把绘制好的 ER 模型，转换成具体的数据表，下面介绍下转换的原则：</p>
<ul>
<li>一个实体通常转换成一个数据表；</li>
<li>一个多对多的关系，通常也转换成一个数据表；</li>
<li>一个一对一或者一对多的关系，往往通过表的外键来表达，而不是设计一个新的数据表；</li>
<li>属性转换成表的字段。</li>
</ul>
<p>下面结合前面的 ER 模型，具体讲解一下怎么运用这些转换的原则，把 ER 模型转换成具体的数据表，从而把抽象出来的数据模型，落实到具体的数据库设计当中。</p>
<p><strong>一个实体转换成一个数据表</strong></p>
<p><strong>首先是强实体转换成数据表</strong>：用户实体转换成用户表 (user_info) 的代码如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_info` (</span><br><span class="line">	`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `user_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名称&#x27;</span>,</span><br><span class="line">  `nick_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户昵称&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户密码&#x27;</span>,</span><br><span class="line">  `phone_num` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  `head_imd` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;头像&#x27;</span>,</span><br><span class="line">  `user_level` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户级别&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>商品分类实体转换成商品分类表 (base_category)，由于商品分类可以有一级分类和二级分类，比如一级分类有家居、手机等等分类，二级分类可以根据手机的一级分类分为手机配件，运营商等，这里我们把商品分类实体规划为两张表，分别是一级分类表和二级分类表，之所以这么规划是因为一级分类和二级分类都是有限的，存储为两张表业务结构更加清晰。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 一级分类表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `base_category1` (</span><br><span class="line">	`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>，</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类名称&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;一级分类表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 二级分类表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `base_category2` (</span><br><span class="line">	`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;二级分类名称&#x27;</span>,</span><br><span class="line">  `category1_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;一级分类编号&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;二级分类表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>那么如果规划一张表，表结构如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `base_category` (</span><br><span class="line">	`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;二级分类名称&#x27;</span>,</span><br><span class="line">  `category1_parent_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;父分类编号&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;分类表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果这样分类的话，那么查询一级分类的时候，就需要判断父分类编号是否为空，但是如果插入二级分类的时候也是空，就容易造成业务数据混乱。而且查询二级分类的时候 <code>IS NOT NULL</code> 条件是无法使用到索引的。同时，这样的设计也不符合第二范式 (因为父分类编号并不依赖分类编号 ID，因为父分类编号可以有很多数据为 NULL)，所以就需要进行表的拆分。因此无论是业务需求还是数据库表的规范来看都应该拆分为两张表。</p>
<p><strong>再把弱实体转换成数据表</strong>：</p>
<p>地址实体转换成地址表 (user_address)，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_address` (</span><br><span class="line">	`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `province` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;省&#x27;</span>,</span><br><span class="line">  `city` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;市&#x27;</span>,</span><br><span class="line">  `user_address` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;具体地址&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">  `consignee` <span class="type">varchar</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;收件人&#x27;</span>,</span><br><span class="line">  `phone_num` <span class="type">varchar</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;联系方式&#x27;</span>,</span><br><span class="line">  `is_fefault` <span class="type">varchar</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;是否是默认&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;用户地址表；&#x27;</span></span><br></pre></td></tr></table></figure>

<p>订单实体转换成订单表 (order_info)，如下所示，实际业务中订单的信息会非常多，这里做了简化。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `order_info` (</span><br><span class="line">	`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `consignee` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;收货人&#x27;</span>,</span><br><span class="line">  `consignee_tel` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;收件人电话&#x27;</span>,</span><br><span class="line">  `total_amount` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;总金额&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `payment_way` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;付款方式&#x27;</span>,</span><br><span class="line">  `delivery_address` <span class="type">varchar</span>(<span class="number">1000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;送货地址&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;下单时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;订单表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>订单详情实体转换成订单详情表 (order_detail)，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 订单详情表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `order_detail` (</span><br><span class="line">	`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;订单详情编号&#x27;</span>,</span><br><span class="line">  `order_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单编号&#x27;</span>,</span><br><span class="line">  `sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku_id&#x27;</span>,</span><br><span class="line">  `sku_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku 名称&#x27;</span>,</span><br><span class="line">  `sku_num` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;购买个数&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;订单明细表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>购物车实体转换成购物车表 (cart_info)，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `cart_info` (</span><br><span class="line">	`cart_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku_id&#x27;</span>,</span><br><span class="line">  `sku_num` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;数量&#x27;</span>,</span><br><span class="line">  `img_url` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;图片文件&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;购物车表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>评论实体转换成评论表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sku_comments` (</span><br><span class="line">	`comment_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;评论编号&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户编号&#x27;</span>,</span><br><span class="line">  `sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku_id&#x27;</span>,</span><br><span class="line">  `comment` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;评论内容&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;评论时间&#x27;</span>,</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">45</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;商品评论表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>商品实体转换成商品表 (members)，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sku_info` (</span><br><span class="line">	`sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;商品编号itemID&#x27;</span>,</span><br><span class="line">  `price` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;价格&#x27;</span>,</span><br><span class="line">  `sku_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku 名称&#x27;</span>,</span><br><span class="line">  `sku_desc` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品规格描述&#x27;</span>,</span><br><span class="line">  `category3_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;三级分类id(冗余)&#x27;</span>,</span><br><span class="line">  `color` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;颜色&#x27;</span>,</span><br><span class="line">  `is_sale` tinyint(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;是否销售(1:是 0:否)&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">45</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;商品表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>一个多对多的关系转换成一个数据表</strong></p>
<p>这个 ER 模型中的多对多的关系有 一个，即商品和订单之间的关系，同品类的商品可以出现在不同的订单中，不同的订单也可以包含同一类型的商品，所以它们之间的关系是多对多。针对这种情况需要设计一个独立的表来表示，这种表一般称为中间表。</p>
<p>我们可以设计一个独立的订单详情表，来代替商品和订单之间的包含关系。这个表关联到两个实体，分别是订单、商品。所以，表中必须要包括这两个实体转换成的表的主键。除此之外，我们还要包括该关系自有的属性：商品数量，商品下单价格以及商品名称。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 订单详情表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `order_detail` (</span><br><span class="line">	`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;订单详情编号&#x27;</span>,</span><br><span class="line">  `order_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单编号&#x27;</span>,</span><br><span class="line">  `sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku_id&#x27;</span>,</span><br><span class="line">  `sku_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku名称&#x27;</span>,</span><br><span class="line">  `sku_num` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;购买个数&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;订单明细表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>通过外键来表达一对多的关系</strong></p>
<p>在上面的表的设计中，我们可以用外键来表达一对多的关系。比如在商品评论表 sku_comments 中，分别把 user_id、sku_id 定义成外键，以使用下面的语句设置外键。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONSTRAINT</span> fk_comment_user <span class="keyword">FOREIGN</span> KEY (user_id) <span class="keyword">REFERENCES</span> user_info (id),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_comment_sku <span class="keyword">FOREIGN</span> KEY (sku_id) <span class="keyword">REFERENCES</span> sku_info (sku_id)</span><br></pre></td></tr></table></figure>

<p>外键约束主要是在数据库层面上保证数据的一致性，但是因为插入和更新数据需要检查外键，理论上性能会有所下降，对性能是负面的影响。</p>
<p>实际的项目，不建议使用外键，一方面是降低开发的复杂度 (有外键的话主从表类的操作必须是先操作主表)，另外是有外键在处理数据的时候非常麻烦。在电商平台，由于并发业务量比较大，所以一般不设置外键，以免影响数据库性能。</p>
<p>在应用层面做数据的一致性检查，本来就是一个正常的功能需求。如学生选课的场景，课程肯定不是输入的，而是通过下来或者查找等方式从系统中进行选取，就能保证是合法的课程 ID，因此就不需要靠数据库的外键来检查了。</p>
<p><strong>把属性转换成表的字段</strong></p>
<p>在刚刚的设计中，我们也完成了把属性都转换成了表的字段，比如把商品属性转换成了商品信息表中的字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sku_info` (</span><br><span class="line">	`sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;商品编号itemID&#x27;</span>,</span><br><span class="line">  `price` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;价格&#x27;</span>,</span><br><span class="line">  `sku_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku 名称&#x27;</span>,</span><br><span class="line">  `sku_desc` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品规格描述&#x27;</span>,</span><br><span class="line">  `category3_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;三级分类id(冗余)&#x27;</span>,</span><br><span class="line">  `color` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;颜色&#x27;</span>,</span><br><span class="line">  `is_sale` tinyint(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;是否销售(1:是 0:否)&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">45</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;商品表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>到这里，我们通过创建电商项目业务流程的 ER 模型，再把 ER 模型转换成具体的数据表的过程，完成了利用 ER 模型设计电商项目数据库的工作。</p>
<p>其实，任何一个机遇数据库的应用项目，都可以通过这种先建立 ER 模型，再转换成数据表的方式，完成数据库的设计工作。创建 ER 模型不是目的，目的是把业务逻辑梳理清楚，设计出优秀的数据库。建议不是为了建模而建模，要利用创建 ER 模型的过程来整理思路，这样创建 ER 模型才有意义。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/er%E6%A8%A1%E5%9E%8B.png" alt="er模型"></p>
<h3 id="8-数据表的设计原则"><a href="#8-数据表的设计原则" class="headerlink" title="8. 数据表的设计原则"></a>8. 数据表的设计原则</h3><p>综合以上内容，总结出数据表设计的一般原则：三少一多</p>
<ul>
<li><p>数据表的个数越少越好</p>
<p>  RDBMS 的核心在于对实体和联系的定义，也就是 E-R 图 (Entity Relationship Diagram)，数据表越少，证明实体和联系设计得越简洁，既方便理解又方便操作。</p>
</li>
<li><p>数据表中的字段个数越少越好</p>
<p>  字段个数越多，数据冗余的可能性越大。设置字段个数的前提是各个字段相互独立，而不是某个字段的取值可以由其他字段计算出来。当然字段个数少是相对的，我们通常会在数据冗余和检索效率中进行平衡。</p>
</li>
<li><p>数据表中联合主键的字段个数越少越好</p>
<p>  设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式 (也就是用多个字段来定义一个主键)。联合主键中的字段越多，占用的索引空间越大，不仅会加大理解难度，还会增加运行时间和索引空间，因此联合主键的字段个数越少越好。</p>
</li>
<li><p>使用主键和外键越多越好</p>
<p>  数据库的设计实际上就是定义各种表，以及各种字段之间的关系。这些关系越多，证明这些实体之间的冗余度越低，利用度越高。这样做的好处在于不仅保证了数据表之间的独立性，还能提升相互之间的关联使用率。</p>
</li>
</ul>
<p>三少一多原则的核心就是简单可复用。简单指的是用更少的表、更少的字段、更少的联合主键字段来完成数据表的设计。可复用则是通过主键、外键的使用来增强数据表之间的复用率。因为一个主键可以理解是一张表的代表。键设计得越多，证明它们之间的利用率越高。</p>
<blockquote>
<p>注意：这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。</p>
</blockquote>
<h3 id="9-数据库对象编写建议"><a href="#9-数据库对象编写建议" class="headerlink" title="9. 数据库对象编写建议"></a>9. 数据库对象编写建议</h3><h4 id="9-1-关于库"><a href="#9-1-关于库" class="headerlink" title="9.1 关于库"></a>9.1 关于库</h4><ul>
<li><p>【强制】库的名称必须控制在 32 个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。</p>
</li>
<li><p>【强制】库名中英文一律小写，不同单词采用下划线分割。须见名知意。</p>
</li>
<li><p>【强制】库的名称格式：业务系统名称_子系统名。</p>
</li>
<li><p>【强制】库名禁止使用关键字，如 type，order 等。</p>
</li>
<li><p>【强制】创建数据库时必须显示指定字符集，并且字符集只能是 utf8 或者 utf8mb4.</p>
<p>  创建数据库 SQL 举例：<code>CREATE DATABASE crm_fund DEFAULT CHARACTER SET &#39;utf8&#39;;</code></p>
</li>
<li><p>【建议】对于程序连接数据库账号，遵循权限最小原则</p>
<p>  使用数据库账号只能在一个 DB 下使用，不准跨库。程序使用的账号原则上不准有 DROP 权限。</p>
</li>
<li><p>【建议】临时库以 tmp_ 为前缀，并以日期为后缀。备份库以 bak_ 为前缀，并以日期为后缀。</p>
</li>
</ul>
<h4 id="9-2-关于表、列"><a href="#9-2-关于表、列" class="headerlink" title="9.2 关于表、列"></a>9.2 关于表、列</h4><ul>
<li><p>【强制】表和列的名称必须控制在 32 个字符以内，表明只能使用英文字母、数字和下划线，建议以英文字母开头。</p>
</li>
<li><p>【强制】表明、列名一律小写，不同单词采用下划线分割。须见名知意。</p>
</li>
<li><p>【强制】表明要求有模块名强相关，同一模块的表明尽量使用统一前缀。比如：crm_fund_item</p>
</li>
<li><p>【强制】创建表时必须显式指定字符集为 utf8 或 utf8mb4。</p>
</li>
<li><p>【强制】表名、列名禁止使用关键字 (如 type、order 等)</p>
</li>
<li><p>【强制】创建表时必须显式指定表存储引擎类型。如无特殊需求，一律为 InnoDB。</p>
</li>
<li><p>【强制】建表必须有 comment。</p>
</li>
<li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或缩写。如：公司 ID，不要使用 corporation_id，而用 corp_id。</p>
</li>
<li><p>【强制】布尔值类型的字段命名为 is_描述。如 member 表上表示是否为 enabled 的会员的字段命名为 is_enabled。</p>
</li>
<li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据。</p>
<p>  通常文件很大，短时间内造成数据量快速增长，数据库进行数据读取时，通常会进行大量的随机 I&#x2F;O 操作，文件很大时，IO 操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</p>
</li>
<li><p>【建议】建表时关于主键：表必须有主键</p>
<ul>
<li>强制要求主键为 id，类型为 int 或 bigint，且为 AUTO_INCREMENT 建议使用 UNSIGNED 无符号型。</li>
<li>标识表里每一行主体的字段不要设为主键，建议设为其他字段如 user_id，order_id 等，并建立 unique key 索引。因为如果设为主键且主键值为随机插入，则会导致 innodb 内部页分裂和大量随机 I&#x2F;O，性能下降。</li>
</ul>
</li>
<li><p>【建议】核心表 (如用户表) 必须有行数据的创建时间字段 (create_time) 和最后更新时间字段 (update_time)，便于查问题。</p>
</li>
<li><p>【建议】表中所有字段尽量都是 NOT NULL 属性，业务可以根据需要定义 DEFAULT 值。</p>
<p>  因为使用 NULL 值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</p>
</li>
<li><p>【建议】所有存储相同数据的列名和列类型必须一致 (一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，到值查询效率降低)。</p>
</li>
<li><p>【建议】中间表 (或临时表) 用于保留中间结果集，名称以 tmp_ 开头。备份表用于备份或抓取原表快照，名称以 bak_ 开头。中间表和备份表定期清理。</p>
</li>
<li><p>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语句，方便数据库和数据表结构的导出和导入。</p>
</li>
</ul>
<h4 id="9-3-关于索引"><a href="#9-3-关于索引" class="headerlink" title="9.3 关于索引"></a>9.3 关于索引</h4><ul>
<li><p>【强制】InnoDB 表必须主键为 id int &#x2F; bigint auto_increment，且主键值禁止被更新。</p>
</li>
<li><p>【强制】InnoDB 和 MyISAM 存储引擎表，索引类型必须为 BTREE。</p>
</li>
<li><p>【建议】主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_ 开头，一律使用小写格式，以字段的名称或缩写作为后缀。</p>
</li>
<li><p>【建议】多单词组成的 columnname，取前几个单词首字母，加末单词组成 column_name。如：sample 表member_id 上的索引：idx_sample_mid。</p>
</li>
<li><p>【建议】单个表上的索引个数不能超过 6 个。</p>
</li>
<li><p>【建议】在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面。</p>
</li>
<li><p>【建议】在多表 JOIN 的 SQL 里，保证被驱动表的连接列上有索引，这样 JOIN 执行效率最高。</p>
</li>
<li><p>【建议】建表或加索引时，保证表里互相不存在冗余索引。</p>
<p>  比如：如果表里已经存在 key(a,b)，则 key(a) 为冗余索引，需要删除。</p>
</li>
</ul>
<h4 id="9-4-SQL-编写"><a href="#9-4-SQL-编写" class="headerlink" title="9.4 SQL 编写"></a>9.4 SQL 编写</h4><ul>
<li><p>【强制】程序端 SELECT 语句必须指定具体字段名称，禁止写成 *。</p>
</li>
<li><p>【建议】程序端 INSERT 语句制定具体字段名称，不要写成 INSERT INTO t1 VALUES(…)。</p>
</li>
<li><p>【建议】除静态表或小表 (100 行以内)，DML 语句必须有 WHERE 条件，且使用索引查找。</p>
</li>
<li><p>【建议】INSERT INTO … VALUES(xx),(xx),(xx).. 这里 xx 的值不要超过 5000 个。值过多虽然上线很快，但会引起主从同步延迟。</p>
</li>
<li><p>【建议】SELECT 语句不要使用 UNION，推荐使用 UNION ALL，并且 UNION 字句个数限制在 5 个以内。</p>
</li>
<li><p>【建议】线上环境，多表 JOIN 不要超过 5 个表。</p>
</li>
<li><p>【建议】减少使用 ORDER BY，和业务沟通能不排序就不排序，获奖排序放到程序段去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费 CPU，数据库的 CPU 资源是极其宝贵的。</p>
</li>
<li><p>【建议】包含了 ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在 1000 行以内，否则 SQL 会很慢。</p>
</li>
<li><p>【建议】对单表的多次 ALTER 操作必须合并为一次</p>
<p>  对于超过 100w 行的大表进行 alter table，必须经过 DBA 审核，并在业务低峰期执行，多个 alter 需整合在一起。因为 alter table 会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</p>
</li>
<li><p>【建议】批量操作数据时，需要控制事物处理间隔时间，进行必要的 sleep。</p>
</li>
<li><p>【建议】事物里包含 SQL 不超过 5 个。</p>
<p>  因为过长的事物会导致锁数据较久，MySQL 内部缓存、连接消耗过多等问题。</p>
</li>
<li><p>【建议】事物里更新语句尽量基于主键或 UNIQUE KEY，如 UPDATE … WHERE id &#x3D; xxx;</p>
<p>  否则会产生间隙锁，内部扩大锁定范围，到值系统性能下降，产生死锁。</p>
</li>
</ul>
<h2 id="十、数据库其它调优策略"><a href="#十、数据库其它调优策略" class="headerlink" title="十、数据库其它调优策略"></a>十、数据库其它调优策略</h2><h3 id="1-数据库调优的措施"><a href="#1-数据库调优的措施" class="headerlink" title="1. 数据库调优的措施"></a>1. 数据库调优的措施</h3><h4 id="1-1-调优的目标"><a href="#1-1-调优的目标" class="headerlink" title="1.1 调优的目标"></a>1.1 调优的目标</h4><ul>
<li>尽可能节省系统资源，以便系统可以提供更大负荷的服务。(吞吐量更大)</li>
<li>合理的结构设计和参数调整，以提高用户操作响应的速度。(响应速度更快)</li>
<li>减少系统的瓶颈，提高 MySQL 数据库整体的性能。</li>
</ul>
<h4 id="1-2-如何定位调优问题"><a href="#1-2-如何定位调优问题" class="headerlink" title="1.2 如何定位调优问题"></a>1.2 如何定位调优问题</h4><p>不过随着用户量的不断增加，以及应用程序复杂度的提升，我们很难用更快取定义数据库调优的目标，因为用户在不同时间段访问服务器遇到的瓶颈不同，比如双十一促销的时候会带来大规模的并发访问；还有用户在进行不同业务操作的时候，数据库的事物处理和 SQL 查询都会有所不同。因此我们还需要更加精细的定位，取确定调优的目标。一般情况下，有如下几种方式：</p>
<ul>
<li><p>用户的反馈 (主要)</p>
<p>  用户是我们服务对象，因此它们的反馈是最直接的。虽然它们不会直接提出技术建议，但是有些问题往往是用户第一时间发现的。我们要重视用户的反馈，找到和数据相关的问题。</p>
</li>
<li><p>日志分析 (主要)</p>
<p>  可以通过查看数据库日志和操作系统日志等方式找出异常情况，通过它们来定位遇到的问题。</p>
</li>
<li><p>服务器资源使用监控</p>
<p>  通过监控服务器的 CPU、内存、I&#x2F;O 等使用情况，可以实时了解服务器的性能使用，与历史情况进行对比。</p>
</li>
<li><p>数据库内部状况监控</p>
<p>  在数据库的监控中，活动会话 (Active Session) 监控是一个重要的指标。通过它，可以清楚地了解数据库当前是否处于非常繁忙的状态，是否存在 SQL 堆积等。</p>
</li>
<li><p>其它</p>
<p>  除了活动会话监控以外，我们也可以对事物、锁等待等进行监控，这些都可以帮助我们对数据库的运行状态有更全面的认识。</p>
</li>
</ul>
<h4 id="1-3-调优的维度和步骤"><a href="#1-3-调优的维度和步骤" class="headerlink" title="1.3 调优的维度和步骤"></a>1.3 调优的维度和步骤</h4><p>我们需要调优的对象是整个数据库管理系统，它不仅包括 SQL 查询，还包括数据库的部署配置、架构等。从这个角度来说，我们思考的维度就不仅仅局限在 SQL 优化上了。通过如下的步骤我们进行梳理：</p>
<p><strong>第一步：选择适合的 DBMS</strong></p>
<p>如果对事务性处理以及安全性要求高的话，可以选择商业的数据库产品。这些数据库在事物处理和查询性能上都比较强，比如采用 SQL Server、Oracle，那么单表存储上亿条数据是没有问题的。如果数据表设计得好，即使不采用分库分表的方式，查询效率也不差。</p>
<p>出此以外，也可以采用开源的 MySQL 进行存储，他有很多存储引擎可以选择，如果进行事物处理的话可以选择 InnoDB，非事物处理可以选择 MyISAM。</p>
<p>NoSQL 阵营包括键值型数据库、文档型数据库、搜索引擎、列式存储和图形数据库。这些数据库的优缺点和使用场景各有不同，比如列式存储数据库可以大幅度降低系统的 I&#x2F;O，适合于分布式文件系统，但如果数据需要频繁地增删改，那么列式存储就不太适用了。</p>
<p>DBMS 的选择关系到了后面的整个设计过程，所以第一步就是要选择合适的 DBMS。如果已经确定了 DBMS，那么这步可以跳过。</p>
<p><strong>第二步：优化表设计</strong></p>
<p>选择了 DBMS 之后，我们就需要进行表设计了。而数据表的设计方式也直接影响了后续的 SQL 查询语句。RDBMS 中，每个对象都可以定义为一张表，表于表之间的关系代表了对象之间的关系。如果用的是 MySQL，我们还可以根据不同的使用需求，选择不同的存储引擎。除此以外，还有一些优化的原则可以参考：</p>
<ul>
<li>表结构要尽量遵循三范式的原则。这样可以让数据结构更加清晰规范，减少冗余字段，同时也减少了在更新、插入和删除数据时等异常情况的发生。</li>
<li>如果查询应用比较多，尤其是需要进行多表联查的时候，可以采用反范式进行优化。反范式采用空间换时间的方式，通过增加冗余字段提高查询的效率。</li>
<li>表字段的数据类型选择，关系到了查询效率的高低以及存储空间的大小。一般来说，如果字段可以采用数值类型就不要采用字符类型；字符长度要尽可能设计得短一些。针对字符类型来说，当确定字符长度固定时，就可以采用 CHAR 类型；当长度不固定时，通常采用 VARCHAR 类型。</li>
</ul>
<p>数据表的结构设计很基础，也很关键。好的表结构可以在业务发展和用户量增加的情况下依然发挥作用，不好的表结构设计会让数据表变得非常臃肿，查询效率也会降低。</p>
<p><strong>第三步：优化逻辑查询</strong></p>
<p>当我们建立好数据表之后，就可以对数据表进行增删改查的操作了。这时我们首先需要考虑的是逻辑查询优化。SQL 查询优化，可以分为逻辑查询优化和物理查询优化。逻辑查询优化就是通过改变 SQL 语句的内容让 SQL 执行效率更高效，采用的方式是对 SQL 语句进行等价变换，对查询进行重写。</p>
<p><strong>SQL 的查询重写包括了子查询优化、等价谓词重写、视图重写、条件简化、连接消除和嵌套连接消除等</strong>。</p>
<p>比如用到 EXISTS 子查询和 IN 子查询的时候，会根据小表驱动大表的原则选择适合的子查询。在 WHERE 字句中会尽量避免对字段进行函数运算，它们会让字段的索引失效。</p>
<p>举例：查询评论内容开头为 abc 的内容都有哪些，如果在 WHERE 字句中使用了函数，语句就会写成下面这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> comment_id, comment_text, comment_time <span class="keyword">FROM</span> product_comment <span class="keyword">WHERE</span> <span class="built_in">SUBSTRING</span>(comment_text, <span class="number">1</span>, <span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>采用查询重写的方式进行等价替换：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> comment_id, comment_text, comment_time <span class="keyword">FROM</span> product_comment <span class="keyword">WHERE</span> comment_text <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>第四步：优化物理查询</strong></p>
<p>物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术 (比如索引等)，通过计算代价模型对各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。<strong>在这个部分中，我们需要掌握的重点是对索引的创建和使用</strong>。</p>
<p>但索引不是万能的，我们需要根据实际情况来创建索引。SQL 查询时需要对不同的数据表进行查询，因此在屋里查询优化阶段也需要确定这些查询所采用的路径，具体的情况包括：</p>
<ul>
<li>单表扫描：对于单表扫描来说，我们可以全表扫描所有的数据，也可以局部扫描。</li>
<li>两张表的连接：常用的连接方式包括了嵌套循环连接、HASH 连接和合并连接。</li>
<li>多张表的连接：多张数据表进行连接的时候，顺序很重要，因为不同的连接路径查询的效率不同，搜索空间也会不同。我们在进行多表连接的时候，搜索空间可能会达到很高的数据量级，巨大的搜索空间显然会占用更多的资源，因此我们需要通过调整连接顺序，将搜索空间调整在一个可接受的范围内。</li>
</ul>
<p><strong>第五步：使用 Redis 或 memcached 作为缓存</strong></p>
<p>除了可以对 SQL 本身进行优化以外，我们还可以请外援提升查询的效率。</p>
<p>因为数据都是存放到数据库中，我们需要从数据库层中取出数据放到内存中进行业务逻辑的操作，当用户量增大的时候，如果频繁地进行数据查询，会消耗数据库的很多资源。如果我们将常用的数据直接放到内存中，就会大幅提升查询的效率。</p>
<p>常用的键值存储数据库有 Redis 和 Memcached，它们都可以将数据存放到内存中。</p>
<p>从可靠性来说，Redis 支持持久化，可以让我们的数据保存在硬盘上，不过这样一来性能消耗也会比较大。而 Memcache 仅仅是内存存储，不支持持久化。</p>
<p>从支持的数据类型来说，Redis 比 Memcached 要多，它不仅支持 key-value 类型的数据，还支持 List、Set、Hash等数据结构。当我们有持久化需求或者是更高级的数据处理需求的时候，就可以使用 Redis。如果是简单的 key-value 存储，则可以使用 Memcached。</p>
<p><strong>通常我们对于查询响应要求高的场景 (响应时间短，吞吐量大)，可以考虑内存数据库，毕竟术业有专攻</strong>。传统的 RDBMS 都是将数据存储在硬盘上，而内存数据库则存放在内存中，查询起来要快得多。不过使用不同的工具，也增加了开发人员的使用成本。</p>
<p><strong>第六步：库级优化</strong></p>
<p>库级优化是站在数据库的维度上进行的优化策略，比如控制一个库中的数据表数量。另外，单一的数据库总会遇到各种限制，不如取长补短，利用外援的方式。通过主从架构优化我们的读写策略，通过对数据库进行垂直或者水平切分，突破单一数据库或数据表的访问限制，提升查询的性能。</p>
<p><strong>读写分离</strong></p>
<p>如果读和写的业务量都很大，并且它们都在同一个数据库服务器中进行操作，那么数据库的性能就会出现瓶颈，这时为了提升系统的性能，优化用户体验，我们可以采用读写分离的方式降低主数据库的负载，比如用主数据库 (master) 完成写操作，用从数据库 (slave) 完成读操作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E4%B8%80%E4%B8%BB%E4%B8%80%E4%BB%8E%E6%A8%A1%E5%BC%8F.png" alt="一主一从模式"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/myslq/%E5%8F%8C%E4%B8%BB%E5%8F%8C%E4%BB%8E%E6%A8%A1%E5%BC%8F.png" alt="双主双从模式"></p>
<p><strong>数据分片</strong></p>
<p>对数据库分库分表。当数据量级达到千万级以上时，有时候我们需要把一个数据库切分成多份，放到不同的数据库服务器上，减少对单一数据库服务器的访问压力。如果你使用的是 MySQL，就可以使用 MySQL 自带的分区表功能，当然你也可以考虑自己做垂直拆分 (分库)、水平拆分 (分表)、垂直+水平拆分 (分库分表)。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87-1.png" alt="数据分片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87-2.png" alt="数据分片"></p>
<blockquote>
<p>但需要注意的是，拆分在提升数据库性能的同时，也会增加维护和使用成本。</p>
</blockquote>
<h3 id="2-优化-MySQL-服务器"><a href="#2-优化-MySQL-服务器" class="headerlink" title="2. 优化 MySQL 服务器"></a>2. 优化 MySQL 服务器</h3><p>优化 MySQL 服务器主要从两个方面来优化，一方面是对硬件进行优化；另一方面是对 MySQL 服务的参数进行优化。这部分的内容需要较全面的知识，一般只有专业的数据库管理员才能进行这一类的优化。对于可以定制参数的操作系统，也可以针对 MySQL 进行操作系统优化。</p>
<h4 id="2-1-优化服务器硬件"><a href="#2-1-优化服务器硬件" class="headerlink" title="2.1 优化服务器硬件"></a>2.1 优化服务器硬件</h4><p><strong>服务器的硬件性能直接决定着 MySQL 数据库的性能</strong>。硬件的性能瓶颈直接决定 MySQL 数据库的运行速度和效率。针对性能瓶颈提高硬件配置，可以提高 MySQL 数据库查询、更新的速度。</p>
<ul>
<li>配置较大的内存。足够大的内存是提高 MySQL 数据库性能的方法之一。内存的速度比磁盘 I&#x2F;O 快得多，可以通过增加系统的缓冲区容量使数据在内存中停留的时间更长，以减少磁盘 I&#x2F;O。</li>
<li>配置高速磁盘系统，以减少读盘的等待时间，提高响应速度。磁盘的 I&#x2F;O 能力，也就是它的寻道能力，目前的 SCSI 高速旋转的是 7200 转&#x2F;分钟，这样的速度，一旦访问的用户量上去，磁盘的压力就会过大，如果是每天的网站 pv (page view) 在 150w，这样的一般配置就无法满足这样的需求了。现在 SSD 盛行，在 SSD 上随机访问和顺序访问性能几乎差不多，使用SSD 可以减少随机 I&#x2F;O 带来的性能损耗。</li>
<li>合理分布磁盘 I&#x2F;O，把磁盘 I&#x2F;O 分散在多个设备上，以减少资源竞争，提高并行操作能力。</li>
<li>配置多处理器，MySQL 是多线程的数据库，多处理器可同时执行多个线程。</li>
</ul>
<h4 id="2-2-优化-MySQL-的参数"><a href="#2-2-优化-MySQL-的参数" class="headerlink" title="2.2 优化 MySQL 的参数"></a>2.2 优化 MySQL 的参数</h4><p>通过优化 MySQL 的参数可以提高资源利用率，从而达到提高 MySQL 服务器性能的目的。</p>
<p>MySQL 服务的配置参数都在 my.cnf 或者 my.ini 文件的 [mysqld] 组中。配置完参数以后，需要重新启动 MySQL 服务器才会生效。下面对几个对性能影响比较大的参数进行详细介绍。</p>
<ul>
<li><p><code>innodb_buffer_pool_size</code>：这个参数是 My SQL 数据库最重要的参数之一，表示 InnoDB 类型的表和索引的最大缓存。它不仅仅缓存索引数据，还会缓存表的数据。这个值越大，查询的速度就会越快。但是这个值太大会影响操作系统的性能。</p>
</li>
<li><p><code>key_buffer_size</code>：表示索引缓冲区的大小。索引缓冲区是所有的线程共享。增加索引缓冲区可以得到更好处理的索引 (对所有读和多重写)。当然，这个值不是越大越好，它的大小取决于内存的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在 4GB 左右的服务器该参数可设置为 256M 或 384M。</p>
</li>
<li><p><code>table_cache</code>：表示同时打开的表的个数。这个值越大，能够同时打开的表的个数越多。物理内存越大，设置就越大。默认为2402，调到 512-1024 最佳。这个值不是越大越好，因为同时打开的表太多会影响操作系统的性能。</p>
</li>
<li><p><code>query_cache_size</code>：表示查询缓冲区的大小。可以通过 MySQL控制台观察，如果 Cache_lowmem_prunes 的值非常大，则表明经常出现缓冲不够的情况，就要增加 Query_cache_size 的值；如果 Qcache_hits 的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区碎片很多。MySQL 8.0 之后失效。该参数需要和 query_cache_type 配合使用。</p>
</li>
<li><p><code>query_cache_type</code> 的值是 0 时，所有的查询都不使用查询缓存区。但是 query_cache_type&#x3D;0 并不会导致 MySQL 释放 query_cache_size 所配置的缓存区内存。</p>
<ul>
<li>当 query_cache_type&#x3D;1 时，所有的查询都将使用查询缓存区，除非在查询语句中指定 SQL_NO_CACHE，如果 SELECT SQL_NO_CACHE * FROM tel_name。</li>
<li>当 query_cache_type&#x3D;2 时，只有在查询语句中使用 SQL_CACHE 关键字，查询才会使用查询缓存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的查询操作的情况。</li>
</ul>
</li>
<li><p><code>sort_buffer_size</code>：表示每个需要进行排序的线程分配的缓冲区的大小。增加这个参数的值可以提高 ORDER BY 或 GROUP BY 操作的速度。默认数值是 2097144字节 (约 2MB)。对于内存在 4GB 左右的服务器推荐设置为 6-8M，如果有 100个连接，那么实际分配的总共排序缓冲区大小为 100 * 6 &#x3D; 600MB。</p>
</li>
<li><p><code>join_buffer_size=8M</code>：表示联合查询操作所能使用的缓冲区大小，和 sort_buffer_size 一样，该参数对应的分配内存也是每个连接独享。</p>
</li>
<li><p><code>read_buffer_size</code>：表示每个线程连续扫描时为扫描的每个表分配的缓冲区的大小 (字节)。当线程从表中连续读取记录时需要用到这个缓冲区。 SET SESSION read_buffer_size&#x3D;n 可以临时设置该参数的值。默认为 64k，可以设置为 4M。</p>
</li>
<li><p><code>innodb_flush_log_at_trx_commit</code>：表示何时将缓冲区的数据写入日志文件，并且将日志文件写入磁盘中。该参数对于 InnoDB 引擎非常重要。该参数有 3 个值，分别为 0、1 和 2 该参数的默认值为 1。</p>
<ul>
<li>值为 0 时，表示每秒 1 次的频率将数据写入日志文件并将日志文件写入磁盘。每个事物的 COMMIT 并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld 进程的崩溃会导致上一秒钟所有事物数据的丢失。</li>
<li>值为 1 时，表示每次提交事物时将数据写入日志文件并将日志文件写入磁盘进行同步。该模式是最安全的，但也是最慢的一种方式。因为每次事物提交或事物外的指令都需要把日志写入 (flush) 磁盘。</li>
<li>值为 2 时，表示每次提交事物时将数据写入日志文件，每隔 1 秒将日志文件写入磁盘。该模式速度较快，也比 0 安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事物数据才可能丢失。</li>
</ul>
</li>
<li><p><code>innodb_log_buffer_size</code>：这是 InnoDB 存储引擎的 事物日志所使用的缓冲区。为了提高性能，也是先将信息写入 InnoDB Log Buffer 中，当满足 in no d b_flush_log_trx_commit 参数所设置的相应条件 (或者日志缓冲区写满) 之后，才会将日志写到文件 (或者同步到磁盘) 中。</p>
</li>
<li><p><code>max_connections</code>：表示允许连接到 MySQL 数据库的最大数量，默认值是 151。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这时可以考虑增大 max_connections 的值。在 Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数不是越大越好，因为这些连接会浪费内存的资源。过多的连接可能会导致 MySQL 服务器僵死。</p>
</li>
<li><p><code>back_log</code>：用于控制 MySQL 监听 TCP 端口时设置的积压请求栈大小。如果 MySQL 的连接数达到 max_connections 时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即 back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50，之后的版本默认为 50 + (max_connections &#x2F; 5)，对于 Linux 系统推荐设置为小于 512 的整数，但最大不超过 900。如果需要数据库在较短的时间内处理大量连接请求，可以考虑适当增大 back_log 的值。</p>
</li>
<li><p><code>thread_cache_size</code>：线程池缓存线程数量的大小，当客户端断开链接后将当前线程缓存起来，当在接到新的连接请求时快速响应无需创建新的线程。这尤其对那些使用短连接的应用程序来说可以极大的提高创建连接的效率。那么为了提高可以增大该参数的值。默认为 60，可以设置为 120。</p>
<p>  可以通过如下几个 MySQL 状态值来适当调整线程池的大小：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Thread%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>  当 Thread_cached 越来越少，但 Threads_connected 始终不降，且 Threads_created 持续升高，可适当增加 thread_cache_size 的大小。</p>
</li>
<li><p><code>wait_timeout</code>：指定一个请求的最大连接时间，对于 4GB 左右内存的服务器可以设置为 5-10。</p>
</li>
<li><p><code>interactive_timeout</code>：表示服务器在关闭连接前等待行动的秒数。</p>
</li>
</ul>
<p>这里给出一份 my.cnf 的参考配置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">port<span class="operator">=</span><span class="number">3306</span></span><br><span class="line">serverid<span class="operator">=</span><span class="number">1</span></span><br><span class="line">socket<span class="operator">=</span><span class="operator">/</span>tmp<span class="operator">/</span>mysql.sock</span><br><span class="line"><span class="keyword">skip</span><span class="operator">-</span>locking</span><br><span class="line"># 避免 MySQL 的外部锁定，减少出错几率增强稳定性。</span><br><span class="line"><span class="keyword">skip</span><span class="operator">-</span>name<span class="operator">-</span>resolve</span><br><span class="line"># 禁止 MySQL 对外部连接进行 DNS 解析，使用这一选项可以消除 MySQL 进行 DNS 解析的时间。但需要注意，如果开启该选项，则所有远程主机授权都要使用 IP 地址方式，否则 MySQL 将无法正常处理连接请求！</span><br><span class="line">back_log<span class="operator">=</span><span class="number">384</span></span><br><span class="line">key_buffer_size<span class="operator">=</span><span class="number">256</span>M</span><br><span class="line">max_allowed_packet<span class="operator">=</span><span class="number">4</span>M</span><br><span class="line">thread_stack<span class="operator">=</span><span class="number">256</span>k</span><br><span class="line">table_cache<span class="operator">=</span><span class="number">128</span>k</span><br><span class="line">sort_buffer_size<span class="operator">=</span><span class="number">6</span>M</span><br><span class="line">read_buffer_size<span class="operator">=</span><span class="number">4</span>M</span><br><span class="line">read_rnd_buffer_size<span class="operator">=</span><span class="number">16</span>M</span><br><span class="line">join_buffer_size<span class="operator">=</span><span class="number">8</span>M</span><br><span class="line">myisam_sort_buffer_size<span class="operator">=</span><span class="number">64</span>M</span><br><span class="line">table_cache<span class="operator">=</span><span class="number">512</span></span><br><span class="line">thread_cache_size<span class="operator">=</span><span class="number">64</span></span><br><span class="line">query_cache_size<span class="operator">=</span><span class="number">64</span>M</span><br><span class="line">tmp_table_size<span class="operator">=</span><span class="number">256</span>M</span><br><span class="line">max_connections<span class="operator">=</span><span class="number">768</span></span><br><span class="line">max_connect_errors<span class="operator">=</span><span class="number">10000000</span></span><br><span class="line">wait_timeout<span class="operator">=</span><span class="number">10</span></span><br><span class="line">thread_concurrency<span class="operator">=</span><span class="number">8</span></span><br><span class="line"># 该参数取值为服务器逻辑CPU数量<span class="operator">*</span><span class="number">2</span>，在本例中，服务器有两颗物理CPU，而每颗物理CPU又支持H.T超线程，所以实际取值为<span class="number">4</span><span class="operator">*</span><span class="number">2</span><span class="operator">=</span><span class="number">8</span></span><br><span class="line"><span class="keyword">skip</span><span class="operator">-</span>networking</span><br><span class="line"># 开启该选项可以彻底关闭 MYSQL 的 TCP<span class="operator">/</span>IP 连接方式，如果 WEB 服务器是以远程连接的方式访问 MYSQL 数据库服务器则不要开启该选项！否则将无法正常连接</span><br><span class="line">table_cache<span class="operator">=</span><span class="number">1024</span></span><br><span class="line">innodb_additional_mem_pool_size<span class="operator">=</span><span class="number">4</span>M</span><br><span class="line"># 默认为 <span class="number">2</span>M</span><br><span class="line">innodb_flush_log_at_trx_commit<span class="operator">=</span><span class="number">1</span></span><br><span class="line">innodb_log_buffer_size<span class="operator">=</span><span class="number">2</span>M</span><br><span class="line"># 默认为 <span class="number">1</span>M</span><br><span class="line">innodb_thread_concurrency<span class="operator">=</span><span class="number">8</span></span><br><span class="line"># 你的服务器 CPU 有几个就设置为几。建议用默认一般为 <span class="number">8</span></span><br><span class="line">tmp_table_size<span class="operator">=</span><span class="number">64</span>M</span><br><span class="line"># 默认为 <span class="number">16</span>M，调到 <span class="number">64</span>～<span class="number">256</span> 最佳</span><br><span class="line">thread_cache_size<span class="operator">=</span><span class="number">120</span></span><br><span class="line">query_cache_size<span class="operator">=</span><span class="number">32</span>M</span><br></pre></td></tr></table></figure>

<p>很多情况还需要具体情况具体分析！</p>
<p><strong>举例</strong>：</p>
<p>下面是一个电商平台，类似京东或天猫这样的平台。商家购买服务，入驻平台，开通之后，商家可以在系统中上架各种商品，客户通过手机 App、微信小程序等渠道购买商品，商家接到订单以后安排快递送货。</p>
<p>刚刚上线的时候，系统运行状态良好。但是，随着入住的商家不断增多，使用系统的用户量越来越多，每天的订单数据达到了 5 万条以上。这个时候，系统开始出现问题，CPU 使用率不断飙升。终于，双十一或者 618 活动高峰的时候，CPU 使用率达到 99%，这实际上就意味着，系统的计算资源已经耗尽，再也无法处理任何新的订单了。换句话说，系统已经崩溃了。</p>
<p>这个时候，我们想到了对系统参数进行调整，因为参数的值决定了资源配置的方式和投放的程度。</p>
<p>为了解决这个问题，一共调整了 3 个系统参数，分别是</p>
<ul>
<li>InnoDB_flush_log_at_trx_commit</li>
<li>InnoDB_buffer_pool_size</li>
<li>InnoDB_buffer_pool_instances</li>
</ul>
<p>下面我们就说一说调整这三个参数的原因是什么。</p>
<p><strong>调整系统参数 InnoDB_flush_log_at_trx_commit</strong></p>
<p>这个参数适用于 InnoDB 存储引擎，电商平台系统中的表用的存储引擎都是 InnoDB。默认的值是 1，意思是每次提交事物的时候，都把数据写入日志，并把日志写入磁盘。这样做的好处是数据安全性最佳，不足之处在于每次提交事物，都要进行磁盘写入的操作。在大并发的场景下，过于频繁的磁盘读写会导致 CPU 资源浪费，系统效率变低。</p>
<p>这个参数的值还有 2 个可能的选项，分别是 0 和 2。我们把这个参数的值改成了 2.这样就不用每次提交事物的时候都启动磁盘读写了，在大并发的场景下，可以改善系统效率，降低 CPU 使用率。即便出现故障，损失的数据也比较小。</p>
<p><strong>调整系统参数 InnoDB_buffer_pool_size</strong></p>
<p>这个参数的意思是，InnoDB 存储引擎使用缓存来存储索引和数据。这个值越大，可以加载到缓存区的索引和数据量就越多，需要的磁盘读写就越少。</p>
<p>因为我们的 MySQL 服务器是数据库专属服务器，只用来运行 MySQL 数据库服务，没有其他应用了，而我们的计算机是 64 位机器，内存也有 128G。于是我们把这个参数的值调整为 64G。这样一来，磁盘读写次数可以大幅降低，我们就可以充分利用内存，释放出一些 CPU 的资源。</p>
<p><strong>调整系统参数 InnoDB_buffer_pool_instances</strong></p>
<p>这个参数可以讲 InnoDB 的缓存区分成几个部分，这样可以提高系统的并行处理能力，因为可以允许多个进程同时处理不同部分的缓存区。</p>
<p>我们把 InnoDB_buffer_pool_instances 的值修改为 64，意思就是把 InnoDB 的缓存区分成 64 个分区，这样就可以同时有多个进程进行数据操作，CPU 的效率就高多了。修改好了系统参数的值，要重启 MySQL 数据库服务器。</p>
<blockquote>
<p>总结一下就是遇到 CPU 资源不足的问题，可以从下面两个思路去解决。</p>
<ul>
<li>疏通拥堵路段，消除瓶颈，让等待的时间更短；</li>
<li>开拓新的通道，增加并行处理能力。</li>
</ul>
</blockquote>
<h3 id="3-优化数据库结构"><a href="#3-优化数据库结构" class="headerlink" title="3. 优化数据库结构"></a>3. 优化数据库结构</h3><p>一个好的数据库设计方案对于数据库的性能常常会起到事半功倍的效果。合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p>
<h4 id="3-1-拆分表：冷热数据分离"><a href="#3-1-拆分表：冷热数据分离" class="headerlink" title="3.1 拆分表：冷热数据分离"></a>3.1 拆分表：冷热数据分离</h4><p>拆分表的思路是，把一个包含很多字段的表拆分成 2 个或者多个相对较小的表。这样做的原因是，这些表中某些字段的操作频率很高 (热数据)，经常要进行查询或者更新操作，而另外一些字段的使用频率却很低 (冷数据)，冷热数据分离，可以减小表的宽度。如果放在一个表里面，每次查询都要读取大记录，会消耗较多的资源。</p>
<p>MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。表越宽，把表装载进内存缓冲池时所占用的内存也就越大，会消耗更多的 IO。冷热数据分离的目的是：减少磁盘 IO，保证热数据的内存缓存命中率；更有效的利用缓存，避免读入无用的冷数据。</p>
<p>举例：会员 members 存储会员登录认证信息，该表中有很多字段，如 id、姓名、密码、地址、电话、个人描述字段。其中地址、电话、个人描述等字段并不常用，可以将这些不常用的字段分解出另一个表。将这个表取名叫 members_detail，表中有 member_id、address、telephone、description 等字段。这样就把会员表分成了两个表，分别为 members 和 members_detail 表。</p>
<p>创建这两个表的 SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> members (</span><br><span class="line">	id <span class="type">int</span>() <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  username <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  password <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  last_login_time datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  last_login_ip <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> members_detail (</span><br><span class="line">	member_id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  address <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  telephone <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  description text</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果需要查询会员的基本信息或详细信息，那么可以用会员的 id 来查询。如果需要将会员的基本信息和详细信息同时显示，那么可以将 members 表和 members_detail 表进行联合查询，查询语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> members <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> members_detail <span class="keyword">ON</span> members.id <span class="operator">=</span> members_detail.member_id;</span><br></pre></td></tr></table></figure>

<p>通过这种分解可以提高表的查询效率。对于字段很多且有些字段使用不频繁的表，可以通过这种分解的方式来优化数据库的性能。</p>
<h4 id="3-2-增加中间表"><a href="#3-2-增加中间表" class="headerlink" title="3.2 增加中间表"></a>3.2 增加中间表</h4><p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，<strong>把需要经常李娜和查询的数据插入中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率</strong>。</p>
<p>首先，分析经常联合查询表中的字段；然后，使用这些字段建立一个中间表，并将原来联合查询的表的数据插入中间表中；最后，使用中间表来进行查询。</p>
<p>举例：学生信息表和班级表的 SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `class` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `className` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `address` <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `monitor` <span class="type">INT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `stuno` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `classId` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>现在有一个模块需要经常查询带有学生名称 (name)、学生所在班级名称 (className)、学生班级班长 (monito) 的学生信息。根据这种情况可以创建一个 temp_student 表。temp_student 表中存储学生名称 (stu_name)、学生所在班级名称 (className) 和学生班级班长 (monitor) 信息。创建表的语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `temp_student` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `stu_name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `className` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `monitor` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>接下来，从学生信息表和班级表中查询相关信息存储到临时表中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_student(stu_name, clasName, monitor)</span><br><span class="line"><span class="keyword">SELECT</span> s.name, c.className, c.monitor</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">as</span> s, class <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">WHERE</span> s.classId <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure>

<p>以后，可以直接从 temp_student 表中查询学生名称、班级名称和班级班长，而不用每次都进行联合查询。这样可以提高数据库的查询速度。</p>
<blockquote>
<p>如果用户信息修改了，是不是会导致 temp_vip 中的数据不一致的问题呢？如何同步数据呢？</p>
<p>方式1: 清空数据 -&gt; 重新添加数据</p>
<p>方式2: 使用视图</p>
</blockquote>
<h4 id="3-3-增加冗余字段"><a href="#3-3-增加冗余字段" class="headerlink" title="3.3 增加冗余字段"></a>3.3 增加冗余字段</h4><p>设计数据库表时应尽量遵循范式理论的规约，尽可能减少冗余字段，让数据库设计看起来精致、优雅。但是，合理地加入冗余字段可以提高查询速度。</p>
<p>表的规范化程度越高，表于表之间的关系就越多，需要连接查询的情况也就越多。尤其在数据量大，而且需要频繁进行连接的时候，为了提升效率，我们也可以考虑增加冗余字段来减少连接。</p>
<p>改进表的设计时，可以考虑优化字段的数据类型。这个问题在打架刚从事开发时进本不算是问题。但是，随着你的经验越来越丰富，参与的项目越来越大，数据量也越来越多的时候，你就不能只从系统稳定性的角度来思考问题了，还要考虑懂啊系统整体的稳定性和效率。此时，优先选择符合存储需要的最小的数据类型。</p>
<p>列的字段越大，建立索引时所需要的空间也就越大。这样一页中所能存储的索引节点的数据量也就越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。</p>
<p>具体来说：</p>
<ul>
<li><p>情况一：对整数类型数据进行优化。</p>
<p>  遇到整数类型的字段可以用 INT 型。这样做的理由是，INT 型数据有足够大的取值范围，不用担心数据超出取值范围的问题。刚开始做项目的时候，首先要保证系统的稳定性，这样设计字段类型是可以的。但在数据量很大的时候，数据类型的定义，在很大程度上会影响到系统整体的执行效率。</p>
<p>  对于非负型的数据 (如自增 ID、整型 IP) 来说，要优先使用无符号整型 UNSIGNED 来存储。因为无符号相对于有符号，同样的字节数，存储的数值范围更大。如 tinyint 有符号为 -128～127，无符号为 0～255，多出一倍的存储空间。</p>
</li>
<li><p>情况二：既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型。</p>
<p>  跟文本类型数据相比，大整数往往占用更少的存储空间，因此，在存取和比对的时候，可以占用更少的内存空间。所以，在二者皆可用的情况下，尽量使用整数类型，这样可以提高查询的效率。如：将 IP 地址转换成整型数据。</p>
</li>
<li><p>情况三：避免使用 TEXT、BLOB 数据类型</p>
<p>  MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用 磁盘临时表进行。并且对于这种数据，MySQL 还是要进行二次查询，会使 SQL 性能表的很差，但是不是说一定不能使用这样的数据类型。</p>
<p>  如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select *，而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p>
</li>
<li><p>情况四：避免使用 ENUM 类型</p>
<p>  修正 ENUM 值需要使用 ALTER 语句。</p>
<p>  ENUM 类型的 OPDER BY 操作效率低，需要额外操作。使用 TINYINT 来代替 ENUM 类型。</p>
</li>
<li><p>情况五：使用 TIMESTAMP 存储时间</p>
<p>  TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19 03:14:07。TIMESTAMP 使用 4 字节，DATETIME 使用 8 个字节，同时 TIMESTAMP 具有自动赋值以及自动更新的特性。</p>
</li>
<li><p>情况六：用 DECIMAL 代替 FLOAT 和 DOUBLE 存储精确浮点数</p>
<ul>
<li>非精准浮点：float、double</li>
<li>精准浮点：decimal</li>
</ul>
<p>  Decimal 类型为精准浮点数，在计算时不会丢失精度，尤其是财务相关的金融类数据。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。可以用于存储比 bigint 更大的整型数据。</p>
</li>
</ul>
<p>总之，遇到数据量大的项目时，一定要在充分连接业务需求的前提下，合理优化数据类型，这样才能充分发挥资源的效率，使系统达到最优。</p>
<h4 id="3-5-优化插入记录的速度"><a href="#3-5-优化插入记录的速度" class="headerlink" title="3.5 优化插入记录的速度"></a>3.5 优化插入记录的速度</h4><p>插入记录时，影响插入速度的主要时索引、唯一性校验、一次插入记录条数等。根据这些情况可以分别进行优化。这里我们分为 MyISAM 引擎和 InnoDB 存储引擎来讲。</p>
<ul>
<li><p>MyISAM 引擎的表：</p>
<ul>
<li><p>禁用索引</p>
<p>  对于非空表，插入记录时，MySQL 会根据表的索引对插入的记录建立索引。如果插入大量数据，建立索引就会降低插入记录的速度。为了解决这种问题，可以再插入记录之前禁用索引，数据插入完毕后再开启索引。禁用索引的语句如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name DISABLE KEYS;</span><br></pre></td></tr></table></figure>

<p>  重新开启索引的语句如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name ENABLE KEYS;</span><br></pre></td></tr></table></figure>

<p>  若对于空表批量导入数据，则不需要进行此操作，因为 MyISAM 引擎的表是在导入数据之后才建立索引的。</p>
</li>
<li><p>禁用唯一性检查</p>
<p>  插入数据时，MySQL 会对插入的记录进行唯一性校验。这种唯一性校验会降低插入记录的速度。为了降低这种情况对查询速度的影响，可以在插入记录之前禁用唯一性检查，等到记录插入完毕后再开启。禁用唯一性检查的语句如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> UNIQUE_CHECKS<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>  开启唯一性检查的语句如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> UNIQUE_CHECKS<span class="operator">=</span><span class="number">1</span>；</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用批量插入</p>
<p>  插入多条记录时，可以使用一条 INSERT 语句插入一条记录，也可以使用一条 INSERT 语句插入多条记录。插入一条记录的 INSERT 语句情形如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;wangwu&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">&#x27;zhaoliu&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>  使用一条 INSERT 插入多条记录的情形如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;wangwu&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;zhaoliu&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>  第二种情形的插入速度要比第一种情形快。</p>
</li>
<li><p>使用 LOAD DATA INFILE 批量导入</p>
<p>  当需要批量导入数据时，如果能用 LOAD DATA INFILE 语句，就尽量使用。因为 LOAD DATA INFILE 语句导入数据的速度比 INSERT 语句快。</p>
</li>
</ul>
</li>
<li><p>InnoDB 引擎的表：</p>
<ul>
<li><p>禁用唯一性检查</p>
<p>  插入数据之前执行 <code>set unique_checks=0</code> 来禁止对唯一索引的检查，数据导入完成之后再运行 <code>set unique_checks=1</code>。这个和 MyISAM 引擎的使用方法一样。</p>
</li>
<li><p>禁用外键检查</p>
<p>  插入数据执勤啊执行禁止对外键的检查，数据插入完成之后再恢复对外键的检查。禁用外键检查的语句如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> foreign_key_checks<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>  恢复对外键的检查语句如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> foreign_key_checks<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁止自动提交</p>
<p>  插入数据之前禁止事物的自动提交，数据导入完成之后，执行恢复自动提交操作。禁止自动提交的语句如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>  恢复自动提交的语句如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="3-6-使用非空约束"><a href="#3-6-使用非空约束" class="headerlink" title="3.6 使用非空约束"></a>3.6 使用非空约束</h4><p>在设计字段的时候，如果业务允许，建议尽量使用非空约束。这样做的好处是：</p>
<ul>
<li>进行比较和计算时，省去要对 NULL 值的字段判断是否为空的开销，提高存储效率。</li>
<li>非空字段也容易创建索引。因为索引 NULL 列需要额外的空间来保存，所以要占用更多的空间。使用非空约束，就可以节省存储空间 (每个字段 1 个 bit)。</li>
</ul>
<h4 id="3-7-分析表、检查表与优化表"><a href="#3-7-分析表、检查表与优化表" class="headerlink" title="3.7 分析表、检查表与优化表"></a>3.7 分析表、检查表与优化表</h4><p>MySQL 提供了分析表、检查表和优化表的语句。分析表主要是分析关键字的分布，检查表主要是检查表是否存在错误，优化表主要是消除删除或者更新造成的空间浪费。</p>
<ul>
<li><p>分析表</p>
<p>  MySQL 中提供了 ANALYZE TABLE 语句分析包，ANALYZE TABLE 语句的基本语法如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> tbl_name[, tbl_name]...</span><br></pre></td></tr></table></figure>

<p>  默认的，MySQL 服务会讲 ANALYZE TABLE 语句写到 BINLOG 中，以便在主从架构中，从服务能够同步数据。可以添加参数 LOCAL 或者 NO_WRITE_TO_BINLOG 取消将语句写到 BINLOG 中。</p>
<p>  使用 ANALYZE TABLE 分析表的过程中，数据库系统会自动对表加一个只读锁。在分析期间，只能读取表中的记录，不能更新和插入记录。ANALYZE TABLE 语句能够分析 InnoDB 和 MyISAM 类型的表，但是不能作用于视图。</p>
<p>  ANALYZE TABLE 分析后的统计结果会反应到 cardinality 的值，该值统计了表中某一键所在的列不重复的值的个数。<strong>该值越接近表中的总行数，则在表连接查询或者索引查询时，就越优先被优化器选择使用</strong>。也就是索引列的 cardinality 的值愈表中数据的总条数差距越大，即使查询的时候使用了该索引作为查询条件，存储引擎实际查询的时候使用的概率就越小。下面通过例子来验证下。cardinality 可以通过 SHOW INDEX FROM 表名查看。</p>
</li>
<li><p>检查表</p>
<p>  MySQL 中可以使用 CHECK TABLE 语句来检查表。CHECK TABLE 语句能够检查 InnoDB 和 MyISAM 类型的表是否存在错误。CHECK TABLE 语句在执行过程中也会给表加上只读锁。</p>
<p>  对于 MyISAM 类型的表，CHECK TABLE 语句还会更新关键字统计数据。而且，CHECK TABLE 也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在。该语句的基本语法如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHECK</span> <span class="keyword">TABLE</span> tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option <span class="operator">=</span> &#123;QUICK <span class="operator">|</span> FAST <span class="operator">|</span> MEDIUM <span class="operator">|</span> EXTENDED <span class="operator">|</span> CHANGED&#125;</span><br></pre></td></tr></table></figure>

<p>  其中，tbl_name 是表名；option 参数有 5 个取值，分别是 QUICK、FAST、MEDIUM、EXTENDED 和 CHANGED。各个选项的意义分别是：</p>
<ul>
<li>QUICK：不扫描行，不检查错误的连接。</li>
<li>FAST：只检查没有被正确关闭的表。</li>
<li>CHANGED：值检查上次检查后被更改的表和没有被正确关闭的表。</li>
<li>MEDIUM：扫描行，以验证被删除的连接是有效的。也可以计算各行的关键字校验和，并使用计算出的校验和验证这一点。</li>
<li>EXTENDED：对每行的所有关键字进行一个全面的关机那字查找。这可以确保表时 100% 一致的，但是画的时间较长。</li>
</ul>
<p>  option 只对 MyISAM 类型的表有效，对 InnoDB 类型的表无效。</p>
</li>
<li><p>优化表</p>
<ul>
<li><p>OPTIMIZE TABLE</p>
<p>  MySQL 中使用 OPTIMIZE TABLE 语句来优化表。但是 OPTIMIZE TABLE 语句只能优化表中的 VARCHAR、BLOB 或 TEXT 类型的字段。一个表使用了这些字段的数据类型，若已经删除了表的一大部分数据，或者已经对含有可变长度行的表 (含有 VARCHAR、BLOB 或 TEXT 列的表) 进行了很多更新，则应使用 OPTIMIZE TABLE 来重新利用未使用的空间，并整理数据文件的碎片。</p>
<p>  OPTIMIZE TABLE 语句对 InnoDB 和 MyISAM 类型的表都有效。该语句在执行过程中也会给表加上只读锁。</p>
<p>  OPTIMIZE TABLE 语句的基本语法如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> tbl_name[, tbl_name] ...</span><br></pre></td></tr></table></figure>

<p>  LOCAL ｜ NO_WRITE_TO_BINLOG 关键字的意义和分析表相同，都是指定不写入二进制日志。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> optimize <span class="keyword">table</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+----------+----------+-------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>              <span class="operator">|</span> Op       <span class="operator">|</span> Msg_type <span class="operator">|</span> Msg_text                                                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+----------+----------+-------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> mysql_test.student <span class="operator">|</span> optimize <span class="operator">|</span> note     <span class="operator">|</span> <span class="keyword">Table</span> does <span class="keyword">not</span> support optimize, doing recreate <span class="operator">+</span> analyze instead <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql_test.student <span class="operator">|</span> optimize <span class="operator">|</span> status   <span class="operator">|</span> OK                                                                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+----------+----------+-------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">1.17</span> sec)</span><br></pre></td></tr></table></figure>

<p>  Msg_text 显示</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Table</span> does <span class="keyword">not</span> support optimize, doing recreate <span class="operator">+</span> analyze instead</span><br></pre></td></tr></table></figure>

<p>  是因为该表的存储引擎是 InnoDB。根据官网介绍，在 MyISAM中，实现分析这张表，然后会整理相关的 MySQL datafile，之后回收未使用的空间；在 InnoDB 中，回收空间是简单通过 Alter table 进行整理空间。在优化期间，MySQL 会创建一个临时表，优化完成之后会删除原始表，然后会将临时表 rename 成为原始表。</p>
<blockquote>
<p>说明：</p>
<p>在多数的设置中，根本不需要运行 OPTIMIZE TABLE。即使对可变长度的行进行了大量的更新，也不需要经常运行，每周一次或每月一次即可，并且只需要对特定的表运行。</p>
</blockquote>
</li>
<li><p>方式二：使用 mysqlcheck 命令</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlcheck <span class="operator">-</span>o DatabaseName TableName <span class="operator">-</span>uroot <span class="operator">-</span>p<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br></pre></td></tr></table></figure>

<p>  mysqlcheck 是 Linux 中的 rompt，-o 是代表 Optimize。</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-8-小结"><a href="#3-8-小结" class="headerlink" title="3.8 小结"></a>3.8 小结</h4><p>上述这些方法都是有利有弊的。比如：</p>
<ul>
<li>修改数据类型，节省存储空间的同时，要考虑到数据不能超过取值范围；</li>
<li>增加冗余字段的时候，不要忘了确保数据一致性；</li>
<li>把大表拆分，也意味着你的查询会增加新的连接，从而增加额外的开销和运维的成本。</li>
</ul>
<p>因此，你一定要结合实际的业务需求进行权衡。</p>
<h3 id="4-大表优化"><a href="#4-大表优化" class="headerlink" title="4. 大表优化"></a>4. 大表优化</h3><p>当 MySQL 单表记录数过大时，数据库的 CRUD 性能会明显下降，一些常见的优化措施如下：</p>
<h4 id="4-1-限定查询的范围"><a href="#4-1-限定查询的范围" class="headerlink" title="4.1 限定查询的范围"></a>4.1 限定查询的范围</h4><p><strong>禁止不带任何限制数据范围条件的查询语句</strong>。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。</p>
<h4 id="4-2-读-x2F-写分离"><a href="#4-2-读-x2F-写分离" class="headerlink" title="4.2 读&#x2F;写分离"></a>4.2 读&#x2F;写分离</h4><p>经典的数据库拆分方案，主库负责写，从库负责读。</p>
<ul>
<li><p>一主一从模式</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E4%B8%80%E4%B8%BB%E4%B8%80%E4%BB%8E%E6%A8%A1%E5%BC%8F.png" alt="一主一从模式"></p>
</li>
<li><p>双主双从模式</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E5%8F%8C%E4%B8%BB%E5%8F%8C%E4%BB%8E%E6%A8%A1%E5%BC%8F.png" alt="双主双从模式"></p>
</li>
</ul>
<h4 id="4-3-垂直拆分"><a href="#4-3-垂直拆分" class="headerlink" title="4.3 垂直拆分"></a>4.3 垂直拆分</h4><p>当数据量达到千万级以上时，有时候我们需要把一个数据库切分成多份，放到不同的数据库服务器上，减少对单一数据库服务器的访问压力。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87-1.png" alt="垂直拆分"></p>
<ul>
<li>如果数据库中的数据表过多，可以采用垂直分库的方式，将关联的数据表部署在同一个数据库上。</li>
<li>如果数据表中的列过多，可以采用垂直分表的方式，将一张数据表分拆成多张数据表，把经常一起使用的列放到同一张表里。</li>
</ul>
<p><strong>垂直拆分的有点</strong>：可以是的列数据变小，在查询时减少读取的 BLOCK 数，减少 IO 次数。此外，垂直分区可以简化表的结构，易于维护。</p>
<p><strong>垂直拆分的缺点</strong>：主键会出现冗余，需要管理冗余列，并会引起 JOIN 操作。此外，垂直拆分会让事物变得更加复杂。</p>
<h4 id="4-4-水平拆分"><a href="#4-4-水平拆分" class="headerlink" title="4.4 水平拆分"></a>4.4 水平拆分</h4><ul>
<li>尽量控制单表数据量的大小，建议控制在 1000 万以内。1000 万并不是 MySQL 数据库的限制，过大会造成修改表结构、备份、恢复都会有很大的问题。此时可以用历史数据归档 (应用于日志数据)，水平分表 (应用于业务数据) 等手段来控制数据量大小。</li>
<li>这里我们主要考虑业务数据的水平分表策略。将大的数据表按照某个属性维度分拆成不同的小表，每张小表保持相同的表结构。比如你可以按照年份来划分，把不同年份的数据放到不同的数据表中。2017 年、2018 年和 2019 年的数据就可以分别放到三张数据表中。</li>
<li>水平分表近视解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升 MySQL 并发能力没有什么意义，所以水平拆分最好分库，从而达到分布式的目的。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87-2.png" alt="水平拆分"></p>
<p>水平拆分能够支持非常大的数据量存储，应用端改造也少，但分片事物难以解决，跨界点 Join 性能较差，逻辑复杂。《Java 工程师修炼之道》 的作者推荐<strong>尽量不要对数据进行分片，因为拆分会到来逻辑、部署、运维的各种复杂度</strong>，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络 IO。</p>
<p>下面补充一下数据库分片的两种常见方案：</p>
<ul>
<li><strong>客户端代理：分片逻辑在应用端，封装在 jar 包里，通过修改或着封装 JDBC 层来实现</strong>。当当网的 Sharding-JDBC、阿里的 TDDL 是两种比较常用的实现。</li>
<li><strong>中间件代理：在应用层和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中</strong>。我们现在谈的 Mycat、360 的 Atlas、网易的 DDB 等等都是这种架构的实现。</li>
</ul>
<h3 id="5-其它调优策略"><a href="#5-其它调优策略" class="headerlink" title="5. 其它调优策略"></a>5. 其它调优策略</h3><h4 id="5-1-服务器语句超时处理"><a href="#5-1-服务器语句超时处理" class="headerlink" title="5.1 服务器语句超时处理"></a>5.1 服务器语句超时处理</h4><p>在 MySQL 8.0 中可以设置服务器语句超时的限制，单位可以达到毫秒级别。当中断的执行语句超过设置的毫秒数后，服务器将终止查询影响不大的事物或连接，然后将错误报给客户端。</p>
<p>设置服务器语句超时的限制，可以通过设置系统变量 MAX_EXECUTION_TIME 来实现。默认情况下，MAX_EXECUTION_TIME 的值为 0，代表没有时间限制。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> MAX_EXECUTION_TIME<span class="operator">=</span><span class="number">2000</span>;</span><br><span class="line"><span class="keyword">SET</span> SESSION MAX_EXECUTION_TIME<span class="operator">=</span><span class="number">2000</span>; # 指定该会话中 <span class="keyword">SELECT</span> 语句的超时时间</span><br></pre></td></tr></table></figure>

<h4 id="5-2-创建全局通用表空间"><a href="#5-2-创建全局通用表空间" class="headerlink" title="5.2 创建全局通用表空间"></a>5.2 创建全局通用表空间</h4><p>MySQL 8.0 使用 CREATE TABLESPACE 语句来创建一个全局通用表空间。全局表空间可以被所有的数据库的表共享，而且相比于独享表空间，<strong>使用手动创建共享空间可以节约元数据方面的内存</strong>。可以在创建表的时候，指定属于哪个表空间，也可以对已有表进行表空间修改等。</p>
<p>下面创建名为 test1 的共享表空间，SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE test1 <span class="keyword">ADD</span> datafile `test1.ibd` file_block_size<span class="operator">=</span><span class="number">16</span>k;</span><br><span class="line"></span><br><span class="line"># 指定表空间，<span class="keyword">SQL</span> 语句如下：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">10</span>)) engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset utf8mb4 tablespace test1;</span><br><span class="line"></span><br><span class="line"># 也可以通过 <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 语句指定表空间</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test tablespace test1;</span><br></pre></td></tr></table></figure>

<p>因为是共享表空间，所以不能直接通过 drop table tbname 删除，这样操作并不能回收空间。当确定共享表空间的数据都没用，并且依赖该表空间的表均已经删除时，可以通过 drop tablespace 删除共享表空间来释放空间，如果依赖该共享表空间的表存在，就会删除失败。如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> TABLESPACE test1;</span><br><span class="line">Tablespace <span class="string">&#x27;test1&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> empty.</span><br></pre></td></tr></table></figure>

<p>所以应该首先删除依赖该表空间的数据表，SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> test;</span><br></pre></td></tr></table></figure>

<p>最后即可删除表空间，SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> TABLESPACE test1;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-MySQL-8-0-新特性：隐藏索引对调优的帮助"><a href="#5-3-MySQL-8-0-新特性：隐藏索引对调优的帮助" class="headerlink" title="5.3 MySQL 8.0 新特性：隐藏索引对调优的帮助"></a>5.3 MySQL 8.0 新特性：隐藏索引对调优的帮助</h4><p>不可见索引的特性对于性能调试非常有用。在 MySQL 8.0 中，索引可以被隐藏和显示。当一个索引被隐藏时，它不会被查询优化器所使用。也就是说，管理员可以隐藏一个索引，然后观察对数据库的影响。如果数据库性能有所下降，就说明这个索引是有用的，于是将其恢复显示即可；如果数据库性能看不出变化，就说明这个索引是多余的，可以删掉了。</p>
<p>需要注意的是当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p>
<p>数据表中的主键不能被设置为 invisible。</p>
<h2 id="十一、事务基础知识"><a href="#十一、事务基础知识" class="headerlink" title="十一、事务基础知识"></a>十一、事务基础知识</h2><h3 id="1-数据库事务概述"><a href="#1-数据库事务概述" class="headerlink" title="1. 数据库事务概述"></a>1. 数据库事务概述</h3><p>事务是数据库区别于文件系统的重要特性之一，当我们有了事务就会让数据库始终保持一致性，同时我们还能通过事务的机制恢复到某个时间点，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失。</p>
<h4 id="1-1-存储引擎支持情况"><a href="#1-1-存储引擎支持情况" class="headerlink" title="1.1 存储引擎支持情况"></a>1.1 存储引擎支持情况</h4><p>SHOW ENGINES 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> engines;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> Engine             <span class="operator">|</span> Support <span class="operator">|</span> Comment                                                        <span class="operator">|</span> Transactions <span class="operator">|</span> XA   <span class="operator">|</span> Savepoints <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> ARCHIVE            <span class="operator">|</span> YES     <span class="operator">|</span> Archive storage engine                                         <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLACKHOLE          <span class="operator">|</span> YES     <span class="operator">|</span> <span class="operator">/</span>dev<span class="operator">/</span><span class="keyword">null</span> storage engine (anything you write <span class="keyword">to</span> it disappears) <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MRG_MYISAM         <span class="operator">|</span> YES     <span class="operator">|</span> Collection <span class="keyword">of</span> identical MyISAM tables                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FEDERATED          <span class="operator">|</span> <span class="keyword">NO</span>      <span class="operator">|</span> Federated MySQL storage engine                                 <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MyISAM             <span class="operator">|</span> YES     <span class="operator">|</span> MyISAM storage engine                                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> PERFORMANCE_SCHEMA <span class="operator">|</span> YES     <span class="operator">|</span> Performance Schema                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> InnoDB             <span class="operator">|</span> <span class="keyword">DEFAULT</span> <span class="operator">|</span> Supports transactions, <span class="type">row</span><span class="operator">-</span>level locking, <span class="keyword">and</span> <span class="keyword">foreign</span> keys     <span class="operator">|</span> YES          <span class="operator">|</span> YES  <span class="operator">|</span> YES        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MEMORY             <span class="operator">|</span> YES     <span class="operator">|</span> Hash based, stored <span class="keyword">in</span> memory, useful <span class="keyword">for</span> temporary tables      <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CSV                <span class="operator">|</span> YES     <span class="operator">|</span> CSV storage engine                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br></pre></td></tr></table></figure>

<p>能看出在 MySQL中国呢，只有 InnoDB 是支持事务的。</p>
<h4 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2 基本概念"></a>1.2 基本概念</h4><p><strong>事务</strong>：一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p>
<p><strong>事物处理的原则</strong>：保证所有事物都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事物都被提交 (commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事物回滚 (rollback) 到最初状态。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 案例：AA用户给BB用户转账<span class="number">100</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;AA&#x27;</span>;</span><br><span class="line"># 服务器宕机</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;BB&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-事物的-ACID-特性"><a href="#1-3-事物的-ACID-特性" class="headerlink" title="1.3 事物的 ACID 特性"></a>1.3 事物的 ACID 特性</h4><ul>
<li><p><strong>原子性 (Atomicity)</strong></p>
<p>  原子性是指事物是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。即要么转账成功，要么转账失败，是不存在中间的状态。如果无法保证原子性会怎么样？就会出现数据不一致的情形，A 账户减去 100 元，而 B 账户增加 100 元操作失败，系统将无故丢失 100 元。</p>
</li>
<li><p><strong>一致性 (Consistency)</strong></p>
<p>  根据定义，一致性是指事务执行前后，数据从一个合法性状态变换到另一个合法性状态。这种状态是语义上的而不是语法上的，跟具体的业务有关。</p>
<p>  满足约定的约束的状态就叫做合法的状态。通俗一点，这状态是由自己来定义的 (比如满足现实世界中的约束)。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的！如果事物中的某个操作失败了，系统就会自动撤销当前正在执行的事物，返回到事物操作之前的状态。</p>
<p>  举例：A 账户有 200 元，转账 300 元出去，此时 A 账户余额为 -100 元。你自然就发现了此时数据是不一致的，为什么呢？因为你定义了一个状态，余额这列必须 &gt;&#x3D; 0。如果 A 转账 50 给 B 账户，但是 B 账户由于种种原因没有收到，此时数据也是不一致的，因为 A 和 B 账户的总金额必须不变。</p>
</li>
<li><p><strong>隔离性 (Isolation)</strong></p>
<p>  事物的隔离性是指一个事务的执行不能被其他事物干扰，即一个事务内部的操作及使用的数据对并发的其它事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>  如果无法保证隔离性会怎么样？假设 A 账户有 200 元，B 账户 0 元。A 账户往 B 账户转账两次，每次金额为 50 元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">50</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;AA&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">50</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;BB&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E9%9A%94%E7%A6%BB%E6%80%A7%E6%A1%88%E4%BE%8B.png" alt="隔离性案例"></p>
</li>
<li><p><strong>持久性 (Durability)</strong></p>
<p>  持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其它操作和数据库故障不应该对其有任何影响。</p>
<p>  持久性是通过事务日志来保证的。日志包括了重做日志和回滚日志。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p>
<blockquote>
<p>总结</p>
<p>ACID 是事务的四大特性，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件，而持久性时我们的目的。</p>
<p>数据库事务，其实就是数据库设计者为了方便起见，把需要保证原子性、隔离性、一致性和持久性的一个或多个数据库操作称为一个事务。</p>
</blockquote>
</li>
</ul>
<h4 id="1-4-事务的状态"><a href="#1-4-事务的状态" class="headerlink" title="1.4 事务的状态"></a>1.4 事务的状态</h4><p>事务是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL 根据这些操作所执行的不同阶段把事务大致划分成几个状态：</p>
<ul>
<li><p><strong>活动的 (Active)</strong></p>
<p>  事务对应的数据库操作正在执行过程中时，该事务处于活动的状态。</p>
</li>
<li><p><strong>部分提交的 (Partially committed)</strong></p>
<p>  当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态。</p>
</li>
<li><p><strong>失败的 (Failed)</strong></p>
<p>  当事务处在活动的活着部分提交的状态时，可能遇到了某些错误 (数据库自身的错误、操作系统错误或者直接断电等) 而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态。</p>
</li>
<li><p><strong>中止的 (Aborted)</strong></p>
<p>  如果事务执行了一部分而变为失败的状态，那么就需要把意境修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为回滚。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。</p>
</li>
<li><p><strong>提交的 (Committed)</strong></p>
<p>  当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了提交的状态。一个基本的状态转换图如下所示：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt="状态转换图"></p>
</li>
</ul>
<h3 id="2-如何使用事物"><a href="#2-如何使用事物" class="headerlink" title="2. 如何使用事物"></a>2. 如何使用事物</h3><p>使用事务有两种方式，分别为显式事务和隐式事务。</p>
<h4 id="2-1-显式事务"><a href="#2-1-显式事务" class="headerlink" title="2.1 显式事务"></a>2.1 显式事务</h4><p><strong>步骤一</strong>：<code>START TRANSACTION</code> 或者 <code>BEGIN</code>，作用是显式开启一个事务。</p>
<p><code>START TRANSACTION</code> 语句相较于 <code>BEGIN</code> 特别之处在于，后边能跟随几个修饰符：</p>
<ul>
<li><p><code>READ ONLY</code>：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p>
<blockquote>
<p>补充：只读事务中知识不允许修改那些其它事务也能访问到的表中的数据，对于临时表来说 (我们使用 <code>CREATE TMEPORARY TABLE</code> 创建的表)，由于它们只能在当前会话中可见，所有只读事务其实也是可以对临时表进行增、删、改操作的。</p>
</blockquote>
</li>
<li><p><code>READ WRITE</code>：标识当前事务是一个读写事务，也就是属于该事务的数据库操作即可以读取数据，也可以修改数据。</p>
</li>
<li><p><code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读。</p>
</li>
</ul>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION READ <span class="keyword">ONLY</span>;# 开启一个只读事务</span><br><span class="line"><span class="keyword">START</span> TRANSACTION READ <span class="keyword">ONLY</span>, <span class="keyword">WITH</span> CONSISTENT SNAPSHOT;# 开启只读事务和一致性读</span><br><span class="line"><span class="keyword">START</span> TRANSACTION READ WRITE, <span class="keyword">WITH</span> CONSISTENT SNAPSHOT;# 开启读写事务和一致性读</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p><code>READ ONLY</code> 和 <code>READ WRITE</code> 是用来设置所谓的事务访问模式的，就是以只读还是读写的方式来访问数据库中的数据，一个事务的访问模式不能同时既设置为只读的也设置为读写的，所以不能同时把 <code>READ ONLY</code> 和 <code>READ WRITE</code> 放到 <code>START TRANSACTION</code> 语句后边。如果我们不显式指定事务的访问模式，那么该事务的访问模式就是读写模式。</p>
<p><strong>步骤二</strong>：一系列事务中的操作 (主要是 DML，不含 DDL)</p>
<p><strong>步骤三</strong>：提交事务或中止事务 (即回滚事务)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 提交事务。当提交事务后，对数据库的修改是永久性的。</span><br><span class="line"><span class="keyword">COMMIT</span>；</span><br><span class="line"># 回滚事务，即撤销正在进行的所有没有提交的修改</span><br><span class="line"><span class="keyword">ROLLBACK</span>；</span><br><span class="line"># 将事务回滚到某个保存点</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> [<span class="keyword">SAVEPOINT</span>]</span><br></pre></td></tr></table></figure>

<p>其中关于 SAVEPOINT 相关操作有：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。</span><br><span class="line"><span class="keyword">SAVEPOINT</span> 保存点名称;</span><br><span class="line"># 删除某个保存点</span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> 保存点名称;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-隐式事务"><a href="#2-2-隐式事务" class="headerlink" title="2.2 隐式事务"></a>2.2 隐式事务</h4><p>MySQL 中有一个系统变量 <code>autocommit</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;autocommit&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> autocommit    <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，如我我们不显式的使用 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的自动提交。也就是说，不以 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 语句显式的开启一个事务，那么下边这两条语句就相当于放到两个独立的事务中去执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">10</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">10</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>当然，如果我们想关闭这种自动提交的功能，可以使用下边两种方法之一：</p>
<ul>
<li><p>显式的使用 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</p>
</li>
<li><p>把系统变量 autocommit 的值设置为 off，就像这样：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> OFF;</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这样的话，我们写入的多条语句就算是属于同一个事务了，直到我们显式的写出 COMMIT 语句来把这个事务提交掉，或者显式的写出 ROLLBACK 语句来把这个事务回滚掉。</p>
<blockquote>
<p>补充：Oracle 默认不自动提交，需要手写 COMMIT 命令，而 MySQL 默认自动提交。</p>
</blockquote>
<h4 id="2-3-隐式提交数据的情况"><a href="#2-3-隐式提交数据的情况" class="headerlink" title="2.3 隐式提交数据的情况"></a>2.3 隐式提交数据的情况</h4><ul>
<li><p><strong>数据定义语言 (DDL)</strong></p>
<p>  数据库对象，指的就是数据库、表、视图、存储过程等结构。当我们使用 CREATE、ALTER、DROP 等语句去修改数据库对象时，就会隐式的提交前边语句所属于的事务。即：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">SELECT...</span><br><span class="line">UPDATE...</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ...# 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>隐式使用或修改 mysql 数据库中的表</strong></p>
<p>  当我们使用 <code>ALTER USER</code>、<code>UPDATE USER</code>、<code>DROP USER</code>、<code>GRANT</code>、<code>RENAME USER</code>、<code>ALTER USER</code>、<code>REVOKE</code>、<code>SET PASSWORD</code> 等语句时也会隐式的提交前边语句所属于的事务。</p>
</li>
<li><p>事务控制或关于锁定的语句</p>
<p>  当我们在一个事务还没提交或者回滚时就又使用 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 语句开启了另一个事务时，会隐式的提交上一个事务。即：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">UPDATE</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;# 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure>

<p>  当前的 autocommit 系统变量的值为 OFF，我们手动把它调整为 ON 时，也会隐式的提交前边语句所属的事务。</p>
<p>  使用 <code>LOCK TABLES</code>、<code>UNLOCK TABLES</code> 等关于锁定的语句也会隐式的提交前边语句所属的事务。</p>
</li>
<li><p>加载数据的语句</p>
<p>  使用 <code>LOAD DATA</code> 语句来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务。</p>
</li>
<li><p>关于 MySQL 复制的一些语句</p>
<p>  使用 <code>START SLAVE</code>、<code>STOP SLAVE</code>、<code>RESET SLAVE</code>、<code>CHANGE MASTER TO</code> 等语句时会隐式的提交前边语句所属的事务。</p>
</li>
<li><p>其它的一些语句</p>
<p>  使用 <code>ANALYZE TABLE</code>、<code>CACHE INDEX</code>、<code>CHECK TABLE</code>、<code>FLUSH</code>、<code>LOAD INDEX INTO CACHE</code>、<code>OPTIMIZE TABLE</code>、<code>REPAIR TABLE</code>、<code>RESET</code> 等语句也会隐式的提交前边语句所属的事务。</p>
</li>
</ul>
<h3 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3. 事务隔离级别"></a>3. 事务隔离级别</h3><p>MySQL 是一个客户端 &#x2F; 服务器架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接之后，就可以称为一个会话 (Session)。每个客户端都可以在自己的会话中想服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。事务由隔离性的特性，理论上在某个事务对某个数据进行访问时，其它事务应该进行 排队，当该事务提交之后，其它事务才可以继续访问这个数据。但是这样对性能影响太大，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，那就看二者如何权衡取舍了。</p>
<h4 id="3-1-数据准备-2"><a href="#3-1-数据准备-2" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">	studentno <span class="type">INT</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  class <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (studentno)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;小姑娘&#x27;</span>, <span class="string">&#x27;1班&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-数据并发问题"><a href="#3-2-数据并发问题" class="headerlink" title="3.2 数据并发问题"></a>3.2 数据并发问题</h4><p>针对事务的隔离性和并发性，我们怎么做取舍呢？先看一下访问相同数据的事务在不保证串行执行 (也就是执行完一个在执行另一个) 的情况下可能会出现哪些问题：</p>
<ul>
<li><p><strong>脏写 (Dirty Write)</strong></p>
<p>  对于两个事务 Session A、Session B，如果事务 Session A 修改了另一个未提交事务 Session B 修改过的数据，那就意味着发生了脏写，示意图如下：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E8%84%8F%E5%86%99%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="脏写示意图"></p>
<p>  Session A 和 Session B 各开启了一个事务，Session B 中的事务先将 studentno 列为 1 的记录的 name 列更新为 ‘李四’，然后 Session A 中的事务接着又把这条 studentno 列为 1 的记录的 name 列更新为 ‘张三’。如果之后 Session B 中的事务进行了回滚，那么 Session A 中的更新也将不复存在，这种现象就称之为脏写。这时 Session A 中的事务就没有效果了，明明把数据更新了，最后也提交事物了，最后看到的数据什么变化也没有。这里大家对事务的隔离级别比较了解的话，会发现默认隔离级别下，上面 Session A 中的更新语句会处于等待状态，这里知识跟大家说明一下会出现这样现象。</p>
</li>
<li><p><strong>脏读 (Dirty Read)</strong></p>
<p>  对于两个事务 Session A、Session B，Session A 读取了已经被 Session B 更新但还没有被提交的字段。之后若 Session B 回滚，Session A 读取的内容就是临时且无效的。</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E8%84%8F%E8%AF%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="脏读示意图"></p>
<p>  Session A 和 Session B 各开启了一个事务，Session B 中的事务先将 studentno 列为 1 的记录的 name 列更新为 ‘张三’，然后 Session A 中的事务再去查询这条 studentno 为 1 的记录，如果读到列 name 的值为 ‘张三’，而 Session B 中的事务稍后进行了回滚，那么 Session A 中的事务相当于读到了一个不存在的数据，这种现象就称之为脏读。</p>
</li>
<li><p><strong>不可重复读 (Non-Repeatable Read)</strong></p>
<p>  对于两个事务 Session A、Session B，Session A 读取了一个字段，然后 Session B 更新了该字段。之后 Session A 再次读取同一个字段，值就不同了。那就意味着发生了不可重复读。</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="不可重复读示意图"></p>
<p>  我们在 Session B 中提交了几个 隐式事务 (注意是隐式事务，意味着语句结束事务就提交了)，这些事务都修改了 studentno 列为 1 的记录的列 name 的值，每次事物提交之后，如果 Session A 中的事务都可以查看到最新的值，这种现象也被称之为 不可重复读。</p>
</li>
<li><p><strong>幻读 (Phantom)</strong></p>
<p>  对于两个事务 Session A、Session B，Session A 从一个表中读取了一个字段，然后 Session B 在该表中插入了一些新的行。之后，如果 Session A 再次读取同一个表，就会多出几行。那就意味着发生了幻读。</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/myslq/%E5%B9%BB%E8%AF%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="幻读示意图"></p>
<p>  Session A 中的事务先根据条件 studentno &gt; 0 这个条件查询表 student，得到了列值为 ‘张三’ 的记录；之后 Session B 中提及哦啊了一个隐式事务，该事务向表 student 中插入了一条新纪录；之后 Session A 中的事务再根据相同的条件 studentno &gt; 0 查询表 student，得到的结果集中包含 Session B 中的事务新插入的那条记录，这种现象也被称之为幻读。我们把新插入的那些记录称之为 幻影记录。</p>
<p>  <strong>注意 1</strong>：</p>
<p>  如果 Session B 中删除了一些符合 studentno &gt; 0 的记录而不是插入新纪录，那 Session A 之后再根据 studentno &gt; 0 的条件读取的记录变少了，这种现象算不算幻读呢？这种现象不属于幻读，幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</p>
<p>  <strong>注意 2</strong>：</p>
<p>  那对于先前已经读到的记录，之后又读不到的情况呢？这相当于对每一条记录都发生了不可重复读的现象。幻读只是重点强调了读取到了之前读取没有获取到的记录。</p>
</li>
</ul>
<h4 id="3-3-SQL-中的四种隔离级别"><a href="#3-3-SQL-中的四种隔离级别" class="headerlink" title="3.3 SQL 中的四种隔离级别"></a>3.3 SQL 中的四种隔离级别</h4><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题按照严重性来排一下序 ：</p>
<blockquote>
<p>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p>
</blockquote>
<p>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。SQL 标准中设立了 4 个隔离级别：</p>
<ul>
<li><code>READ UNCOMMITTED</code>：读未提交，在该隔离级别，所有事物都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li>
<li><code>READ COMMITTED</code>：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别 (但不是 MySQL 默认的)。可以避免脏读，但不可重复读、幻读问题仍然存在。</li>
<li><code>REPEATABLE READ</code>：可重复读，事务 A 在读到一条数据之后，此时事务 B 对该数据进行了修改并提交，那么事务 A 再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这时 MySQL 的默认隔离级别。</li>
<li><code>SERIALIZABLE</code>：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其它事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li>
</ul>
<p>SQL 标准中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读可能性</th>
<th>不可重复读可能性</th>
<th>幻读可能性</th>
<th>加锁读</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCONMITED</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>READ COMMITED</td>
<td>NO</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
</tr>
</tbody></table>
<p>脏写怎么没涉及到？因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</p>
<p>不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4 种事务隔离级别与并发性能的关系如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="四种事务隔离级别与并发性能的关系.png"></p>
<h4 id="3-4-MySQL-支持的四种隔离级别"><a href="#3-4-MySQL-支持的四种隔离级别" class="headerlink" title="3.4 MySQL 支持的四种隔离级别"></a>3.4 MySQL 支持的四种隔离级别</h4><p>不同的数据库厂商对 SQL 标准中规定的四种隔离级别支持不一样。比如，Oracle 就只支持 <code>READ COMMITTED (默认隔离级别)</code> 和 <code>SERIALIZABLE 隔离级别</code>。MySQL 虽然支持 4 种隔离级别，但与 SQL 标准中所规定的各级隔离级别允许发生的问题却有些出入，MySQL 在 REPEATABLE READ 隔离级别下，是可以禁止幻读问题的发生的。</p>
<p>MySQL 的默认隔离级别为 REPEATABLE READ，可以手动修改一下事务的隔离级别。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 查看隔离级别，MySQL <span class="number">5.7</span><span class="number">.20</span> 的版本之前：</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;tx_isolation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name         <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> tx_isolation 					<span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"></span><br><span class="line"># MySQL <span class="number">5.7</span><span class="number">.20</span> 版本之后，引入 transaction_isolation 来替换 tx_isolation</span><br><span class="line"></span><br><span class="line"># 查看隔离级别，MySQL <span class="number">5.7</span><span class="number">.20</span> 的版本及之后：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name         <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> transaction_isolation <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"></span><br><span class="line"># 或者不同 MySQL 版本中都可以使用的：</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-如何设置事务的隔离级别"><a href="#3-5-如何设置事务的隔离级别" class="headerlink" title="3.5 如何设置事务的隔离级别"></a>3.5 如何设置事务的隔离级别</h4><p>通过下面的语句修改事务的隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span> <span class="operator">|</span> SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;</span><br><span class="line"># 其中，隔离级别格式：</span><br><span class="line"><span class="operator">&gt;</span> READ UNCOMMITTED</span><br><span class="line"><span class="operator">&gt;</span> READ COMMITTED</span><br><span class="line"><span class="operator">&gt;</span> REPEATABLE READ</span><br><span class="line"><span class="operator">&gt;</span> SERIALIZABLE</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span> <span class="operator">|</span> SESSION] TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;隔离级别&#x27;</span></span><br><span class="line"># 其中，隔离级别格式：</span><br><span class="line"><span class="operator">&gt;</span> READ<span class="operator">-</span>UNCOMMITTED</span><br><span class="line"><span class="operator">&gt;</span> READ<span class="operator">-</span>COMMITTED</span><br><span class="line"><span class="operator">&gt;</span> REPEATABLE<span class="operator">-</span>READ</span><br><span class="line"><span class="operator">&gt;</span> SERIALIZABLE</span><br></pre></td></tr></table></figure>

<p>关于设置时使用 GLOBAL 或 SESSION 的影响：</p>
<ul>
<li><p>使用 GLOBAL 关键字 (在全局范围影响)：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line"># 或</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;SERIALIZABLE&#x27;</span></span><br></pre></td></tr></table></figure>

<p>  则：</p>
<ul>
<li>当前已经存在的会话无效</li>
<li>只对执行完该语句之后产生的会话起作用</li>
</ul>
</li>
<li><p>使用 SESSION 关键字 (在会话范围影响)：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line"># 或</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;SERIALIZABLE&#x27;</span></span><br></pre></td></tr></table></figure>

<p>  则：</p>
<ul>
<li>对当前会话的所有后续的事务有效</li>
<li>如果在事物之间执行，则对后续的事务有效</li>
<li>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</li>
</ul>
</li>
</ul>
<p>如果在服务器启动时想改变事务的默认隔离级别，可以修改启动参数 <code>TRANSACTION_ISOLATION</code> 的值。比如，在启动服务器时制定了 <code>TRANSACTION_ISOLATION = SERIALIZABLE</code>，那么事务的默认隔离级别就从原来的 <code>REPEATABLE-READ</code> 变成了 <code>SERIALIZABLE</code>。</p>
<h2 id="十二、MySQL-事务日志"><a href="#十二、MySQL-事务日志" class="headerlink" title="十二、MySQL 事务日志"></a>十二、MySQL 事务日志</h2><p>事务有 4 种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p>
<ul>
<li>事务的隔离性由锁机制实现。</li>
<li>而事务的原子性、一致性和持久性由事务的 redo 日志和 undo 日志来保证。<ul>
<li>REDO LOG 称为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li>
<li>UNDO LOG 称为回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li>
</ul>
</li>
</ul>
<p>有的 DBA 或许会认为 UNDO 是 REDO 的逆过程，其实不然。REDO 和 UNDO 都可以视为一种恢复操作，但是：</p>
<ul>
<li>REDO LOG：是存储引擎层 (innodb) 生成的日志，记录的是物理级别上的页修改操作，比如页号xxx、偏移量yyy写入了zzz数据。主要为了保证数据的可靠性；</li>
<li>UNDO LOG：是存储引擎层 (innodb) 生成的日志，记录的是逻辑操作日志，比如对某一行数据进行了 INSERT 语句操作，那么 UNDO LOG 就记录一条与之相反的 DELETE 操作。主要用于事务的回滚 (UNDO LOG 记录的是每个修改操作的逆操作) 和一致性非锁定读 (UNDO LOG 回滚行记录到某种特定的版本——MVCC，即多版本并发控制)。</li>
</ul>
<h3 id="1-redo-日志"><a href="#1-redo-日志" class="headerlink" title="1. redo 日志"></a>1. redo 日志</h3><p>InnoDB 存储引擎是以页为单位来管理存储空间的。在真正访问页面之前，需要把磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访问。所有的变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页会以一定的频率被刷入磁盘 (checkPoint 机制)，通过缓冲池来优化 CPU 和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p>
<h4 id="1-1-为什么需要-REDO-日志"><a href="#1-1-为什么需要-REDO-日志" class="headerlink" title="1.1 为什么需要 REDO 日志"></a>1.1 为什么需要 REDO 日志</h4><p>一方面，缓冲池可以帮助我们消除 CPU 和磁盘之间的鸿沟，checkpoint 机制可以保证数据的最终落盘，然而由于 checkpoint 并不是每次变更的时候就触发的，而是 master 线程隔一段时间去处理的。所以最坏的情况是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就丢失的，无法恢复。</p>
<p>另一方面，事务包含持久性的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库所做的更改也不能丢失。</p>
<p>那么如何保证这个持久性呢？一个简单的做法：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题：</p>
<ul>
<li><p>修改量与刷新磁盘工作量严重不成比例</p>
<p>  有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在 InnoDB 中是以页为单位来进行磁盘 IO 的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是 16KB 大小，只修改一个字节就要刷新 16KB 的数据到磁盘上显然是太小题大做了。</p>
</li>
<li><p>随机 IO 刷新较慢</p>
<p>  一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的 Buffer Pool 中的页面刷新到磁盘时，需要进行很多的随机 IO，随机 IO 比顺序 IO 要慢，尤其对于传统的机械硬盘来说。</p>
</li>
</ul>
<p>另一个解决的思路：我们只是想让已经提交了的事务对数据库中数据所作的修改永久有效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好。比如，某个事务将系统表空间中第 10 号页面中偏移量为 100 处的那个字节的值 1 改为 2。我们只需要记录一下：将第 0 号表空间的 10 号页面的偏移量为 100 处的值更新为 2。</p>
<p>InnoDB 引擎的事务采用了 WAL (Write-Ahead Logging)，这种技术的思想就是先写日志，在写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是 redo log。当发生宕机且数据未刷到磁盘的时候，可以通过 redo log 来回复，保证 ACID 中的 D，这就是 redo log 的作用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/redo%E6%A6%82%E5%BF%B5%E5%9B%BE.png" alt="redo概念图"></p>
<h4 id="1-2-REDO-日志的好处、特点"><a href="#1-2-REDO-日志的好处、特点" class="headerlink" title="1.2 REDO 日志的好处、特点"></a>1.2 REDO 日志的好处、特点</h4><p><strong>好处</strong>：</p>
<ul>
<li>redo 日志降低了刷盘频率</li>
<li>redo 日志占用的空间非常小</li>
</ul>
<p>存储表空间 ID、页号、偏移量以及需要更新的值，所需的存储空间是很小的，刷盘快。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>redo 日志是顺序写入磁盘的</li>
</ul>
<p>在执行事务的过程中，没执行一条语句，就可能产生若干条 redo 日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序 IO，效率比随机 IO 快。</p>
<ul>
<li>事务执行过程中，redo log 不断记录</li>
</ul>
<p>redo log 跟 bin log 的区别，redo log 是存储引擎层产生的，而 bin log 是数据库层产生的。假设一个事务，对表做 10 万行的记录插入，在这个过程中，一直不断往 redo log 顺序记录，而 bin log 不会记录，直到这个事务提交，才会一次写入到 bin log 文件中。</p>
<h4 id="1-3-redo-的组成"><a href="#1-3-redo-的组成" class="headerlink" title="1.3 redo 的组成"></a>1.3 redo 的组成</h4><p>Redo log 可以简单分为以下两个部分：</p>
<ul>
<li><p>重做日志的缓冲 (redo log buffer)，保存在内存中，是易失的。</p>
<p>  在服务器启动时就向操作系统申请了一大片称之为 redo log buffer 的连续内存空间，翻译成中文就是 redo 日志缓冲区。这片内存空间被划分成若干个连续的 redo log block。一个 redo log block 占用 512 字节大小。</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/logbuffer%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="logbuffer结构示意图"></p>
<p>  <strong>参数设置：innodb_log_buffer_size：</strong></p>
<p>  redo log buffer 大小，默认 16M，最大值时 4096M，最小值为 1M。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%innodb_log_buffer_size%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name          <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_log_buffer_size <span class="operator">|</span> <span class="number">16777216</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重做日志文件 (redo log file)，保存在硬盘中，是持久的。</p>
<p>  REDO 日志文件如图所示，其中的 ib_logfile0 和 ib_logfile1 即为 REDO 日志。</p>
</li>
</ul>
<h4 id="1-4-redo-的整体流程"><a href="#1-4-redo-的整体流程" class="headerlink" title="1.4 redo 的整体流程"></a>1.4 redo 的整体流程</h4><p>以一个更新事务为例，redo log 流转过程，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/%E6%9B%B4%E6%96%B0%E4%BA%8B%E5%8A%A1redolog.png" alt="更新事务"></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝</span><br><span class="line">第二步：生成一条重做日志并写入 redo log buffer，记录的是数据被修改后的值</span><br><span class="line">第三步：当事务 commit 时，将 redo log buffer 中的内容刷新到 redo log file，对 redo log file 采用追加写的方式</span><br><span class="line">第四步：定期将内存中修改的数据刷新到磁盘中</span><br></pre></td></tr></table></figure>

<blockquote>
<p>体会：</p>
<p>Write-Ahead Log (预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。</p>
</blockquote>
<h4 id="1-5-redo-log-的刷盘策略"><a href="#1-5-redo-log-的刷盘策略" class="headerlink" title="1.5 redo log 的刷盘策略"></a>1.5 redo log 的刷盘策略</h4><p>redo log 的写入并不是直接写入磁盘的，InnoDB 引擎会在写 redo log 的时候先写 redo log buffer，之后以一定的频率刷入到真正的 redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/redolog%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5.png" alt="redo刷盘"></p>
<p>注意，redo log buffer 刷盘到 redo log file 的过程并不是真正的刷到磁盘中去，只是刷入到文件系统缓存 (page cache) 中去 (这是现代操作系统为了提高文件写入效率做的一个优化)，真正的写入会交给系统自己来决定 (比如 page cache 足够大了)。那么对于 InnoDB 来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了 (虽然整个系统宕机的概率还是比较小的)。</p>
<p>针对这种情况，InnoDB 给出 <code>innodb_flush_log_at_trx_commit</code> 参数，该参数控制 commit 提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p>
<ul>
<li>设置为 0：表示每次事务提交时不进行刷盘操作。(系统默认 master thread 每隔 1s 进行一次重做日志的同步)</li>
<li>设置为 1：表示每次事务提交时都将进行同步，刷盘操作 (默认值)</li>
<li>设置为 2：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由 os 自己决定什么时候同步到磁盘文件。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_flush_log_at_trx_commit&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                  <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_flush_log_at_trx_commit <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+-------+</span></span><br></pre></td></tr></table></figure>

<p>另外，InnoDB 存储引擎有一个后台线程，每隔 1 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存 (page cache)，然后调用刷盘操作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/redolog%E5%88%B7%E7%9B%98-1.png" alt="redolog刷盘"></p>
<p>也就是说，一个没有提交事务的 redo log 记录，也可能会刷盘。因为在事务执行过程 redo log 记录是会写入 redo log buffer 中，这些 redo log 记录会被后台线程刷盘。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/redolog%E5%88%B7%E7%9B%98-2.png" alt="redolog刷盘"></p>
<p>除了后台线程每秒 1 次的轮训操作，还有一种情况，当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size (这个参数默认是 16M) 的一半的时候，后台线程会主动刷盘。</p>
<h4 id="1-6-不同刷盘策略演示"><a href="#1-6-不同刷盘策略演示" class="headerlink" title="1.6 不同刷盘策略演示"></a>1.6 不同刷盘策略演示</h4><ul>
<li><p>流程图</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/innodb_flush_log_at_trx_commit%E4%B8%BA1.png" alt="刷盘策略流程图"></p>
<blockquote>
<p>小结：innodb_flush_log_at_trx_commit&#x3D;1</p>
<p>为 1 时，只要事务提交成功，redo log 记录就一定在硬盘里，不会有任何数据丢失。</p>
<p>如果事务执行期间 MySQL 挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。可以保证 ACID 的 D，数据绝对不会丢失，但是效率最差的。</p>
<p>建议使用默认值，虽然操作系统宕机的概率理论小于数据库宕机的概率，但是一般既然使用了事务，那么数据的安全相对来说更重要些。</p>
</blockquote>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/innodb_flush_log_at_trx_commit%E4%B8%BA2.png" alt="innodb_flush_log_at_trx_commit=2"></p>
<blockquote>
<p>小结：innodb_flush_log_at_trx_commit&#x3D;2</p>
<p>为 2 时，只要事务提交成功，redo log buffer 中的内容只写入文件系统缓存 (page cache)。</p>
<p>如果仅仅只是 MySQL 挂了不会有任何数据丢失，但是操作系统宕机可能会有 1 秒数据的丢失，这种情况下无法满足 ACID 中的 D。但是数值 2 肯定是效率最高的。</p>
</blockquote>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/innodb_flush_log_at_trx_commit%E4%B8%BA0.png" alt="innodb_flush_log_at_trx_commit为0"></p>
<blockquote>
<p>小结：innodb_flush_log_at_trx_commit&#x3D;0</p>
<p>为 0 时，master thread 中每 1 秒进行一次重做日志的 fsync 操作，因此实例 crash 最多丢失 1 秒钟内的事务。(master thread 是负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性)</p>
<p>数值 0 的话，是一种折中的做法，它的 IO 效率理论是高于 1 的，低于 2 的，这种策略也有丢失数据的风险，也无法保证 D。</p>
</blockquote>
</li>
</ul>
<h4 id="1-7-写入-redo-log-buffer-过程"><a href="#1-7-写入-redo-log-buffer-过程" class="headerlink" title="1.7 写入 redo log buffer 过程"></a>1.7 写入 redo log buffer 过程</h4><p><strong>1. 补充概念：Mini-Transaction</strong></p>
<p>MySQL 把对底层页面中的一次源自访问的过程称之为一个 <code>Mini-Transaction</code>，简称 <code>mtr</code>，比如，像某个索引对应的 B+ 树中插入一条记录的过程就是一个 <code>Mini-Transaction</code>。一个所谓的 <code>mtr</code> 可以包含一组 redo 日志，在进行崩溃恢复时这一组 <code>redo</code> 日志作为一个不可分割的整体。</p>
<p>一个事物可以包含若干条语句，每一条语句其实是由若干个 <code>mtr</code> 组成，每一个 <code>mtr</code> 又可以包含若干条 redo 日志，画个图表表示他们的关系就是这样：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230130150340421.png" alt="image-20230130150340421" style="zoom:50%;" />

<p><strong>2. redo 日志写入 log buffer</strong></p>
<p>向 <code>log buffer</code> 中写入 redo 日志的过程是顺序的，也就是先往前边的 block 中写，当该 block 的空闲空间用完之后再往下一个 block 中写。当我们想往 <code>log buffer</code> 中写入 redo 日志时，第一个遇到的问题就是应该写在哪个 <code>block</code> 的那个偏移量处，所以 <code>InnoDB</code> 的设计者特意提供了一个称之为 <code>buf_free</code> 的全局变量，该变量指明后续写入的 redo 日志应该写入到 <code>log buffer</code> 哪个位置，如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230130150948881.png" alt="image-20230130150948881"></p>
<p>一个 mtr 执行过程中可能产生若干条 redo 日志，<code>这些 redo 日志是一个不可分割的组</code>，所以其实并不是每升成一条 redo 日志，就将其插入到 <code>log buffer</code> 中，而是每个 mtr 运行过程中产生的日志先暂时存放到一个地方，当该 mtr 结束的时候，将过程中产生的一组 redo 日志在全部复制到 <code>log buffer</code> 中。我们现在假设有两个名为 <code>T1</code>、<code>T2</code> 的事物，每个事物都包含 2 个 mtr，我们给这几个 mtr 命名一下：</p>
<ul>
<li>事物 <code>T1</code> 的两个 <code>mtr</code> 分别称为 <code>mtr_T1_1</code> 和 <code>mtr_T1_2</code>。</li>
<li>事物 <code>T2</code> 的两个 <code>mtr</code> 分别称为 <code>mtr_T2_1</code> 和 <code>mtr_T2_2</code>。</li>
</ul>
<p>每个 mtr 都会产生一组 redo 日志，用示意图来描述一下这些 mtr 产生的日志情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230130151633396.png" alt="image-20230130151633396"></p>
<p>不同的事物可能是<strong>并发</strong>执行的，所以 <code>T1</code> 、<code>T2</code> 之间的 <code>mtr</code> 可能是<strong>交替执行</strong>的。每当一个 <code>mtr</code> 执行完成时，伴随该 <code>mtr</code> 生成的一组 redo 日志就需要被复制到 <code>log buffer</code> 中，也就是说不同事物的 mtr 可能是交替写入 log buffer 的，我们画个示意图(为了美观，把一个 mtr 中产生的所有 redo 日志当做一个整体来画)：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230130151938838.png" alt="image-20230130151938838"></p>
<p>有的 mtr 产生的 redo 日志量非常大，比如 <code>mtr_t1_2</code> 产生的 redo 日志占用空间比较大，占用了 3 个 block 来存储。</p>
<p><strong>3. redo log block 的结构图</strong></p>
<p>一个 redo log block 是由<strong>日志头</strong>、<strong>日志体</strong>、<strong>日志尾</strong>组成。日志头占用 12 字节，日志尾占用 8 字节，所以一个 block 真正能存储的数据就是 512-12-8&#x3D;492 字节。</p>
<blockquote>
<p><strong>为什么一个 block 设计成 512 字节</strong>？</p>
<p>这个和磁盘的扇区有关，机械磁盘默认的扇区就是 512 字节，如果你要写入的数据大于 512 字节，那么要写入的扇区肯定不止一个，这时就要涉及到磁片的转动，找到下一个扇区，假设现在需要写入两个扇区 A 和 B，如果扇区 A 写入成功，扇区 B 写入失败，那么就会出现<strong>非原子性</strong>的写入，而如果每次只写入和扇区的大小一样的 512 字节，那么每次的写入都是原子性的。</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230130152723402.png" alt="image-20230130152723402" style="zoom:50%;" />

<p>真正的 redo 日志都是存储到占用 496 字节大小的 <code>log block body</code> 中，图中的 <code>log block header</code> 和 <code>log block trailer</code> 存储的是一些<strong>管理信息</strong>，我们看看这些所谓的管理信息都有什么？</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230130152940780.png" alt="image-20230130152940780" style="zoom:50%;" />

<ul>
<li><code>log block header</code> 的属性分别如下：<ul>
<li><code>LOG_BLOCK_HDR_NO</code>：log buffer 是由 log block 组成，在内部 log buffer 就好似一个数组，因此 LOG_BLOCK_HDR_NO 用来标记这个数组中的位置，其是递增并且循环使用的，占用 4 个字节，但是由于第一位用来判断是否是 flush bit，所以最大的值为 2G。</li>
<li><code>LOG_BLOCK_HDR_DATA_LEN</code>：表示 block 中已经使用了多少字节，初始值为 12 (因为 log block body 从第 12 个字节处开始)。随着往 block 中写入的日志越来越多，本属性值也跟正增长。如果 log block body 已经被全部写满，那么本属性的值被设置为 512。</li>
<li><code>LOG_BLOCK_FIRST_REC_GROUP</code>：一条 redo 日志也可以称之为一条 redo 日志记录 (redo log record)，一个 mtr 会产生多条 redo 日志记录，这些 redo 日志记录被称之为一个 redo 日志记录组 (redo log record group)。LOG_BLOCK_FIRST_REC_GROUP 就代表该 block 中第一个 mtr 生成的 redo 日志记录组的偏移量 (其实也就是这个 block 里第一个 mtr 生成的第一条 redo 日志的偏移量)。如果该值的大小和 LOG_BLOCK_HDR_DATA_LEN 相同，则表示当前 log block 不包含新的日志。</li>
<li><code>LOG_BLOCK_CHECKPOINT_NO</code>：占用 4 字节，表示该 log block 最后被写入时的 checkpoint。</li>
</ul>
</li>
<li><code>log block trailer</code> 中属性的意思如下：<ul>
<li><code>LOG_BLOCK_CHECKSUM</code>：表示 block 的校验值，用于正确性校验 (其值和 LOG_BLOCK_HDR_NO 相同)，暂时不关心它。</li>
</ul>
</li>
</ul>
<h4 id="1-8-redo-log-file"><a href="#1-8-redo-log-file" class="headerlink" title="1.8 redo log file"></a>1.8 redo log file</h4><p><strong>1. 相关参数设置</strong></p>
<ul>
<li><code>innodb_log_group_home_dir</code>：指定 redo log 文件组所在的路径，默认值为 <code>./</code>，表示在数据库的数据目录下。MySQL 的默认数据目录 (<code>var/lib/mysql</code>) 下默认有两个名为 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>  的文件，log buffer 中的日志默认情况下就是刷新到这两个磁盘文件中。此 redo 日志文件位置还可以修改。</li>
<li><code>innodb_log_file_in_group</code>：指明 redo log file 的个数，命名方式如：ib_logfile0，ib_logfile1… ib_logfilen。默认 2 个。最大 100 个。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_log_files_in_group&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name             <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_log_files_in_group <span class="operator">|</span> <span class="number">2</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>innodb_flush_log_at_trx_commit</code>：控制 redo log 刷新到磁盘的策略，默认为 1。</li>
<li><code>innodb_log_file_size</code>：单个 redo log 文件设置大小，默认值为 48M。最大值为 512G，注意最大值指的是整个 redo log 系列文件之后，即 (innodb_log_files_in_group * innodb_log_file_size) 不能大于最大值 512G。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_log_file_size&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name        <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_log_file_size <span class="operator">|</span> <span class="number">50331648</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br></pre></td></tr></table></figure>

<p>根据业务修改其大小，以便容纳较大的事物。编辑 my.cnf 文件并重启数据库生效，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br><span class="line">innodb_log_file_size=200M</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在数据库实例更新比较频繁的情况下，可以适当加大 redo log 组数和大小。但也不推荐 redo log 设置过大，在 MySQL 崩溃恢复时会重新执行 redo 日志中的记录。</p>
</blockquote>
<p><strong>2. 日志文件组</strong></p>
<p>从上边的描述中可以看到，磁盘上的 redo 日志文件不止一个，而是以一个日志文件组的形式出现的。这些文件以 <code>ib_logfile[数字]</code>(数字可以是 0、1、2…) 的形式进行命名，每个 redo 日志文件大小都是一样的。</p>
<p>在将 redo 日志写入日志文件组时，是从 <code>ib_logfile0</code> 开始写，如果 <code>ib_logfile0</code> 写满了，就接着 <code>ib_logfile1</code> 写。同理，<code>ib_logfile1</code> 写满了就去写 <code>ib_logfile2</code>，依此类推。如果写到最后一个文件该咋办？那就重新转到 <code>ib_logfile0</code> 继续写，所以整个过程如下图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230130155914261.png" alt="image-20230130155914261" style="zoom:50%;" />

<p>总共的 redo 日志文件大小其实就是：<code>innodb_log_file_size * innodb_log_files_in_group</code>。</p>
<p>采用循环使用的方式向 redo 日志文件组里写数据的话，会导致后写入的 redo 日志覆盖掉前边写的 redo 日志？当然，所以 InnoDB 的设计者提出了 checkpoint 的概念。</p>
<p><strong>3. checkpoint</strong></p>
<p>在整个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint</p>
<ul>
<li><code>write pos</code> 是当前记录的位置，一边写一边后移</li>
<li><code>checkpoint</code> 是当前要擦除的位置，也是往后推移</li>
</ul>
<p>每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。每次 MySQL 家在日志文件恢复数据时，会清空加载过的 redo log 记录，并把 checkpoint 后移更新。write pos 和 checkpoint 之间的还空着的部分可以用来写入新的 redo log 记录。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230130160454246.png" alt="image-20230130160454246" style="zoom:50%;" />

<p>如果 write pos 追上 checkpoint，表示日志文件组满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230130160628429.png" alt="image-20230130160628429" style="zoom:50%;" />

<h4 id="1-9-redo-log-小结"><a href="#1-9-redo-log-小结" class="headerlink" title="1.9 redo log 小结"></a>1.9 redo log 小结</h4><p>redo log 的作用和它的刷盘时机、存储形式：</p>
<p><strong>InnoDB 的更新操作采用的是 Write Ahead Log(预先日志持久化)策略，即先写日志，再写入磁盘</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230130160811676.png" alt="image-20230130160811676" style="zoom:50%;" />

<h3 id="2-Undo-日志"><a href="#2-Undo-日志" class="headerlink" title="2. Undo 日志"></a>2. Undo 日志</h3><p>redo log 是事务持久性的保证，undo log 是事务原子性的保证。在事务中<code>更新数据</code>的<code>前置操作</code>其实是要先写入一个 <code>undo log</code>。</p>
<h4 id="2-1-如何理解-Undo-日志"><a href="#2-1-如何理解-Undo-日志" class="headerlink" title="2.1 如何理解 Undo 日志"></a>2.1 如何理解 Undo 日志</h4><p>事务需要保证<code>原子性</code>，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p>
<ul>
<li>情况一：事务执行过程中可能遇到各种错误，比如<code>服务器本身的错误</code>，<code>操作系统错误</code>，甚至是突然<code>断电</code>导的错误。</li>
<li>情况二：程序员可以在事务执行过程中手动输入 <code>ROLLBACK</code> 语句结束当前事务的执行。</li>
</ul>
<p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为<code>回滚</code>，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合<code>原子性</code>要求。</p>
<p>每当我们要对一条记录做改动时(这里的改动可以指 <code>INSERT、DELETE、UPDATE</code>)，都需要”留一手”——把回滚时所需的东西记下来。比如:</p>
<ul>
<li><p>你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。(对于每个 INSERT,  InnoDB 存储引擎会完成一个 DELETE)</p>
</li>
<li><p>你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。(对于每个 DELETE，InnoDB 存储引擎会执行一个 INSERT)</p>
</li>
<li><p>你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。(对于每个 UPDATE，InnoDB 存储引擎会执行一个相反的 UPDATE，将修改前的行放回去)</p>
</li>
</ul>
<p>MySQL 把这些为了回滚而记录的这些内容称之为撤销日志或者回滚日志(即 undo log)。注意，由于查询操作 (SELECT) 并不会修改任何用户记录，所以在杳询操作行时，并不需要记录相应的 undo 日志</p>
<p>此外，undo log 会产生 redo log，也就是 undo log 的产生会伴随着 redo log 的产生，这是因为 undo log 也需要持久性的保护</p>
<h4 id="2-2-Undo-日志的作用"><a href="#2-2-Undo-日志的作用" class="headerlink" title="2.2 Undo 日志的作用"></a>2.2 Undo 日志的作用</h4><ul>
<li><p>作用1：回滚数据<br>  用户对 undo 日志可能有误解: undo 用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此。undo 是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。<br>  这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。</p>
</li>
<li><p>作用2：MVCC<br>  undo 的另一个作用是 MVCC，即在 InnoDB 存储引擎中 MVCC 的实现是通过 undo 来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过 undo 读取之前的行版本信息，以此实现非锁定读取。</p>
</li>
</ul>
<h4 id="2-3-Undo-的存储结构"><a href="#2-3-Undo-的存储结构" class="headerlink" title="2.3 Undo 的存储结构"></a>2.3 Undo 的存储结构</h4><p><strong>1. 回滚段与 undo 页</strong></p>
<p>InnoDB 对 undo log 的管理采用段的方式，也就是<code>回滚段（rollback segment）</code> 。每个回滚段记录了 <code>1024</code> 个 <code>undo log segment</code>，而在每个 undo log segment 段中进行 <code>undo页</code>的申请。</p>
<ul>
<li><p>在<code>InnoDB1.1 版本之前 </code>（不包括1.1版本），只有一个 rollback segment，因此支持同时在线的事务限制为<code>1024</code>。虽然对绝大多数的应用来说都已经够用。</p>
</li>
<li><p>从 1.1 版本开始 InnoDB 支持最大 <code>128个rollback segment</code>，故其支持同时在线的事务限制提高到了 <code>128*1024</code>。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_undo_logs&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_undo_logs <span class="operator">|</span> <span class="number">128</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br></pre></td></tr></table></figure>

<p>虽然 InnoDB1.1 版本支持了 128 个 rollback segment，但是这些 rollback segment 都存储于共享表空间 ibdata 中。从 lnnoDB1.2 版本开始，可通过参数对 rollback segment 做进一步的设置。这些参数包括:</p>
<ul>
<li><p><code>innodb_undo_directory</code>: 设置 rollback segment 文件所在的路径。这意味着 rollback segment 可以存放在共享表空间以外的位置，即可以设置为独立表空间。该参数的默认值为 “.&#x2F;”，表示当前 InnoDB 存储引擎的目录。</p>
</li>
<li><p><code>innodb_undo_logs</code>: 设置 rollback segment 的个数，默认值为 128。在 InnoDB1.2 版本中，该参数用来替换之前版本的参数innodb_rollback_segments。</p>
</li>
<li><p><code>innodb_undo_tablespaces</code> : 设置构成 rollback segment 文件的数量，这样 rollback segment 可以较为平均地分布在多个文件中。设置该参数后，会在路径 innodb_undo_directory 看到 undo 为前缀的文件，该文件就代表 rollback segment 文件。</p>
</li>
</ul>
<p><strong>undo 页的重用</strong></p>
<p>当我们开启一个事务需要写 undo log 的时候，就得先去 undo log segment 中去找到一个空闲的位置，当有空位的时候，就去申请 undo 页，在这个申请到的 undo 页中进行 undo log 的写入。我们知道mysql默认一页的大小是 16k。</p>
<p>为每一个事务分配一个页，是非常浪费的(除非你的事务非常长)，假设你的应用的 TPS(每秒处理的事务数目)为 1000，那么 1s 就需要 1000 个页，大概需要 16M 的存储，1 分钟大概需要 1G 的存储。如果照这样下去除非 MySQL 清理的非常勤快，否则随着时间的推移，磁盘空间会增长的非常快，而且很多空间都是浪费的。</p>
<p>于是 undo 页就被设计的可以重用了，当事务提交时，并不会立刻删除 undo 页。因为重用，所以这个 undo 页可能混杂着其他事务的undo log。undo log 在 commit 后，会被放到一个链表中，然后判断 undo 页的使用空间是否小于 3&#x2F;4，如果小于 3&#x2F;4 的话，则表示当前的 undo 页可以被重用，那么它就不会被回收，其他事务的 undo log 可以记录在当前 undo 页的后面。由于 undo log 是离散的，所以清理对应的磁盘空间时，效率不高。</p>
<p><strong>2. 回滚段与事务</strong></p>
<ol>
<li><p>每个事务只会使用一个回滚段 (rollback segment)，一个回滚段在同一时刻可能会服务于多个事务。</p>
</li>
<li><p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p>
</li>
<li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</p>
</li>
<li><p>回滚段存在于 undo 表空间中，在数据库中可以存在多个 undo 表空间，但同一时刻只能使用一个 undo 表空间。</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_undo_tablespaces&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name           <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_undo_tablespaces <span class="operator">|</span> <span class="number">2</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>当事务提交时，InnoDB 存储引擎会做以下两件事情：</p>
<ul>
<li><p>将 undo log 放入列表中，以供之后的 purge 操作</p>
</li>
<li><p>判断 undo log 所在的页是否可以重用(低于 3&#x2F;4 可以重用)，若可以分配给下个事务使用</p>
</li>
</ul>
</li>
</ol>
<p><strong>3. 回滚段中的数据分类</strong></p>
<ul>
<li><p>未提交的回滚数据 (uncommitted undo information)：该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。</p>
</li>
<li><p>已经提交但未过期的回滚数据 (committed undo information)：该数据关联的事务已经提交，但是仍受到 undo retention 参数的保持时间的影响。</p>
</li>
<li><p>事务已经提交并过期的数据 (expired undo information)：事务已经提交，而且数据保存时间已经超过 undo retention 参数指定的时间，属于已经过期的数据。当回滚段满了之后，会优先覆盖”事务已经提交并过期的数据”。</p>
</li>
</ul>
<p>事务提交后并不能马上删除 undo log 及 undo log 所在的页。这是因为可能还有其他事务需要通过 undo log 来得到行记录之前的版本。故事务提交时将 undo log 放入一个链表中，是否可以最终删除 undo log 及 undo log 所在页由 purge 线程来判断。</p>
<h4 id="2-4-Undo-的类型"><a href="#2-4-Undo-的类型" class="headerlink" title="2.4 Undo 的类型"></a>2.4 Undo 的类型</h4><p>在 InnoDB 存储引擎中，undo log 分为：</p>
<ul>
<li><p>insert undo log<br>  insert undo log 是指在 insert 操作中产生的 undo log。因为 insert 操作的记录，只对事务本身可见，对其他事务不可见(这是事务隔离性的要求)，故该 undo log 可以在事务提交后直接删除。不需要进行 purge 操作。</p>
</li>
<li><p>update undo log<br>  update undo log 记录的是对 delete 和 update 操作产生的 undo log。该 undo log 可能需要提供 MVCC 机制，因此不能在事务提交时就进行删除。提交时放入 undo log 链表，等待 purge 线程进行最后的删除。</p>
</li>
</ul>
<h4 id="2-5-Undo-log-的生命周期"><a href="#2-5-Undo-log-的生命周期" class="headerlink" title="2.5 Undo log 的生命周期"></a>2.5 Undo log 的生命周期</h4><p><strong>1. 简要生成过程</strong></p>
<p>以下是 undo+redo 事务的简化过程</p>
<p>假设有 2 个数值，分别为 A&#x3D;1 和 B&#x3D;2，然后将 A 修改为 3，B 修改为 4</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. start transaction;</span><br><span class="line">2．记录A=1到undo <span class="built_in">log</span>;</span><br><span class="line">3. update A = 3;</span><br><span class="line">4．记录A=3 到redo <span class="built_in">log</span>;</span><br><span class="line">5．记录 B=2到undo loq;</span><br><span class="line">6. update B = 4;</span><br><span class="line">7．记录B = 4到redo <span class="built_in">log</span>;</span><br><span class="line">8．将redo <span class="built_in">log</span>刷新到磁盘;</span><br><span class="line">9. commit</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在 1-8 步骤的任意一步系统宕机，事务未提交，该事务就不会对磁盘上的数据做任何影响。</p>
</li>
<li><p>如果在 8-9 之间宕机，回复之后可以选择回滚，也可以选择继续完成事务提交，因为此时 redo log 已经持久化。</p>
</li>
<li><p>若在 9 之后系统宕机，内存映射中变更的数据还来不及刷回磁盘，那么系统恢复之后，可以根据 redo log 把数据刷回磁盘。</p>
</li>
</ul>
<p><strong>只有 Buffer Pool 的流程</strong>：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230130163555532.png" alt="image-20230130163555532" style="zoom:50%;" />

<p><strong>有了 Redo Log 和 Undo Log 之后</strong>：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230130163636605.png" alt="image-20230130163636605" style="zoom:50%;" />

<p>在更新 Buffer Pool 中的数据之前，我们需要先将该数据事务开始之前的状态写入 Undo Log 中。假设更新到一半出错了，我们就可以通过 Undo Log 来回滚到事务开始前。</p>
<p><strong>2. 详细生成过程</strong></p>
<p>对于 InnoDB 引擎来说，每个行记录除了记录本身的数据之外，还有几个隐藏的列:</p>
<ul>
<li><p><code>DB_ROW_ID</code>: 如果没有为表显式的定义主键，并且表中也没有定义唯一索引，那么 InnoDB 会自动为表添加一个 row_id 的隐藏列作为主键。</p>
</li>
<li><p><code>DB_TRX_ID</code>: 每个事务都会分配一个事务 ID，当对某条记录发生变更时，就会将这个事务的事务 ID 写入 trx_id 中。</p>
</li>
<li><p><code>DB_ROLL_PTR</code>: 回滚指针，本质上就是指向 undo log 的指针。</p>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230130163934855.png" alt="image-20230130163934855" style="zoom:50%;" />

<p>当我们执行 INSERT 时：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (name) <span class="keyword">VALUES</span> (&quot;tom&quot;);</span><br></pre></td></tr></table></figure>

<p>插入的数据都会生成一条 insert undo log，并且数据的回滚指针会指向它。undo log 会记录 undo log 的序号、插入主键的列和值…，那么在进行 rollback 的时候，通过主键直接把对应的数据删除即可。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230130164048129.png" alt="image-20230130164048129" style="zoom:50%;" />

<p>当我们执行 UPDATE 时：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name<span class="operator">=</span> &quot;Sun&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230130164206448.png" alt="image-20230130164206448" style="zoom:50%;" />

<p>这时会把老的记录写入新的 undo log，让回滚指针指向新的 undo log，它的 undo no 是 1，并且新的 undo log 会指向老的 undo log (undo no&#x3D;0)。</p>
<p>假设现在执行:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> id<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;  </span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230130164314445.png" alt="image-20230130164314445" style="zoom:50%;" />

<p>对于更新主键的操作，会先把原来的数据 deletemark 标识打开，这时并没有真正的删除数据，真正的删除会交给清理线程去判断，然后在后面插入一条新的数据，新的数据也会产生 undo log，并且 undo log 的序号会递增。</p>
<p>可以发现每次对数据的变更都会产生一个 undo log，当一条记录被变更多次时，那么就会产生多条 undo log，undo log 记录的是变更前的日志，并且每个 undo log 的序号是递增的，那么当要回滚的时候，按照序号依次向前推，就可以找到我们的原始数据了。</p>
<p><strong>3. undo log 是如何回滚的</strong></p>
<p>以上面的例子来说，假设执行 rollback，那么对应的流程应该是这样：</p>
<ol>
<li>通过undo no&#x3D;3 的日志把 id&#x3D;2 的数据删除</li>
<li>通过 undo no&#x3D;2 的日志把 id&#x3D;1 的数据的 deletemark 还原成 0</li>
<li>通过 undo no&#x3D;1 的日志把 id&#x3D;1 的数据的 name 还原成 Tom</li>
<li>通过 undo no&#x3D;0 的日志把 id&#x3D;1 的数据删除</li>
</ol>
<p><strong>4. undo log 的删除</strong></p>
<ul>
<li>针对于 insert undo log</li>
</ul>
<p>因为 insert 操作的记录，只对事务本身可见，对其他事务不可见。故该 undo log 可以在事务提交后直接删除，不需要进行 purge 操作。</p>
<ul>
<li>针对于 update undo log</li>
</ul>
<p>该 undo log 可能需要提供 MVCC 机制，因此不能在事务提交时就进行删除。提交时放入 undo log 链表，等待 purge 线程进行最后的删除。</p>
<blockquote>
<p>补充: purge 线程两个主要作用是: <code>清理 undo 页</code>和<code>清除 page 里面带有 Delete_Bit 标识的数据行</code>。仕 InnoDB 中，事分中的 Delete 操作实际上并不是真正的删除掉数据行，而是一种 Delete Mark 操作，在记录上标识 Delete_Bit，而不删除记录。是一种”假删除”只是做了个标记，真正的删除工作需要后台 purge 线程去完成。</p>
</blockquote>
<h4 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230130164835932.png" alt="image-20230130164835932" style="zoom:50%;" />

<p>undo log 是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p>
<p>redo log 是物理日志，记录的是数据页的物理变化，undo log 不是 redo log 的逆过程。</p>
<h2 id="十三、锁"><a href="#十三、锁" class="headerlink" title="十三、锁"></a>十三、锁</h2><blockquote>
<p>事务的<code>隔离性</code>由<code>锁</code>来实现。</p>
</blockquote>
<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><code>锁</code>是计算机协调多个进程或线程<code>并发访问某一资源</code>的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等），我们就需要保证这个数据在任何时刻<code>最多只有一个线程在访问</code>，保证数据的<code>完整性</code>和<code>一致性</code>。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。</p>
<p>在数据库中，除传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对<code>并发操作进行控制</code>，因此产生了<code>锁</code>。同时<code>锁机制</code>也为实现MySQL的各个隔离级别提供了保证。<code>锁冲突</code>也是影响数据库<code>并发访问性能</code>的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p>
<h3 id="2-MySQL并发事务访问相同记录"><a href="#2-MySQL并发事务访问相同记录" class="headerlink" title="2. MySQL并发事务访问相同记录"></a>2. MySQL并发事务访问相同记录</h3><h4 id="2-1-读-读情况"><a href="#2-1-读-读情况" class="headerlink" title="2.1 读-读情况"></a>2.1 读-读情况</h4><p><code>读-读</code>情况，即并发事务相继读取相同的记录。<code>读取操作本身不会对记录有任何影响</code>，并不会引起什么问题，所以允许这种情况的发生。</p>
<h4 id="2-2-写-写情况"><a href="#2-2-写-写情况" class="headerlink" title="2.2 写-写情况"></a>2.2 写-写情况</h4><p><code>写-写</code>情况，即并发事务相继对相同的记录做出改动。</p>
<p>在这种情况下会发生<code>脏写</code>的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们<code>排队执行</code>，这个排队的过程其实是通过锁来实现的。这个所谓的锁其实是一个<code>内存中的结构</code>，在事务执行前本来是没有锁的，也就是说一开始是没有<code>锁结构</code>和记录进行关联的。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131104306577.png" alt="image-20230131104306577" style="zoom:50%;" />

<p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。比如，事务T1要对这条记录做改动，就需要生成一个锁结构与之关联：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131104331436.png" alt="image-20230131104331436" style="zoom:50%;" />

<ul>
<li><code>trx信息:</code>代表这个锁结构是哪个事务生成的。</li>
<li><code>is_waiting:</code>代表当前事务是否在等待。</li>
</ul>
<p>当事务<code>T1</code>改动了这条记录后，就生成了一个<code>锁结构</code>与该记录关联，因为之前没有别的事务为这条记录加锁，所以<code>is_waiting</code>属性就是<code>false</code>，我们把这个场景就称之为<code>获取锁成功</code>，或者<code>加锁成功</code>，然后就可以继续执行操作了。<br>在事务<code>T1</code>提交之前，另一个事务<code>T2</code>也想对该记录做改动，那么先看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的<code>is_waiting</code>属性值为<code>true</code>, 表示当前事务需要等待，我们把这个场景就称之为<code>获取锁失败</code>，或者<code>加锁失败</code>，图示:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131104526814.png" alt="image-20230131104526814" style="zoom:50%;" />

<p>在事务T1提交之后，就会把该事务生成的<code>锁结构释放</code>掉，然后看看还有没有别的事务在等待获取锁，发现了事务T2还在等待获取锁，所以把事务T2对应的锁结构的<code>is_waiting属性设置为false</code>，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了。效果图就是这样:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131104117421.png" alt="image-20230131104117421" style="zoom:50%;" />

<p>小结几种说法：</p>
<ul>
<li><p>不加锁<br>  意思就是不需要在内存中生成对应的<code>锁结构</code>，可以直接执行操作。</p>
</li>
<li><p>获取锁成功，或者加锁成功<br>  意思就是在内存中生成了对应的<code>锁结构</code>，而且锁结构的<code>is_waiting</code>属性为<code>false</code>，也就是事务可以继续执行操作。</p>
</li>
<li><p>获取锁失败，或者加锁失败，或者没有获取到锁<br>  意思就是在内存中生成了对应的<code>锁结构</code>，不过锁结构的<code>is_waiting</code>属性为<code>true</code>，也就是事务需要等待，不可以继续执行操作。</p>
</li>
</ul>
<h4 id="2-3-读-写或写-读情况"><a href="#2-3-读-写或写-读情况" class="headerlink" title="2.3 读-写或写-读情况"></a>2.3 读-写或写-读情况</h4><p><code>读-写</code>或<code>写-读</code>，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>的问题。</p>
<p>各个数据库厂商对<code>SQL标准</code>的支持都可能不一样。比如MySQL在<code>REPEATABLE READ</code>隔离级别上就已经解决了幻读问题。</p>
<h4 id="2-4-并发问题的解决方案"><a href="#2-4-并发问题的解决方案" class="headerlink" title="2.4 并发问题的解决方案"></a>2.4 并发问题的解决方案</h4><p>怎么解决脏读、不可重复读、幻读这些问题呢？其实有两种可选的解决方案：</p>
<ul>
<li>方案一：读操作利用多版本并发控制（MVCC），写操作进行加锁。<br>  所谓的<code>MVCC</code>，就是生成一个<code>ReadView</code>，通过ReadView找到符合条件的记录版本（历史版本由<code>undo日志</code>构建)。查询语句只能<code>读到</code>在生成ReadView之前<code>已提交事务所做的更改</code>，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<code>写操作</code>肯定针对的是<code>最新版本的记录</code>，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<code>读-写</code>操作并不冲突。</li>
</ul>
<blockquote>
<p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p>
<ul>
<li>在READ COMMITTED隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象；</li>
<li>在REPEATABLE READ隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作才会生成一个ReadView，之后的SELECT操作都复用这个ReadView，这样也就避免了不可重复读和幻读的问题。</li>
</ul>
</blockquote>
<ul>
<li>方案二：读、写操作都采用<code>加锁</code>的方式。<br>  如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去<code>读取记录的最新版本</code>。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行加锁操作，这样也就意味着读操作和写操作也像<code>写-写</code>操作那样<code>排队执行</code>。</li>
</ul>
<p><code>脏读</code>的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p>
<p><code>不可重复读</code>产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p>
<p><code>幻读</code>问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在，所以读取的时候加锁就有点尴尬（因为你并不知道给谁加锁)。</p>
<ul>
<li>小结对比发现：<ul>
<li>采用<code>MVCC</code>方式的话，<code>读-写</code>操作彼此并不冲突，性能更高。</li>
<li>采用<code>加锁方式</code>的话，读-写操作彼此需要排队执行，<code>影响性能</code>。</li>
</ul>
</li>
</ul>
<p>一般情况下我们当然愿意采用<code>MVCC</code>来解决<code>读-写</code>操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用<code>加锁</code>的方式执行。下面就讲解下MySQL中不同类别的锁。</p>
<h3 id="3-锁的不同角度分类"><a href="#3-锁的不同角度分类" class="headerlink" title="3. 锁的不同角度分类"></a>3. 锁的不同角度分类</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131105316516.png" alt="image-20230131105316516" style="zoom:50%;" />

<h4 id="3-1-从数据操作的类型划分：读锁、写锁"><a href="#3-1-从数据操作的类型划分：读锁、写锁" class="headerlink" title="3.1 从数据操作的类型划分：读锁、写锁"></a>3.1 从数据操作的类型划分：读锁、写锁</h4><p>对于数据库中并发事务的读-读情况并不会引起什么问题。对于写-写、读-写或写-读这些情况可能会引起一些问题，需要使用MVCC或者加锁的方式来解决它们。在使用加锁的方式解决问题时，由于既要允许读-读情况不受影响，又要使写-写、读-写或写-读情况中的操作相互阻塞，所以MySQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为<code>共享锁(Shared Lock，SLock)</code>和<code>排他锁(Exclusive Lock，XLock)</code>也叫读锁(readlock)和写锁(write lock)。</p>
<ul>
<li><p><code>读锁：</code>也称为共享锁、英文用S表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</p>
</li>
<li><p><code>写锁：</code>也称为排他锁、英文用X表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</p>
</li>
</ul>
<p><strong>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。</strong></p>
<p>举例(行级读写锁)∶如果一个事务T1已经获得了某个行r的读锁，那么此时另外的一个事务T2是可以去获得这个行r的读锁的，因为读取操作并没有改变行r的数据;但是，如果某个事务T3想获得行r的写锁，则它必须等待事务T1、T2释放掉行r上的读锁才行。</p>
<p>总结:这里的兼容是指对同一张表或记录的锁的兼容性情况。</p>
<table>
<thead>
<tr>
<th></th>
<th>X锁</th>
<th>S锁</th>
</tr>
</thead>
<tbody><tr>
<td>X锁</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>S锁</td>
<td>不兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p><strong>3.1.1 锁定读</strong></p>
<p>在采用<code>加锁</code>方式解决脏读、不可重复读、幻读这些问题时，读取一条记录时需要获取该记录的S锁，其实是不严谨的，有时候需要在读取记录时就获取记录的X锁，来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的SELECT语句格式:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对读取的记录加S锁:</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> SHARE;#(<span class="number">8.0</span>新增语法)</span><br></pre></td></tr></table></figure>

<p>在普通的SELECT语句后边加<code>LOCK IN SHARE MODE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加S锁，这样允许别的事务继续获取这些记录的S锁(比方说别的事务也使用<code>SELECT ... LOCK IN SHAREMODE</code>语句来读取这些记录)，但是不能获取这些记录的X锁(比如使用<code>SELECT ... FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的<code>x锁</code>，那么它们会阻塞，直到当前事务提交之后将这些记录上的<code>S锁</code>释放掉。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对读取的记录加X锁:</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>在普通的SELECT语句后边加<code>FOR UPDATE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加X锁，这样既不允许别的事务获取这些记录的S锁(比方说别的事务使用<code>SELECT ... LOCK IN SHARE MODE语句</code>来读取这些记录)，也不允许获取这些记录的X锁(比如使用<code>SELECT ... FOR UPDATE语句</code>来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的S锁或者X锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的X锁释放掉。</p>
<p><strong>MySQL8.0新特性:</strong></p>
<p>在5.7及之前的版本，SELECT …FOR UPDATE，如果获取不到锁，会一直等待，直到innodb_lock_wait_timeout超时。在8.0版本中，SELECT. FOR UPDATE，SELECT …FOR SHARE添加NOWAIT、SKIP LOCKED语法，跳过锁等待，或者跳过锁定。</p>
<p>通过添加NOWAIT、SKIP LOCKED语法，能够立即返回。如果查询的行已经加锁:</p>
<ul>
<li>那么NOWAIT会立即报错返回（等不到锁立即返回）</li>
<li>而SKIP LOCKED也会立即返回，只是返回的结果中不包含被锁定的行。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT. <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> NOWAIT</span><br><span class="line">SELECT. <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">SKIP</span> LOCKED</span><br></pre></td></tr></table></figure>

<p><strong>3.1.2 写操作</strong></p>
<p>平常所用到的<code>写操作</code>无非是<code>DELETE</code>、<code>UPDATE</code>、<code>INSERT</code>这三种:</p>
<ul>
<li>DELETE:<br>  对一条记录做DELETE操作的过程其实是先在<code>B+树</code>中定位到这条记录的位置，然后获取这条记录的<code>X锁</code>，再执行delete mark.操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</li>
<li>UPDATE∶在对一条记录做UPDATE操作时分为三种情况:<ul>
<li>情况1: 未修改该记录的<code>键值</code>，并且被更新的列占用的存储空间在修改前后<code>未发生变化</code>。<br>  则先在<code>B+树</code>中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原记录的位置进行修改操作。我们也可以把这个定位待修改记录在B+树中位置的过程看成是一个<code>获取X锁</code>的<code>锁定读</code>。</li>
<li>情况2∶未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。<br>  则先在B+树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表)，最后再插入一条新记录。这个定位待修改记录在B+树中位置的过程看成是一个获取<code>×锁</code>的<code>锁定读</code>，新插入的记录由<code>INSERT</code>操作提供的隐式锁进行保护。</li>
<li>情况3∶修改了该记录的键值，则相当于在原记录上做DELETE操作之后再来一次INSERT操作，加锁操作就需要按照<code>DELETE和INSERT</code>的规则进行了。</li>
</ul>
</li>
<li>INSERT :<br>  一般情况下，新插入一条记录的操作并不加锁，通过一种称之为<code>隐式锁</code>的结构来保护这条新插入的记录在本事务<code>提交前不被别的事务访问</code>。</li>
</ul>
<h4 id="3-2-从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#3-2-从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="3.2 从数据操作的粒度划分：表级锁、页级锁、行锁"></a>3.2 从数据操作的粒度划分：表级锁、页级锁、行锁</h4><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很<code>耗资源</code>的事情（涉及获取、检查、释放锁等动作)(越小消耗越大)。因此数据库系统需要在<code>高并响应</code>和<code>系统性能</code>两方面进行平衡，这样就产生了<code>“锁粒度(Lock granularity)”</code>的概念。</p>
<p>对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细;其实一个事务也可以在表级别进行加锁，自然就被称之为表级锁或者表锁，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。锁的粒度主要分为<code>表级锁、页级锁和行锁</code>。</p>
<p><strong>3.2.1 表锁（Table Lock）</strong></p>
<p>该锁会锁定整张表，它是MySQL中最基本的锁策略，<code>并不依赖于存储引擎</code>(不管你是MySQL的什么存储引擎，对于表锁的策略都是一样的)，并且表锁是<code>开销最小</code>的策略（因为粒度比较大)。由于表级锁一次会将整个表锁定，所以可以很好的<code>避免死锁</code>问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致<code>并发率大打折扣</code>。</p>
<p><strong>① 表级别的S锁、X锁</strong></p>
<p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的<code>S锁或者X锁</code>的。在对某个表执行一些诸如ALTER TABLE、DROP TABLE这类的<code>DDL语句</code>时，其他事务对这个表并发执行诸如SELECT、NSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行DDL语句也会发生阻塞。这个过程其实是通过在server层使用一种称之为<code>元数据锁</code>（英文名：Metadata Locks，简称MDL）结构来实现的。</p>
<p>一般情况下，<code>不会使用</code>InnoDB存储引擎提供的<code>表级别的S锁和X锁</code>。只会在一些特殊情况下，比方说<code>崩溃恢复</code>过程中用到。比如，在系统变量<code>autocommit=0，innodb_table_locks = 1</code>时，手动获取InnoDB存储引擎提供的表t 的S锁或者X锁可以这么写：</p>
<ul>
<li><code>LOCK TABLES t READ：</code>InnoDB存储引擎会对表t加表级别的S锁。</li>
<li><code>LOCK TABLES t WRITE：</code>InnoDB存储引擎会对表t加表级别的X锁。</li>
</ul>
<p>不过尽量避免在使用InnoDB存储引擎的表上使用<code>LOCK TABLES</code>这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的行锁，关于InnoDB表级别的S锁和X锁大家了解一下就可以了。</p>
<p><strong>举例：MyISAM 引擎下的表锁</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 步骤一：创建表并添加数据</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> mylock(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">)engine myisam;# 存储引擎使用innodb也可以，知识不建议</span><br><span class="line"></span><br><span class="line"># 插入一条数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mylock(name) <span class="keyword">values</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 查询表中所有的数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mylock;</span><br><span class="line"></span><br><span class="line"># 步骤二：查看表上加过的锁</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> tables;  #主要关注in_use字段的值</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> tables <span class="keyword">where</span> In_use <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"># 步骤三：手动增加表锁命令</span><br><span class="line">lock tables t read; #存储引擎会对表t加表级别的共享锁。共享锁也叫读锁或s锁</span><br><span class="line">lock tables t <span class="keyword">where</span>; #存储引擎会对表t加表级别的排他锁。排他锁也叫独占锁、写锁或x锁</span><br><span class="line"></span><br><span class="line"># 步骤四：释放表锁</span><br><span class="line">unlock tables; # 使用此命令解锁当前加锁的表</span><br><span class="line"></span><br><span class="line"># 步骤五：加读锁</span><br><span class="line"># 为mylock表加read锁（读阻塞写），观察阻塞情况，流程如下</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131112857176.png" alt="image-20230131112857176" style="zoom:50%;" />

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 步骤流：加写锁</span><br><span class="line"># 为mylock加write锁，观察阻塞的情况，流程如下：</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131113157484.png" alt="image-20230131113157484" style="zoom:50%;" />

<p><strong>总结：</strong></p>
<p>MyISAM在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。InnoDB存储引擎是不会为这个表添加表级别的<code>读锁</code>或者<code>写锁</code>的。</p>
<p>MySQL的表级锁有两种模式：（以MyISAM表进行操作的演示）</p>
<ul>
<li>表共享读锁（Table Read Lock）</li>
<li>表独占写锁（Table Write Lock）</li>
</ul>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>自己可读</th>
<th>自己可写</th>
<th>自己可操作其他表</th>
<th>他人可读</th>
<th>他人可写</th>
</tr>
</thead>
<tbody><tr>
<td>读锁</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否，等</td>
</tr>
<tr>
<td>写锁</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否，等</td>
<td>否，等</td>
</tr>
</tbody></table>
<p><strong>② 意向锁 （intention lock）</strong></p>
<p>InnoDB 支持多粒度锁（multiple granularity locking），它允许行级锁与表级锁共存，而 意向锁 就是其中的一种表锁。</p>
<p>1、意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁)的锁并存。</p>
<p>2、意向锁是一种不与行级锁冲突表级锁，这一点非常重要。</p>
<p>3、表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</p>
<p>意向锁分为两种：</p>
<ul>
<li><strong>意向共享锁 （intention shared lock, IS）</strong>：事务有意向对表中的某些行加 <strong>共享锁（S锁）</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 </span></span><br><span class="line"><span class="comment">-- 会自动加，不用管</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>意向排他锁 （intention exclusive lock, IX）</strong>：事务有意向对表中的某些行加 <strong>排他锁（X锁）</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span></span><br><span class="line"><span class="comment">-- 会自动加，不用管</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>即：意向锁是由存储引擎<code>自己维护的</code>，用户无法手动操作意向锁，在为数据行加共享 &#x2F; 排他锁之前，InooDB 会先获取该数据行<code>所在数据表的对应意向锁</code>。</p>
<p><strong>意向锁要解决的问题</strong>:</p>
<p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁;如果存在意向锁，那么此时就会受到由T1控制的<code>表级别意向锁的阻塞</code>。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。<code>简单来说就是给更大一级别的空间示意里面是否已经上过锁</code>。</p>
<p>在数据表的场景中，<code>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</code>(不这么做的话，想上表锁的那个程序，还要遍历有没有行锁)，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p>
<ul>
<li>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上<code>添加意向共享锁</code>。</li>
<li>如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上<code>添加意向排他锁</code>。</li>
</ul>
<p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。</p>
<p>因为共享锁与排他锁互斥，所以事务B在试图对X表加共享锁的时候，必须保证两个条件。 </p>
<p>(1）当前没有其他事务持有X表的排他锁</p>
<p>(2）当前没有其他事务持有X表中任意一行的排他锁。</p>
<p>为了检测是否满足第二个条件，事务B必须在确保X表不存在任何排他锁的前提下，去检测表中的每一行是否存在排他锁。很明显这是一个效率很差的做法，但是有了意向锁之后，情况就不一样了。</p>
<p>意向锁是怎么解决这个问题的呢?首先，我们需要知道意向锁之间的兼容互斥性，如下所示。</p>
<table>
<thead>
<tr>
<th></th>
<th>意向共享锁(lS)</th>
<th>意向排他锁(IX)</th>
</tr>
</thead>
<tbody><tr>
<td>意向共享锁(IS)</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>意向排他锁（IX)</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>即意向锁之间是互相兼容的，虽然意向锁和自家兄弟互相兼容，但是它会与普通的排他&#x2F;共享锁互斥。</p>
<table>
<thead>
<tr>
<th></th>
<th>意向共享锁(lS)</th>
<th>意向排他锁(IX)</th>
</tr>
</thead>
<tbody><tr>
<td>共享锁(S)表</td>
<td>兼容</td>
<td>互斥</td>
</tr>
<tr>
<td>排他锁（X)表</td>
<td>互斥</td>
<td>互斥</td>
</tr>
</tbody></table>
<p>注意这里的排他&#x2F;共享锁指的都是表锁，意向锁不会与行级的共享&#x2F;排他锁互斥。</p>
<p><strong>意向锁的并发性</strong></p>
<p>意向锁不会与行级的共享 &#x2F; 排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。（不然我们直接用普通的表锁就行了）</p>
<p>我们扩展一下上面 teacher表的例子来概括一下意向锁的作用（一条数据从被锁定到被释放的过程中，可能存在多种不同锁，但是这里我们只着重表现意向锁）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 事务A先获取了某一行的排他锁，并未提交：</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"># 事务A获取了teacher表上的意象排他锁，事务A获取了id为<span class="number">6</span>的数据行上的排他锁。时候事务B想要获取teacher表的共享锁。</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">lock tables teacher read;</span><br><span class="line"># 事务B检测到事务A持有teacher表的意象排他锁。事务B对teacher表的枷锁请求被阻塞(排斥)。最后事务C也想获取teacher表中某一行的排他锁。</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"># 事务C申请teacher表的意象排他锁。事务C检测到事务A持有teacher表的意象排他锁。因为意象锁之间并不互斥，所以事务C获取到了teacher表的意象排他锁。因为id为<span class="number">5</span>的数据行上不存在任何排他锁，最终事务C成功获取到了该数据行上的排他锁。</span><br></pre></td></tr></table></figure>

<p><strong>从上面的案例可以得到如下结论：</strong></p>
<ul>
<li><p>InnoDB 支持<code>多粒度锁</code>，特定场景下，行级锁可以与表级锁共存。</p>
</li>
<li><p>意向锁之间互不排斥，但除了 IS 与 S 兼容外，<code>意向锁会与 共享锁 / 排他锁 互斥</code>。</p>
</li>
<li><p>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</p>
</li>
<li><p>意向锁在保证并发性的前提下，实现了<code>行锁和表锁共存</code>且<code>满足事务隔离性</code>的要求。</p>
</li>
</ul>
<p><strong>③ 自增锁（AUTO-INC锁）</strong></p>
<p>在使用MySQL过程中，我们可以为表的某个列添加<code>AUTO_INCREMENT</code>属性。</p>
<p>插入数据是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是<code>“Simple inserts”</code>，<code>“Bulk inserts”</code>和<code>“Mixed-mode inserts”</code>。</p>
<ul>
<li><p><strong>“Simple inserts” （简单插入）</strong></p>
<p>  可以<code>预先确定要插入的行数</code>（当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行<code>INSERT...VALUES()</code>和<code>REPLACE</code>语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行数。</p>
</li>
<li><p><strong>“Bulk inserts” （批量插入）</strong></p>
<p>  <code>事先不知道要插入的行数</code>（和所需自动递增值的数量）的语句。比如INSERT … SELECT，REPLACE… SELECT和LOAD DATA语句，但不包括纯INSERT。InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。</p>
</li>
<li><p><strong>“Mixed-mode inserts” （混合模式插入）</strong></p>
<p>  这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如INSERT INTO teacher (id,name) VALUES (1,‘a’), (NULL,‘b’), (5,‘c’), (NULL,‘d’);只是指定了部分id的值。另一种类型的“混合模式插入”是<code>INSERT ... ON DUPLICATE KEY UPDATE</code>。</p>
</li>
</ul>
<p>对于上面数据插入的案例，MySQL中采用了<code>自增锁</code>的方式来实现，<code>AUTO-INC锁是当向使用含有AUTO_INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁</code>，在执行插入语句时就在表级别加一个AUTO-INC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INC锁释放掉。<code>一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞</code>，可以保证<code>一个语句</code>中分配的递增值是<code>连续</code>的。也正因为此，其并发性显然并不高，<code>当我们向一个有AUTO_INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争</code>，这样的并发潜力其实是很低下的，所以innodb通过<code>innodb_autoinc_lock_mode</code>的不同取值来提供不同的锁定机制，来显著提高SQL语句的可伸缩性和性能。</p>
<p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）innodb_autoinc_lock_mode <span class="operator">=</span> <span class="number">0</span>(“传统”锁定模式)</span><br></pre></td></tr></table></figure>

<p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺<code>会限制并发能力</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">2</span>）innodb_autoinc_lock_mode <span class="operator">=</span> <span class="number">1</span>(“连续”锁定模式)</span><br></pre></td></tr></table></figure>

<p>在 MySQL 8.0 之前，连续锁定模式是<code>默认</code>的。</p>
<p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT …</p>
<p>SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p>
<p>对于“Simple inserts”（要插入的行数事先已知），则通过在<code>mutex（轻量锁）</code>的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（ <span class="number">3</span> ）innodb_autoinc_lock_mode <span class="operator">=</span> <span class="number">2</span>(“交错”锁定模式)</span><br></pre></td></tr></table></figure>

<p>从 MySQL 8.0 开始，交错锁模式是<code>默认</code>设置。</p>
<p>在这种锁定模式下，所有类INSERT语句都不会使用表级AUTO-INC锁，并且可以同时执行多个语句。这是最快和最可扩展的锁定模式，但是当使用基于语句的复制或恢复方案时，<code>从二进制日志重播SQL语句时，这是不安全的。(主从复制id可能不一致)</code></p>
<p>在此锁定模式下，自动递增值<code>保证</code>在所有并发执行的所有类型的insert语句中是唯一且单调递增的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号）， <strong>为任何给定语句插入的行生成的值可能不是连续的。</strong></p>
<p>如果执行的语句是“simple inserts”，其中要插入的行数已提前知道，除了“Mixed-mode inserts”之外，为单个语句生成的数字不会有间隙。然而，当执行“bulk inserts”时,在由任何给定语句分配的自动递增值中可能存在间隙。</p>
<p><strong>④ 元数据锁（MDL锁）</strong></p>
<p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个<code>表结构做变更</code>，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p>
<p>因此， <strong>当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</strong></p>
<p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。<code>不需要显式使用</code>，在访问一个表的时候会被自动加上。</p>
<p><strong>3.2.2 InnoDB中的行锁</strong></p>
<p>行锁(Row Lock)也称为记录锁，顾名思义，就是锁住某一行（某条记录row)。需要的注意的是，MySQL服务器层并没有实现行锁机制，<strong>行级锁只在存储引擎层实现。</strong></p>
<p>优点: 锁定力度小，发生<code>锁冲突概率低</code>，可以实现的<code>并发度高</code>。</p>
<p>缺点: 对于<code>锁的开销比大</code>，加锁会比较慢，容易出现<code>死锁</code>情况。</p>
<p>InnoDB与MylSAM的最大不同有两点: <code>一是支持事务(TRANSACTION)</code>；<code>二是采用了行级锁</code>。</p>
<p>首先我们创建表如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">	id <span class="type">INT</span>,</span><br><span class="line">	name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	class <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line">再插入几条数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>) ,</span><br><span class="line">(<span class="number">8</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;二班&#x27;</span>) ,</span><br><span class="line">(<span class="number">15</span>,<span class="string">&#x27;赵六&#x27;</span>,<span class="string">&#x27;二班&#x27;</span>) ,</span><br><span class="line">(<span class="number">20</span>,<span class="string">&#x27;钱七&#x27;</span>,<span class="string">&#x27;三班&#x27;</span>);</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131130330632.png" alt="image-20230131130330632" style="zoom:50%;" />

<p>这里把B+树的索引结构做了一个超级简化，只把索引中的记录给拿了出来，下面看看都有哪些常用的行锁类型。</p>
<p><strong>① 记录锁（Record Locks）</strong></p>
<p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为：<code>LOCK_REC_NOT_GAP</code>。比如我们把id值为 8 的<br>那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为 8 的记录，对周围的数据没有影响。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131130426964.png" alt="image-20230131130426964" style="zoom:50%;" />

<p>举例如下：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131130452484.png" alt="image-20230131130452484" style="zoom:50%;" /></p>
<p>记录锁是有S锁和X锁之分的，称之为<code>S型记录锁</code>和<code>X型记录锁</code>。</p>
<ul>
<li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li>
<li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li>
</ul>
<p><strong>② 间隙锁（Gap Locks）</strong></p>
<p>MySQL在<code>REPEATABLE READ</code>隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用<code>MVCC</code>方案解决，也可以采用加锁方案解决。但是在使用<code>加锁</code>方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些<code>幻影记录</code>加上记录锁。InnoDB提出了一种称之为<code>Gap Locks的锁</code>，官方的类型名称为：<code>LOCK_GAP</code>，我们可以简称为gap锁。比如，把id值为 8 的那条记录加一个gap锁的示意图如下。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131130756762.png" alt="image-20230131130756762" style="zoom:50%;" />

<p>图中id值为 8 的记录加了gap锁，意味着<code>不允许别的事务在id值为 8 的记录前边的间隙插入新记录</code>，其实就是id列的值( 3 , 8 )这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为 4 的新记录，它定位到该条新记录的下一条记录的id值为 8 ，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间( 3 , 8 )中的新记录才可以被插入。</p>
<p>**gap锁的提出仅仅是为了防止插入幻影记录而提出的 **。虽然有<code>共享gap锁</code>和<code>独占gap锁</code>这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁（不论是共享gap锁还是独占gap锁)，并不会限制其他事务对这条记录加记录锁或者继续加gap锁。</p>
<table>
<thead>
<tr>
<th>session 1</th>
<th>session 2</th>
</tr>
</thead>
<tbody><tr>
<td>select *from student where id &#x3D;5 lock in share mode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>select * from student where id &#x3D; 5 for update;</td>
</tr>
</tbody></table>
<p>这里session 2并不会被堵住。因为表里并没有id&#x3D;5这个记录，因此session 1加的是间隙锁（3,8)。而session 2也是在这个间隙加的间隙锁。它们有共同的目标，即:保护这个间隙，不允许插入值。但，它们之间是不冲突的。</p>
<p>注意，给一条记录加了<code>gap锁</code>知识不允许其他事务往这条记录前边的间隙插入新纪录，那对于最后一条记录之后的间隙，也就是 student 表中 id 值为 20 的记录之后的间隙该咋办呢？也就是说给哪条记录加 <code>gap锁</code> 才能阻止其他事务插入 id 值在 (20, +∞) 这个区间的新纪录呢？这时候我们再将数据页时介绍的两条伪记录派上用场了：</p>
<ul>
<li><code>Infimum</code>记录，表示该页面中最小的记录</li>
<li><code>Supremum</code>记录，表示该页面中最大的记录</li>
</ul>
<p>为了实现组织其他事务插入id值在(20, +∞) 这个区间的新纪录，我们可以给索引中的最后一条记录，也就是id值为 20 的那条记录所在页面的 Supremum 记录加上一个 gap锁，如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131131933042.png" alt="image-20230131131933042" style="zoom:50%;" />

<p><strong>③ 临键锁（Next-Key Locks）</strong></p>
<p>有时候我们既想<code>锁住某条记录</code>，又想<code>阻止</code>其他事务在该记录前边的<code>间隙插入新记录</code>，所以InnoDB就提出了一种称之为<code>Next-Key Locks的锁</code>，官方的类型名称为：<code>LOCK_ORDINARY</code>，我们也可以简称为next-key锁。<code>Next-Key Locks</code>是在存储引擎innodb、事务级别在<code>可重复读</code>的情况下使用的数据库锁，innodb默认的锁就是Next-Key locks。比如吧id值为 8 的那条记录加一个 next-key锁的示意图如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131132319500.png" alt="image-20230131132319500" style="zoom:50%;" />

<p><code>next-key锁</code>的本纸就是一个记录锁和一个gap锁的合体，他技能保护该条记录，又能阻止别的事务将新纪录插入被保护记录前边的间隙。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">8</span> <span class="keyword">and</span> id <span class="operator">&gt;</span> <span class="number">3</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p><strong>④ 插入意向锁（Insert Intention Locks）</strong></p>
<p>我们说一个事务在<code>插入</code>一条记录时需要判断一下插入位置是不是被别的事务加了<code>gap锁</code>（<code>next-key锁</code>也包含<code>gap锁</code>），如果有的话，插入操作需要等待，直到拥有<code>gap锁</code>的那个事务提交。但是 InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构 ，表明有事务想在某个间隙中插入新记录，但是现在在等待。InnoDB就把这种类型的锁命名为<code>Insert Intention Locks</code>，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，我们称为插入意向锁。插入意向锁是一种Gap锁，不是意向锁，在insert操作时产生。</p>
<p>插入意向锁是在插入一条记录行前，由 <code>INSERT 操作产生的一种间隙锁。</code>该锁用以表示插入意向，当多个事务在同一区间(gap)插入位置不同的多条数据时，事物之间不需要互相等待。假设存在两条值分别为 4 和 7 的记录，两个不同的事务分别是图插入值为 5 和 6 的两条记录，每个事务在获取插入行上独占 (排他) 锁前，都会获取 (4, 7)之间的间隙锁，但是因为数据行之间并不冲突，所以两个事物之间并不会产生冲突(阻塞等待)。</p>
<p>总结来说，插入意向锁的特性可以分成两部分：</p>
<p>（1）插入意向锁是一种特殊的间隙锁——间隙锁可以锁定开区间的部分记录。</p>
<p>（2）插入意向锁之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身 (主键、唯一索引)不冲突，那么事务之间就不会出现冲突等待。</p>
<p>注意，虽然插入意向锁中含有意向锁三字，但是他并不属于意向锁而属于间隙锁，因为意象锁是表锁而插入意向锁是行锁。</p>
<p>事实上<strong>插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁</strong>。</p>
<p><strong>3.2.3 页锁</strong></p>
<p>页锁就是在<code>页的粒度</code>上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。 <strong>页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong></p>
<p>每个层级的锁数量是有限制的，因为锁会占用内存空间，<code>锁空间的大小是有限的</code>。当某个层级的锁数量超过了这个层级的阈值时，就会进行<code>锁升级</code>。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p>
<h4 id="3-3-从对待锁的态度划分-乐观锁、悲观锁"><a href="#3-3-从对待锁的态度划分-乐观锁、悲观锁" class="headerlink" title="3.3 从对待锁的态度划分:乐观锁、悲观锁"></a>3.3 从对待锁的态度划分:乐观锁、悲观锁</h4><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%82%B2%E8%A7%82%E9%94%81&spm=1001.2101.3001.7020">悲观锁</a>，从名字中也可以看出这两种锁是两种看待<code>数据并发的思维方式</code>。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的<code>设计思想</code>。</p>
<p><strong>悲观锁（Pessimistic Locking）</strong><br>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。</p>
<p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<code>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</code>）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p>
<p><strong>乐观锁（Optimistic Locking）</strong><br>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是<code>不采用数据库自身的锁机制，而是通过程序来实现</code>。在程序上，我们可以采用<code>版本号机制</code>或者<code>CAS机制实现</code>。<code>乐观锁适用于多读的应用类型，这样可以提高吞吐量</code>。在Java中java.util.concurrent.atomic包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。</p>
<p><strong>乐观锁的版本号机制</strong></p>
<p>在表中设计一个<code>版本字段 version</code>，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行<code>UPDATE ... SET version=version+1 WHERE version=version</code>。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</p>
<p><strong>2. 乐观锁的时间戳机制</strong></p>
<p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。</p>
<p>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或者时间戳），从而证明当前拿到的数据是否最新。</p>
<p><strong>两种锁的适用场景</strong></p>
<p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p>
<ul>
<li><code>乐观锁适合读操作多的场景</code>，相对来说写的操作比较少。它的优点在于程序实现，不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</li>
<li><code>悲观锁适合写操作多的场景</code>，因为写的操作具有<code>排它性</code>。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止<code>读 - 写</code>和<code>写 - 写</code>的冲突。</li>
</ul>
<h4 id="3-4-按加锁的方式划分：显式锁、隐式锁"><a href="#3-4-按加锁的方式划分：显式锁、隐式锁" class="headerlink" title="3.4 按加锁的方式划分：显式锁、隐式锁"></a>3.4 按加锁的方式划分：显式锁、隐式锁</h4><p><strong>隐式锁</strong><br>一个事务在<code>执行INSERT操作</code>时，如果即将插入的间隙已经被其他事务加了gap锁，那么本次INSERT操作会阻塞，并且当前事务会在该间隙上加一个<code>插入意向锁</code>，否则一般情况下<code>INSERT操作</code>是不加锁的。那如果一个事务首先插入了一条记录（此时并没有在内存生产与该记录关联的锁结构）,然后另一个事务：</p>
<ul>
<li><p>立即使用<code>SELECT...LOCK IN SHARE MODE</code>语句读取这条记录，也就是要获取这条记录的S锁，或者使用<code>SELECT...FOR UPDATE</code>语句读取这条记录，也就是要获取这条记录的X锁，怎么办？如果允许这种情况的发生，那么可能产生<code>脏读</code>问题。</p>
</li>
<li><p>立即修改这条记录，也就是要获取这条记录的X锁，怎么办？<br>  如果允许这种情况的发生，那么可能产生脏写问题。</p>
</li>
</ul>
<p>这时候我们前边提过的事务id又要起作用了。我们把聚簇索引和二级索引中的记录分开看一下：</p>
<ul>
<li><p>情景一： 对于聚簇索引记录来说，有一个<code>trx_id隐藏列</code>，</p>
</li>
<li><p>该隐藏列记录着最后改动该记录的事务id。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的trx_id隐藏列代表的的就是当前事务的事务id，如果其他事务此时想对该记录添加S锁或者X锁时，首先会看一下该记录的trx_id隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个X锁（也就是为当前事务创建一个锁结构，is_waiting属性是false），然后自己进入等待状态（也就是为自己也创建一个锁结构，is_waiting属性是true）。</p>
</li>
<li><p>情景二： 对于二级索引记录来说，本身并没有trx_id隐藏列，但是在二级索引页面的PageHeader部分有一个<code>PAGE_MAX_TRX_ID</code>属性，该属性代表对该页面做改动的最大的事务id，如果<code>PAGE_MAX_TRX_ID</code>属性值小于当前最小的活跃事务id，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复情景一的做法。</p>
</li>
</ul>
<p>即：一个事务对新插入的记录可以不显式的加锁（生成一个锁结构）,但是由于事务id的存在，相当于加了一个<code>隐式锁</code>。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。隐式锁是一种<code>延迟加锁</code>的机制，从而来减少加锁的数量。</p>
<p><strong>隐式锁的逻辑过程如下</strong>：</p>
<p>A. InnoDB的每条记录中都一个隐含的trx_id字段，这个字段存在于聚簇索引的B+Tree中。</p>
<p>B. 在操作一条记录前，首先根据记录中的trx_id检查该事务是否是活动的事务(未提交或回滚)。如果是活动的事务，首先将隐式锁转换为显式锁(就是为该事务添加一个锁)。</p>
<p>C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为waiting状态。如果没有冲突不加锁，跳到E。</p>
<p>D. 等待加锁成功，被唤醒，或者超时。</p>
<p>E. 写数据，并将自己的trx_id写入trx_id字段。</p>
<p><strong>显式锁</strong></p>
<p>通过特定的语句进行加锁，我们一般称之为显示加锁，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">显示加共享锁：</span><br><span class="line"><span class="keyword">select</span> ....  lock <span class="keyword">in</span> share mode</span><br><span class="line">显示加排它锁：</span><br><span class="line"><span class="keyword">select</span> ....  <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-其它锁之：全局锁"><a href="#3-5-其它锁之：全局锁" class="headerlink" title="3.5 其它锁之：全局锁"></a>3.5 其它锁之：全局锁</h4><p>全局锁就是<code>对整个数据库实例加锁</code>。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用场景是：<code>做全库逻辑备份</code>。</p>
<p>全局锁的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables <span class="keyword">with</span> read lock</span><br></pre></td></tr></table></figure>

<h4 id="3-6-其它锁之：死锁"><a href="#3-6-其它锁之：死锁" class="headerlink" title="3.6 其它锁之：死锁"></a>3.6 其它锁之：死锁</h4><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。死锁示例：</p>
<table>
<thead>
<tr>
<th>事务1</th>
<th>事务2</th>
</tr>
</thead>
<tbody><tr>
<td>start transaction;update account set money&#x3D;10 where id&#x3D;1;</td>
<td>start transaction;</td>
</tr>
<tr>
<td></td>
<td>update account set money&#x3D;10 where id&#x3D;2;</td>
</tr>
<tr>
<td>update account set money&#x3D;20 where id&#x3D;2;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update account set money&#x3D;20 where id&#x3D;1;</td>
</tr>
</tbody></table>
<p>这时候，事务 1 在等待事务 2 释放id&#x3D;2的行锁，而事务 2 在等待事务 1 释放id&#x3D;1的行锁。 事务 1 和事务 2 在互相等待对方的资源释放，就是进入了死锁状态。</p>
<p><strong>产生死锁的必要条件</strong></p>
<ul>
<li>两个或者两个以上事务</li>
<li>每个事务都已经持有锁并且申请新的锁</li>
<li>锁资源同时只能被同一个事务持有或者不兼容</li>
<li>事务之间因为持有锁和申请锁导致彼此循环等待</li>
</ul>
<blockquote>
<p>死锁的关键在于：两个（或以上）的Session加锁的顺序不一致。</p>
</blockquote>
<p><strong>如何处理死锁</strong><br>当出现死锁以后，有两种策略：</p>
<ul>
<li><p><strong>等待，直到超时（innodb_lock_wait_timeout&#x3D;50s)。</strong></p>
<p>  即当两个事务互相等待时，当一个事务等待时间超过设置的國值时，<code>就将其回滚</code>，另外事务继续进行。这种方法简单有效，在innodb中，参数<code>innodb_lock_wait_timeout</code>用来设置超时时间。</p>
<p>  缺点：对于在线服务来说，这个等待时间往往是无法接受的。</p>
<p>  那将此值修改短一些，比如1s,0.1s是否合适？不合适，容易误伤到普通的锁等待。</p>
</li>
<li><p><strong>使用死锁检测进行死锁处理</strong></p>
<p>  方式1检测死锁太过被动，innodb还提供了<code>wait-for graph</code>算法来主动进行死锁检测，每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。</p>
<p>  这是一种较为<code>主动的死锁检测机制</code>，要求数据库保存<code>锁的信息链表</code>和<code>事务等待链表</code>两部分信息。</p>
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131135751675.png" alt="image-20230131135751675" style="zoom:50%;" />

<p>  基于这两个信息，可以绘制wait-for graph(等待图)</p>
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131135848718.png" alt="image-20230131135848718" style="zoom:50%;" />

<blockquote>
<p>死锁检测的原理是构建一个以事务为顶点、锁为边的有向图，判断有向图是否存在环，存在即有死锁。</p>
</blockquote>
<p>  一旦检测到回路、有死锁，这时候 InnoDB 存储引擎会选择<code>回滚 undo量最小的事务</code>，让其他事务继续执行(<code>innodb_deadlock_detect=on</code>表示开启这个逻辑)。</p>
<p>  缺点：每个新的被阻塞的线程，都要判断是不是由于自己的加入导致了死锁，这个操作时间复杂度是 O(n)。如果 100 个并发线程同时更新同一行，意味着要检测 100*100&#x3D;1万次，1万个线程就会有 1 千万次检测。</p>
<p>  <strong>如何解决</strong>？</p>
<ul>
<li>关闭死锁检测，但意味着可能会出现大量的超时，会导致业务有损。</li>
<li>控制并发访问的数量。比如在中间件中实现对于相同行的更新，在进入引擎之前排队，这样在 InnoDb 内部就不会有大量的死锁检测工作。</li>
</ul>
<p>  <strong>一进步的思路</strong>：</p>
<p>  可以考虑通过将一行改成逻辑上的多行来减少锁冲突。比如，连锁超市账户总额的记录，可以考虑放到多条记录上。账户总额等于这多个记录的值的总和。</p>
</li>
</ul>
<p><strong>如何避免死锁</strong></p>
<ul>
<li>合理设计索引，使业务 SQL 尽可能通过索引定位更少的行，减少锁竞争。</li>
<li>调整业务逻辑 SQL 执行顺序，避免 update&#x2F;delete 长时间持有锁的 SQL 在事务前面。</li>
<li>避免大事务，尽量将大事务拆成多个小事务来处理，小事务缩短锁定资源的时间，发生锁冲突的几率也更小。</li>
<li>在并发比较高的系统中，不要显式加锁，特别是在事务里显式加锁。如 select.. for update 语句，如果是在事务里运行了 start transaction 或设置了 autocommit &#x3D; 0，那么就会锁定所查找到的记录。</li>
<li>降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为 RC，可以避免掉很多因为 gap 锁造成的死锁。</li>
</ul>
<h3 id="4-锁的内存结构"><a href="#4-锁的内存结构" class="headerlink" title="4. 锁的内存结构"></a>4. 锁的内存结构</h3><p>我们前边说对一条记录加锁的本质就是在内存中创建一个<code>锁结构</code>与之关联，那么是不是一个事务对多条记录加锁，就要创建多个锁结构呢？比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#事务T1</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure>

<p>理论上创建多个<code>锁结构</code>没问题，但是如果一个事务要获取1000条记录的锁，生成10000个锁结构也太崩溃了！所以决定在对不同记录加锁时，如果符合下边这些条件的记录会放到一个锁结构中。</p>
<ul>
<li>在同一个事务中进行加锁操作</li>
<li>被加锁的记录在同一个页面中</li>
<li>加锁的类型是一样的</li>
<li>等待状态是一样的</li>
</ul>
<p>InnoDB存储引擎中的锁结构如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131141425303.png" alt="image-20230131141425303" style="zoom:50%;" />

<p><strong>结构解析：</strong></p>
<ol>
<li><p>锁所在的事务信息：<br> 不论是<code>表锁</code>还是<code>行锁</code>，都是在事务执行过程中生成的，哪个事务生成了这个<code>锁结构</code>，这里就记录这个事务的信息。</p>
<p> 此<code>锁所在的事务信息</code>在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p>
</li>
<li><p>索引信息：<br> 对于行锁来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p>
</li>
<li><p>表锁／行锁信息：<br> <code>表锁结构</code>和<code>行锁结构</code>在这个位置的内容是不同的：</p>
<ul>
<li><p>表锁：<br>  记载着是对哪个表加的锁，还有其他的一些信息。</p>
</li>
<li><p>行锁：</p>
<p>  记载了三个重要的信息：</p>
<ul>
<li><p>Space ID：记录所在表空间。</p>
</li>
<li><p>Page Number：记录所在页号。</p>
</li>
<li><p>n_bits：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits属性代表使用了多少比特位。</p>
<blockquote>
<p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后<br>也不至于重新分配锁结构</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>type_mode：<br> 这是一个 32 位的数，被分成了lock_mode、lock_type和rec_lock_type三个部分，如图所示：</p>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131141725339.png" alt="image-20230131141725339" style="zoom:50%;" />

<ul>
<li><p>锁的模式（lock_mode），占用低 4 位，可选的值如下：</p>
<ul>
<li><p>LOCK_IS（十进制的 0 ）：表示共享意向锁，也就是IS锁。</p>
</li>
<li><p>LOCK_IX（十进制的 1 ）：表示独占意向锁，也就是IX锁。</p>
</li>
<li><p>LOCK_S（十进制的 2 ）：表示共享锁，也就是S锁。</p>
</li>
<li><p>LOCK_X（十进制的 3 ）：表示独占锁，也就是X锁。</p>
</li>
<li><p>LOCK_AUTO_INC（十进制的 4 ）：表示AUTO-INC锁。</p>
</li>
</ul>
<p>  在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p>
</li>
<li><p>锁的类型（lock_type），占用第 5 ～ 8 位，不过现阶段只有第 5 位和第 6 位被使用：</p>
<ul>
<li>LOCK_TABLE（十进制的 16 ），也就是当第 5 个比特位置为 1 时，表示表级锁。</li>
<li>LOCK_REC（十进制的 32 ），也就是当第 6 个比特位置为 1 时，表示行级锁。</li>
</ul>
</li>
<li><p>行锁的具体类型（rec_lock_type），使用其余的位来表示。只有在lock_type的值为</p>
<ul>
<li>LOCK_REC时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：</li>
<li>LOCK_ORDINARY（十进制的 0 ）：表示next-key锁。</li>
<li>LOCK_GAP（十进制的 512 ）：也就是当第 10 个比特位置为 1 时，表示gap锁。</li>
<li>LOCK_REC_NOT_GAP（十进制的 1024 ）：也就是当第 11 个比特位置为 1 时，表示正经记录锁。</li>
<li>LOCK_INSERT_INTENTION（十进制的 2048 ）：也就是当第 12 个比特位置为 1 时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li>
</ul>
</li>
<li><p>is_waiting属性呢？基于内存空间的节省，所以把is_waiting属性放到了type_mode这个 32位的数字中：</p>
<ul>
<li>LOCK_WAIT（十进制的 256 ） ：当第 9 个比特位置为 1 时，表示is_waiting为true，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示is_waiting为false，也就是当前事务获取锁成功。</li>
</ul>
</li>
</ul>
<ol start="5">
<li>其他信息：<br> 为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</li>
<li>一堆比特位：<br> 如果是行锁结构的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的n_bits属性表示的。InnoDB数据页中的每条记录在记录头信息中都包含一个heap_no属性，伪记录Infimum的heap_no值为 0 ，Supremum的heap_no值为 1 ，之后每插入一条记录，heap_no值就增 1 。锁结构最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个heap_no，即一个比特位映射到页内的一条记录。</li>
</ol>
<h3 id="5-锁监控"><a href="#5-锁监控" class="headerlink" title="5. 锁监控"></a>5. 锁监控</h3><p>关于MySQL锁的监控，我们一般可以通过检查<code>InnoDB_row_lock</code>等状态变量来分析系统上的行锁的争夺情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                 <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_current_waits <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_time          <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_time_avg      <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_time_max      <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_waits         <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+-------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p><strong>对各个状态量的说明如下：</strong></p>
<ul>
<li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li>
<li><code>Innodb_row_lock_time</code>：从系统启动到现在锁定总时间长度；（等待总时长）</li>
<li><code>Innodb_row_lock_time_avg</code>：每次等待所花平均时间；（等待平均时长）</li>
<li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li>
<li><code>Innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数；（等待总次数）</li>
</ul>
<p><strong>其他监控方法：</strong><br>MySQL把事务和锁的信息记录在了<code>information_schema库</code>中，涉及到的三张表分别是<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>。</p>
<p>MySQL5.7及之前，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。</p>
<p>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了<code>performance_schema.data_locks</code>，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，<code>performance_schema.data_locks</code>不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p>
<p>同时，<code>information_schema.INNODB_LOCK_WAITS</code>也被<code>performance_schema.data_lock_waits</code>所代替。</p>
<h2 id="十四、多版本并发控制"><a href="#十四、多版本并发控制" class="headerlink" title="十四、多版本并发控制"></a>十四、多版本并发控制</h2><h3 id="1-什么是-MVCC"><a href="#1-什么是-MVCC" class="headerlink" title="1. 什么是 MVCC"></a>1. 什么是 MVCC</h3><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的<code>并发控制</code>。这项技术使得在InnoDB的事务<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB&spm=1001.2101.3001.7020">隔离级别</a>下执行<code>一致性读</code>操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</p>
<p>MVCC没有正式的标准，在不同的DBMS中MVCC的实现方式可能是不同的，也不是普遍使用的(大家可以参考相关的DBMS文档)。这里讲解InnoDB 中MVCC的实现机制（MySQL其它的存储引擎并不支持它)。</p>
<h3 id="2-快照读与当前读"><a href="#2-快照读与当前读" class="headerlink" title="2. 快照读与当前读"></a>2. 快照读与当前读</h3><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理<code>读-写</code>冲突，做到即使有读写冲突时，也能做到<code>不加锁，非阻塞并发读</code>，而这个读指的就是<code>快照读</code>, 而非当前读。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p>
<h4 id="2-1-快照读"><a href="#2-1-快照读" class="headerlink" title="2.1 快照读"></a>2.1 快照读</h4><p>快照读又叫一致性读，读取的是快照数据。 <strong>不加锁的简单的 SELECT 都属于快照读</strong> ，即不加锁的非阻塞读；比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>

<p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。</p>
<p>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</p>
<p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p>
<h4 id="2-2-当前读"><a href="#2-2-当前读" class="headerlink" title="2.2 当前读"></a>2.2 当前读</h4><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前读。比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LOCK <span class="keyword">IN</span> SHARE MODE;  # 共享锁</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; # 排他锁</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span> ...  # 排他锁</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> ...  # 排他锁</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> ...  # 排他锁</span><br></pre></td></tr></table></figure>

<h3 id="3-复习"><a href="#3-复习" class="headerlink" title="3. 复习"></a>3. 复习</h3><h4 id="3-1-再谈隔离级别"><a href="#3-1-再谈隔离级别" class="headerlink" title="3.1 再谈隔离级别"></a>3.1 再谈隔离级别</h4><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131142926434.png" alt="image-20230131142926434" style="zoom:50%;" />

<p>在MySQL中，默认的隔离级别是可重复读，可以解决脏读和不可重复读的问题，如果仅从定义的角度来看，它并不能解决<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%B9%BB%E8%AF%BB&spm=1001.2101.3001.7020">幻读</a>问题。如果我们想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力。</p>
<p>MVCC 可以不采用锁机制，而是通过乐观锁的方式来解决不可重复读和幻读问题!它可以在大多数情况下替代行级锁，降低系统的开销。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131143022253.png" alt="image-20230131143022253" style="zoom:50%;" />

<h4 id="3-2-隐藏字段、Undo-Log版本链"><a href="#3-2-隐藏字段、Undo-Log版本链" class="headerlink" title="3.2 隐藏字段、Undo Log版本链"></a>3.2 隐藏字段、Undo Log版本链</h4><p>回顾一下undo日志的版本链，对于使用<code>InnoDB</code>存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列(字段)。</p>
<ul>
<li><code>trx_id</code>：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。</li>
<li><code>roll_pointer</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到<code>undo日志</code>中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
<p>举例：student 表数据如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> class  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 张三   <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>假设插入该记录的事务id为8，那么此刻该条记录的示意图如下所示:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131143159781.png" alt="image-20230131143159781" style="zoom:50%;" />

<blockquote>
<p>insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的UndoLog Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。</p>
</blockquote>
<p>假设之后两个事务id分别为 10 、 20 的事务对这条记录进行UPDATE操作，操作流程如下：</p>
<table>
<thead>
<tr>
<th align="center">发生时间顺序</th>
<th align="center">事务10</th>
<th align="center">事务20</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">BEGIN;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center">BEGIN;</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">UPDATE student SET name&#x3D;“李四” WHERE id&#x3D;1;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">UPDATE student SET name&#x3D;“王五” WHERE id&#x3D;1;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">COMMIT;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"></td>
<td align="center">UPDATE student SET name&#x3D;“钱七” WHERE id&#x3D;1;</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"></td>
<td align="center">UPDATE student SET name&#x3D;“宋八” WHERE id&#x3D;1;</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"></td>
<td align="center">COMMIT;</td>
</tr>
</tbody></table>
<blockquote>
<p>能不能在两个事务中交叉更新同一条记录呢?不能!这不就是一个事务修改了另一个未提交事务修改过的数据，脏写。<br>InnoDB使用锁来保证不会有脏写情况的发生，也就是在第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。</p>
</blockquote>
<p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个<code>roll_pointer</code>属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些<code>undo日志</code>都连起来，串成一个链表：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131143518958.png" alt="image-20230131143518958" style="zoom:50%;" />

<p>对该记录每次更新后，都会将旧值放到一条<code>undo日志</code>中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被<code>roll_pointer</code>属性连接成一个链表，我们把这个链表称之为<code>版本链</code>，版本链的头节点就是当前记录最新的值。</p>
<p>每个版本中还包含生成该版本时对应的<code>事务id</code>。</p>
<h3 id="4-MVCC实现原理之ReadView"><a href="#4-MVCC实现原理之ReadView" class="headerlink" title="4. MVCC实现原理之ReadView"></a>4. MVCC实现原理之ReadView</h3><p>MVCC 的实现依赖于： <code>隐藏字段</code>、<code>Undo Log</code>、<code>Read View</code> 。</p>
<h4 id="4-1-什么是ReadView"><a href="#4-1-什么是ReadView" class="headerlink" title="4.1 什么是ReadView"></a>4.1 什么是ReadView</h4><p>在MVCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在Undo Log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢?这时就需要用到ReadView了，它帮我们解决了行的可见性问题。</p>
<p>ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前<code>活跃事务的ID</code>(“活跃”指的就是，启动了但还没提交)。</p>
<h4 id="4-2-设计思路"><a href="#4-2-设计思路" class="headerlink" title="4.2 设计思路"></a>4.2 设计思路</h4><p>使用<code>READ UNCOMMITTED</code>隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</p>
<p>使用<code>SERIALIZABLE</code>隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p>
<p>使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务，都必须保证读到已经提交了的事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p>
<p>这个ReadView中主要包含 4 个比较重要的内容，分别如下：</p>
<ol>
<li><p><code>creator_trx_id</code>，创建这个 Read View 的事务 ID。</p>
<blockquote>
<p>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为 0 。</p>
</blockquote>
</li>
<li><p><code>trx_ids</code>，表示在生成ReadView时当前系统中活跃的读写事务的<code>事务id列表</code>。</p>
</li>
<li><p><code>up_limit_id</code>，活跃的事务中最小的事务 ID。</p>
</li>
<li><p><code>low_limit_id</code>，表示生成ReadView时系统中应该分配给下一个事务的<code>id</code>值。<code>low_limit_id </code>是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID</p>
<blockquote>
<p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为 1 ，2 ， 3 这三个事务，之后id为 3 的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括 1 和 2 ，up_limit_id的值就是 1 ，low_limit_id的值就是 4 。</p>
</blockquote>
</li>
</ol>
<p>举例:</p>
<p>trx_ids为tr2、tr3、tr:5和trx8的集合，系统的最大事务ID (low_limit_id)为trx8+1(如果之前没有其他的新增事务)，活跃的最小事务ID (up_limit_id)为trx2。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131143947011.png" alt="image-20230131143947011" style="zoom:50%;" />

<h4 id="4-3-ReadView的规则"><a href="#4-3-ReadView的规则" class="headerlink" title="4.3 ReadView的规则"></a>4.3 ReadView的规则</h4><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p>
<ul>
<li><p>如果被访问版本的trx_id属性值与ReadView中的<code>creator_trx_id</code>值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</p>
</li>
<li><p>如果被访问版本的trx_id属性值小于ReadView中的<code>up_limit_id</code>值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</p>
</li>
<li><p>如果被访问版本的trx_id属性值大于或等于ReadView中的<code>low_limit_id</code>值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</p>
</li>
<li><p>如果被访问版本的trx_id属性值在ReadView的<code>up_limit_id</code>和<code>low_limit_id</code>之间，那就需要判断一下trx_id属性值是不是在trx_ids列表中。</p>
<ul>
<li><p>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</p>
</li>
<li><p>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</p>
</li>
</ul>
</li>
</ul>
<h4 id="4-4-MVCC整体操作流程"><a href="#4-4-MVCC整体操作流程" class="headerlink" title="4.4 MVCC整体操作流程"></a>4.4 MVCC整体操作流程</h4><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p>
<ul>
<li>首先获取事务自己的版本号，也就是事务 ID；</li>
<li>生成 ReadView；</li>
<li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li>
<li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</li>
<li>最后返回符合规则的数据。</li>
</ul>
<p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p>
<blockquote>
<p>lnnoDB中，MVCC是通过Undo Log + Read View进行数据读取，Undo Log保存了历史快照，而Read View规则帮我们判断当前版本的数据是否可见。</p>
</blockquote>
<p>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次Read View。</p>
<table>
<thead>
<tr>
<th align="center">事务</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">select * from student where id &gt;2;</td>
<td align="center">获取一次Read View</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">select * from student where id &gt;2;</td>
<td align="center">获取一次Read View</td>
</tr>
<tr>
<td align="center">commit;</td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。</p>
</blockquote>
<p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131144258799.png" alt="image-20230131144258799" style="zoom:50%;" />

<h3 id="5-举例说明"><a href="#5-举例说明" class="headerlink" title="5 举例说明"></a>5 举例说明</h3><p>假设现在 student 表中只有一条由事务ID为 8 的事务插入的一条记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> class  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 张三   <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>MVCC只能在 read committed 和repeatable read 两个隔离级别下工作。接下来看一下 read committed 和repeatable read 所谓的生成readview 的时机不同到底不同在哪里</p>
<h4 id="5-1-READ-COMMITTED-隔离级别下"><a href="#5-1-READ-COMMITTED-隔离级别下" class="headerlink" title="5.1 READ COMMITTED 隔离级别下"></a>5.1 READ COMMITTED 隔离级别下</h4><p><strong>READ COMMITTED ：每次读取数据前都生成一个ReadView 。</strong><br>现在有两个事务id分别为 10 、 20 的事务在执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明:事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句)，才会被<br>分配一个单独的事务id，这个事务id是递增的。所以我们才在事务2中更新些别的表的记录，目的是让它分<br>配事务id。</p>
</blockquote>
<p>此刻，表 student中id为1的记录得到的版本链表如下所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131144803904.png" alt="image-20230131144803904" style="zoom:50%;" />

<p>假设现在有一个使用READ COMMITTED隔离级别的事务开始执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、 <span class="number">20</span> 未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> ; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个SELECT1的执行过程如下:</p>
<p>步骤1: 在执行SELECT语句时会先生成一个<code>ReadView</code> , ReadView的<code> trx_ids列表</code>的内容就是<code>[10，20]</code>，<code>up_limit_id为10</code>, <code>low_limit_id为21</code>, <code>creator_trx_id为0</code>。</p>
<p>步骤2:从版本链中挑选可见的记录，从图中看出，最新版本的列<code>name</code>的内容是<code>’王五’</code>，该版本的<code>trx_id</code>值为<code>10</code>，在<code>trx_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</p>
<p>步骤3:下一个版本的列<code>name</code>的内容是’李四’，该版本的<code>trx_id</code>值也为<code>10</code>，也在<code>trx_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</p>
<p>步骤4:下一个版本的列name的内容是’张三’，该版本的<code>trx_id</code>值为<code>8</code>，小于<code>ReadView</code>中的<code>up_limit_id</code>值<code>10</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘张三’的记录。</p>
<p>之后，我们把事务id为 10 的事务提交一下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>然后再到事务id为 20 的事务中更新一下表student中id为 1 的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;钱七&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;宋八&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br></pre></td></tr></table></figure>

<p>此刻，表student中id为 1 的记录的版本链就长这样：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131144953806.png" alt="image-20230131144953806"></p>
<p>然后再到刚才使用READ COMMITTED隔离级别的事务中继续查找这个id为 1 的记录，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、 <span class="number">20</span> 均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> ; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction <span class="number">10</span>提交，Transaction <span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> ; # 得到的列name的值为<span class="string">&#x27;王五&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个<code>SELECT2</code>的执行过程如下:</p>
<p>步骤1:在执行<code>SELECT</code>语句时会又会单独生成一个<code>ReadView</code>，该<code>ReadView的trx_ids列表</code>的内容就是<code>[20],up_limitid为.20,low_limit_id为21, creator_trx_id为0。</code></p>
<p>步骤2:从版本链中挑选可见的记录，从图中看出，最新版本的列name的内容是‘宋八‘，该版本的trx_id值为20，在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</p>
<p>步骤3:下一个版本的列name的内容是‘钱七’，该版本的trx_id值为28，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。</p>
<p>步骤4:下一个版本的列name的内容是’王五’，该版本的trx_id值为10，小于ReadView中的up_limit_id值20，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘王五‘的记录。</p>
<p>以此类推，如果之后事务id为20的记录也提交了，再次在使用READ COMMITTED隔离级别的事务中查询表student中id值为1的记录时，得到的结果就是‘宋八’了，具体流程我们就不分析了。</p>
<blockquote>
<p>强调: 使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p>
</blockquote>
<h4 id="5-2-REPEATABLE-READ隔离级别下"><a href="#5-2-REPEATABLE-READ隔离级别下" class="headerlink" title="5.2 REPEATABLE READ隔离级别下"></a>5.2 REPEATABLE READ隔离级别下</h4><p>使用<code>REPEATABLE READ</code>隔离级别的事务来说，<code>只会在第一次</code>执行查询语句时生成一个<code>ReadView</code>，之后的查询就不会重复生成了。</p>
<p>比如，系统里有两个事务id分别为 10 、 20 的事务在执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>此刻，表student 中id为 1 的记录得到的版本链表如下所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131145345166.png" alt="image-20230131145345166" style="zoom:50%;" />

<p>假设现在有一个使用<code>REPEATABLE READ</code>隔离级别的事务开始执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、 <span class="number">20</span> 未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> ; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个SELECT1的执行过程如下（第一个ReadView和读已提交是一样的):</p>
<p>步骤1: 在执行SELECT语句时会先生成一个ReadView , ReadView的<code>trx_ids</code>列表的内容就是<code>[10，20]</code>，<code>up_limit_id为10</code>, <code>low_limit_id为21</code>, <code>creator_trx_id为0</code>。</p>
<p>步骤2:从版本链中挑选可见的记录，从图中看出，最新版本的列name的内容是’王五’，该版本的trx_id值为10，在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</p>
<p>步骤3:下一个版本的列name的内容是’李四’，该版本的trx_id值也为10，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。</p>
<p>步骤4:下一个版本的列name的内容是’张三’，该版本的trx_id值为8，小于ReadView中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘张三’的记录。</p>
<p>之后，我们把事务id为 10 的事务提交一下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>然后再到事务id为 20 的事务中更新一下表student中id为 1 的记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;钱七&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;宋八&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br></pre></td></tr></table></figure>

<p>此刻，表student 中id为 1 的记录的版本链长这样：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131145607213.png" alt="image-20230131145607213" style="zoom:50%;" />

<p>然后再到刚才使用REPEATABLE READ隔离级别的事务中继续查找这个id为 1 的记录，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、 <span class="number">20</span> 均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> ; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction <span class="number">10</span>提交，Transaction <span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> ; # 得到的列name的值仍为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个<code>SELECT2</code>的执行过程如下:</p>
<p>步骤1: 因为当前事务的隔离级别为 <code>REPEATABLE READ</code>，而之前在执行 <code>SELECT1</code>时已经生成过<code>ReadView</code>了，所以此时直接复用之前的<code>ReadView</code>，之前的<code>ReadView</code>的<code>trx_ids</code>列表的内容就是<code>[10，20]</code>，<code>up_limit_id</code>为<code>10</code>, <code>low_limit_id</code>为<code>21</code>, <code>creator_trx_id</code>为<code>0</code>。</p>
<p>步骤2:然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>name</code>的内容是<code>宋八</code>，该版本的<code>trx_id</code>值为<code>20</code>，在<code>trx_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</p>
<p>步骤3:下一个版本的列<code>name</code>的内容是<code>’钱七’</code>，该版本的<code>trx_id</code>值为<code>20</code>，也在<code>trx_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</p>
<p>步骤4∶下一个版本的列<code>name</code>的内容是<code>’王五’</code>，该版本的<code>trx_id</code>值为<code>10</code>，而<code>trx_ids</code>列表中是包含值为<code>10</code>的<code>事务id``的，所以该版本也不符合要求，同理下一个列</code>name<code>的内容是</code>’李四’&#96;的版本也不符合要求。继续跳到下一个版本。</p>
<p>步骤5∶下一个版本的列<code>name</code>的内容是<code>‘张三’</code>，该版本的<code>trx_id</code>值为<code>80</code>，小于<code>ReadView</code>中的<code>up_limit_id</code>值<code>10</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>c</code>为<code>‘张三’</code>的记录。</p>
<p>两次<code>SELECT</code>查询得到的结果是重复的，记录的列<code>c</code>值都是<code>‘张三’</code>，这就是<code>可重复读</code>的含义。如果我们之后再把<code>事务id</code>为<code>20</code>的记录提交了，然后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个<code>id</code>为<code>1</code>的记录，得到的结果还是<code>‘张三’</code>，具体执行过程大家可以自己分析一下。</p>
<h4 id="5-3-如何解决幻读"><a href="#5-3-如何解决幻读" class="headerlink" title="5.3 如何解决幻读"></a>5.3 如何解决幻读</h4><p>接下来说明InnoDB 是如何解决幻读的。</p>
<p>假设现在表 student 中只有一条数据，数据内容中，主键 id&#x3D;1，隐藏的 trx_id&#x3D;10，它的 undo log 如下图所示。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131150417858.png" alt="image-20230131150417858" style="zoom:50%;" />

<p>假设现在有事务 A 和事务 B 并发执行，事务 A 的事务 id 为 20 ，事务 B 的事务 id 为 30 。</p>
<p>步骤 1 ：事务 A 开始第一次查询数据，查询的 SQL 语句如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">1</span> ;</span><br></pre></td></tr></table></figure>

<p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下：<code>trx_ids=[20,30]</code>，<code>up_limit_id=20</code>，<code>low_limit_id=31</code>，<code>creator_trx_id=20</code>。</p>
<p>由于此时表 student 中只有一条数据，且符合 where id&gt;&#x3D;1 条件，因此会查询出来。然后根据 ReadView机制，发现该行数据的trx_id&#x3D;10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p>
<p>结论：事务 A 的第一次查询，能读取到一条数据，id&#x3D;1。</p>
<p>步骤 2 ：接着事务 B(trx_id&#x3D;30)，往表 student 中新插入两条数据，并提交事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id,name) <span class="keyword">values</span>( <span class="number">2</span> ,<span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id,name) <span class="keyword">values</span>( <span class="number">3</span> ,<span class="string">&#x27;王五&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>此时表student 中就有三条数据了，对应的 undo 如下图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131150637422.png" alt="image-20230131150637422" style="zoom:50%;" />

<p>步骤 3 ：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成ReadView。此时表 student 中的 3 条数据都满足 where id&gt;&#x3D;1 的条件，因此会先查出来。然后根据ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p>
<p>1 ）首先 id&#x3D;1 的这条数据，前面已经说过了，可以被事务 A 看到。</p>
<p>2 ）然后是 id&#x3D;2 的数据，它的 trx_id&#x3D;30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids&#x3D;[20,30]，因此在数组内，这表示 id&#x3D;2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</p>
<p>3 ）同理，id&#x3D;3 的这条数据，trx_id 也为 30 ，因此也不能被事务 A 看见。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131150719757.png" alt="image-20230131150719757"></p>
<p>结论：最终事务 A 的第二次查询，只能查询出 id&#x3D;1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。</p>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>这里介绍了<code>MVCC</code>在<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事务的读-写、写-读操作并发执行，从而提升系统性能。</p>
<p>核心点在于 ReadView 的原理，<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两个隔离级别的一个很大不同就是生成ReadView的时机不同：</p>
<ul>
<li><code>READ COMMITTD</code>在每一次进行普通SELECT操作前都会生成一个ReadView</li>
<li><code>REPEATABLE READ</code>只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</li>
</ul>
<blockquote>
<p>说明: 我们之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除,而是执行一个所谓的delete mark操作，相当于只是对记录打上了一个删除标志位，这主要就是为MVCc服务的。</p>
</blockquote>
<p>通过MVCC我们可以解决:</p>
<ul>
<li><code>读写之间阻塞的问题。</code>通过MVCC可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。</li>
<li><code>降低了死锁的概率。</code>这是因为MVCC采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</li>
<li><code>解决快照读的问题。</code>当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</li>
</ul>
<h2 id="十五、其他数据库日志"><a href="#十五、其他数据库日志" class="headerlink" title="十五、其他数据库日志"></a>十五、其他数据库日志</h2><p>我们在讲解数据库事务时，讲过两种日志:<code>重做日志</code>、<code>回滚日志</code>。</p>
<p>对于线上数据库应用系统，突然遭遇数据库宕机怎么办?在这种情况下，定位宕机的原因就非常关键。我们可以查看数据库的错误日志。因为日志中记录了数据库运行中的诊断信息，包括了错误、警告和注释等信息。比如:从日志中发现某个连接中的SQL操作发生了死循环，导致内存不足，被系统强行终止了。明确了原因，处理起来也就轻松了，系统很快就恢复了运行。</p>
<p>除了发现错误，日志在数据复制、数据恢复、操作审计，以及确保数据的永久性和一致性等方面，都有着不可替代的作用。</p>
<p>千万不要小看日志 。很多看似奇怪的问题，答案往往就藏在日志里。很多情况下，只有通过查看日志才能发现问题的原因，真正解决问题。所以，一定要学会查看日志，养成检查日志的习惯，对提升你的数据库应用开发能力至关重要。</p>
<p>MySQL8.0 官网日志地址：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/server-logs.html">https://dev.mysql.com/doc/refman/8.0/en/server-logs.html</a></p>
<h3 id="1-MySQL支持的日志"><a href="#1-MySQL支持的日志" class="headerlink" title="1. MySQL支持的日志"></a>1. MySQL支持的日志</h3><h4 id="1-1-日志类型"><a href="#1-1-日志类型" class="headerlink" title="1.1 日志类型"></a>1.1 日志类型</h4><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为<code>二进制日志</code>、<code>错误日志</code>、<code>通用查询日志</code>和<code>慢查询日志</code>，这也是常用的 4 种。MySQL 8又新增两种支持的日志：<code>中继日志</code>和<code>数据定义语句日志</code>。使用这些日志文件，可以查看MySQL内部发生的事情。</p>
<p><strong>这 6 类日志分别为：</strong></p>
<ul>
<li><p><code>慢查询日志： </code>记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</p>
</li>
<li><p><code>通用查询日志： </code>记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</p>
</li>
<li><p><code>错误日志：</code> 记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。<code>二进制日志：</code> 记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。</p>
</li>
<li><p><code>中继日志： </code>用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。</p>
</li>
<li><p><code>数据定义语句日志：</code> 记录数据定义语句执行的元数据操作。</p>
</li>
</ul>
<p>除二进制日志外，其他日志都是<code>文本文件</code>。默认情况下，所有日志创建于<code>MySQL数据目录</code>中。</p>
<h4 id="1-2-日志的弊端"><a href="#1-2-日志的弊端" class="headerlink" title="1.2 日志的弊端"></a>1.2 日志的弊端</h4><ul>
<li>日志功能会<code>降低MySQL数据库的性能</code>。例如，在查询非常频繁的MysQL数据库系统中，如果开启了通用查询日志和慢查询日志，MySQL数据库会花费很多时间记录日志。</li>
<li>日志会<code>占用大量的磁盘空间</code>。对于用户量非常大、操作非常频繁的数据库,日志文件需要的存储空间设置比数据库文件需要的存储空间还要大。</li>
</ul>
<h3 id="2-慢查询日志（show-query-log）"><a href="#2-慢查询日志（show-query-log）" class="headerlink" title="2. 慢查询日志（show query log）"></a>2. 慢查询日志（show query log）</h3><p>性能分析工具的使用已经讲过。</p>
<h3 id="3-通用查询日志（general-query-log）"><a href="#3-通用查询日志（general-query-log）" class="headerlink" title="3. 通用查询日志（general query log）"></a>3. 通用查询日志（general query log）</h3><p>通用查询日志用来<code>记录用户的所有操作</code>，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时， <strong>查看通用查询日志，还原操作时的具体场景</strong> ，可以帮助我们准确定位问题。</p>
<h4 id="3-1-问题场景"><a href="#3-1-问题场景" class="headerlink" title="3.1 问题场景"></a><strong>3.1 问题场景</strong></h4><p>在电商系统中，购买商品并且使用微信支付完成以后，却发现支付中心的记录并没有新增，此时用户再次使用支付宝支付，就会出现重复支付的问题。但是当去数据库中查询数据的时候，会发现只有一条记录存在。那么此时给到的现象就是只有一条支付记录，但是用户却支付了两次。</p>
<p>我们对系统进行了仔细检查，没有发现数据问题，因为用户编号和订单编号以及第三方流水号都是对的。可是用户确实支付了两次，这个时候，我们想到了检查通用查询日志，看看当天到底发生了什么。</p>
<p>查看之后，发现: 1月1日下午2点，用户使用微信支付完以后，但是由于网络故障，支付中心没有及时收到微信支付的回调通知，导致当时没有写入数据。1月1日下午2点30，用户又使用支付宝支付，此时记录更新到支付中心。1月1日晚上9点，微信的回调通知过来了，但是支付中心已经存在了支付宝的记录，所以只能覆盖记录了。</p>
<h4 id="3-2-查看当前状态"><a href="#3-2-查看当前状态" class="headerlink" title="3.2 查看当前状态"></a>3.2 查看当前状态</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> general_log <span class="operator">|</span> OFF <span class="operator">|</span> #通用查询日志处于关闭状态</span><br><span class="line"><span class="operator">|</span> general_log_file <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu01.log <span class="operator">|</span> #通用查询日志文件的名称是atguigu01.log</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>

<h4 id="3-3-启动日志"><a href="#3-3-启动日志" class="headerlink" title="3.3 启动日志"></a>3.3 启动日志</h4><p><strong>方式 1 ：永久性方式</strong></p>
<p>修改my.cnf或者my.ini配置文件来设置。在[mysqld]组下加入log选项，并重启MySQL服务。格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">general_log<span class="operator">=</span><span class="keyword">ON</span></span><br><span class="line">general_log_file<span class="operator">=</span>[path[filename]] #日志文件所在目录路径，filename为日志文件名		</span><br></pre></td></tr></table></figure>

<p>如果不指定目录和文件名，通用查询日志将默认存储在MySQL数据目录中的hostname.log文件中，hostname表示主机名。</p>
<p><strong>方式 2 ：临时性方式</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log<span class="operator">=</span><span class="keyword">on</span>;  # 开启通用查询日志</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log_file<span class="operator">=</span><span class="string">&#x27;path/filename&#x27;</span>; # 设置日志文件保存位置</span><br></pre></td></tr></table></figure>

<p>对应的，关闭操作SQL命令如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log<span class="operator">=</span>off;  # 关闭通用查询日志</span><br></pre></td></tr></table></figure>

<p>查看设置后情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;general_log%&#x27;</span>;		</span><br></pre></td></tr></table></figure>

<h4 id="3-4-查看日志"><a href="#3-4-查看日志" class="headerlink" title="3.4 查看日志"></a>3.4 查看日志</h4><p>通用查询日志是以文本文件的形式存储在文件系统中的，可以使用文本编辑器直接打开日志文件。每台MySQL服务器的通用查询日志内容是不同的。</p>
<ul>
<li>在Windows操作系统中，使用文本文件查看器；</li>
<li>在Linux系统中，可以使用vi工具或者gedit工具查看；</li>
<li>在Mac OSX系统中，可以使用文本文件查看器或者vi等工具查看。</li>
</ul>
<p>从<code>SHOW VARIABLES LIKE &#39;general_log%&#39;;</code>结果中可以看到通用查询日志的位置。</p>
<p>在通用查询日志里面，我们可以清楚地看到，什么时候开启了新的客户端登陆数据库，登录之后做了什么 SQL 操作，针对的是哪个数据表等信息。</p>
<h4 id="3-5-停止日志"><a href="#3-5-停止日志" class="headerlink" title="3.5 停止日志"></a>3.5 停止日志</h4><p><strong>方式 1 ：永久性方式</strong></p>
<p>修改my.cnf或者my.ini文件，把[mysqld]组下的general_log值设置为OFF或者把general_log一项注释掉。修改保存后，再重启MySQL服务，即可生效。<br><strong>举例 1 ：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">general_log<span class="operator">=</span>OFF</span><br></pre></td></tr></table></figure>

<p><strong>举例 2 ：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#general_log<span class="operator">=</span><span class="keyword">ON</span></span><br></pre></td></tr></table></figure>

<p><strong>方式 2 ：临时性方式</strong></p>
<p>使用SET语句停止MySQL通用查询日志功能：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log<span class="operator">=</span>off;</span><br></pre></td></tr></table></figure>

<p>查询通用日志功能：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;general_log%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-6-删除-刷新日志"><a href="#3-6-删除-刷新日志" class="headerlink" title="3.6 删除\刷新日志"></a>3.6 删除\刷新日志</h4><p>如果数据的使用非常频繁，那么通用查询日志会占用服务器非常大的磁盘空间。数据管理员可以删除很长时间之前的查询日志，以保证MySQL服务器上的硬盘空间。</p>
<p><strong>手动删除文件</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;general_log%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>可以看出，通用查询日志的目录默认为MySQL数据目录。在该目录下手动删除通用查询日志atguigu 01 .log。</p>
<p>使用如下命令重新生成查询日志文件，具体命令如下。刷新MySQL数据目录，发现创建了新的日志文件。前提一定要开启通用日志。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p flush<span class="operator">-</span>logs</span><br></pre></td></tr></table></figure>

<h3 id="4-错误日志-error-log"><a href="#4-错误日志-error-log" class="headerlink" title="4. 错误日志(error log)"></a>4. 错误日志(error log)</h3><p>错误日志记录了 MySQL 服务器启动、停止运行的时间，以及系统启动、运行和停止过程中的诊断信息，包括错误、警告和提示等。</p>
<p>通过错误日志可以查看系统的运行状态，便于及时发现故障。如果 MySQL 服务出现异常，错误日志是发现问题、解决故障的首选。</p>
<h4 id="4-1-启动日志"><a href="#4-1-启动日志" class="headerlink" title="4.1 启动日志"></a>4.1 启动日志</h4><p>在MySQL数据库中，错误日志功能是默认开启的。而且，错误日志无法被禁止。</p>
<p>默认情况下，错误日志存储在MySQL数据库的数据文件夹下，名称默认为mysqld.log（Linux系统）或hostname.err（mac系统）。如果需要制定文件名，则需要在my.cnf或者my.ini中做如下配置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log<span class="operator">-</span>error<span class="operator">=</span>[path<span class="operator">/</span>[filename]] #path为日志文件所在的目录路径，filename为日志文件名</span><br></pre></td></tr></table></figure>

<p>修改配置项后，需要重启MySQL服务以生效。</p>
<h4 id="4-2-查看日志"><a href="#4-2-查看日志" class="headerlink" title="4.2 查看日志"></a>4.2 查看日志</h4><p>MySQL错误日志是以文本文件形式存储的，可以使用文本编辑器直接查看。查询错误日志的存储路径：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;log_err%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-删除-刷新日志"><a href="#4-3-删除-刷新日志" class="headerlink" title="4.3 删除\刷新日志"></a>4.3 删除\刷新日志</h4><p>对于很久以前的错误日志，数据库管理员查看这些错误日志的可能性不大，可以将这些错误日志删除，以保证MySQL服务器上的硬盘空间。MySQL的错误日志是以文本文件的形式存储在文件系统中的，可以直接删除。</p>
<ul>
<li><p>第一步(方式一)：删除操作</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm <span class="operator">-</span>rf <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>mysqld.log</span><br></pre></td></tr></table></figure>

<p>  在运行状态下删除错误日志文件后，MySQL并不会自动创建日志文件。</p>
</li>
<li><p>第一步(方式二)：重命名文件</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> /var/log/mysqld.log /var/log/mysqld.log.old</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步：重建日志</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u root -p flush-logs</span><br></pre></td></tr></table></figure>

<p>  可能会报错：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#刷新日志</span><br><span class="line">[root<span class="variable">@kaito</span> log]# mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p flush<span class="operator">-</span>logs</span><br><span class="line">Enter password:</span><br><span class="line">mysqladmin: refresh failed; error: <span class="string">&#x27;Could not open file &#x27;</span><span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysqld.log<span class="string">&#x27; for error logging.&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  官网提示：</p>
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131164521763.png" alt="image-20230131164521763" style="zoom:50%;" /></li>
</ul>
<p>补充操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install <span class="operator">-</span>omysql <span class="operator">-</span>gmysql <span class="operator">-</span>m0644 <span class="operator">/</span>dev<span class="operator">/</span><span class="keyword">null</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysqld.log</span><br></pre></td></tr></table></figure>

<p>·flush-logs·指令操作：</p>
<ul>
<li>MySQL5.5.7以前的版本，flush-logs将错误日志文件重命名为filename.err_old,并创建新的日志文件。</li>
<li>从MySQL5.5.7开始，flush-logs只是重新打开日志文件，并不做日志备份和创建的操作。</li>
<li>如果日志文件不存在，MySQL启动或者执行flush-logs时会自动创建新的日志文件。重新创建错误日志，大小为0字节。</li>
</ul>
<h3 id="5-二进制日志-bin-log"><a href="#5-二进制日志-bin-log" class="headerlink" title="5. 二进制日志(bin log)"></a>5. 二进制日志(bin log)</h3><p>binlog可以说是MySQL中<code>比较重要</code>的日志了，在日常开发及运维过程中，经常会遇到。</p>
<p>binlog即binary log，二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的DDL和DML等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、show等）。</p>
<p>它以<code>事件形式</code>记录并保存在<code>二进制文件</code>中。通过这些信息，我们可以再现数据更新操作的全过程。</p>
<blockquote>
<p>如果想要记录所有语句（例如，为了识别有问题的查询)，需要使用通用查询日志。</p>
</blockquote>
<p><strong>binlog主要应用场景：</strong></p>
<ul>
<li>一是用于<code>数据恢复</code>，如果MySQL数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器。</li>
<li>二是用于<code>数据复制</code>，由于日志的延续性和时效性，master把它的二进制日志传递给slaves来达到master-slave数据一致的目的。</li>
</ul>
<p>可以说MySQL<strong>数据库的数据备份、主备、主主、主从</strong>都离不开binlog,需要依靠binlog来同步数据，保证数据一致性。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131165050932.png" alt="image-20230131165050932" style="zoom:50%;" />

<h4 id="5-1-查看默认情况"><a href="#5-1-查看默认情况" class="headerlink" title="5.1 查看默认情况"></a>5.1 查看默认情况</h4><p>查看记录二进制日志是否开启：在MySQL8中默认情况下，二进制文件是开启的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                   <span class="operator">|</span> <span class="keyword">Value</span>                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> log_bin                         <span class="operator">|</span> <span class="keyword">ON</span>                          <span class="operator">|</span>  <span class="operator">/</span><span class="operator">/</span>开关</span><br><span class="line"><span class="operator">|</span> log_bin_basename                <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>binlog       <span class="operator">|</span> <span class="operator">/</span><span class="operator">/</span> 存放路径</span><br><span class="line"><span class="operator">|</span> log_bin_index                   <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>binlog.index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_trust_function_creators <span class="operator">|</span> <span class="keyword">ON</span>                          <span class="operator">|</span><span class="operator">/</span><span class="operator">/</span>  函数创建 </span><br><span class="line"><span class="operator">|</span> log_bin_use_v1_row_events       <span class="operator">|</span> OFF                         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sql_log_bin                     <span class="operator">|</span> <span class="keyword">ON</span>                          <span class="operator">|</span><span class="operator">/</span><span class="operator">/</span>变更<span class="keyword">sql</span>记录下来</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+-----------------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>log_bin_basename:</code>是binlog日志的基本文件名，后面会追加标识来表示每一个文件</p>
</li>
<li><p><code>log_bin_index:</code>是binlog文件的素引文件，这个文件管理了所有的binlog文件的目录</p>
</li>
<li><p><code>log_bin_trust_function_creators:</code>限制存储过程，前面我们已经讲过了，这是因为二进制日志的一个重要功能是用于主从复制，而存储函数有可能导致主从的数据不一致。所以当开启二进制日志后，需要限制存储函数的创建、修改、调用。</p>
</li>
<li><p><code>log_bin_use_v1_row_events此只读系统变量已弃用</code>。ON表示使用版本1二进制日志行，OFF表示使用版本2二进制日志行（MySQL5.6的默认值为2)。</p>
</li>
</ul>
<h4 id="5-2-日志参数设置"><a href="#5-2-日志参数设置" class="headerlink" title="5.2 日志参数设置"></a>5.2 日志参数设置</h4><p><strong>方式 1 ：永久性方式</strong></p>
<p>修改MySQL的my.cnf或my.ini文件可以设置二进制日志的相关参数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#启用二进制日志</span><br><span class="line">log<span class="operator">-</span>bin<span class="operator">=</span>atguigu<span class="operator">-</span>bin</span><br><span class="line">binlog_expire_logs_seconds<span class="operator">=</span> <span class="number">600</span></span><br><span class="line">max_binlog_size<span class="operator">=</span><span class="number">100</span>M</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示:</strong></p>
<ol>
<li>log-bin&#x3D;mysql-bin #打开日志(主机需要打开)，这个mysql-bin也可以自定义，这里也可以加上路径，如:&#x2F;home&#x2F;www&#x2F;mysql_bin_log&#x2F;mysql-bin</li>
<li>binlog_expire_logs_seconds:此参数控制二进制日志文件保留的时长单位是秒，默认2592000 30天 –14400 4小时;86400 1天; 259200 3天;</li>
<li>max_binlog_size:控制单个二进制日志大小，当前日志文件大小超过此变量时，执行切换动作。此参数的<code>最大和默认值是1GB</code>，该设置并<code>不能严格控制Binlog的大小</code>，尤其是Binlog比较靠近最大值而又遇到一个比较大事务时，为了保证事务的完整性，可能不做切换日志的动作只能将该事务的所有SQL都记录进当前日志，直到事务结束。一般情况下可采取默认值。</li>
</ol>
</blockquote>
<p><strong>设置带文件夹的bin-log日志存放目录</strong></p>
<p>如果想改变日志文件的目录和名称，可以对my.cnf或my.ini中的log_bin参数修改如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log<span class="operator">-</span>bin<span class="operator">=</span>&quot;/var/lib/mysql/binlog/atguigu-bin&quot;</span><br></pre></td></tr></table></figure>

<p>注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown <span class="operator">-</span>R <span class="operator">-</span>v mysql:mysql binlog</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示</p>
<p>数据库文件<code>最好不要与日志文件放在同一个磁盘上!</code>这样，当数据库文件所在的磁盘发生故障时，可以使用日志文件恢复数据。</p>
</blockquote>
<p><strong>方式 2 ：临时性方式</strong><br>如果不希望通过修改配置文件并重启的方式设置二进制日志的话，还可以使用如下指令，需要注意的是在mysql 8 中只有会话级别的设置，没有了global级别的设置。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">global</span> 级别</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> sql_log_bin<span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">ERROR <span class="number">1228</span> (HY000): Variable <span class="string">&#x27;sql_log_bin&#x27;</span> <span class="keyword">is</span> a SESSION variable <span class="keyword">and</span> can`t be used</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">SET</span> <span class="keyword">GLOBAL</span></span><br><span class="line"></span><br><span class="line"># session级别</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> sql_log_bin <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> 秒)</span><br></pre></td></tr></table></figure>

<h4 id="5-3-查看日志"><a href="#5-3-查看日志" class="headerlink" title="5.3 查看日志"></a>5.3 查看日志</h4><p>当MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“.index”为后缀的文件，再创建一个以“filename”为名称、以“.000001”为后缀的文件。</p>
<p>MySQL服务重新启动一次，以“.000001”为后缀的文件就会增加一个，并且后缀名按 1 递增。即日志文件的数与MySQL服务启动的次数相同；如果日志长度超过了max_binlog_size的上限（默认是1GB），就会创建一个新的日志文件。</p>
<p>查看当前的二进制日志文件列表及大小。指令如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Log_name           <span class="operator">|</span> File_size <span class="operator">|</span> Encrypted <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">156</span>       <span class="operator">|</span> <span class="keyword">No</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>所有对数据库的修改都会记录在binglog中。但binlog是二进制文件，无法直接查看，借助mysqlbinlog命令工具了。指令如下:在查看执行，先执行一条sQL语句，如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;张三_back&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">[root<span class="variable">@localhost</span> <span class="operator">~</span>]$ cd <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql</span><br><span class="line">[root<span class="variable">@localhost</span> <span class="operator">~</span>]$ mysqlbinlog  &quot;/var/lib/mysql/lqhdb-binlog.000001&quot;</span><br></pre></td></tr></table></figure>

<p>执行结果可以看到，这是一个简单的日志文件，日志中记录了用户的一些操作，这里并没有出现具体的SQL语句，这是因为binlog关键字后面的内容是经过编码后的二进制日志。</p>
<p>这里一个update语句包含如下事件</p>
<ul>
<li>Query事件负责开始一个事务(BEGIN)</li>
<li>Table_map事件负责映射需要的表</li>
<li>Update_rows事件负责写入数据</li>
<li>Xid事件负责结束事务</li>
</ul>
<p>下面命令将行事件以<code>伪SQL</code>的形式表现出来</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog <span class="operator">-</span>v &quot;/var/lib/mysql/binlog/test.000002&quot;</span><br></pre></td></tr></table></figure>

<p>前面的命令同时显示binlog格式的语句，使用如下命令不显示它</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog <span class="operator">-</span>v <span class="comment">--base64-output=DECODE-ROWS &quot;/var/lib/mysql/binlog/test.000002&quot;</span></span><br></pre></td></tr></table></figure>

<p>关于mysqlbinlog工具的使用技巧还有很多，例如只解析对某个库的操作或者某个时间段内的操作等。简单分享几个常用的语句，更多操作可以参考官方文档。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 可查看参数帮助</span><br><span class="line">mysqlbinlog <span class="comment">--no-defaults --help</span></span><br><span class="line"></span><br><span class="line"># 查看最后 <span class="number">100</span> 行</span><br><span class="line">mysqlbinlog <span class="comment">--no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |tail - 100</span></span><br><span class="line"></span><br><span class="line"># 根据position查找</span><br><span class="line">mysqlbinlog <span class="comment">--no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |grep -A </span></span><br><span class="line"><span class="number">20</span> <span class="string">&#x27;4939002&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的查询命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> binlog events [<span class="keyword">IN</span> <span class="string">&#x27;log_name&#x27;</span>] [<span class="keyword">FROM</span> pos] [LIMIT [<span class="keyword">offset</span>,] row_count];</span><br></pre></td></tr></table></figure>

<ul>
<li><code>IN &#39;log_name&#39;：</code>指定要查询的binlog文件名（不指定就是第一个binlog文件）</li>
<li><code>FROM pos：</code>指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）</li>
<li><code>LIMIT [offset]：</code>偏移量(不指定就是 0 )</li>
<li><code>row_count :</code>查询总条数（不指定就是所有行）</li>
</ul>
<p>上面这条语句可以将指定的binlog日志文件，分成有效事件行的方式返回，并可使用limit指定pos点的起始偏移，查询条数。其它举例:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#a、查询第一个最早的binlog日志:</span><br><span class="line"><span class="keyword">show</span> binlog events\G ;</span><br><span class="line"></span><br><span class="line">#b、指定查询mysql<span class="operator">-</span>bin<span class="number">.088802</span>这个文件</span><br><span class="line"><span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;atguigu-bin. 008002&#x27;</span>\G;</span><br><span class="line"></span><br><span class="line">#c、指定查询mysql<span class="operator">-</span>bin. <span class="number">080802</span>这个文件，从pos点:<span class="number">391</span>开始查起:</span><br><span class="line"><span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;atguigu-bin.008802&#x27;</span> <span class="keyword">from</span> <span class="number">391</span>\G;</span><br><span class="line"></span><br><span class="line">#d、指定查询mysql<span class="operator">-</span>bin<span class="number">.000802</span>这个文件，从pos点:<span class="number">391</span>开始查起，查询<span class="number">5</span>条（即<span class="number">5</span>条语句)</span><br><span class="line"><span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;atguigu-bin.000882&#x27;</span> <span class="keyword">from</span> <span class="number">391</span> limit <span class="number">5</span>\G</span><br><span class="line"></span><br><span class="line">#e、指定查询 mysql<span class="operator">-</span>bin<span class="number">.880002</span>这个文件，从pos点:<span class="number">391</span>开始查起，偏移<span class="number">2</span>行〈即中间跳过<span class="number">2</span>个）查询<span class="number">5</span>条（即<span class="number">5</span>条语句)。</span><br><span class="line"><span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;atguigu-bin.088882&#x27;</span> <span class="keyword">from</span> <span class="number">391</span> limit <span class="number">2</span>,<span class="number">5</span>\G;</span><br></pre></td></tr></table></figure>

<p>binlog格式查看</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;binlog_format&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> binlog_format <span class="operator">|</span> <span class="type">ROW</span>   <span class="operator">|</span> <span class="operator">/</span><span class="operator">/</span>行格式</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>除此之外，binlog还有 2 种格式，分别是<code>Statemen</code>和<code>Mixed</code></p>
<ul>
<li><p>Statement<br>  每一条会修改数据的sql都会记录在binlog中。</p>
<p>  优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。</p>
</li>
<li><p>Row<br>  5.1.5版本的MySQL才开始支持row level 的复制，它不记录sql语句上下文相关信息，仅保存哪条记录被修改。<br>  优点：row level 的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题。</p>
</li>
<li><p>Mixed<br>  从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。</p>
</li>
</ul>
<h4 id="5-4-使用日志恢复数据"><a href="#5-4-使用日志恢复数据" class="headerlink" title="5.4 使用日志恢复数据"></a>5.4 使用日志恢复数据</h4><p>mysqlbinlog恢复数据的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [option] filename<span class="operator">|</span>mysql –uuser <span class="operator">-</span>ppass;</span><br></pre></td></tr></table></figure>

<p>这个命令可以这样理解：使用mysqlbinlog命令来读取filename中的内容，然后使用mysql命令将这些内容恢复到数据库中。</p>
<ul>
<li>filename：是日志文件名。</li>
<li>option：可选项，比较重要的两对option参数是–start-date、–stop-date 和 –start-position、–stop-position。<ul>
<li>–start-date 和 - -stop-date：可以指定恢复数据库的起始时间点和结束时间点。</li>
<li>–start-position和–stop-position：可以指定恢复数据的开始位置和结束位置。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必须在atguigu-bin.000002之前恢复。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flush logs; #可以生成新的binLog 文件，不然这个文件边恢复边变大是不行的。</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="type">binary</span> logs; # 显示有哪些binLog 文件</span><br></pre></td></tr></table></figure>

<p>恢复数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [option] filename<span class="operator">|</span>mysql –uuser <span class="operator">-</span>ppass;</span><br><span class="line"></span><br><span class="line">mysqlbinlog <span class="comment">--no-defaults  --start-position=236  --stop-position=1071 --database=my_db1 /var/lib/mysql/lqhdb-bin.000002 | /usr/bin/mysql -root -p123456 -v my_db1</span></span><br></pre></td></tr></table></figure>

<h4 id="5-5-删除二进制日志"><a href="#5-5-删除二进制日志" class="headerlink" title="5.5 删除二进制日志"></a>5.5 删除二进制日志</h4><p>MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。<code>PURGE MASTER LOGS</code>只删除指定部分的二进制日志文件，<code>RESET MASTER</code>删除所有的二进制日志文件。具体如下：</p>
<p><strong>1.PURGE MASTER LOGS：删除指定日志文件</strong></p>
<p>PURGE MASTER LOGS语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PURGE &#123;MASTER <span class="operator">|</span> <span class="type">BINARY</span>&#125; LOGS <span class="keyword">TO</span> ‘指定日志文件名’</span><br><span class="line"></span><br><span class="line">PURGE &#123;MASTER <span class="operator">|</span> <span class="type">BINARY</span>&#125; LOGS BEFORE ‘指定日期’</span><br></pre></td></tr></table></figure>

<p>**举例 **使用PURGE MASTER LOGS语句删除创建时间比binlog.000005早的所有日志</p>
<p>(1)多次重新启动MysSQL服务，便于生成多个日志文件。然后用SHOW语句显示二进制日志文件列表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS;</span><br></pre></td></tr></table></figure>

<p>(2）执行PURGE MASTER LOGS语句删除创建时间比binlog.000005早的所有日志</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PURGE MASTER LOGS T0 &quot;binlog. 000005&quot;;</span><br></pre></td></tr></table></figure>

<p>(3）显示二进制日志文件列表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHGW <span class="type">BINARY</span> LOGS;</span><br></pre></td></tr></table></figure>

<p><strong>举例</strong>:使用PURGE MASTER LOGS语句删除2020年10月25号前创建的所有日志文件。具体步骤如下:</p>
<p>(1) 显示二进制日志文件列表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS;</span><br></pre></td></tr></table></figure>

<p>(2）执行mysqlbinlog命令查看二进制日志文件binlog.000005的内容</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog <span class="comment">--no-defaults &quot;/var/lib/mysql/binlog/atguigu-bin.000005&quot;</span></span><br></pre></td></tr></table></figure>

<p>结果可以看出20220105为日志创建的时间，即2022年1月05日。</p>
<p>(3）使用PURGE MASTER LOGS语句删除2o22年1月q5日前创建的所有日志文件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PURGE MASTER LOGS before &quot;20220105&quot;;</span><br></pre></td></tr></table></figure>

<p>(4）显示二进制日志文件列表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS;</span><br></pre></td></tr></table></figure>

<p>2022年01月05号之前的二进制日志文件都已经被删除，最后一个没有删除，是因为当前在用，还未记录最后的时间，所以未被删除。</p>
<p><strong>2.RESET MASTER:删除所有二进制日志文件</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reset master;</span><br></pre></td></tr></table></figure>

<h4 id="5-6-其它场景"><a href="#5-6-其它场景" class="headerlink" title="5.6 其它场景"></a>5.6 其它场景</h4><p>二进制日志可以通过数据库的<code>全量备份</code>和二进制日志中保存的<code>增量信息</code>，完成数据库的<code>无损失恢复</code>。但是，如果遇到数据量大、数据库和数据表很多（比如分库分表的应用）的场景，用二进制日志进行数据恢复，是很有挑战性的，因为起止位置不容易管理。</p>
<p>在这种情况下，一个有效的解决办法是<code>配置主从数据库服务器</code>，甚至是<code>一主多从</code>的架构，把二进制日志文件的内容通过中继日志，同步到从数据库服务器中，这样就可以有效避免数据库故障导致的数据异常等问题。</p>
<h3 id="6-再谈二进制日志"><a href="#6-再谈二进制日志" class="headerlink" title="6. 再谈二进制日志"></a>6. 再谈二进制日志</h3><h4 id="6-1-写入机制"><a href="#6-1-写入机制" class="headerlink" title="6.1 写入机制"></a>6.1 写入机制</h4><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。</p>
<p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程binlog cache大，如果存储内容超过了这个参数，就要暂存到磁盘(Swap)。binlog日志刷盘流程如下:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131171836210.png" alt="image-20230131171836210" style="zoom:50%;" />

<blockquote>
<ul>
<li>上图的write，是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。</li>
<li>上图的fsync，才是将数据持久化到磁盘的操作</li>
</ul>
</blockquote>
<p>write和fsync的时机，可以由参数sync_binlog控制，默认是 0 。为 0 的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的binglog 会丢失。如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131172036255.png" alt="image-20230131172036255" style="zoom:50%;" />

<p>为了安全起见，可以设置为 1 ，表示每次提交事务都会执行fsync，就如同 redo log 刷盘流程 一样。最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131172130789.png" alt="image-20230131172130789" style="zoom:50%;" />

<p>在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p>
<h4 id="6-2-binlog与redolog对比"><a href="#6-2-binlog与redolog对比" class="headerlink" title="6.2 binlog与redolog对比"></a>6.2 binlog与redolog对比</h4><ul>
<li><p>redo log 它是<code>物理日志</code>，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎层产生的。</p>
</li>
<li><p>而 binlog 是<code>逻辑日志</code>，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于MySQL Server 层</p>
</li>
<li><p>虽然它们都属于持久化的保证，但是则重点不同。</p>
<ul>
<li>redo log让InnoDB存储引擎拥有了崩溃恢复能力。</li>
<li>binlog保证了MySQL集群架构的数据一致性。</li>
</ul>
</li>
</ul>
<h4 id="6-3-两阶段提交"><a href="#6-3-两阶段提交" class="headerlink" title="6.3 两阶段提交"></a>6.3 两阶段提交</h4><p>在执行更新语句过程，会记录 redo log 与 binlog 两块日志，以基本的事务为单位，redo log 在事务执行过程中可以不断写入，而 binlog 只有在提交事务时才写入，所以 redo log 与 binlog 的写入时机不一样。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131172515589.png" alt="image-20230131172515589" style="zoom:50%;" />

<p><strong>redo log 与 binlog 两份日志之间的逻辑不一致，会出现什么问题</strong>？</p>
<p>以 update 语句为例，假设 id&#x3D;2 的记录，字段 c 值是 0，把字段 c 值更新成 1，SQL 语句为 <code>update T set c = 1 where id = 2</code>。</p>
<p>假设执行过程中写完redo log 日之后，binlog 日志写期间发生了异常，会出现什么问题？</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131172810906.png" alt="image-20230131172810906" style="zoom:50%;" />

<p>由于 binlog 没有写完就异常，这时候 binlog 里面没有对应的修改记录。因此，之后用 binlog 日志恢复数据时，就会少这一次更新，恢复出来的这一行 c 值是 0，而原库因为 redo log 日志恢复，这一行 c 值是 1，最终数据不一致。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131173009465.png" alt="image-20230131173009465" style="zoom:50%;" />

<p>为了解决两份日志之间的逻辑一致问题，InnoDB 存储引擎使用两阶段提交方案。原理很简单，将 redo log 的写入拆成了两个步骤，prepare 和 commit，这就是两阶段提交。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131173144626.png" alt="image-20230131173144626" style="zoom:50%;" />

<p>使用两阶段提交后，写入 binlog 时发生异常也不会有影响，因为 MySQL 根据 redo log 日志恢复数据时，发现 redo log 还处于 prepare 阶段，并且没有对应 binlog日志，就会回滚该事务。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131173305299.png" alt="image-20230131173305299" style="zoom:50%;" />

<p>另一个场景，redo log 设置 commit 阶段发生异常，那会不会回滚事务呢？</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230131173412548.png" alt="image-20230131173412548" style="zoom:50%;" />

<p>并不会回滚事务，他会执行上图框住的逻辑，虽然 redo log 是处于 prepare 阶段，但是能通过事务id找到对应的 binlog 日志，所以 MySQL 认为是完整的，就会提交事务恢复数据。</p>
<h3 id="7-中继日志-relay-log"><a href="#7-中继日志-relay-log" class="headerlink" title="7. 中继日志(relay log)"></a>7. 中继日志(relay log)</h3><h4 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h4><p>中继日志只在主从服务器架构的从服务器上存在 。从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入<code>本地的日志文件</code>中，这个从服务器本地的日志文件就叫<code>中继日志</code>。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的<code>数据同步</code>。</p>
<p>搭建好主从服务器之后，中继日志默认会保存在从服务器的数据目录下。</p>
<p>文件名的格式是：<code>从服务器名 - relay-bin.序号</code>。中继日志还有一个索引文件：从服务器名<code>- relay-bin.index</code>，用来定位当前正在使用的中继日志。</p>
<h4 id="7-2-查看中继日志"><a href="#7-2-查看中继日志" class="headerlink" title="7.2 查看中继日志"></a>7.2 查看中继日志</h4><p>中继日志与二进制日志的格式相同，可以用 mysqlbinlog 工具进行查看。下面是中继日志的一个片段：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="type">TIMESTAMP</span><span class="operator">=</span> <span class="number">1618558728</span> <span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">950</span></span><br><span class="line">#<span class="number">210416</span> <span class="number">15</span>:<span class="number">38</span>:<span class="number">48</span> server id <span class="number">1</span> end_log_pos <span class="number">832</span> CRC32 <span class="number">0xcc16d651</span> Table_map:</span><br><span class="line">`atguigu`.`test` mapped <span class="keyword">to</span> number <span class="number">91</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">1000</span></span><br><span class="line">#<span class="number">210416</span> <span class="number">15</span>:<span class="number">38</span>:<span class="number">48</span> server id <span class="number">1</span> end_log_pos <span class="number">872</span> CRC32 <span class="number">0x07e4047c</span> Delete_rows: <span class="keyword">table</span> id</span><br><span class="line"><span class="number">91</span> flags: STMT_END_F <span class="comment">-- server id 1 是主服务器，意思是主服务器删了一行数据</span></span><br><span class="line">BINLOG <span class="string">&#x27;</span></span><br><span class="line"><span class="string">CD95YBMBAAAAMgAAAEADAAAAAFsAAAAAAAEABGRlbW8ABHRlc3QAAQMAAQEBAFHWFsw=</span></span><br><span class="line"><span class="string">CD95YCABAAAAKAAAAGgDAAAAAFsAAAAAAAEAAgAB/wABAAAAfATkBw==</span></span><br><span class="line"><span class="string">&#x27;</span><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">1040</span></span><br></pre></td></tr></table></figure>

<p>这一段的意思是，主服务器（“server id 1”）对表 atguigu.test 进行了 2 步操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定位到表 atguigu.test 编号是 91 的记录，日志位置是 832 ；</span><br><span class="line"></span><br><span class="line">删除编号是 91 的记录，日志位置是 872 。</span><br></pre></td></tr></table></figure>

<h4 id="7-3-恢复的典型错误"><a href="#7-3-恢复的典型错误" class="headerlink" title="7.3 恢复的典型错误"></a>7.3 恢复的典型错误</h4><p>如果从服务器宕机，有的时候为了系统恢复，要重装操作系统，这样就可能会导致你的服务器名称与之前不同。而中继日志里是包含从服务器名的。在这种情况下，就可能导致你恢复从服务器的时候，无法从宕机前的中继日志里读取数据，以为是日志文件损坏了，其实是名称不对了。</p>
<p>解决的方法也很简单，把从服务器的名称改回之前的名称。</p>
<h2 id="十六、主从复制"><a href="#十六、主从复制" class="headerlink" title="十六、主从复制"></a>十六、主从复制</h2><h3 id="1-主从复制概述"><a href="#1-主从复制概述" class="headerlink" title="1. 主从复制概述"></a>1. 主从复制概述</h3><h4 id="1-1-如何提升数据库并发能力"><a href="#1-1-如何提升数据库并发能力" class="headerlink" title="1.1 如何提升数据库并发能力"></a>1.1 如何提升数据库并发能力</h4><p>在实际工作中，我们常常将<code>Redis</code>作为缓存与<code>MySQL</code>配合来使用，当有请求的时候，首先会从缓存中进行查找，如果存在就直接取出。如果不存在再访问数据库，这样就<code>提升了读取的效率</code>，也减少了对后端数据库的<code>访问压力</code>。Redis的缓存架构是<code>高并发架构</code>中非常重要的一环。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230201091006326.png" alt="image-20230201091006326" style="zoom:50%;" />

<p>此外，一般应用对数据库而言都是<code>“读多写少”</code>，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做<code>主从架构</code>、进行<code>读写分离</code>，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。</p>
<p>如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何优化<code>SQL和索引</code>，这种方式简单有效；其次才是采用<code>缓存的策略</code>，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用<code>主从架构</code>，进行读写分离。</p>
<h4 id="1-2-主从复制的作用"><a href="#1-2-主从复制的作用" class="headerlink" title="1.2 主从复制的作用"></a>1.2 主从复制的作用</h4><p>主从同步设计不仅可以提高数据库的吞吐量，还有以下 3 个方面的作用。</p>
<p><code>第 1 个作用：读写分离</code>。 我们可以通过主从复制的方式来<code>同步数据</code>，然后通过读写分离提高数据库并发处理能力。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230201091306074.png" alt="image-20230201091306074" style="zoom:50%;" />

<p>其中一个是Master主库，负责写入数据，我们称之为：<code>写库</code>。</p>
<p>其它都是Slave从库，负责读取数据，我们称之为：<code>读库</code>。</p>
<p>当主库进行更新的时候，会自动将数据复制到从库中，而我们在客户端读取数据的时候，会从从库中进行读取。</p>
<p>面对“读多写少”的需求，采用读写分离的方式，可以实现更高的并发访问。同时，我们还能对从服务器进行负载均衡，让不同的读请求按照策略均匀地分发到不同的从服务器上，让读取更加顺畅。读取顺畅的另一个原因，就是减少了锁表的影响，比如我们让主库负责写，当主库出现写锁的时候，不会影响到从库进行SELECT的读取。</p>
<p><strong>第 2 个作用就是数据备份。</strong> 我们通过主从复制将主库上的数据复制到了从库上，相当于是一种热备份机制，也就是在主库正常运行的情况下进行的备份，不会影响到服务。</p>
<p><strong>第 3 个作用是具有高可用性。</strong> 数据备份实际上是一种冗余的机制，通过这种冗余的方式可以换取数据库的高可用性，也就是当服务器出现<code>故障</code>或<code>宕机</code>的情况下，可以<code>切换</code>到从服务器上，保证服务的正常运行。</p>
<p>关于高可用性的程度，我们可以用一个指标衡量，即正常可用时间&#x2F;全年时间。比如要达到全年99.999%的时间都可用，就意味着系统在一年中的不可用时间不得超过<code>365*24*60*(1-99.999%)=5.256分钟</code>(含系统崩溃的时间、日常维护操作导致的停机时间等)，其他时间都需要保持可用的状态。</p>
<p>实际上，更高的高可用性，意味着需要付出更高的成本代价。在现实中我们需要结合业务需求和成本来进行选择。</p>
<h3 id="2-主从复制的原理"><a href="#2-主从复制的原理" class="headerlink" title="2. 主从复制的原理"></a>2. 主从复制的原理</h3><p><code>Slave</code>会从<code>Master</code>读取<code>binlog</code>来进行数据同步。</p>
<h4 id="2-1-原理剖析"><a href="#2-1-原理剖析" class="headerlink" title="2.1 原理剖析"></a>2.1 原理剖析</h4><p><strong>三个线程</strong></p>
<p>实际上主从同步的原理就是基于 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=binlog&spm=1001.2101.3001.7020">binlog</a> 进行数据同步的。在主从复制过程中，会基于<code>3个线程</code>来操作，一个主库线程，两个从库线程。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230201091651293.png" alt="image-20230201091651293" style="zoom:50%;" />

<p><code>二进制日志转储线程</code>（Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上加锁，读取完成之后，再将锁释放掉。</p>
<p><code>从库 I/O 线程会连接到主库</code>，向主库发送请求更新 Binlog。这时从库的 I&#x2F;O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</p>
<p><code>从库 SQL 线程</code>会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230201091744050.png" alt="image-20230201091744050" style="zoom:50%;" />

<blockquote>
<p>注意:<br>不是所有版本的MySQL都默认开启服务器的二进制日志。在进行主从同步的时候，我们需要先检查服务器是否已经开启了二进制日志。</p>
<p>除非特殊指定，默认情况下从服务器会执行所有主服务器中保存的事件。也可以通过配置，使从服务器执行特定的事件。</p>
</blockquote>
<p><strong>复制三步骤</strong><br>步骤 1 ：<code>Master</code>将写操作记录到二进制日志（<code>binlog</code>）。</p>
<p>步骤 2 ：<code>Slave</code>将<code>Master</code>的binary log events拷贝到它的<code>中继日志</code>（relay log）；</p>
<p>步骤 3 ：<code>Slave</code>重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从<code>接入点</code>开始复制。</p>
<p><strong>复制的问题</strong></p>
<p>复制的最大问题：<code>延时</code></p>
<h4 id="2-2-复制的基本原则"><a href="#2-2-复制的基本原则" class="headerlink" title="2.2 复制的基本原则"></a>2.2 复制的基本原则</h4><ul>
<li><p>每个Slave只有一个Master</p>
</li>
<li><p>每个Slave只能有一个唯一的服务器ID</p>
</li>
<li><p>每个Master可以有多个Slave</p>
</li>
</ul>
<h3 id="3-一主一从架构搭建"><a href="#3-一主一从架构搭建" class="headerlink" title="3. 一主一从架构搭建"></a>3. 一主一从架构搭建</h3><p>一台主机用于处理所有写请求，一台从机负责读请求，架构图如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230201092227168.png" alt="image-20230201092227168" style="zoom:50%;" />

<h4 id="3-1-主机配置文件"><a href="#3-1-主机配置文件" class="headerlink" title="3.1 主机配置文件"></a>3.1 主机配置文件</h4><p>建议 MySQL 版本一直且后台以服务运行，主从所有配置项都在 <code>[mysqld]</code> 节点下，且都是小写字母。具体参数配置如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[必须]主服务器唯一ID</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[必须]启动二进制日志，指明路径。比如：自己本地的路径/log/mysqlbin</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[可选]0(默认)表示读写(主机)，1表示只读(从机)</span></span><br><span class="line"><span class="attr">read-only</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#设置日志文件保留的时长，单位是秒</span></span><br><span class="line"><span class="attr">binlog_expire_logs_seconds</span>=<span class="string">6000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#控制单个二进制日志大小。此参数的最大和默认值是1GB</span></span><br><span class="line"><span class="attr">max_binlog_size</span>=<span class="string">200M</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[可选]设置不要复制的数据库</span></span><br><span class="line"><span class="attr">binlog-ignore-db</span>=<span class="string">test</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[可选]设置需要复制的数据库，默认全部记录。</span></span><br><span class="line"><span class="attr">binlog-do-db</span>=<span class="string">需要复制的主数据库名字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[可选]设置binlog格式</span></span><br><span class="line"><span class="attr">binlog_format</span>=<span class="string">STATEMENT</span></span><br></pre></td></tr></table></figure>

<p>重启后台 mysql 服务，使配置生效</p>
<blockquote>
<p>注意：</p>
<p>先搭建完主从复制，在创建数据库。</p>
<p>MySQL 主从复制起始时，从机不继承主机数据。</p>
</blockquote>
<h4 id="3-2-从机配置文件"><a href="#3-2-从机配置文件" class="headerlink" title="3.2 从机配置文件"></a>3.2 从机配置文件</h4><p>主从所有配置项都在 <code>[mysqld]</code> 节点下，且都是小写字母。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[必须]从服务器唯一ID</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="string">2</span></span><br><span class="line"><span class="comment">#[可选]启用中继日志</span></span><br><span class="line"><span class="attr">relay-log</span>=<span class="string">mysql-relay</span></span><br></pre></td></tr></table></figure>

<p>重启后台 mysql 服务，使配置生效</p>
<blockquote>
<p>注意：主从机都关闭防火墙systemctl stop firewalld.service</p>
</blockquote>
<h4 id="3-3-主机：建立账户并授权"><a href="#3-3-主机：建立账户并授权" class="headerlink" title="3.3 主机：建立账户并授权"></a>3.3 主机：建立账户并授权</h4><p><strong>注意：如果使用的是MySQL8，需要如下的方式建立账户，并授权slave：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 创建用户</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;slave1&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;******&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 赋予权限</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;slave1&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"># 查看权限</span><br><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;slave1&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#此语句必须执行。否则会报错。</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;slave1&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;*******&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 刷新权限</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>查询Master的状态，并记录下File和Position的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+-------------------+------------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> File            <span class="operator">|</span> Position <span class="operator">|</span> Binlog_Do_DB      <span class="operator">|</span> Binlog_Ignore_DB <span class="operator">|</span> Executed_Gtid_Set <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+-------------------+------------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> test<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span>     <span class="number">1136</span> <span class="operator">|</span> test_master_slave <span class="operator">|</span>                  <span class="operator">|</span>                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+-------------------+------------------+-------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>至此，不要再动主机，以免服务器状态变化</p>
</blockquote>
<h4 id="3-4-从机：配置需要复制的主机"><a href="#3-4-从机：配置需要复制的主机" class="headerlink" title="3.4 从机：配置需要复制的主机"></a>3.4 从机：配置需要复制的主机</h4><p>步骤一：从机上复制主机的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO</span><br><span class="line">MASTER_HOST=&#x27;主机的IP地址&#x27;,</span><br><span class="line">MASTER_USER=&#x27;主机用户名&#x27;,</span><br><span class="line">MASTER_PASSWORD=&#x27;主机用户名的密码&#x27;,</span><br><span class="line">MASTER_LOG_FILE=&#x27;mysql-bin.具体数字&#x27;,</span><br><span class="line">MASTER_LOG_POS=具体值;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> CHANGE MASTER <span class="keyword">TO</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;192.168.133.200&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> MASTER_USER<span class="operator">=</span><span class="string">&#x27;slave1&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;********&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;test-bin.000001&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> MASTER_LOG_POS<span class="operator">=</span><span class="number">1136</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected, <span class="number">8</span> warnings (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>

<p>步骤二：启动 slave 同步</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> SLAVE</span><br></pre></td></tr></table></figure>

<p>如果报错<code>Slave failed to initialize relay Log info structure from the repository</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 可以执行如下操作，删除之前的relay_log信息。然后重新执行 CHANGE MASTER <span class="keyword">TO</span> …语句即可。</span><br><span class="line">reset slave; #删除SLAVE数据库的relaylog日志文件，并重新启用新的relaylog文件</span><br></pre></td></tr></table></figure>

<p>步骤三：查看同步状态</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> slave status\G;</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230201100450108.png" alt="image-20230201100450108" style="zoom:50%;" />

<p>图中两值为 yes 则为成功。</p>
<h4 id="3-5-测试"><a href="#3-5-测试" class="headerlink" title="3.5 测试"></a>3.5 测试</h4><p>主机新建库、新建表、insert记录，从机复制：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test_master_slave;</span><br><span class="line"></span><br><span class="line">use test_master_slave;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(id <span class="type">INT</span>,NAME <span class="type">VARCHAR</span>(<span class="number">16</span>));</span><br><span class="line">		</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-6-停止主从同步"><a href="#3-6-停止主从同步" class="headerlink" title="3.6 停止主从同步"></a>3.6 停止主从同步</h4><ul>
<li><p>停止主从同步命令：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何重新配置主从</p>
<p>  如果停止从服务器复制功能，再使用需要重新配置主从。否则会报错。</p>
</li>
</ul>
<p>重新配置主从，需要在从机上执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">reset master;</span><br></pre></td></tr></table></figure>

<h4 id="3-7-后续"><a href="#3-7-后续" class="headerlink" title="3.7 后续"></a>3.7 后续</h4><p>搭建主从复制：双主双从</p>
<p>一个主机 m1 用于处理所有写请求，它的从机 s1 和另一台主机 m2 还有它的从机 s2 负责所有读请求。当 m1 主机宕机后，m2 主机负责写请求，m1、m2互为备机。架构图如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230201101754925.png" alt="image-20230201101754925" style="zoom:50%;" />

<h3 id="4-同步数据一致性问题"><a href="#4-同步数据一致性问题" class="headerlink" title="4. 同步数据一致性问题"></a>4. 同步数据一致性问题</h3><p><strong>主从同步的要求：</strong></p>
<ul>
<li>读库和写库的数据一致(最终一致)；</li>
<li>写数据必须写到写库；</li>
<li>读数据必须到读库(不一定)；</li>
</ul>
<h4 id="4-1-理解主从延迟问题"><a href="#4-1-理解主从延迟问题" class="headerlink" title="4.1 理解主从延迟问题"></a>4.1 理解主从延迟问题</h4><p>进行主从同步的内容是二进制日志，它是一个文件，在进行<code>网络传输</code>的过程中就一定会存在主从延迟（比如 500 ms），这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的<code>数据不一致性</code>问题。</p>
<p>导致主从延迟的时间点主要包括以下三个:</p>
<ul>
<li>1.主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;</li>
<li>2.之后传给从库B，我们把从库B接收完这个binlog的时刻记为T2;</li>
<li>3.从库B执行完成这个事务，我们把这个时刻记为T3。</li>
</ul>
<h4 id="4-2-主从延迟问题原因"><a href="#4-2-主从延迟问题原因" class="headerlink" title="4.2 主从延迟问题原因"></a>4.2 主从延迟问题原因</h4><p>在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T 2 - T 1 的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。</p>
<p><strong>主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。</strong> 造成原因：</p>
<ol>
<li>从库的机器性能比主库要差</li>
<li>从库的压力大</li>
<li>大事务的执行</li>
</ol>
<ul>
<li><p>举例 1 ： 一次性用delete语句删除太多数据<br>  结论：后续再删除数据的时候，要控制每个事务删除的数据量，分成多次删除。</p>
</li>
<li><p>举例 2 ： 一次性用insert…select插入太多数据</p>
</li>
<li><p>举例: 3 ： 大表DDL<br>  比如在主库对一张500W的表添加一个字段耗费了 10 分钟，那么从节点上也会耗费 10 分钟。</p>
</li>
</ul>
<h4 id="4-3-如何减少主从延迟"><a href="#4-3-如何减少主从延迟" class="headerlink" title="4.3 如何减少主从延迟"></a>4.3 如何减少主从延迟</h4><p><strong>若想要减少主从延迟的时间，可以采取下面的办法：</strong></p>
<ul>
<li><p>降低多线程大事务并发的概率，优化业务逻辑</p>
</li>
<li><p>优化SQL，避免慢SQL，<code>减少批量操作</code>，建议写脚本以update-sleep这样的形式完成。</p>
</li>
<li><p><code>提高从库机器的配置</code>，减少主库写binlog和从库读binlog的效率差。</p>
</li>
<li><p>尽量采用<code>短的链路</code>，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。</p>
</li>
<li><p>实时性要求的业务读强制走主库，从库只做灾备，备份。</p>
</li>
</ul>
<h4 id="4-4-如何解决一致性问题"><a href="#4-4-如何解决一致性问题" class="headerlink" title="4.4 如何解决一致性问题"></a>4.4 如何解决一致性问题</h4><p>如果操作的数据存储在同一个数据库中，那么对数据进行更新的时候，可以对记录加写锁，这样在读取的时候就不会发生数据不一致的情况。但这时从库的作用就是备份，并没有起到读写分离，分担主库读压力的作用。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230201102611214.png" alt="image-20230201102611214" style="zoom:50%;" />

<p>读写分离情况下，解决主从同步中数据不一致的问题， 就是解决主从之间<code>数据复制方式</code>的问题，如果按照数据一致性<code>从弱到强</code>来进行划分，有以下 3 种复制方式。</p>
<p><strong>方法 1 ：异步复制</strong></p>
<p>异步模式就是客户端提交COMMIT之后不需要等从库返回任何结果，而是直接将结果返回给客户端，这样做的好处是不会影响主库写的效率，但可能会存在主库宕机，而Binlog还没有同步到从库的情况，也就是此时的主库和从库数据不一致。这时候从从库中选择一个作为新主，那么新主则可能缺少原来主服务器中已提交的事务。所以，这种复制模式下的数据一致性是最弱的。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230201102713168.png" alt="image-20230201102713168" style="zoom:50%;" />

<p><strong>方法 2 ：半同步复制</strong></p>
<p>MySQL5.5版本之后开始支持半同步复制的方式。原理是在客户端提交COMMIT之后不直接将结果返回给客户端，而是等待至少有一个从库接收到了Binlog，并且写入到中继日志中，再返回给客户端。</p>
<p>这样做的好处就是提高了数据的一致性，当然相比于异步复制来说，至少多增加了一个网络连接的延迟，降低了主库写的效率。</p>
<p>在MySQL5.7版本中还增加了一个<code>rpl_semi_sync_master_wait_for_slave_count</code>参数，可以对应答的从库数量进行设置，默认为1，也就是说只要有1个从库进行了响应，就可以返回给客户端。如果将这个参数调大，可以提升数据一致性的强度，但也会增加主库等待从库响应的时间。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230201102836729.png" alt="image-20230201102836729" style="zoom:50%;" />

<p><strong>方法 3 ：组复制</strong></p>
<p>异步复制和半同步复制都无法最终保证数据的一致性问题，半同步复制是通过判断从库响应的个数来决定是否返回给客户端，虽然数据一致性相比于异步复制有提升，但仍然无法满足对数据一致性要求高的场景，比如金融领域。MGR 很好地弥补了这两种复制模式的不足。</p>
<p>组复制技术，简称 MGR（MySQL Group Replication）。是 MySQL 在 5.7.17 版本中推出的一种新的数据复制技术，这种复制技术是基于 Paxos 协议的状态机复制。</p>
<p><strong>MGR 是如何工作的</strong></p>
<p>首先我们将多个节点共同组成一个复制组，在执行<code>读写</code>（RW）事务的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于 <code>（N/2+1）</code>，这样才可以进行提交，而不是原发起方一个说了算。而针对<code>只读（RO）事务</code>则不需要经过组内同意，直接 COMMIT 即可。</p>
<p>在一个复制组内有多个节点组成，它们各自维护了自己的数据副本，并且在一致性协议层实现了原子消息和全局有序消息，从而保证组内数据的一致性。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230201103020826.png" alt="image-20230201103020826" style="zoom:50%;" />

<p>MGR 将 MySQL 带入了数据强一致性的时代，是一个划时代的创新，其中一个重要的原因就是MGR 是基于 Paxos 协议的。Paxos 算法是由 2013 年的图灵奖获得者 Leslie Lamport 于 1990 年提出的，有关这个算法的决策机制可以搜一下。事实上，Paxos 算法提出来之后就作为<code>分布式一致性算法</code>被广泛应用，比如Apache 的 ZooKeeper 也是基于 Paxos 实现的。</p>
<h3 id="5-知识延伸"><a href="#5-知识延伸" class="headerlink" title="5. 知识延伸"></a>5. 知识延伸</h3><p>在主从架构的配置中，如果想要采取读写分离的策略，我们可以自己编写程序，也可以通过第三方的中间件来实现。</p>
<ul>
<li><p>自己编写程序的好处就在于比较自主，我们可以自己判断哪些查询在从库上来执行，针对实时性要求高的需求，我们还可以考虑哪些查询可以在主库上执行。同时，程序直接连接数据库，减少了中间件层，相当于减少了性能损耗。</p>
</li>
<li><p>采用中间件的方法有很明显的优势，功能强大，使用简单。但因为在客户端和数据库之间增加了中间件层会有一些性能损耗，同时商业中间件也是有使用成本的。我们也可以考虑采取一些优秀的开源工具。</p>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230201103234734.png" alt="image-20230201103234734" style="zoom:50%;" />

<p>① Cobar属于阿里B2B事业群，始于 2008 年，在阿里服役 3 年多，接管3000+个MySQL数据库的schema,集群日处理在线SQL请求 50 亿次以上。由于Cobar发起人的离职，Cobar停止维护。</p>
<p>② Mycat是开源社区在阿里cobar基础上进行二次开发，解决了cobar存在的问题，并且加入了许多新的功能在其中。青出于蓝而胜于蓝。</p>
<p>③ OneProxy基于MySQL官方的proxy思想利用c语言进行开发的，OneProxy是一款商业收费的中间件。舍弃了一些功能，专注在性能和稳定性上。</p>
<p>④ kingshard由小团队用go语言开发，还需要发展，需要不断完善。</p>
<p>⑤ Vitess是Youtube生产在使用，架构很复杂。不支持MySQL原生协议，使用需要大量改造成本。</p>
<p>⑥ Atlas是 360 团队基于mysql proxy改写，功能还需完善，高并发下不稳定。</p>
<p>⑦ MaxScale是mariadb（MySQL原作者维护的一个版本） 研发的中间件</p>
<p>⑧ MySQLRoute是MySQL官方Oracle公司发布的中间件</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230201103339191.png" alt="image-20230201103339191" style="zoom:50%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230201103352864.png" alt="image-20230201103352864" style="zoom:50%;" />

<p>主备切换</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230201103437884.png" alt="image-20230201103437884" style="zoom:50%;" />

<ul>
<li>主动切换</li>
<li>被动切换</li>
</ul>
<h1 id="十七、数据库备份与恢复"><a href="#十七、数据库备份与恢复" class="headerlink" title="十七、数据库备份与恢复"></a>十七、数据库备份与恢复</h1><h3 id="1-物理备份与逻辑备份"><a href="#1-物理备份与逻辑备份" class="headerlink" title="1. 物理备份与逻辑备份"></a>1. 物理备份与逻辑备份</h3><p><strong>物理备份</strong>：备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以用<code>xtrabackup</code>工具来进行物理备份。</p>
<p><strong>逻辑备份</strong>：对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL 中常用的逻辑备份工具为<code>mysqldump</code>。逻辑备份就是<code>备份sql语句</code>，在恢复的时候执行备份的sql语句实现数据库数据的重现。</p>
<h3 id="2-MySQLdump实现逻辑备份"><a href="#2-MySQLdump实现逻辑备份" class="headerlink" title="2. MySQLdump实现逻辑备份"></a>2. MySQLdump实现逻辑备份</h3><h4 id="2-1-备份一个数据库"><a href="#2-1-备份一个数据库" class="headerlink" title="2.1 备份一个数据库"></a>2.1 备份一个数据库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump –u 用户名称 –h 主机名称 –p密码 待备份的数据库名称[tbname, [tbname...]]&gt; 备份文件名称.sql</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明： 备份的文件并非一定要求后缀名为.sql，例如后缀名为.txt的文件也是可以的。</p>
</blockquote>
<h4 id="2-2-备份全部数据库"><a href="#2-2-备份全部数据库" class="headerlink" title="2.2 备份全部数据库"></a>2.2 备份全部数据库</h4><p>若想用mysqldump备份整个实例，可以使用<code> --all-databases</code> 或<code>-A</code>参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -pxxxxxx --all-databases &gt; all_database.sql </span><br><span class="line">mysqldump -uroot -pxxxxxx -A &gt; all_database.sql</span><br></pre></td></tr></table></figure>

<h4 id="2-3-备份部分数据库"><a href="#2-3-备份部分数据库" class="headerlink" title="2.3 备份部分数据库"></a>2.3 备份部分数据库</h4><p>使用 <code>--databases </code>或<code>-B</code>参数了，该参数后面跟数据库名称，多个数据库间用空格隔开。如果指定databases参数，备份文件中会存在创建数据库的语句，如果不指定参数，则不存在。语法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldump –u user –h host –p --databases [数据库的名称1 [数据库的名称2...]] &gt; 备份文件名称.sql</span><br><span class="line"></span><br><span class="line">mysqldump -uroot -p --databases KK KK2 &gt;two_database.sql</span><br><span class="line">mysqldump -uroot -p -B KK KK12 &gt; two_database.sql</span><br></pre></td></tr></table></figure>

<h4 id="2-4-备份部分表"><a href="#2-4-备份部分表" class="headerlink" title="2.4 备份部分表"></a>2.4 备份部分表</h4><p>比如，在表变更前做个备份。语法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump –u user –h host –p 数据库的名称 [表名1 [表名2...]] &gt; 备份文件名称.sql</span><br></pre></td></tr></table></figure>

<h4 id="2-5-备份单表的部分数据"><a href="#2-5-备份单表的部分数据" class="headerlink" title="2.5 备份单表的部分数据"></a>2.5 备份单表的部分数据</h4><p>有些时候一张表的数据量很大，我们只需要部分数据。这时就可以使用 <code>--where</code>选项了。where后面附带需要满足的条件。</p>
<p>举例：备份student表中id小于10的数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu student <span class="comment">--where=&quot;id &lt; 10 &quot; &gt; student_part_id10_low_</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6-排除某些表的备份"><a href="#2-6-排除某些表的备份" class="headerlink" title="2.6 排除某些表的备份"></a>2.6 排除某些表的备份</h4><p>如果我们想备份某个库，但是某些表数据量很大或者与业务关联不大，这个时候可以考虑排除掉这些表，同样的，选项<code>--ignore-table</code>可以完成这个功能。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p atguigu --ignore-table=atguigu.student &gt; no_stu_bak.sql</span><br></pre></td></tr></table></figure>

<h4 id="2-7-只备份结构或只备份数据"><a href="#2-7-只备份结构或只备份数据" class="headerlink" title="2.7 只备份结构或只备份数据"></a>2.7 只备份结构或只备份数据</h4><p>只备份结构的话可以使用<code>--no-data</code>简写为<code>-d</code>选项；只备份数据可以使用<code>--no-create-info</code>简写为<code>-t</code> 选项。</p>
<ul>
<li>只备份结构</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu <span class="comment">--no-data &gt; atguigu_no_data_bak.sql</span></span><br></pre></td></tr></table></figure>

<ul>
<li>只备份数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu <span class="comment">--no-create-info &gt; atguigu_no_create_info_bak.sql</span></span><br></pre></td></tr></table></figure>

<h4 id="2-8-备份中包含存储过程、函数、事件"><a href="#2-8-备份中包含存储过程、函数、事件" class="headerlink" title="2.8 备份中包含存储过程、函数、事件"></a>2.8 备份中包含存储过程、函数、事件</h4><p>mysqldump备份默认是不包含存储过程，自定义函数及事件的。可以使用 –routines 或<code>-R</code>选项来备份存储过程及函数，使用 –events 或<code>-E</code>参数来备份事件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="operator">-</span>R <span class="operator">-</span>E <span class="comment">--databases atguigu &gt; fun_atguigu_bak.sql</span></span><br></pre></td></tr></table></figure>

<h4 id="2-9-mysqldump常用选项"><a href="#2-9-mysqldump常用选项" class="headerlink" title="2.9 mysqldump常用选项"></a>2.9 mysqldump常用选项</h4><p>mysqldump其他常用选项如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--add-drop-database：在每个CREATE DATABASE语句前添加DROP DATABASE语句。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--add-drop-tables：在每个CREATE TABLE语句前添加DROP TABLE语句。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--add-locking：用LOCK TABLES和UNLOCK TABLES语句引用每个表转储。重载转储文件时插入得更快。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--all-database, -A：转储所有数据库中的所有表。与使用--database选项相同，在命令行中命名所有数据库。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--comment[=0|1]：如果设置为0，禁止转储文件中的其他信息，例如程序版本、服务器版本和主机。--skip- comments与--comments=0的结果相同。默认值为1，即包括额外信息。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--compact：产生少量输出。该选项禁用注释并启用--skip-add-drop-tables、--no-set-names、--skip- disable-keys和--skip-add-locking选项。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--compatible=name：产生与其他数据库系统或旧的MySQL服务器更兼容的输出，值可以为ansi、MySQL323、 MySQL40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_table_options或者 no_field_options。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--complete_insert, -c：使用包括列名的完整的INSERT语句。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--debug[=debug_options], -#[debug_options]：写调试日志。</span></span><br><span class="line"><span class="comment">--delete，-D：导入文本文件前清空表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--default-character-set=charset：使用charsets默认字符集。如果没有指定，就使用utf8。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--delete--master-logs：在主复制服务器上，完成转储操作后删除二进制日志。该选项自动启用-master- data。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--extended-insert，-e：使用包括几个VALUES列表的多行INSERT语法。这样使得转储文件更小，重载文件时可 以加速插入。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--flush-logs，-F：开始转储前刷新MySQL服务器日志文件。该选项要求RELOAD权限。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--force，-f：在表转储过程中，即使出现SQL错误也继续。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--lock-all-tables，-x：对所有数据库中的所有表加锁。在整体转储过程中通过全局锁定来实现。该选项自动关 闭--single-transaction和--lock-tables。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--lock-tables，-l：开始转储前锁定所有表。用READ LOCAL锁定表以允许并行插入MyISAM表。对于事务表（例 如InnoDB和BDB），--single-transaction是一个更好的选项，因为它根本不需要锁定表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--no-create-db，-n：该选项禁用CREATE DATABASE /*!32312 IF NOT EXIST*/db_name语句，如果给出- -database或--all-database选项，就包含到输出中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--no-create-info，-t：只导出数据，而不添加CREATE TABLE语句。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--no-data，-d：不写表的任何行信息，只转储表的结构。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--opt：该选项是速记，它可以快速进行转储操作并产生一个能很快装入MySQL服务器的转储文件。该选项默认开启， 但可以用--skip-opt禁用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--password[=password]，-p[password]：当连接服务器时使用的密码。</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>port<span class="operator">=</span>port_num，<span class="operator">-</span>P port_num：用于连接的TCP<span class="operator">/</span>IP端口号。</span><br><span class="line"></span><br><span class="line"><span class="comment">--protocol=&#123;TCP|SOCKET|PIPE|MEMORY&#125;：使用的连接协议。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--replace，-r –replace和--ignore：控制替换或复制唯一键值已有记录的输入记录的处理。如果指定-- replace，新行替换有相同的唯一键值的已有行；如果指定--ignore，复制已有的唯一键值的输入行被跳过。如果不 指定这两个选项，当发现一个复制键值时会出现一个错误，并且忽视文本文件的剩余部分。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--silent，-s：沉默模式。只有出现错误时才输出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--socket=path，-S path：当连接localhost时使用的套接字文件（为默认主机）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--user=user_name，-u user_name：当连接服务器时MySQL使用的用户名。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--verbose，-v：冗长模式，打印出程序操作的详细信息。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--xml，-X：产生XML输出</span></span><br></pre></td></tr></table></figure>

<p>运行帮助命令<code>mysqldump --help</code>，可以获得特定版本的完整选项列表。</p>
<blockquote>
<p>提示 如果运行mysqldump没有–quick或–opt选项，mysqldump在转储结果前将整个结果集装入内存。如果转储大数据库可能会出现问题，该选项默认启用，但可以用–skip-opt禁用。如果使用最新版本的mysqldump程序备份数据，并用于恢复到比较旧版本的MySQL服务器中，则不要使用–opt 或-e选项。</p>
</blockquote>
<h3 id="3-MySQL命令恢复数据"><a href="#3-MySQL命令恢复数据" class="headerlink" title="3. MySQL命令恢复数据"></a>3. MySQL命令恢复数据</h3><p>基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql –u root –p [dbname] <span class="operator">&lt;</span> backup.sql</span><br></pre></td></tr></table></figure>

<h4 id="3-1-单库备份中恢复单库"><a href="#3-1-单库备份中恢复单库" class="headerlink" title="3.1 单库备份中恢复单库"></a>3.1 单库备份中恢复单库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#备份文件中包含了创建数据库的语句</span><br><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="operator">&lt;</span> atguigu.sql</span><br><span class="line">#备份文件中不包含了创建数据库的语句</span><br><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu4<span class="operator">&lt;</span> atguigu.sql</span><br></pre></td></tr></table></figure>

<h4 id="3-2-全量备份恢复"><a href="#3-2-全量备份恢复" class="headerlink" title="3.2 全量备份恢复"></a>3.2 全量备份恢复</h4><p>如果我们现在有昨天的全量备份，现在想整个恢复，则可以这样操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql –u root –p <span class="operator">&lt;</span> all.sql</span><br></pre></td></tr></table></figure>

<h4 id="3-3-从全量备份中恢复单库"><a href="#3-3-从全量备份中恢复单库" class="headerlink" title="3.3 从全量备份中恢复单库"></a>3.3 从全量备份中恢复单库</h4><p>可能有这样的需求，比如说我们只想恢复某一个库，但是我们有的是整个实例的备份，这个时候我们可以从全量备份中分离出单个库的备份。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="operator">-</span>n <span class="string">&#x27;/^-- Current Database: `atguigu`/,/^-- Current Database: `/p&#x27;</span> all_database.sql <span class="operator">&gt;</span> atguigu.sql </span><br><span class="line">#分离完成后我们再导入KK.sql即可恢复单个库</span><br></pre></td></tr></table></figure>

<h4 id="3-4-从单库备份中恢复单表"><a href="#3-4-从单库备份中恢复单表" class="headerlink" title="3.4 从单库备份中恢复单表"></a>3.4 从单库备份中恢复单表</h4><p>这个需求还是比较常见的。比如说我们知道哪个表误操作了，那么就可以用单表恢复的方式来恢复。</p>
<p>举例：我们有atguigu整库的备份，但是由于class表误操作，需要单独恢复出这张表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat KK.sql <span class="operator">|</span> sed <span class="operator">-</span>e <span class="string">&#x27;/./&#123;H;$!d;&#125;&#x27;</span> <span class="operator">-</span>e <span class="string">&#x27;x;/CREATE TABLE `class`/!d;q&#x27;</span> <span class="operator">&gt;</span> class_structure.sql </span><br><span class="line">cat KK.sql <span class="operator">|</span> grep <span class="comment">--ignore-case &#x27;insert into `class`&#x27; &gt; class_data.sql </span></span><br><span class="line">#用shell语法分离出创建表的语句及插入数据的语句后 再依次导出即可完成恢复 </span><br><span class="line">use test; </span><br><span class="line">mysql<span class="operator">&gt;</span> source class_structure.sql; </span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected, <span class="number">1</span> warning (<span class="number">0.00</span> sec) </span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> source class_data.sql; </span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="4-物理备份：直接复制整个数据库"><a href="#4-物理备份：直接复制整个数据库" class="headerlink" title="4. 物理备份：直接复制整个数据库"></a>4. 物理备份：直接复制整个数据库</h3><p>直接将MySQL中的数据库文件复制出来。这种方法最简单，速度也最快。MySQL的数据库目录位置不一定相同：</p>
<ul>
<li><p>在Windows平台下，MySQL 8.0存放数据库的目录通常默认为 “ C:\ProgramData\MySQL\MySQL Server 8.0\Data ”或者其他用户自定义目录；</p>
</li>
<li><p>在Linux平台下，数据库目录位置通常为&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;；</p>
</li>
<li><p>在MAC OSX平台下，数据库目录位置通常为“&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data”</p>
</li>
</ul>
<p>但为了保证备份的一致性。需要保证：</p>
<ul>
<li>方式1：备份前，将服务器停止。</li>
<li>方式2：备份前，对相关表执行 FLUSH TABLES WITH READ LOCK 操作。这样当复制数据库目录中的文件时，允许其他客户继续查询表。同时，FLUSH TABLES语句来确保开始备份前将所有激活的索引页写入硬盘。</li>
</ul>
<p>这种方式方便、快速，但不是最好的备份方法，因为实际情况可能 不允许停止MySQL服务器 或者 锁住 表 ，而且这种方法 对InnoDB存储引擎 的表不适用。对于MyISAM存储引擎的表，这样备份和还原很方便，但是还原时最好是相同版本的MySQL数据库，否则可能会存在文件类型不同的情况。</p>
<p>注意，物理备份完毕后，执行<code>UNLOCK TABLES</code>来结算其他客户对表的修改行为。</p>
<blockquote>
<p>说明： 在MySQL版本号中，第一个数字表示主版本号，主版本号相同的MySQL数据库文件格式相同。</p>
</blockquote>
<p>此外，还可以考虑使用相关工具实现备份。比如， MySQLhotcopy 工具。MySQLhotcopy是一个Perl脚本，它使用LOCK TABLES、FLUSH TABLES和cp或scp来快速备份数据库。它是备份数据库或单个表最快的途径，但它只能运行在数据库目录所在的机器上，并且只能备份MyISAM类型的表。多用于mysql5.5之前。</p>
<h3 id="5-物理恢复：直接复制到数据库目录"><a href="#5-物理恢复：直接复制到数据库目录" class="headerlink" title="5. 物理恢复：直接复制到数据库目录"></a>5. 物理恢复：直接复制到数据库目录</h3><p>步骤：<br>1）演示删除备份的数据库中指定表的数据<br>2）将备份的数据库数据拷贝到数据目录下，并重启MySQL服务器<br>3）查询相关表的数据是否恢复。需要使用下面的 chown 操作。</p>
<p>要求</p>
<ul>
<li><p>必须确保备份数据的数据库和待恢复的数据库服务器的主版本号相同。</p>
<ul>
<li>因为只有MySQL数据库主版本号相同时，才能保证这两个MySQL数据库文件类型是相同的。</li>
</ul>
</li>
<li><p>这种方式对 MyISAM类型的表比较有效 ，对于InnoDB类型的表则不可用。</p>
<ul>
<li>因为InnoDB表的表空间不能直接复制。</li>
</ul>
</li>
<li><p>在Linux操作系统下，复制到数据库目录后，一定要将数据库的用户和组变成mysql，命令如下：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown <span class="operator">-</span>R mysql.mysql <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>dbname</span><br></pre></td></tr></table></figure>

<p>其中，两个mysql分别表示组和用户；“-R”参数可以改变文件夹下的所有子文件的用户和组；“dbname”参数表示数据库目录。</p>
<blockquote>
<p>提示 Linux操作系统下的权限设置非常严格。通常情况下，MySQL数据库只有root用户和mysql用户组下的mysql用户才可以访问，因此将数据库目录复制到指定文件夹后，一定要使用chown命令将文件夹的用户组变为mysql，将用户变为mysql。</p>
</blockquote>
<h3 id="6-表的导入与导出"><a href="#6-表的导入与导出" class="headerlink" title="6. 表的导入与导出"></a>6. 表的导入与导出</h3><h4 id="6-1-表的导出"><a href="#6-1-表的导出" class="headerlink" title="6.1 表的导出"></a>6.1 表的导出</h4><ol>
<li>使用SELECT…INTO OUTFILE导出文本文件</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%secure%&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">INTO</span> OUTFILE &quot;/var/lib/mysql-files/account.txt&quot;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用mysqldump命令导出文本文件</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="operator">-</span>T &quot;/var/lib/mysql-files/&quot; atguigu account</span><br><span class="line"># 或</span><br><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="operator">-</span>T &quot;/var/lib/mysql-files/&quot; atguigu account <span class="comment">--fields-terminated- by=&#x27;,&#x27; --fields-optionally-enclosed-by=&#x27;\&quot;&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用mysql命令导出文本文件</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="comment">--execute=&quot;SELECT * FROM account;&quot; atguigu&gt; &quot;/var/lib/mysql-files/account.txt</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-表的导入"><a href="#6-2-表的导入" class="headerlink" title="6.2 表的导入"></a>6.2 表的导入</h4><ol>
<li>使用LOAD DATA INFILE方式导入文本文件</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">&#x27;/var/lib/mysql-files/account_0.txt&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> atguigu.account;</span><br><span class="line"># 或</span><br><span class="line">LOAD DATA INFILE <span class="string">&#x27;/var/lib/mysql-files/account_1.txt&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> atguigu.account FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span> ENCLOSED <span class="keyword">BY</span> <span class="string">&#x27;\&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用mysqlimport方式导入文本文件</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlimport <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu <span class="string">&#x27;/var/lib/mysql-files/account.txt&#x27;</span> <span class="comment">--fields-terminated- by=&#x27;,&#x27; -</span></span><br></pre></td></tr></table></figure>

<h3 id="7-数据库迁移"><a href="#7-数据库迁移" class="headerlink" title="7. 数据库迁移"></a>7. 数据库迁移</h3><h4 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h4><p>数据迁移(data migration) 是指选择、准备、提取和转换数据，并<strong>将数据从一个计算机存储系统永久地传输到另一个计算机存储系统的过程</strong>。此外，<strong>验证迁移数据的完整性</strong>和<strong>退役原来旧的数据存储</strong>，也被认为是整个数据迁移过程的一部分。</p>
<p>数据库迁移的原因是多样的，包括服务器或存储设备更换、维护或升级，应用程序迁移，网站集成，灾难恢复和数据中心迁移。</p>
<p>根据不同的需求可能要采取不同的迁移方案，但总体来说，MySQL数据迁移方案大值可以分为<strong>物理迁移</strong>和<strong>逻辑迁移</strong>两类。通常以尽可能自动化的方式执行，从而将人力资源从繁琐的任务中解放出来。</p>
<h4 id="7-2-迁移方案"><a href="#7-2-迁移方案" class="headerlink" title="7.2 迁移方案"></a>7.2 迁移方案</h4><ul>
<li><p>物理迁移</p>
<p>  物理迁移适用于大数据量下的整体迁移。使用物理迁移方案的优点是比较快速，但需要停机迁移并且要求 MySQL版本及配置必须和原服务器相同，也可能引起未知问题。</p>
<p>  物理迁移包括拷贝数据文件和使用 XtraBackup 备份工具两种。</p>
<p>  不同服务器之间可以采用物理迁移，我们可以在新的服务器上安装好同版本的数据库软件，创建好相同目录，建议配置文件也要和原数据库相同，然后从原数据库方拷贝来数据文件及日志文件，配置好文件组权限，之后在新服务器这边使用 mysqld 命令启动数据库。</p>
</li>
<li><p>逻辑迁移</p>
<p>  逻辑迁移适用范围更广，无论是部分迁移还是全量迁移，都可以使用逻辑迁移。逻辑迁移中使用最多的就是通过 mysqldump 等备份工具。</p>
</li>
</ul>
<h4 id="7-3-迁移注意点"><a href="#7-3-迁移注意点" class="headerlink" title="7.3 迁移注意点"></a>7.3 迁移注意点</h4><p><strong>1. 相同版本的数据库之间迁移注意点</strong></p>
<p>指的是在主版本号相同的 MySQL 数据库之间进行数据库移动。</p>
<p>方式1: 因为迁移前后 MySQL 数据库的主版本号相同，所以可以通过复制数据库目录来实现数据库迁移，但是物理迁移方式只适用于 MyISAM 引擎的表。对于 InnoDB 表，不能用直接复制文件的方式备份数据库。</p>
<p>方式2: 最常见和最安全的方式是使用 mysqldump 命令导出数据，然后再目标数据库服务器中使用 MySQL 命令导入。</p>
<p><strong>2. 不同版本的数据库之间迁移注意点</strong></p>
<p>例如，原来很多服务器使用5.7版本的MySQL数据库，在8.0版本推出来以后，改进了5.7版本的很多缺陷，因此需要把数据库升级到8.0版本。</p>
<p>旧版本与新版本的 MySQL 可能使用不同的默认字符集，例如有的旧版本中使用latin1作为默认字符集，而最新版本的 MySQL 默认字符集为 utf8mb4.如果数据库中有中文数据，那么迁移过程中需要对默认字符集进行修改，不然可能无法正常显示数据。</p>
<p>高版本的 MySQL 数据库通常都会兼容低版本，因此可以从低版本的MySQL 数据库迁移到高版本的MySQL数据库。</p>
<p><strong>3. 不同数据库之间迁移注意点</strong></p>
<p>不同数据库之间迁移是指从其他类型的数据库迁移到MySQL数据库，或者从MySQL数据库迁移到其他类型的数据库。这种迁移没有普适的解决方法。</p>
<p>迁移之前，需要了解不同数据库的架构， 比较它们之间的差异。不同数据库中定义相同类型的数据的关键字可能会不同。例如，MysQL中日期字段分为DATE和TIME两种，而ORACLE日期字段只有DATE; SQLServer数据库中有 ntext、Image等数据类型，MySQL数据库没有这些数据类型;MysQL支持的ENUM和SET类型，这些SQL Server数振库不支持。</p>
<p>另外，数据库厂商并没有完全按照SQL标准来设计数据库系统，导致不同的数据库系统的SQL语句有差别。例如，微软的SQL Server软件使用的是T-SQL语句，下-SQL中包含了非标准的SQL语句，不能和MySQL的SQL语句兼容。</p>
<p>不同类型数据库之间的差昇造成了互相迁移的困难，这些差异其实是商业公司故意造成的技术壁垒。但是不同头型的数据库之间的迁移并不是完全不可能。例如，可以使用 MyODBC 实现MySQL和SQL server之间的迁移。 MysQL 官方提供的工具 MySQL Migration Toolkit 也可以在不同数据之间进行数据迁移。MySQL迁移到Oracle时，需要使用mysqldump命令导出sql文件，然后， 手动更改sql文件中的CREATE语句。</p>
<h4 id="7-4-迁移小结"><a href="#7-4-迁移小结" class="headerlink" title="7.4 迁移小结"></a>7.4 迁移小结</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/image-20230201113541781.png" alt="image-20230201113541781" style="zoom:50%;" />

<h3 id="8-误删数据库处理方式"><a href="#8-误删数据库处理方式" class="headerlink" title="8. 误删数据库处理方式"></a>8. 误删数据库处理方式</h3><p>传统的高可用架构是不能预防误删数据的，因为主库的一个drop table命呤，会通过binlog传给所有从库和级联从库，进而导致整个集群的实例都会执行这个命令。</p>
<p>为了找到解决误删数据的更高效的方法，我们需要先对和MySQL相关的误删数据，做下分类：</p>
<ol>
<li>使用delete语句误删数据行；</li>
<li>使用drop table或者truncate table语句误删数据表；</li>
<li>使用drop database 语句误删数据库；</li>
<li>使用rm命令误删整个MysQL实例。</li>
</ol>
<h4 id="8-1-delete：误删行"><a href="#8-1-delete：误删行" class="headerlink" title="8.1 delete：误删行"></a>8.1 delete：误删行</h4><p><strong>处理措施1：数据恢复</strong></p>
<p>使用<code>Flashback工具</code>恢复数据。</p>
<p>原理：	修改binlog	内容，拿回原库重放。如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行。</p>
<p>使用前提：<code>binlog_format=row</code> 和<code>binlog_row_image=FULL</code></p>
<p><strong>处理措施2：预防</strong></p>
<ul>
<li><p>代码上线前，必须<code>SQL审查</code>、<code>审计</code>。</p>
</li>
<li><p>建议可以打开<code>安全模式</code>，把 <code>sql_safe_updates</code> 参数设置为 <code>on</code>。强制要求加where 条件且where后需要是索引l字段，否则必须使用limit。否则就会报错。</p>
</li>
</ul>
<h4 id="8-2-truncate-x2F-drop：误删库-x2F-表"><a href="#8-2-truncate-x2F-drop：误删库-x2F-表" class="headerlink" title="8.2 truncate&#x2F;drop：误删库&#x2F;表"></a>8.2 truncate&#x2F;drop：误删库&#x2F;表</h4><p><strong>背景</strong>：</p>
<p>delete全表是很慢的，需要生成回滚日志、写redo、写binlog。所以，从性能角度考虑，优先考虑使用truncate table或者drop table命令。</p>
<p>使用delete命令删除的数据，你还可以用Flashback来恢复。而使用truncate &#x2F;drop table和drop database命令删除的数据，就没办法通过Flashback来恢复了。因为，即使我们配置了binlog_ format&#x3D;row，执行这三个命令时，记录的 binlog还是statement格式。binlog里面就只有一个truncate&#x2F;drop 语句，这些信息是恢复不出数据的。</p>
<p><strong>方案</strong>：</p>
<p>这种情况下恢复数据，需要使用全量备份与增量日志结合的方式。</p>
<p>方案的前提：有定期的全量备份，并且实时备份binlog </p>
<p>举例：有人误删了一个库，时间为下午3点。步骤如下：</p>
<ol>
<li>取最近一次全量备份。假设设置数据库库是一天一备，最近备份数据是当天凌晨2点；</li>
<li>用备份恢复出一个临时库;（注意：这里选择临时库，而不是直接操作主库）</li>
<li>取出凌晨2点之后的binlog日志；</li>
<li>剔除误删除数据的语句外，其它语句全部应用到临时库。（前面讲过binlog的恢复）</li>
<li>最后恢复到主库</li>
</ol>
<h4 id="8-3-预防使用truncate-x2F-drop误删库-x2F-表"><a href="#8-3-预防使用truncate-x2F-drop误删库-x2F-表" class="headerlink" title="8.3 预防使用truncate &#x2F;drop误删库&#x2F;表"></a>8.3 预防使用truncate &#x2F;drop误删库&#x2F;表</h4><p>上面我们说了使用truncate&#x2F;drop语句误删库&#x2F;表的恢复方案，在生产环境中可以通过下面建议的方案来尽量的避免类似的误操作。</p>
<p><strong>(1)权限分离</strong></p>
<ul>
<li><p>限制帐户权限，核心的数据库，一般都不能随便分配写权限，想要获取写权限需要审批。比如只给业务开发人员DML权限，不给truncate&#x2F;drop权限。即使是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。</p>
</li>
<li><p>不同的账号，不同的数据之问要进行权限分离，避免一个账号可以删除所有库。</p>
</li>
</ul>
<p><strong>(2)制定操作规范</strong></p>
<p>比如在删除数据表之前，必须先对表做改名操作（比如加_to_be_deleted ）。然后，观察一段时间，确保对业务无影响以后再删除这张表。</p>
<p><strong>(3)设置延迟复制备库</strong></p>
<p>简单的说延迟复制就是设置一个固定的延迟时间，比如1个小时，让从库落后主库一个小时。出现误删除操作小小时内，到这个备库上执行 <code>stop slave</code>，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。这里通过 <code>CHANGE MASTER TO MASTER_DELAY = N</code>命令，可以指定这个备库持续保持跟主库有N秒的延迟。比如把N设置为3600，即代表1个小时。</p>
<p>此外，延迟复制还可以用来解决以下问题：</p>
<p>① 用来做延迟测试，比如做好的数据库读写分离，把从库作为读库，那么想知道当数据产生延迟的时候到底会发生什么，就可以使用这个特性模拟延迟。</p>
<p>② 用于老数据的查询等需求，比如你经常需要查看某天前一个表或者字段的数值，你可能需要把备份恢复后进行查看，如果有延迟从库，比如延迟一周，那么就可以解决这样类似的需求。|</p>
<h4 id="8-4-rm：误删MySQL实例"><a href="#8-4-rm：误删MySQL实例" class="headerlink" title="8.4 rm：误删MySQL实例"></a>8.4 rm：误删MySQL实例</h4><p>对于一个有高可用机制的MySQL集群来说，不用担心 rm 删除数据。因为只删掉其中某一个节点数据的话，HA系统就会选出一个新的主库，从而保证整个集群的正常工作。我们把这个节点上的数据恢复回来后，再接入整个集群就好了。</p>
<p>但如果是恶意地把整个集群删除，那就需要考虑跨机房备份，跨城市备份。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="http://1.117.162.142:9000/blog/cover.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/28/kafka/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/cover.jpeg" onerror="onerror=null;src='http://1.117.162.142:9000/blog/404.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Kafka</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/25/mysql-basic/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/cover.jpeg" onerror="onerror=null;src='http://1.117.162.142:9000/blog/404.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL 基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/10/25/mysql-basic/" title="MySQL 基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/cover.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-25</div><div class="title">MySQL 基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">一、用户与权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">1. 用户管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%99%BB%E5%BD%95-MySQL-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 登录 MySQL 服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 创建用户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 修改用户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 删除用户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 设置当前用户密码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-%E4%BF%AE%E6%94%B9%E5%85%B6%E5%AE%83%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.6 修改其它用户密码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-MySQL-8-%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.7.</span> <span class="toc-text">1.7 MySQL 8 密码管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">2. 权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%9D%83%E9%99%90%E5%88%97%E8%A1%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 权限列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%8E%88%E4%BA%88%E6%9D%83%E9%99%90%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 授予权限的原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%8E%88%E4%BA%88%E6%9D%83%E9%99%90"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 授予权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E6%9F%A5%E7%9C%8B%E6%9D%83%E9%99%90"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 查看权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E6%94%B6%E5%9B%9E%E6%9D%83%E9%99%90"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 收回权限</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9D%83%E9%99%90%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">3. 权限表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">4. 访问控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%A7%92%E8%89%B2%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">5. 角色管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E5%88%9B%E5%BB%BA%E8%A7%92%E8%89%B2"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 创建角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E7%BB%99%E8%A7%92%E8%89%B2%E8%B5%8B%E4%BA%88%E6%9D%83%E9%99%90"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 给角色赋予权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E6%9F%A5%E7%9C%8B%E8%A7%92%E8%89%B2%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 查看角色的权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E5%9B%9E%E6%94%B6%E8%A7%92%E8%89%B2%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 回收角色的权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E5%88%A0%E9%99%A4%E8%A7%92%E8%89%B2"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.5 删除角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-%E7%BB%99%E7%94%A8%E6%88%B7%E8%B5%8B%E4%BA%88%E8%A7%92%E8%89%B2"><span class="toc-number">1.5.6.</span> <span class="toc-text">5.6 给用户赋予角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-%E6%BF%80%E6%B4%BB%E8%A7%92%E8%89%B2"><span class="toc-number">1.5.7.</span> <span class="toc-text">5.7 激活角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-%E6%92%A4%E9%94%80%E7%94%A8%E6%88%B7%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-number">1.5.8.</span> <span class="toc-text">5.8 撤销用户的角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-9-%E8%AE%BE%E7%BD%AE%E5%BC%BA%E5%88%B6%E8%A7%92%E8%89%B2-mandatory-role"><span class="toc-number">1.5.9.</span> <span class="toc-text">5.9 设置强制角色 (mandatory role)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-10-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.5.10.</span> <span class="toc-text">5.10 小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">二、逻辑架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%89%96%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">1. 逻辑架构剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 服务器处理客户端请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-Connectors"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 Connectors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E7%AC%AC%E4%B8%80%E5%B1%82%EF%BC%9A%E8%BF%9E%E6%8E%A5%E5%B1%82"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 第一层：连接层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E7%AC%AC%E4%BA%8C%E5%B1%82%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%B1%82"><span class="toc-number">2.1.4.</span> <span class="toc-text">1.4 第二层：服务层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E7%AC%AC%E4%B8%89%E5%B1%82%EF%BC%9A%E5%BC%95%E6%93%8E%E5%B1%82"><span class="toc-number">2.1.5.</span> <span class="toc-text">1.5 第三层：引擎层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-%E5%AD%98%E5%82%A8%E5%B1%82"><span class="toc-number">2.1.6.</span> <span class="toc-text">1.6 存储层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-%E5%B0%8F%E7%BB%93"><span class="toc-number">2.1.7.</span> <span class="toc-text">1.7 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SQL-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2. SQL 执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-MySQL-%E4%B8%AD%E7%9A%84-SQL-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 MySQL 中的 SQL 执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-MySQL-8-%E4%B8%AD-SQL-%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 MySQL 8 中 SQL 执行原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%86%B2%E6%B1%A0-buffer-pool"><span class="toc-number">2.3.</span> <span class="toc-text">3. 数据库缓冲池 (buffer pool)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E7%BC%93%E5%86%B2%E6%B1%A0-vs-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1 缓冲池 vs 查询缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E7%BC%93%E5%86%B2%E6%B1%A0%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2 缓冲池如何读取数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E6%9F%A5%E7%9C%8B-x2F-%E8%AE%BE%E7%BD%AE%E7%BC%93%E5%86%B2%E6%B1%A0%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3 查看&#x2F;设置缓冲池的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E5%A4%9A%E4%B8%AA-Buffer-Pool-%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.3.4.</span> <span class="toc-text">3.4 多个 Buffer Pool 实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%BC%95%E7%94%B3%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.5.</span> <span class="toc-text">3.5 引申问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.</span> <span class="toc-text">三、存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9F%A5%E7%9C%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.1.</span> <span class="toc-text">1. 查看存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.2.</span> <span class="toc-text">2. 设置系统默认的存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%BE%E7%BD%AE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.3.</span> <span class="toc-text">3. 设置表的存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%97%B6%E6%8C%87%E5%AE%9A%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1 创建表时指定存储引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.2 修改表的存储引擎</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.4.</span> <span class="toc-text">4. 引擎介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-InnoDB-%E5%BC%95%E6%93%8E%EF%BC%9A%E5%85%B7%E5%A4%87%E5%A4%96%E9%94%AE%E6%94%AF%E6%8C%81%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.4.1.</span> <span class="toc-text">4.1 InnoDB 引擎：具备外键支持功能的事务存储引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-MyISAM-%E5%BC%95%E6%93%8E%EF%BC%9A%E4%B8%BB%E8%A6%81%E7%9A%84%E9%9D%9E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.4.2.</span> <span class="toc-text">4.2 MyISAM 引擎：主要的非事务处理存储引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-Archive-%E5%BC%95%E6%93%8E%EF%BC%9A%E7%94%A8%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E6%A1%A3"><span class="toc-number">3.4.3.</span> <span class="toc-text">4.3 Archive 引擎：用于数据存档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-Blackhole-%E5%BC%95%E6%93%8E%EF%BC%9A%E4%B8%A2%E5%BC%83%E5%86%99%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%AF%BB%E6%93%8D%E4%BD%9C%E4%BC%9A%E8%BF%94%E5%9B%9E%E7%A9%BA%E5%86%85%E5%AE%B9"><span class="toc-number">3.4.4.</span> <span class="toc-text">4.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-CSV-%E5%BC%95%E6%93%8E%EF%BC%9A%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E4%BB%A5%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94%E5%90%84%E4%B8%AA%E6%95%B0%E6%8D%AE%E9%A1%B9"><span class="toc-number">3.4.5.</span> <span class="toc-text">4.5 CSV 引擎：存储数据时，以逗号分隔各个数据项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-Memory-%E5%BC%95%E6%93%8E%EF%BC%9A%E7%BD%AE%E4%BA%8E%E5%86%85%E5%AD%98%E7%9A%84%E8%A1%A8"><span class="toc-number">3.4.6.</span> <span class="toc-text">4.6 Memory 引擎：置于内存的表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-Federated-%E5%BC%95%E6%93%8E%EF%BC%9A%E8%AE%BF%E9%97%AE%E8%BF%9C%E7%A8%8B%E8%A1%A8"><span class="toc-number">3.4.7.</span> <span class="toc-text">4.7 Federated 引擎：访问远程表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-Merge-%E5%BC%95%E6%93%8E%EF%BC%9A%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AA-MyISAM-%E8%A1%A8%E6%9E%84%E6%88%90%E7%9A%84%E8%A1%A8%E9%9B%86%E5%90%88"><span class="toc-number">3.4.8.</span> <span class="toc-text">4.8 Merge 引擎：管理多个 MyISAM 表构成的表集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-9-NDB-%E5%BC%95%E6%93%8E%EF%BC%9AMySQL-%E9%9B%86%E7%BE%A4%E4%B8%93%E7%94%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.4.9.</span> <span class="toc-text">4.9 NDB 引擎：MySQL 集群专用存储引擎</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-MyISAM-%E5%92%8C-InnoDB"><span class="toc-number">3.5.</span> <span class="toc-text">5. MyISAM 和 InnoDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E3%80%81%E6%B7%98%E5%AE%9D%E7%94%A8%E5%93%AA%E4%B8%AA"><span class="toc-number">3.6.</span> <span class="toc-text">6. 阿里巴巴、淘宝用哪个</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%A1%A5%E5%85%85"><span class="toc-number">3.7.</span> <span class="toc-text">7. 补充</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-InnoDB-%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">3.7.1.</span> <span class="toc-text">7.1 InnoDB 表的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-InnoDB-%E5%92%8C-ACID-%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.7.2.</span> <span class="toc-text">7.2 InnoDB 和 ACID 模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-InnoDB-%E6%9E%B6%E6%9E%84"><span class="toc-number">3.7.3.</span> <span class="toc-text">7.3 InnoDB 架构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">四、索引的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">4.1.</span> <span class="toc-text">1. 为什么使用索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">2. 索引及其优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E7%B4%A2%E5%BC%95%E6%A6%82%E8%BF%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1 索引概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E4%BC%98%E7%82%B9"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2 优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E7%BC%BA%E7%82%B9"><span class="toc-number">4.2.3.</span> <span class="toc-text">2.3 缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-InnoDB-%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%A8%E6%BC%94"><span class="toc-number">4.3.</span> <span class="toc-text">3. InnoDB 中索引的推演</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E7%B4%A2%E5%BC%95%E4%B9%8B%E5%89%8D%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.1 索引之前的查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E8%AE%BE%E8%AE%A1%E7%B4%A2%E5%BC%95"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.2 设计索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5"><span class="toc-number">4.3.3.</span> <span class="toc-text">3.3 常见索引概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-InnoDB-%E7%9A%84-B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.3.4.</span> <span class="toc-text">3.4 InnoDB 的 B+ 树索引的注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-MyISAM-%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="toc-number">4.4.</span> <span class="toc-text">4. MyISAM 中的索引方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-MyISAM-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.1 MyISAM 索引的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-MyISAM-%E4%B8%8E-InnoDB-%E5%AF%B9%E6%AF%94"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.2 MyISAM 与 InnoDB 对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">4.5.</span> <span class="toc-text">5. 索引的代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-MySQL-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E6%8B%A9%E7%9A%84%E5%90%88%E7%90%86%E6%80%A7"><span class="toc-number">4.6.</span> <span class="toc-text">6. MySQL 数据结构选择的合理性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E5%85%A8%E8%A1%A8%E9%81%8D%E5%8E%86"><span class="toc-number">4.6.1.</span> <span class="toc-text">6.1 全表遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-Hash-%E7%BB%93%E6%9E%84"><span class="toc-number">4.6.2.</span> <span class="toc-text">6.2 Hash 结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">4.6.3.</span> <span class="toc-text">6.3 二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-AVL-%E6%A0%91"><span class="toc-number">4.6.4.</span> <span class="toc-text">6.4 AVL 树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-BTree"><span class="toc-number">4.6.5.</span> <span class="toc-text">6.5 BTree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-B-Tree"><span class="toc-number">4.6.6.</span> <span class="toc-text">6.6 B + Tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-R-%E6%A0%91"><span class="toc-number">4.6.7.</span> <span class="toc-text">6.7 R 树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-%E5%B0%8F%E7%BB%93"><span class="toc-number">4.6.8.</span> <span class="toc-text">6.8 小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81InnoDB-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">五、InnoDB 数据存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A%E9%A1%B5"><span class="toc-number">5.1.</span> <span class="toc-text">1. 数据库的存储结构：页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%A3%81%E7%9B%98%E4%B8%8E%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D%EF%BC%9A%E9%A1%B5"><span class="toc-number">5.1.1.</span> <span class="toc-text">1.1 磁盘与内存交互基本单位：页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E9%A1%B5%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.2.</span> <span class="toc-text">1.2 页结构概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E9%A1%B5%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">5.1.3.</span> <span class="toc-text">1.3 页的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E9%A1%B5%E7%9A%84%E4%B8%8A%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.4.</span> <span class="toc-text">1.4 页的上层结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%A1%B5%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">2. 页的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-File-Header-%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8-%E5%92%8C-File-Trailer-%E6%96%87%E4%BB%B6%E5%B0%BE%E9%83%A8"><span class="toc-number">5.2.1.</span> <span class="toc-text">2.1 File Header (文件头部) 和 File Trailer (文件尾部)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-User-Records-%E7%94%A8%E6%88%B7%E8%AE%B0%E5%BD%95-%E3%80%81%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%AE%B0%E5%BD%95%E3%80%81Free-Space-%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.2 User Records (用户记录)、最大最小记录、Free Space (空闲空间)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Page-Directory-%E9%A1%B5%E7%9B%AE%E5%BD%95-%E3%80%81Page-Header-%E9%A1%B5%E9%9D%A2%E5%A4%B4%E9%83%A8"><span class="toc-number">5.2.3.</span> <span class="toc-text">2.3 Page Directory (页目录)、Page Header (页面头部)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E4%BB%8E%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B-B-%E6%A0%91%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.2.4.</span> <span class="toc-text">2.4 从数据页的角度看 B+ 树如何查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-InnoDB-%E8%A1%8C%E6%A0%BC%E5%BC%8F-%E6%88%96%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">3. InnoDB 行格式 (或记录格式)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%8C%87%E5%AE%9A%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">5.3.1.</span> <span class="toc-text">3.1 指定行格式的语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-COMPACT-%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.3.2.</span> <span class="toc-text">3.2 COMPACT 行格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Dynamic-%E5%92%8C-Compressed-%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.3.3.</span> <span class="toc-text">3.3 Dynamic 和 Compressed 行格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-Redundant-%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.3.4.</span> <span class="toc-text">3.4 Redundant 行格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8C%BA%E3%80%81%E6%AE%B5%E4%B8%8E%E7%A2%8E%E7%89%87%E5%8C%BA"><span class="toc-number">5.4.</span> <span class="toc-text">4. 区、段与碎片区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8C%BA%EF%BC%9F"><span class="toc-number">5.4.1.</span> <span class="toc-text">4.1 为什么要有区？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E6%AE%B5%EF%BC%9F"><span class="toc-number">5.4.2.</span> <span class="toc-text">4.2 为什么要有段？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%A2%8E%E7%89%87%E5%8C%BA%EF%BC%9F"><span class="toc-number">5.4.3.</span> <span class="toc-text">4.3 为什么要有碎片区？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E5%8C%BA%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">5.4.4.</span> <span class="toc-text">4.4 区的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">5.5.</span> <span class="toc-text">5. 表空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E7%8B%AC%E7%AB%8B%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">5.5.1.</span> <span class="toc-text">5.1 独立表空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">5.5.2.</span> <span class="toc-text">5.2 系统表空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%BD%95%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">5.6.</span> <span class="toc-text">附录：数据页加载的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%AF%BB%E5%8F%96"><span class="toc-number">5.6.1.</span> <span class="toc-text">内存读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%8F%96"><span class="toc-number">5.6.2.</span> <span class="toc-text">随机读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%8F%96"><span class="toc-number">5.6.3.</span> <span class="toc-text">顺序读取</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">6.</span> <span class="toc-text">六、索引的创建与设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B4%A2%E5%BC%95%E7%9A%84%E7%94%9F%E5%91%BD%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">6.1.</span> <span class="toc-text">1. 索引的生命与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">6.1.1.</span> <span class="toc-text">1.1 索引的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">6.1.2.</span> <span class="toc-text">1.2 创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">6.1.3.</span> <span class="toc-text">1.3 删除索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-MySQL-8-0-%E7%B4%A2%E5%BC%95%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text">2. MySQL 8.0 索引新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%94%AF%E6%8C%81%E9%99%8D%E5%BA%8F%E7%B4%A2%E5%BC%95"><span class="toc-number">6.2.1.</span> <span class="toc-text">2.1 支持降序索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E9%9A%90%E8%97%8F%E7%B4%A2%E5%BC%95"><span class="toc-number">6.2.2.</span> <span class="toc-text">2.2 隐藏索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">6.3.</span> <span class="toc-text">3. 索引的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87"><span class="toc-number">6.3.1.</span> <span class="toc-text">3.1 数据准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">6.3.2.</span> <span class="toc-text">3.2 哪些情况适合创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E9%99%90%E5%88%B6%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">6.3.3.</span> <span class="toc-text">3.3 限制索引的数目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">6.3.4.</span> <span class="toc-text">3.4 哪些情况不适合创建索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">6.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">七、性能分析工具的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="toc-number">7.1.</span> <span class="toc-text">1. 数据库服务器的优化步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">2. 查看系统性能参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%9F%E8%AE%A1-SQL-%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%88%90%E6%9C%AC%EF%BC%9Alast-query-cost"><span class="toc-number">7.3.</span> <span class="toc-text">3. 统计 SQL 的查询成本：last_query_cost</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AE%9A%E4%BD%8D%E6%89%A7%E8%A1%8C%E6%85%A2%E7%9A%84-SQL%EF%BC%9A%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">7.4.</span> <span class="toc-text">4. 定位执行慢的 SQL：慢查询日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%BC%80%E5%90%AF%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%8F%82%E6%95%B0"><span class="toc-number">7.4.1.</span> <span class="toc-text">4.1 开启慢查询日志参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E4%BF%AE%E6%94%B9-long-query-time-%E9%98%88%E5%80%BC"><span class="toc-number">7.4.2.</span> <span class="toc-text">4.2 修改 long_query_time 阈值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">7.4.3.</span> <span class="toc-text">4.3 案例演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%9Amysqldumpslow"><span class="toc-number">7.4.4.</span> <span class="toc-text">4.4 慢查询日志分析工具：mysqldumpslow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-%E5%85%B3%E9%97%AD%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">7.4.5.</span> <span class="toc-text">4.5 关闭慢查询日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-%E5%88%A0%E9%99%A4%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">7.4.6.</span> <span class="toc-text">4.6 删除慢查询日志</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9F%A5%E7%9C%8B-SQL-%E6%89%A7%E8%A1%8C%E6%88%90%E6%9C%AC%EF%BC%9ASHOW-PROFILE"><span class="toc-number">7.5.</span> <span class="toc-text">5. 查看 SQL 执行成本：SHOW PROFILE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%88%86%E6%9E%90%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%EF%BC%9AEXPLAIN"><span class="toc-number">7.6.</span> <span class="toc-text">6. 分析查询语句：EXPLAIN</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">7.6.1.</span> <span class="toc-text">6.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">7.6.2.</span> <span class="toc-text">6.2 基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87"><span class="toc-number">7.6.3.</span> <span class="toc-text">6.3 数据准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-EXPLAIN-%E5%90%84%E5%88%97%E4%BD%9C%E7%94%A8"><span class="toc-number">7.6.4.</span> <span class="toc-text">6.4 EXPLAIN 各列作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-EXPLAIN-%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BD%BF%E7%94%A8"><span class="toc-number">7.7.</span> <span class="toc-text">7. EXPLAIN 的进一步使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-EXPLAIN-%E5%9B%9B%E7%A7%8D%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-number">7.7.1.</span> <span class="toc-text">7.1 EXPLAIN 四种输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-SHOW-WARNINGS-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.7.2.</span> <span class="toc-text">7.2 SHOW WARNINGS 的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96%E5%99%A8%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%9Atrace"><span class="toc-number">7.8.</span> <span class="toc-text">8. 分析优化器执行计划：trace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-MySQL-%E7%9B%91%E6%8E%A7%E5%88%86%E6%9E%90%E8%A7%86%E5%9B%BE-sys-schema"><span class="toc-number">7.9.</span> <span class="toc-text">9. MySQL 监控分析视图 - sys schema</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-Sys-schema-%E8%A7%86%E5%9B%BE%E6%91%98%E8%A6%81"><span class="toc-number">7.9.1.</span> <span class="toc-text">9.1 Sys schema 视图摘要</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-Sys-schema-%E8%A7%86%E5%9B%BE%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.9.2.</span> <span class="toc-text">9.2 Sys schema 视图使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">八、索引优化与查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87"><span class="toc-number">8.1.</span> <span class="toc-text">1. 数据准备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%BB%BA%E8%A1%A8"><span class="toc-number">8.1.1.</span> <span class="toc-text">1.1 建表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">8.1.2.</span> <span class="toc-text">1.2 设置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.3.</span> <span class="toc-text">1.3 创建函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">8.1.4.</span> <span class="toc-text">1.4 创建存储过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E8%B0%83%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">8.1.5.</span> <span class="toc-text">1.5 调用存储过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-%E5%88%A0%E9%99%A4%E6%9F%90%E8%A1%A8%E4%B8%8A%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">8.1.6.</span> <span class="toc-text">1.6 删除某表上的索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%A1%88%E4%BE%8B"><span class="toc-number">8.2.</span> <span class="toc-text">2. 索引失效案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%85%A8%E5%80%BC%E5%8C%B9%E9%85%8D"><span class="toc-number">8.2.1.</span> <span class="toc-text">2.1 全值匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%9C%80%E4%BD%B3%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="toc-number">8.2.2.</span> <span class="toc-text">2.2 最佳左前缀法则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E4%B8%BB%E9%94%AE%E6%8F%92%E5%85%A5%E9%A1%BA%E5%BA%8F"><span class="toc-number">8.2.3.</span> <span class="toc-text">2.3 主键插入顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E8%AE%A1%E7%AE%97%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%88%B0%E5%80%BC%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">8.2.4.</span> <span class="toc-text">2.4 计算、函数、类型转换到值索引失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%88%B0%E5%80%BC%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">8.2.5.</span> <span class="toc-text">2.5 类型转换到值索引失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E8%8C%83%E5%9B%B4%E6%9D%A1%E4%BB%B6%E5%8F%B3%E8%BE%B9%E7%9A%84%E5%88%97%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">8.2.6.</span> <span class="toc-text">2.6 范围条件右边的列索引失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-%E4%B8%8D%E7%AD%89%E4%BA%8E-x3D-%E6%88%96-lt-gt-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">8.2.7.</span> <span class="toc-text">2.7 不等于 (!&#x3D; 或 &lt;&gt;) 索引失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-IS-NULL-%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%8CIS-NOT-NULL-%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">8.2.8.</span> <span class="toc-text">2.8 IS NULL 可以使用索引，IS NOT NULL 无法使用索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-like-%E4%BB%A5%E9%80%9A%E9%85%8D%E7%AC%A6-%E5%BC%80%E5%A4%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">8.2.9.</span> <span class="toc-text">2.9 like 以通配符 % 开头索引失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-10-OR-%E5%89%8D%E5%90%8E%E5%AD%98%E5%9C%A8%E9%9D%9E%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%97%EF%BC%8C%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">8.2.10.</span> <span class="toc-text">2.10 OR 前后存在非索引的列，索引失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BB%9F%E4%B8%80%E4%BD%BF%E7%94%A8-utf8mb4"><span class="toc-number">8.2.11.</span> <span class="toc-text">2.11 数据库和表的字符集统一使用 utf8mb4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-%E5%BB%BA%E8%AE%AE"><span class="toc-number">8.2.12.</span> <span class="toc-text">2.12 建议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">8.3.</span> <span class="toc-text">3. 关联查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-1"><span class="toc-number">8.3.1.</span> <span class="toc-text">3.1 数据准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E9%87%87%E7%94%A8%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">8.3.2.</span> <span class="toc-text">3.2 采用左外连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E9%87%87%E7%94%A8%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="toc-number">8.3.3.</span> <span class="toc-text">3.3 采用内连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-JOIN-%E8%AF%AD%E5%8F%A5%E5%8E%9F%E7%90%86"><span class="toc-number">8.3.4.</span> <span class="toc-text">3.4 JOIN 语句原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%B0%8F%E7%BB%93"><span class="toc-number">8.3.5.</span> <span class="toc-text">3.5 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">8.4.</span> <span class="toc-text">4. 子查询优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-number">8.5.</span> <span class="toc-text">5. 排序优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-GROUP-BY-%E4%BC%98%E5%8C%96"><span class="toc-number">8.6.</span> <span class="toc-text">6.GROUP BY 优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BC%98%E5%8C%96%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.7.</span> <span class="toc-text">7. 优化分页查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">8.8.</span> <span class="toc-text">8. 优先考虑覆盖索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">8.8.1.</span> <span class="toc-text">8.1 什么是覆盖索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%A9%E5%BC%8A"><span class="toc-number">8.8.2.</span> <span class="toc-text">8.2 覆盖索引的利弊</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%A6%82%E4%BD%95%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">8.9.</span> <span class="toc-text">9. 如何给字符串添加索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">8.10.</span> <span class="toc-text">10. 索引下推</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-%E4%BD%BF%E7%94%A8%E5%89%8D%E5%90%8E%E5%AF%B9%E6%AF%94"><span class="toc-number">8.10.1.</span> <span class="toc-text">10.1 使用前后对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-ICP-%E7%9A%84%E5%BC%80%E5%90%AF-x2F-%E5%85%B3%E9%97%AD"><span class="toc-number">8.10.2.</span> <span class="toc-text">10.2 ICP 的开启&#x2F;关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-ICP-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">8.10.3.</span> <span class="toc-text">10.3 ICP 使用案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%AD-ICP-%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">8.10.4.</span> <span class="toc-text">10.4 开启和关闭 ICP 的性能对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-ICP-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">8.10.5.</span> <span class="toc-text">10.5 ICP 的使用条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">8.11.</span> <span class="toc-text">11. 其他查询优化策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-EXISTS-%E5%92%8C-IN-%E7%9A%84%E5%8C%BA%E5%88%86"><span class="toc-number">8.11.1.</span> <span class="toc-text">11.1 EXISTS 和 IN 的区分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-COUNT-%E4%B8%8E-COUNT-%E5%85%B7%E4%BD%93%E5%AD%97%E6%AE%B5-%E6%95%88%E7%8E%87"><span class="toc-number">8.11.2.</span> <span class="toc-text">11.2 COUNT(*) 与 COUNT(具体字段) 效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-%E5%85%B3%E4%BA%8E-SELECT"><span class="toc-number">8.11.3.</span> <span class="toc-text">11.3 关于 SELECT(*)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-LIMIT-1-%E5%AF%B9%E4%BC%98%E5%8C%96%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">8.11.4.</span> <span class="toc-text">11.4 LIMIT 1 对优化的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-5-%E5%A4%9A%E4%BD%BF%E7%94%A8-COMMIT"><span class="toc-number">8.11.5.</span> <span class="toc-text">11.5 多使用 COMMIT</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%B7%98%E5%AE%9D%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%9A%84%EF%BC%9F"><span class="toc-number">8.12.</span> <span class="toc-text">12. 淘宝数据库，主键如何设计的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-%E8%87%AA%E5%A2%9E-ID-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.12.1.</span> <span class="toc-text">12.1 自增 ID 的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-%E4%B8%9A%E5%8A%A1%E5%AD%97%E6%AE%B5%E5%81%9A%E4%B8%BB%E9%94%AE"><span class="toc-number">8.12.2.</span> <span class="toc-text">12.2 业务字段做主键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-%E6%B7%98%E5%AE%9D%E7%9A%84%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.12.3.</span> <span class="toc-text">12.3 淘宝的主键设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-%E6%8E%A8%E8%8D%90%E7%9A%84%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.12.4.</span> <span class="toc-text">12.4 推荐的主键设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-number">9.</span> <span class="toc-text">九、数据库的设计规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.1.</span> <span class="toc-text">1. 为什么需要数据库设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%8C%83%E5%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">2. 范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E8%8C%83%E5%BC%8F%E7%AE%80%E4%BB%8B"><span class="toc-number">9.2.1.</span> <span class="toc-text">2.1 范式简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E8%8C%83%E5%BC%8F%E9%83%BD%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B"><span class="toc-number">9.2.2.</span> <span class="toc-text">2.2 范式都包括哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E9%94%AE%E5%92%8C%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">9.2.3.</span> <span class="toc-text">2.3 键和相关属性的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F-1st-NF"><span class="toc-number">9.2.4.</span> <span class="toc-text">2.4 第一范式 (1st NF)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F-2nd-NF"><span class="toc-number">9.2.5.</span> <span class="toc-text">2.5 第二范式 (2nd NF)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F-3rd-NF"><span class="toc-number">9.2.6.</span> <span class="toc-text">2.6 第三范式 (3rd NF)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-%E5%B0%8F%E7%BB%93"><span class="toc-number">9.2.7.</span> <span class="toc-text">2.7 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%8D%E8%8C%83%E5%BC%8F%E5%8C%96"><span class="toc-number">9.3.</span> <span class="toc-text">3. 反范式化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">9.3.1.</span> <span class="toc-text">3.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-number">9.3.2.</span> <span class="toc-text">3.2 应用举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%8F%8D%E8%8C%83%E5%BC%8F%E7%9A%84%E6%96%B0%E9%97%AE%E9%A2%98"><span class="toc-number">9.3.3.</span> <span class="toc-text">3.3 反范式的新问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E5%8F%8D%E8%8C%83%E5%BC%8F%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.3.4.</span> <span class="toc-text">3.4 反范式的适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-BCNF-%E5%B7%B4%E6%96%AF%E8%8C%83%E5%BC%8F"><span class="toc-number">9.4.</span> <span class="toc-text">4. BCNF (巴斯范式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F"><span class="toc-number">9.5.</span> <span class="toc-text">5. 第四范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%AC%AC%E4%BA%94%E8%8C%83%E5%BC%8F"><span class="toc-number">9.6.</span> <span class="toc-text">6. 第五范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-ER-%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.7.</span> <span class="toc-text">7. ER 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-ER-%E6%A8%A1%E5%9E%8B%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E8%A6%81%E7%B4%A0%EF%BC%9F"><span class="toc-number">9.7.1.</span> <span class="toc-text">7.1 ER 模型包括哪些要素？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E5%85%B3%E7%B3%BB%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.7.2.</span> <span class="toc-text">7.2 关系的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E5%BB%BA%E6%A8%A1%E5%88%86%E6%9E%90"><span class="toc-number">9.7.3.</span> <span class="toc-text">7.3 建模分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-ER-%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%86%E5%8C%96"><span class="toc-number">9.7.4.</span> <span class="toc-text">7.4 ER 模型的细化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-ER-%E6%A8%A1%E5%9E%8B%E5%9B%BE%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">9.7.5.</span> <span class="toc-text">7.5 ER 模型图转换成数据表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">9.8.</span> <span class="toc-text">8. 数据表的设计原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1%E7%BC%96%E5%86%99%E5%BB%BA%E8%AE%AE"><span class="toc-number">9.9.</span> <span class="toc-text">9. 数据库对象编写建议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-%E5%85%B3%E4%BA%8E%E5%BA%93"><span class="toc-number">9.9.1.</span> <span class="toc-text">9.1 关于库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-%E5%85%B3%E4%BA%8E%E8%A1%A8%E3%80%81%E5%88%97"><span class="toc-number">9.9.2.</span> <span class="toc-text">9.2 关于表、列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95"><span class="toc-number">9.9.3.</span> <span class="toc-text">9.3 关于索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-SQL-%E7%BC%96%E5%86%99"><span class="toc-number">9.9.4.</span> <span class="toc-text">9.4 SQL 编写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E5%AE%83%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5"><span class="toc-number">10.</span> <span class="toc-text">十、数据库其它调优策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98%E7%9A%84%E6%8E%AA%E6%96%BD"><span class="toc-number">10.1.</span> <span class="toc-text">1. 数据库调优的措施</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E8%B0%83%E4%BC%98%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">10.1.1.</span> <span class="toc-text">1.1 调优的目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E8%B0%83%E4%BC%98%E9%97%AE%E9%A2%98"><span class="toc-number">10.1.2.</span> <span class="toc-text">1.2 如何定位调优问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E8%B0%83%E4%BC%98%E7%9A%84%E7%BB%B4%E5%BA%A6%E5%92%8C%E6%AD%A5%E9%AA%A4"><span class="toc-number">10.1.3.</span> <span class="toc-text">1.3 调优的维度和步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%98%E5%8C%96-MySQL-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">10.2.</span> <span class="toc-text">2. 优化 MySQL 服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E4%BB%B6"><span class="toc-number">10.2.1.</span> <span class="toc-text">2.1 优化服务器硬件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E4%BC%98%E5%8C%96-MySQL-%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">10.2.2.</span> <span class="toc-text">2.2 优化 MySQL 的参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84"><span class="toc-number">10.3.</span> <span class="toc-text">3. 优化数据库结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%8B%86%E5%88%86%E8%A1%A8%EF%BC%9A%E5%86%B7%E7%83%AD%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB"><span class="toc-number">10.3.1.</span> <span class="toc-text">3.1 拆分表：冷热数据分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%A2%9E%E5%8A%A0%E4%B8%AD%E9%97%B4%E8%A1%A8"><span class="toc-number">10.3.2.</span> <span class="toc-text">3.2 增加中间表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%A2%9E%E5%8A%A0%E5%86%97%E4%BD%99%E5%AD%97%E6%AE%B5"><span class="toc-number">10.3.3.</span> <span class="toc-text">3.3 增加冗余字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E4%BC%98%E5%8C%96%E6%8F%92%E5%85%A5%E8%AE%B0%E5%BD%95%E7%9A%84%E9%80%9F%E5%BA%A6"><span class="toc-number">10.3.4.</span> <span class="toc-text">3.5 优化插入记录的速度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E4%BD%BF%E7%94%A8%E9%9D%9E%E7%A9%BA%E7%BA%A6%E6%9D%9F"><span class="toc-number">10.3.5.</span> <span class="toc-text">3.6 使用非空约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-%E5%88%86%E6%9E%90%E8%A1%A8%E3%80%81%E6%A3%80%E6%9F%A5%E8%A1%A8%E4%B8%8E%E4%BC%98%E5%8C%96%E8%A1%A8"><span class="toc-number">10.3.6.</span> <span class="toc-text">3.7 分析表、检查表与优化表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-%E5%B0%8F%E7%BB%93"><span class="toc-number">10.3.7.</span> <span class="toc-text">3.8 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%A7%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="toc-number">10.4.</span> <span class="toc-text">4. 大表优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E9%99%90%E5%AE%9A%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-number">10.4.1.</span> <span class="toc-text">4.1 限定查询的范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E8%AF%BB-x2F-%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">10.4.2.</span> <span class="toc-text">4.2 读&#x2F;写分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86"><span class="toc-number">10.4.3.</span> <span class="toc-text">4.3 垂直拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86"><span class="toc-number">10.4.4.</span> <span class="toc-text">4.4 水平拆分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%B6%E5%AE%83%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5"><span class="toc-number">10.5.</span> <span class="toc-text">5. 其它调优策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%AD%E5%8F%A5%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86"><span class="toc-number">10.5.1.</span> <span class="toc-text">5.1 服务器语句超时处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E5%88%9B%E5%BB%BA%E5%85%A8%E5%B1%80%E9%80%9A%E7%94%A8%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">10.5.2.</span> <span class="toc-text">5.2 创建全局通用表空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-MySQL-8-0-%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E9%9A%90%E8%97%8F%E7%B4%A2%E5%BC%95%E5%AF%B9%E8%B0%83%E4%BC%98%E7%9A%84%E5%B8%AE%E5%8A%A9"><span class="toc-number">10.5.3.</span> <span class="toc-text">5.3 MySQL 8.0 新特性：隐藏索引对调优的帮助</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">11.</span> <span class="toc-text">十一、事务基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">11.1.</span> <span class="toc-text">1. 数据库事务概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5"><span class="toc-number">11.1.1.</span> <span class="toc-text">1.1 存储引擎支持情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">11.1.2.</span> <span class="toc-text">1.2 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E4%BA%8B%E7%89%A9%E7%9A%84-ACID-%E7%89%B9%E6%80%A7"><span class="toc-number">11.1.3.</span> <span class="toc-text">1.3 事物的 ACID 特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">11.1.4.</span> <span class="toc-text">1.4 事务的状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8B%E7%89%A9"><span class="toc-number">11.2.</span> <span class="toc-text">2. 如何使用事物</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%98%BE%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">11.2.1.</span> <span class="toc-text">2.1 显式事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E9%9A%90%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">11.2.2.</span> <span class="toc-text">2.2 隐式事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E9%9A%90%E5%BC%8F%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">11.2.3.</span> <span class="toc-text">2.3 隐式提交数据的情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">11.3.</span> <span class="toc-text">3. 事务隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-2"><span class="toc-number">11.3.1.</span> <span class="toc-text">3.1 数据准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">11.3.2.</span> <span class="toc-text">3.2 数据并发问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-SQL-%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">11.3.3.</span> <span class="toc-text">3.3 SQL 中的四种隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-MySQL-%E6%94%AF%E6%8C%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">11.3.4.</span> <span class="toc-text">3.4 MySQL 支持的四种隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">11.3.5.</span> <span class="toc-text">3.5 如何设置事务的隔离级别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81MySQL-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="toc-number">12.</span> <span class="toc-text">十二、MySQL 事务日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-redo-%E6%97%A5%E5%BF%97"><span class="toc-number">12.1.</span> <span class="toc-text">1. redo 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-REDO-%E6%97%A5%E5%BF%97"><span class="toc-number">12.1.1.</span> <span class="toc-text">1.1 为什么需要 REDO 日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-REDO-%E6%97%A5%E5%BF%97%E7%9A%84%E5%A5%BD%E5%A4%84%E3%80%81%E7%89%B9%E7%82%B9"><span class="toc-number">12.1.2.</span> <span class="toc-text">1.2 REDO 日志的好处、特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-redo-%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">12.1.3.</span> <span class="toc-text">1.3 redo 的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-redo-%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">12.1.4.</span> <span class="toc-text">1.4 redo 的整体流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-redo-log-%E7%9A%84%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5"><span class="toc-number">12.1.5.</span> <span class="toc-text">1.5 redo log 的刷盘策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-%E4%B8%8D%E5%90%8C%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5%E6%BC%94%E7%A4%BA"><span class="toc-number">12.1.6.</span> <span class="toc-text">1.6 不同刷盘策略演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-%E5%86%99%E5%85%A5-redo-log-buffer-%E8%BF%87%E7%A8%8B"><span class="toc-number">12.1.7.</span> <span class="toc-text">1.7 写入 redo log buffer 过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-redo-log-file"><span class="toc-number">12.1.8.</span> <span class="toc-text">1.8 redo log file</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-redo-log-%E5%B0%8F%E7%BB%93"><span class="toc-number">12.1.9.</span> <span class="toc-text">1.9 redo log 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Undo-%E6%97%A5%E5%BF%97"><span class="toc-number">12.2.</span> <span class="toc-text">2. Undo 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Undo-%E6%97%A5%E5%BF%97"><span class="toc-number">12.2.1.</span> <span class="toc-text">2.1 如何理解 Undo 日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Undo-%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">12.2.2.</span> <span class="toc-text">2.2 Undo 日志的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Undo-%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">12.2.3.</span> <span class="toc-text">2.3 Undo 的存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-Undo-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.2.4.</span> <span class="toc-text">2.4 Undo 的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-Undo-log-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">12.2.5.</span> <span class="toc-text">2.5 Undo log 的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E5%B0%8F%E7%BB%93"><span class="toc-number">12.2.6.</span> <span class="toc-text">2.6 小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E9%94%81"><span class="toc-number">13.</span> <span class="toc-text">十三、锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">13.1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-MySQL%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E8%AE%BF%E9%97%AE%E7%9B%B8%E5%90%8C%E8%AE%B0%E5%BD%95"><span class="toc-number">13.2.</span> <span class="toc-text">2. MySQL并发事务访问相同记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E8%AF%BB-%E8%AF%BB%E6%83%85%E5%86%B5"><span class="toc-number">13.2.1.</span> <span class="toc-text">2.1 读-读情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%86%99-%E5%86%99%E6%83%85%E5%86%B5"><span class="toc-number">13.2.2.</span> <span class="toc-text">2.2 写-写情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E8%AF%BB-%E5%86%99%E6%88%96%E5%86%99-%E8%AF%BB%E6%83%85%E5%86%B5"><span class="toc-number">13.2.3.</span> <span class="toc-text">2.3 读-写或写-读情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">13.2.4.</span> <span class="toc-text">2.4 并发问题的解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%94%81%E7%9A%84%E4%B8%8D%E5%90%8C%E8%A7%92%E5%BA%A6%E5%88%86%E7%B1%BB"><span class="toc-number">13.3.</span> <span class="toc-text">3. 锁的不同角度分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%92%E5%88%86%EF%BC%9A%E8%AF%BB%E9%94%81%E3%80%81%E5%86%99%E9%94%81"><span class="toc-number">13.3.1.</span> <span class="toc-text">3.1 从数据操作的类型划分：读锁、写锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%92%E5%88%86%EF%BC%9A%E8%A1%A8%E7%BA%A7%E9%94%81%E3%80%81%E9%A1%B5%E7%BA%A7%E9%94%81%E3%80%81%E8%A1%8C%E9%94%81"><span class="toc-number">13.3.2.</span> <span class="toc-text">3.2 从数据操作的粒度划分：表级锁、页级锁、行锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E4%BB%8E%E5%AF%B9%E5%BE%85%E9%94%81%E7%9A%84%E6%80%81%E5%BA%A6%E5%88%92%E5%88%86-%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">13.3.3.</span> <span class="toc-text">3.3 从对待锁的态度划分:乐观锁、悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E6%8C%89%E5%8A%A0%E9%94%81%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%92%E5%88%86%EF%BC%9A%E6%98%BE%E5%BC%8F%E9%94%81%E3%80%81%E9%9A%90%E5%BC%8F%E9%94%81"><span class="toc-number">13.3.4.</span> <span class="toc-text">3.4 按加锁的方式划分：显式锁、隐式锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%85%B6%E5%AE%83%E9%94%81%E4%B9%8B%EF%BC%9A%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">13.3.5.</span> <span class="toc-text">3.5 其它锁之：全局锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E5%85%B6%E5%AE%83%E9%94%81%E4%B9%8B%EF%BC%9A%E6%AD%BB%E9%94%81"><span class="toc-number">13.3.6.</span> <span class="toc-text">3.6 其它锁之：死锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%94%81%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">13.4.</span> <span class="toc-text">4. 锁的内存结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%94%81%E7%9B%91%E6%8E%A7"><span class="toc-number">13.5.</span> <span class="toc-text">5. 锁监控</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">14.</span> <span class="toc-text">十四、多版本并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-MVCC"><span class="toc-number">14.1.</span> <span class="toc-text">1. 什么是 MVCC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BF%AB%E7%85%A7%E8%AF%BB%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">14.2.</span> <span class="toc-text">2. 快照读与当前读</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="toc-number">14.2.1.</span> <span class="toc-text">2.1 快照读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">14.2.2.</span> <span class="toc-text">2.2 当前读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%8D%E4%B9%A0"><span class="toc-number">14.3.</span> <span class="toc-text">3. 复习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%86%8D%E8%B0%88%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">14.3.1.</span> <span class="toc-text">3.1 再谈隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5%E3%80%81Undo-Log%E7%89%88%E6%9C%AC%E9%93%BE"><span class="toc-number">14.3.2.</span> <span class="toc-text">3.2 隐藏字段、Undo Log版本链</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8BReadView"><span class="toc-number">14.4.</span> <span class="toc-text">4. MVCC实现原理之ReadView</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E4%BB%80%E4%B9%88%E6%98%AFReadView"><span class="toc-number">14.4.1.</span> <span class="toc-text">4.1 什么是ReadView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">14.4.2.</span> <span class="toc-text">4.2 设计思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-ReadView%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">14.4.3.</span> <span class="toc-text">4.3 ReadView的规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-MVCC%E6%95%B4%E4%BD%93%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">14.4.4.</span> <span class="toc-text">4.4 MVCC整体操作流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">14.5.</span> <span class="toc-text">5 举例说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-READ-COMMITTED-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B"><span class="toc-number">14.5.1.</span> <span class="toc-text">5.1 READ COMMITTED 隔离级别下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-REPEATABLE-READ%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B"><span class="toc-number">14.5.2.</span> <span class="toc-text">5.2 REPEATABLE READ隔离级别下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB"><span class="toc-number">14.5.3.</span> <span class="toc-text">5.3 如何解决幻读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%80%BB%E7%BB%93"><span class="toc-number">14.6.</span> <span class="toc-text">6. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A5%E5%BF%97"><span class="toc-number">15.</span> <span class="toc-text">十五、其他数据库日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-MySQL%E6%94%AF%E6%8C%81%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-number">15.1.</span> <span class="toc-text">1. MySQL支持的日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">15.1.1.</span> <span class="toc-text">1.1 日志类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%97%A5%E5%BF%97%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">15.1.2.</span> <span class="toc-text">1.2 日志的弊端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%EF%BC%88show-query-log%EF%BC%89"><span class="toc-number">15.2.</span> <span class="toc-text">2. 慢查询日志（show query log）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%9A%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%EF%BC%88general-query-log%EF%BC%89"><span class="toc-number">15.3.</span> <span class="toc-text">3. 通用查询日志（general query log）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF"><span class="toc-number">15.3.1.</span> <span class="toc-text">3.1 问题场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%8A%B6%E6%80%81"><span class="toc-number">15.3.2.</span> <span class="toc-text">3.2 查看当前状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%90%AF%E5%8A%A8%E6%97%A5%E5%BF%97"><span class="toc-number">15.3.3.</span> <span class="toc-text">3.3 启动日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97"><span class="toc-number">15.3.4.</span> <span class="toc-text">3.4 查看日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%81%9C%E6%AD%A2%E6%97%A5%E5%BF%97"><span class="toc-number">15.3.5.</span> <span class="toc-text">3.5 停止日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E5%88%A0%E9%99%A4-%E5%88%B7%E6%96%B0%E6%97%A5%E5%BF%97"><span class="toc-number">15.3.6.</span> <span class="toc-text">3.6 删除\刷新日志</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97-error-log"><span class="toc-number">15.4.</span> <span class="toc-text">4. 错误日志(error log)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%90%AF%E5%8A%A8%E6%97%A5%E5%BF%97"><span class="toc-number">15.4.1.</span> <span class="toc-text">4.1 启动日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97"><span class="toc-number">15.4.2.</span> <span class="toc-text">4.2 查看日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E5%88%A0%E9%99%A4-%E5%88%B7%E6%96%B0%E6%97%A5%E5%BF%97"><span class="toc-number">15.4.3.</span> <span class="toc-text">4.3 删除\刷新日志</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97-bin-log"><span class="toc-number">15.5.</span> <span class="toc-text">5. 二进制日志(bin log)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5"><span class="toc-number">15.5.1.</span> <span class="toc-text">5.1 查看默认情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E6%97%A5%E5%BF%97%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">15.5.2.</span> <span class="toc-text">5.2 日志参数设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97"><span class="toc-number">15.5.3.</span> <span class="toc-text">5.3 查看日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="toc-number">15.5.4.</span> <span class="toc-text">5.4 使用日志恢复数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E5%88%A0%E9%99%A4%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97"><span class="toc-number">15.5.5.</span> <span class="toc-text">5.5 删除二进制日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-%E5%85%B6%E5%AE%83%E5%9C%BA%E6%99%AF"><span class="toc-number">15.5.6.</span> <span class="toc-text">5.6 其它场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%86%8D%E8%B0%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97"><span class="toc-number">15.6.</span> <span class="toc-text">6. 再谈二进制日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">15.6.1.</span> <span class="toc-text">6.1 写入机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-binlog%E4%B8%8Eredolog%E5%AF%B9%E6%AF%94"><span class="toc-number">15.6.2.</span> <span class="toc-text">6.2 binlog与redolog对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">15.6.3.</span> <span class="toc-text">6.3 两阶段提交</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97-relay-log"><span class="toc-number">15.7.</span> <span class="toc-text">7. 中继日志(relay log)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">15.7.1.</span> <span class="toc-text">7.1 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E6%9F%A5%E7%9C%8B%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97"><span class="toc-number">15.7.2.</span> <span class="toc-text">7.2 查看中继日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E6%81%A2%E5%A4%8D%E7%9A%84%E5%85%B8%E5%9E%8B%E9%94%99%E8%AF%AF"><span class="toc-number">15.7.3.</span> <span class="toc-text">7.3 恢复的典型错误</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">16.</span> <span class="toc-text">十六、主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">16.1.</span> <span class="toc-text">1. 主从复制概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E8%83%BD%E5%8A%9B"><span class="toc-number">16.1.1.</span> <span class="toc-text">1.1 如何提升数据库并发能力</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">16.1.2.</span> <span class="toc-text">1.2 主从复制的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">16.2.</span> <span class="toc-text">2. 主从复制的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90"><span class="toc-number">16.2.1.</span> <span class="toc-text">2.1 原理剖析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">16.2.2.</span> <span class="toc-text">2.2 复制的基本原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%80%E4%B8%BB%E4%B8%80%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%90%AD%E5%BB%BA"><span class="toc-number">16.3.</span> <span class="toc-text">3. 一主一从架构搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">16.3.1.</span> <span class="toc-text">3.1 主机配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E4%BB%8E%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">16.3.2.</span> <span class="toc-text">3.2 从机配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E4%B8%BB%E6%9C%BA%EF%BC%9A%E5%BB%BA%E7%AB%8B%E8%B4%A6%E6%88%B7%E5%B9%B6%E6%8E%88%E6%9D%83"><span class="toc-number">16.3.3.</span> <span class="toc-text">3.3 主机：建立账户并授权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E4%BB%8E%E6%9C%BA%EF%BC%9A%E9%85%8D%E7%BD%AE%E9%9C%80%E8%A6%81%E5%A4%8D%E5%88%B6%E7%9A%84%E4%B8%BB%E6%9C%BA"><span class="toc-number">16.3.4.</span> <span class="toc-text">3.4 从机：配置需要复制的主机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E6%B5%8B%E8%AF%95"><span class="toc-number">16.3.5.</span> <span class="toc-text">3.5 测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E5%81%9C%E6%AD%A2%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">16.3.6.</span> <span class="toc-text">3.6 停止主从同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-%E5%90%8E%E7%BB%AD"><span class="toc-number">16.3.7.</span> <span class="toc-text">3.7 后续</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">16.4.</span> <span class="toc-text">4. 同步数据一致性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E7%90%86%E8%A7%A3%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98"><span class="toc-number">16.4.1.</span> <span class="toc-text">4.1 理解主从延迟问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0"><span class="toc-number">16.4.2.</span> <span class="toc-text">4.2 主从延迟问题原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F"><span class="toc-number">16.4.3.</span> <span class="toc-text">4.3 如何减少主从延迟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">16.4.4.</span> <span class="toc-text">4.4 如何解决一致性问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%9F%A5%E8%AF%86%E5%BB%B6%E4%BC%B8"><span class="toc-number">16.5.</span> <span class="toc-text">5. 知识延伸</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%83%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="toc-number"></span> <span class="toc-text">十七、数据库备份与恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%89%A9%E7%90%86%E5%A4%87%E4%BB%BD%E4%B8%8E%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD"><span class="toc-number">0.1.</span> <span class="toc-text">1. 物理备份与逻辑备份</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-MySQLdump%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD"><span class="toc-number">0.2.</span> <span class="toc-text">2. MySQLdump实现逻辑备份</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%A4%87%E4%BB%BD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">0.2.1.</span> <span class="toc-text">2.1 备份一个数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%A4%87%E4%BB%BD%E5%85%A8%E9%83%A8%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">0.2.2.</span> <span class="toc-text">2.2 备份全部数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%A4%87%E4%BB%BD%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">0.2.3.</span> <span class="toc-text">2.3 备份部分数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E5%A4%87%E4%BB%BD%E9%83%A8%E5%88%86%E8%A1%A8"><span class="toc-number">0.2.4.</span> <span class="toc-text">2.4 备份部分表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E5%A4%87%E4%BB%BD%E5%8D%95%E8%A1%A8%E7%9A%84%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE"><span class="toc-number">0.2.5.</span> <span class="toc-text">2.5 备份单表的部分数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E6%8E%92%E9%99%A4%E6%9F%90%E4%BA%9B%E8%A1%A8%E7%9A%84%E5%A4%87%E4%BB%BD"><span class="toc-number">0.2.6.</span> <span class="toc-text">2.6 排除某些表的备份</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-%E5%8F%AA%E5%A4%87%E4%BB%BD%E7%BB%93%E6%9E%84%E6%88%96%E5%8F%AA%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE"><span class="toc-number">0.2.7.</span> <span class="toc-text">2.7 只备份结构或只备份数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-%E5%A4%87%E4%BB%BD%E4%B8%AD%E5%8C%85%E5%90%AB%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E4%BA%8B%E4%BB%B6"><span class="toc-number">0.2.8.</span> <span class="toc-text">2.8 备份中包含存储过程、函数、事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-mysqldump%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9"><span class="toc-number">0.2.9.</span> <span class="toc-text">2.9 mysqldump常用选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-MySQL%E5%91%BD%E4%BB%A4%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="toc-number">0.3.</span> <span class="toc-text">3. MySQL命令恢复数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%8D%95%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%AD%E6%81%A2%E5%A4%8D%E5%8D%95%E5%BA%93"><span class="toc-number">0.3.1.</span> <span class="toc-text">3.1 单库备份中恢复单库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%85%A8%E9%87%8F%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D"><span class="toc-number">0.3.2.</span> <span class="toc-text">3.2 全量备份恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E4%BB%8E%E5%85%A8%E9%87%8F%E5%A4%87%E4%BB%BD%E4%B8%AD%E6%81%A2%E5%A4%8D%E5%8D%95%E5%BA%93"><span class="toc-number">0.3.3.</span> <span class="toc-text">3.3 从全量备份中恢复单库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E4%BB%8E%E5%8D%95%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%AD%E6%81%A2%E5%A4%8D%E5%8D%95%E8%A1%A8"><span class="toc-number">0.3.4.</span> <span class="toc-text">3.4 从单库备份中恢复单表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%89%A9%E7%90%86%E5%A4%87%E4%BB%BD%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%A4%8D%E5%88%B6%E6%95%B4%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">0.4.</span> <span class="toc-text">4. 物理备份：直接复制整个数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%89%A9%E7%90%86%E6%81%A2%E5%A4%8D%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%A4%8D%E5%88%B6%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%AE%E5%BD%95"><span class="toc-number">0.5.</span> <span class="toc-text">5. 物理恢复：直接复制到数据库目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%A1%A8%E7%9A%84%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%AF%BC%E5%87%BA"><span class="toc-number">0.6.</span> <span class="toc-text">6. 表的导入与导出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E8%A1%A8%E7%9A%84%E5%AF%BC%E5%87%BA"><span class="toc-number">0.6.1.</span> <span class="toc-text">6.1 表的导出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E8%A1%A8%E7%9A%84%E5%AF%BC%E5%85%A5"><span class="toc-number">0.6.2.</span> <span class="toc-text">6.2 表的导入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB"><span class="toc-number">0.7.</span> <span class="toc-text">7. 数据库迁移</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">0.7.1.</span> <span class="toc-text">7.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88"><span class="toc-number">0.7.2.</span> <span class="toc-text">7.2 迁移方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E8%BF%81%E7%A7%BB%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">0.7.3.</span> <span class="toc-text">7.3 迁移注意点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-%E8%BF%81%E7%A7%BB%E5%B0%8F%E7%BB%93"><span class="toc-number">0.7.4.</span> <span class="toc-text">7.4 迁移小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">0.8.</span> <span class="toc-text">8. 误删数据库处理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-delete%EF%BC%9A%E8%AF%AF%E5%88%A0%E8%A1%8C"><span class="toc-number">0.8.1.</span> <span class="toc-text">8.1 delete：误删行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-truncate-x2F-drop%EF%BC%9A%E8%AF%AF%E5%88%A0%E5%BA%93-x2F-%E8%A1%A8"><span class="toc-number">0.8.2.</span> <span class="toc-text">8.2 truncate&#x2F;drop：误删库&#x2F;表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-%E9%A2%84%E9%98%B2%E4%BD%BF%E7%94%A8truncate-x2F-drop%E8%AF%AF%E5%88%A0%E5%BA%93-x2F-%E8%A1%A8"><span class="toc-number">0.8.3.</span> <span class="toc-text">8.3 预防使用truncate &#x2F;drop误删库&#x2F;表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-rm%EF%BC%9A%E8%AF%AF%E5%88%A0MySQL%E5%AE%9E%E4%BE%8B"><span class="toc-number">0.8.4.</span> <span class="toc-text">8.4 rm：误删MySQL实例</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Zhang Jian</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 570px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 480px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(http://1.117.162.142:9000/blog/cover1.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/DXC-实习/&quot;);" href="javascript:void(0);">DXC 实习</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">Spring 全家桶</span></li><li class="categoryBar-list-item" style="background:url(http://1.117.162.142:9000/blog/cover2.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Linux/&quot;);" href="javascript:void(0);">Linux</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">Linux 操作系统</span></li><li class="categoryBar-list-item" style="background:url(http://1.117.162.142:9000/blog/cover3.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Spring/&quot;);" href="javascript:void(0);">Spring</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">计算机网络知识体系</span></li><li class="categoryBar-list-item" style="background:url(http://1.117.162.142:9000/blog/cover4.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机网络/&quot;);" href="javascript:void(0);">计算机网络</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">其他文档集合</span></li><li class="categoryBar-list-item" style="background:url(http://1.117.162.142:9000/blog/cover5.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/其他/&quot;);" href="javascript:void(0);">其他</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">Java 知识</span></li><li class="categoryBar-list-item" style="background:url(http://1.117.162.142:9000/blog/cover6.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java/&quot;);" href="javascript:void(0);">Java</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr">数据结构与算法</span></li><li class="categoryBar-list-item" style="background:url(http://1.117.162.142:9000/blog/cover1.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据结构与算法/&quot;);" href="javascript:void(0);">数据结构与算法</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">海量中间件</span></li><li class="categoryBar-list-item" style="background:url(http://1.117.162.142:9000/blog/cover2.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/中间件/&quot;);" href="javascript:void(0);">中间件</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">关系型数据库和非关系型数据库</span></li><li class="categoryBar-list-item" style="background:url(http://1.117.162.142:9000/blog/cover3.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/操作系统/&quot;);" href="javascript:void(0);">操作系统</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">操作系统知识</span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据库/&quot;);" href="javascript:void(0);">数据库</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'd8ef7a65db7c4006a56ac333e3160913';
  var gaud_map_key = 'b08b224a212eea586a32bbcc5605bbe4';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/11/28/kafka/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://1.117.162.142:9000/blog/cover.jpeg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-28</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/11/28/kafka/&quot;);" href="javascript:void(0);" alt="">Kafka</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/11/28/kafka/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/about/'|| '/about/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar.fomal.cc/api?zhangjianGorilla",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'zhangjianGorilla')
    }
  </script><!-- hexo injector body_end end --></body></html>