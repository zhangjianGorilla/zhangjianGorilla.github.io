<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>MySQL 进阶 | 个人文档</title><meta name="author" content="Zhang Jian"><meta name="copyright" content="Zhang Jian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="用户与权限管理用户管理MySQL 用户可以分为普通 用户和 root 用户。root 用户是超级管理员，拥有所有权限，包括创建用户、删除用户和修改用户的密码等管理权限；普通用户只拥有被授予的各种权限。 MySQL 提供了许多语句用来管理用户账号，这些语句可以用来管理包括登录和退出 MySQL 服务器、创建用户、删除用户、密码管理和权限管理等内容。 登录 MySQL 服务器启动 MySQL 服务器后">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL 进阶">
<meta property="og:url" content="http://example.com/2022/10/31/mysql-advanced/index.html">
<meta property="og:site_name" content="个人文档">
<meta property="og:description" content="用户与权限管理用户管理MySQL 用户可以分为普通 用户和 root 用户。root 用户是超级管理员，拥有所有权限，包括创建用户、删除用户和修改用户的密码等管理权限；普通用户只拥有被授予的各种权限。 MySQL 提供了许多语句用来管理用户账号，这些语句可以用来管理包括登录和退出 MySQL 服务器、创建用户、删除用户、密码管理和权限管理等内容。 登录 MySQL 服务器启动 MySQL 服务器后">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2022-10-31T01:58:40.000Z">
<meta property="article:modified_time" content="2022-12-14T03:32:44.028Z">
<meta property="article:author" content="Zhang Jian">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/10/31/mysql-advanced/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL 进阶',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-14 11:32:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/xxx.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">个人文档</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">MySQL 进阶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-31T01:58:40.000Z" title="发表于 2022-10-31 09:58:40">2022-10-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-14T03:32:44.028Z" title="更新于 2022-12-14 11:32:44">2022-12-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">114.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>383分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL 进阶"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="用户与权限管理"><a href="#用户与权限管理" class="headerlink" title="用户与权限管理"></a>用户与权限管理</h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>MySQL 用户可以分为普通 用户和 root 用户。root 用户是超级管理员，拥有所有权限，包括创建用户、删除用户和修改用户的密码等管理权限；普通用户只拥有被授予的各种权限。</p>
<p>MySQL 提供了许多语句用来管理用户账号，这些语句可以用来管理包括登录和退出 MySQL 服务器、创建用户、删除用户、密码管理和权限管理等内容。</p>
<h4 id="登录-MySQL-服务器"><a href="#登录-MySQL-服务器" class="headerlink" title="登录 MySQL 服务器"></a>登录 MySQL 服务器</h4><p>启动 MySQL 服务器后，可以通过 mysql 命令来登录服务器。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h hostname<span class="operator">|</span>hostIP <span class="operator">-</span>P port <span class="operator">-</span>u username <span class="operator">-</span>p DatabaseName <span class="operator">-</span>e &quot;SQL语句&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-h 参数</code> 后面接主机名或主机 IP，hostname 为主机，hostIP 为主机 IP。</li>
<li><code>-P 参数</code> 后面接 MySQL服务器的端口，通过该参数连接到指定的端口。MySQL 服务的默认端口是 3306，不使用该参数时自动连接到 3306 端口，port 为连接的端口号。</li>
<li><code>-u 参数</code> 后面接用户名，username 为用户名。</li>
<li><code>-p 参数</code> 会提示输入密码。</li>
<li><code>DatabaseName 参数</code> 知名登录到哪一个数据库中。如果没有该参数，就会直接登录到 MySQL 数据库中，然后可以使用 USE 命令来选择数据库。</li>
<li><code>-e 参数</code> 后面可以直接加 SQL 语句。登录 MySQL 服务器以后即可执行这个 SQL 语句，然后退出 MySQL 服务器。</li>
</ul>
<h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><p>在 MySQL 数据库中，官方推荐使用 <code>CREATE USER</code> 语句来创建新用户。MySQL 8 版本移除了 PASSWORD 加密方法，因此不再推荐使用 INSERT 语句直接操作 MySQL 中的 user 表来增加用户。</p>
<p>使用 <code>CREATE USER</code> 语句来创建新用户时，必须拥有 CREATE USER 权限。每添加一个用户，CREATE USER 语句会在 MySQL.user 表中添加一条新记录，但是新创建的账户没有任何权限。如果添加的账户已经存在，CREATE USER 语句就会返回一个错误。</p>
<p>CREATE USER 语句的基本语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> 用户名 [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>][, 用户名 [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>]];</span><br></pre></td></tr></table></figure>

<ul>
<li>用户名参数表示新建用户的账户，由用户 (User) 和 主机名 (Host) 构成；</li>
<li>“[]”表示可选，也就是说，可以指定用户登录时需要密码验证，也可以不指定密码验证，这样用户可以直接登录。不过，不指定密码的方式不安全，不推荐使用。如果指定密码值，这里需要使用 IDENTIFIED BY 指定明文密码值。</li>
<li>CREATE USER 语句可以同时创建多个用户。</li>
</ul>
<h4 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 修改用户名</span><br><span class="line"><span class="keyword">UPDATE</span> mysql.user <span class="keyword">SET</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">USER</span> <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p>在 MySQL 数据库中，可以使用 <code>DROP USER</code> 语句来删除普通用户，也可以直接在 mysql.user 表中删除用户。</p>
<p><strong>方式一：使用 DROP 方式删除 (推荐)</strong></p>
<p>使用 DROP USER 语句来删除用户时，必须拥有 DROP USER 权限。DROP USER 语句的基本语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="keyword">user</span>[, <span class="keyword">user</span>] ...; # 默认删除的是<span class="keyword">user</span>@<span class="operator">%</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="keyword">user</span>@<span class="string">&#x27;host&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其中，user 参数是需要删除的用户，由用户的用户名 (User) 和主机名 (Host) 组成。DROP USER 语句可以同事删除多个用户，各用户之间用逗号隔开。</p>
<p><strong>方式二：使用 DELETE 方式删除</strong></p>
<p>可以使用 DELETE 语句直接将用户的信息从 mysql.user 表中删除，但必须拥有对 mysql.user 表的 DELETE 权限。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mysql.user <span class="keyword">WHERE</span> Host<span class="operator">=</span><span class="string">&#x27;hostname&#x27;</span> <span class="keyword">AND</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;username&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>Host 字段和 User 字段是 user 表的联合主键，因此两个字段的值才能唯一确定一条记录。</p>
<p>执行完 DELETE 命令后要使用 FLUSH 命令来使用户生效，命令如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>:::tip</p>
<p>不推荐通过 <code>DELETE FROM USER u WHERE USER=&#39;&#39;;</code> 进行删除，系统会有残留信息保留。而 <code>DROP user</code> 命令会删除用户以及对应的权限，执行命令 mysql.user 表和 mysql.db 表的相应记录都消失了。</p>
<p>:::</p>
<h4 id="设置当前用户密码"><a href="#设置当前用户密码" class="headerlink" title="设置当前用户密码"></a>设置当前用户密码</h4><p>适用于 root 用户修改自己的密码，以及普通用户登录后修改自己的密码。</p>
<p>root 用户拥有很高的权限，因此必须保证 root 用户的密码安全。root 用户可以通过多种方式来修改密码，使用 ALTER USER 修改用户密码是 MySQL 官方推荐的方式。此外，也可以通过 SET 语句修改密码。由于 MySQL 8 中已移除了 PASSWORD() 函数，因此不再使用 UPDATE 语句直接操作用户表修改密码。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 旧的写法 (MySQL <span class="number">5.7</span> 测试有效)</span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="operator">=</span> PASSWORD(<span class="string">&#x27;密码&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 使用 <span class="keyword">ALTER</span> <span class="keyword">USER</span> 命令来修改当前用户密码 (推荐使用)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">USER</span>() IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;NEW_PASSWORD&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 使用 <span class="keyword">SET</span> 语句来修改当前用户密码，该语句会自动将密码加密后再赋给当前用户</span><br><span class="line"><span class="keyword">SET</span> PASSWORD<span class="operator">=</span><span class="string">&#x27;new_password&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="修改其它用户密码"><a href="#修改其它用户密码" class="headerlink" title="修改其它用户密码"></a>修改其它用户密码</h4><p>root 用户不仅可以修改自己的密码，还可以修改其它普通用户的密码。root 用户登录 MySQL 服务器后，可以通过 ALTER 语句和 SET 语句来修改普通用户的密码。由于 PASSWORD() 函数已移除，因此使用 UPDATE 直接操作用户表的方式已不再使用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 使用 <span class="keyword">ALTER</span> 语句来修改普通用户的密码</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">user</span> [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>][, <span class="keyword">user</span> [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>]];</span><br><span class="line"></span><br><span class="line"># 使用 <span class="keyword">SET</span> 命令来修改普通用户的密码</span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span><span class="operator">=</span><span class="string">&#x27;new_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 使用 <span class="keyword">UPDATE</span> 语句修改普通用户密码 (不推荐)</span><br><span class="line"><span class="keyword">UPDATE</span> MySQL.user <span class="keyword">SET</span> authentication_string<span class="operator">=</span>PASSWORD(<span class="string">&#x27;new_password&#x27;</span>) </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;username&#x27;</span> <span class="keyword">AND</span> Host<span class="operator">=</span><span class="string">&#x27;hostname&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="MySQL-8-密码管理"><a href="#MySQL-8-密码管理" class="headerlink" title="MySQL 8 密码管理"></a>MySQL 8 密码管理</h4><p>MySQL 中记录使用过的历史密码，目前包含如下密码管理功能：</p>
<ul>
<li>密码过期：要求定期修改密码。</li>
<li>密码重用限制：不允许使用旧密码。</li>
<li>密码强度评估：要求使用高强度密码。</li>
</ul>
<blockquote>
<p>提示</p>
<p>MySQL 密码管理功能只针对使用基于 MySQL 授权插件的账号，这些插件有 mysql_native_password、sha256_password 和 caching_sha2_password。</p>
</blockquote>
<p><strong>密码过期策略</strong></p>
<ul>
<li>在 MySQL 中，数据库管理员可以手动设置账号密码过期，也可以建一个自动密码过期策略。</li>
<li>过期策略可以是全局的，也可以为每个账号设置单独的过期策略。</li>
</ul>
<p><strong>手动设置立马过期</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">user</span> PASSWORD EXPIRE;</span><br></pre></td></tr></table></figure>

<p>该语句将密码设置为过期后，用户仍然可以登录数据库，但是无法进行查询，只有在重置了密码后，才可进行查询。</p>
<p><strong>手动设置指定时间过期：全局</strong></p>
<p>如果密码使用的时间大于允许的时间，服务器会自动设置为过期，不需要手动设置。</p>
<p>MySQL 使用 <code>default_password_lifetime</code> 系统变量建立全局密码过期策略。</p>
<ul>
<li>它的默认值是 0，表示禁用自动密码过期。</li>
<li>它允许的值是正整数 N，表示允许的密码生存期。密码必须每隔 N 天进行修改。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用 <span class="keyword">SQL</span> 语句更改该变量的值并持久化</span><br><span class="line"><span class="keyword">SET</span> PERSIST default_password_lifetime <span class="operator">=</span> <span class="number">180</span>; # 建立全局策略，设置密码每隔 <span class="number">180</span> 天过期</span><br><span class="line"></span><br><span class="line"># 配置文件my.cnf(或my.ini)中进行维护</span><br><span class="line">[mysqld]</span><br><span class="line">default_password_lifetime<span class="number">-180</span> # 建立全局策略，设置密码每隔 <span class="number">180</span> 天过期</span><br></pre></td></tr></table></figure>

<p><strong>手动设置指定时间过期：单独设置</strong></p>
<p>每隔账号既可延用全局密码过期策略，也可单独设置策略。在 CREATE USER 和 ALTER USER 语句上加入 PASSWORD EXPIRE 选项可实现单独设置策略。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 设置 rose 账号密码每<span class="number">90</span>天过期；</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE <span class="type">INTERVAL</span> <span class="number">90</span> <span class="keyword">DAY</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE <span class="type">INTERVAL</span> <span class="number">90</span> <span class="keyword">DAY</span>;</span><br><span class="line"></span><br><span class="line"># 设置密码永不过期；</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE NAVER;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE NAVER;</span><br><span class="line"></span><br><span class="line"># 延用全局密码过期策略</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE <span class="keyword">DEFAULT</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE <span class="keyword">DEFAULT</span>;</span><br></pre></td></tr></table></figure>

<p><strong>密码重用策略</strong></p>
<p>MySQL 限制使用已用过的密码。重用限制策略基于密码更改的数量和使用的时间。重用策略可以是全局的，也可以为每个账号设置单独的策略。</p>
<ul>
<li><p>账号的历史密码包含过去该账号所使用的密码。MySQL 基于以下规则来限制密码重用：</p>
<ul>
<li>如果账号的密码限制<strong>基于密码更改的数量</strong>，那么新密码不能从最近限制的密码数量中选择。例如，如果密码更改的最小值为 3，那么新密码不能与最近 3 个密码中任何一个相同。</li>
<li>如果账号密码限制<strong>基于时间</strong>，那么新密码不能从规定时间内选择。例如，如果密码重用周期为 60 天，那么新密码不能从最近 60 天内使用的密码中选择。</li>
</ul>
</li>
<li><p>MySQL 使用 password_history 和 password_reuser_interval 系统变量设置密码重用策略。</p>
<ul>
<li><code>password_history</code>：规定密码重用的数量</li>
<li><code>password_reuser_interval</code>: 规定密码重用的周期</li>
</ul>
</li>
<li><p>这两个值可在服务器的配置文件中进行维护，也可在运行期间使用 SQL 语句更改该变量的值并持久化。</p>
</li>
<li><p>手动设置密码重用方式一：全局</p>
<ul>
<li><p>使用 SQL</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 设置不能选择最近使用过的 <span class="number">6</span> 个密码</span><br><span class="line"><span class="keyword">SET</span> PERSIST password_history <span class="operator">=</span> <span class="number">6</span>;	</span><br><span class="line"></span><br><span class="line">#	设置不能选择最近一年内的密码</span><br><span class="line"><span class="keyword">SET</span> PERSIST password_reuse_interval <span class="operator">=</span> <span class="number">365</span>;	</span><br></pre></td></tr></table></figure>
</li>
<li><p>my.cnf (或 my.ini) 配置文件</p>
  <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">password_history</span>=<span class="string">6</span></span><br><span class="line"><span class="attr">password_reuser_interval</span>=<span class="string">365</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>手动设置密码重用方式二：单独设置</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 不能使用最近 <span class="number">5</span> 个密码</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD HISTORY <span class="number">5</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD HISTORY <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"># 不能使用最近 <span class="number">365</span> 天内的密码</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD REUSE <span class="type">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD REUSE <span class="type">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br><span class="line"></span><br><span class="line"># 既不能使用最近 <span class="number">5</span> 个密码，也不能使用 <span class="number">365</span> 天内的密码</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> </span><br><span class="line">PASSWORD HISTORY <span class="number">5</span></span><br><span class="line">PASSWORD REUSE <span class="type">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> </span><br><span class="line">PASSWORD HISTORY <span class="number">5</span></span><br><span class="line">PASSWORD REUSE <span class="type">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br><span class="line"></span><br><span class="line"># 延用全局策略</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> </span><br><span class="line">PASSWORD HISTORY <span class="keyword">DEFAULT</span></span><br><span class="line">PASSWORD REUSE <span class="type">INTERVAL</span> <span class="keyword">DEFAULT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> </span><br><span class="line">PASSWORD HISTORY <span class="keyword">DEFAULT</span></span><br><span class="line">PASSWORD REUSE <span class="type">INTERVAL</span> <span class="keyword">DEFAULT</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>关于 MySQL 的权限简单的理解就是 MySQL 允许你做你权力以内的事情，不可以越界。比如只允许你执行 SELECT 操作，那么你就不能执行 UPDATE 操作。只允许你从某台机器上连接 MySQL，那么就不能从除那台机器外的其它机器连接 MySQL。</p>
<h4 id="权限列表"><a href="#权限列表" class="headerlink" title="权限列表"></a>权限列表</h4><p>使用 <code>show privileges;</code> 查看权限列表</p>
<ul>
<li><code>CREATE 和 DROP 权限</code>，可以创建新的数据库和表，或删除 (移掉) 已有的数据库和表。如果将 MySQL 数据库中的 DROP 权限授予某用户，用户就可以删除 MySQL 访问权限保存的数据库。</li>
<li><code>SELECT、INSERT、UPDATE 和 DELETE 权限 </code>允许在一个数据库现有的表上实施操作。</li>
<li><code>SELECT 权限 </code>只有在它们真正从一个表中检索行时才被用到。</li>
<li><code>INDEX 权限</code> 允许创建或删除索引，INDEX 适用于已有的表。如果具有某个表的 CREATE 权限，就可以在 CREATE TABLE 语句中包括索引定义。</li>
<li><code>ALTER 权限</code> 可以使用 ALTER TABLE 来更改表的结构和重新命名表。</li>
<li><code>CREATE ROUTINE 权限</code> 用来创建保存的程序 (函数和程序)，ALTER ROUTINE 权限用来更改和删除保存的程序，<code>EXECUTE 权限</code> 用来执行保存的程序。</li>
<li><code>GRANT 权限</code> 允许授权给其它用户，可用于数据库、表和保存的程序。</li>
<li><code>FILE 权限</code> 是用户可以使用 <code>LOAD DATA INFILE</code> 和 <code>SELECT ... INTO OUTFILE</code> 语句读或写服务器上的文件，任何被授予 FILE 权限的用户都能读或写 MySQL 服务器上的任何文件 (说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件)。</li>
</ul>
<p>MySQL 的权限如何分布：</p>
<table>
<thead>
<tr>
<th>权限分布</th>
<th>可能的设置的权限</th>
</tr>
</thead>
<tbody><tr>
<td>表权限</td>
<td><code>Select</code>, <code>Insert</code>, <code>Update</code>, <code>Delete</code>, <code>Create</code>, <code>Drop</code>, <code>Grant</code>, <code>References</code>, <code>Index</code>, <code>Alter</code></td>
</tr>
<tr>
<td>列权限</td>
<td><code>Select</code>, <code>Insert</code>, <code>Update</code>, <code>References</code></td>
</tr>
<tr>
<td>过程权限</td>
<td><code>Execute</code>, <code>Alter Routine</code>, <code>Grant</code></td>
</tr>
</tbody></table>
<h4 id="授予权限的原则"><a href="#授予权限的原则" class="headerlink" title="授予权限的原则"></a>授予权限的原则</h4><p>权限控制主要是出于安全因素，因此需要遵循以下几个经验原则：</p>
<ol>
<li>只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给 select 权限就可以了，不要给用户赋予 update、insert 或者 delete 权限。</li>
<li>创建用户的时候限制用户的登录主机，一般是限制成指定 IP 或者内网 IP 段。</li>
<li>为每个用户设置满足密码复杂度的密码。</li>
<li>定期清理不需要的用户，回收权限或者删除用户。</li>
</ol>
<h4 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h4><p>给用户授权的方式有两种，分别是通过把角色赋予用户给用户授权和直接给用户授权。用户是数据库的使用者，我们可以通过给用户授予访问数据库中资源的权限，来控制使用者对数据库的访问，消除安全隐患。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限<span class="number">1</span>, 权限<span class="number">2</span>, ..., 权限n <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> 用户名@用户地址 [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码口令&#x27;</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>该权限如果发现没有该用户，则会直接新建一个用户。 </li>
<li>如果要给所有权限，可以使用 ALL PRIVILEGES，但不包括 GRANT 权限。</li>
<li>如果要赋予包括 GRANT 的权限，添加参数 <code>WITH GRANT OPTION</code> 这个选项即可，表示该用户可以将自己拥有的权限授权给别人。经常有人在创建操作用户的时候不指定 <code>WITH GRANT OPTION</code> 选项导致后来该用户不能使用 GRANT 命令创建用户或者给其它用户授权。</li>
<li>可以使用 GRANT 重复给用户添加权限，权限叠加，比如你先给用户添加一个 SELECT 权限，然后又给用户添加一个 INSERT 权限，那么该用户就同时拥有了 SELECT 和 INSERT 权限。</li>
</ul>
<blockquote>
<p>在开发应用的时候，经常会遇到一种需求，就是要根据用户的不同，对数据进行横向和纵向的分组。</p>
<ul>
<li>所谓横向的分组，就是指用户可以接触到的数据范围，比如可以看到那些表的数据；</li>
<li>所谓纵向的分组，就是指用户对接触到的数据能访问到什么程度，比如能看、能改，甚至是删除。</li>
</ul>
</blockquote>
<h4 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前用户权限</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANT</span>;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="built_in">CURRENT_USER</span>;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="built_in">CURRENT_USER</span>();</span><br><span class="line"></span><br><span class="line"># 查看某用户的全局权限</span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;主机地址&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="收回权限"><a href="#收回权限" class="headerlink" title="收回权限"></a>收回权限</h4><p>收回全新啊就是取消已经赋予用户的某些权限。收回用户不必要的权限可以在一定程度上保证系统的安全性。MySQL 中使用 <code>REVOKE 语句</code> 取消用户的某些权限。使用 REVOKE 收回权限之后，用户账户的记录将从 db、host、tables_priv 和 column_priv 表中删除，但是用户账户记录仍然在 user 表中保存 (删除 user 表中的账户记录使用 DROP USER 语句)。</p>
<p><strong>注意：再将用户账户从 user 表删除之前，应该收回相应用户的所有权限</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限<span class="number">1</span>, 权限<span class="number">2</span>, ..., 权限n <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">FROM</span> 用户名@用户地址;</span><br></pre></td></tr></table></figure>

<p><strong>注意：须用户重新登录后才能生效</strong>。</p>
<blockquote>
<p>总结</p>
<p>有一些程序员喜欢使用 Root 超级用户来访问数据库，完全把权限控制放在应用层面实现。这样当然也是可以的。但建议大家，尽量使用数据库自己的角色和用户机制来控制访问权限，不要轻易用 Root 账号。因为 Root 账号密码放在代码里面不安全，一旦泄露，数据库就会完全失去保护。</p>
<p>而且，MySQL 的权限控制功能十分完善，应该尽量利用，可以提高效率，而且安全可靠。</p>
</blockquote>
<h3 id="权限表"><a href="#权限表" class="headerlink" title="权限表"></a>权限表</h3><p>MySQL 服务器通过权限表来控制用户对数据库的访问，权限表存放在 mysql 数据库中。MySQL 数据库系统会根据这些权限表的内容为每个用户赋予相应的权限。这些权限表中最重要的是 <code>user表</code>、<code>db表</code>。除此之外，还有 <code>tables_priv 表</code> 、<code>columns_priv 表</code> 和 <code>procs_priv 表</code> 等。在 MySQL 启动时，服务器将这些数据库表中权限信息的内容读入内存。</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>user</td>
<td>用户账号及权限信息</td>
</tr>
<tr>
<td>global_grants</td>
<td>动态全局授权</td>
</tr>
<tr>
<td>db</td>
<td>数据库层级的权限</td>
</tr>
<tr>
<td>tables_priv</td>
<td>表层级的权限</td>
</tr>
<tr>
<td>columns_priv</td>
<td>列层级的权限</td>
</tr>
<tr>
<td>procs_priv</td>
<td>存储的过程和函数权限</td>
</tr>
<tr>
<td>proxies_priv</td>
<td>代理用户的权限</td>
</tr>
<tr>
<td>default_roles</td>
<td>账号连接并认证后默认授予的角色</td>
</tr>
<tr>
<td>role_edges</td>
<td>角色子图的边界</td>
</tr>
<tr>
<td>password_history</td>
<td>密码更改信息</td>
</tr>
</tbody></table>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>连接请求来时，会匹配 mysql 数据库中 user 表里的 user、host 和 password，全部匹配成功才连接成功，这是连接核实阶段。接下来访问数据库、表、字段时，会去 db、tables_priv、columns_priv 表里匹配当前用户的权限。这是请求核实阶段。</p>
<h3 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h3><p>角色是在 MySQL 8.0 中引入的新功能。在 MySQL 中，角色是权限的集合，可以为角色添加或移除权限。用户可以被赋予角色，同时也被授予角色包含的权限。对角色进行操作需要较高的权限。并且向用户账户一样，角色可以游泳授予和撤销的权限。</p>
<p>引入角色的目的是方便管理拥有相同权限的用户。恰当的权限设定，可以确保数据的安全性，这是至关重要的。</p>
<h4 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h4><p>在实际应用中，为了安全性，需要给用户授予权限。当用户数量较多时，为了避免单独给每一个用户授予多个权限，可以先讲权限集合放入角色中，再赋予用户相应的角色。</p>
<p>创建角色使用 <code>CREATE ROLE</code> 语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>][, <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>]]...</span><br></pre></td></tr></table></figure>

<p>角色名称的命名规则和用户名类似。如果 host_name 省略，默认为 %，role_name 不可省略，不可为空。</p>
<h4 id="给角色赋予权限"><a href="#给角色赋予权限" class="headerlink" title="给角色赋予权限"></a>给角色赋予权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privileges <span class="keyword">ON</span> table_name <span class="keyword">TO</span> <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>Privileges 代表权限的命你在，多个权限用逗号隔开。</li>
</ul>
<h4 id="查看角色的权限"><a href="#查看角色的权限" class="headerlink" title="查看角色的权限"></a>查看角色的权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;role_name&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>只要创建了一个角色，系统就会自动给一个 USAGE 权限，意思是连接登录数据库的权限。</li>
</ul>
<h4 id="回收角色的权限"><a href="#回收角色的权限" class="headerlink" title="回收角色的权限"></a>回收角色的权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> privileges <span class="keyword">ON</span> table_name <span class="keyword">FROM</span> <span class="string">&#x27;role_name&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="删除角色"><a href="#删除角色" class="headerlink" title="删除角色"></a>删除角色</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> ROLE role [, role2]...</span><br></pre></td></tr></table></figure>

<h4 id="给用户赋予角色"><a href="#给用户赋予角色" class="headerlink" title="给用户赋予角色"></a>给用户赋予角色</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> role [, role2, ...] <span class="keyword">TO</span> <span class="keyword">user</span> [, user2, ...];</span><br></pre></td></tr></table></figure>

<h4 id="激活角色"><a href="#激活角色" class="headerlink" title="激活角色"></a>激活角色</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 方式一：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">DEFAULT</span> ROLE <span class="keyword">ALL</span> <span class="keyword">TO</span> <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;host_name&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 方式二：将 active_all_roles_on_login 设置为 <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> activate_all_roles_on_login<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line"># 上面这条<span class="keyword">SQL</span>的意思是对所有角色永久激活。</span><br><span class="line"></span><br><span class="line"># 查看当前已激活的角色</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_ROLE</span>();</span><br></pre></td></tr></table></figure>

<h4 id="撤销用户的角色"><a href="#撤销用户的角色" class="headerlink" title="撤销用户的角色"></a>撤销用户的角色</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> role <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h4 id="设置强制角色-mandatory-role"><a href="#设置强制角色-mandatory-role" class="headerlink" title="设置强制角色 (mandatory role)"></a>设置强制角色 (mandatory role)</h4><p>强制角色是给每个创建账户的默认角色，不需要手动设置，强制角色无法被 REVOKE 或者 DROP。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 方式一：服务启动前设置</span><br><span class="line">[mysqld]</span><br><span class="line">mandatory_roles<span class="operator">=</span><span class="string">&#x27;role1,role2@localhost,...&#x27;</span></span><br><span class="line"></span><br><span class="line"># 方式二：运行时设置</span><br><span class="line"><span class="keyword">SET</span> PERSIST mandatory_roles <span class="operator">=</span> <span class="string">&#x27;role1,role2@localhost,...&#x27;</span>;	# 系统重启后仍然有效</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> mandatory_roles <span class="operator">=</span> <span class="string">&#x27;role1,role2@localhost,...&#x27;</span>;	# 系统重启后失效</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>MySQL 主要管理角色的语句如下：</p>
<table>
<thead>
<tr>
<th align="center">语句</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CREATE ROLE and DROP ROLE</td>
<td align="center">创建和删除角色</td>
</tr>
<tr>
<td align="center">GRANT and REVOKE</td>
<td align="center">给角色或者用户分配&#x2F;撤销权限</td>
</tr>
<tr>
<td align="center">SHOW GRANTS</td>
<td align="center">显示用户&#x2F;角色所拥有的权限或者角色</td>
</tr>
<tr>
<td align="center">SET DEFAULT ROLE</td>
<td align="center">设置账户默认使用什么角色</td>
</tr>
<tr>
<td align="center">SET ROLE</td>
<td align="center">改变当前会话的角色</td>
</tr>
<tr>
<td align="center">CURRENT_ROLE()</td>
<td align="center">显示当前会话的角色</td>
</tr>
<tr>
<td align="center">Mandatory_roles 和 activate_all_roles_on_login 系统变量</td>
<td align="center">允许定义用户登录时强制的或者激活授权的角色</td>
</tr>
</tbody></table>
<h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h2><h3 id="逻辑架构剖析"><a href="#逻辑架构剖析" class="headerlink" title="逻辑架构剖析"></a>逻辑架构剖析</h3><h4 id="服务器处理客户端请求"><a href="#服务器处理客户端请求" class="headerlink" title="服务器处理客户端请求"></a>服务器处理客户端请求</h4><p>首先 MySQL 是典型的 C&#x2F;S 架构，即 Client &#x2F; Server 架构，服务器端程序使用的 mysqld。不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：**客户端进程向服务器进程发送一段文本 (SQL 语句)，服务器进程处理后再向客户端进程发送一段文本 (处理结果)**。</p>
<p>下图为服务器处理客户端进程发送的查询请求的示例图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82.png" alt="服务器处理客户端请求"></p>
<p>具体结构：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.png" alt="mysql逻辑架构"></p>
<h4 id="Connectors"><a href="#Connectors" class="headerlink" title="Connectors"></a>Connectors</h4><p>Connectors，指的是不同语言中与 SQL 的交互。MySQL 首先是一个网络程序，在 TCP 之上定义了自己的应用层协议。所以要使用 MySQL，我们可以编写代码，跟 MySQL Server 建立 TCP 连接，之后按照其定义好的协议进行交互。或者比较方便的办法是调用 SDK，比如 Native C API、JDBC、PHP等各语言 MySQL Connector，或者通过 ODBC。但<strong>通过 SDK 来访问 MySQL，本质上还是在 TCP 连接上通过 MySQL 协议跟 MySQL 进行交互</strong>。</p>
<p>MySQL Server 结构可以分为三层：</p>
<h4 id="第一层：连接层"><a href="#第一层：连接层" class="headerlink" title="第一层：连接层"></a>第一层：连接层</h4><p>系统 (客户端) 访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。</p>
<p>经过三次握手建立连接成功后，MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。</p>
<ul>
<li>用户名或密码不对，会收到一个 Access denied for user 错误，客户端程序结束执行。</li>
<li>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖此时读到的权限。</li>
</ul>
<blockquote>
<p>一个系统只会和 MySQL 服务器建立一个连接吗？只能有一个系统和 MySQL 服务器建立连接吗？</p>
</blockquote>
<p>当然不是，多个系统都可以和 MySQL 服务器建立连接，每个系统建立的连接肯定不止一个。所以，为了解决 TCP 无限创建与 TCP频繁创建销毁带来的资源耗尽、性能下降问题。MySQL 服务器里有专门的 <strong>TCP 连接池</strong>限制连接数，采用<strong>长连接模式</strong>复用 TCP 连接，来解决上述问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0.png" alt="mysql连接池"></p>
<p>TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p>
<p>所以连接管理的职责是负责认证、管理连接、获取权限信息。</p>
<h4 id="第二层：服务层"><a href="#第二层：服务层" class="headerlink" title="第二层：服务层"></a>第二层：服务层</h4><p>第二层架构主要完成大多数的核心服务功能，如 SQL 接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p>
<p>在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化：如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。</p>
<p>如果是 SELECT 语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>
<ul>
<li><p><strong>SQL Interface：SQL 接口</strong></p>
<ul>
<li>接收用户的 SQL 命令，并且返回用户需要查询的结果。比如 SELECT … FROM 就是调用 SQL Interface</li>
<li>MySQL 支持 DML (数据操作语言)、DDL (数据定义语言)、存储过程、视图、触发器、自定义函数等多种 SQL 语言接口</li>
</ul>
</li>
<li><p><strong>Parser：解析器</strong></p>
<ul>
<li>在解析器中对 SQL 语句进行语法分析、语义分析。将 SQL 语句分解成数据结构，并将这个结构传递到后续步骤，以后 SQL 语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个 SQL 语句是不合理的。</li>
<li>在 SQL 命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL 还会对 SQL 查询进行语法上的优化，进行查询重写。</li>
</ul>
</li>
<li><p><strong>Optimizer：优化器</strong></p>
<ul>
<li><p>SQL 语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划。</p>
</li>
<li><p>这个执行计划表明应该使用哪些索引进行查询 (全表检索还是使用索引检索)，表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</p>
</li>
<li><p>它使用 <code>选取-投影-连接</code> 策略进行查询。例如</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>  这个 SELECT 查询先根据 WHERE 语句进行选取，而不是将表全部查询出来以后再进行 gender 过滤。</p>
<p>  这个 SELECT 查询先根据 id 和 name 进行属性投影，而不是将属性全部取出来以后再进行过滤，将这两个查询条件连接起来生成最终查询结果。</p>
</li>
</ul>
</li>
<li><p><strong>Caches &amp; Buffers：查询缓存组件</strong></p>
<ul>
<li>MySQL 内部维持着一些 Cache 和 Buffer，比如 Query Cache 用来缓存一条 SELECT 语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</li>
<li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存，权限缓存等。</li>
<li>这个查询缓存可以在不同客户端之间共享。</li>
<li>从 MySQL 5.7.20 开始，不推荐使用查询缓存，并在 MySQL 8.0 中删除。</li>
</ul>
</li>
</ul>
<h4 id="第三层：引擎层"><a href="#第三层：引擎层" class="headerlink" title="第三层：引擎层"></a>第三层：引擎层</h4><p>和其它数据库相比，MySQL 有点与众不同，它的架构可以在多种场景中应用并发挥良好作用，主要体现在存储引擎的架构上，插件式的存储引擎结构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。同时开源的 MySQL 还允许开发人员设置自己的存储引擎。</p>
<p>这种高效的模块化结构为那些希望专门针对特定应用程序需求 (例如数据仓库、事务处理或高可用性情况) 的人提供了巨大的好处，同时享受使用一组独立于任何借口和服务的优势存储引擎。</p>
<p>插件式存储引擎层 (Storage Engines)，<strong>真正的负责了 MySQL 中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</strong>，服务器通过 API 于存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p>
<p>MySQL 8.0.27 默认支持的存储引擎如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> engines;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> Engine             <span class="operator">|</span> Support <span class="operator">|</span> Comment                                                        <span class="operator">|</span> Transactions <span class="operator">|</span> XA   <span class="operator">|</span> Savepoints <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> ARCHIVE            <span class="operator">|</span> YES     <span class="operator">|</span> Archive storage engine                                         <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLACKHOLE          <span class="operator">|</span> YES     <span class="operator">|</span> <span class="operator">/</span>dev<span class="operator">/</span><span class="keyword">null</span> storage engine (anything you write <span class="keyword">to</span> it disappears) <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MRG_MYISAM         <span class="operator">|</span> YES     <span class="operator">|</span> Collection <span class="keyword">of</span> identical MyISAM tables                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FEDERATED          <span class="operator">|</span> <span class="keyword">NO</span>      <span class="operator">|</span> Federated MySQL storage engine                                 <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MyISAM             <span class="operator">|</span> YES     <span class="operator">|</span> MyISAM storage engine                                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> PERFORMANCE_SCHEMA <span class="operator">|</span> YES     <span class="operator">|</span> Performance Schema                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> InnoDB             <span class="operator">|</span> <span class="keyword">DEFAULT</span> <span class="operator">|</span> Supports transactions, <span class="type">row</span><span class="operator">-</span>level locking, <span class="keyword">and</span> <span class="keyword">foreign</span> keys     <span class="operator">|</span> YES          <span class="operator">|</span> YES  <span class="operator">|</span> YES        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MEMORY             <span class="operator">|</span> YES     <span class="operator">|</span> Hash based, stored <span class="keyword">in</span> memory, useful <span class="keyword">for</span> temporary tables      <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CSV                <span class="operator">|</span> YES     <span class="operator">|</span> CSV storage engine                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br></pre></td></tr></table></figure>

<h4 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h4><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存在的，并完成于存储引擎的交互。当然有些存储引擎比如 InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的使用是的这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用 DAS、NAS、SAN 等各种存储系统。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>简化 SQL 执行流程：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%AE%80%E5%8C%96sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="简化sql执行流程"></p>
<p>简化为三层结构：</p>
<ol>
<li>连接层：客户端和服务端建立连接，客户端发送 SQL 至服务器端；</li>
<li>SQL 层 (服务层)：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</li>
<li>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</li>
</ol>
<h3 id="SQL-执行流程"><a href="#SQL-执行流程" class="headerlink" title="SQL 执行流程"></a>SQL 执行流程</h3><h4 id="MySQL-中的-SQL-执行流程"><a href="#MySQL-中的-SQL-执行流程" class="headerlink" title="MySQL 中的 SQL 执行流程"></a>MySQL 中的 SQL 执行流程</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="sql执行流程"></p>
<p>MySQL 的查询流程：</p>
<ol>
<li><p><strong>查询缓存</strong>：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL 8.0 之后就抛弃了这个功能。</p>
<p> MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被肢解缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被肢解返回给客户端。如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。所以，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p>
<blockquote>
<p>大多数情况查询缓存就是个鸡肋，为什么呢？</p>
</blockquote>
<p> 查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的鲁棒性大大降低，只有相同的查询操作才会命中查询缓存。两个查询请求在任何字符上的不同 (如空格、注释、大小写)，都会导致缓存不会命中。因此 MySQL 的查询缓存命中率不高。</p>
<p> 同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql、information_schema、performance_schema 数据库中的表，那这个查询就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数 NOW，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的。</p>
<p> 此外，既然时缓存，那就有它缓存失效的时候。MySQL 的缓存系统会监测涉及到的每张表，只要该表的结果或者数据被修改，如对该表使用了 INSERT、UPDATE、DELETE、TRUNCATE TABLE、ALTER TABLE、DROP TABLE 或 DROP DATABASE 语句，那使用该表的所有高速缓存存储都将变为无效并从高速缓存中删除。对于更新压力大的数据库来说，查询缓存的命中率会非常低。</p>
<p> <strong>总之，因为查询缓存往往弊大于利，查询缓存的失效非常频繁</strong>。</p>
<p> 一般建议大家在静态表里使用查询缓存，什么叫静态表呢？就是一般我们极少更新的表。比如，一个系统配置表、字典表、这种表上的查询才适合使用查询缓存。好在 MySQL 也提供了这种“按需使用”的方式。你可以将 my.cnf 参数 query_cache_type 设置成 DEMAND，代表当 SQL 语句中有 SQL_CACHE 关键词时才缓存。</p>
</li>
<li><p><strong>解析器</strong>：在解析器中对 SQL 语句进行语法分析、语义分析。</p>
<p> 如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。SQL 语句的分析分为词法分析与语法分析。</p>
<p> 分析器先做词法分析。你输入的是由多少个字符串和空格组成的一条 SQL 语句，MySLQ 需要识别出里面的字符串分别是什么，代表什么。</p>
<p> MySLQ 从你输入的 “select” 这个关键字识别出来，这是一个查询语句。它也要把字符串 “T” 识别成”表名 T“，把字符串 “ID” 识别成 “列ID”。</p>
<p> 接着，要做语法分析。根据词法分析的结果，语法分析器 (比如：Bison) 会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p>
<p> 如果你的 语句不对，就会收到 “You have an error in you SQL syntax” 的错误提醒。 </p>
<p> sql词法分析过程：</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/sql%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B.png" alt="sql词法分析过程"></p>
</li>
<li><p><strong>优化器</strong>：在优化器中会确定 SQL 语句的执行路径，比如时根据全表检索，还是根据索引检索等。</p>
<p> 经过了解析器，MySQL 就知道要做什么了。在开始执行之前，还要先经过优化器的处理。<strong>一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划</strong>。</p>
<p> 比如：优化器是在表里面有多个索引的时候，决定使用那个索引；或者在一个语句有多表关联 (join) 的时候，决定各个表的连接顺序，还有表达式简化、子查询转为连接、外连接转为内连接等。</p>
<p> 在查询优化器中，可以分为逻辑查询优化阶段和物理查询优化阶段。</p>
<p> 逻辑查询优化就是通过改变 SQL 语句的内容来时的 SQL 查询更高效，同时为物理查询优化提供更多的候选执行计划。通常采用的方式是对 SQL 语句进行等价变换，对查询进行重写，而查询重写的数学基础就是关系代数。对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等。</p>
<p> 物理查询优化是基于关系代数进行的查询重写，而关系代数的每一步都对应着无力计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。在这个阶段里，对于单表和多表连接的操作，需要高效地使用索引，提升查询效率。</p>
</li>
<li><p><strong>执行器</strong>：</p>
<p> 截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了执行器阶段。在执行之前需要判断该用户是否具备权限。如果没有，就会返回权限错误。如果具备权限，就执行 SQL 查询并返回结果。在 MySQL 8.0 以下的版本，如果设置了查询缓存，这是会讲查询结果进行缓存。</p>
<p> 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，调用存储引擎 API 对表进行读写。存储引擎 API 只是抽象接口，下面还有个存储引擎层，具体实现还是要看表选择的存储引擎。</p>
</li>
</ol>
<p>SQL 语句在 MySQL 中的执行流程是：<code>SQL 语句 → 查询缓存 → 解析器 → 优化器 → 执行器</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B2.png" alt="sql执行流程2"></p>
<h4 id="MySQL-8-中-SQL-执行原理"><a href="#MySQL-8-中-SQL-执行原理" class="headerlink" title="MySQL 8 中 SQL 执行原理"></a>MySQL 8 中 SQL 执行原理</h4><p>前面的结构图很复杂，我们需要抓取最核心的部分：SQL 的执行原理。不同 DBMS 的 SQL 的执行原理是相通的，只是在不同的软件中，各有各的实现路径。</p>
<p>既然一条 SQL 语句会经历不同的模块，那接下来看下在不同的模块中，SQL 执行所使用的资源 (时间) 是怎样的。如何在 MySQL 中对一条 SQL 语句的执行时间进行分析。</p>
<ol>
<li><p>确认 profiling 是否开启</p>
<p> 了解查询语句底层执行的过程：<code>select @@profiling;</code> 或者 <code>show variables like &#39;%profiling&amp;&#39;;</code> 查看是否开启计划。开启它可以让 MySQL 收集在 SQL 执行时所使用的资源情况。</p>
<p> profiling&#x3D;0 代表关闭，将其改为 1，<code>set profiling=1;</code>。Profiling 功能由 MySQL 会话变量：profiling 控制。默认是 OFF。</p>
</li>
<li><p>多次执行相同 SQL 查询</p>
</li>
<li><p>查看 profiles</p>
<p> <code>SHOW profiles;</code> 和 <code>SHOW profile;</code> 语句可以展示当前会话 (退出 session 后，profiling 重置为 0) 中执行语句的资源使用情况。</p>
</li>
</ol>
<h3 id="数据库缓冲池-buffer-pool"><a href="#数据库缓冲池-buffer-pool" class="headerlink" title="数据库缓冲池 (buffer pool)"></a>数据库缓冲池 (buffer pool)</h3><p>InnoDB 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面 (包括读页面、写页面、创建新页面等操作)。而磁盘 I&#x2F;O需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请占用内存来作为数据缓冲池，在真正访问页面之前，需要把磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访问。</p>
<p>这样做的好处是可以让磁盘活动最小化，从而减少与磁盘直接进行 I&#x2F;O 的时间。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里面，那么访问的成本就会降低很多。</p>
<h4 id="缓冲池-vs-查询缓存"><a href="#缓冲池-vs-查询缓存" class="headerlink" title="缓冲池 vs 查询缓存"></a>缓冲池 vs 查询缓存</h4><ul>
<li><p>缓冲池</p>
<p>  在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，如下图：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%BC%93%E5%86%B2%E6%B1%A0.png" alt="缓冲池"></p>
<p>  从图中，可以看到 InnoDB 缓冲池包括了数据页、索引页、插入缓存、锁信息、自适应 Hash 和数据字典信息等。</p>
<p>  <strong>缓冲池的重要性</strong>：</p>
<p>  对于使用 InnoDB 作为存储引擎的表来说，不管是用于存储用户数据的索引 (包括聚簇索引和二级索引)，还是各种系统数据，都是以页的形式存放在表空间中的，而所谓的表空间只不过是 InnoDB 对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。但是各位也都知道，磁盘的速度慢得跟乌龟一样，怎么能配得上 CPU 呢。这里，缓冲池可以帮助我们消除 CPU 和磁盘之间的鸿沟。所以 InnoDB 存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，也就是说即使我们只需要访问一夜的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘 I&#x2F;O 的开销了。</p>
<p>  <strong>缓存原则</strong>：</p>
<p>  <code>为止 * 频次</code> 这个原则，可以帮我们对 I&#x2F;O 访问效率进行优化。</p>
<p>  首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。</p>
<p>  其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会优先对使用频次高的热数据进行加载。</p>
<p>  <strong>缓冲池的预读特性</strong>：</p>
<p>  了解了缓冲池的作用之后，我们还需要了解缓冲池的另一个特性：<strong>预读</strong>。</p>
<p>  缓冲池的作用就是提升 I&#x2F;O 效率，而我们进行读取数据的时候存在一个局部性原理，也就是说我们使用了一些数据，大概率还会使用它周围的一些数据，因此采用预读的机制提前加载，可以减少未来可能的磁盘 I&#x2F;O 操作。</p>
</li>
<li><p>查询缓存</p>
<p>  那么什么是查询缓存呢？</p>
<p>  查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</p>
<p>  缓冲池服务于数据库整体的 I&#x2F;O 操作，它们的共同点都是通过缓存的机制来提升效率。</p>
</li>
</ul>
<h4 id="缓冲池如何读取数据"><a href="#缓冲池如何读取数据" class="headerlink" title="缓冲池如何读取数据"></a>缓冲池如何读取数据</h4><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p>
<p>缓存在数据库中的结构和作用：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%BC%93%E5%AD%98%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E4%BD%9C%E7%94%A8.png" alt="缓存在数据库中的结构和作用"></p>
<p>如果我们执行 SQL 语句的时候更新了缓冲池中的数据，那么这些数据会马上同步到磁盘上吗？</p>
<p>实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会以一定的频率刷新到磁盘上。注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做 <code>checkpoint</code> 的机制将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。</p>
<p>比如，当缓冲池不够用时，需要释放掉一些不常用的页，此时就可以强行采用 checkpoint 的方式，将不常用的脏页回写到磁盘上，然后再从缓冲池中将这些页释放掉。这里脏页指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。</p>
<h4 id="查看-x2F-设置缓冲池的大小"><a href="#查看-x2F-设置缓冲池的大小" class="headerlink" title="查看&#x2F;设置缓冲池的大小"></a>查看&#x2F;设置缓冲池的大小</h4><p>如果你使用的是 MySQL MyISAM 存储引擎，它只缓存索引，不缓存数据，对应的键缓存参数为 <code>key_buffer-size</code>，你可以用它进行查看。</p>
<p>如果你使用的是 InnoDB 存储引擎，可以通过查看 <code>innodb_buffer_pool_size</code> 变量来查看缓冲池的大小。命令如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看缓冲池大小</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_size&#x27;</span>; # 单位是 B</span><br><span class="line"></span><br><span class="line"># 修改缓冲池大小</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_buffer_pool_size <span class="operator">=</span> xxxxx;</span><br><span class="line">或</span><br><span class="line">[mysqld]</span><br><span class="line">innodb_buffer_pool_size <span class="operator">=</span> xxxxxx</span><br></pre></td></tr></table></figure>

<h4 id="多个-Buffer-Pool-实例"><a href="#多个-Buffer-Pool-实例" class="headerlink" title="多个 Buffer Pool 实例"></a>多个 Buffer Pool 实例</h4><p>Buffer Pool 本质是 InnoDB 向操作系统申请的一块连续的内存空间，再多线程环境下，访问 Buffer Pool 中的数据都需要加锁处理。在 Buffer Pool 特别大而且多线程并发访问特别高的情况下，单一的 Buffer Pool 可能会影响请求的处理速度。所以在 Buffer Pool 特别大的时候，我们可以把它们拆分成若干个小的 Buffer Pool，每个 Buffer Pool 都称为一个实例，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。</p>
<p>我们可以在服务器启动的时候通过设置 <code>innodb_buffer_pool_instances</code> 的值来修改 Buffer Pool 实例的个数。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[server]</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_instances</span> = <span class="string">2</span></span><br></pre></td></tr></table></figure>

<p>这样就表明我们要创建两个 Buffer Pool 实例。</p>
<p>查看缓冲池的个数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_instances&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>每个 Buffer Pool实例实际占多少内存空间公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size / innodb_buffer_pool_instances</span><br></pre></td></tr></table></figure>

<p>也就是总共的大小除以实例的个数，结果就是每个 Buffer Pool 实例占用的大小。</p>
<p>不过也不是说 Buffer Pool 实例创建的越多越好，分别管理各个 Buffer Pool 也是需要性能开销的，InnoDB 规定：当 innodb_buffer_pool_size 的值小于 1G 的时候设置多个实例是无效的，InnoDB 会默认把 innodb_buffer_pool_instances 的值改为 1。而我们鼓励在 Buffer Pool 大于或等于 1G 的时候设置多个 Buffer Pool 实例。</p>
<h4 id="引申问题"><a href="#引申问题" class="headerlink" title="引申问题"></a>引申问题</h4><p>Buffer Pool 是MySQL 内存结构中十分核心的一个组成，可以把它想象成一个黑盒子。</p>
<p><strong>黑盒下的更新数据流程</strong></p>
<p>当我们查询数据的时候，会先去把 Buffer Pool 中查询。如果 Buffer Pool 中不存在，存储引擎会先将数据从磁盘加载到 Buffer Pool 中，然后将数据返回给客户端；同理，当我们更新某个数据的时候，如果这个数据不存在于 Buffer Pool，同样会先将数据加载进来，然后修改内存的数据。被修改过的数据会在之后统一刷入磁盘。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E9%BB%91%E7%9B%92%E4%B8%8B%E7%9A%84%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B.png" alt="黑盒下的更新数据流程"></p>
<p>这个过程看似没啥问题，实则是有问题的。假设我们修改 Buffer Pool 中的数据成功，但是还没来得及讲数据刷入磁盘 MySQL 就挂了怎么办？按照上图的逻辑，此时更新之后的数据只存在于 Buffer Pool 中，如果此时 MySQL 服务宕机了，这部分数据将会永久地消失。</p>
<p>再者，我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回滚都做不到还谈什么崩溃恢复？</p>
<p>利用 <code>Redo Log &amp; Undo Log</code>。</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>为了管理方便，人们把连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存储的功能划分为MySQL Server 的功能，把真实存取数据的功能划分为存储引擎的功能。所以在MySQL Server 完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</p>
<p>MySQL 中提到了存储引擎的概念。简而言之，存储引擎就是指表的类型。其实存储引擎以前叫做表处理器，后来改名为存储引擎，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。</p>
<h3 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> engines;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> Engine             <span class="operator">|</span> Support <span class="operator">|</span> Comment                                                        <span class="operator">|</span> Transactions <span class="operator">|</span> XA   <span class="operator">|</span> Savepoints <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> ARCHIVE            <span class="operator">|</span> YES     <span class="operator">|</span> Archive storage engine                                         <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLACKHOLE          <span class="operator">|</span> YES     <span class="operator">|</span> <span class="operator">/</span>dev<span class="operator">/</span><span class="keyword">null</span> storage engine (anything you write <span class="keyword">to</span> it disappears) <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MRG_MYISAM         <span class="operator">|</span> YES     <span class="operator">|</span> Collection <span class="keyword">of</span> identical MyISAM tables                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FEDERATED          <span class="operator">|</span> <span class="keyword">NO</span>      <span class="operator">|</span> Federated MySQL storage engine                                 <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MyISAM             <span class="operator">|</span> YES     <span class="operator">|</span> MyISAM storage engine                                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> PERFORMANCE_SCHEMA <span class="operator">|</span> YES     <span class="operator">|</span> Performance Schema                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> InnoDB             <span class="operator">|</span> <span class="keyword">DEFAULT</span> <span class="operator">|</span> Supports transactions, <span class="type">row</span><span class="operator">-</span>level locking, <span class="keyword">and</span> <span class="keyword">foreign</span> keys     <span class="operator">|</span> YES          <span class="operator">|</span> YES  <span class="operator">|</span> YES        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MEMORY             <span class="operator">|</span> YES     <span class="operator">|</span> Hash based, stored <span class="keyword">in</span> memory, useful <span class="keyword">for</span> temporary tables      <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CSV                <span class="operator">|</span> YES     <span class="operator">|</span> CSV storage engine                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Engine 参数</code> 表示存储引擎名称。</li>
<li><code>Support 参数</code> 表示 MySQL 数据库管理系统是否支持该存储引擎：YES 表示支持，NO 表示不支持。</li>
<li><code>DEFAULT</code> 表示系统默认支持的存储引擎。</li>
<li><code>Comment 参数</code> 表示对存储引擎的评论。</li>
<li><code>Transactions 参数</code> 表示存储引擎是否支持事务：YES 表示支持，NO 表示不支持。</li>
<li><code>XA 参数</code> 表示存储引擎所支持的分布式是否符合 XA 规范：YES 表示支持，NO 表示不支持。代表着该存储引擎是否支持分布式事务。</li>
<li><code>Saverpoints 参数</code> 表示存储引擎是否支持事务处理的保存点：YES 表示支持，NO 表示不支持。也就是说，该存储引擎是否支持部分事务回滚。</li>
</ul>
<h3 id="设置系统默认的存储引擎"><a href="#设置系统默认的存储引擎" class="headerlink" title="设置系统默认的存储引擎"></a>设置系统默认的存储引擎</h3><ul>
<li><p>查看默认的存储引擎</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span>;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@default</span>_storage_engine;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改默认的存储引擎</p>
<p>  如果在创建表的语句中没有显示指定表的存储引擎的话，那就会默认使用 InnoDB 作为表的存储引擎。如果我们想改变表的默认存储引擎的话，可以这样可启动服务器的命令行：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> DEFAULT_STORAGE_ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure>

<p>  或者修改 my.cnf (Windows 系统叫 my.ini) 文件：</p>
  <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">default_storage_engine</span>=<span class="string">MyISAM</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">restart mysqld.service</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="设置表的存储引擎"><a href="#设置表的存储引擎" class="headerlink" title="设置表的存储引擎"></a>设置表的存储引擎</h3><p>存储引擎室负责对表中的数据进行提取和写入工作的，我们可以为不同的表设置不同的存储引擎，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。</p>
<h4 id="创建表时指定存储引擎"><a href="#创建表时指定存储引擎" class="headerlink" title="创建表时指定存储引擎"></a>创建表时指定存储引擎</h4><p>我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎 InnoDB。如果我们想显式的指定一下表的存储引擎，那可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">	建表语句;</span><br><span class="line">) ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure>

<h4 id="修改表的存储引擎"><a href="#修改表的存储引擎" class="headerlink" title="修改表的存储引擎"></a>修改表的存储引擎</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure>

<h3 id="引擎介绍"><a href="#引擎介绍" class="headerlink" title="引擎介绍"></a>引擎介绍</h3><h4 id="InnoDB-引擎：具备外键支持功能的事务存储引擎"><a href="#InnoDB-引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="InnoDB 引擎：具备外键支持功能的事务存储引擎"></a>InnoDB 引擎：具备外键支持功能的事务存储引擎</h4><ul>
<li>MySQL 从 3.23.34a 开始就包含 InnoDB 存储引擎。大于等于 5.5 之后，默认采用 InnoDB 引擎。</li>
<li>InnoDB 是 MySQL 的默认事务型引擎，它被设计用来处理大量的短期 (short-lived) 事务。可以确保事务的完整提交 (Commit) 和 回滚 (Rollback)。</li>
<li>除了增加和查询外，还需要更新、删除操作，那么，应优先选择 InnoDB 存储引擎。</li>
<li>除非有非常特别的原因需要使用其它的存储引擎，否则应该优先考虑 InnoDB 引擎。</li>
<li>数据文件结构：<ul>
<li>表名.frm 存储表结构 (MySQL 8.0 时，合并在表名.ibd 中)</li>
<li>表名.ibd 存储数据和索引</li>
</ul>
</li>
<li>InnoDB 是为处理巨大数据量的最大性能设计。<ul>
<li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如 <code>.frm</code>，<code>.par</code>， <code>.trn</code>，<code>.isl</code>，<code>.db</code>，<code>.opt</code> 等都在MySQL 8.0 中不存在了。</li>
</ul>
</li>
<li>对比 MyISAM 的存储引擎，InnoDB 写的处理效率差一些，并且会占用更多的磁盘空间以保存数据和索引。</li>
<li>MyISAM 只缓存索引，不缓存真实数据；InnoDB 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响。</li>
</ul>
<h4 id="MyISAM-引擎：主要的非事务处理存储引擎"><a href="#MyISAM-引擎：主要的非事务处理存储引擎" class="headerlink" title="MyISAM 引擎：主要的非事务处理存储引擎"></a>MyISAM 引擎：主要的非事务处理存储引擎</h4><ul>
<li>MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数 (GIS) 等，但 MyISAM 不支持事务、行级锁、外键，有一个毫无疑问的缺陷就是崩溃后无法安全回复。</li>
<li>5.5 之前默认的存储引擎。</li>
<li>优势是访问的速度快，对事物完整性没有要求或者以 SELECT、INSERT 为主的应用。</li>
<li>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高。</li>
<li>数据文件结构：<ul>
<li>表名.frm 存储表结构</li>
<li>表名.MYD 存储数据 (MYData)</li>
<li>表名.MYI 存储索引 (MYIndex)</li>
</ul>
</li>
<li>应用场景：只读应用或者以读为主的业务。</li>
</ul>
<h4 id="Archive-引擎：用于数据存档"><a href="#Archive-引擎：用于数据存档" class="headerlink" title="Archive 引擎：用于数据存档"></a>Archive 引擎：用于数据存档</h4><ul>
<li><p><code>archive</code> 是归档的意思，仅仅支持插入和查询两种功能 (行被插入后不能再修改)。</p>
</li>
<li><p>在 MySQL 5.5 以后支持索引的功能。</p>
</li>
<li><p>拥有很好的压缩机制，使用 zlib 压缩裤，在记录请求的时候实时的进行压缩，经常被用来作为仓库使用。</p>
</li>
<li><p>创建 ARCHIVE 表时，存储引擎会创建名称以表名开头的文件。数据文件的扩展名为 <code>.ARZ</code>。</p>
</li>
<li><p>根据英文的测试结论来看，同样数据量下，Archive 表比 MyISAM 表要小大约 75%，比支持事务处理的 InnoDB 表小大约 83%。</p>
</li>
<li><p>ARCHIVE 存储引擎采用了行级锁。该 ARCHIVE 引擎支持 AUTO_INCREMENT 列属性。AUTO_INCREMENT 列可以具有唯一索引或非唯一索引。尝试在任何其它列上创建索引会导致错误。</p>
</li>
<li><p>ARCHIVE 表适合日志和数据采集 (归档) 类应用；适合存储大量的独立 的作为历史记录的数据。拥有很高的插入速度，但是对查询的支持较差。</p>
</li>
<li><p>ARCHIVE 存储引擎功能</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>支持</th>
</tr>
</thead>
<tbody><tr>
<td>B 树索引</td>
<td>不支持</td>
</tr>
<tr>
<td>备份&#x2F;时间点恢复 (在服务器中实现，而不是在存储引擎中)</td>
<td>支持</td>
</tr>
<tr>
<td>集群数据库支持</td>
<td>不支持</td>
</tr>
<tr>
<td>聚集索引</td>
<td>不支持</td>
</tr>
<tr>
<td>压缩数据</td>
<td>支持</td>
</tr>
<tr>
<td>数据缓存</td>
<td>不支持</td>
</tr>
<tr>
<td>加密数据 (加密功能在服务器中实现)</td>
<td>支持</td>
</tr>
<tr>
<td>外键支持</td>
<td>不支持</td>
</tr>
<tr>
<td>全文检索索引</td>
<td>不支持</td>
</tr>
<tr>
<td>地理空间数据类型支持</td>
<td>支持</td>
</tr>
<tr>
<td>地理空间索引支持</td>
<td>不支持</td>
</tr>
<tr>
<td>哈希索引</td>
<td>不支持</td>
</tr>
<tr>
<td>索引缓存</td>
<td>不支持</td>
</tr>
<tr>
<td>锁粒度</td>
<td>行锁</td>
</tr>
<tr>
<td>MVCC</td>
<td>不支持</td>
</tr>
<tr>
<td>存储限制</td>
<td>没有任何限制</td>
</tr>
<tr>
<td>交易</td>
<td>不支持</td>
</tr>
<tr>
<td>更新数据字典的统计信息</td>
<td>支持</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="Blackhole-引擎：丢弃写操作，读操作会返回空内容"><a href="#Blackhole-引擎：丢弃写操作，读操作会返回空内容" class="headerlink" title="Blackhole 引擎：丢弃写操作，读操作会返回空内容"></a>Blackhole 引擎：丢弃写操作，读操作会返回空内容</h4><ul>
<li>Blackhole 引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。</li>
<li>但服务器会记录 Blackhole 表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。</li>
</ul>
<h4 id="CSV-引擎：存储数据时，以逗号分隔各个数据项"><a href="#CSV-引擎：存储数据时，以逗号分隔各个数据项" class="headerlink" title="CSV 引擎：存储数据时，以逗号分隔各个数据项"></a>CSV 引擎：存储数据时，以逗号分隔各个数据项</h4><ul>
<li>CSV 引擎可以将普通的 CSV 文件作为 MySQL 的表来处理，但不支持索引。</li>
<li>CSV 引擎可以作为一种数据交换的机制，非常有用。</li>
<li>CSV 存储的数据直接可以在操作系统里，用文本编辑器，或者 excel 读取。</li>
<li>对于数据的快速导入、导出是有明显优势的。</li>
</ul>
<p>创建 CSV 表时，服务器会创建一个纯文本数据文件，其名称以表名开头并带有 .CSV 扩展名。当你将数据存储到表中时，存储引擎将其以逗号分隔值格式保存到数据文件中。</p>
<h4 id="Memory-引擎：置于内存的表"><a href="#Memory-引擎：置于内存的表" class="headerlink" title="Memory 引擎：置于内存的表"></a>Memory 引擎：置于内存的表</h4><p>概述：</p>
<p>Memory 采用的逻辑介质是内存，响应速度很快，但是当 mysqld 守护进程崩溃的时候数据会丢失。另外，要求存储的数据是数据长度不变的格式，比如，Blob 和 Text 类型的数据不可用 (长度不固定的)。</p>
<p>主要特征：</p>
<ul>
<li>Memory 同时支持哈希索引和 B+ 树索引。<ul>
<li>哈希索引相等的比较快，但是对于范围的比较慢很多。</li>
<li>默认使用哈希索引，其速度要比使用 B 型树索引快。</li>
<li>如果希望使用 B 树索引，可以在创建索引时选择使用。</li>
</ul>
</li>
<li>Memory 表至少比 MyISAM 表要快一个数量级。</li>
<li>Memory 表的大小是受限制的。表的大小主要取决于两个参数，分别是 max_rows 和 max_heap_table_size。其中，max_rows 可以在创建表时指定；max_heap_table_size 的大小默认为 16MB，可以按需要进行扩大。</li>
<li>数据文件与索引文件分开存储。<ul>
<li>每个基于 Memory 存储引擎的表实际对应一个磁盘文件，该文件的文件名与表名相同，类型为 frm 类型，该文件中只存储表的结构，而其数据文件都是存储在内存中的。</li>
<li>这样有利于数据的快速处理，提供整个表的处理效率。</li>
</ul>
</li>
<li>缺点：其数据易丢失，生命周期短。基于这个缺陷，选择 Memory 存储引擎时需要特别小心。</li>
</ul>
<p>使用 Memory 存储引擎的场景：</p>
<ol>
<li>目标数据比较小，而且非常频繁的进行访问，在内存中存放数据，如果太大的数据会造成内存溢出。可以通过参数 max_heap_table_size 控制 Memory 表的大小，限制 Memory 表的最大的大小。</li>
<li>如果数据是临时的，而且必须立即可用得到，那么就可以放在内存中。</li>
<li>存储在 Memory 表中的数据如果突然间丢失的话也没有太大的关系。</li>
</ol>
<h4 id="Federated-引擎：访问远程表"><a href="#Federated-引擎：访问远程表" class="headerlink" title="Federated 引擎：访问远程表"></a>Federated 引擎：访问远程表</h4><ul>
<li>Federated 引擎是访问其他 MySQL 服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</li>
</ul>
<h4 id="Merge-引擎：管理多个-MyISAM-表构成的表集合"><a href="#Merge-引擎：管理多个-MyISAM-表构成的表集合" class="headerlink" title="Merge 引擎：管理多个 MyISAM 表构成的表集合"></a>Merge 引擎：管理多个 MyISAM 表构成的表集合</h4><h4 id="NDB-引擎：MySQL-集群专用存储引擎"><a href="#NDB-引擎：MySQL-集群专用存储引擎" class="headerlink" title="NDB 引擎：MySQL 集群专用存储引擎"></a>NDB 引擎：MySQL 集群专用存储引擎</h4><p>也叫作 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。</p>
<h3 id="MyISAM-和-InnoDB"><a href="#MyISAM-和-InnoDB" class="headerlink" title="MyISAM 和 InnoDB"></a>MyISAM 和 InnoDB</h3><blockquote>
<p>很多人对 InnoDB 和 MyISAM 的取舍存在疑问，到底选择哪个比较好呢？</p>
</blockquote>
<p>MySQL 5.5 之前的默认存储引擎是 MyISAM，5.5 之后改为了 InnoDB。</p>
<p>首先对于 InnoDB 存储引擎，提供了良好的事务管理、崩溃修改能力和并发控制。因为 InnoDB 存储引擎支持事务，所以对于要求事务完整性的场合需要选择 InnoDB，比如数据操作出了插入和查询意外还包含很多更新和删除操作，像财务系统等对数据准确性要求较高的系统。缺点是其读写效率稍差，占用的数据空间相对比较大。</p>
<p>其次对于 MyISAM 存储引擎，如果是小型应用，系统以读操作和插入操作为主，只有很少的更新、删除操作，并且对事务的要求没有那么高，则可以选择这个存储引擎。MyISAM 存储引擎的优势在于占用空间小，处理速度快；缺点是不支持事务的完整性和并发性。</p>
<p>这两种存储引擎各有特点，当然也可以在 MySQL 中，针对不同的数据表，可以选择不同的存储引擎。</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
<td>行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响。</td>
</tr>
<tr>
<td>自带系统表使用</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>关注点</td>
<td>性能：节省资源、消耗少、简单业务</td>
<td>事务：并发写、事务、更大资源</td>
</tr>
<tr>
<td>默认安装</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>默认使用</td>
<td>N</td>
<td>Y</td>
</tr>
</tbody></table>
<h3 id="阿里巴巴、淘宝用哪个"><a href="#阿里巴巴、淘宝用哪个" class="headerlink" title="阿里巴巴、淘宝用哪个"></a>阿里巴巴、淘宝用哪个</h3><table>
<thead>
<tr>
<th>产品</th>
<th>价格</th>
<th>目标</th>
<th>主要功能</th>
<th>是否可投入生产？</th>
</tr>
</thead>
<tbody><tr>
<td>Percona Server</td>
<td>免费</td>
<td>提供 XtraDB 存储引擎的包装器和其它分析工具</td>
<td>XtraDB</td>
<td>是</td>
</tr>
<tr>
<td>MariaDB</td>
<td>免费</td>
<td>扩展 MySQL 以包含 XtraDB 和其他性能改进</td>
<td>XtraDB</td>
<td>是</td>
</tr>
<tr>
<td>Drizzle</td>
<td>免费</td>
<td>提供比 MySQL 更强大的可扩展性和性能改进</td>
<td>高可用性</td>
<td>是</td>
</tr>
</tbody></table>
<ul>
<li>Percona 为 MySQL 数据库服务器进行了改进，在功能和性能上较 MySQL 有很显著的提升。</li>
<li>该版本提升了在高负载情况下的 InnoDB 的性能、为 DBA 提供一些非常有用的性能诊断工具；另外有更多的参数和命令来控制服务器行为。</li>
<li>该公司新建了一款存储引擎较 XtraDB 完全可以替代 InnoDB，并且在性能和并发上做的更好。</li>
<li>阿里巴巴大部分 MySQL 数据库其实使用的 percona 的原型加以修改。</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="InnoDB-表的优势"><a href="#InnoDB-表的优势" class="headerlink" title="InnoDB 表的优势"></a>InnoDB 表的优势</h4><p>InnoDB 存储引擎在实际应用中拥有诸多优势，比如操作便利、提高了数据库的性能、维护成本低等。如果由于硬件或软件的原因导致服务器崩溃，那么在重启服务器之后不需要进行额外的操作。InnoDB 崩溃恢复功能自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。</p>
<p>InnoDB 存储引擎在主内存中维护缓冲池，高频率使用的数据将在内存中直接被处理。这种缓存方式应用于多种信息，加速了处理进程。</p>
<p>在专用服务器上，物理內存中高达 80% 的部分被应用于缓冲池。如果需要将数据插入不同的表中，可以设置外键加强数据的完整性。更新或者删除数据，关联数据将会被自动更新或删除。如果试图将数据插入从表，但在主表中没有对应的数据，插入的数据将被自动移除。如果磁盘或內存中的数据出现崩溃，在使用脏数据之前，校验和机制会发出警告。当每个表的主键都设置合理时，与这些列有关的操作会被自动优化。插入、更新和删除操作通过做改变缓冲自动机制进行优。InnoDB 不仅支持当前读写，也会缓冲改变的数据到数据流磁盘。</p>
<p>InnoDe的性能优势不只存在于长时运行查询的大型表。在同一列多次被查询时，自适应哈希索引会提高查询的速度，使用 InnoDB 可以压缩表和相关的索引，可以在不影响性能和可用性的情况下创建或删除索引，对干大型文本和 BLOB 数据，使用动态行形式，这种存储布局更高效。通过查询 INFORMATION_SCHEMA 库中的表可以监控存储引擎的内部工作。在同一个语句中，InnoDB 表可以与其他存储引擎表混用。即使有些操作系统限制文件大小为 2GB，InnoDB 仍然可以处理。当处理大数据量时，InnoDB 兼顾 CPU，以达到最大性能。</p>
<h4 id="InnoDB-和-ACID-模型"><a href="#InnoDB-和-ACID-模型" class="headerlink" title="InnoDB 和 ACID 模型"></a>InnoDB 和 ACID 模型</h4><p>ACID 模型是一系列数据库设计规则，这些规则着重强调可靠性，而可靠性对于商业数据和任务关键型应用非常重要。MySQL 包含类似 InnoDB 存储引擎的组件，与 ACID 模型紧密相连，这样出现意外时，数据不会崩溃，结果不会失真。如果依赖 ACID 模型，可以不使用一致性检查和崩溃恢复机制。如果拥有额外的软件保护，极可靠的硬件或者应用可以容忍一小部分的数据丢失和不一致，可以将 MySQL 设置调整为只依赖部分 ACID 特性，以达到更高的性能。</p>
<p>InnoDB 存储引擎与 ACID 模型相同作用的四个方面。</p>
<ol>
<li><p>原子方面</p>
<p> ACID 的原子方面主要涉及 InnoDB 事务，与 MySQL 相关的特性主要包括：</p>
<ul>
<li>自动提交设置</li>
<li>COMMIT 语句</li>
<li>ROLLBACK 语句</li>
<li>操作 INFORMATION_SCHEMA 库中的表数据。</li>
</ul>
</li>
<li><p>一致性方面</p>
<p> ACID 模型的一致性主要涉及保护数据不崩溃的内部 InnoDB 处理过程，与 MySQL 相关的特性主要包括：</p>
<ul>
<li>InnoDB 双写缓存</li>
<li>InnoDB 崩溃恢复</li>
</ul>
</li>
<li><p>隔离方面</p>
<p> 隔离是应用于事务的级别，与 MySQL 相关的特性主要包括：</p>
<ul>
<li>自动提交设置</li>
<li><code>SET ISOLATION LEVEL</code> 语句</li>
<li>InnoDB 锁的低级别信息</li>
</ul>
</li>
<li><p>耐久性方面</p>
<p> ACID 模型的耐久性主要涉及与硬件配置相互影响的 MySQL 软件特性。由于硬件复杂多样化，耐久性方面没有具体的规则可循，与 MySQL 相关的特性有：</p>
<ul>
<li>InnoDB 双写缓存，通过 innodb_doublewrite 配置项配置</li>
<li>配置项 innodb_flush_log_at_trx_commit </li>
<li>配置项 sync_binlog</li>
<li>配置项 innodb_file_per_table</li>
<li>存储设备的写入缓存</li>
<li>存储设备的备用电池缓存</li>
<li>运行 MySQL 的操作系统</li>
<li>持续的电力供应</li>
<li>备份策略</li>
<li>对分布式或托管的应用，最主要的在于硬件设备的地点以及网络情况</li>
</ul>
</li>
</ol>
<h4 id="InnoDB-架构"><a href="#InnoDB-架构" class="headerlink" title="InnoDB 架构"></a>InnoDB 架构</h4><ul>
<li><p>缓冲池</p>
<p>  缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的数据能够直接在内存中获得，从而提高速度。</p>
</li>
<li><p>更改缓存</p>
<p>  更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索引页的更改。索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁盘。更新缓存合并期间，可能会大大降低查询的性能。在内存中，更新缓存占用一部分 InnoDB 缓冲池。在磁盘中，更新缓存是系统表空间的一部分。更新缓存的数据类型由 innodb_change_buffering 配置项管理。</p>
</li>
<li><p>自适应哈希索引</p>
<p>  自适应哈希索引将负载和足够的内存结合起来，使得 InnoDB 像内存数据库一样运行，不需要降低事务上的性能或可靠性。这个特性通过 innodb_adaptive_hash_index 选项配置，或者通过 –skip-innodb_adaptive_hash_index 命令行在服务启动时关闭。</p>
</li>
<li><p>重做日志缓存</p>
<p>  重做日志缓存存放要放入重做日志的数据。重做日志缓存大小通过 innodb_log_buffer_size 配置项配置。重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存是的大型事务能够正常运行而不需要写入磁盘。</p>
</li>
<li><p>系统表空间</p>
<p>  系统表空间包括 InnoDB 数据字典、双写缓存、更新缓存和撤销日志，同时也包括表和索引数据。多表共享，系统表空间被视为共享表空间。</p>
</li>
<li><p>双写缓存</p>
<p>  双写缓存位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存后，InnoDB 才会将数据页写入合适的位置。</p>
</li>
<li><p>撤销日志</p>
<p>  撤销日志是一系列与事务相关的插销记录的集合，包含如何撤销事务最近的更改。如果其它事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。插销日志存在于撤销日志片段中，这些片段包含于回滚片段中。</p>
</li>
<li><p>每个表一个文件的表空间</p>
<p>  每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中，而不是系统表空间中。这个功能通过 innodb_file_per_table 配置项开启。每个表空间由一个单独的 .ibd 数据文件代表，该文件默认被创建在数据库目录中。</p>
</li>
<li><p>通用表空间</p>
<p>  使用 CREATE TABLESPACE 语法创建共享的 InnoDB 表空间。通过表空间可以创建在 MySQL 数据目录之外能够管理多个表并支持所有行格式的表。</p>
</li>
<li><p>撤销表空间</p>
<p>  撤销表空间由一个或多个包含撤销日志的文件组成。撤销表空间的数量由 innodb_undo_tablespaces 配置项配置。</p>
</li>
<li><p>临时表空间</p>
<p>  用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。innodb_temp_data_file_path 配置项定义了相关的路径、名称、大小和属性。如果该值为空，默认会在 innodb_data_home_dir 变量指定的目录下创建一个自动扩展的数据文件。</p>
</li>
<li><p>重做日志</p>
<p>  重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据。正常操作期间，重做日志会将请求数据进行编码，这些请求会改变 InnoDB 表数据。遇到意外崩溃后，未完成的更改会自动在初始化期间重新进行。</p>
</li>
</ul>
<h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><h3 id="为什么使用索引"><a href="#为什么使用索引" class="headerlink" title="为什么使用索引"></a>为什么使用索引</h3><p>索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL 中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%B4%A2%E5%BC%95-1.png" alt="索引-1"></p>
<p>如上图所示，数据库没有索引的情况下，数据分布在硬盘的不同的位置上面，读取数据时，摆臂需要前后摆动查找数据，这样操作非常消耗时间。如果数据顺序摆放，那么也需要从 1 到 6 行按顺序读取，这样就相当于进行了 6 次 IO 操作，依旧非常耗时。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找 Col2 &#x3D; 89 这条记录，就要逐行去查找、去比较。从 Col2 &#x3D; 34 开始，进行比较，发现不是，继续下一行。我们当前的表只有不到 10 行数据，但如果表很大的话，有上千万条数据，就意味着要做很多很多次磁盘 I&#x2F;O 才能找到。现在要查找 Col2 &#x3D; 89 这条记录。CPU 必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最消耗时间的就是磁盘 I&#x2F;O (涉及到磁盘的旋转时间 (速度较快)、磁头的寻道时间 (速度慢、耗时))。</p>
<p>假如给数据使用二叉树这样的数据结构进行存储，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%B4%A2%E5%BC%95-2.png" alt="索引-2"></p>
<p>对字段 Col2 添加了索引，就相当于在硬盘上为 Col2 维护了一个索引的数据结构，即这个二叉搜索树。二叉搜索树的每个结点存储的是 (K, V) 结构，key 是 Col2，value 是该 key 所在行的文件指针 (地址) 。比如：该二叉搜索树的根结点就是：(34，0x07)。现在对 Col2 添加了索引，这时再去查找 Col2 &#x3D; 89 这条记录的时候会先去查找该二叉搜索树 (二叉树的遍历查找)。读 34 到内存，89 &gt; 34；继续右侧数据，读 89 到内存，89 &#x3D;&#x3D; 89；找到数据返回。找到之后就根据当前结点的 value 快速定位到要查找的记录对应的地址。我们可以发现，只需要查找两次就可以定位到记录的地址，查询速度就提高了。</p>
<p>这就是我们为什么要建索引，目的就是为了<strong>减少磁盘 I&#x2F;O 的次数</strong>，加快查询速率。</p>
<h3 id="索引及其优缺点"><a href="#索引及其优缺点" class="headerlink" title="索引及其优缺点"></a>索引及其优缺点</h3><h4 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h4><p>MySQL 官方对索引的定义为：<strong>索引 (index) 是帮助 MySQL 高效获取数据的数据结构</strong>。</p>
<p>索引的本质：索引是数据结构。可以简单理解为排好序的快速查找数据结构，满足特定查找算法。这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法。</p>
<p>索引是在存储引擎中实现的，因此没中存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的最大索引数和最大索引长度。所有存储引擎支持每个表至少 16 个索引，总索引长度至少为 256 字节。有些存储引擎支持更多的索引数和更大的索引长度。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的 IO 成本，这也是创建索引最主要的原因。</li>
<li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。</li>
<li>在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间，降低了 CPU 的消耗。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>增加索引也有许多不利的方面，主要表现在如下几个方面：</p>
<ol>
<li>创建索引和维护索引要消耗时间，并且随着数据量的增加，所耗费的时间也会增加。</li>
<li>索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</li>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</li>
</ol>
<p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p>
<blockquote>
<p>提示：</p>
<p>索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p>
</blockquote>
<h3 id="InnoDB-中索引的推演"><a href="#InnoDB-中索引的推演" class="headerlink" title="InnoDB 中索引的推演"></a>InnoDB 中索引的推演</h3><h4 id="索引之前的查找"><a href="#索引之前的查找" class="headerlink" title="索引之前的查找"></a>索引之前的查找</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [列名列表] <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="operator">=</span> xxx;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在一个页中查找</p>
<p>  假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p>
<ul>
<li>以主键为搜索条件。可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li>
<li>以其他列作为搜索条件。因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然这种查找的效率是非常低的。</li>
</ul>
</li>
<li><p>在很多页中查找</p>
<p>  大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：</p>
<ul>
<li>定位到记录所在的页。</li>
<li>从所在的页内中查找相应的记录。</li>
</ul>
<p>  在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是超级耗时的。如果一个表有一亿条记录呢？此时索引应运而生。</p>
</li>
</ul>
<h4 id="设计索引"><a href="#设计索引" class="headerlink" title="设计索引"></a>设计索引</h4><p>建一个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line">	c1 <span class="type">INT</span>,</span><br><span class="line">  c2 <span class="type">INT</span>,</span><br><span class="line">  c3 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(c1)</span><br><span class="line">) ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure>

<p>这个新建的 index_demo 表中有两个 INT 类型的列，一个 CHAR(1) 类型的列，而且规定了 c1 列为主键，这个表使用 Compact 行格式来实际存储记录的。这里简化了index_demo 表的行格式示意图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-1.png" alt="简化行格式示意图"></p>
<p>只在示意图里展示记录的这几个部分：</p>
<ul>
<li>record_type：记录头信息的一项属性，表示记录的类型，0 表示普通记录，2 表示最小记录，3 表示最大记录，1 后文再描述。</li>
<li>next_record：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，用箭头来表明下一条记录是谁。</li>
<li>各个列的值：这里指记录在 index_demo 表中的三个列，分别是 c1、c2、c3。</li>
<li>其他信息：除了上述三种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li>
</ul>
<p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-2.png" alt="简化行格式示意图"></p>
<p>把一些记录放到页里的示意图就是：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-3.png" alt="简化行格式示意图"></p>
<p><strong>一个简单的索引设计方案：</strong></p>
<p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？ 我们可以为快速定位记录所在的数据页而建立一个目录，建这个目录必须完成下边这些事：</p>
<ul>
<li><p>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</p>
<p>  假设：每个数据页最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。有了这个假设之后我们向 index_demo 表插入 3 条记录：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> index_demo <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="string">&#x27;u&#x27;</span>), (<span class="number">3</span>, <span class="number">9</span>, <span class="string">&#x27;d&#x27;</span>), (<span class="number">5</span>, <span class="number">3</span>, <span class="string">&#x27;y&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>  那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-4.png" alt="简化行格式示意图"></p>
<p>  从图中可以看出来，index_demo 表中的 3 条记录都被插入到了编号为 10 的数据页中。此时我们再来插一条记录：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> index_demo <span class="keyword">VALUES</span>(<span class="number">4</span>, <span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>  因为页 10 最多只能放 3 条记录，所以我们不得不再分配一个新页：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-5.png" alt="简化行格式示意图"></p>
<p>  注意，新分配的数据页编号可能并不是连续的。它们只是通过维护着上个页和下一个页的编号而建立了链表关系。另外，页 10 中用户记录最大的主键值是 5，而页 28 中有一条记录的主键值是 4，因为 5 ＞ 4，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为 4 的记录的时候需要伴随着一次记录移动，也就是把主键值为 5 的记录移动到页 28 中，然后再把主键值为 4 的记录插入到页 10 中，这个过程的示意图如下：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-6.png" alt="简化行格式示意图"></p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-7.png" alt="简化行格式示意图"></p>
<p>  这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：下一个数据页的用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程称为<strong>页分裂</strong>。</p>
</li>
<li><p>给所有的页建立一个目录项。</p>
<p>  由于数据页的编号可能是不连续的，所以在向 index_demo 表中插入许多条记录后，可能是这样的效果：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-8.png" alt="简化行格式示意图"></p>
<p>  因为这些 16KB 的页在物理存储上是不连续的，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给他们做个目录，每个页对应一个目录项，每个目录项包括下边两部分：</p>
<ul>
<li>页的用户记录中最小的主键值，用 key 表示。</li>
<li>页号，用 page_no 表示。</li>
</ul>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-9.png" alt="简化行格式示意图"></p>
<p>  以页 28 为例，它对应目录项 2，这个目录项中国呢包含着该页的页号 28 以及该页中用户记录的最小主键值 5。只需要把几个目录项在物理存储器上连续存储 (比如：数组)，就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：</p>
<ul>
<li>先从目录项中根据二分法快速确定出主键值为 20 的记录在目录项 3 中 (因为 12 &lt; 20 &lt; 209)，它对应的页是页 9。</li>
<li>再根据在页中查找记录的方式去页 9 中定位具体的记录。</li>
</ul>
</li>
</ul>
<p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为索引。</p>
<p><strong>InnoDB 中的索引方案</strong></p>
<ul>
<li><p>迭代 1 次：目录项记录的页</p>
<p>  上边称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用二分法快速定位具体的目录项而假设所有目录项都可以在物理存储器上连续存储，但是这样做有几个问题：</p>
<ul>
<li>InnoDB 是使用页来作为管理存储空间的基本单位，最多能保证 16KB 的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</li>
<li>我们时常会对记录进行增删，假设我们把页 28 中的记录都删除了，那意味着目录项 2 也就没有存在的必要了，这就需要吧目录项 2 后的目录项都向前移动一下，这样牵一发而动全身的操作效率很差。</li>
</ul>
<p>  所以，我们需要一种可以灵活管理所有目录项的方式。我们发现目录项其实长得跟我们的用户记录差不多，只不过目录项中的两个列是主键和页号而已，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录。那 InnoDB 怎么区分一条记录是普通的用户记录还是目录项记录呢？使用记录头信息里的 record_type 属性，它的各个取值代表的意思如下：</p>
<ul>
<li>0：普通的用户记录</li>
<li>1：目录项记录</li>
<li>2：最小记录</li>
<li>3：最大记录</li>
</ul>
<p>  我们把前边使用到的目录项放到数据页中的样子就是这样：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-10.png" alt="简化行格式示意图"></p>
<p>  从图中可以看出来，我们新分配了一个编号为 30 的页来专门存储目录项记录。这里再次强调目录项记录和普通用户记录的不同点：</p>
<ul>
<li>目录项记录的 record_type 值是 1，而普通用户记录的 record_type 值是 0。</li>
<li>目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有 InnoDB 自己添加的隐藏列。</li>
<li>了解：记录头信息里还有一个叫 min_rec_mask 的属性，只有在存储目录项记录的页中的主键值最小的目录项记录的 min_rec_mask 值为 1，其它别的记录的 min_rec_mask 值都是 0。</li>
</ul>
<p>  <strong>相同点</strong>：两者用的是一样的数据页，都会为主键值生成 Page Directory (页目录)，从而在按照主键值进行查找时可以使用二分法来加快查询速度。</p>
<p>  现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p>
<ul>
<li>先到存储目录项记录的页，也就是页 30 中通过二分法快速定位到对应目录项，因为 12 &lt; 20 &lt; 209，所以定位到对应的记录所在的页就是页 9。</li>
<li>再到存储用户记录的页 9 中根据二分法快速定位到主键值为 20 的用户记录。</li>
</ul>
</li>
<li><p>迭代 2 次：多个目录项记录的页</p>
<p>  虽然说目录项记录中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有 16KB 大小，能存放的目录项记录也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的目录项记录，如何处理呢？</p>
<p>  这里假设一个存储目录项记录的页最多只能存放 4 条目录项记录，所以如果此时再向上图中插入一条主键值为 320 的用户记录的话，那就需要分配一个新的存储目录项记录的页：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-11.png" alt="简化行格式示意图"></p>
<p>  从图中可以看出，插入了一条主键值为 320 的用户记录之后需要两个新的数据页：</p>
<ul>
<li>为存储该用户记录而新生成了页 31。</li>
<li>因为原先存储目录项记录的页 30 的容量已满 (假设只能存储 4 条目录项记录)，所以不得不需要一个新的页 32 来存放页 31 对应的目录项。</li>
</ul>
<p>  现在因为存储目录项记录的页不止一个，所以如果想根据主键值查找一条用户记录大致需要 3 个步骤，以查找主键值为 20 的记录为例：</p>
<ul>
<li>确定目录项记录页。现在的存储目录项记录的页有两个，即页 30 和 页 32，又因为页 30 表示的目录项的主键值的范围是 [1, 320)，页 32 表示的目录项的主键值不小于 320，所以主键值为 20 的记录对应的目录项记录在页 30 中。</li>
<li>通过目录项记录页确定用户记录真实所在的页。在一个存储目录项记录的页中通过主键值定位一条目录项记录的方式说过了。</li>
<li>在真实存储用户记录的页中定位到具体的记录。</li>
</ul>
</li>
<li><p>迭代 3 次：目录项记录页的目录页</p>
<p>  问题来了，在这个查询步骤的第一步中我们需要定位存储目录项记录的页，但是这些页是不连续的，如果我们表中的数据非常多则会产生很多存储目录项记录的页，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-12.png" alt="简化行格式示意图"></p>
<p>  如图，我们生成了一个存储更高级目录项的页 33，这个页中的两条记录分别代表页 30 和页 32，如果用户记录的主键值在 [1, 320) 之间，则到页 30 中查找更详细的目录项记录，如果主键值不小于 320 的话，就到页 32 中查找更详细的目录项记录。</p>
<p>  随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用瞎编的这个图来描述它：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/B+%E6%A0%91-1.png" alt="B+树-1"></p>
<p>  这个数据结构，它的名称是 B+ 树。</p>
</li>
<li><p>B+ Tree</p>
<p>  不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到 B+ 树这个数据结构中了，所以我们也称这些数据页为节点。从图中可以看出，我们的实际用户记录其实都存放在 B+ 树的最底层的节点上，这些节点也被称为叶子结点，其余用来存放目录项的节点称为非叶子节点或者内节点，其中 B+ 树最上边的那个节点也称为根结点。</p>
<p>  一个 B+ 树的结点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页最多存放 3 条记录，存放目录项记录的页最多存放 4 条记录。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放 100 条用户记录，所有存放目录项记录的内节点代表的数据页可以存放 1000 条目录项记录，那么：</p>
<ul>
<li>如果 B+ 树只有一层，也就是只有一个用于存放用户记录的节点，最多能存放 100 条记录。</li>
<li>如果 B+ 树有两层，最多能存放 1000 * 100 &#x3D; 100 000 条记录。</li>
<li>如果 B+ 树有三层，最多能存放 1000 * 1000 * 100 &#x3D; 100 000 000 条记录。</li>
<li>如果 B+ 树有四层，最多能存放 1000 * 1000 * 1000 * 100 &#x3D; 100 000 000 000 条记录。</li>
</ul>
<p>  你的表里能存放 100000000000 条记录吗？所以<strong>一般情况下，我们用到的 B+ 树都不会超过 4 层</strong>，那我们通过主键值去查找某条记录最多只需要做 4 个页面内的查找 (查找 3 个目录项页和一个用户记录页)，又因为在每个页面内有所谓的 Page Directory (页目录)，所以在页面内也可以通过二分法实现快速定位记录。</p>
</li>
</ul>
<h4 id="常见索引概念"><a href="#常见索引概念" class="headerlink" title="常见索引概念"></a>常见索引概念</h4><p>索引按照物理实现方式，索引可以分为 2 种：聚簇索引和非聚簇索引。我们也把非聚簇索引称为二级索引或者辅助索引。</p>
<ul>
<li><p><strong>聚簇索引</strong></p>
<p>  聚簇索引并不是一种单独的索引类型，而是一种数据存储方式 (所有的用户记录都存储在了叶子节点)，也就是所谓的<strong>索引即数据，数据即索引</strong>。</p>
<blockquote>
<p>术语“聚簇”表示数据行和相邻的键值聚簇的存储在一起。</p>
</blockquote>
<p>  特点：</p>
<ul>
<li>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：<ul>
<li>页内的记录是按照主键的大小顺序排成一个单向链表。</li>
<li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</li>
<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li>
</ul>
</li>
<li>B+ 树的叶子节点存储的是完整的用户记录。所谓完整的用户记录，就是指这个记录中存储了所有列的值 (包括隐藏列)。</li>
</ul>
<p>  我们把具有这两种特性的 B+ 树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子结点处。这种聚簇索引并不需要我们在 MySQL 语句中显式的使用 INDEX 语句去创建，InnoDB 存储引擎会自动的为我们创建聚簇索引。</p>
<p>  优点：</p>
<ul>
<li>数据访问更快，因为聚簇索引将索引和数据保存在同一个 B+ 树中，因此从聚簇索引中获取数据比非聚簇索引更快。</li>
<li>聚簇索引对于主键的排序查找和范围查找速度非常快。</li>
<li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的 I&#x2F;O 操作。</li>
</ul>
<p>  缺点：</p>
<ul>
<li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主键。</li>
<li>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义主键为不可更新。</li>
<li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</li>
</ul>
<p>  限制：</p>
<ul>
<li>对于 MySQL 数据库目前只有 InnoDB 数据引擎支持聚簇索引，而 MyISAM 并不支持聚簇索引。</li>
<li>由于数据物理存储排序方式只能有一种，所以每个 MySQL 的表只能有一个聚簇索引。一般情况下就是该表的主键。</li>
<li>如果没有定义主键，InnoDB 会选择非空的唯一索引代替。如果没有这样的索引，InnoDB 会隐式的定义一个主键来作为聚簇索引。</li>
<li>为了充分利用聚簇索引的聚簇的特性，所以 InnoDB 表的主键列尽量选用有序的顺序 ID，而不建议用无需的id，比如 UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。</li>
</ul>
</li>
<li><p><strong>二级索引 (辅助索引、非聚簇索引)</strong></p>
<p>  上边介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用，因为 B+ 树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办呢？肯定不能是从头到位沿着链表依次遍历记录一遍。</p>
<p>  答案：我们可以多建几棵 B+ 树，不同的 B+ 树中的数据采用不同的排序规则。比方说我们用 c2 列的大小作为数据页、页中巨鹿的排序规则，再建一棵 B+ 树，效果如下图所示：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png" alt="二级索引"></p>
<p>  这个 B+ 树与上边介绍的聚簇索引有几处不同：</p>
<ul>
<li>使用记录 c2 列的大小进行记录和页的排序，这包括三方面的含义：<ul>
<li>页内的记录是按照 c2 列的大小顺序排成一个单向链表。</li>
<li>各个存放用户记录的页也是根据页中记录的 c2 列大小顺序排成一个双向链表。</li>
<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的 c2 列大小顺序排成一个双向链表。</li>
</ul>
</li>
<li>B+ 树的叶子节点存储的并不是完整的用户记录，而只是 c2 列 + 主键这两个列的值。</li>
<li>目录项记录中不再是主键 + 页号的搭配，而变成了 c2 列 + 页号的搭配。</li>
</ul>
<p>  所以如果我们想再想通过 c2 列的值查找某些记录的话就可以使用我们刚刚建好的这个 B+ 树了。以查找 c2 列的值为 4 的记录为例，查找过程如下：</p>
<ul>
<li>确定目录项记录页。根据跟页面，也就是页 44，可以快速定位到目录项记录所在的页为页 42 (因为 2 &lt; 4 &lt; 9)。</li>
<li>通过目录项记录页确定用户记录真实所在的页。在页 42 中可以快速定位到实际存储用户记录的页，但是由于 c2 列并没有唯一性约束，所以 c2 列值为 4 的记录可能分布在多个数据页中，又因为 2 &lt; 4 ≤ 4，所以确定实际存储用户记录的页在页 34 和页 35 中。</li>
<li>在真实存储用户记录的页中定位到具体的记录。到页 34 和页 35 中定位到具体的记录。</li>
<li>但是这个 B+树的叶子节点中的记录只存储了 c2 和 c1 (也就是主键) 两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</li>
</ul>
<p>  <strong>概念：回表</strong></p>
<p>  我们根据这个以 c2 列大小排序的 B+ 树只能确定我们要查找记录的主键值，所以如果我们想根据 c2 列的值查找到完整的用户记录的话，仍然需要到聚簇索引中再查找一遍，这个过程称为回表。也就是根据 c2 列的值查询一条完整的用户记录需要使用到两棵 B+ 树。</p>
<p>  <strong>问题</strong>：为什么我们还需要一次回表操作呢？直接把完整的用户记录放到叶子节点不行吗？</p>
<p>  <strong>回答</strong>：如果把完整的用户记录放到叶子节点是不用回表。但是 太占地方了，相当于每建立一棵 B+ 树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。</p>
<p>  因为这种按照非主键列建立的 B+ 树需要一次回表操作才可以定位到完整的用户记录，所以这种 B+ 树也被称为二级索引 (英文名 secondary index)，或者辅助索引。由于我们使用的是 c2 列的大小作为 B+ 树的排序规则，所以我们也称这个 B+ 树是为 c2 列建立的索引。</p>
<p>  非聚簇索引的存在不影响数据在聚簇索引中的组织，索引一张表可以有多个非聚簇索引。</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E5%A4%9A%E4%B8%AA%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt="多个非聚簇索引"></p>
<p>  <strong>小结</strong>：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：</p>
<ul>
<li>聚簇索引的叶子节点存储的就是我们的数据记录，非聚簇索引的叶子节点存储的是数据位置。非聚簇索引不会影响数据表的物理存储顺序。</li>
<li>一个表只能有一个聚簇索引，因为只能有一种排序存储的方式，但可以有多个非聚簇索引，也就是多个索引目录提供数据检索。</li>
<li>使用聚簇索引的时候，数据的查询效率高，但如果对数据进行插入、删除、更新等操作，效率会比非聚簇索引低。</li>
</ul>
</li>
<li><p><strong>联合索引</strong></p>
<p>  我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让 B+ 树按照 c2 和 c3 列的大小进行排序，这个包含两层含义：</p>
<ul>
<li>先把各个记录和页按照 c2 列进行排序。</li>
<li>在记录的 c2 列相同的情况下，采用 c3 列进行排序。</li>
</ul>
<p>  为 c2 和 c3 列建立的索引的示意图如下：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.png" alt="联合索引"></p>
<p>  如图所示，我们需要注意以下几点：</p>
<ul>
<li>每条目录项记录都由 c2、c3、页号这三个部分组成，各条记录先按照 c2 列的值进行排序，如果记录的 c2 列相同，则按照 c3 列的值进行排序。</li>
<li>B+ 树叶子节点处的用户记录由 c2、c3 和主键 c1 列组成。</li>
</ul>
<p>  注意一点，以 c2 和 c3 列的大小为排序规则建立的 B+ 树称为联合索引，本质上也是一个二级索引。它的意思与分别为 c2 和 c3 列分别建立索引的表述是不同的，不同点如下：</p>
<ul>
<li>建立联合索引只会建立如上图一样的一棵 B+ 树。</li>
<li>为 c2 和 c3 列分别建立索引会分别以 c2 和 c3 列的大小为排序规则建立两棵 B+ 树。</li>
</ul>
</li>
</ul>
<h4 id="InnoDB-的-B-树索引的注意事项"><a href="#InnoDB-的-B-树索引的注意事项" class="headerlink" title="InnoDB 的 B+ 树索引的注意事项"></a>InnoDB 的 B+ 树索引的注意事项</h4><p><strong>根页面位置万年不动</strong></p>
<p>前面介绍 B+ 树索引的时候，为了理解方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上 B+ 树的形成过程是这样的：</p>
<ul>
<li>每当为某个表创建一个 B+ 树索引 (聚簇索引不是人为创建的，默认就有) 的时候，都会为这个索引创建一个根结点页面。最开始表中没有数据的时候，每个 B+ 树索引对应的根结点中既没有用户记录，也没有目录项记录。</li>
<li>随后向表中插入用户记录时，先把用户记录存储到这个根结点中。</li>
<li>当根结点中的可用空间用完时继续插入记录，此时会将根结点中的所有记录复制到一个新分配的页，比如页 a 中，然后对这个新页进行页分裂的从左，得到另一个新页，比如页 b。这时新插入的记录根据键值 (也就是聚簇索引中的主键值，二级索引中对应的索引列的值) 的大小就会被分配到页 a 或者页 b 中，而根结点便升级为存储目录项记录的页。</li>
</ul>
<p>这个过程特别注意的是：一个 B+ 树索引的根结点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根结点的页号便会被记录到某个地方，然后凡是 InnoDB 存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根结点的页号，从而来访问这个索引。</p>
<p><strong>内节点中目录项记录的唯一性</strong></p>
<p>我们知道 B+ 树索引的内节点中目录项记录的内容是索引列 + 页号的搭配，但是这个搭配对于耳机索引来说有点不严谨。以 index_demo 为例，假设这个表中的数据是这样的：</p>
<table>
<thead>
<tr>
<th>c1</th>
<th>c2</th>
<th>c3</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>‘u’</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>‘d’</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>‘y’</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td>‘a’</td>
</tr>
</tbody></table>
<p>如果二级索引中目录项记录的内容只是索引列 + 页号的搭配的话，那么为 c2 列建立索引后的 B+ 树应该长这样：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/index_demoB+%E6%A0%91.png" alt="index_demoB+树"></p>
<p>如果我们相信插入一行记录，其中 c1、c2、c3 的值分别是：9、1、’c’，那么在修改这个 c2 列建立的二级索引对应的 B+ 树时碰到了个大问题：由于页 3 中存储的目录项记录是由 c2 列 + 页号的值构建成的，页 3 中的两条目录项记录对应的 c2 列的值都是 1，而我们新插入的这条记录的 c2 列的值也是 1，那我们这条新插入的记录到底应该放到页 4 中，还是应该放到页 5 中啊？</p>
<p>为了让新插入记录能找到自己在哪个页里，我们需要保证在 B+ 树的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于耳机索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>
<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号</li>
</ul>
<p>也就是把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证 B+ 树每一层中各条目录项记录除页号这个字段外是唯一的，所以我们为 c2 列建立二级索引后的示意图实际上应该是这样子的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/index_demoB+%E6%A0%912.png" alt="index_demoB+树"></p>
<p>这样我们再插入记录 (9, 1, ‘c’) 时，由于页 3 中存储的目录项记录是由 c2 列 + 主键 + 页号的值构成的，可以先把新纪录的 c2 列的值和页 3中各目录项记录的 c2 列的值做比较，如果 c2 列的值相同的话，可以接着比较主键值，因为 B+ 树同一层中不同目录项记录的 c2 列 + 主键值 的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新纪录应该被插入到页 5 中。</p>
<p><strong>一个页面最少存储两条记录</strong></p>
<p>一个 B+ 树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为 B+ 树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉很多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是啥效果呢？那就是目录层级非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半条劲只能存放一条真实的用户记录？所以 InnoDB 的一个数据页至少可以存放两条记录。</p>
<h3 id="MyISAM-中的索引方案"><a href="#MyISAM-中的索引方案" class="headerlink" title="MyISAM 中的索引方案"></a>MyISAM 中的索引方案</h3><p>B 树索引适用存储引擎如表所示：</p>
<table>
<thead>
<tr>
<th>索引 &#x2F; 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>B-Tree 索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>即使多个存储引擎支持同一种类型的索引，但是她们的实现原理也是不同的。InnoDB 和 MyISAM 默认的索引是 BTree 索引；而 Memory 默认的索引是 Hash 索引。</p>
<p>MyISAM 引擎使用 B+ 树作为索引结构，叶子节点的 data 域存放的是数据记录的地址。</p>
<h4 id="MyISAM-索引的原理"><a href="#MyISAM-索引的原理" class="headerlink" title="MyISAM 索引的原理"></a>MyISAM 索引的原理</h4><p>InnoDB 中索引即数据，也就是聚簇索引的那棵 B+ 树的叶子节点中已经把所有完整的用户记录都包含了，而 MyISAM 的索引方案虽然也适用树形结构，但是却将索引和数据分开存储：</p>
<ul>
<li>将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为数据文件。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。</li>
<li>使用 MyISAM 存储引擎的表会把索引信息另外存储到一个称为索引文件的另一个文件中。MyISAM 会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是主键值 + 数据记录地址的组合。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/MyISAM%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84-1.png" alt="MyISAM索引结构-1"></p>
<p>这里设表一共有三列，假设我们以 col1 为主键，上图是一个 MyISAM 表的主索引 (Primary key) 示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。在 MyISAM 中，主键索引和二级索引 (Secondary key) 在结构上没有任何区别，只是主键索引要求 key 是唯一的，而二级索引的 key 可以重复。如果我们在 col2 上建立一个二级索引，则此索引的结构如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/MyISAM%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84-2.png" alt="MyISAM索引结构-2"></p>
<p>同样也是一棵 B+ 树，data 域保存数据记录的地址。因为，MyISAM 中索引检索的算法为：首先按照 B+ 树搜索算法搜索索引，如果指定的 key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。</p>
<h4 id="MyISAM-与-InnoDB-对比"><a href="#MyISAM-与-InnoDB-对比" class="headerlink" title="MyISAM 与 InnoDB 对比"></a>MyISAM 与 InnoDB 对比</h4><p>MyISAM 的索引方式都是非聚簇的，与 InnoDB 包含 1 个聚簇索引是不同的。小结两种引擎索引的区别：</p>
<ul>
<li>在 InnoDB 存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次回表操作，意味着 MyISAM 中建立的索引相当于全部都是二级索引。</li>
<li>InnoDB 的数据文件本身就是索引文件，而 MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</li>
<li>InnoDB 的非聚簇索引 data 域存储相应记录主键的值，而 MyISAM 索引记录的是地址。换句话说，InnoDB 的所有非聚簇索引都引用主键作为 data 域。</li>
<li>MyISAM 的回表操作是十分快速的，因为是拿地址偏移量直接到文件中取数据的，反观 InnoDB 是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</li>
<li>InnoDB 要求表必须有主键 (MyISAM 可以没有)。如果没有显示指定，则 MySQL 系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整型。</li>
</ul>
<p><strong>小结</strong>：</p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助。比如：</p>
<ul>
<li>知道了 InnoDB 的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。</li>
<li>用非单调的字段作为主键在 InnoDB 中不是好主意，因为 InnoDB 数据文件本身是一棵 B+ 树，非单调的主键会造成在插入新纪录时，数据文件为了维持 B+ 树的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</li>
</ul>
<h3 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h3><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p>
<ul>
<li><p>空间上的代价</p>
<p>  每建立一个索引都要为它建立一棵 B+ 树，每一棵 B+ 树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的 B+ 树由许多数据页组成，那就是很大的一片存储空间。</p>
</li>
<li><p>时间上的代价</p>
<p>  每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+ 树索引。而且 B+ 树每层节点都是按照索引列的值从小到大的顺序排列而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录 (也就是不论是用户记录还是目录项记录) 都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的 B+ 树都要进行相关的维护操作，会给性能拖后腿。</p>
</li>
</ul>
<blockquote>
<p>一个表上索引建得越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们得学学这些索引在哪些条件下起作用的。</p>
</blockquote>
<h3 id="MySQL-数据结构选择的合理性"><a href="#MySQL-数据结构选择的合理性" class="headerlink" title="MySQL 数据结构选择的合理性"></a>MySQL 数据结构选择的合理性</h3><p>从 MySQL 的角度讲，不得不考虑一个现实问题就是磁盘 IO。如果我们能让索引的数据结构尽量减少硬盘的 I&#x2F;O 操作，所消耗的时间也越小。可以说，磁盘的 I&#x2F;O 操作次数对索引的使用效率至关重要。</p>
<p>查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个 G 甚至更多，为了减少索引在内存的占用，数据库索引是存储在外部磁盘上的。当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载，那么 MySQL 衡量查询效率的标准就是磁盘 IO 次数。</p>
<h4 id="全表遍历"><a href="#全表遍历" class="headerlink" title="全表遍历"></a>全表遍历</h4><p>略</p>
<h4 id="Hash-结构"><a href="#Hash-结构" class="headerlink" title="Hash 结构"></a>Hash 结构</h4><p>Hash 本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。</p>
<p>Hash 算法是通过某种确定性的算法 (比如 MD5、SHA1、SHA2、SHA3) 将输入转变为输出。相同的输入永远可以得到相同的输出，假设输入内容有微小偏差，在输出中通常会有不同的结果。</p>
<p>举例：如果你想要验证两个文件是否相同，那么你不需要把两份文件直接拿来比对，只需要让对方把 Hash 函数计算得到的结果告诉你即可，然后在本地同样对文件进行 Hash 函数的运算，最后通过比较这两个 Hash 函数的结果是否相同，就可以知道这两个文件是否相同。</p>
<p><strong>加速查找速度的数据结构，常见的有两类</strong>：</p>
<ul>
<li>树，例如平衡二叉搜索树，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是 O(log<sub>2</sub>N)。</li>
<li>哈希，例如 HashMap，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是 O(1)。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%951.png" alt="哈希算法"></p>
<p>采用 Hash 进行检索效率非常高，基本上一次检索就可以找到数据，而 B+ 树需要自顶向下依次查找，多次访问节点才能找到数据，中间需要多次 I&#x2F;O 操作，从效率来说 Hash 比 B+ 树更快。</p>
<p>在哈希的方式下，一个元素 k 处于 h(k) 中，即利用哈希函数 h，根据关键字 k 计算出槽的位置。函数 h 将关键字域映射到哈希表 T[0 ··· m - 1] 的槽位上。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%952.png" alt="哈希算法2"></p>
<p>上图中哈希函数 h 有可能将两个不同的关键字映射到相同的位置，这叫做碰撞，在数据库中一般采用链接法来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%953.png" alt="哈希算法3"></p>
<p>实验：体会数组和 hash 表的查找方面的效率区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法复杂度为 O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">in</span>[<span class="number">100000</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100000</span>; j++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(temp == arr[i]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  System.out.println(<span class="string">&quot;time: &quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法复杂度为 O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">  HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">100000</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    set.add(i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> j;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> set.contains(temp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  System.out.println(<span class="string">&quot;time: &quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Hash 结构效率高，那为什么索引结构要设计成树型呢</strong>？</p>
<ul>
<li>Hash 索引仅能满足 &#x3D; 、&lt;&gt; 和 IN 查询。如果进行范围查询，哈希型的索引，时间复杂度会退化为 O(n)；而树型的有序特性，依然能够保持 O(log<sub>2</sub>N) 的高效率。</li>
<li>Hash 索引还有一个缺陷，数据的存储是没有顺序的，在 ORDER BY 的情况下，使用 Hash 索引还需要对数据重新排序。</li>
<li>对于联合索引的情况，Hash 值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。</li>
<li>对于等值查询来说，通常 Hash 索引的效率更高，不过也存在一种情况，就是索引列的重复值如果很多，效率就会降低。这是因为遇到 Hash 冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以，Hash 索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。</li>
</ul>
<p><strong>Hash 索引适用存储引擎如表所示</strong>：</p>
<table>
<thead>
<tr>
<th>索引 &#x2F; 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>Hash 索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p><strong>Hash 索引的适用性</strong>：</p>
<p>Hash 索引存在着很多限制，相比之下在数据库中 B+ 树索引的使用面会更广，不过也有一些场景采用 Hash 索引效率更高，比如在键值型 (Key-Value) 数据库中，Redis 存储的核心就是 Hash 表。</p>
<p>MySQL 中的 Memory 存储引擎支持 Hash 存储，如果我们需要用到查询的临时表时，就可以选择 Memory 存储引擎，把某个字段设置为 Hash 索引，比如字符串类型的字段，进行 Hash 计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要等值查询的时候，采用 Hash 索引是个不错的选择。</p>
<p>另外，InnoDB 本身不支持 Hash 索引，但是提供自适应 Hash 索引 (Adaptive Hash Index)。什么情况下才会使用自适应 Hash 索引呢？如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到 Hash 表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让 B+ 树也具备了 Hash 索引的优点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95.png" alt="自适应哈希索引"></p>
<p> 采用自适应 Hash 索引的目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。</p>
<p>可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%adaptive_hash_index&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>如果我们利用二叉树作为索引结构，那么磁盘的 IO 次数和索引树的高度是相关的。</p>
<p><strong>二叉搜索树的特点</strong></p>
<ul>
<li>一个节点只能有两个子节点，也就是一个节点度不能超过 2</li>
<li>左子节点 &lt; 本节点；右子节点 &gt; 本节点，比我大的向右，比我小的向左</li>
</ul>
<p><strong>查找规则</strong></p>
<p>最基础的二叉搜索树 (Binary Search Tree)，搜索某个节点和插入节点的规则一样，假设搜索插入的数值为 key：</p>
<ul>
<li>如果 key 大于根结点，则在右子树中进行查找；</li>
<li>如果 key 小雨根结点，则在左子树中进行查找；</li>
<li>如果 key 等于根结点，也就是找到了这个节点，返回根结点即可。</li>
</ul>
<p>举个例子，对数列 (34, 22, 89, 5, 23, 77, 91) 创造出来的二分查找树如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-1.png" alt="二叉搜索树"></p>
<p>但是存在特俗的情况，就是有时候二叉树的深度非常大。比如我们给出的数据顺序是 (5, 22, 23, 34, 77, 89, 91)，创造出来的二分搜索树如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-2.png" alt="二叉搜索树"></p>
<p>上面第二棵树也属于二分查找树，但是性能上已经退化成了一条链表，查找数据的时间复杂度变成了 O(n)。能看出来第一个树的深度是 3，也就是说最多只需 3 次比较，就可以找到结点，而第二个树的深度是 7，最多需要 7 次比较才能找到结点。</p>
<p>为了提高查询效率，就需要减少磁盘 IO 数。为了减少磁盘 IO 的次数，就需要尽量降低树的高度，需要把原来高瘦的树结构变得矮胖，树的每层的分叉越多越好。</p>
<h4 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h4><p>为了解决上面二叉搜索树退化成链表的问题，人们提出了平衡二叉搜索树 (Balanced Binary Tree)，又称为 AVL 树，它在二叉搜索树的基础上增加了约束，具有以下性质：</p>
<p><strong>它是一棵空树或他的左右两个紫薯的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树</strong>。</p>
<p>这里说一下，常见的平衡二叉树有很多种，包括了平衡二叉搜索树、红黑树、数堆、伸展树。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到了平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就属于平衡二叉搜索树，搜索时间复杂度就是 O(log<sub>2</sub>n)。</p>
<p>数据查询的时间主要依赖于磁盘 I&#x2F;O 的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改进，树的深度也是 O(log<sub>2</sub>n)，当 n 比较大时，深度也是比较高的，比如下图的情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/avl%E6%A0%91.png" alt="avl树"></p>
<p>每访问一次节点就需要进行一次磁盘 I&#x2F;O 操作，对于上面的树来说，我们需要进行 5 次 I&#x2F;O 操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘 I&#x2F;O 操作次数多，会影响整体数据查询的效率。</p>
<p>针对同样的数据，如果我们把二叉树改成 M 叉树 (M &gt; 2) 呢？当 M &#x3D; 3 时，同样的 31 个节点可以由下面的三叉树来进行存储：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E5%B9%B3%E8%A1%A1%E4%B8%89%E5%8F%89%E6%A0%91.png" alt="平衡三叉树"></p>
<p>能看到此时树的高低降低了，当数据量 N 大的时候，以及树的分叉数 M 大的时候，M 叉树的高度会远小于二叉树的高度 (M &gt; 2)。所以，我们需要把树丛高瘦变矮胖。</p>
<h4 id="BTree"><a href="#BTree" class="headerlink" title="BTree"></a>BTree</h4><p>B 树的英文是 Balance Tree，也就是多路平衡查找树。简写为 B-Tree。它的高度远小于平衡二叉树的高度。</p>
<p>B 树的结构如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/B%E6%A0%91.png" alt="B树"></p>
<p>B 树作为多路平衡查找树，它的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶。每个磁盘块包括了关键字和子节点的指针。如果一个磁盘块中包括了 x 个关键字，那么指针数就是 x+1。对于一个 100 阶的 B 树来说，如果有 3 层的话最多可以存储约 100 万的索引数据。对于大量的索引数据来说，采用 B 树的结构是非常适合的，因为树的高度要远小于二叉树的高度。</p>
<p>一个 M 阶的 B 树 (M &gt; 2) 有以下的特性：</p>
<ul>
<li>根结点的儿子树的范围是 [2, M]。</li>
<li>每个中间节点包含 k - 1 个关键字和 k 个孩子，孩子的数量 &#x3D; 关键字的数量 +1，k 的取值范围为 [ceil(M &#x2F; 2), M]。</li>
<li>叶子节点包括 k - 1 个关键字 (叶子节点没有孩子)，k 的取值范围为 [ceil(M &#x2F; 2), M]。</li>
<li>假设中间节点的关键字为：Key[1], Key[2], …, Key[k - 1]，且关键字按照升序排序，即 Key[i] &lt; Key[i + 1]。此时 k - 1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i - 1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k - 1] 的子树。</li>
<li>所有叶子节点位于同一层。</li>
</ul>
<p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。可以看下磁盘块 2，里面的关键字为 (8, 12)，它有 3 个孩子 (3, 5)，(9, 10)， (13, 15)，能看到 (3, 5) 小于 8，(9, 10) 在 8 和 12 之间，而 (13, 15) 大于 12，刚好符合刚才给出的特征。</p>
<p>然后看下如何用 B 树进行查找。假设想要查找的关键字是 9，那么步骤可以分为以下几步：</p>
<ul>
<li>与根结点的关键字 (17, 35) 进行比较，9 小于 17 纳米得到指针 P1；</li>
<li>按照指针 P1 找到磁盘块 2，关键字为 (8, 12)，因为 9 在 8 和 12 之间，所以得到指针 P2；</li>
<li>按照指针 P2 找到磁盘块 6，关键字为 (9, 10)，然后找到了关键字 9。</li>
</ul>
<p>能看出来在 B 树的搜索过程中，比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I&#x2F;O 操作，消耗的时间比在内存中进行比较所需的时间要多，是数据查找用时的重要因素。<strong>B 树相比于平衡二叉树来说磁盘 I&#x2F;O 操作要少</strong>，在数据查询中比平衡二叉树效率要高。所以<strong>只要树的高度足够低，IO 次数足够少，就可以提高查询性能</strong>。</p>
<p><strong>小结</strong>：</p>
<ul>
<li>B 树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li>
<li>关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束。</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找。</li>
</ul>
<p>例子：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/B%E6%A0%91%E4%BE%8B%E5%AD%90.png" alt="B树例子"></p>
<h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B + Tree"></a>B + Tree</h4><p>B+ 树也是一种多路搜索树，基于 B 树做出了改进，主流的 DBMS 都支持 B+ 树的索引方式，比如 MySQL。相比于 B-Tree，B+Tree 适合文件索引系统。</p>
<p><strong>B+ 树和 B 树的差异在于以下几点</strong>：</p>
<ul>
<li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字树 + 1。</li>
<li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大或最小。</li>
<li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中，非叶子节点及保存索引，也保存数据记录。</li>
<li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</li>
</ul>
<p>下图就是一棵 B+ 树，阶数为 3，根节点中的关键字 1、18、35 分别是子节点 (1, 8, 14)，(18, 24,31) 和 (35, 41, 53) 中的最小值。每一层父节点的关键字都会出现在下一层的子节点的关键字中，因此在叶子节点中包括了所有的关键字信息，并且每一个叶子节点都有一个只想下一个节点的指针，这样就形成了一个链表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/B+%E6%A0%91.png" alt="B+树"></p>
<p>如果，想要查找关键字 16，B+ 树会自顶向下逐层进行查找：</p>
<ul>
<li>与根结点的关键字 (1, 18, 35) 进行比较，16 在 1 和 18 之间，得到指针 P1 (指向磁盘块 2)</li>
<li>找到磁盘块 2，关键字为 (1, 8, 14)，因为 16 大于 14，所以得到指针 P3 (指向磁盘块 7)</li>
<li>找到磁盘块 7，关键字为 (14, 16, 17)，然后找到了关键字 16，所以可以找到关键字 16 所对应的数据。</li>
</ul>
<p>整个过程一共进行了 3 次 IO 操作，看起来 B+ 树和 B 树的查询过程差不多，但是 B+ 树和 B 树有根根本的差异在于，<strong>B+ 树的中间节点并不直接存储数据</strong>。这样的好处都有什么？</p>
<p>首先，<strong>B+ 树查询效率更稳定</strong>。因为 B+ 树每次只有访问到叶子节点才能找到对应的数据，而在 B 树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。</p>
<p>其次，<strong>B+ 树的查询效率更高</strong>。这是因为通常 B+ 树比 B 树更矮胖 (阶数更大，深度更低)，查询所需要的磁盘 I&#x2F;O 也会更少。同样的磁盘页大小，B+ 树可以存储更多的节点关键字。</p>
<p>不仅是对单个关键字的查询上，<strong>在查询范围上，B+ 树的效率也比 B 树高</strong>。这里因为所有关键字都出现在 B+ 树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在 B 树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</p>
<blockquote>
<p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。</p>
<p>但 B 树和 B+ 树各有自己的应用场景，不能说 B+ 树完全比 B 树好，反之亦然。</p>
</blockquote>
<p><strong>思考题：为了减少 IO，索引树会一次性加载吗</strong>？</p>
<blockquote>
<p>1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个 G。</p>
<p>2、当我们利用索引查询的时候，是不可能将全部几个 G 的索引都加载进内存的，能做的只能是：逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</p>
</blockquote>
<p><strong>思考题：B+ 树的存储能力如何？为何说一般查找行记录，最多只需要 1～3 次磁盘 IO</strong>？</p>
<blockquote>
<p>InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT (占用 4 个字节) 或BIGINT (占用 8 个字节)，指针类型也一般为 4 或 8 个字节，也就是说一个页 (B+ 树中的一个节点) 中大概存储 16KB &#x2F; (8B + 8B) &#x3D; 1K 个键值 (因为是估值，为方便计算，这里的 K 取值为 10<sup>3</sup>。也就是说一个深度为 3 的 B+ 树索引可以维护 10<sup>3</sup> * 10<sup>3</sup> * 10<sup>3</sup> &#x3D; 10 亿条记录。这里假定一个数据页也存储 10<sup>3</sup> 条行记录数据了)。</p>
<p>实际情况中每个节点可能不能填充满，因此在数据库中，B+ 树的高度一般都在 2～4 层。MySQL 的 InnoDB 存储引擎在设计时是将根结点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1～3 次磁盘 I&#x2F;O 操作。</p>
</blockquote>
<p><strong>思考：为什么说 B+ 树比 B 树更适合实际应用中操作系统的文件索引和数据库索引</strong>？</p>
<blockquote>
<p>1、B+ 树的磁盘读写代价更低</p>
<p>B+ 树的内部节点并没有指向关键字具体信息的指针。因此其内部节点相对 B 树更小。如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了。</p>
<p>2、B+ 树的查询效率更加稳定</p>
<p>由于非终结点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</blockquote>
<p><strong>思考题：Hash 索引与 B+ 树索引的区别</strong></p>
<blockquote>
<p>1、Hash 索引不能进行范围查询，而 B+ 树可以。这是因为 Hash 索引指向的数据是无序的，而 B+ 树的叶子节点是个有序的链表。</p>
<p>2、Hash 索引不支持联合索引的最左侧原理 (即联合索引的部分索引无法使用)，而 B+ 树可以。对于联合索引来说，Hash 索引在计算 Hash 值的时候是将索引键合并后再一起计算 Hash 值，所以不会针对每个索引单独计算 Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</p>
<p>3、Hash 索引不支持 ORDER BY 排序，因为 Hash 索引指向的数据是无序的，因此无法起到排序优化的作用，而 B+ 树索引数据是有序的，可以起到对该字段 ORDER BY 排序优化的作用。同理，也无法用 Hash 索引进行模糊查询，而 B+ 树使用 LIKE 进行模糊查询的时候，LIKE 后面模糊查询 (比如 % 结尾) 的话就可以起到优化作用。</p>
<p>4、I浓浓DB 不支持 哈希索引。</p>
</blockquote>
<p><strong>思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗</strong>？</p>
<blockquote>
<p>如果使用的是 MySQL 的话，我们需要了解 MySQL 的存储引擎都支持哪些索引结构，如下表</p>
<table>
<thead>
<tr>
<th>Storage Engine</th>
<th>Permissible Index Types</th>
</tr>
</thead>
<tbody><tr>
<td>InnoDB</td>
<td>BTREE</td>
</tr>
<tr>
<td>MyISAM</td>
<td>BREEE</td>
</tr>
<tr>
<td>MEMORY&#x2F;HEAP</td>
<td>HASH，BTREE</td>
</tr>
<tr>
<td>NDB</td>
<td>HASH，BTREE</td>
</tr>
</tbody></table>
<p>能看到，针对 InnoDB 和 MyISAM 存储引擎，都会默认采用 B+ 树索引，无法使用 Hash 索引。InnoDB 提供的自适应 Hash 是不需要手动指定的。如果是 Memory&#x2F;Heap 和 NDB 引擎，是可以进行选择 Hash 索引的。</p>
</blockquote>
<h4 id="R-树"><a href="#R-树" class="headerlink" title="R 树"></a>R 树</h4><p>R- Tree 在 MySQL 很少使用，仅支持 geometry 数据类型，支持该类型的存储引擎只有 MyISAM、BDB、InnoDB、NDB、Archive 集中。举个 R 树在现实领域中能够解决的例子：查找 20 英里以内所有的餐厅。如果没有 R 树你会怎么解决？一般情况下我们会把餐厅的坐标 (x, y) 分为两个字段存放在数据库中，一个字段记录精度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满足要求。如果一个地区有 100 家餐厅的话，我们就需要进行 100 次位置计算了，如果应用到谷歌、百度地图这种超级大数据库中，这种方法便必定不可行了。R 树就很好的解决了这种高维空间搜索问题。它把 B 树的思想很好的扩展到了多维空间，采用了 B 树分割空间的思想，并在添加、删除操作时采用合并、分解节点的方法，保证树的平衡性。因此，R 树就是一棵用来存储高维数据的平衡树。相对于 B-Tree，R-Tree 的优势在于范围查找。</p>
<table>
<thead>
<tr>
<th>索引 &#x2F; 存储引擎</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>R-Tree 索引</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>使用索引可以帮助我们从海量的数据中快速定位想要查找的数据，不过索引也存在一些不足，比如占用存储空间、降低数据库写操作的性能等，如果有多个索引还会增加索引选择的时间。当我们使用索引时，需要平衡索引的利 (提升查询效率) 和弊(维护索引所需的代价)。</p>
<p>在实际工作中，我们还需要基于需求和数据本身的分布情况来确定是否使用索引，尽管索引不是万能的，但数据量大的时候不使用索引是不可想象的，毕竟索引的本质，是帮助我们提升数据检索的效率。</p>
<h2 id="InnoDB-数据存储结构"><a href="#InnoDB-数据存储结构" class="headerlink" title="InnoDB 数据存储结构"></a>InnoDB 数据存储结构</h2><h3 id="数据库的存储结构：页"><a href="#数据库的存储结构：页" class="headerlink" title="数据库的存储结构：页"></a>数据库的存储结构：页</h3><p>索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都是保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL 服务器上的存储引擎负责对表中数据的读取和写入工作。不同存储引擎中存放的格式一般是不同的，甚至有的存储引擎比如 Memory 都不用磁盘来存储数据。</p>
<p>由于 InnoDB 是 MySQL 的默认存储引擎，所以本章剖析 InnoDB 存储引擎的数据存储结构。</p>
<h4 id="磁盘与内存交互基本单位：页"><a href="#磁盘与内存交互基本单位：页" class="headerlink" title="磁盘与内存交互基本单位：页"></a>磁盘与内存交互基本单位：页</h4><p>InnoDB 将数据划分为若干个页，InnoDB 中页的大小默认为 16KB。</p>
<p>以页作为磁盘和内存之间交互的基本单位，也就是一次最少丛磁盘中读取 16KB 的内容到内存中，一次最少把内存中的 16KB 内容刷新到磁盘中。也就是说，<strong>在数据库中，不论读一行，还是读多行，都是将这些所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页 (Page)，数据库 I&#x2F;O 操作的最小单位是页</strong>。一个页中可以存储多个行记录。</p>
<blockquote>
<p>记录是按照行来存储的，但是数据库的读取并不是以行为单位，否则一次读取 (也就是一次 I&#x2F;O 操作) 只能处理一行数据，效率会非常低。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E6%95%B0%E6%8D%AE%E9%A1%B5.png" alt="数据页"></p>
<h4 id="页结构概述"><a href="#页结构概述" class="headerlink" title="页结构概述"></a>页结构概述</h4><p>页 a、页 b、页 c … 页 n 这些页可以不再物理结构上相连，只要通过双向链表相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页都会为存储在它里边的记录生成一个页目录，再通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，啊啊然后再便利该槽对应分组中的记录即可快速找到指定的记录。</p>
<h4 id="页的大小"><a href="#页的大小" class="headerlink" title="页的大小"></a>页的大小</h4><p>不同的数据库管理系统的页大小不同。比如在 MySQL 的 InnoDB 存储引擎中，默认页的大小是 16KB，我们可以通过下面的命令来进行查看：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_page_size%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>SQL Server 中页的大小为 8KB，而在 Oracle 中我们用术语“块” (Block) 来代表“页”，Oracle 支持的块的大小为 2KB、4KB、8KB、16KB、32KB 和 64KB。</p>
<h4 id="页的上层结构"><a href="#页的上层结构" class="headerlink" title="页的上层结构"></a>页的上层结构</h4><p>另外在数据库中，还存在着区 (Extent)、段 (Segment) 和表空间 (Tablespace) 的概念。行、页、区、段、表空间的关系如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E8%A1%8C%E9%A1%B5%E5%8C%BA%E6%AE%B5%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="行页区段表空间的关系"></p>
<p>区 (Extent) 是比页大一级的存储结构，在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64 * 16KB &#x3D; 1MB。</p>
<p>段 (Segment) 由一个或多个区组成，区在文件系统中是一个连续分配的空间 (在 InnoDB 中是连续的 64 个页)，不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p>
<p>表空间 (Tablespace) 是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。</p>
<h3 id="页的内部结构"><a href="#页的内部结构" class="headerlink" title="页的内部结构"></a>页的内部结构</h3><p>页如果按类型划分的话，常见的有数据页 (保存 B+ 树节点)、系统页、Undo 页 和 事物数据页等。数据页是我们最常使用的页。</p>
<p>数据页的 16KB 大小的存储空间被划分为七个部分，分别是文件头 (File Header)、页头 (Page Header)、最大最小记录 (Infimum + supremum)、用户记录 (User Records)、空闲空间 (Free Space)、页目录 (Page Directory) 和文件尾 (File Tailer)。</p>
<p>页结构的示意图如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E9%A1%B5%E7%BB%93%E6%9E%84%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="页结构的示意图"></p>
<p>这 7 个部分作用分别如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用大小</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>File Header</td>
<td>38 字节</td>
<td>文件头，描述页的信息</td>
</tr>
<tr>
<td>Page Header</td>
<td>56 字节</td>
<td>页头，页的状态信息</td>
</tr>
<tr>
<td>Infimum + Supremum</td>
<td>26 字节</td>
<td>最大和最小记录，这时两个虚拟的行记录</td>
</tr>
<tr>
<td>User Records</td>
<td>不确定</td>
<td>用户记录，存储行记录内容</td>
</tr>
<tr>
<td>Free Space</td>
<td>不确定</td>
<td>空闲记录，页中还没有被使用的空间</td>
</tr>
<tr>
<td>Page Directory</td>
<td>不确定</td>
<td>页目录，存储用户记录的相对位置</td>
</tr>
<tr>
<td>File Trailer</td>
<td>8 字节</td>
<td>文件尾，校验页是否完整</td>
</tr>
</tbody></table>
<p>我们可以把这 7 个结构分成 3 个部分。</p>
<h4 id="File-Header-文件头部-和-File-Trailer-文件尾部"><a href="#File-Header-文件头部-和-File-Trailer-文件尾部" class="headerlink" title="File Header (文件头部) 和 File Trailer (文件尾部)"></a>File Header (文件头部) 和 File Trailer (文件尾部)</h4><p>首先是文件通用部分，也就是文件头和文件尾。</p>
<p><strong>文件头部信息</strong></p>
<p>不同类型的页都会以 File Header 作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁等，所有的数据页会组成一个双链表。这个部分占用固定的 38 个字节，是由下边这些内容组成的：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FIL_PAGE_SPACE_OR_CHKSUM</td>
<td>4 字节</td>
<td>页的校验和 (checksum 值)</td>
</tr>
<tr>
<td>FIL_PAGE_OFFSET</td>
<td>4 字节</td>
<td>页号</td>
</tr>
<tr>
<td>FIL_PAGE_PREV</td>
<td>4 字节</td>
<td>上一个页的页号</td>
</tr>
<tr>
<td>FIL_PAGE_NEXT</td>
<td>4 字节</td>
<td>下一个页的页号</td>
</tr>
<tr>
<td>FIL_PAGE_LSN</td>
<td>8 字节</td>
<td>页面被最后修改时对应的日志序列位置 (英文名是：Log Sequence Number)</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE</td>
<td>2 字节</td>
<td>该页的类型</td>
</tr>
<tr>
<td>FIL_PAGE_FILE_FLUSH_LSN</td>
<td>8 字节</td>
<td>尽在系统表空间的一个页中定义，代表文件至少被刷新到了对应的 LSN 值</td>
</tr>
<tr>
<td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td>4 字节</td>
<td>页属于哪个表空间</td>
</tr>
</tbody></table>
<p>其中：</p>
<ul>
<li><p>FIL_PAGE_OFFSET</p>
<p>  每一个页都有一个单独的页号，InnoDB通过页号可以唯一定位一个页。</p>
</li>
<li><p>FIL_PAGE_TYPE</p>
<p>  这个代表当前页的类型。InnoDB 为了不同的目的而把页分为不同的类型，上面介绍的都是存储记录的数据页，还有很多其它的类型的页：</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>十六进制</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FIL_PAGE_TYPE_ALLOCATED</td>
<td>0x0000</td>
<td>最新分配，还没使用</td>
</tr>
<tr>
<td>FIL_PAGE_UNDO_LOG</td>
<td>0x0002</td>
<td>Undo 日志页</td>
</tr>
<tr>
<td>FIL_PAGE_INODE</td>
<td>0x0003</td>
<td>段信息节点</td>
</tr>
<tr>
<td>FIL_PAGE_IBUF_FREE_LIST</td>
<td>0x0004</td>
<td>Insert Buffer 空闲列表</td>
</tr>
<tr>
<td>FIL_PAGE_IBUF_BITMAP</td>
<td>0x0005</td>
<td>Insert Buffer 位图</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_SYS</td>
<td>0x0006</td>
<td>系统页</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_TRX_SYS</td>
<td>0x0007</td>
<td>事务系统数据</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_FSP_HDR</td>
<td>0x0008</td>
<td>表空间头部信息</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_XDES</td>
<td>0x0009</td>
<td>扩展描述页</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_BLOB</td>
<td>0x000A</td>
<td>溢出页</td>
</tr>
<tr>
<td>FIL_PAGE_INDEX</td>
<td>0x45BF</td>
<td>索引页，也就是数据页</td>
</tr>
</tbody></table>
<p>  我们存放记录的数据页的类型其实是 FIL_PAGE_INDEX，也就是所谓的索引页。</p>
</li>
</ul>
<p><strong>数据页的链接实现</strong></p>
<p>在文件头部内容中有两个属性：FIL_PAGE_PREV 和 FIL_PAGE_NEXT</p>
<p>InnoDB 都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV 和 FIL_PAGE_NEXT 就跟别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间不需要是物理上的连续，而是逻辑上的连续。</p>
<p>数据页之间组成的双向链表：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%BB%84%E6%88%90%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="数据页之间组成的双向链表"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%BB%84%E6%88%90%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A82.png" alt="数据页之间组成的双向链表"> </p>
<p><strong>检验页的完整性</strong></p>
<p>文件头部和文件尾部都有属性：FIL_PAGE_SPACE_OR_CHKSUM</p>
<p>代表当前页面的检验和 (checksum)。</p>
<blockquote>
<p>什么是校验和？</p>
<p>就是对于一个很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为检验和。</p>
<p>在比较两个很长的字节串之前，先比较这两个长字节串的校验和，如果校验和都不一样，则两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。</p>
</blockquote>
<p>InnoDB 存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候断电了，造成了该页传输的不完整性。</p>
<p>为了检测一个页是否完整 (也就是在同步的时候有没有发生只同步一半的尴尬情况)，这时可以通过文件尾的检验和 (checksum 值) 与文件头的检验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。</p>
<p><strong>文件尾部</strong></p>
<p>文件尾部总共占用 8 个字节</p>
<ul>
<li>前 4 个字节代表页的校验和：这个部分适合 File Header 中的校验和相对应的。</li>
<li>后 4 个字节代表页面被最后修改时对应的日志序列位置 (LSN)。</li>
</ul>
<p>这个部分也是为了校验页的完整性的，如果首部和尾部的 LSN 值校验不成功的话，就说明同步过程出现了问题。</p>
<h4 id="User-Records-用户记录-、最大最小记录、Free-Space-空闲空间"><a href="#User-Records-用户记录-、最大最小记录、Free-Space-空闲空间" class="headerlink" title="User Records (用户记录)、最大最小记录、Free Space (空闲空间)"></a>User Records (用户记录)、最大最小记录、Free Space (空闲空间)</h4><p>第二部分是记录部分，页的主要作用是存储记录，所以”最大和最小记录“和“用户记录”部分占了页结构的主要空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E9%A1%B5%E7%BB%93%E6%9E%84%E7%A9%BA%E9%97%B4%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="页结构空间示意图"></p>
<p><strong>空闲空间 (Free Space)</strong></p>
<p>我们自己存储的记录会按照指定的行格式存储到 User Records 部分。但是在一开始生成页的时候，其实并没有 User Records 这个部分，每当我们插入一条记录，都会从 Free Space 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到 User Records 部分，当 Free Space 部分的空间全部被 User Records 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。</p>
<p><strong>用户记录 (User Records)</strong></p>
<p>User Records 中的这些记录按照指定的行格式一条一条摆在 User Records 部分，相互之间形成单链表。用户记录里的</p>
<p><strong>最小最大记录 (Infimum + Supremum)</strong></p>
<p>记录可以比较大小吗？</p>
<p>记录可以比大小，对于一条完整的记录来说，比较就的大小就是比较主键的大小。比方说我们插入的 4 行记录的主键值分别是：1、2、3、4，这就意味着这 4 条记录是从小到大依次递增。</p>
<p>InnoDB 规定的最小记录与最大记录这两条记录的构造十分简单，都是由 5 个字节大小的记录头信息和 8 字节大小的一个固定的部分组成的，如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E8%AE%B0%E5%BD%95.png" alt="最小最大记录"></p>
<p>这两条记录不是我们自己定义的记录，所以她们并不存放在页的 User Records 部分，她们被单独放在一个称为 Infimum + Supremum 的部分，如图：</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E8%AE%B0%E5%BD%952.png" alt="最小最大记录"></p>
<h4 id="Page-Directory-页目录-、Page-Header-页面头部"><a href="#Page-Directory-页目录-、Page-Header-页面头部" class="headerlink" title="Page Directory (页目录)、Page Header (页面头部)"></a>Page Directory (页目录)、Page Header (页面头部)</h4><p><strong>页目录</strong></p>
<p>在页中，记录是以单向链表的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了目录页这个模块，专门给记录做一个目录，通过二分查找法的方式进行检索提升效率。</p>
<p><strong>页目录是如何构成的</strong></p>
<p>需求：根据主键值查找页中的某条记录，如何实现快速查找呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> page_demo <span class="operator">=</span> <span class="keyword">WHERE</span> c1 <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>最笨的办法：顺序查找</p>
<p>从 Infimum 记录 (最小记录) 开始，沿着链表一直往后找，总有一天会找到或者找不到，在找的时候还能投机取巧，因为链表中哥哥记录的值是按照从小到大的顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值是，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。</p>
<p>如果一个页中存储了非常多的记录，这么查找性能很差。</p>
<p>好办法：使用目录，二分查找法</p>
<ul>
<li>将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。</li>
<li>第一组，也就是最小记录所在的分组只有一个记录；最后一组，就是最大记录所在的分组，会有 1～8 条记录；其余的组记录数量在 4～8 条之间。这样做的好处是，除了第一组以外，其余组的记录树会尽量平分。</li>
<li>在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。</li>
<li>页目录用来存储魅族最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，魅族的地址偏移量也被称之为槽 (slot)，每个槽相当于指针指向了不同组的最后一个记录。</li>
</ul>
<p>页目录分组的个数如何确定？</p>
<p>为什么最小记录的 n_owned 值为 1，而最大记录的 n_owned 值为 5 呢？</p>
<p>InnoDB 规定：对于最小记录所在的分组只能有一条记录，最大记录所在的分组拥有的记录条数只能在 1～8 之间，剩下的分组中记录的条数范围只能在 4～8 之间。</p>
<p>分组是按照下面的步骤进行的：</p>
<ul>
<li>初始情况下一个数据页里只有最小记录和最大记录两条记录，她们分属于两个分组。</li>
<li>之后没插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的 n_owned 值加 1，表示本组内又添加了一条记录，知道该组中的记录数等于 8 个。</li>
<li>在一个组中的记录数等于 8 个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中 4 条记录，另一个 5 条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li>
</ul>
<p><strong>页面头部</strong></p>
<p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫 Page Header 的部分，这个部分占用固定的 56 个字节，专门存储各种状态信息。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td>2 字节</td>
<td>在页目录中的槽数量</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td>2 字节</td>
<td>还未使用的空间最小地址，也就是说从该地址之后就是 Free Space</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td>2 字节</td>
<td>本页中的记录的数量 (包括最小和最大记录以及标记为删除的记录)</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td>2 字节</td>
<td>第一个已经标记为删除的记录地址 (各个已删除的记录通过 next_record 也会组成一个单链表，这个单链表中的记录可以被重新利用)</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td>2 字节</td>
<td>已删除记录占用的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td>2 字节</td>
<td>最后插入记录的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td>2 字节</td>
<td>记录插入的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td>2 字节</td>
<td>一个方向连续插入的记录数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td>2 字节</td>
<td>该页中记录的数量 (不包括最小和最大记录以及被标记为删除的记录)</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td>8 字节</td>
<td>修改当前页的最大事务 ID，该值尽在二级索引中定义</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td>2 字节</td>
<td>当前页在 B+ 树中所处的层级</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td>8 字节</td>
<td>索引 ID，表示当前页属于哪个索引</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td>10 字节</td>
<td>B+ 树叶子段的头部信息，仅在 B+ 树的 Root 页定义</td>
</tr>
</tbody></table>
<h4 id="从数据页的角度看-B-树如何查询"><a href="#从数据页的角度看-B-树如何查询" class="headerlink" title="从数据页的角度看 B+ 树如何查询"></a>从数据页的角度看 B+ 树如何查询</h4><p>一棵 B+ 树按照节点类型可以分成两部分：</p>
<ul>
<li>叶子节点，B+ 树最底层的节点，节点的高度为 0，存储行记录。</li>
<li>非叶子节点，节点的高度大于 0，存储索引键和页面指针，并不存储记录本身。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/B+%E6%A0%91%E6%9F%A5%E8%AF%A2.png" alt="B+树查询"></p>
<p>当我们从页结构来理解 B+ 树的时候，可以帮我们理解一些通过索引进行检索的原理：</p>
<p><strong>B+ 树是如何进行记录检索的</strong>？</p>
<p>如果通过 B+ 树的索引查询行记录，首先是从 B+ 树的根开始，逐层检索，知道找到叶子节点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽 (slot) 采用二分查找的方式先找到一个粗略的记录分组，然后再在分组中通过链表遍历的方式查找记录。</p>
<p><strong>普通索引和唯一索引在存储效率上有什么不同</strong>？</p>
<p>我们创建索引的时候可以是普通索引，也可以是唯一索引，那么这两个索引在查询效率上有什么不同呢？</p>
<p>唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索。而普通索引，可能会存储在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是单独将这条记录从磁盘中读出去，而是将这个记录所在的页加载到内存中进行读取。InnoDB 存储引擎的页大小为 16KB，在一个页中可能存储着上千个记录，因此在普通索引的字段上进行查找也就是在内存中多几次判断下一条记录的操作，对于 CPU 来说，这些操作所消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本没有差别。</p>
<h3 id="InnoDB-行格式-或记录格式"><a href="#InnoDB-行格式-或记录格式" class="headerlink" title="InnoDB 行格式 (或记录格式)"></a>InnoDB 行格式 (或记录格式)</h3><p>平时的数据以行为单位来向表中插入数据，这些记录在磁盘上的存放方式也被称为行格式或记录格式。InnoDB 存储引擎设计了 4 种不同类型的行格式，分别是 Compact、Redundant、Dynamic 和 Compressed 行格式。</p>
<p>查看 MySQL8 的默认行格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@innodb</span>_default_row_format;</span><br></pre></td></tr></table></figure>

<p>也可以使用如下语法查看具体表使用的行格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">like</span> 表名\G</span><br></pre></td></tr></table></figure>

<h4 id="指定行格式的语法"><a href="#指定行格式的语法" class="headerlink" title="指定行格式的语法"></a>指定行格式的语法</h4><p>在创建或修改表的语句中指定行格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (列信息) ROW_FORMAT<span class="operator">=</span>行格式名称;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ROW_FORMAT<span class="operator">=</span>行格式名称;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> record_test_table(</span><br><span class="line">	col1 <span class="type">VARCHAR</span>(<span class="number">8</span>),</span><br><span class="line">  col2 <span class="type">VARCHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  col3 <span class="type">char</span>(<span class="number">8</span>),</span><br><span class="line">  col4 <span class="type">VARCHAR</span>(<span class="number">8</span>)</span><br><span class="line">) CHARSET<span class="operator">=</span>ascii ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> record_test_table(col1, col2, col3, col4)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="string">&#x27;wangwu&#x27;</span>,<span class="string">&#x27;laji&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;xiaoming&#x27;</span>,<span class="string">&#x27;xiaohong&#x27;</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure>

<h4 id="COMPACT-行格式"><a href="#COMPACT-行格式" class="headerlink" title="COMPACT 行格式"></a>COMPACT 行格式</h4><p>在 MySQL 5.1 版本中，默认设置为 Compact 行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/compact%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="compact行格式示意图"></p>
<p><strong>变长字段长度列表</strong></p>
<p>MySQL 支持一些变长的数据类型，比如 VARCHAR(M)、VARBINARY(M)、TEXT 类型，BLOB 类型，这些数据类型修饰列称为变长字段，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。在 Compact 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。</p>
<blockquote>
<p>注意：这里面存储的变长长度和字段顺序是反过来的。比如两个 varchar 字段在表结构的顺序是 a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是 15，10，是反过来的。</p>
</blockquote>
<p>以 record_test_table 表中的第一条记录举例：因为 record_test_table 表的 col1、col2、col4 都是 VARCHAR(8) 类型的，所以这三个列的值的长度都需要保存在记录开头处，注意 record_test_table 表中的各个列都使用的是 ascii 字符集 (每个字符只需要 1 字节来进行编码)。</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>存储内容</th>
<th>内容长度 (十进制表示)</th>
<th>内容长度 (十六进制表示)</th>
</tr>
</thead>
<tbody><tr>
<td>col1</td>
<td>‘zhangsan’</td>
<td>8</td>
<td>0x88</td>
</tr>
<tr>
<td>col2</td>
<td>‘lisi’</td>
<td>4</td>
<td>0x04</td>
</tr>
<tr>
<td>col4</td>
<td>‘laji’</td>
<td>6</td>
<td>0x06</td>
</tr>
</tbody></table>
<p>又因为这些长度值需要按照列的逆序存放，所以最后变长字段长度列表的字节串用十六进制表示的效果就是 (各个字节之间实际上没有空格，用空格隔开只是方便理解)：06 04 08</p>
<p>把这个字节串组成的变长字段长度列表填入上边的示意图中的效果就是：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/compact%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-1.png" alt="compact行格式示意图"></p>
<p><strong>NULL 值列表</strong></p>
<p>Compact 行格式会把可以为 NULL 的列统一管理起来，存在一个标记为 NULL 值列表中。如果表中没有允许存储 NULL 的列，则 NULL 值列表也不存在了。</p>
<p>为什么定义 NULL 值列表？</p>
<p>之所以要存储 NULL 是因为数据都是需要对齐的，如果没有标注出来 NULL 值的位置，就有可能在查询数据的时候出现混乱。如果使用一个特定的符号放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据的头部开辟出一块空间专门用来记录改行数据哪些是非空数据，哪些是空数据，格式如下：</p>
<ul>
<li>二进制位的值为 1 时，代表该列的值为 NULL。</li>
<li>二进制位的值为 0 时，代表该列的值不为 NULL。</li>
</ul>
<p>例如：字段 a、b、c，其中 a 是主键，在某一行中存储的数依次是 a &#x3D; 1、b &#x3D; null、c &#x3D; 2。那么 Compact 行格式中的 NULL 值列表中存储：01。第一个 0 表示 c 不为 null，第二个 1 表示 b 是 null。这里之所以没有 a 是因为数据库会自动跳过主键，因为主键肯定是非 NULL 且唯一的，在 NULL 值列表的数据中就会自动跳过主键。</p>
<p>record_test_table 的两条记录的 NULL 值列表就如下：</p>
<p>第一条记录：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%AC%AC%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95.png" alt="第一条记录"></p>
<p>第二条记录：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%AC%AC%E4%BA%8C%E6%9D%A1%E8%AE%B0%E5%BD%95.png" alt="第二条记录"></p>
<p><strong>记录头信息</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> page_demp(</span><br><span class="line">	c1 <span class="type">INT</span>,</span><br><span class="line">  c2 <span class="type">INT</span>,</span><br><span class="line">  c3 <span class="type">VARCHAR</span>(<span class="number">10000</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> kEY(c1)</span><br><span class="line">)CHARSET<span class="operator">=</span>ascii ROW_FORMAT<span class="operator">=</span>Compact;</span><br></pre></td></tr></table></figure>

<p>这个表中的记录的行格式示意图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="行格式示意图"></p>
<p>这些记录头信息中各个属性如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小 (单位：bit)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>预留位 1</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>预留位 2</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>B+ 树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表示当前记录的类型，0 表示普通记录，1 表示 B+ 树非叶子节点记录，2 表示最小记录，3 表示最大记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>表示下一条记录的相对位置</td>
</tr>
</tbody></table>
<p>简化后的行格式示意图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%AE%80%E5%8C%96%E5%90%8E%E7%9A%84%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="简化后的行格式示意图"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demp</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">100</span>, <span class="string">&#x27;song&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;tong&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="number">300</span>, <span class="string">&#x27;zhan&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="number">400</span>, <span class="string">&#x27;lisi&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/page_demo%E6%95%B0%E6%8D%AE.png" alt="page_demo数据"></p>
<ul>
<li><p>delete_mask</p>
<p>  这个属性标记着当前记录是否被删除，占用 1 个二进制位。</p>
<ul>
<li>值为 0：代表记录并没有被删除</li>
<li>值为 1:代表记录被删除</li>
</ul>
<p>  被删除的记录为什么还在页中存储呢？</p>
<p>  你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其它的记录在磁盘上需要重新排列，导致性能消耗。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为可重用空间，之后如果有新纪录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</p>
</li>
<li><p>min_rec_mask</p>
<p>  B+ 树的每层非叶子节点中最小记录都会添加该标记，min_rec_mask 值为 1。我们自己插入的四条记录 min_rec_mask 值都是 0，意味着他们都不是 B+ 树的非叶子节点中的最小记录。</p>
</li>
<li><p>record_type</p>
<p>  这个属性表示当前记录的类型，一共有 4 种类型的记录：</p>
<p>  0：表示普通记录</p>
<p>  1：表示 B+ 树非叶子节点记录</p>
<p>  2：表示最小记录</p>
<p>  3：表示最大记录</p>
<p>  从图中我们可以看出来，我们自己插入的记录就是普通记录，它们的 record_type 值都是 0，而最小记录和最大记录的 record_type 值分别为 2 和 3。</p>
</li>
<li><p>heap_no</p>
<p>  这个属性表示当前记录在本页中的位置。</p>
<p>  从图中可以看出来，我们插入的 4 条记录在本页中的位置分别是：2、3、4、5。</p>
<p>  怎么不见 heap_no 值为 0 和 1 的记录呢？</p>
<p>  MySQL 会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录。最小记录和最大记录的 heap_no 值分别是 0 和 1，也就是说它们的位置最靠前。</p>
</li>
<li><p>n_owned</p>
<p>  页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。</p>
</li>
<li><p>next_record</p>
<p>  记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。</p>
<p>  比如：第一条记录的 next_record 值为 32，意味着从第一条记录的真实数据的地址处向后找 32 个字节便是下一条记录的真实数据。</p>
<p>  注意，下一条记录指的并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 Infimum 记录 (也就是最小记录) 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum 记录 (也就是最大记录)。下图用箭头代替偏移量表示 next_record。</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/next_record%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="next_record示意图"></p>
<ul>
<li><p>删除操作</p>
<p>  从表中删除掉一条记录，这个链表也是会跟着变化：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> page_demo <span class="keyword">WHERE</span> c1 <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>  删掉第二条记录后的示意图就是：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="删除操作示意图"></p>
<p>  从图中可以看出来，删除第二条记录前后主要发生了这些变化：</p>
<ul>
<li>第二条记录并没有从存储空间中移除，而是把该记录的 delete_mask 值设置为 1。</li>
<li>第二条记录的 next_record 值变为了 0，意味着该记录没有下一条记录了。</li>
<li>第一条记录的 next_record 指向了第三条记录。</li>
<li>最大记录的 n_owned 值从 5 变成了 4。</li>
</ul>
<p>  所以，不论我们怎么对页中的记录做增删改操作，InnoDB 始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。</p>
</li>
<li><p>添加操作</p>
<p>  主键值为 2 的记录被我们删掉了，但是存储空间却没有回收，如果再次把这条记录插入到表中，会发生什么事呢？</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;tong&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>  看一下记录的存储情况：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="添加操作示意图"></p>
<p>  直接服用了原来被删除记录的存储空间。</p>
<p>  说明：</p>
<p>  当数据页中存在多条被删掉的记录时，这些记录的 next_record 属性将会把这些被删除的记录组成一个垃圾链表，以备之后重用这部分存储空间。</p>
</li>
</ul>
</li>
</ul>
<p><strong>记录的真实数据</strong></p>
<p>记录的真实数据除了我们自己定义的列的数据以外，还会有三个隐藏列：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>是否必须</th>
<th>占用空间</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>row_id</td>
<td>否</td>
<td>6 字节</td>
<td>行 ID，唯一标识一条记录</td>
</tr>
<tr>
<td>transaction_id</td>
<td>是</td>
<td>6 字节</td>
<td>事务 ID</td>
</tr>
<tr>
<td>roll_pointer</td>
<td>是</td>
<td>7 字节</td>
<td>回滚指针</td>
</tr>
</tbody></table>
<p>实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR。</p>
<ul>
<li>一个表没有手动定义主键，则会选取一个 Unique 键作为主键，如果连 Unique 键都没有定义的话，则会为表默认添加一个名为 row_id 的隐藏列作为主键。所以 row_id 是在没有自定义主键以及 Unique 键的情况下才会存在的。</li>
<li>事务 ID 和回滚指针在后面描述</li>
</ul>
<h4 id="Dynamic-和-Compressed-行格式"><a href="#Dynamic-和-Compressed-行格式" class="headerlink" title="Dynamic 和 Compressed 行格式"></a>Dynamic 和 Compressed 行格式</h4><p><strong>行溢出</strong></p>
<p>InnoDB 存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。</p>
<p>很多 DBA 喜欢 MySQL 数据库提供的 VARCHAR(M) 类型，认为可以存放 65535 字节。这是真的吗？如果我们使用 ascii 字符集的话，一个字符就代表一个字节，我们看看 VARCHAR(65535) 是否可用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> varchar_size_demo(c <span class="type">VARCHAR</span>(<span class="number">65535</span>)) CHARSET <span class="operator">=</span> ascii ROW_FORMAT <span class="operator">=</span> Compact;</span><br><span class="line"># 结果如下：</span><br><span class="line">ERROR <span class="number">1118</span> (<span class="number">42000</span>): <span class="type">Row</span> size too large.</span><br></pre></td></tr></table></figure>

<p>报错的信息表达的意思是：MySQL 对一条记录占用的最大存储空间是有限制的，除 BLOB 或 TEXT 类型的列之外，其他所有的列 (不包含隐藏列和记录头信息) 占用的字节长度加起来不能超过 65535 个字节。</p>
<p>这个 65535 个字节除了列本身的数据之外，还包括一些其它的数据，以 Compact 行格式为例，比如我们为了存储一个 VARCHAR(M) 类型的列，除了真实数据占有空间以外，还需要记录的额外信息。</p>
<p>如果该 VARCHAR 类型的列没有 NOT NULL 属性，那最多只能存储 65532 个字节的数据， 因为变长字段的长度占用 2 个字节，NULL 值标识需要占用 1 个字节。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> varchar_size_demo(c <span class="type">VARCHAR</span>(<span class="number">65532</span>)) CHARSET <span class="operator">=</span> ascii ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure>

<p>如果有 NOT NULL 属性，那么就不需要 NULL 值标识，也就可以多存储一个字节，即 65533 个字节。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> varchar_size_demo(c <span class="type">VARCHAR</span>(<span class="number">65533</span>) <span class="keyword">not</span> <span class="keyword">null</span>) CHARSET <span class="operator">=</span> ascii ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure>

<p>通过上面的案例，我们可以知道一个页的大小一般是 16KB，也就是 16384 字节，而一个 VARCHAR(M) 类型的列就最多可以存储 65533 个字节，这样就可能出现一个页存放不了一条记录，这种现象称为行溢出。</p>
<p>在 Compact 和 Redundant 行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行分也存储，然后记录的真实数据处用 20 个字节存储指向这些页的地址 (当然这 20 个字节中国呢还包括这些分散在其他页面中的数据的占用的字节数)，从而可以找到剩余数据所在的页。这称为页的扩展，举例如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E9%A1%B5%E7%9A%84%E6%89%A9%E5%B1%95.png" alt="页的扩展"></p>
<p>在 MySQL 8.0 中，默认行格式就是 Dynamic，Dynamic、Compressed 行格式和 Compact 行格式挺像，只不过在处理行溢出数据时有分歧：</p>
<ul>
<li>Compressed 和 Dynamic 两种记录格式对于存放在 BLOB 中的数据采用了完全的行溢出的方式。如图，在数据页中只存放 20 个字节的指针 (溢出页的地址)，实际的数据都存放在 Off Page (溢出页) 中。</li>
<li>Compact 和 Redundant 两种格式会在记录的真实数据处存储一部分数据 (存放 768 个前缀字节)。</li>
</ul>
<p>Compressed 行记录格式的另一个功能就是，存储在其中的行数据会以 zlib 的算法进行压缩，因此对于 BLOB、TEXT、VARCHAR 这类大长度类型的数据能够进行非常有效的存储。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/Compressed%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F.png" alt="Compressed行记录格式"></p>
<h4 id="Redundant-行格式"><a href="#Redundant-行格式" class="headerlink" title="Redundant 行格式"></a>Redundant 行格式</h4><p>Redundant 是 MySQL 5.0 版本之前 InnoDB 的行记录存储方式，MySQL 5.0 支持 Redundant 是为了兼容之前版本的页格式。</p>
<p>现在我们把表 record_test_table 的行格式修改为 Redundant：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> recoord_test_table ROW_FORMAT <span class="operator">=</span> Redundant;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/Redundant%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Redundant行格式示意图"></p>
<p>从上图可以看到，不同于 Compact 行记录格式，Redundant 行格式的首部是一个字段长度偏移列表，同样是按照列的顺序逆序放置的。</p>
<h3 id="区、段与碎片区"><a href="#区、段与碎片区" class="headerlink" title="区、段与碎片区"></a>区、段与碎片区</h3><h4 id="为什么要有区？"><a href="#为什么要有区？" class="headerlink" title="为什么要有区？"></a>为什么要有区？</h4><p>B+ 树的每一层中的页都会形成一个双向链表，如果是以页为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。我们介绍 B+ 树索引的使用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的随机 I&#x2F;O。再一次强调，磁盘的速度和内存的速度差了好几个数量级，随机 I&#x2F;O 是非常慢的，所以我们应该尽量让链表中相邻的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的顺序 I&#x2F;O。</p>
<p>引入区的概念，一个区就是在物理位置上连续的 64 个页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB&#x3D;1MB。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费 (数据不足以填充满整个区)，但是从性能角度看，可以消除很多的随机 I&#x2F;O，功大于过。</p>
<h4 id="为什么要有段？"><a href="#为什么要有段？" class="headerlink" title="为什么要有段？"></a>为什么要有段？</h4><p>对于范围查询，其实是对 B+ 树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以 InnoDB 对 B+ 树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点由自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段 (segment)，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成两个段，一个叶子节点段，一个非叶子节点段。</p>
<p>除了索引的叶子节点段和非叶子节点段之外，InnoDB 中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段友数据段、索引段、回滚段。数据段即为 B+ 树的叶子节点，索引段即为 B+ 树的非叶子节点。</p>
<p>在 InnoDB 存储引擎中，对段的管理都是由引擎自身所完成的，DBA 不能也没有必要对其进行控制。这从一定程度上简化了 DBA 对于段的管理。</p>
<p>段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p>
<h4 id="为什么要有碎片区？"><a href="#为什么要有碎片区？" class="headerlink" title="为什么要有碎片区？"></a>为什么要有碎片区？</h4><p>默认情况下，一个使用 InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成两个段，而段是以区为单位申请存储空间的，一个区默认占用 1M (64 * 16KB&#x3D; 1024KB) 存储空间，所以默认情况下一个只存了几条记录的小表也需要 2M 的存储空间么？以后每次添加一个索引都要多申请 2M 的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常纯粹的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。</p>
<p>为了考虑以完整的区为单位分配给某个段对于数据量小的表太浪费存储空间的情况，InnoDB 提出了一个碎片 (fragment) 区的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段 A，有些页用于段 B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。</p>
<p>所以此后为某个段分配存储空间的策略是这样的：</p>
<ul>
<li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li>
<li>当某个段已经占用了 32 个碎片区页面之后，就会申请以完整的区为单位来分配存储空间。</li>
</ul>
<p>所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。</p>
<h4 id="区的分类"><a href="#区的分类" class="headerlink" title="区的分类"></a>区的分类</h4><p>区大体上可以分为四种类型：</p>
<ul>
<li>空闲的区 (FREE)：现在还没有用到这个区中的任何页面。</li>
<li>有剩余空间的碎片区 (FREE_FRAG)：表示碎片区中还有可用的页面。</li>
<li>没有剩余空间的碎片区 (FULL_FRAG)：表示碎片区中的所有页面都被使用，没有空闲页面。</li>
<li>附属于某个段的区 (FSEG)：每一个索引都可以分为叶子节点段和非叶子节点段。</li>
</ul>
<p>处于 FREE、FREE_FRAG 以及 FULL_FRAG 这三种状态的区都是独立的，直属于表空间。而处于 FSEG 状态的区市附属于某个段的。</p>
<blockquote>
<p>如果把表空间比作是一个集团军，段就相当于师，区就相当于团。一般的团都是隶属于某个师的，就像是处于 FSEG 的区全都隶属于某个段，而处于 FREE、FREE_FRAG 和 FULL_FRAG 这三种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样。</p>
</blockquote>
<h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>表空间可以看做是 InnoDB 存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。</p>
<p>表空间是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。表空间数据库有一个或多个表空间组成，表空间从管理上可以划分为系统表空间 (System tablespace)、独立表空间 (File-per-table tablespace)、撤销表空间 (Undo Tablespace) 和临时表空间 (Temporary Tablespace) 等。</p>
<h4 id="独立表空间"><a href="#独立表空间" class="headerlink" title="独立表空间"></a>独立表空间</h4><p>独立表空间，即每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间 (即：单表) 可以在不同的数据库之间进行迁移。</p>
<p>空间可以回收 (DROP TABLE 操作可以自动回收表空间；其他情况，表空间不能自己回收)。如果对于统计分析或事日志表，删除大量数据后可以通过：<code>alter table TableName engine=innodb</code>；回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。</p>
<p><strong>独立表空间结构</strong></p>
<p>独立表空间由段、区、页组成。</p>
<p><strong>真实表空间对应的文件大小</strong></p>
<p>我们到数据目录里看，会发现一个新建的表对应的 <code>.ibd</code> 文件只占用了 96k，才 6 个页面大小 (MySQL 5.7中)，这是因为一开始表空间占用的空间很小，因为表里边都没有数据。不过别忘了这些 .ibd 文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。</p>
<p><strong>查看 InnoDB 的表空间类型：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_file_per_table&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>你能看到 innodb_file_per_table&#x3D;ON，这就意味着每张表都会单独保存为一个 .ibd 文件。</p>
<h4 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h4><p>系统表空间的结构和独立表空间基本类似，只不过由于整个 MySQL 进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。</p>
<p><strong>InnoDB 数据字典</strong></p>
<p>每当我们向一个表中插入一条记录的时候，MySQL 检验过程如下：</p>
<p>先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的 B+ 树中。所以说，MySQL 除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说：</p>
<ul>
<li>某个表属于哪个表空间，表里边有多少列</li>
<li>表对应的每一个列的类型是什么</li>
<li>该表有多少索引，每个索引对应哪几个字段，该索引对应的跟页面在哪个表空间的哪个页面</li>
<li>该表有哪些外键，外键对应哪个表的哪些列</li>
<li>某个表空间对应文件系统上文件路径是什么</li>
<li>……</li>
</ul>
<p>上述这些数据并不是我们使用 INSERT 语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为元数据。InnoDB存储引擎特意定义了一些列的内部系统表 (internal system table) 来记录这些元数据：</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SYS_TABLES</td>
<td>整个 InnoDB 存储引擎中所有的表的信息</td>
</tr>
<tr>
<td>SYS_COLUMNS</td>
<td>整个 InnoDB 存储引擎中所有的列的信息</td>
</tr>
<tr>
<td>SYS_INDEXES</td>
<td>整个 InnoDB 存储引擎中所有的索引的信息</td>
</tr>
<tr>
<td>SYS_FIELDS</td>
<td>整个 InnoDB 存储引擎中所有的索引对应的列的信息</td>
</tr>
<tr>
<td>SYS_FOREIGN</td>
<td>整个 InnoDB 存储引擎中所有的外键的信息</td>
</tr>
<tr>
<td>SYS_FOREIGN_COLS</td>
<td>整个 InnoDb 存储引擎中所有的外键对应的信息</td>
</tr>
<tr>
<td>SYS_TABLESPACES</td>
<td>整个 InnoDB 存储引擎中所有的表空间信息</td>
</tr>
<tr>
<td>SYS_DATAFILES</td>
<td>整个 InnoDB 存储引擎中所有的表空间对应文件系统的文件路径信息</td>
</tr>
<tr>
<td>SYS_VIPTUAL</td>
<td>整个 InnoDB 存储引擎中所有的虚拟生成列的信息</td>
</tr>
</tbody></table>
<p>这些系统表也被称为数据字典，它们都是以 B+ 树的形式保存在系统表空间的某些页面中，其中SYS_TABLES、SYS_COLUMNS、SYS_INDEXES、SYS_FIELDS 这四个表尤其重要，称之为基本系统表 (basic system tables)，我们先看看这四个表的结构：</p>
<p><strong>SYS_TABLES 表结构</strong></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>NAME</td>
<td>表的名称。主键</td>
</tr>
<tr>
<td>ID</td>
<td>InnoDB 存储引擎中每个表都有一个唯一的ID。(二级索引)</td>
</tr>
<tr>
<td>N_COLS</td>
<td>该表拥有列的个数</td>
</tr>
<tr>
<td>TYPE</td>
<td>表的类型，记录了一些文件格式、行格式、压缩等信息</td>
</tr>
<tr>
<td>MIX_ID</td>
<td>已过时，忽略</td>
</tr>
<tr>
<td>MIX_LEN</td>
<td>表的一些额外的属性</td>
</tr>
<tr>
<td>CLUSTER_ID</td>
<td>未使用，忽略</td>
</tr>
<tr>
<td>SPACE</td>
<td>该表所属表空间的ID</td>
</tr>
</tbody></table>
<p><strong>SYSCOLUMNS 表结构</strong></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>TABLE_ID</td>
<td>该列所属表对应的 ID。</td>
</tr>
<tr>
<td>POS</td>
<td>该列在表中是第几列</td>
</tr>
<tr>
<td>NAME</td>
<td>该列的名称</td>
</tr>
<tr>
<td>MTYPE</td>
<td>main data type，主数据类型，就是那堆 INT、CHAR、VARCHAR、FLOAT、DOUBLE 之类的东东</td>
</tr>
<tr>
<td>PRTYPE</td>
<td>precise type，精确数据类型，就是修饰主数据类型的那堆东东，比如是否允许 NULL 值，是否允许负数啥的</td>
</tr>
<tr>
<td>LEN</td>
<td>该列最多占用存储空间的字节数</td>
</tr>
<tr>
<td>PREC</td>
<td>该列的精度，不过这列貌似都没有使用，默认值都是 0</td>
</tr>
</tbody></table>
<p><strong>SYS_INDEXES 表结构</strong></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>TABLE_ID</td>
<td>该索引所属表对应的ID</td>
</tr>
<tr>
<td>ID</td>
<td>InnoDB 存储引擎中每个索引都有一个唯一的 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>该索引的名称</td>
</tr>
<tr>
<td>M_FIELDS</td>
<td>该索引包含列的个数</td>
</tr>
<tr>
<td>TYPE</td>
<td>该索引的类型，比如聚簇索引、唯一索引、更改缓冲区的索引、全文索引、普通的二级索引等等各种类型</td>
</tr>
<tr>
<td>SPACE</td>
<td>该索引根页面所在的表空间</td>
</tr>
<tr>
<td>PAGE_NO</td>
<td>该索引根页面所在的页面号</td>
</tr>
<tr>
<td>MERGE_THRESHOLD</td>
<td>如果页面中的记录被删除到某个比列，就把该页面和相邻页面合并，这个值就是这个比例</td>
</tr>
</tbody></table>
<p><strong>SYS_FIELDS 表结构</strong></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>INDEX_ID</td>
<td>该索引列所属的索引的ID</td>
</tr>
<tr>
<td>POS</td>
<td>该索引列在某个索引中是第几列</td>
</tr>
<tr>
<td>COL_NAME</td>
<td>该索引列的名称</td>
</tr>
</tbody></table>
<p>注意：用户是不能直接访问 InnoDB 的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。不过考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库 information_schema 中提供了一些以 innodb_sys 开头的表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use information_schema;</span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">like</span> <span class="string">&#x27;innodb_sys%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在 information_schema 数据库中的这些以 INNODB_SYS 开头的表并不是真正的内部系统表 (内部系统表就是我们上边以 SYS 开头的那些表)，而是在存储引擎启动时读取这些以 SYS 开头的系统表，然后填充到这些以 INNODB_SYS 开头的表中。以 INNODB_SYS 开头的表和以 SYS 开头的表中的字段并不完全一样，但供参考已经足矣。</p>
<h3 id="附录：数据页加载的三种方式"><a href="#附录：数据页加载的三种方式" class="headerlink" title="附录：数据页加载的三种方式"></a>附录：数据页加载的三种方式</h3><p>InnoDB 从磁盘中读取数据的最小单位是数据页。而你想得到的 id &#x3D; xxx 的数据，就是这个数据页众多行中的一行。对于 MySQL 存放的数据，逻辑概念上我们称之为表，在磁盘等物理层面而言是按数据页形式进行存放的，当其加载到 MySQL 中我们称之为缓存页。</p>
<p>如果缓冲池中没有该页数据，那么缓冲池有以下三种读取数据的方式，每种方式的读取效率都是不同的：</p>
<h4 id="内存读取"><a href="#内存读取" class="headerlink" title="内存读取"></a>内存读取</h4><p>如果该数据存在于内存中，基本上执行时间在 1ms 左右，效率还是很高的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E5%86%85%E5%AD%98%E8%AF%BB%E5%8F%96.png" alt="内存读取"></p>
<h4 id="随机读取"><a href="#随机读取" class="headerlink" title="随机读取"></a>随机读取</h4><p>如果数据没有在内存中，就需要在磁盘上对该页进行查找，整体时间预估在 10ms 左右，这 10ms 中有 6ms 是磁盘的实际繁忙时间 (包括了寻到和半圈旋转时间)，有 3ms 是对可能发生的排队时间的估计值，另外还有 1ms 的传输时间，将页从磁盘服务缓冲区传输到数据缓冲区中。这 10ms 看起来很快，但实际上对于数据库来说消耗的时间已经非常长了，因为这还只是一个页的读取时间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%8F%96.png" alt="随机读取"></p>
<h4 id="顺序读取"><a href="#顺序读取" class="headerlink" title="顺序读取"></a>顺序读取</h4><p>顺序读取其实是一种批量读取的方式，因为我们请求的数据在磁盘上往往都是相邻存储的，顺序读取可以帮我们批量读取页面，这样的话，一次性加载到缓冲池中就不需要再对其他页面单独进行磁盘 I&#x2F;O 操作了。如果一个磁盘的吞吐量是 40MB&#x2F;S，那么对于一个 16KB 大小的页来说，一次可以顺序读取 2560 (40MB&#x2F;16KB) 个页，相当于一个页的读取时间为 0.4ms。采用批量读取的方式，即使是从磁盘上进行读取，效率也比从内存中只单独读取一个页的效率要高。</p>
<h2 id="索引的创建与设计原则"><a href="#索引的创建与设计原则" class="headerlink" title="索引的创建与设计原则"></a>索引的创建与设计原则</h2><h3 id="索引的生命与使用"><a href="#索引的生命与使用" class="headerlink" title="索引的生命与使用"></a>索引的生命与使用</h3><h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><p>MySQL 的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p>
<ul>
<li>从功能逻辑上说，索引主要有四种，分别是普通索引、唯一索引、主键索引、全文索引。</li>
<li>按照物理实现方式，索引可以分为两种：聚簇索引和非聚簇索引。</li>
<li>按照作用字段个数进行划分，分成单列索引和联合索引。</li>
</ul>
<p><strong>普通索引</strong>：</p>
<p>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在任何数据类型中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表 student 的字段 name 上建立一个普通索引，查询记录时就可以根据该索引进行查询。</p>
<p><strong>唯一性索引</strong>：</p>
<p>使用 UNIQUE 可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里可以有多个唯一索引。</p>
<p>例如，在表 student 的字段 email 中创建唯一性索引，那么字段 email 的值就必须是唯一的。通过唯一性索引，可以更快速地确定某条记录。</p>
<p><strong>主键索引</strong></p>
<p>主键索引就是一种特殊的 唯一性索引，在唯一索引的基础上增加了不为空的约束，也就是 NOT NULL + UNIQUE，一张表里最多只有一个主键索引。这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</p>
<p><strong>单列索引</strong></p>
<p>在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。</p>
<p><strong>多列 (组合、联合) 索引</strong></p>
<p>多列索引是在表的多个字段组合上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段 id、name 和 gender 上建立一个多列索引 idx_id_name_gender，只有在查询条件中使用了字段 id 时该索引才会被使用。使用组合索引时遵循最左前缀集合。</p>
<p><strong>全文索引</strong></p>
<p>全文索引 (也称全文检索) 是目前搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</p>
<p>使用参数 FULL TEXT 可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引只能创建在 CHAR、VARCHAR 或 TEXT 类型及其系列类型的字段上，<strong>查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度</strong>。例如，表 student 的字段 information 是 TEXT 类型，该字段包含了很多文字信息。在字段 information 上建立全文索引后，可以提高查询字段 information 的速度。</p>
<p>全文索引典型的两种类型：自然语言的全文索引和布尔全文索引。</p>
<ul>
<li>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。<strong>在整个索引中出现次数越少的词语，匹配时的相关度就越高</strong>。相反，非常常见的单词将不会被搜索，如果一个词语的在超过 50% 的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。</li>
</ul>
<p>MySQL 数据库从 3.23.23 版本开始支持全文索引，但 MySQL 5.6.4 以前只有 MyISAM 支持，5.6.4 版本以后 InnoDB 才支持，但是官方版本不支持中文分词，需要第三方分词插件。在 5.7.6 版本，MySQL 内置了 ngram 全文解析器，用来支持亚洲语种的分词。测试或使用全文索引时，要先看一下自己的 MySQL 版本、存储引擎和数据类型是否支持全文索引。</p>
<p>随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被 solr、ElasticSearch 等专门的搜索引擎所替代。</p>
<p><strong>空间索引</strong></p>
<p>使用参数 SPATIAL 可以设置索引为空间索引。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL 中的空间数据类型包括 GEOMETRY、POINT、LINESTRING 和 POLYGON 等。目前只有 MyISAM 存储引擎支持空间检索，而且索引的字段不能为空值。对于初学者来说，这类索引很少会用到。</p>
<p><strong>小结</strong>：</p>
<ul>
<li>InnoDB：支持 B-Tree、Full-text 等索引，不支持 Hash 索引；</li>
<li>MyISAM：支持 B-Tree、Full-text 等索引，不支持 Hash 索引；</li>
<li>Memory：支持 B-Tree、Hash 等索引，不支持 Full-text 索引；</li>
<li>NDB：支持 Hash 索引，不支持 B-Tree、Full-text 等索引；</li>
<li>Archive：不支持 B-Tree、Hash、Full-text 等索引。</li>
</ul>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>MySQL 支持多种 方法在单个或多个列上创建索引：在创建表的定义语句 CREATE TABLE 中指定索引列，使用 ALTER TABLE 语句在存在的表上创建索引，或者使用 CREATE INDEX 语句在已存在的表上添加索引。</p>
<p><strong>创建表的时候创建索引</strong></p>
<p>使用 CREATE TABLE 创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外键约束或者唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">	dept_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">	emp_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  emp_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">  dept_id <span class="type">INT</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> emp_dept_id_fk <span class="keyword">FOREIGN</span> KEY(dept_id) <span class="keyword">REFERENCES</span> dept(dept_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>但是，如果现实创建表时创建索引的话，基本语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name [col_name data_type]</span><br><span class="line">[<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY] [index_name] (col_name [length]) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>UNIQUE、FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引；</li>
<li>INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引；</li>
<li>index_name 指定索引的名称，为可选参数，如果不指定，那么 MySQL 默认 col_name 为索引名；</li>
<li>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</li>
<li>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</li>
<li>ASC 或 DESC 指定生序或者降序的索引值存储。</li>
</ul>
<p><strong>创建普通索引</strong></p>
<p>在 book 表中的 year_publication 字段上建立普通索引，SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book(</span><br><span class="line">	book_id <span class="type">INT</span>,</span><br><span class="line">  book_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  authors <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  info <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  comment <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  year_publication <span class="keyword">YEAR</span>,</span><br><span class="line">  INDEX(year_publication)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>通过命令查看索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>

<p>使用 EXPLAIN 语句查看索引是否正在使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> year_publication <span class="operator">=</span> <span class="string">&#x27;1997&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>EXPLAIN 语句输出结果：</p>
<ul>
<li>possible_keys 行给出了 MySQL 在搜索数据记录时可选用的各个索引</li>
<li>key 行是 MySQL 实际选用的索引。</li>
</ul>
<p>可以看到，possible_keys 和 key 的值都为 year_publication，查询时使用了索引。</p>
<p><strong>创建唯一索引</strong></p>
<p>创建唯一索引的目的也是减少查询索引列操作的执行时间，尤其是对比较庞大的数据表。它与前面的普通索引类似，不同的是，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX idx_id(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用 <code>SHOW CREATE TABLE</code> 查看表结构。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure>

<p>其中各个主要参数的含义为：</p>
<ul>
<li>Table 表示创建索引的表</li>
<li>Non_unique 表示索引非唯一，1 代表非唯一索引，0 代表唯一索引。</li>
<li>Key_name 表示索引的名字。</li>
<li>Seq_in_index 表示该字段在索引中的位置，单列索引该值为 1，组合索引为每个字段在索引定义中的顺序。</li>
<li>Column_name 表示定义索引的列字段。</li>
<li>Sub_part 表示索引的长度。</li>
<li>Null 表示该字段是否能为空值。</li>
<li>Index_type 表示索引类型</li>
</ul>
<p>由结果可以看到，id 字段上已经成功建立了一个名为 idx_id 的唯一索引。</p>
<p><strong>主键索引</strong></p>
<p>设定为主键后数据库会自动建立索引，innodb 为聚簇索引，语法：</p>
<ul>
<li><p>随表一起建索引：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">	id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED AUTO_INCREMENT,</span><br><span class="line">  student_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  student_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除主键索引</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主键索引：必须先删除掉 (drop) 原索引，再新建 (add) 索引</p>
</li>
</ul>
<p><strong>创建单列索引</strong></p>
<p>单列索引是在数据表中的某一个字段上创建的索引，一个表中可以创建多个单列索引，前面例子中创建的索引都为单列索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  INDEX aingle_idx_name(name(<span class="number">20</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用 <code>SHOW CREATE TABLE</code> 查看表结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure>

<p>由结果可以看到，id 字段上已经成功建立了一个名为 single_idx_name 的单列索引。索引长度为 20。</p>
<p><strong>创建组合索引</strong></p>
<p>组合索引是在多个字段上创建一个索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(</span><br><span class="line">	id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  INDEX mul_idx(id, name, age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用 SHOW INDEX 查看：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure>

<p>由结果可以看到，id、name 和 age 字段上已经成功建立了一个名为 mul_idx 的组合索引。</p>
<p>组合索引可起几个索引的作用，但是使用时并不是随便查询哪个字段都可以使用索引，而是遵从“最左前缀”。例如，索引可以搜索的字段组合为：(id, name, age)、(id, name) 或者 id。而 age 或者 (name, age) 组合不能使用索引查询。</p>
<p>在 test 表中，查询 id 和 name 字段，使用 EXPLAIN 语句查看索引的使用情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> name <span class="operator">=</span> <span class="string">&#x27;zhangsan&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到，查询 id 和 name 字段时，使用了名称为 mul_idx 的索引，如果查询 (name, age) 组合或者单独查询 name 和 age 字段，会发现结果中 possible_keys 和 key 值为 NULL，并没有使用在 test 表中创建的索引进行查询。</p>
<p><strong>创建全文索引</strong></p>
<p>FULLTEXT 全文索引可以用于全文搜索，并且只为 CHAR、VARCHAR 和 TEXT 列创建索引。索引总是对整个列进行，不支持局部 (前缀) 索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  age <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  FULLTEXT INDEX futxt_idx_info(info)</span><br><span class="line">)ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 MySQL 5.7 及之后版本中可以不指定最后的 ENGINE 了，因为在此版本中 InnoDB 支持全文索引。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure>

<p>由结果可以看到，info 字段上已经成功建立了一个名为 futxt_idx_info 的 FULLTEXT 索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles(</span><br><span class="line">	id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  title <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  body TEXT,</span><br><span class="line">  FULLTEXT index(title, body)</span><br><span class="line">)ENGINE <span class="operator">=</span> INNODB;</span><br></pre></td></tr></table></figure>

<p>创建了一个给 title 和 body 字段添加全文索引的表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> papers(</span><br><span class="line">	id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  title <span class="type">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  content text,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  FULLTEXT KEY title (title, content)</span><br><span class="line">)ENGINE<span class="operator">=</span>MyISAM <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>不同于 like 方式的查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> content <span class="keyword">LIKE</span> <span class="string">&#x27;%查询字符串%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>全文索引用 match + against 方式查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, content) AGAINST (<span class="string">&#x27;查询字符串&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>明显的提高查询效率。</p>
<blockquote>
<p>注意点</p>
<ul>
<li>使用全文索引前，搞清楚版本支持情况；</li>
<li>全文索引比 like + % 快 N 倍，但是可能存在精度问题；</li>
<li>如果需要全文索引的是大量数据，建议先添加数据，再创建索引。</li>
</ul>
</blockquote>
<p><strong>创建空间索引</strong></p>
<p>空间索引创建中，要求空间类型的字段必须为非空。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(</span><br><span class="line">	geo GEOMETRY <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  SPATIAL INDEX spa_idx_geo(geo)</span><br><span class="line">)ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用 SHOW CREATE TABLE 查看表结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure>

<p>可以看到，test 表的 geo 字段上创建了名为 spa_idx_geo 的空间索引。注意创建时指定空间类型字段值的非空约束，并且表的存储引擎为MyISAM。</p>
<p><strong>使用 ALTER TABLE 语句创建索引</strong></p>
<p>ALTER TABLE 语句创建索引的基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY]</span><br><span class="line">[index_name] (col_name[length], ...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<p>与创建表时创建索引的语法不同的是，在这里使用了 ALTER TABLE 和 ADD 关键字，ADD 表示向表中添加索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">ADD</span> INDEX idx_bkname(book_name(<span class="number">30</span>));</span><br></pre></td></tr></table></figure>

<p><strong>使用 CREATE INDEX 创建索引</strong></p>
<p>CREATE INDEX 语句可以在意境存在的表上添加索引，在 MySQL 中，CREATE INDEX 被映射到一个 ALTER TABLE 语句上，基本语法结构为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span>SPATIAL] INDEX index_name </span><br><span class="line"><span class="keyword">ON</span> table_name (col_name[length], ...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_cmt <span class="keyword">ON</span> book(COMMENT);</span><br></pre></td></tr></table></figure>

<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p>MySQL 中删除索引使用 ALTER TABLE 或者 DROP INDEX 语句，两者可实现相同的功能，DROP INDEX 语句在内部被映射到一个 ALTER TABLE 语句中。</p>
<p><strong>使用 ALTER TABLE 删除索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示</p>
<p>添加 AUTO_INCREMENT 约束字段的唯一索引不能被删除。</p>
</blockquote>
<p><strong>使用 DROP INDEX 语句删除索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示</p>
<p>删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。</p>
</blockquote>
<h3 id="MySQL-8-0-索引新特性"><a href="#MySQL-8-0-索引新特性" class="headerlink" title="MySQL 8.0 索引新特性"></a>MySQL 8.0 索引新特性</h3><h4 id="支持降序索引"><a href="#支持降序索引" class="headerlink" title="支持降序索引"></a>支持降序索引</h4><p>降序索引以降序存储键值。虽然在语法上，从 MySQL 4 版本开始就已经支持降序索引的语法了，但实际上 DESC 定义是被忽略的，直到MySQL 8.x 版本才开始真正支持降序索引 (仅限于 InnoDB 存储引擎)。</p>
<p>MySQL 在 8.0 版本之前创建的仍然是生序索引，使用时进行反向扫描，这大大降低了数据库的效率。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。</p>
<p>分别在 MySQL 5.7 版本和 MySQL 8.0 版本中创建数据表 ts1</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ts1(a <span class="type">int</span>, b <span class="type">int</span>, index idx_a_b(a, b <span class="keyword">desc</span>));</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> ts1;</span><br></pre></td></tr></table></figure>

<p>从结果中可以看出，MySQL 5.7 版本中，索引仍然是默认的生序。而 MySQL 8.0 版本中，索引可以降序。分别插入 800 条随机数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ts_insert()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">	WHILE i <span class="operator">&lt;</span> <span class="number">800</span></span><br><span class="line">	DO</span><br><span class="line">		<span class="keyword">insert</span> <span class="keyword">into</span> ts1 <span class="keyword">select</span> rand() <span class="operator">*</span> <span class="number">80000</span>, rand() <span class="operator">*</span> <span class="number">80000</span>;</span><br><span class="line">		<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">END</span> WHILE;</span><br><span class="line">		<span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line"><span class="keyword">CALL</span> ts_insert();</span><br></pre></td></tr></table></figure>

<p>在 MySQL 5.7 版本中查看数据表 ts1 的执行计划，结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ts1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a, b <span class="keyword">DESC</span> LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，执行计划中扫描数为 799，而且使用了 Using filesort。</p>
<blockquote>
<p>提示</p>
<p>Using filesort 是 MySQL 中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员可以通过优化索引尽量避免出现 Using filesort，从而提高数据库执行速度。</p>
</blockquote>
<p>在 MySQL 8.0 版本中查看数据表 ts1 的执行计划。从结果可以看出，执行计划中扫描数为 5，而且没有使用 Using filesort。</p>
<blockquote>
<p>注意</p>
<p>降序索引支队查询中特定的排序顺序有效，如果使用不当，反而查询效率更低。例如，上述查询排序条件改为order by a desc, b desc，MySQL 5.7 的执行计划要明显好于 MySQL 8.0。</p>
</blockquote>
<p>将排序条件修改为 order by a desc, b desc 后，下面来对比不同版本中执行计划的效果。</p>
<p>在 MySQL 5.7 版本中查看数据表 ts1 的执行计划，结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ts1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a DEDC, b <span class="keyword">DESC</span> LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>在 MySQL 8.0 版本中查看数据表 ts1 的执行计划。</p>
<p>从结果可以看出，修改后 MySQL 5.7 的执行计划要明显好于 MySQL 8.0。</p>
<h4 id="隐藏索引"><a href="#隐藏索引" class="headerlink" title="隐藏索引"></a>隐藏索引</h4><p>在 MySQL 5.7 版本之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，有智能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。</p>
<p>从 MySQL 8.x 开始支持隐藏索引 (invisible indexes)，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引 (即使使用 force index (强制使用索引)，优化器也不会使用该索引)，确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。这种通过现将索引设置为隐藏索引，再删除索引的方式就是软删除。</p>
<p>同时，如果你想验证某个索引删除之后的查询性能影响，就可以暂时先隐藏该索引。</p>
<blockquote>
<p>注意：</p>
<p>主键不能被设置为隐藏索引。当表中没有显示主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引。</p>
</blockquote>
<p>索引默认是可见的，在使用 CREATE TABLE，CREATE INDEX 或 ALTER TABLE 等语句时可以通过 VISIBLE 或者 INVISIBLE 关键词设置索引的可见性。</p>
<p><strong>创建表时直接创建</strong></p>
<p>在 MySQL 中创建隐藏索引通过 SQL 语句 INVISIBLE 来实现，其语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename(</span><br><span class="line">	propname1 type1[CONSTRAINT1],</span><br><span class="line">	propname2 type2[CONSTRAINT2],</span><br><span class="line">	......</span><br><span class="line">	propname typen,</span><br><span class="line">  INDEX [indexname](propname1 [(length)] INVISIBLE)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上述语句比普通索引多了一个关键字 INVISIBLE，用来标记索引为不可见索引。</p>
<p><strong>在已经存在的表上创建</strong></p>
<p>可以为已经存在的表设置隐藏索引，其语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX indexname</span><br><span class="line"><span class="keyword">ON</span> tablename(propname[(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>

<p><strong>通过 ALTER TABLE 语句创建</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename</span><br><span class="line"><span class="keyword">ADD</span> INDEX indexname (propname [(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure>

<p><strong>切换索引可见状态</strong></p>
<p>已存在的索引可通过如下语句切换可见状态：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> INDEX index_name INVISIBLE; # 切换成隐藏索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> INDEX index_name VISIBLE; # 切换成非隐藏索引</span><br></pre></td></tr></table></figure>

<p>如果将 index_cname 索引切换成可见状态，通过 explain 查看执行计划，发现优化器选择了 index_cname 索引。</p>
<blockquote>
<p>注意</p>
<p>当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p>
</blockquote>
<p>通过设置隐藏索引的可见性可以查看索引对调优的帮助。</p>
<p><strong>使隐藏索引对查询优化器可见</strong></p>
<p>在 MySQL 8.x 版本中，为索引提供了一种新的方式，可以通过查询优化器的一个开关 (use_invisible_indexes) 来打开某个设置，使隐藏索引对查询优化器可见。如果 use_invisible_indexes 设置为 off (默认)，优化器会忽略隐藏索引。如果设置为 on，即使隐藏索引不可见，优化器在生成执行计划时仍然会考虑使用隐藏索引。</p>
<ul>
<li><p>在 MySQL 命令执行如下命令查看查询优化器的开关设置</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@optimizer</span>_switch \G</span><br></pre></td></tr></table></figure>

<p>  在输出的结果信息中找到如下属性配置。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_invisible_indexes<span class="operator">=</span>off</span><br></pre></td></tr></table></figure>

<p>  此属性配置值为 off，说明隐藏索引默认为对查询优化器不可见。</p>
</li>
<li><p>使隐藏索引对查询优化器可见，需要在 MySQL 命令执行如下命令：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION optimizer_switch<span class="operator">=</span>&quot;use_invisible_indexes=on&quot;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h3><p>为了使索引的使用效率更高，再创建索引时，必须考虑在那些字段上创建索引和创建什么类型的索引。<strong>索引设计不合理或缺少索引都会对数据库和应用程序的性能造成障碍</strong>。高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑相应准则。</p>
<h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE indextest;</span><br><span class="line">USE indextest;</span><br><span class="line">#创建学生表和课程表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_info(</span><br><span class="line">	id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  student_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  course_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  class_id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  create_time DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> course(</span><br><span class="line">	id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  course_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  course_name <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 函数<span class="number">1</span>:创建随机产生字符串函数</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>)</span><br><span class="line">	<span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>)	# 该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span></span><br><span class="line">	<span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line">		<span class="keyword">SET</span> return_str <span class="operator">=</span> CONCAT(return_str, <span class="built_in">SUBSTRING</span>(chars_str, <span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> RAND() <span class="operator">*</span> <span class="number">52</span>), <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">END</span> WHILE;</span><br><span class="line">	<span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建随机数函数</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num(from_num <span class="type">INT</span>, to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span> RAND() <span class="operator">*</span> (to_num <span class="operator">-</span> from_num <span class="operator">+</span> <span class="number">1</span>));</span><br><span class="line"><span class="keyword">RETURN</span> i;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p> 创建函数，假如报错：</p>
<p><code>This function has none of DETERMINISTIC......</code></p>
<p>由于开启过慢查询日志 bin-log，我们就必须为我们的 function 指定一个参数。<br>主从复制，主机会将写操作记录在 bin-log 日志中。从机读取 bin-log 日志，执行语句来同步数据。如果使用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，mysql 不开启创建函数设置。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看 mysql 是否允许创建函数</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_bin_trust_function_creators&#x27;</span>;</span><br><span class="line"># 命令开启：允许创建函数设置：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>;	# 不加 <span class="keyword">global</span> 只是当前窗口有效</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 创建插入模拟数据的存储过程</span><br><span class="line"># 存储过程<span class="number">1</span>: 创建插入课程表存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="keyword">insert</span> course(max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>; # 设置手动提交事务</span><br><span class="line">	REPEAT	# 循环</span><br><span class="line">	<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;	# 赋值</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> course (course_id, course_name) <span class="keyword">VALUES</span> (rand_num(<span class="number">10000</span>, <span class="number">10100</span>), rand_string(<span class="number">6</span>));</span><br><span class="line">	UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">	<span class="keyword">END</span> REPEAT;</span><br><span class="line">	<span class="keyword">COMMIT</span>;	# 提交事物</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 存储过程<span class="number">2</span>:创建插入学生信息表存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_stu(max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	REPEAT</span><br><span class="line">	<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> student_info (course_id, class_id, student_id, NAME) <span class="keyword">VALUES</span></span><br><span class="line">	(rand_num(<span class="number">10000</span>, <span class="number">10100</span>), rand_num(<span class="number">10000</span>,<span class="number">10200</span>), rand_num(<span class="number">1</span>, <span class="number">200000</span>), rand_string(<span class="number">6</span>));</span><br><span class="line">	UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">	<span class="keyword">END</span> REPEAT;</span><br><span class="line">	<span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 调用存储过程</span><br><span class="line"><span class="keyword">CALL</span> insert_course(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">CALL</span> insert_stu(<span class="number">1000000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="哪些情况适合创建索引"><a href="#哪些情况适合创建索引" class="headerlink" title="哪些情况适合创建索引"></a>哪些情况适合创建索引</h4><ul>
<li><p>字段的数值有唯一性的限制</p>
<p>  索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中，如果某个字段是唯一性的，就可以直接创建唯一性索引，或者主键索引。这样可以更快速地通过该索引来确定某条记录。</p>
<p>  例如，学生表中学好是具有唯一性的字段，为该字段建立唯一性索引可以很快确定某个学生的信息，如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p>
<blockquote>
<p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。</p>
<p>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p>
</blockquote>
</li>
<li><p>频繁作为 WHERE 查询条件的字段</p>
<p>  某个字段在 SELECT 语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p>
<p>  比如 student_info 数据表 (含 100 万条数据)，假设我们想要查询 student_id&#x3D;123110 的用户信息。</p>
<p>  如果我们没有对 student_id 字段创建索引，进行如下查询：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> course_id, class_id, name, create_time, student_id</span><br><span class="line"><span class="keyword">FROM</span> student_info</span><br><span class="line"><span class="keyword">WHERE</span> student_id <span class="operator">=</span> <span class="number">123110</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 耗时：<span class="number">251</span>ms</span><br></pre></td></tr></table></figure>

<p>  为 student_id 添加索引</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_sid(student_id);</span><br><span class="line"># 耗时<span class="number">1</span>ms。</span><br></pre></td></tr></table></figure>
</li>
<li><p>经常 GROUP BY 和 ORDER BY 的列</p>
<p>  索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要对分组或者排序的字段进行索引。如果待排序的列有多个，那么可以在这些列上建立组合索引。</p>
<p>  比如，按照 student_id 对学生选修的课程进行分组，现是不同的 student_id 和课程数量，显式 100 个即可。如果我们不对 student_id 创建索引，执行下面的 SQL 语句：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num <span class="keyword">FROM</span> student_info <span class="keyword">GROUP</span> <span class="keyword">BY</span> student_id LIMIT <span class="number">100</span>;</span><br><span class="line">耗时<span class="number">1</span>ms。</span><br></pre></td></tr></table></figure>

<p>  删除索引 (<code>DROP INDEX idx_sid ON student_info;</code>) 后运行时间: 1273ms。</p>
<p>  同样，如果是 ORDER BY，也需要对字段创建索引。</p>
<p>  如果同时有 GROUP BY 和 ORDER BY 的情况：比如我们按照 student_id 进行分组，同时按照创建时间降序的方式进行排序，这时我们就需要同时进行 GROUP BY 和 ORDER BY，那么是不是需要单独创建 student_id 的索引和 create_time 的索引呢？</p>
<p>  当我们对 student_id 和 create_time 分别创建索引，执行下面的 SQL 查询：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num <span class="keyword">FROM</span> student_info</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> student_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>  当对 student_id 和 create_time 分别创建索引时，sql 执行顺序是先执行 GROUP BY，所以只会使用 student_id 的索引。要想提高效率需要创建联合索引 <code>ALTER TABLE student_info ADD INDEX idx_sid_create_time(student_id, create_time DESC);</code>。但是如果创建索引时，student_id 和 create_time 顺序交换，执行上面的 sql，也不会用到该索引。</p>
</li>
<li><p>UPDATE、DELTET 的 WHERE 条件列</p>
<p>  当我们对某条数据进行 UPDATE 或者 DELETE 操作的时候，是否也需要对 WHERE 的条件列创建索引呢？</p>
<p>  想要把 name 为 IWIDRA 对应的 student_id 修改为 10002，当我们没有对 name 进行索引的时候，执行 SQL 语句：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> student_info <span class="keyword">SET</span> student_id <span class="operator">=</span> <span class="number">10002</span></span><br><span class="line"><span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;IWIDRA&#x27;</span>;</span><br><span class="line"># 耗时 <span class="number">356</span>ms</span><br></pre></td></tr></table></figure>

<p>  看一看到效率不高，但如果对 name 字段创建了索引，在执行类似 SQL </p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_name(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> student_info <span class="keyword">SET</span> student_id <span class="operator">=</span> <span class="number">10003</span></span><br><span class="line"><span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;qStmgT&#x27;</span>;</span><br><span class="line"># 耗时 <span class="number">3</span>ms</span><br></pre></td></tr></table></figure>

<p>  同样的，对 DELETE 语句 WHERE 条件后的字段创建索引，也会大幅提升效率。</p>
<p>  对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段时非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护</strong>。</p>
</li>
<li><p>DISTINCT 字段需要创建索引</p>
<p>  有时我门需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。比如，想要查询课程表中不同的 student_id 都有哪些，如果没有对 student_id 创建索引，执行 SQL 语句：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(student_id) <span class="keyword">FROM</span> student_info;</span><br><span class="line"># 耗时：<span class="number">553</span>ms</span><br></pre></td></tr></table></figure>

<p>  如果对 student_id 创建索引，在执行 SQL：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_sid(student_id);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(student_id) <span class="keyword">FROM</span> student_info;</span><br><span class="line"># 耗时：<span class="number">12</span>ms</span><br></pre></td></tr></table></figure>

<p>  能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照递增的顺序进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。</p>
</li>
<li><p>多表 JOIN 连接操作时，创建索引注意事项</p>
<p>  首先，连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套循环，数量级增长会非常快，严重影响查询的效率。</p>
<p>  其次，对 WHERE 条件创建索引，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p>
<p>  最后，对用于连接的字段创建索引，并且该字段再多张表中的类型必须一致。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。</p>
<p>  执行下面的 SQL，如果只对 student_id 创建索引</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> course.course_id, name, student_info.student_id, course_name</span><br><span class="line"><span class="keyword">FROM</span> student_info <span class="keyword">JOIN</span> course</span><br><span class="line"><span class="keyword">ON</span> student_info.course_id<span class="operator">=</span>course.course_id</span><br><span class="line"><span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;qStmgT&#x27;</span>;</span><br><span class="line"># 耗时：<span class="number">186</span>ms</span><br></pre></td></tr></table></figure>

<p>  对 name 创建索引，再次执行耗时：3ms</p>
</li>
<li><p>使用列的类型小的创建索引</p>
<p>  我们这里说的类型大小指的就是该类型表示的数据范围的大小。</p>
<p>  我们在定义表结构的时候要显式的指定列的类型，以整数类型为列，有 TINYINT、MEDIUMINT、INT、BIGINT 等，它们占用的存储空间一次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引使用较小的类型，比如我们能使用 INT 就不要使用 BIGINT，能使用 MEDIUMINT 就不要使用 INT。这是因为：</p>
<ul>
<li>数据类型越小，在查询时进行的比较操作越快</li>
<li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I&#x2F;O 到来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li>
</ul>
<p>  这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I&#x2F;O。</p>
</li>
<li><p>使用字符串前缀创建索引</p>
</li>
<li><p>假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的 B+ 树中有那么两个问题：</p>
<ul>
<li>B+ 树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在索引中占用的存储空间越大。</li>
<li>如果 B+ 树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。</li>
</ul>
<p>  我们可以通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既节约空间，又减少了字符串的比较时间，还大体能解决排序的问题。</p>
<p>  例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间，如果只检索字段前面的若干字符，这样可以提高检索速度。</p>
<p>  创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> shop(address <span class="type">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> shop <span class="keyword">ADD</span> INDEX(address(<span class="number">12</span>));</span><br></pre></td></tr></table></figure>

<p>  问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的，截取得少了，重复内容太多，字段的散列度会降低。怎么计算不同的长度的选择性呢？</p>
<p>  先看一下字段在全部数据中的选择度：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">distinct</span> address) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> shop;</span><br></pre></td></tr></table></figure>

<p>  通过不同长度去计算，与全表的选择性对比：</p>
<p>  公式：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(列名, 索引长度)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br></pre></td></tr></table></figure>

<p>  例如：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address, <span class="number">10</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub10, <span class="comment">-- 截取前 10 个字符的选择度</span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address, <span class="number">15</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub11, <span class="comment">-- 截取前 15 个字符的选择度</span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address, <span class="number">20</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub12, <span class="comment">-- 截取前 20 个字符的选择度</span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address, <span class="number">25</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub13, <span class="comment">-- 截取前 25 个字符的选择度</span></span><br></pre></td></tr></table></figure>

<p>  <strong>引申另一个问题：索引列前缀对排序的影响</strong></p>
<p>  如果使用了索引列前缀，比方说前边只把 address 列的前 12 个字符放到了二级索引中，下边这个查询可能就有点尴尬了：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> shop</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> address</span><br><span class="line">LIMIT <span class="number">12</span>;</span><br></pre></td></tr></table></figure>

<p>  因为二级索引中不包含完整的 address 列信息，所以无法对前 12 个字符相同，后边不同的记录进行排序，也就是使用索引列前缀的方式无法支持使用索引排序，只能使用文件排序。</p>
<p>  <strong>拓展：Alibaba《Java 开发手册》</strong></p>
<p>  【强制】在 varchar 字段上建立索引时，必须制定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</p>
<p>  说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上，可以使用  <code>count(distinct left(列名, 索引长度)) / count(*)</code> 的区分度来确定。</p>
</li>
<li><p>区分度高 (散列性高) 的列适合作为索引</p>
<p>  列的基数指的是某一列中不重复数据的个数，比方说某个列包含值 2，5，8，2，5，8，2，5，8，虽然有 9 条记录，但该列的基数却是 3.也就是说，在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</p>
<p>  可以使用公式 <code>SELECT COUNT(distinct a) / count(*) FROM t1</code> 计算区分度，越接近 1 越好，一般超过 33% 就算是比较高效的索引了。</p>
<p>  拓展：联合索引把区分度高 (散列性高) 的列放在前面。</p>
</li>
<li><p>使用最频繁的列放到联合索引的左侧</p>
<p>  这样也可以较少的建立一些索引。同时，由于“最左前缀原则”，可以增加联合索引的使用率。</p>
</li>
<li><p>在多个字段都要创建索引的情况下，联合索引由于单值索引</p>
</li>
</ul>
<h4 id="限制索引的数目"><a href="#限制索引的数目" class="headerlink" title="限制索引的数目"></a>限制索引的数目</h4><p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量不超过 6 个。原因：</p>
<ul>
<li>每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。</li>
<li>索引会影响 INSERT、DELETE、UPDATE 等语句的性能，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</li>
<li>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加 MySQL 优化器生成执行计划时间，降低查询性能。</li>
</ul>
<h4 id="哪些情况不适合创建索引"><a href="#哪些情况不适合创建索引" class="headerlink" title="哪些情况不适合创建索引"></a>哪些情况不适合创建索引</h4><ol>
<li><p>在 WHERE 中使用不到的字段，不要设置索引</p>
<p> WHERE 条件 (包括 GROUP BY、ORDER BY) 里用不到的字段不需要创建索引，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的。</p>
</li>
<li><p>数据量小的表最好不要使用索引</p>
<p> <strong>如果表记录太少，比如少于 1000 个，那么是不需要创建索引的</strong>。表记录太少，是否创建索引对查询效率的影响并不大。甚至说，查询话费的时间可能比遍历索引的时间还短，索引可能不会产生优化效果。</p>
</li>
<li><p>有大量重复数据的列上不需要建立索引</p>
<p> 在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。比如在学生表的“性别”字段上只有“男”与“女”两个不同值，因此无需建立索引。如果建立索引，不但不会提高查询效率，反而会严重降低数据更新速度。</p>
<blockquote>
<p>结论：当数据重复度大，比如高于 10% 的时候，也不需要对这个字段使用索引。</p>
</blockquote>
</li>
<li><p>避免对经常更新的表创建过多的索引</p>
<p> 第一层含义：频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。</p>
<p> 第二层含义：避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却会降低更新表的速度。</p>
</li>
<li><p>不建议用无序的值作为索引</p>
<p> 例如身份证、UUID (在索引比较时需要专为 ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p>
</li>
<li><p>删除不再使用或者很少使用的索引</p>
<p> 表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将他们删除，从而减少索引对更新操作的影响。</p>
</li>
<li><p>不要定义冗余或重复的索引</p>
<p> <strong>冗余索引</strong></p>
<p> 有时候有意或无意的就对同一个列创建了多个索引，比如：index(a, b, c) 相当于 index(a)、index(a, b)、index(a, b, c)。index(a, b, c) 索引就可以对 a 进行快速搜索，如果在对 a 列进行创建索引，就是一个冗余索引。</p>
<p> <strong>重复索引</strong></p>
<p> 在一个表中，col1 是主键，此时给他定义一个唯一索引，还定义了一个普通索引，但是主键本身就会生成聚簇索引，索引定义的唯一索引和普通索引是重复的，这种情况要避免。</p>
</li>
</ol>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>索引是一把双刃剑，可提高查询效率，但也会降低插入和更新的速度并占用磁盘空间。</p>
<p>选择索引的最终目的是为了使查询的速度变快，上面给出的原则是最基本的准则，但不能拘泥于上面的准则，大家要在以后的学习和工作中进行不断的实践，根据应用的实际情况进行分析和判断，选择最合适的索引方式。</p>
<h2 id="性能分析工具的使用"><a href="#性能分析工具的使用" class="headerlink" title="性能分析工具的使用"></a>性能分析工具的使用</h2><p>在数据库调优中，我们的目标就是响应时间更快，吞吐量更大。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。</p>
<h3 id="数据库服务器的优化步骤"><a href="#数据库服务器的优化步骤" class="headerlink" title="数据库服务器的优化步骤"></a>数据库服务器的优化步骤</h3><p>当我们遇到数据库调优问题的时候，该如何思考呢？思考的的整个流程图分成了观察 Show status 和行动 Action 两个部分。字母 S 的部分代表观察 (会使用相应的分析工具)，字母 A 代表的部分是行动 (对应分析可以采取的行动)。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="数据库服务器的优化流程图"></p>
<p>我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的 SQL 都有哪些，查看具体的 SQL 执行计划，甚至是 SQL 执行中的每一步的成本代价，这样才能定位问题所在，找到了问题，再采取相应的行动。</p>
<p><strong>详细解释一下上图</strong>：</p>
<p>首先在 S1 部分，我们需要观察服务器的状态是否存在周期性的波动。如果存在周期性波动，有可能是周期性节点的原因，比如双十一、</p>
<p>促销活动等。这样的话，我们可以通过 A1 这一步骤解决，也就是加缓存，或者更改缓存失效策略。</p>
<p>如果缓存策略没有解决，或者不是周期性波动的原因，我们就需要进一步分析查询延迟和卡顿的原因。接下来进入 S2 这一步，我们需要开启慢查询。慢查询可以帮我们定位执行慢的 SQL 语句。我们可以通过设置 long_query_time 参数定义慢的阈值，如果 SQL 执行实际那超过了 long_query_time，则会认为是慢查询。当收集上来这些慢查询之后，我们就可以通过分析工具对慢查询日志进行分析。</p>
<p>在 S3 这一步骤中，我们就知道了执行慢的 SQL，这样就可以针对性地使用 EXPLAIN 查看对应 SQL 语句的执行计划，或者使用 show profile 查看 SQL 中每一个步骤的时间成本。这样我们就可以了解 SQL 查询慢是因为执行时间长，还是等待时间长。</p>
<p>如果是 SQL 等待时间长，我们进入 A2 步骤。在这一步骤中，我们可以调优服务器的参数，比如适当增加数据库缓冲池。如果是 SQL 执行时间长，就进入 A3 步骤，这一步中我们需要考虑是索引设计的问题？还是查询关联的数据表过多？还是因为数据表的字段设计问题导致了这一现象。然后在这些维度上进行对应的调整。</p>
<p>如果 A2 和 A3 都不能解决问题，我们需要考虑数据库自身的 SQL 查询性能是否已经达到了瓶颈，如果确认没有到达性能瓶颈，就需要重新检查，重复以上的步骤。如果已经到达了性能瓶颈，进入 A4 阶段，需要考虑增加服务器，采用读写分离的架构，或者考虑对数据库进行分库分表，比如垂直分库、垂直分表和水平分表等。</p>
<p>以上就是数据库调优的流程思路。如果我们发现执行 SQL 时存在不规则延迟或卡顿的时候，就可以采用分析工具帮我们定位有问题的 SQL，这三种分析工具你可以理解是 SQL 调优的三个步骤：慢查询、EXPLAIN 和 SHOW PROFILING。</p>
<p><strong>小结</strong>：</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.png" alt="性能分析"></p>
<h3 id="查看系统性能参数"><a href="#查看系统性能参数" class="headerlink" title="查看系统性能参数"></a>查看系统性能参数</h3><p>在 MySQL 中，可以使用 SHOW STATUS 语句查询一些 MySQL 数据库服务器的性能参数、执行效率。</p>
<p>SHOW STATUS 语句语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;参数&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>一些常用的性能参数如下：</p>
<ul>
<li>Connections：连接 MySQL 服务器的次数。</li>
<li>Uptime：MySQL 服务器上线时间。</li>
<li>Slow_queries：慢查询的次数。</li>
<li>Innodb_rows_read：Select 查询返回的行数。</li>
<li>Innodb_rows_inserted：执行 INSERT 操作插入的行数。</li>
<li>Innodb_rows_updated：执行 UPDATE 操作更新的行数。</li>
<li>Innodb_rows_deleted：执行 DELETED 擦欧总删除的行数。</li>
<li>Com_select：查询操作的次数。</li>
<li>Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。</li>
<li>Com_update：更新操作的次数。</li>
<li>Com_delete：删除操作的次数。</li>
</ul>
<h3 id="统计-SQL-的查询成本：last-query-cost"><a href="#统计-SQL-的查询成本：last-query-cost" class="headerlink" title="统计 SQL 的查询成本：last_query_cost"></a>统计 SQL 的查询成本：last_query_cost</h3><p>一条 SQL 查询语句在执行前需要确定查询执行计划，如果存在多种执行计划的话，MySQL 会计算每个执行计划所需要的成本，从中选择成本最小的一个座位最终执行的执行计划。</p>
<p>如果我们想要查看某条 SQL 语句的查询成本，可以在执行完这条 SQL 语句之后，通过查看当前会话中的last_query_cost 变量值来得到当前查询的成本。它通常也是我们评价一个查询的执行效率的一个常用指标。这个查询成本对应的是 SQL 语句所需要读取的页的数量。</p>
<p>例如：想要在 student 表中查询 id&#x3D;900001 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time <span class="keyword">FROM</span> student_info</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">900001</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果 (1 条记录，运行时间为 0.015s)</p>
<p>然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#结果</span><br><span class="line">last_query_cost <span class="operator">=</span> <span class="number">1.000000</span></span><br></pre></td></tr></table></figure>

<p>如果想要查询 id 在 900001 到 900100 之间的学生记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time <span class="keyword">FROM</span> student_info</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">900001</span> <span class="keyword">AND</span> <span class="number">900100</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果 (100 条记录，运行时间为 0.004s)</p>
<p>查看优化器成本</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#结果</span><br><span class="line">last_query_cost <span class="operator">=</span> <span class="number">20.290432</span></span><br></pre></td></tr></table></figure>

<p>能看到页的数量是刚才的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SQL 查询的时间基本上一样，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然页数量增加了不少，但是通过缓冲池的机制，并没有增加多少查询时间。</p>
<p>使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p>
<p>SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到一下两点结论：</p>
<ul>
<li><strong>位置决定效率</strong>。如果页就在数据库缓冲池中，那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li>
<li><strong>批量决定效率</strong>。如果我们从磁盘中对单一页进行随机读，那么效率是很低的 (差不多 10ms)，而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li>
</ul>
<p>所以说，遇到 I&#x2F;O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到缓冲池中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p>
<h3 id="定位执行慢的-SQL：慢查询日志"><a href="#定位执行慢的-SQL：慢查询日志" class="headerlink" title="定位执行慢的 SQL：慢查询日志"></a>定位执行慢的 SQL：慢查询日志</h3><p>MySQL 的慢查询日志，用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 long_query_time 值的 SQL，则会被记录到慢查询日志中。long_query_time 的默认值为 10，意思是运行 10 秒以上 (不包含 10 秒) 的语句，认为是超出了我们的最大忍耐时间值。</p>
<p>它的主要作用是，帮助我们发现那些执行时间特别长的 SQL 查询，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，对解决问题很有帮助。比如一条 SQL 执行超过 15s，我们就算慢 SQL，希望能收集超过 5s 的 SQL，结合 EXPLAIN 进行全面分析。</p>
<p>默认情况下，MySQL 数据库没有开启慢查询日志，需要我们手动来设置这个参数。如果不是条有需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持 将日志记录写入文件。</p>
<h4 id="开启慢查询日志参数"><a href="#开启慢查询日志参数" class="headerlink" title="开启慢查询日志参数"></a>开启慢查询日志参数</h4><p><strong>开启 slow_query_log</strong></p>
<p>在使用前，需要先看下慢查询是否已经开启 <code>show variables like &#39;%slow_query_log&#39;;</code> ，如果是 off 状态，使用 <code>set global slow_query_log=&#39;ON&#39;;</code> 开启。使用 <code>show variables like &#39;%slow_query_log%&#39;;</code> 查看慢查询日志文件的位置。</p>
<h4 id="修改-long-query-time-阈值"><a href="#修改-long-query-time-阈值" class="headerlink" title="修改 long_query_time 阈值"></a>修改 long_query_time 阈值</h4><p>使用 <code>show variables like &#39;%long_query_time%&#39;;</code> 查看慢查询的时间阈值设置，使用 <code>set global long_query_time = 1;</code> 修改慢查询的时间阈值。使用 <code>show global status like &#39;%slow_queries%&#39;;</code> 查看当前系统中有多少条慢查询记录。</p>
<h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><p><strong>分析</strong></p>
<p>除了上述变量，控制慢查询日志的还有一个系统变量：min_examined_row_limit。这个变量的意思是，查询扫描过的最少记录数。这个变量和查询执行时间，共同组成了判别一个查询是否是慢查询的条件。如果查询扫描过的记录数大于等于这个变量的值，并且查询执行时间超过 long_query_time 的值，那么，这个查询就被记录到慢查询日志中；反之，则不被记录到慢查询日志中。</p>
<p><code>show variables like &#39;min%&#39;;</code> 这个值默认是 0。与 long_query_time&#x3D;10 合在一起，表示只要查询的执行时间超过 10 秒钟，哪怕一个记录也没有扫描，都要被记录到慢查询日志中。你也可以根据需要，通过修改 my.ini 文件，来修改查询时长，或者通过 SET 命令，用 SQL 语句修改 min_examined_row_limit 的值。</p>
<h4 id="慢查询日志分析工具：mysqldumpslow"><a href="#慢查询日志分析工具：mysqldumpslow" class="headerlink" title="慢查询日志分析工具：mysqldumpslow"></a>慢查询日志分析工具：mysqldumpslow</h4><p>在生产环境中，如果要收工分析日志，查找、分析 SQL，显然是个体力活，MySQL 提供了日志分析工具 mysqldumpslow。</p>
<p>查看 mysqldumpslow 的帮助信息 <code>mysqldumpslow --help</code> </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">~</span><span class="operator">/</span> mysqldumpslow <span class="comment">--help</span></span><br><span class="line">Usage: mysqldumpslow [ OPTS... ] [ LOGS... ]</span><br><span class="line"></span><br><span class="line">Parse <span class="keyword">and</span> summarize the MySQL slow query log. Options <span class="keyword">are</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">--verbose    verbose</span></span><br><span class="line">  <span class="comment">--debug      debug</span></span><br><span class="line">  <span class="comment">--help       write this text to standard output</span></span><br><span class="line"></span><br><span class="line">  <span class="operator">-</span>v           verbose</span><br><span class="line">  <span class="operator">-</span>d           debug</span><br><span class="line">  <span class="operator">-</span>s <span class="keyword">ORDER</span>     what <span class="keyword">to</span> sort <span class="keyword">by</span> (al, <span class="keyword">at</span>, ar, c, l, r, t), <span class="string">&#x27;at&#x27;</span> <span class="keyword">is</span> <span class="keyword">default</span></span><br><span class="line">                al: average lock <span class="type">time</span></span><br><span class="line">                ar: average <span class="keyword">rows</span> sent</span><br><span class="line">                <span class="keyword">at</span>: average query <span class="type">time</span></span><br><span class="line">                 c: count</span><br><span class="line">                 l: lock <span class="type">time</span></span><br><span class="line">                 r: <span class="keyword">rows</span> sent</span><br><span class="line">                 t: query <span class="type">time</span>  </span><br><span class="line">  <span class="operator">-</span>r           reverse the sort <span class="keyword">order</span> (largest <span class="keyword">last</span> instead <span class="keyword">of</span> <span class="keyword">first</span>)</span><br><span class="line">  <span class="operator">-</span>t NUM       just <span class="keyword">show</span> the top n queries</span><br><span class="line">  <span class="operator">-</span>a           don<span class="string">&#x27;t abstract all numbers to N and strings to &#x27;</span>S<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  -n NUM       abstract numbers with at least n digits within names</span></span><br><span class="line"><span class="string">  -g PATTERN   grep: only consider stmts that include this string</span></span><br><span class="line"><span class="string">  -h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),</span></span><br><span class="line"><span class="string">               default is &#x27;</span><span class="operator">*</span><span class="string">&#x27;, i.e. match all</span></span><br><span class="line"><span class="string">  -i NAME      name of server instance (if using mysql.server startup script)</span></span><br><span class="line"><span class="string">  -l           don&#x27;</span>t subtract lock <span class="type">time</span> <span class="keyword">from</span> total <span class="type">time</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>mysqldumpslow -a -s t -t 5 /opt/homebrew/var/mysql/zhangjiandeMacBook-Pro-slow.log</code> 定位慢查询 SQL。</p>
<h4 id="关闭慢查询日志"><a href="#关闭慢查询日志" class="headerlink" title="关闭慢查询日志"></a>关闭慢查询日志</h4><ul>
<li><p>永久性方式</p>
<p>  修改 my.cnf 或 my.ini 文件，把 [mysqld] 组下的 slow_query_log 值设为 OFF，修改保存后，在重启 MySQL 服务，即可生效。</p>
</li>
<li><p>临时性方式</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log<span class="operator">=</span>OFF;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="删除慢查询日志"><a href="#删除慢查询日志" class="headerlink" title="删除慢查询日志"></a>删除慢查询日志</h4><p>使用 SHOW 语句显示慢查询日志信息，具体 SQL 语句如下：</p>
<p><code>SHOW VARIABLES LIKE &#39;slow_query_log%&#39;;</code></p>
<p>从执行结果可以看出慢查询日志的的目录，在该目录下手动删除慢查询日志文件即可。使用命令 <code>mysqladmin flush-logs</code> 来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p flush<span class="operator">-</span>logs slow</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示</p>
<p>慢查询日志都是使用 mysqladmin flush-logs 命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。</p>
</blockquote>
<h3 id="查看-SQL-执行成本：SHOW-PROFILE"><a href="#查看-SQL-执行成本：SHOW-PROFILE" class="headerlink" title="查看 SQL 执行成本：SHOW PROFILE"></a>查看 SQL 执行成本：SHOW PROFILE</h3><p>show profile 是 MySQL 提供的可以用来分析当前会话中 SQL 都做了什么、执行的资源消耗情况的工具，可用于 SQL 调优的测量。默认情况下处于关闭状态，并保存最近 15 次的运行结果。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看状态</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span>;</span><br><span class="line"># 开启</span><br><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"># 查看当前会话有哪些 profile</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"># 查看指定 query id</span><br><span class="line"><span class="keyword">show</span> profile cpu, block io <span class="keyword">for</span> query <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>show profile 的常用查询参数</strong>：</p>
<ul>
<li>ALL：显示所有的开销信息。</li>
<li>BLOCK IO：显示块 IO 开销。</li>
<li>CONTEXT SWITCHES：上下文切换开销。</li>
<li>CPU：显示 CPU 开销信息。</li>
<li>IPC：显示发送和接受开销信息。</li>
<li>MEMORY：显示内存开销信息。</li>
<li>PAGE FAULTS：显示页面错误开销信息。</li>
<li>SOURCE：显示和 Source_function，Source_file，Source_line 相关的开销信息。</li>
<li>SWAPS：显示交换次数开销信息。</li>
</ul>
<p><strong>日常开发需要注意的结论</strong>：</p>
<ul>
<li><code>concerting HEAP to MyISAM</code>：查询结果太大，内存不够，数据往磁盘上搬了。</li>
<li><code>Creating tmp table</code>：创建临时表，先拷贝数据到临时表，用完后再删除临时表。</li>
<li><code>Copying to tmp table on disk</code>：把内存中临时表复制到磁盘上，警惕！</li>
<li><code>locked</code>。</li>
</ul>
<p>如果在 show profile 诊断结果中出现了以上 4 条结果中的任何一条，则 SQL 语句需要优化。</p>
<blockquote>
<p>注意：</p>
<p>不过 show profile 命令将被弃用，可以从 information_schema 中 profiling 数据表进行查看。</p>
</blockquote>
<h3 id="分析查询语句：EXPLAIN"><a href="#分析查询语句：EXPLAIN" class="headerlink" title="分析查询语句：EXPLAIN"></a>分析查询语句：EXPLAIN</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>定位了慢查询的 SQL 之后，我们就可以使用 EXPLAIN 或 DESCRIBE 工具做针对性的分析查询语句</strong>。DESCRIBE 语句的使用方法与 EXPLAIN 语句是一样的，并且分析结果也是一样的。</p>
<p>MySQL 中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的 Query 提供它认为最优的执行计划 (他认为最优的数据检索方式，但不见得是 DBA 认为是最优的，这部分最耗费时间)。</p>
<p>这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL 为我们提供了 EXPLAIN 语句来帮助我们查看某个查询语句的具体执行计划。</p>
<p><strong>能做什么</strong>？</p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li><strong>哪些索引被实际使用</strong></li>
<li>表之间的引用</li>
<li><strong>每张表有多少行被优化器查询</strong></li>
</ul>
<p><strong><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">官网介绍</a></strong></p>
<p><strong>版本情况</strong></p>
<ul>
<li>MySQL 5.6.3 以前只能 EXPLAIN SELECT；MySQL 5.6.3 以后就可以 EXPLAIN SELECT、UPDATE、DELETE</li>
<li>在 5.7 以前的版本中，想要显示 partitions 需要使用 explain partitions 命令；想要显示 filtered 需要使用 explain extended 命令。在 5.7 版本后，默认 explain 直接显示 partitions 和 filtered 中的信息。</li>
</ul>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>EXPLAIN 或 DESCRIBE 语句的语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> select_options</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">SELECT</span> select_options</span><br></pre></td></tr></table></figure>

<p>如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 EXPLAIN，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">No</span> tables used <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br></pre></td></tr></table></figure>

<p>输出的上述信息就是所谓的执行计划。在这个执行计划的辅助下，我们需要知道应该怎么样改进自己的查询语句以使查询执行起来更高效。其实除了以 SELECT 开头的查询语句，其余的 DELETE、INSERT、REPLACE 以及 UPDATE 语句等都可以加上 EXPLAIN，用来查看这些语句的执行计划，只是平时我们对 SELECT 语句更感兴趣。</p>
<blockquote>
<p>注意：</p>
<p>执行 EXPLAIN 时并没有真正的执行该后面的语句，因此可以安全的查看执行计划。</p>
</blockquote>
<p>EXPLAIN 语句输出的各个列的作用如下：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id</td>
</tr>
<tr>
<td>select_type</td>
<td>SELECT 关键字对应的那个查询的类型</td>
</tr>
<tr>
<td>table</td>
<td>表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区信息</td>
</tr>
<tr>
<td>type</td>
<td>针对单表的访问方法</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际上使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>实际使用到的索引长度</td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td>rows</td>
<td>预估的需要读取的记录条数</td>
</tr>
<tr>
<td>filtered</td>
<td>某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>一些额外的信息</td>
</tr>
</tbody></table>
<h4 id="数据准备-1"><a href="#数据准备-1" class="headerlink" title="数据准备"></a>数据准备</h4><p><strong>建表</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s1 (</span><br><span class="line">	id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">  key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key2 <span class="type">INT</span>,</span><br><span class="line">  key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  INDEX idx_key1 (key1),</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX idx_key2 (key2),</span><br><span class="line">  INDEX idx_key3 (key3),</span><br><span class="line">  INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s2 (</span><br><span class="line">	id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">  key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key2 <span class="type">INT</span>,</span><br><span class="line">  key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  INDEX idx_key1 (key1),</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX idx_key2 (key2),</span><br><span class="line">  INDEX idx_key3 (key3),</span><br><span class="line">  INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p><strong>设置参数 log_bin_trust_function_creators</strong></p>
<p>创建函数，假如报错，需开启如下命令：允许创建函数设置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>;	# 不加 <span class="keyword">global</span> 只是当前窗口有效。</span><br></pre></td></tr></table></figure>

<p><strong>创建函数</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string1(n <span class="type">INT</span>)</span><br><span class="line">	<span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>)	#	该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line">		<span class="keyword">SET</span> return_str <span class="operator">=</span> CONCAT(return_str, <span class="built_in">SUBSTRING</span>(chars_str, <span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> RAND() <span class="operator">*</span> <span class="number">52</span>), <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">END</span> WHILE;</span><br><span class="line">	<span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><strong>创建存储过程</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_s1 (<span class="keyword">IN</span> min_num <span class="type">INT</span> (<span class="number">10</span>), <span class="keyword">IN</span> max_num <span class="type">INT</span> (<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	REPEAT</span><br><span class="line">	<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> s1 <span class="keyword">VALUES</span>(</span><br><span class="line">  (min_num <span class="operator">+</span> i),</span><br><span class="line">  rand_string1(<span class="number">6</span>),</span><br><span class="line">  (min_num <span class="operator">+</span> <span class="number">30</span> <span class="operator">*</span> i <span class="operator">+</span> <span class="number">5</span>),</span><br><span class="line">  rand_string1(<span class="number">6</span>),</span><br><span class="line">  rand_string1(<span class="number">10</span>),</span><br><span class="line">  rand_string1(<span class="number">5</span>),</span><br><span class="line">  rand_string1(<span class="number">10</span>),</span><br><span class="line">  rand_string1(<span class="number">10</span>));</span><br><span class="line">  UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">  <span class="keyword">END</span> REPEAT;</span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_s2 (<span class="keyword">IN</span> min_num <span class="type">INT</span> (<span class="number">10</span>), <span class="keyword">IN</span> max_num <span class="type">INT</span> (<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	REPEAT</span><br><span class="line">	<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> s2 <span class="keyword">VALUES</span>(</span><br><span class="line">  (min_num <span class="operator">+</span> i),</span><br><span class="line">  rand_string1(<span class="number">6</span>),</span><br><span class="line">  (min_num <span class="operator">+</span> <span class="number">30</span> <span class="operator">*</span> i <span class="operator">+</span> <span class="number">5</span>),</span><br><span class="line">  rand_string1(<span class="number">6</span>),</span><br><span class="line">  rand_string1(<span class="number">10</span>),</span><br><span class="line">  rand_string1(<span class="number">5</span>),</span><br><span class="line">  rand_string1(<span class="number">10</span>),</span><br><span class="line">  rand_string1(<span class="number">10</span>));</span><br><span class="line">  UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">  <span class="keyword">END</span> REPEAT;</span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><strong>调用存储过程</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> insert_s1(<span class="number">10001</span>, <span class="number">10000</span>);</span><br><span class="line"><span class="keyword">CALL</span> insert_s2(<span class="number">10001</span>, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="EXPLAIN-各列作用"><a href="#EXPLAIN-各列作用" class="headerlink" title="EXPLAIN 各列作用"></a>EXPLAIN 各列作用</h4><ul>
<li>table：表名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 查询的每一行记录都对应着一个单表</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line"># s1:驱动表  s2:被驱动表</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">join</span> buffer (hash <span class="keyword">join</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+</span></span><br><span class="line"># 执行计划中，记录在前的为驱动表，在后的为被驱动表，这里s2为驱动表，s1为被驱动表</span><br></pre></td></tr></table></figure>

<ul>
<li>id：在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2</span><br><span class="line"><span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key2</span><br><span class="line"><span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> idx_key1      <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> idx_key2      <span class="operator">|</span> idx_key2 <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> mysql_test.s1.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-----------------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key3 <span class="keyword">FROM</span> s2);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>       <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys       <span class="operator">|</span> key                 <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE       <span class="operator">|</span> s1          <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> idx_key1            <span class="operator">|</span> <span class="keyword">NULL</span>                <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE       <span class="operator">|</span> <span class="operator">&lt;</span>subquery2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="operator">&lt;</span>auto_distinct_key<span class="operator">&gt;</span> <span class="operator">|</span> <span class="operator">&lt;</span>auto_distinct_key<span class="operator">&gt;</span> <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> mysql_test.s1.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> MATERIALIZED <span class="operator">|</span> s2          <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index  <span class="operator">|</span> idx_key3            <span class="operator">|</span> idx_key3            <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> s2         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span> <span class="operator">|</span> <span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br></pre></td></tr></table></figure>

<p><strong>查询优化器可能对涉及子查询的查询语句进行重写，转变为多表查询的操作</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key2 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> idx_key1      <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> idx_key2      <span class="operator">|</span> idx_key2 <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> mysql_test.s1.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span>; <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p><strong>Union 去重</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> s2         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span> <span class="operator">|</span> <span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>       <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>id 如果相同，可以认为是一组，从上往下顺序执行</p>
</li>
<li><p>在所有组中，id 值越大，优先级越高，越先执行</p>
</li>
<li><p>关注点：id 号每个号码，表示一趟独立的查询，一个 SQL 的查询趟越少越好数</p>
</li>
</ul>
</blockquote>
<ul>
<li>select_type</li>
</ul>
<p>一条大的查询语句里边可以包含若干个 SELECT 关键字，每个 SELECT 关键字代表着一个小的查询语句，而每个 SELECT 关键字的 FROM 字句中都可以包含若干张表 (这些表用来做连接查询)，每一张表都对应着执行计划输出中的一条记录，对于在同一个 SELECT 关键字中的表来说，它们的 id 值是相同的。</p>
<p>MySQL 为每个 SELECT 关键字代表的小查询都定义了一个称之为 select_type 的属性，意思是我们只要知道了某个小查询的 select_type 属性，就知道了这个小查询在整个大查询中扮演的一个什么角色，select_type 能取的值：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>Simple SELECT (not using UNION or subqueries)</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>Outermost SELECT</td>
</tr>
<tr>
<td>UNION</td>
<td>Second or later SELECT statement in a UNION</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>Result of a UNION</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>FIRST SELECT in subquery</td>
</tr>
<tr>
<td>DEPENDENT SUBQUERY</td>
<td>First SELECT in subquery,dependent on outer query</td>
</tr>
<tr>
<td>DEPENDENT UNION</td>
<td>Second or later SELECT statement in a UNION, dependent on outer query</td>
</tr>
<tr>
<td>DERIVED</td>
<td>Derived table</td>
</tr>
<tr>
<td>MATERIALIZED</td>
<td>Materialized subquery</td>
</tr>
<tr>
<td>UNCACHEABLE SUBQUERY</td>
<td>A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td>
</tr>
<tr>
<td>UNCACHEABLE UNION</td>
<td>The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td>
</tr>
</tbody></table>
<p>select_type：SELECT 关键字对应的那个查询的类型，确定小查询在整个大查询中扮演了一个什么角色</p>
<p>具体分析：</p>
<ol>
<li><p>SIMPLE</p>
<p> 查询语句中不包含 UNION 或者子查询的查询都算是 SIMPLE 类型</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line"># 连接查询也算是 SIMPLE 类型</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">join</span> buffer (hash <span class="keyword">join</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>UNION RESULT</p>
<p> 对于包含 UNION 或者 UNION ALL 或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的 select_type 值就是 PRIMARY。</p>
<p> 对于包含 UNION 或者 UNION ALL 的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的 select_type 值就是 UNION。</p>
<p> MySQL 选择使用临时表来完成 UNION 查询的去重工作，针对该临时表的查询的 select_type 就是 UNION RESULT。</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> s2         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span> <span class="operator">|</span> <span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>       <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>SUBQUERY</p>
<p> 如果包含子查询的查询语句不能够专为对应的 semi-join 的形式，并且该子查询是不相关子查询。该子查询的第一个 SELECT 关键字代表的那个查询的 select_type 就是 SUBQUERY</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>​		如果包含子查询的查询语句不能够专为对应的 semi-join 的形式，并且该子查询是相关子查询，则该子查询的第一个 SELECT 关键字		代表的那个查询的 select_type 就是 DEPENDENT SUBQUERY</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1</span><br><span class="line"><span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> s1.key2 <span class="operator">=</span> s2.key2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+--------+-------------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type        <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys     <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+--------+-------------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>            <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> idx_key3          <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DEPENDENT SUBQUERY <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> idx_key2,idx_key1 <span class="operator">|</span> idx_key2 <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> mysql_test.s1.key2 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+--------+-------------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"># 注意的是，select_type 为 DEPENDENT SUBQUERY 的查询可能会被执行多次</span><br></pre></td></tr></table></figure>

<p>​		在包含 UNION 或者 UNION ALL 的大查询中，如果各个小查询都依赖于外层查询的话，拿出了最左边的那个小查询之外，其余的小		查询的 select_type 的值就是 DEPENDENT UNION。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1</span><br><span class="line"><span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type        <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>            <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DEPENDENT SUBQUERY <span class="operator">|</span> s2         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> DEPENDENT <span class="keyword">UNION</span>    <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span>       <span class="operator">|</span> <span class="operator">&lt;</span>union2,<span class="number">3</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span></span><br></pre></td></tr></table></figure>

<p>​		对于派生表的查询，该派生表对应的子查询的 select_type 就是 DERIVED。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> key1, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> c <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> key1) <span class="keyword">AS</span> derived_s1 <span class="keyword">WHERE</span> c <span class="operator">&gt;</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> <span class="operator">&lt;</span>derived2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<p>​		当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的 select_type 属性就		是 MATERALIZED。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2);	#	子查询被转化为物化表</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>       <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys       <span class="operator">|</span> key                 <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE       <span class="operator">|</span> s1          <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> idx_key1            <span class="operator">|</span> <span class="keyword">NULL</span>                <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE       <span class="operator">|</span> <span class="operator">&lt;</span>subquery2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="operator">&lt;</span>auto_distinct_key<span class="operator">&gt;</span> <span class="operator">|</span> <span class="operator">&lt;</span>auto_distinct_key<span class="operator">&gt;</span> <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> mysql_test.s1.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> MATERIALIZED <span class="operator">|</span> s2          <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index  <span class="operator">|</span> idx_key1            <span class="operator">|</span> idx_key1            <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>partitions：匹配的分区信息</p>
<p>  代表分区表中的命中情况，非分区表，该项为 NULL。一般情况下我们的查询语句的执行计划的 partitions 列的值都是 NULL。</p>
</li>
<li><p><strong>type</strong>：针对单表的访问方法</p>
<p>  执行计划的一条记录就代表着 MySQL 对某个表的执行查询时的访问方法，又称访问类型，其中的 type 列就表明了这个访问方法是啥，是较为重要的一个指标。比如，看到 type 列的值是 ref，表明 MySQL 即将使用 ref 访问方法来执行对 s1 表的查询。</p>
<p>  完整的访问方法如下：system, const, eq_ref, ref, fulltext, ref_or_null, index_merge, unique_subquery, index_subquery, range, index, ALL。</p>
<ul>
<li><p>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如 MyISAM、MEMORY，那么对该表的访问方法就是 system。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t(i <span class="type">INT</span>) ENGINE<span class="operator">=</span>MyISAM;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t     <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">system</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是 const</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10005</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> const <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key2 <span class="operator">=</span> <span class="number">10066</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> const <span class="operator">|</span> idx_key2      <span class="operator">|</span> idx_key2 <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在连接查询时，如果被驱动表时通过主键或者唯一二级索引列等值匹配的方式进行访问的 (如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较)，则对该被驱动表的访问方法就是 eq_ref。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>              <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> mysql_test.s2.id <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是 ref</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当对普通二级索引进行等值匹配查询，该索引列的值也可以是 NULL 值时，那么对该表的访问方法就可能是 ref_or_null</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key1 <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type        <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> ref_or_null <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>单表访问方法时在某些场景下可以使用 Intersection、Union、Sort-Union 这三种索引合并的方式来执行查询</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type        <span class="operator">|</span> possible_keys     <span class="operator">|</span> key               <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index_merge <span class="operator">|</span> idx_key1,idx_key3 <span class="operator">|</span> idx_key1,idx_key3 <span class="operator">|</span> <span class="number">303</span>,<span class="number">303</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">union</span>(idx_key1,idx_key3); <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>unique_subquery 是针对在一些包含 IN 子查询的查询语句中，如果查询优化器决定将 IN 子查询转换为 EXISTS 子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的 type 列的值就是 unique_subquery。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1</span><br><span class="line"><span class="keyword">WHERE</span> key2 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> s1.key1 <span class="operator">=</span> s2.key1) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type        <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type            <span class="operator">|</span> possible_keys    <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>            <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>             <span class="operator">|</span> idx_key3         <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DEPENDENT SUBQUERY <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> unique_subquery <span class="operator">|</span> <span class="keyword">PRIMARY</span>,idx_key1 <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> func <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果使用索引获取某些范围区间的记录，那么就可能使用到 range 访问方法</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是 index</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> key_part2 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> idx_key_part  <span class="operator">|</span> idx_key_part <span class="operator">|</span> <span class="number">909</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>全表扫描</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>小结</p>
<p>  结果值从最好到最坏依次是：</p>
<p>  <strong>system</strong> &gt; <strong>const</strong> &gt; <strong>eq_ref</strong> &gt; <strong>ref</strong> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <strong>range</strong> &gt; <strong>index</strong> &gt; <strong>ALL</strong></p>
<p>  其中比较重要的几个提取出来 (加粗的)。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts 级别。</p>
</li>
</ul>
</li>
<li><p>possible_keys 和 key (可能用到的索引和实际上使用的索引)</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys     <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1,idx_key3 <span class="operator">|</span> idx_key3 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>     <span class="number">5.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>key_len：实际使用到的索引长度 (即：字节数)</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10005</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> const <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ref：当使用索引列等值查询时，与索引列进行等值匹配的对象信息。</p>
<p>  比如知识一个常数或者是某个列。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>              <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> mysql_test.s2.id <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>rows：预估的需要读取的记录条数，值越小越好</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">366</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>filtered：某个表经过搜索条件过滤后剩余记录条数的百分比。</p>
<p>  如果使用的是索引执行的单表扫描，那么计算时需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">366</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span>; <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>   对于单表查询来说，这个 filtered 列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的 filtered 值，它决定了被驱动表要执行的次数 (即：rows * filtered)</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> mysql_test.s1.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Extra：一些额外的信息，更准确的理解 MySQL 到底将如何执行给定的查询语句。</p>
<p>  当查询语句没有 FROM 字句时将会提示该额外信息</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">No</span> tables used <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br></pre></td></tr></table></figure>

<p>  查询语句的 WHERE 字句永远为 FALSE 时将会提示该额外信息</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">!=</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> Impossible <span class="keyword">WHERE</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span></span><br></pre></td></tr></table></figure>

<p>  当我们使用全表扫描来执行对某个表的查询，并且该语句的 WHERE 字句中有针对该表的搜索条件时，在 Extra 列中会提示上述额外信息</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<p>  当查询列表处有 MIN 或者 MAX 聚合函数，但是并没有符合 WHERE 字句中国呢的搜索条件的记录时，将会提示该额外信息</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(key1) <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;abcdefg&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">No</span> matching min<span class="operator">/</span>max <span class="type">row</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+</span></span><br></pre></td></tr></table></figure>

<p>  当查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用覆盖索引的情况下，在 Extra 列将会提示该额外信息。比方说下边这个查询中只需要用到 idx_key1 而不需要回表操作：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<p>  有些搜索条件中虽然出现了索引列，但却不能使用到索引</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key1 <span class="keyword">LIKE</span> <span class="string">&#x27;%a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">366</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure>

<p>  在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL 一般会为其分配一块名叫 join buffer 的内存块来加快查询速度，也就是我们所说的基于块的嵌套循环算法</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.common_field <span class="operator">=</span> s2.common_field;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">join</span> buffer (hash <span class="keyword">join</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>  当我们使用左连接时，如果 WHERE 子句中包含要求被驱动表的某个列等于 NULL 值的搜索条件，而且那个列又是不允许存储 NULL 值的，那么在该表的执行计划的 Extra 列就会提示 Not exists 额外信息</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> mysql_test.s1.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Not</span> <span class="keyword">exists</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------------------+</span></span><br></pre></td></tr></table></figure>

<p>  如果执行计划的 Extra 列出现了 Using intersect(…) 提示，说明准备使用 Intersect 索引合并的方式执行查询，括号中的 … 表示需要进行索引合并的索引名称。如果出现了 Using union(…) 提示，说明准备使用 Union 索引合并的方式执行查询。出现了 Using sort union(…) 提示，说明准备使用 Sort-Union 索引合并的方式执行查询。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type        <span class="operator">|</span> possible_keys     <span class="operator">|</span> key               <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index_merge <span class="operator">|</span> idx_key1,idx_key3 <span class="operator">|</span> idx_key1,idx_key3 <span class="operator">|</span> <span class="number">303</span>,<span class="number">303</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">union</span>(idx_key1,idx_key3); <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>  当我们的 LIMIT 子句的参数为 0 时，表示压根不打算从表中读出任何记录，将会提示该额外信息</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 LIMIT <span class="number">0</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> Zero limit <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+</span></span><br></pre></td></tr></table></figure>

<p>  有一些情况对结果集中的记录进行排序是可以使用到索引的。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> key1 LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>

<p>  很多情况下排序操作无法使用到索引，只能在内存中 (记录较少的时候) 或者磁盘中 (记录较多的时候) 进行排序，MySQL 把这种在内存或者磁盘上进行排序的方式统称为文件排序 (英文名：filesort)</p>
<p>  如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的 Extra 列中显示 Using filesort 提示</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> common_field LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br></pre></td></tr></table></figure>

<p>  在许多查询的执行过程中，MySQL 可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含 DISTINCT、GROUP BY、UNION 等子句的查询过程中，如果不能有效利用索引来完成查询，MySQL 很有可能寻求通过建立内部临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的 Extra 列将会显示 Using temporary 提示。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> common_field <span class="keyword">FROM</span> s1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br></pre></td></tr></table></figure>

<p>  执行计划中出现 Using temporary 并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以我们最好能使用索引来替代掉使用临时表。比如：扫描指定的索引 idx_key1 即可。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> key1, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> amount <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> key1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>小结</p>
<ul>
<li>EXPLAIN 不考虑各种 cache</li>
<li>EXPLAIN 不能显示 MySQL 在执行查询时所作的优化工作</li>
<li>EXPLAIN 不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li>
<li>部分统计信息是估算的，并非精确值</li>
</ul>
</li>
</ul>
<h3 id="EXPLAIN-的进一步使用"><a href="#EXPLAIN-的进一步使用" class="headerlink" title="EXPLAIN 的进一步使用"></a>EXPLAIN 的进一步使用</h3><h4 id="EXPLAIN-四种输出格式"><a href="#EXPLAIN-四种输出格式" class="headerlink" title="EXPLAIN 四种输出格式"></a>EXPLAIN 四种输出格式</h4><ul>
<li><p>传统格式</p>
<p>  传统格式简单明了，输出是一个表格形式，概要说明查询计划。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> s1.key1, s2.key1 <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.common_field <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>    <span class="number">90.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> mysql_test.s2.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JSON 格式</p>
<p>  第一种格式中介绍的 EXPLAIN 语句输出中缺少了一个衡量执行计划好坏的重要属性——成本。而 JSON 格式是四种格式里面输出信息最详尽的格式，里面包含了执行的成本信息。</p>
<ul>
<li><p>JSON 格式：在 EXPLAIN 单词和真正的查询语句中间加上 FORMAT&#x3D;JSON。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT<span class="operator">=</span>JSON <span class="keyword">SELECT</span> ......</span><br></pre></td></tr></table></figure>
</li>
<li><p>EXPLAIN 的 Column 与 JSON 的对应关系</p>
<table>
<thead>
<tr>
<th>Column</th>
<th>JSON Name</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>select_id</td>
<td>The SELECT identifier</td>
</tr>
<tr>
<td>select_type</td>
<td>None</td>
<td>The SELECT type</td>
</tr>
<tr>
<td>table</td>
<td>table_name</td>
<td>The table for the output row</td>
</tr>
<tr>
<td>partitions</td>
<td>partitions</td>
<td>The matching partitions</td>
</tr>
<tr>
<td>type</td>
<td>access_type</td>
<td>The join type</td>
</tr>
<tr>
<td>possible_keys</td>
<td>possible_keys</td>
<td>The possible indexes to choose</td>
</tr>
<tr>
<td>key</td>
<td>key</td>
<td>The index actually chosen</td>
</tr>
<tr>
<td>ken_len</td>
<td>key_length</td>
<td>The length of the chosen key</td>
</tr>
<tr>
<td>ref</td>
<td>ref</td>
<td>The columns compared to the index</td>
</tr>
<tr>
<td>rows</td>
<td>rows</td>
<td>Estimate of rows to be examined</td>
</tr>
<tr>
<td>filtered</td>
<td>filtered</td>
<td>Percentage of rows filtered by table condition</td>
</tr>
<tr>
<td>Extra</td>
<td>None</td>
<td>Additional information</td>
</tr>
</tbody></table>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT<span class="operator">=</span>JSON <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key2 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">EXPLAIN: &#123;</span><br><span class="line">  &quot;query_block&quot;: &#123;</span><br><span class="line">    &quot;select_id&quot;: <span class="number">1</span>,</span><br><span class="line">    &quot;cost_info&quot;: &#123;</span><br><span class="line">      &quot;query_cost&quot;: &quot;1360.07&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;nested_loop&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;table&quot;: &#123;</span><br><span class="line">          &quot;table_name&quot;: &quot;s1&quot;,</span><br><span class="line">          &quot;access_type&quot;: &quot;ALL&quot;,</span><br><span class="line">          &quot;possible_keys&quot;: [</span><br><span class="line">            &quot;idx_key1&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;rows_examined_per_scan&quot;: <span class="number">9895</span>,</span><br><span class="line">          &quot;rows_produced_per_join&quot;: <span class="number">989</span>,</span><br><span class="line">          &quot;filtered&quot;: &quot;10.00&quot;,</span><br><span class="line">          &quot;cost_info&quot;: &#123;</span><br><span class="line">            &quot;read_cost&quot;: &quot;914.80&quot;,</span><br><span class="line">            &quot;eval_cost&quot;: &quot;98.95&quot;,</span><br><span class="line">            &quot;prefix_cost&quot;: &quot;1013.75&quot;,</span><br><span class="line">            &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;used_columns&quot;: [</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;key1&quot;,</span><br><span class="line">            &quot;key2&quot;,</span><br><span class="line">            &quot;key3&quot;,</span><br><span class="line">            &quot;key_part1&quot;,</span><br><span class="line">            &quot;key_part2&quot;,</span><br><span class="line">            &quot;key_part3&quot;,</span><br><span class="line">            &quot;common_field&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;attached_condition&quot;: &quot;((`mysql_test`.`s1`.`common_field` = &#x27;a&#x27;) and (`mysql_test`.`s1`.`key1` is not null))&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;table&quot;: &#123;</span><br><span class="line">          &quot;table_name&quot;: &quot;s2&quot;,</span><br><span class="line">          &quot;access_type&quot;: &quot;eq_ref&quot;,</span><br><span class="line">          &quot;possible_keys&quot;: [</span><br><span class="line">            &quot;idx_key2&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;key&quot;: &quot;idx_key2&quot;,</span><br><span class="line">          &quot;used_key_parts&quot;: [</span><br><span class="line">            &quot;key2&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;key_length&quot;: &quot;5&quot;,</span><br><span class="line">          &quot;ref&quot;: [</span><br><span class="line">            &quot;mysql_test.s1.key1&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;rows_examined_per_scan&quot;: <span class="number">1</span>,</span><br><span class="line">          &quot;rows_produced_per_join&quot;: <span class="number">989</span>,</span><br><span class="line">          &quot;filtered&quot;: &quot;100.00&quot;,</span><br><span class="line">          &quot;index_condition&quot;: &quot;(cast(`mysql_test`.`s1`.`key1` as double) = cast(`mysql_test`.`s2`.`key2` as double))&quot;,</span><br><span class="line">          &quot;cost_info&quot;: &#123;</span><br><span class="line">            &quot;read_cost&quot;: &quot;247.38&quot;,</span><br><span class="line">            &quot;eval_cost&quot;: &quot;98.95&quot;,</span><br><span class="line">            &quot;prefix_cost&quot;: &quot;1360.08&quot;,</span><br><span class="line">            &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;used_columns&quot;: [</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;key1&quot;,</span><br><span class="line">            &quot;key2&quot;,</span><br><span class="line">            &quot;key3&quot;,</span><br><span class="line">            &quot;key_part1&quot;,</span><br><span class="line">            &quot;key_part2&quot;,</span><br><span class="line">            &quot;key_part3&quot;,</span><br><span class="line">            &quot;common_field&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  s1 表的的成本计算：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">  &quot;read_cost&quot;: &quot;914.80&quot;,</span><br><span class="line">  &quot;eval_cost&quot;: &quot;98.95&quot;,</span><br><span class="line">  &quot;prefix_cost&quot;: &quot;1013.75&quot;,</span><br><span class="line">  &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>read_cost 是由下边这两部分组成的：</p>
<ul>
<li>IO 成本</li>
<li>检测 <code>rows * (1 - filter)</code> 条记录的 CPU 成本</li>
</ul>
<blockquote>
<p>rows 和 filter 都是前边介绍执行计划的输出列，在 JSON 格式的执行计划中，rows 相当于 rows_wxamined_per_scan，filtered 名称不变。</p>
</blockquote>
</li>
<li><p>eval_cost 是这样计算的：</p>
<p>  检测 <code>rows * filter</code> 条记录的成本</p>
</li>
<li><p>prefix_cost 就是单独查询 s1 表的成本，也就是：</p>
<p>  <code>read_cost + eval_cost</code></p>
</li>
<li><p>data_read_per_join 表示在此次查询中需要读取的数据量。</p>
</li>
</ul>
<p>  对于 s2 表的 cost_info 部分是这样的：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">  &quot;read_cost&quot;: &quot;247.38&quot;,</span><br><span class="line">  &quot;eval_cost&quot;: &quot;98.95&quot;,</span><br><span class="line">  &quot;prefix_cost&quot;: &quot;1360.08&quot;,</span><br><span class="line">  &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  由于 s2 表是被驱动表，所以可能被读取多次，这里的 read_cost 和 eval_cost 是访问多次 s2 表后累加起来的值，主要关注里边的 prefix_cost 的值代表的是整个连接查询预计的成本，也就是单词查询 s1 表和多次查询 s2 表后的成本的和，也就是：</p>
<p>  <code>247.38 + 98.95 + 1013.75 = 1360.08</code></p>
</li>
</ul>
</li>
<li><p>TREE 格式</p>
<p>  TREE 格式是 8.0.16 版本之后引入的新格式，主要根据查询的各个部分之间的关系和各部分的执行顺序来描述如何查询。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT<span class="operator">=</span>TREE <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key2 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>\G</span><br><span class="line">EXPLAIN: <span class="operator">-</span><span class="operator">&gt;</span> Nested loop <span class="keyword">inner</span> <span class="keyword">join</span>  (cost<span class="operator">=</span><span class="number">1360.08</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">990</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Filter</span>: ((s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>) <span class="keyword">and</span> (s1.key1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>))  (cost<span class="operator">=</span><span class="number">1013.75</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">990</span>)</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Table</span> scan <span class="keyword">on</span> s1  (cost<span class="operator">=</span><span class="number">1013.75</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">9895</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> Single<span class="operator">-</span><span class="type">row</span> index lookup <span class="keyword">on</span> s2 <span class="keyword">using</span> idx_key2 (key2<span class="operator">=</span>s1.key1), <span class="keyword">with</span> index <span class="keyword">condition</span>: (<span class="built_in">cast</span>(s1.key1 <span class="keyword">as</span> <span class="keyword">double</span>) <span class="operator">=</span> <span class="built_in">cast</span>(s2.key2 <span class="keyword">as</span> <span class="keyword">double</span>))  (cost<span class="operator">=</span><span class="number">0.25</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>可视化输出</p>
<p>  可视化输出，可以通过 MySQL Workbench 可视化查看 MySQL 的执行计划。通过点击 workbench 的放大镜图标，即可生成可视化的查询计划。</p>
</li>
</ul>
<h4 id="SHOW-WARNINGS-的使用"><a href="#SHOW-WARNINGS-的使用" class="headerlink" title="SHOW WARNINGS 的使用"></a>SHOW WARNINGS 的使用</h4><p>在使用 EXPLAIN 语句查看了某个查询的执行计划之后，紧接着还可以使用 SHOW WARNINGS 语句查看与这个查询的执行计划有关的一下扩展信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> s1.key1, s2.key1 <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.common_field <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>    <span class="number">90.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> mysql_test.s2.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> WARNINGS \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">  Level: Note</span><br><span class="line">   Code: <span class="number">1003</span></span><br><span class="line">Message: <span class="comment">/* select#1 */</span> <span class="keyword">select</span> `mysql_test`.`s1`.`key1` <span class="keyword">AS</span> `key1`,`mysql_test`.`s2`.`key1` <span class="keyword">AS</span> `key1` <span class="keyword">from</span> `mysql_test`.`s1` <span class="keyword">join</span> `mysql_test`.`s2` <span class="keyword">where</span> ((`mysql_test`.`s1`.`key1` <span class="operator">=</span> `mysql_test`.`s2`.`key1`) <span class="keyword">and</span> (`mysql_test`.`s2`.`common_field` <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>))</span><br></pre></td></tr></table></figure>

<p>可以看到 SHOW WARNINGS 展示出来的信息有三个字段：Level、Code、Message。最常见的就是 Code 为 1003 的信息，当 Code 为 1003 时，Message 字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。比如上边的查询本来是一个左外连接查询，但是有一个 s2.common_field IS NOT NULL 的条件，就会导致查询优化器把左外连接查询优化为内连接查询，从 SHOW WARNINGS 的 Message 字段也可以看出来，原本的 LEFT JOIN 已经变成了 JOIN。</p>
<h3 id="分析优化器执行计划：trace"><a href="#分析优化器执行计划：trace" class="headerlink" title="分析优化器执行计划：trace"></a>分析优化器执行计划：trace</h3><p>OPTIMIZER_TRACE 是 MySQL 5.6 引入的一项跟踪功能，它可以跟踪优化器做出的各种决策 (比如访问表的方法、各种开销计算、各种转换等)，并将跟踪结果记录到 INFORMATION_SCHEMA.OPTIMIZER_TRACE 表中。</p>
<p>此功能默认关闭。开启 trace，并设置格式为 JSON，同时设置 trace 最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enable=on&#x27;</span>,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">SET</span> optimizer_trace_max_mem_size<span class="operator">=</span><span class="number">1000000</span>;</span><br></pre></td></tr></table></figure>

<p>开启后，可分析如下语句：</p>
<ul>
<li>SELECT</li>
<li>INSERT</li>
<li>REPLACE</li>
<li>UPDATE</li>
<li>DELETE</li>
<li>EXPLAIN</li>
<li>SET</li>
<li>DECLARE</li>
<li>CASE</li>
<li>IF</li>
<li>RETURN</li>
<li>CALL</li>
</ul>
<p>执行 SQL 后执行 <code>SELECT * FROM information_schema.optimizer_trace \G</code></p>
<p>结果包括四部分：</p>
<ul>
<li>查询语句</li>
<li>QUERY 字段对应语句的跟踪信息</li>
<li>跟踪信息过长时，被截断的跟踪信息的字节数</li>
<li>执行跟踪语句的用户是否有查看对象的权限，当不具有权限时，该列信息为 1 且 TRACE 字段为空，一般在调用带有 SQL SECURITY DEFINER 的视图或者是存储过程的情况下，会出现此问题。</li>
</ul>
<h3 id="MySQL-监控分析视图-sys-schema"><a href="#MySQL-监控分析视图-sys-schema" class="headerlink" title="MySQL 监控分析视图 - sys schema"></a>MySQL 监控分析视图 - sys schema</h3><p>关于 MySQL 的性能监控和问题诊断，我们一般都从 performance_schema 中去获取想要的数据，在 MySQL 5.7.7 版本中新增 sys schema，它将 performance_schema 和 information_schema 中的数据以更容易理解的方式总结归纳为视图，其目的就是为了降低查询 performance_schema 的复杂度，让 DBA 能够快速的定位问题。</p>
<h4 id="Sys-schema-视图摘要"><a href="#Sys-schema-视图摘要" class="headerlink" title="Sys schema 视图摘要"></a>Sys schema 视图摘要</h4><ul>
<li>主机相关：以 host_summary开头，主要汇总了 IO 延迟的信息。</li>
<li>Innodb 相关：以 innodb 开头，汇总了 innodb buffer 信息和事务等待 innodb 锁的信息。</li>
<li>I&#x2F;O 相关：以 io 开头，汇总了等待 I&#x2F;O、I&#x2F;O 使用量情况。</li>
<li>内存使用情况：以 memory 开头，从主机、县城、事件等角度展示内存的使用情况。</li>
<li>连接与会话信息：processlist 和 session 相关视图，总结了会话相关信息。</li>
<li>表相关：以 schema_table 开头的视图，展示了表的统计信息。</li>
<li>索引信息：统计了索引的使用情况，包含冗余索引和未使用的索引情况。</li>
<li>语句相关：以 statement 开头，包含了执行全表扫描、使用临时表、排序等的语句信息。</li>
<li>用户相关：以 user 开头的视图，统计了用户使用的文件 I&#x2F;O、执行语句统计信息。</li>
<li>等待事件相关信息：以 wait 开头，展示等待事件的延迟情况。</li>
</ul>
<h4 id="Sys-schema-视图使用场景"><a href="#Sys-schema-视图使用场景" class="headerlink" title="Sys schema 视图使用场景"></a>Sys schema 视图使用场景</h4><p><strong>索引情况</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查询冗余索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_redundant_indexes;</span><br><span class="line"></span><br><span class="line"># 查询未使用过的索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_unused_indexes;</span><br><span class="line"></span><br><span class="line"># 查询索引的使用情况</span><br><span class="line"><span class="keyword">select</span> index_name, rows_selected, rows_inserted, rows_updated, rows_deleted <span class="keyword">from</span> sys.schema_index_statistics <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>表相关</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查询表的访问量</span><br><span class="line"><span class="keyword">select</span> table_schema, table_name, <span class="built_in">sum</span>(io_read_requests<span class="operator">+</span>io_write_requests) <span class="keyword">as</span> io <span class="keyword">from</span> sys.schema_table_statistics <span class="keyword">group</span> <span class="keyword">by</span> table_schema, table_name <span class="keyword">order</span> <span class="keyword">by</span> io <span class="keyword">desc</span>;</span><br><span class="line"># 查询占用 bufferpool 较多的表</span><br><span class="line"><span class="keyword">select</span> object_schema, object_name, allocated, data <span class="keyword">from</span> sys.innodb_buffer_stats_by_table <span class="keyword">order</span> <span class="keyword">by</span> allocated limit <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># 查看表的全表扫描情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.statements_with_full_table_scans <span class="keyword">where</span> db<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>语句相关</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 监控 <span class="keyword">SQL</span> 执行的频率</span><br><span class="line"><span class="keyword">select</span> db, exec_count, query <span class="keyword">from</span> sys.statement_analysis <span class="keyword">order</span> <span class="keyword">by</span> exec_count <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"># 监控使用了排序的 <span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db, exec_count, first_seen, last_seen, query <span class="keyword">from</span> sys.statements_with_sorting limit <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># 监控使用了临时表或磁盘临时表的 <span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db, exec_count, tmp_tables, tmp_disk_tables, query <span class="keyword">from</span> sys.statement_analysis <span class="keyword">where</span> tmp_tables <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">or</span> tmp_disk_tables <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">order</span> <span class="keyword">by</span> (tmp_tables <span class="operator">+</span> tmp_disk_tables) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p><strong>IO 相关</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看消耗磁盘 IO 的文件</span><br><span class="line"><span class="keyword">select</span> file, avg_read, avg_write, avg_read <span class="operator">+</span> avg_write <span class="keyword">as</span> avg_io <span class="keyword">from</span> sys.io_global_by_file_by_bytes <span class="keyword">order</span> <span class="keyword">by</span> avg_read limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Innodb 相关</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 行锁阻塞情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>风险提示：</p>
<p>通过 sys 库去查询时，MySQL 会消耗大量资源去收集相关信息，严重的可能会导致业务请求被阻塞，从而引起故障。建议生产上不要频繁的去查询 sys 或者 performance_schema、information_schema 来完成监控、巡检等工作。</p>
</blockquote>
<h2 id="索引优化与查询优化"><a href="#索引优化与查询优化" class="headerlink" title="索引优化与查询优化"></a>索引优化与查询优化</h2><p>都有哪些维度可以进行数据库调优？简言之：</p>
<ul>
<li>索引失效、没有充分利用到索引——索引建立</li>
<li>关联查询太多 JOIN (设计缺陷或不得已的需求) ——SQL 优化</li>
<li>服务器调优及各个参数设置 (缓冲、线程数等)——调整 my.cnf</li>
<li>数据过多——分库分表</li>
</ul>
<p>SQL 查询优化的技术大致可以分成物理查询优化和逻辑查询优化两大块。</p>
<ul>
<li>物理查询优化是通过索引和表连接方式等技术来进行优化，这里重点需要掌握索引的使用。</li>
<li>逻辑查询优化就是通过 SQL 等价变换提升查询效率，直白一点就是说，换一种查询写法执行效率可能更高。</li>
</ul>
<h3 id="数据准备-2"><a href="#数据准备-2" class="headerlink" title="数据准备"></a>数据准备</h3><h4 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> class(</span><br><span class="line">	id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  className <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  address <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  monitor <span class="type">INT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">	id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  stuno <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  age <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  classId <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">  # <span class="keyword">CONSTRAINT</span> fk_class_id <span class="keyword">FOREIGN</span> KEY (classId) <span class="keyword">REFERENCES</span> t_class (id)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<h4 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 开启允许创建函数设置：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 生成随机字符串</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>)</span><br><span class="line">	<span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>)	#	该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line">		<span class="keyword">SET</span> return_str <span class="operator">=</span> CONCAT(return_str, <span class="built_in">SUBSTRING</span>(chars_str, <span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> RAND() <span class="operator">*</span> <span class="number">52</span>), <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">END</span> WHILE;</span><br><span class="line">	<span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 生成随机班级编号</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num(from_num <span class="type">INT</span>, to_num <span class="type">INT</span>)</span><br><span class="line">	<span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span> RAND() <span class="operator">*</span> (to_num <span class="operator">-</span> from_num <span class="operator">+</span> <span class="number">1</span>));</span><br><span class="line"><span class="keyword">RETURN</span> i;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 删除函数</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> 函数名;</span><br></pre></td></tr></table></figure>

<h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 创建往 stu 表中插入数据的存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_stu(<span class="keyword">START</span> <span class="type">INT</span>, max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;    # 设置手动提交事物</span><br><span class="line">	REPEAT      # 循环</span><br><span class="line">	<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;    # 赋值</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (stuno, name, age, classId) <span class="keyword">VALUES</span></span><br><span class="line">	((<span class="keyword">START</span> <span class="operator">+</span> i), rand_string(<span class="number">6</span>), rand_num(<span class="number">1</span>, <span class="number">50</span>), rand_num(<span class="number">1</span>, <span class="number">1000</span>));</span><br><span class="line">	UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">	<span class="keyword">END</span> REPEAT;</span><br><span class="line">	<span class="keyword">COMMIT</span>;			# 提交事物</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 往 class 表中插入数据的存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_class(max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;    # 设置手动提交事物</span><br><span class="line">	REPEAT      # 循环</span><br><span class="line">	<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;    # 赋值</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> class (classname, address, monitor) <span class="keyword">VALUES</span></span><br><span class="line">	(rand_string(<span class="number">8</span>), rand_string(<span class="number">10</span>), rand_num(<span class="number">1</span>, <span class="number">100000</span>));</span><br><span class="line">	UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">	<span class="keyword">END</span> REPEAT;</span><br><span class="line">	<span class="keyword">COMMIT</span>;			# 提交事物</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 删除存储过程</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> 存储过程名;</span><br></pre></td></tr></table></figure>

<h4 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 向 class 表中添加一万条数据</span><br><span class="line"><span class="keyword">CALL</span> insert_class(<span class="number">10000</span>);</span><br><span class="line"># 向 stu 表中添加 <span class="number">50</span> 万条数据</span><br><span class="line"><span class="keyword">CALL</span> insert_stu(<span class="number">100000</span>, <span class="number">500000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="删除某表上的索引"><a href="#删除某表上的索引" class="headerlink" title="删除某表上的索引"></a>删除某表上的索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc_drop_index(dbname <span class="type">VARCHAR</span>(<span class="number">200</span>), tablename <span class="type">VARCHAR</span>(<span class="number">200</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> ct <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> _index <span class="type">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> _cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> index_name <span class="keyword">FROM</span> information_schema.STATISTICS <span class="keyword">WHERE</span> table_schema<span class="operator">=</span>dbname <span class="keyword">AND</span> table_name<span class="operator">=</span>tablename <span class="keyword">AND</span> seq_in_index<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> index_name <span class="operator">&lt;&gt;</span> <span class="string">&#x27;PRIMARY&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">set</span> done <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">OPEN</span> _cur;</span><br><span class="line">    <span class="keyword">FETCH</span> _cur <span class="keyword">INTO</span> _index;</span><br><span class="line">    WHILE _index<span class="operator">&lt;&gt;</span><span class="string">&#x27;&#x27;</span> DO</span><br><span class="line">      <span class="keyword">SET</span> <span class="variable">@str</span> <span class="operator">=</span> CONCAT(&quot;drop index &quot;, _index, &quot; on &quot;, tablename);</span><br><span class="line">      <span class="keyword">PREPARE</span> sql_str <span class="keyword">FROM</span> <span class="variable">@str</span>;</span><br><span class="line">      <span class="keyword">EXECUTE</span> sql_str;</span><br><span class="line">      <span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> sql_str;</span><br><span class="line">      <span class="keyword">SET</span> _index<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="keyword">FETCH</span> _cur <span class="keyword">INTO</span> _index;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line">	<span class="keyword">CLOSE</span> _cur;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line"><span class="keyword">CALL</span> proc_drop_index(&quot;dbname&quot;, &quot;tablename&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="索引失效案例"><a href="#索引失效案例" class="headerlink" title="索引失效案例"></a>索引失效案例</h3><p>MySQL 中提高性能的一个最有效的方式是对数据表设计合理的索引。索引提供了高效访问数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。</p>
<ul>
<li>使用索引可以快速地定位表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。</li>
<li>如果查询时没有使用索引，查询语句就会扫描表中的所有记录。在数据量大的情况下，这样查询的速度会很慢。</li>
</ul>
<p>大多数情况下都 (默认) 采用 B+ 树来构建索引。只是空间列类型的索引使用 R-树，并且 MEMORY 表还支持 hash 索引。</p>
<p>其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？给予 cost 开销 (CostBaseOptimizer)，它不是基于规则 (Rule-BasedOptimizer)，也不是基于语义。怎么样开销小就怎么来。另外，SQL 语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</p>
<h4 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h4><p>系统中经常出现的 SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> classId <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> classId <span class="operator">=</span> <span class="number">4</span> <span class="keyword">AND</span> `NAME` <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>建立索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age <span class="keyword">ON</span> student(age);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid <span class="keyword">ON</span> student(age, classId);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student(age, classId, name);</span><br></pre></td></tr></table></figure>

<p>创建索引前的查询时间是 0.137s，创建索引后的查询时间是 0.001s。</p>
<h4 id="最佳左前缀法则"><a href="#最佳左前缀法则" class="headerlink" title="最佳左前缀法则"></a>最佳左前缀法则</h4><p>在 MySQL 建立联合索引时，会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> student.`name` <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.classId <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> student.`name` <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.classId <span class="operator">=</span> <span class="number">4</span> <span class="keyword">AND</span> student.age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> student.`name` <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>MySQL 可以为多个字段创建索引，一个索引可以包括 16 个字段。对于多列索引，<strong>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用</strong>。如果查询条件中没有使用这些字段中第一个字段时，多列或联合索引不会被使用。</p>
<blockquote>
<p>拓展：Alibaba《Java 开发手册》</p>
<p>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
</blockquote>
<h4 id="主键插入顺序"><a href="#主键插入顺序" class="headerlink" title="主键插入顺序"></a>主键插入顺序</h4><p>对于一个使用 InnoDB 存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在 1～100 之间，如果此时再插入一条主键值为 9 的记录，那它插入的位置在 8 和 10 之间，但是这个数据页已经满了，再插进来就需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着性能损耗。所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值一次递增，这样就不会发生这样的性能损耗了。所以建议：让主键具有 AUTO_INCREMENT，让存储引擎自己为表生成主键，而不是我们手动插入。</p>
<p>我们自定义的主键列 id 拥有 AUTO_INCREMENT 属性，再插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。</p>
<h4 id="计算、函数、类型转换到值索引失效"><a href="#计算、函数、类型转换到值索引失效" class="headerlink" title="计算、函数、类型转换到值索引失效"></a>计算、函数、类型转换到值索引失效</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.`name` <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(student.`name`, <span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> index idx_name <span class="keyword">ON</span> student(name);</span><br></pre></td></tr></table></figure>

<p>上面两个 SQL，第一个索引生效，第二个索引失效。</p>
<h4 id="类型转换到值索引失效"><a href="#类型转换到值索引失效" class="headerlink" title="类型转换到值索引失效"></a>类型转换到值索引失效</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="number">123</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_name      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_name      <span class="operator">|</span> idx_name <span class="operator">|</span> <span class="number">63</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>

<p>student 表中 name 字段是字符串类型，第一个 SQL 在执行时，会隐式将 name 转换成 整形，所以会导致索引失效。</p>
<blockquote>
<p>设计实体类属性时，一定要与数据库字段类型相对应。否则，就会出现类习惯转换的情况。</p>
</blockquote>
<h4 id="范围条件右边的列索引失效"><a href="#范围条件右边的列索引失效" class="headerlink" title="范围条件右边的列索引失效"></a>范围条件右边的列索引失效</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student(age, classId, name);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> classId <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">AND</span> `NAME` <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+-------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys        <span class="operator">|</span> key                  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+-------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_age_classid_name <span class="operator">|</span> idx_age_classid_name <span class="operator">|</span> <span class="number">10</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">19008</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+-------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure>

<p>根据 key_len 可以看出该 SQL 只用到了联合索引的 age 和 classId，name 并没有用到。范围条件：&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 和 between 等。</p>
<p>在实际开发中，将范围查询条件防止语句最后，建索引时，也将该字段放置在最后。</p>
<blockquote>
<p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置 where 语句最后。</p>
</blockquote>
<h4 id="不等于-x3D-或-lt-gt-索引失效"><a href="#不等于-x3D-或-lt-gt-索引失效" class="headerlink" title="不等于 (!&#x3D; 或 &lt;&gt;) 索引失效"></a>不等于 (!&#x3D; 或 &lt;&gt;) 索引失效</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> `NAME` <span class="operator">&lt;&gt;</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_name      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">50.15</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<h4 id="IS-NULL-可以使用索引，IS-NOT-NULL-无法使用索引"><a href="#IS-NULL-可以使用索引，IS-NOT-NULL-无法使用索引" class="headerlink" title="IS NULL 可以使用索引，IS NOT NULL 无法使用索引"></a>IS NULL 可以使用索引，IS NOT NULL 无法使用索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys        <span class="operator">|</span> key                  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_age_classid_name <span class="operator">|</span> idx_age_classid_name <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys        <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_age_classid_name <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">50.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：最好在设计数据表的时候就将字段设置为 NOT NULL 约束，比如你可以将 INT 类型的字段，默认值设置为 0。将字符类型的默认值设置为空字符串 (‘’)。</p>
<p>拓展：同理，在查询中使用 NOT LIKE 也无法使用索引，到值全表扫描。</p>
</blockquote>
<h4 id="like-以通配符-开头索引失效"><a href="#like-以通配符-开头索引失效" class="headerlink" title="like 以通配符 % 开头索引失效"></a>like 以通配符 % 开头索引失效</h4><p>在使用 LIKE 关键字进行查询的查询语句中，如果匹配字符串的第一个字符为 %，索引就不会起作用。只有 % 不在第一个位置，索引才会起作用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.`name` <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_name      <span class="operator">|</span> idx_name <span class="operator">|</span> <span class="number">63</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.`name` <span class="keyword">LIKE</span> <span class="string">&#x27;%abc&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">11.11</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>拓展：Alibaba《Java 开发手册》</p>
<p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p>
</blockquote>
<h4 id="OR-前后存在非索引的列，索引失效"><a href="#OR-前后存在非索引的列，索引失效" class="headerlink" title="OR 前后存在非索引的列，索引失效"></a>OR 前后存在非索引的列，索引失效</h4><p>在 WHERE 字句中，如果在 OR 前的条件列进行了索引，而在 OR 后的条件列没有进行索引，那么索引会失效。也就是说，OR 前后的两个条件中的列都是索引时，查询中才使用索引。</p>
<p>因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列进行了索引是没有意义的，只要有条件列没有进行索引，就会进行全表扫描，因此索引的条件列也会失效。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age <span class="keyword">ON</span> student(age);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">OR</span> classId <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_age       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">11.88</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> index idx_cid <span class="keyword">ON</span> student(classId);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------------+-----------------+-----------------+---------+------+-------+----------+-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type        <span class="operator">|</span> possible_keys   <span class="operator">|</span> key             <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------------+-----------------+-----------------+---------+------+-------+----------+-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index_merge <span class="operator">|</span> idx_age,idx_cid <span class="operator">|</span> idx_age,idx_cid <span class="operator">|</span> <span class="number">5</span>,<span class="number">5</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10232</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">union</span>(idx_age,idx_cid); <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------------+-----------------+-----------------+---------+------+-------+----------+-------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>当只在 age 字段上建立索引时，会导致索引失效。如果再给 classId 字段建立索引，此时就可以使用索引。</p>
<h4 id="数据库和表的字符集统一使用-utf8mb4"><a href="#数据库和表的字符集统一使用-utf8mb4" class="headerlink" title="数据库和表的字符集统一使用 utf8mb4"></a>数据库和表的字符集统一使用 utf8mb4</h4><p>统一使用 utf8mb4兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。</p>
<h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><ul>
<li>对于单列索引，尽量选择针对当前 query 过滤性更好的索引。</li>
<li>在选择组合索引的时候，当前 query 中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li>
<li>在选择组合索引的时候，尽量选择能够包含当前 query 中的 where 子句中更多字段的索引。</li>
<li>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。</li>
</ul>
<p>总之，书写 SQL 语句时，尽量避免造成索引失效的情况。 </p>
<h3 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h3><h4 id="数据准备-3"><a href="#数据准备-3" class="headerlink" title="数据准备"></a>数据准备</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 分类表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `type`(</span><br><span class="line">	id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  card <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"># 图书表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> book(</span><br><span class="line">	bookId <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  card <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (bookId)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 向分类表中插入 <span class="number">20</span> 条记录</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TYPE(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"></span><br><span class="line"># 向图书表中插入 <span class="number">20</span> 条记录</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br></pre></td></tr></table></figure>

<h4 id="采用左外连接"><a href="#采用左外连接" class="headerlink" title="采用左外连接"></a>采用左外连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> `type` <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card <span class="operator">=</span> book.card; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> type  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> book  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">join</span> buffer (hash <span class="keyword">join</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX x <span class="keyword">ON</span> book(card);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> type  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> book  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> x             <span class="operator">|</span> x    <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> mysql_test.type.card <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX y <span class="keyword">ON</span> `type`(card);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> type  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> y    <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> book  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> x             <span class="operator">|</span> x    <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> mysql_test.type.card <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<h4 id="采用内连接"><a href="#采用内连接" class="headerlink" title="采用内连接"></a>采用内连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> `type` <span class="keyword">INNER</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card <span class="operator">=</span> book.card; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> type  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> book  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">join</span> buffer (hash <span class="keyword">join</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX y <span class="keyword">ON</span> `type`(card);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> book  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> type  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> y             <span class="operator">|</span> y    <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> mysql_test.book.card <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX x <span class="keyword">ON</span> book(card);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> book  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> x             <span class="operator">|</span> x    <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> type  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> y             <span class="operator">|</span> y    <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> mysql_test.book.card <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<p>从上述可以得出一下结论：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表。如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表。<strong>当表的连接条件中都没有索引 (或都有索引) 时，数据小的表驱动数据大的表</strong>。</p>
<h4 id="JOIN-语句原理"><a href="#JOIN-语句原理" class="headerlink" title="JOIN 语句原理"></a>JOIN 语句原理</h4><p>JOIN 方式连接多表，本质就是各个表之间数据的循环匹配。MySQL5.5 版本之前，MySQL 只支持一种表间关联方式，就是嵌套循环。如果关联表的数据量很大，则 JOIN 关联的执行时间会非常长。在 MySQL 5.5 以后的版本中，MySQL 通过引入 BNLJ 算法来优化嵌套执行。</p>
<p><strong>驱动表和被驱动表</strong></p>
<p>驱动表就是主表，被驱动表就是从表、非驱动表。</p>
<ul>
<li><p>对于内连接来说：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">JOIN</span> B <span class="keyword">ON</span> ...</span><br></pre></td></tr></table></figure>

<p>  对于内连接来说 A 不一定是驱动表，优化器会根据你查询语句做优化，决定先查哪张表。先查询的那张表就是驱动表，反之就是被驱动表。通过 explain 关键字可以查看。</p>
</li>
<li><p>对于外连接来说：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> ...</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> B <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> A <span class="keyword">ON</span> ...</span><br></pre></td></tr></table></figure>

<p>  通常，会认为 A 就是驱动表，B 就是被驱动表。但也未必。 对于外连接来说，查询优化器可能会将外连接修改为内连接，对于内连接，主从表就会不确定。</p>
</li>
</ul>
<p><strong>简单嵌套循环连接 (Simple Nested-Loop Join)</strong></p>
<p>算法相当简单，从表 A 中取出一条数据 1，遍历表 B，将匹配到的数据放到 result..以此类推，驱动表 A 中的每一条记录与被驱动表 B 的记录进行判断：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%AE%80%E5%8D%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5.png" alt="简单嵌套循环连接"></p>
<p>可以看到这种方式效率是非常低的，以上述表 A 数据 100 条，表 B 数据 1000 条计算，则 A * B &#x3D; 10 万次。开销统计如下：</p>
<table>
<thead>
<tr>
<th>开销统计</th>
<th>SNLJ</th>
</tr>
</thead>
<tbody><tr>
<td>外表扫描次数</td>
<td>1</td>
</tr>
<tr>
<td>内表扫描次数</td>
<td>A</td>
</tr>
<tr>
<td>读取记录数</td>
<td>A + B * A</td>
</tr>
<tr>
<td>JOIN 比较次数</td>
<td>A * B</td>
</tr>
<tr>
<td>回表读取记录次数</td>
<td>0</td>
</tr>
</tbody></table>
<p>当然 MySQL 不会这么粗暴的区进行表的连接，所以就出现了后面的两种对 Nested-Loop Join 优化算法。</p>
<p><strong>索引嵌套循环连接 (Index Nested-Loop Join)</strong></p>
<p>Index Nested-Loop Join 其优化的思路主要是为了减少内层表数据的匹配次数，所以要求被驱动表上必须有索引才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去比较，这样极大的减少了对内层表的匹配次数。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%B4%A2%E5%BC%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5.png" alt="索引嵌套循环连接"></p>
<p>驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故 MySQL 优化器都倾向于使用记录数少的表作为驱动表。</p>
<table>
<thead>
<tr>
<th>开销统计</th>
<th>SNLJ</th>
<th>INLJ</th>
</tr>
</thead>
<tbody><tr>
<td>外表扫描次数</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>内表扫描次数</td>
<td>A</td>
<td>0</td>
</tr>
<tr>
<td>读取记录数</td>
<td>A + B * A</td>
<td>A + B(match)</td>
</tr>
<tr>
<td>JOIN 比较次数</td>
<td>A * B</td>
<td>A * Index(Height)</td>
</tr>
<tr>
<td>回表读取记录次数</td>
<td>0</td>
<td>B(match)(if possible)</td>
</tr>
</tbody></table>
<p>如果被驱动表家索引，效率是非常高的，但如果索引不是主键索引，所以还的进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高。</p>
<p><strong>块嵌套循环连接 (Block Nested-Loop Join)</strong></p>
<p>如果存在索引，那么会使用 index 的方式进行 join，如果 join 的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把驱动表的记录再加载到内存匹配，这样周而复始，大大增加了IO 的次数。为了减少被驱动表的 IO 次数，就出现了 Block Nested-Loop Join 的方式。</p>
<p>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了 join buffer 缓冲区，将驱动表 join 相关的部分数据列 (大小受 join buffer 的限制) 缓存到 join buffer 中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和 join buffer 中的所有驱动表记录进行匹配 (内存中操作)，将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</p>
<blockquote>
<p>注意：</p>
<p>这里缓存的不只是关联表的列，select 后面的列也会缓存起来。</p>
<p>在一个有 N 个 join 关联的 SQL 中会分配 N - 1 个 join buffer。所以查询的时候尽量减少不必要的字段，可以让 join buffer 中可以存放更多的列。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E5%9D%97%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5.png" alt="块嵌套循环连接"></p>
<table>
<thead>
<tr>
<th>开销统计</th>
<th>SNLJ</th>
<th>INLJ</th>
<th>BNLJ</th>
</tr>
</thead>
<tbody><tr>
<td>外表扫描次数</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>内表扫描次数</td>
<td>A</td>
<td>0</td>
<td>A * used_column_size &#x2F; join_buffer_size + 1</td>
</tr>
<tr>
<td>读取记录数</td>
<td>A + B * A</td>
<td>A + B(match)</td>
<td>A + B * (A * used_column_size &#x2F; join_buffer_size)</td>
</tr>
<tr>
<td>JOIN 比较次数</td>
<td>B * A</td>
<td>A * Index(Height)</td>
<td>B * A</td>
</tr>
<tr>
<td>回表读取记录次数</td>
<td>0</td>
<td>B(match)(if possible)</td>
<td>0</td>
</tr>
</tbody></table>
<p>参数设置：</p>
<ul>
<li><p>block_nested_loop</p>
<p>  通过 <code>show variables like &#39;%optimizer_switch%&#39;</code> 查看 <code>block_nested_loop</code> 状态。默认是开启的。</p>
</li>
<li><p>join_buffer_size</p>
<p>  驱动表能不能一次加载完，要看 join buffer 能不能存储所有的数据，默认情况下 <code>join_buffer_size=256k</code>。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%join_buffer%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> join_buffer_size <span class="operator">|</span> <span class="number">262144</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+--------+</span></span><br></pre></td></tr></table></figure>

<p>  Join_buffer_size 的最大值在 32 位系统可以申请 4G，而在 64 位操作系统下可以申请大于 4G 的 Join Buffer 空间 (64 位 Windows 除外，其大值会被截断位 4GB 并发出警告)。</p>
</li>
</ul>
<p><strong>Join 小结</strong></p>
<ul>
<li><p>整体效率比较：INLJ &gt; BNLJ &gt; SNLJ </p>
</li>
<li><p>永远用小结果集驱动大结果集 (其本质就是减少外层循环的数据数量) (小的度量单位指的是表行数 * 每行大小)</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.b, t2.<span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.b <span class="operator">=</span> t2.b) <span class="keyword">where</span> t2.id <span class="operator">&lt;=</span> <span class="number">100</span>;  # 推荐</span><br><span class="line"><span class="keyword">select</span> t1.b, t2.<span class="operator">*</span> <span class="keyword">from</span> t2 straight_join t1 <span class="keyword">on</span> (t1.b <span class="operator">=</span> t2.b) <span class="keyword">where</span> t2.id <span class="operator">&lt;=</span> <span class="number">100</span>;  # 不推荐</span><br></pre></td></tr></table></figure>
</li>
<li><p>为被驱动表匹配的条件增加索引 (减少内层表的循环匹配次数)</p>
</li>
<li><p>增大 join buffer size 的大小 (一次缓存的数据越多，那么内层包的扫表次数就越少)</p>
</li>
<li><p>减少驱动表不必要的字段查询 (字段越少，join buffer 所缓存的数据就越多)</p>
</li>
</ul>
<p><strong>Hash Join</strong></p>
<p>从 MySQL 的 8.0.20 版本开始将废弃 BNLJ，因为从 MySQL 8.0.18 版本开始就加入了 hash join 默认都会使用 hash join</p>
<ul>
<li><p>Nested Loop：</p>
<p>  对于被连接的数据子集较小的情况，Nested Loop 是个较好的选择。</p>
</li>
<li><p>Hash Join 是做大数据集连接时常用方式，优化器使用两个表中较小 (相对较小) 的表利用 Join Key 在内存中建立散列表，然后扫描较大的表并探测散列表，找出与 Hash 表匹配的行。</p>
<ul>
<li>这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。</li>
<li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高 I&#x2F;O 的性能。</li>
<li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是 Join 的重型升降机。Hash Join 只能应用于等值连接 (如 WHERE a .col1 &#x3D; b.col2)，这是由 Hash 的特点决定的。</li>
</ul>
<table>
<thead>
<tr>
<th>类别</th>
<th>Nested Loop</th>
<th>Hash Join</th>
</tr>
</thead>
<tbody><tr>
<td>使用条件</td>
<td>任何条件</td>
<td>等值连接 (&#x3D;)</td>
</tr>
<tr>
<td>相关资源</td>
<td>CPU、磁盘 I&#x2F;O</td>
<td>内存、临时空间</td>
</tr>
<tr>
<td>特点</td>
<td>当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果。</td>
<td>当缺乏索引或者索引条件模糊时，Hash Join 比 Nested Loop 有效。在数据仓库环境下，如果表的记录数多，效率高</td>
</tr>
<tr>
<td>缺点</td>
<td>当索引失去或者查询条件限制不够时，效率很低；当表的记录数多时，效率低。</td>
<td>为建立哈希表，需要大量内存。第一次的结果返回较慢。</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><ul>
<li>保证被驱动表的 JOIN 字段已经创建了索引</li>
<li>需要 JOIN 的字段，数据类型保持绝对一致</li>
<li>LEFT JOIN 时，选择小表作为驱动表，大表作为被驱动表。减少外层循环的次数。</li>
<li>INNER JOIN 时，MySQL 会自动将小结果集的表选为驱动表。选择相信 MySQL 优化策略。</li>
<li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</li>
<li>不建议使用子查询，建议将子查询 SQL 拆开结合程序多次查询或使用 JOIN 来代替子查询。</li>
<li>衍生表建不了索引</li>
</ul>
<h3 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h3><p>MySQL 从 4.1 版本开始支持子查询，使用子查询可以进行 SELECT 语句的嵌套查询，记一个 SELECT 查询的结果作为另一个 SELECT 语句的条件。子查询可以一次性完成很多逻辑上需要多个步骤才能完成的 SQL 操作。</p>
<p>子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子查询的执行效率不高。原因：</p>
<ul>
<li>执行子查询时，MySQL 需要为内层查询语句的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</li>
<li>子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引，索引查询性能会受到一定的影响。</li>
<li>对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</li>
</ul>
<p>在 MySQL 中，可以使用连接 (JOIN) 查询来替代子查询。连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引的话，性能就会更好。</p>
<blockquote>
<p>尽量不要使用 NOT IN 或者 NOT EXISTS，用 LEFT JOIN xxx ON xx WHERE xx IS NULL 替代。</p>
</blockquote>
<h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><p><strong>问题</strong>：在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？</p>
<p>在 MySQL 中，支持两种排序方式，分别是 FileSort 和 Index 排序。</p>
<ul>
<li>Index 排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高。</li>
<li>FileSort 排序规则一般在内存中进行排序，占用 CPU 较多。如果待排结果较大，会产生临时文件 I&#x2F;O 到磁盘进行排序的情况，效率较低。</li>
</ul>
<p><strong>优化建议</strong>：</p>
<ul>
<li>SQL 中。可以在 WHERE 字句和 ORDER BY 字句中使用索引，目的是在 WHERE 字句中避免全表扫描，在 ORDER BY 字句避免使用 FileSort 排序。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</li>
<li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。</li>
<li>无法使用 Index 时，需要对 FileSort 方式进行调优。</li>
</ul>
<p><strong>测试</strong></p>
<p>先删除 student 和 class 表创建的索引。<code>CALL proc_drop_index(&#39;mysql_test&#39;, &#39;student&#39;)</code>、<code>CALL proc_drop_index(&#39;mysql_test&#39;, &#39;class&#39;)</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 创建索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classId_name <span class="keyword">ON</span> student (age, classId, name);</span><br><span class="line"># <span class="keyword">ORDER</span> <span class="keyword">BY</span> 时不 LIMIT，索引失效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age, classId;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age, classId LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">ORDER</span> <span class="keyword">BY</span> 时顺序错误，索引失效</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classId_stuno <span class="keyword">ON</span> student (age, classId, stuno);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> classId LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> classId, `NAME` LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age, classId, stuno LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age, classId LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">ORDER</span> <span class="keyword">BY</span> 时规则不一致，索引失效 (顺序错，不索引；方向反，不索引)</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>, classId <span class="keyword">ASC</span> LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> classId <span class="keyword">DESC</span>, `NAME` <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span>, classId <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>, classId <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># 无过滤，不索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> classId;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> classId, `NAME`;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> classId <span class="operator">=</span> <span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> classId <span class="operator">=</span> <span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">INDEX a_b_c(a, b, c)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 能使用索引最左前缀</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a, b</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a, b, c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">DESC</span>, B <span class="keyword">DESC</span>, c <span class="keyword">DESC</span></span><br><span class="line"></span><br><span class="line">如果 <span class="keyword">WHERE</span> 使用索引的最左前缀定义为常量，则 <span class="keyword">order</span> <span class="keyword">by</span> 能使用索引</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">AND</span> b<span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">AND</span> b <span class="operator">&gt;</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c</span><br><span class="line"></span><br><span class="line">不能使用索引进行排序</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">ASC</span>, b <span class="keyword">DESC</span>, c <span class="keyword">DESC</span>	# 排序不一致</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> g <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c		# 丢失 a 索引</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> c 		# 丢失 b 索引</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> a, d		# d 不是索引的一部分</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="keyword">IN</span> (...) <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c		# 对于排序来说，多个相等条件也是范围查询</span><br></pre></td></tr></table></figure>

<p><strong>实战</strong></p>
<p>清空索引。查询年龄为 30 岁的，且学生编号小雨 101000 的学生，按用户名称排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span> <span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `NAME`; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>     <span class="number">3.33</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+</span></span><br></pre></td></tr></table></figure>

<p>结果是 type 为 ALL，Extra 还出现了 Using FIleSort，都是最坏的情况。所以必须优化。</p>
<p><strong>方案一：为了去掉 filesort 可以把所有建成</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_name <span class="keyword">ON</span> student(age, NAME);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span> <span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `NAME`; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+--------------+---------+-------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+--------------+---------+-------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_age_name  <span class="operator">|</span> idx_age_name <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> const <span class="operator">|</span> <span class="number">18544</span> <span class="operator">|</span>    <span class="number">33.33</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+--------------+---------+-------+-------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<p><strong>方案二：尽量让 WHERE 的过滤条件和排序使用上索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 建立一个三个字段的组合索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_stuno_name <span class="keyword">ON</span> student (age, stuno, NAME);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span> <span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `NAME`; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------------------------+--------------------+---------+------+------+----------+---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys                   <span class="operator">|</span> key                <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------------------------+--------------------+---------+------+------+----------+---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_age_name,idx_age_stuno_name <span class="operator">|</span> idx_age_stuno_name <span class="operator">|</span> <span class="number">9</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span>; <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------------------------+--------------------+---------+------+------+----------+---------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>现在发现 Using FileSort 依然存在，索引 name 并没有使用到索引，而且 type 还是 range，光看字面其实并不美好。原因是，因为 stuno 是一个范围过滤，所以索引后面的字段不会再使用索引了。</p>
<p>结果竟然有 filesort 的 SQL 运行速度，超过了已经优化掉 filesort 的 SQL，而且快了很多，几乎一瞬间就出现了结果。</p>
<p>原因：所有的排序都是在条件过滤之后才执行的。所以，如果条件过滤掉大部分数据的话，剩下几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序，但实际提升性能很有限。相对 stuno &lt; 101000 这个条件，如果没有用到索引的话，要对几万条的数据进行扫描，这时非常消耗性能的，索引放在这个字段上性价比最高，是最优选择。</p>
<blockquote>
<p>结论：</p>
<ul>
<li>两个索引同时存在，MySQL 自动选择最优方案。 (对于这个例子，MySQL 选择 idx_age_stuno_name)。但是，随着数据量的变化 ，选择的索引也会随之变化的。</li>
<li>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</li>
</ul>
</blockquote>
<p><strong>FileSort 算法</strong></p>
<p>排序的字段如果不在索引列上，则 FileSort 会有两种算法：双路排序和单路排序</p>
<ul>
<li><p>双路排序 (慢)</p>
<p>  MySQL 4.1 之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据，读取行指针和 order by 列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。从磁盘去排序字段，在 buffer 进行排序，再从磁盘去其他字段。取一批数据，要对磁盘进行两次扫描，总所周知，IO 是很耗时的，索引在 MySQL 4.1 之后，出现了第二种改进的算法，就是单路排序。</p>
</li>
<li><p>单路排序 (快)</p>
<p>  从磁盘读取查询需要的所有列，按照order by 列在 buffer 对他们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。</p>
</li>
</ul>
<p><strong>结果及引申出的问题</strong></p>
<ul>
<li>由于单路是后出，总体而言好过双路</li>
<li>但是用单路有问题<ul>
<li>在 sort_buffer 中，单路比多路要多占用很多空间，因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了 sort_buffer 的容量，导致每次只能取 sort_buffer 容量大小的数据，进行排序 (创建 tmp 文件，多路合并)，排完再取 sort_buffer 容量大小，再排……从而多次 I&#x2F;O。</li>
<li>单路本来想省一次 I&#x2F;O 操作，反而 导致了大量的 I&#x2F;O 操作，反而得不偿失。</li>
</ul>
</li>
</ul>
<p><strong>优化策略</strong></p>
<ul>
<li><p>尝试提高 sort_buffer_size</p>
<p>  不管用哪种算法，提高这个参数都会提高效率，要根据系统的能力去提高，因为这个参数是针对每个进程 (connection) 的 1M-8M 之间调整。MySQL 5.7，InnoDB 存储引擎默认值是 1048576 字节，1MB。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%sort_buffer_size%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name           <span class="operator">|</span> <span class="keyword">Value</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> innodb_sort_buffer_size <span class="operator">|</span> <span class="number">1048576</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> myisam_sort_buffer_size <span class="operator">|</span> <span class="number">8388608</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sort_buffer_size        <span class="operator">|</span> <span class="number">262144</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+---------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>尝试提高 max_length_for_sort_data</p>
<p>  提高这个参数，会增加用改进算法的概率。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%max_length_for_sort_data%&#x27;</span>;		# 默认 <span class="number">1024</span> 字节</span><br></pre></td></tr></table></figure>

<p>  但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大，明显症状是高的磁盘 I&#x2F;O 活动和低的处理器使用率。如果需要返回的列的总长度大于 max_length_for_sort_data，使用双路算法，否则使用单路算法。1024-8192 字节之间调整。</p>
</li>
<li><p>ORDER BY 时 SELECT * 是一个大忌。最好只 QUERY 需要的字段。</p>
<p>  当 QUERY 的字段大小总和小于 max_length_for_sort_data，而且排序字段不是 TEXT｜BLOB 类型时，会用改进后的算法——单路排序，否则用老算法——多路排序。</p>
<p>  两种算法的数据都有可能超出 sort_buffer_size 的容量，超出之后，会创建 tmp 文件进行合并排序，导致多次 I&#x2F;O，但是用单路排序算法的风险风大一些，所以要提高 sort_buffer_size。</p>
</li>
</ul>
<h3 id="GROUP-BY-优化"><a href="#GROUP-BY-优化" class="headerlink" title="GROUP BY 优化"></a>GROUP BY 优化</h3><ul>
<li>group by 使用索引的原则几乎跟 order by 一致，group by 即使没有过滤条件使用到索引，也可以直接使用索引。</li>
<li>group by 先排序再分组，遵照索引建的最佳左前缀原则</li>
<li>当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置</li>
<li>where 效率高于 having，能写在 where 限定的条件就不要写在 having 中了</li>
<li>减少使用 order by，和业务沟通能不排序就不排序，或将排序当道程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费 CPU，数据库的 CPU 资源是极其宝贵的</li>
<li>包含了 ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在 1000 行以内，否则 SQL 会很慢</li>
</ul>
<h3 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h3><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000，10，此时需要 MySQL 排序前 2000010 记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LIMIT <span class="number">2000000</span>, <span class="number">10</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------+</span></span><br></pre></td></tr></table></figure>

<p><strong>优化思路一</strong></p>
<p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student t, (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">2000000</span>, <span class="number">10</span>) a <span class="keyword">WHERE</span> t.id <span class="operator">=</span> a.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+--------+---------------+---------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+--------+---------------+---------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> <span class="operator">&lt;</span>derived2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> t          <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> a.id <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> student    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+--------+---------------+---------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<p><strong>优化思路二</strong></p>
<p>该方案适用于主键自增的表，可以把 LIMIT 查询转换成某个位置的查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">2000000</span> LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>

<h3 id="优先考虑覆盖索引"><a href="#优先考虑覆盖索引" class="headerlink" title="优先考虑覆盖索引"></a>优先考虑覆盖索引</h3><h4 id="什么是覆盖索引"><a href="#什么是覆盖索引" class="headerlink" title="什么是覆盖索引"></a>什么是覆盖索引</h4><ul>
<li><p>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。<strong>一个索引包含了满足查询结果的数据就叫做覆盖索引</strong>。</p>
</li>
<li><p>非聚簇复合索引的一种方式，它包括在查询里的 SELECT、JOIN 和 WHERE 子句用到的所有列 (即建索引的字段正好是覆盖查询条件中所涉及的字段)。简单说就是，<code>索引列 + 主键</code> 包含 <code>SELECT 到 FROM 之间查询的列</code>。</p>
<p>举例：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 删除原有索引并创建新索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_name <span class="keyword">ON</span> student(age, `NAME`);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&lt;&gt;</span> <span class="number">20</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_age_name  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> age, `NAME` <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&lt;&gt;</span> <span class="number">20</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> idx_age_name  <span class="operator">|</span> idx_age_name <span class="operator">|</span> <span class="number">68</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> `NAME` <span class="keyword">LIKE</span> <span class="string">&#x27;%abc&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">11.11</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> id, age <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> `NAME` <span class="keyword">LIKE</span> <span class="string">&#x27;%abc&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_age_name <span class="operator">|</span> <span class="number">68</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">11.11</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+</span></span><br></pre></td></tr></table></figure>

<h4 id="覆盖索引的利弊"><a href="#覆盖索引的利弊" class="headerlink" title="覆盖索引的利弊"></a>覆盖索引的利弊</h4><p>好处：</p>
<ul>
<li><p>避免 InnoDB 表进行索引的二次查询 (回表)</p>
<p>  InnoDB 是以聚簇索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键值后，还需通过主键进行二次查询才能获取真实所需要的数据。在覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询，减少了 IO 操作，提升了查询效率。</p>
</li>
<li><p>可以把随机 IO 变成顺序 IO 加快查询效率</p>
<p>  由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少得多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</p>
</li>
</ul>
<p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段</strong>。</p>
<p>弊端：</p>
<ul>
<li>索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务 DBA，或者成为业务数据架构师的工作。</li>
</ul>
<h3 id="如何给字符串添加索引"><a href="#如何给字符串添加索引" class="headerlink" title="如何给字符串添加索引"></a>如何给字符串添加索引</h3><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><h4 id="使用前后对比"><a href="#使用前后对比" class="headerlink" title="使用前后对比"></a>使用前后对比</h4><p>Index Condition Pushdown (ICP) 是 MySQL 5.6 中新特性，是一种在存储引擎层使用过滤数据的优化方式。</p>
<ul>
<li>如果没有 ICP，存储引擎会遍历索引以定位基表中的行，并将它们返回给 MySQL 服务器，由 MySQL 服务器评估 WHERE 后面的条件是否保留行。</li>
<li>启用 ICP 后，如果部分 WHERE 条件可以仅使用索引中的列进行筛选，则 MySQL 服务器会把这部分 WHERE 条件放到存储引擎筛选。然后，存储引擎通过使用索引条目来筛选数据，并且只有在满足这一条件时才从表中读取行。<ul>
<li>好处：ICP 可以减少存储引擎必须访问基表的次数和 MySQL 服务器必须访问存储引擎的次数。</li>
<li>但是，ICP 的加速效果取决于在存储引擎内通过 ICP 筛选掉的数据的比例。</li>
</ul>
</li>
</ul>
<h4 id="ICP-的开启-x2F-关闭"><a href="#ICP-的开启-x2F-关闭" class="headerlink" title="ICP 的开启&#x2F;关闭"></a>ICP 的开启&#x2F;关闭</h4><ul>
<li>默认情况下启用索引条件下推。可以通过设置系统变量 optimizer_switch 控制：<code>index_condition_pushdown</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 打开索引下推</span><br><span class="line"><span class="keyword">SET</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;index_condition_pushdown=on&#x27;</span>;</span><br><span class="line"># 关闭索引下推</span><br><span class="line"><span class="keyword">SET</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;index_condition_pushdown=off&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>当使用索引条件下推时，EXPLAIN 语句输出结果中 Extra 列内容显示为 <code>Using index condition</code>。</li>
</ul>
<h4 id="ICP-使用案例"><a href="#ICP-使用案例" class="headerlink" title="ICP 使用案例"></a>ICP 使用案例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> people (</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">	zipcode <span class="type">VARCHAR</span> ( <span class="number">20</span> ) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	firstname <span class="type">VARCHAR</span> ( <span class="number">20</span> ) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	lastname <span class="type">VARCHAR</span> ( <span class="number">20</span> ) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	address <span class="type">VARCHAR</span> ( <span class="number">50</span> ) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY ( id ),</span><br><span class="line">KEY zip_last_first ( zipcode, lastname, firstname ) </span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB AUTO_INCREMENT <span class="operator">=</span> <span class="number">5</span> <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb3 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_bin;</span><br><span class="line"></span><br><span class="line"># 插入数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> people <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;000001&#x27;</span>, <span class="string">&#x27;三&#x27;</span>, <span class="string">&#x27;赵&#x27;</span>, <span class="string">&#x27;北京市&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;000002&#x27;</span>, <span class="string">&#x27;四&#x27;</span>, <span class="string">&#x27;钱&#x27;</span>, <span class="string">&#x27;重庆市&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;000003&#x27;</span>, <span class="string">&#x27;五&#x27;</span>, <span class="string">&#x27;孙&#x27;</span>, <span class="string">&#x27;南京市&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;000004&#x27;</span>, <span class="string">&#x27;六&#x27;</span>, <span class="string">&#x27;李&#x27;</span>, <span class="string">&#x27;天津市&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 知道一个人邮编，但是不确定这个人的姓氏</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> people <span class="keyword">WHERE</span> zipcode <span class="operator">=</span> <span class="string">&#x27;000001&#x27;</span> <span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span> <span class="keyword">AND</span> address <span class="keyword">LIKE</span> <span class="string">&#x27;%北京市%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys  <span class="operator">|</span> key            <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> people <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> zip_last_first <span class="operator">|</span> zip_last_first <span class="operator">|</span> <span class="number">63</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">25.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span>; <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>执行查看 SQL 的查询计划，Extra 中显示了 Using index condition，这表示使用了索引下推。另外，Using where 表示条件中包含需要过滤的非索引列数据，即 <code>address LIKE &#39;%北京市%&#39;</code> 这个条件并不是索引列，需要在服务端过滤掉。如果不想出现 Using where，把 <code>address LIKE &#39;%北京市%&#39;</code> 去掉即可。</p>
<h4 id="开启和关闭-ICP-的性能对比"><a href="#开启和关闭-ICP-的性能对比" class="headerlink" title="开启和关闭 ICP 的性能对比"></a>开启和关闭 ICP 的性能对比</h4><p>创建存储过程，主要目的就是插入很多 000001 的数据，这样查询的时候为了在存储引擎层做过滤，减少 IO，也为了减少缓冲池 (缓存数据页，没有 IO) 的作用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_people(max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	REPEAT</span><br><span class="line">	<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">INSERT</span> <span class="keyword">INTO</span> people (zipcode, firstname, lastname, address) <span class="keyword">VALUES</span> (<span class="string">&#x27;000001&#x27;</span>, <span class="string">&#x27;六&#x27;</span>, <span class="string">&#x27;周&#x27;</span>, <span class="string">&#x27;天津市&#x27;</span>);</span><br><span class="line">	UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">	<span class="keyword">END</span> REPEAT;</span><br><span class="line">	<span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 调用存储过程</span><br><span class="line"><span class="keyword">CALL</span> insert_people(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line"># 打开 profiling</span><br><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># 执行 <span class="keyword">SQL</span> 语句，此时默认打开索引下推</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> people <span class="keyword">WHERE</span> zipcode <span class="operator">=</span> <span class="string">&#x27;000001&#x27;</span> <span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 再次执行 <span class="keyword">SQL</span> 语句，不使用索引下推</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ no_icp (people) */</span> <span class="operator">*</span> <span class="keyword">FROM</span> people <span class="keyword">WHERE</span> zipcode <span class="operator">=</span> <span class="string">&#x27;000001&#x27;</span> <span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 查看当前会话所产生的所有 profiles</span><br><span class="line"><span class="keyword">SHOW</span> profiles;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Query_ID <span class="operator">|</span> Duration   <span class="operator">|</span> Query                                                                                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span> <span class="number">0.17796400</span> <span class="operator">|</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> people <span class="keyword">WHERE</span> zipcode <span class="operator">=</span> <span class="string">&#x27;000001&#x27;</span> <span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span>                         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span> <span class="number">1.06563900</span> <span class="operator">|</span> <span class="keyword">SELECT</span> <span class="comment">/*+ no_icp (people) */</span> <span class="operator">*</span> <span class="keyword">FROM</span> people <span class="keyword">WHERE</span> zipcode <span class="operator">=</span> <span class="string">&#x27;000001&#x27;</span> <span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+------------------------------------------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> profile <span class="keyword">FOR</span> query <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Status                         <span class="operator">|</span> Duration <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> starting                       <span class="operator">|</span> <span class="number">0.000193</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Executing hook <span class="keyword">on</span> transaction  <span class="operator">|</span> <span class="number">0.000006</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> starting                       <span class="operator">|</span> <span class="number">0.000015</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> checking permissions           <span class="operator">|</span> <span class="number">0.000011</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Opening tables                 <span class="operator">|</span> <span class="number">0.000314</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> init                           <span class="operator">|</span> <span class="number">0.000011</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">System</span> lock                    <span class="operator">|</span> <span class="number">0.000019</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> optimizing                     <span class="operator">|</span> <span class="number">0.000024</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> statistics                     <span class="operator">|</span> <span class="number">0.000226</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> preparing                      <span class="operator">|</span> <span class="number">0.000046</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> executing                      <span class="operator">|</span> <span class="number">0.177033</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">end</span>                            <span class="operator">|</span> <span class="number">0.000014</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query <span class="keyword">end</span>                      <span class="operator">|</span> <span class="number">0.000003</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> waiting <span class="keyword">for</span> handler <span class="keyword">commit</span>     <span class="operator">|</span> <span class="number">0.000008</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> closing tables                 <span class="operator">|</span> <span class="number">0.000008</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> freeing items                  <span class="operator">|</span> <span class="number">0.000021</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cleaning up                    <span class="operator">|</span> <span class="number">0.000012</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> profile <span class="keyword">FOR</span> query <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Status                         <span class="operator">|</span> Duration <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> starting                       <span class="operator">|</span> <span class="number">0.001877</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Executing hook <span class="keyword">on</span> transaction  <span class="operator">|</span> <span class="number">0.000012</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> starting                       <span class="operator">|</span> <span class="number">0.000015</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> checking permissions           <span class="operator">|</span> <span class="number">0.000008</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Opening tables                 <span class="operator">|</span> <span class="number">0.000120</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> init                           <span class="operator">|</span> <span class="number">0.000007</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">System</span> lock                    <span class="operator">|</span> <span class="number">0.000015</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> optimizing                     <span class="operator">|</span> <span class="number">0.000030</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> statistics                     <span class="operator">|</span> <span class="number">0.000195</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> preparing                      <span class="operator">|</span> <span class="number">0.000041</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> executing                      <span class="operator">|</span> <span class="number">1.063250</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">end</span>                            <span class="operator">|</span> <span class="number">0.000015</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query <span class="keyword">end</span>                      <span class="operator">|</span> <span class="number">0.000004</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> waiting <span class="keyword">for</span> handler <span class="keyword">commit</span>     <span class="operator">|</span> <span class="number">0.000008</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> closing tables                 <span class="operator">|</span> <span class="number">0.000006</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> freeing items                  <span class="operator">|</span> <span class="number">0.000025</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cleaning up                    <span class="operator">|</span> <span class="number">0.000011</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br></pre></td></tr></table></figure>

<p>多次测试效率对比来看，使用 ICP 优化的查询效率会好一些。这里建议多存储一些数据效果更明显。</p>
<h4 id="ICP-的使用条件"><a href="#ICP-的使用条件" class="headerlink" title="ICP 的使用条件"></a>ICP 的使用条件</h4><ul>
<li>如果表访问的类型为 range、ref、eq_ref 和 ref_or_null 可以使用 ICP</li>
<li>ICP 可以用于 InnoDB 和 MyISAM 表，包括分区表 InnoDB 和 MyISAM 表</li>
<li>对于 InnoDB 表，ICP 仅用于二级索引。ICP 的目标是减少全行读取次数，从而减少 I&#x2F;O 操作。</li>
<li>当 SQL 使用覆盖索引时，不支持 ICP。因为这种情况下使用 ICP 不会减少 I&#x2F;O。</li>
<li>相关子查询的条件不能使用 ICP。</li>
</ul>
<h3 id="其他查询优化策略"><a href="#其他查询优化策略" class="headerlink" title="其他查询优化策略"></a>其他查询优化策略</h3><h4 id="EXISTS-和-IN-的区分"><a href="#EXISTS-和-IN-的区分" class="headerlink" title="EXISTS 和 IN 的区分"></a>EXISTS 和 IN 的区分</h4><p><strong>问题</strong>：</p>
<p>不太理解那种情况下应该使用 EXISTS，哪种情况下应该用 IN。选择的标准是看能否使用表的索引吗？</p>
<p><strong>回答</strong>：</p>
<p>索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为小表驱动大表。在这种方式下效率是最高的。</p>
<p>比如下面这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> cc <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> B);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> B <span class="keyword">WHERE</span> B.cc <span class="operator">=</span> A.cc);</span><br></pre></td></tr></table></figure>

<p>当 A 小于 B 时，用 EXISTS。因为 EXISTS 的实现，相当于外表循环，实现的逻辑类似于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> A</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> B</span><br><span class="line">		if j.cc <span class="operator">=</span><span class="operator">=</span> i.cc <span class="keyword">then</span> ...</span><br></pre></td></tr></table></figure>

<p>当 B 小于 A 时用 IN，因为实现的逻辑类似于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> B</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> A</span><br><span class="line">		if j.cc <span class="operator">=</span><span class="operator">=</span> i.cc <span class="keyword">then</span> ...</span><br></pre></td></tr></table></figure>

<p>哪个表小就用哪个表来驱动，A 表小就用 EXISTS，B 表小就用 IN。</p>
<h4 id="COUNT-与-COUNT-具体字段-效率"><a href="#COUNT-与-COUNT-具体字段-效率" class="headerlink" title="COUNT(*) 与 COUNT(具体字段) 效率"></a>COUNT(*) 与 COUNT(具体字段) 效率</h4><p><strong>问提</strong>：</p>
<p>在 MySQL 中统计数据表的行数，可以使用三种方式：<code>SELECT COUNT(*)</code>、<code>SELECT COUNT(1)</code> 和 <code>SELECT COUNT(具体字段)</code>，使用这三者之间的查询效率是怎样的？</p>
<p><strong>回答</strong>：</p>
<p>前提：如果要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才可以。</p>
<ul>
<li>COUNT(*) 和 COUNT(1) 都是对所有结果进行 COUNT，COUNT(*) 和 COUNT(1) 本质上并没有区别 (二者执行时间可能略有差别，不过还是可以把它两的执行效率看成是相等的)。如果有 WHERE 字句，则是对所有符合筛选条件的数据行进行统计；如果没有 WHERE 字句，则是对数据表的数据行数进行统计。</li>
<li>如果是 MyISAM 存储引擎，统计数据表的行数只需要 O(1) 的复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息存储了 row_count 值，而一致性则由表级锁来保证。如果是 InnoDB 存储引擎，因为 InnoDB 支持事物，采用行级锁和 MVCC 机制，所以无法像 MyISAM 一样，维护一个 row_count 变量，因此需要采用扫描全表，是 O(n) 的复杂度，进行循环 + 计数的方式来完成统计。</li>
<li>在 InnoDB 存储引擎中，如果采用 COUNT(具体字段) 来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引 (非聚簇索引)。对于 COUNT(*) 和 COUNT(1) 来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。如果有多个二级索引，会使用 key_len 小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</li>
</ul>
<h4 id="关于-SELECT"><a href="#关于-SELECT" class="headerlink" title="关于 SELECT(*)"></a>关于 SELECT(*)</h4><p>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用 SELECT &lt;字段列表&gt; 查询。原因：</p>
<ul>
<li>MySQL 在解析的过程中，会通过查询数据字典将 * 按序转换成所有列名，这会大大的耗费资源和时间。</li>
<li>无法使用覆盖索引。</li>
</ul>
<h4 id="LIMIT-1-对优化的影响"><a href="#LIMIT-1-对优化的影响" class="headerlink" title="LIMIT 1 对优化的影响"></a>LIMIT 1 对优化的影响</h4><p>针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上 LIMIT 1 的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p>
<p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上 LIMIT 1 了。</p>
<h4 id="多使用-COMMIT"><a href="#多使用-COMMIT" class="headerlink" title="多使用 COMMIT"></a>多使用 COMMIT</h4><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。</p>
<p>COMMIT 所释放的资源：</p>
<ul>
<li>回滚段上用于恢复数据的信息</li>
<li>被程序语句获得的锁</li>
<li>redo &#x2F; undo log buffer 中的空间</li>
<li>管理上述三种资源中的内部花费</li>
</ul>
<h3 id="淘宝数据库，主键如何设计的？"><a href="#淘宝数据库，主键如何设计的？" class="headerlink" title="淘宝数据库，主键如何设计的？"></a>淘宝数据库，主键如何设计的？</h3><p>数据库的主键如何设计，大多数人的回答都会是用 8 字节的 BIGINT 做主键，而不要用 INT。(错)</p>
<p>这样的回答，只站在了数据库着一层，而没有从业务的角度思考主键。主键就是自增 ID 吗？用自增做主键，架构设计上可能连及格都拿不到。</p>
<h4 id="自增-ID-的问题"><a href="#自增-ID-的问题" class="headerlink" title="自增 ID 的问题"></a>自增 ID 的问题</h4><p>自增 ID 做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增 ID 除了简单其他都是缺点，总体来看存在以下几方面的问题：</p>
<ul>
<li><p>可靠性不高</p>
<p>  存在自增 ID 回溯的问题，这个问题直到最新版本的 MySQL 8.0 才修复</p>
</li>
<li><p>安全性不高</p>
<p>  对外暴露的接口可以非常容易猜测对应的信息。比如：&#x2F;User&#x2F;1&#x2F; 这样的接口，可以非常容易猜测用户 ID 的值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。</p>
</li>
<li><p>性能差</p>
<p>  自增 ID 的性能较差，需要在数据库服务器端生成。</p>
</li>
<li><p>交互多</p>
<p>  业务还需要额外执行一次类似 last_insert_id() 的函数才能知道刚才插入的自增值，这需要多一次的网络交互。在海量并发的系统中，多一条 SQL，就多一次性能上的开销。</p>
</li>
<li><p>局部唯一性</p>
<p>  最重要的一点，自增 ID 是局部唯一，只在当前数据库实例中唯一，而不是全剧唯一，在任意服务期间都是唯一的。对于目前分布式系统来说，这简直就是噩梦。</p>
</li>
</ul>
<h4 id="业务字段做主键"><a href="#业务字段做主键" class="headerlink" title="业务字段做主键"></a>业务字段做主键</h4><p>为了能够唯一地标识一个会员的信息，需要为会员信息表设置一个主键。考虑业务字段做主键。</p>
<table>
<thead>
<tr>
<th>cardno</th>
<th>name</th>
<th>phone</th>
<th>pid</th>
<th>address</th>
<th>sex</th>
<th>birthday</th>
</tr>
</thead>
<tbody><tr>
<td>10000001</td>
<td>张三</td>
<td>13300000001</td>
<td>1101232000000007890</td>
<td>上海</td>
<td>女</td>
<td>2000-01-02</td>
</tr>
<tr>
<td>10000002</td>
<td>李四</td>
<td>13300000002</td>
<td>1101232000000007891</td>
<td>浙江</td>
<td>男</td>
<td>1999-02-03</td>
</tr>
</tbody></table>
<ul>
<li><p>选择卡号 (cardno)</p>
<p>  会员卡号看起来比较合适，因为会员卡号不能为空，而且有唯一性，可以用来标识一条会员记录。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo.membermaster(</span><br><span class="line">	cardno <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  name TEXT,</span><br><span class="line">  phone TEXT,</span><br><span class="line">  pid TEXT,</span><br><span class="line">  address TEXT,</span><br><span class="line">  sex TEXT,</span><br><span class="line">  birthday DATETIME</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>  不同的会员卡号对应不同的会员，字段 cardno 唯一地标识某一个会员。如果都是这样，会员卡号与会员一一对应，系统是可以正常运行的。</p>
<p>  但实际情况是，会员卡号可能存在重复使用的情况。比如，张三因为工作变动搬离了原来的地址，不再到商家的门店消费了 (退还了会员卡)，于是张三就不再是这个商家门店的会员了。但是，商家不想让这个会员卡空着，就把卡号 10000001 的会员卡发给了王五。</p>
<p>  从系统设计的角度看，这个变化只是修改了会员信息表中的卡号是 10000001 这个会员信息，并不会影响到数据一致性。也就是说，修改会员卡号是 10000001 的会员信息，系统的各个模块，都会获取到修改后的会员信息，不会出现有的模块获取到修改之前的会员信息，有些模块获取到修改后的会员信息，而导致系统内部数据不一致的情况。因此，从信息系统层面上看是没问题的。</p>
<p>  但是从使用系统的业务层面来看，就有很大的问题了，会对商家造成影响。</p>
<p>  比如，有一个销售流水表 (trans)，记录了所有的销售流水明细。2020-12-01，张三在门店购买了一本书，消费了 89 元。那么，系统中就有了张三买书的流水记录，如下所示：</p>
<table>
<thead>
<tr>
<th>transactionno</th>
<th>itemnumber</th>
<th>quantity</th>
<th>price</th>
<th>salesvalue</th>
<th>cardno</th>
<th>transdate</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>89</td>
<td>89</td>
<td>10000001</td>
<td>2020-12-01</td>
</tr>
</tbody></table>
<p>  接着，查询一下2020-12-01 的会员消费记录：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.name, c.goodsname, a.quantity, a.salesvalue, a.transdate</span><br><span class="line"><span class="keyword">FROM</span> demo.trans <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">JOIN</span> demo.membermaster <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">JOIN</span> demo.goodsmaster <span class="keyword">AS</span> c</span><br><span class="line"><span class="keyword">ON</span> (a.cardno <span class="operator">=</span> b.cardno <span class="keyword">AND</span> a.itemnumber <span class="operator">=</span> c.itemnumber);</span><br></pre></td></tr></table></figure>

<p>  如果会员卡 10000001 又发给了王五，我们会更改会员信息表。到值查询时得到的结果是王五在 2020-12-01 买了一本书，消费 89 元。所以不能将会员卡好当做主键。</p>
</li>
<li><p>选择会员电话或身份证号</p>
<p>  会员电话可以做主键吗？不行的。在实际操作中，手机号也存在被运营商收回，重新发给别人用的情况。</p>
<p>  那身份证号行不行呢？好像可以，因为身份证绝不会重复，身份证号与一个人存在一一对应的关系。可问题是，身份证号属于个人隐私，顾客不一定愿意给你。要是强制要求会员必须登记身份证号，会把很多客人赶跑的。其实，客户电话也有这个问题，这也是我们在设计会员信息表的时候，允许身份证号和电话都为空的原因。</p>
<p>  <strong>所以，建议尽量不要用跟业务有关的字段做主键。毕竟，作为项目设计的技术人员，我们谁也无法预测在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现</strong>。</p>
<blockquote>
<p>经验：</p>
<p>刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高。</p>
</blockquote>
</li>
</ul>
<h4 id="淘宝的主键设计"><a href="#淘宝的主键设计" class="headerlink" title="淘宝的主键设计"></a>淘宝的主键设计</h4><p>打开自己淘宝订单，会发现每个订单号的特征。例如：1713216900604568394、1696231922773568394</p>
<p>可以发现，订单号不是自增 ID。订单号长度为 19 位，且订单号的最后 6 位都是一样的，都是568394。且订单号的前面 13 位部分是单调递增的。</p>
<p>大胆猜测，淘宝的订单 ID 设计应该是：<code>订单 ID = 时间 + 去重字段 + 用户ID后6位尾号</code>。这样的设计能做到全剧唯一，且对分布式系统查询及其友好。</p>
<h4 id="推荐的主键设计"><a href="#推荐的主键设计" class="headerlink" title="推荐的主键设计"></a>推荐的主键设计</h4><p>非核心业务：对应表的主键自增 ID，如告警、日志、监控等信息。</p>
<p>核心业务：<strong>主键设计至少应该是全局唯一且是单调递增</strong>。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能。</p>
<p>这里推荐最简单的一种主键设计：UUID</p>
<p><strong>UUID 的特点</strong>：</p>
<p>全局唯一，占用 36 字节，数据无序，插入性能差。</p>
<p><strong>认识 UUID</strong>：</p>
<ul>
<li>为什么 UUID 是全局唯一的？</li>
<li>为什么 UUID 占用 36 个字节？</li>
<li>为什么 UUID 是无序的？</li>
</ul>
<p>MySQL 数据库的 UUID 组成如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID <span class="operator">=</span> 时间 <span class="operator">+</span> UUID版本(<span class="number">16</span>字节) <span class="operator">-</span> 时钟序列(<span class="number">4</span>字节) <span class="operator">-</span> MAC地址(<span class="number">12</span>字节)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/mysqluuid.png" alt="mysql-uuid"></p>
<p><strong>为什么 UUID 是全局唯一的</strong>？</p>
<p>在 UUID 中的时间部分占用 60 位，存储的类似 TIMESTAMP 的时间戳，但表示的是从 1582-10-15 00:00:00.00 到现在的 100ns 的计数。可以看到 UUID 存储的时间精度比 TIMESTAMP 更高，时间维度发生重复的概率降低到 1&#x2F;100ns。</p>
<p>时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC 地址用于全局唯一。</p>
<p><strong>为什么 UUID 占用 36 字节</strong>？</p>
<p>UUID 根据字符串进行存储，设计时还带有无用的 “-” 字符串，因此总共需要 36 字节。</p>
<p><strong>为什么 UUID 是随机无序的呢</strong>？</p>
<p>因为 UUID 的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</p>
<p><strong>改造 UUID</strong></p>
<p>若将时间高低位互换，则时间就是单调递增的了，也就变的单调递增了。MySQL 8.0 可以更换时间低位和时间高位的存储方式，这样 UUID 就是有序的 UUID 了。</p>
<p>MySQL 8.0 还解决了 UUID 存在的空间占用的问题，除去了 UUID 字符串中无意义的 ”-“ 字符串，并且将字符串用二进制类型保存，这样存储空间降低为了 16 字节。</p>
<p>可以通过 MySQL 8.0 提供的 uuid_to_bin 函数实现上述功能，同样的，MySQL 也提供了 bin_to_uuid 函数进行转化：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@uuid</span> <span class="operator">=</span> UUID();</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@uuid</span>, uuid_to_bin(<span class="variable">@uuid</span>), uuid_to_bin(<span class="variable">@uuid</span>, <span class="literal">TRUE</span>);</span><br></pre></td></tr></table></figure>

<p><strong>通过函数 uuid_to_bin(@uuid, true) 将 UUID 转化为有序 UUID</strong>了。全局唯一 + 单调递增。</p>
<p><strong>有序 UUID 性能测试</strong></p>
<p>16 字节的有序 UUID，相比之前 8 字节的自增 ID，性能和存储空间对比究竟如何呢？</p>
<p>插入 1 亿条数据，每条数据占用 500 字节，含有 3 个二级索引，最终的结果如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E6%9C%89%E5%BA%8Fuuid%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.png" alt="有序uuid性能测试"></p>
<p>从上图可以看到插入 1 亿条数据有序 UUID 是最快的，而且在实际业务使用中有序 UUID 在业务端就可以生成。还可以进一步减少 SQL 交互次数。</p>
<p>另外，虽然有序 UUID 相比自增 ID 多了 8 个字节，但是鸡只增大了 3g 的存储空间，还可以接受。</p>
<blockquote>
<p>在当今的互联网环境中，非常不推荐自增 ID 作为主键的数据库设计。更推荐类似有序 UUID 的全局唯一的实现。</p>
<p>另外，在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。这样的主键设计就更为考验架构师的水平了。</p>
</blockquote>
<p><strong>如果不是 MySQL 8.0 怎么办</strong>？</p>
<p>手动赋值字段做主键！</p>
<p>比如，设计各个分店的会员表的主键，因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题。</p>
<p>可以在总部 MySQL 数据库中，有一个管理信息表，在这个表中添加一个字段，专门用来记录当前会员编号的最大值。</p>
<h2 id="数据库的设计规范"><a href="#数据库的设计规范" class="headerlink" title="数据库的设计规范"></a>数据库的设计规范</h2><h3 id="为什么需要数据库设计"><a href="#为什么需要数据库设计" class="headerlink" title="为什么需要数据库设计"></a>为什么需要数据库设计</h3><p>我们在设计数据表的时候，要考虑很多问题。比如：</p>
<ul>
<li>用户都需要什么数据？需要在数据表中保存哪些数据？</li>
<li>如何保证数据表中数据的正确性，当插入、删除、更新的时候该进行怎样的约束检查？</li>
<li>如何降低数据表的数据冗余度，保证数据表不会因为用户量的增长而迅速扩张？</li>
<li>如何让负责数据维护的人员更方便地使用数据库？</li>
<li>使用数据库的应用场景也各不相同，可以说针对不同的情况，设计出来的数据表可能千差万别。</li>
</ul>
<p>现实情况中，面临的场景：</p>
<p>当数据库运行了一段时间之后，我们才发现数据表设计得有问题。重新调整数据表的结构，就需要做数据迁移，还有可能影响程序的业务逻辑，以及网站的正常访问。</p>
<p>如果是糟糕的数据库设计可能会造成以下问题：</p>
<ul>
<li>数据冗余、信息重复，存储空间浪费</li>
<li>数据更新、插入、删除的一场</li>
<li>无法正确表示信息</li>
<li>丢失有效信息</li>
<li>程序性能差</li>
</ul>
<p>良好的数据库设计则有以下优点：</p>
<ul>
<li>节省数据的存储空间</li>
<li>能够保证数据的完整性</li>
<li>方便进行数据库应用系统的开发</li>
</ul>
<p>总之，开始设置数据库的时候，我们就需要重视数据表的设计。为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。</p>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><h4 id="范式简介"><a href="#范式简介" class="headerlink" title="范式简介"></a>范式简介</h4><p><strong>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式</strong>。可以理解为，一张数据表的设计结构需要满足的某种设计标准的级别。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p>
<p>范式的英文名称是 Mormal Form，简称 NF。它是英国人 E.F.Codd 在上个世纪 70 年代提出关系数据库模型后总结出来的。范式是关系数据库理论的基础，也是我们在设计数据库结构过程中所要遵循的规则和指导方法。</p>
<h4 id="范式都包括哪些"><a href="#范式都包括哪些" class="headerlink" title="范式都包括哪些"></a>范式都包括哪些</h4><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式 (1NF)、第二范式 (2NF)、第三范式 (3NF)、巴斯-科德范式 (BCNF)、第四范式 (4NF) 和第五范式 (5NF，又称完美范式)。</p>
<p>数据库的范式设计越高阶，冗余度就越低，同时高阶的范式一定符合低阶范式的要求，满足最低要求的范式是第一范式 (1NF)。在第一范式的基础上进一步满足更多规范要求的成为第二范式 (2NF)，其余范式以此类推。一般来说，在关系型数据库设计中，最高也就遵循到 BCNF，普遍还是 3NF。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是反规范化。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E8%8C%83%E5%BC%8F.png" alt="范式"></p>
<h4 id="键和相关属性的概念"><a href="#键和相关属性的概念" class="headerlink" title="键和相关属性的概念"></a>键和相关属性的概念</h4><p>范式的定义会使用到主键和候选键，数据库中的键  (Key) 由一个或者多个属性组成。数据表中常用的几种键和属性的定义：</p>
<ul>
<li>超键：能唯一标识元组的属性集叫做超键。</li>
<li>候选键：如果超键不包括多余的属性，那么这个超键就是候选键。</li>
<li>主键：用户可以从候选键中选择一个作为主键。</li>
<li>外键：如果数据表 R1 中的某属性集不是 R1 的主键，而是另一个数据表 R2 的主键，那么这个属性集就是数据表 R1 的外键。</li>
<li>主属性：包含在任一候选键中的属性称为主属性。</li>
<li>非主属性：与主属性相对，指的是不包含在任何一个候选键中的属性。</li>
</ul>
<p>通常，我们也将候选键称之为码，把主键也称为主码。因为键可能是由多个属性组成的，针对单个属性，我们还可以用主属性和非主属性来进行区分。</p>
<p>举例：</p>
<p>这里有两个表：</p>
<p>球员表 (player)：球员编号｜ 姓名｜身份证号｜年龄｜球队编号</p>
<p>球队表 (team)：球队编号｜主教练｜球队所在地</p>
<ul>
<li>超键：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如 (球员编号) (球员编号，姓名) (身份证号，年龄) 等。</li>
<li>候选键：就是最小的超键，对于球员表来说，候选键就是 (球员编号) 或者身份证号。</li>
<li>主键：我们自己选定，也就是从候选键中选择一个，比如 (球员编号)。</li>
<li>外键：球员表中的球队编号。</li>
<li>主属性、非主属性：在球员表中，主属性是 (球员编号) (身份证号)，其他的属性 (姓名) (年龄) (球队编号) 都是非主属性。</li>
</ul>
<h4 id="第一范式-1st-NF"><a href="#第一范式-1st-NF" class="headerlink" title="第一范式 (1st NF)"></a>第一范式 (1st NF)</h4><p>第一范式主要是确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值不可再次拆分的最小数据单元。</p>
<p>我们在设计某个字段的时候，对于字段 X 来说，不能把字段 X 拆分成字段 X-1 和字段 X-2。事实上，任何的 DBMS 都会满足第一范式的要求，不会将字段进行拆分。</p>
<h4 id="第二范式-2nd-NF"><a href="#第二范式-2nd-NF" class="headerlink" title="第二范式 (2nd NF)"></a>第二范式 (2nd NF)</h4><p>第二范式要求，在满足第一范式的基础上，还要<strong>满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分</strong>。如果指导主键的所有属性的值，就可以检索到任何元组 (行) 的任何属性的任何值。(要求中的主键，其实可以拓展替换为候选键)。</p>
<blockquote>
<p>小结：第二范式 (2NF) 要求实体的属性完全依赖主关键字。如果存在不完全依赖，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与元实体之间是一对多的关系。</p>
<p>1 NF 告诉我们字段属性需要是原子性的，而 2NF 告诉我们一张表就是一个独立的对象，一张表只表达一个意思。</p>
</blockquote>
<h4 id="第三范式-3rd-NF"><a href="#第三范式-3rd-NF" class="headerlink" title="第三范式 (3rd NF)"></a>第三范式 (3rd NF)</h4><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段和主键字段直接相关，也就是说，<strong>要求数据表中的所有非主键字段不能依赖于其他非主键字段</strong>。(即，不能存在非主属性 A 依赖于非主属性 B，非主属性 B 依赖于主键 C 的情况，即存在 A→B→C 的决定关系) 通俗地讲，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。</p>
<p>这里的主键可以拓展为候选键。</p>
<blockquote>
<p>符合 3NF 后的数据模型通俗地讲，2NF 和 3NF 通常以这句话概括：“每个非主键属性依赖于主键，依赖于整个主键，并且除了主键别无他物”。</p>
</blockquote>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>关于数据表的设计，有三个范式要遵循。</p>
<ul>
<li>第一范式，确保每列保持原子性。数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。</li>
<li>第二范式，确保每列都和主键完全依赖。尤其在复合主键的情况下，非主键部分不应该依赖于部分主键。</li>
<li>第三范式，确保每列都和主键列直接相关，而不是间接相关。</li>
</ul>
<p>范式的优点：数据的标准化有助于消除数据库中的数据冗余，第三范式通常被认为在性能、扩展性和数据完整性方面达到了最好的平衡。</p>
<p>范式的缺点：范式的使用，可能降低查询的效率。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要关联多张表，这不但代价昂贵，也可能使一些索引策略无效。</p>
<p>范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式的原则，通过增加少量的冗余或重复的数据来提高数据库的读性能，减少关联查询，join 表的次数，实现空间换取时间的目的。因此在实际的设计过程中要理论结合实际，灵活运用。</p>
<blockquote>
<p>范式本身没有优劣之分，只有适用场景不同。没有完美的设计，只有合适的设计，我们在数据表的设计中，还需要根据需求将范式和反范式混合使用。</p>
</blockquote>
<h3 id="反范式化"><a href="#反范式化" class="headerlink" title="反范式化"></a>反范式化</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>有的时候不能简单按照规范要求设计数据表，因为有的数据看似冗余，其实对业务来说十分重要。这个时候，我们就要遵循业务优先的原则，首先满足业务需求，再尽量尽量减少冗余。</p>
<p>如果数据库中的数据量比较大，系统的 UV 和 PV 访问频次比较高，则完全按照 MySQL 的三大范式设计数据表，读数据时会产生大量的关联查询，在一定程度上会影响数据库的读性能。如果我们想对查询效率进行优化，反范式优化也是一种优化思路。此时，可以通过在数据表中增加冗余字段来提高数据库的读性能。</p>
<p><strong>规范化 vs 性能</strong></p>
<blockquote>
<ul>
<li>为满足某种商业目标，数据库性能比规范化数据库更重要</li>
<li>在数据规范化的同时，要综合考虑数据库的性能</li>
<li>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</li>
<li>通过在给定的表中插入计算列，以方便查询</li>
</ul>
</blockquote>
<h4 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h4><p>例如客户表和评论表，如果要查询该条评论的评论人名称，就需要关联客户表去查询客户的名称。如果经常性的去查询评论人，我们就可以在评论表中，添加评论人名称字段，就不用每次进行关联查询了。</p>
<h4 id="反范式的新问题"><a href="#反范式的新问题" class="headerlink" title="反范式的新问题"></a>反范式的新问题</h4><p>反范式可以通过空间换时间，提升查询的效率，但是反范式也会带来一些新问题：</p>
<ul>
<li>存储空间变大了</li>
<li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则数据不一致</li>
<li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常消耗系统资源</li>
<li>在数据量小的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加复杂</li>
</ul>
<h4 id="反范式的适用场景"><a href="#反范式的适用场景" class="headerlink" title="反范式的适用场景"></a>反范式的适用场景</h4><p>当冗余信息有价值或者能大幅度提高查询效率的时候，我们才会采取反范式化的优化。</p>
<ul>
<li><p>增加冗余字段的建议‘</p>
<p>  增加冗余字段一定要符合如下两个条件。只有满足这两个条件，才可以考虑增加冗余字段。</p>
<ul>
<li>这个冗余字段不需要经常进行修改</li>
<li>这个冗余字段查询的时候不可或缺</li>
</ul>
</li>
<li><p>历史快照、历史数据的需要</p>
<p>  在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的订单收货信息都属于历史快照，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</p>
<p>  反范式优化也常用在数据仓库的设计中，因为数据仓库通常存储历史数据，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p>
<p>  简单总结下数据仓库和数据库在使用上的区别：</p>
<ul>
<li>数据库设计的目的在于捕获数据，而数据仓库设计的目的在于分析数据</li>
<li>数据库对数据的增删改实时性要求强，需要存储在线的用户数据，而数据仓库存储的一般是历史数据</li>
<li>数据库设计需要尽量避免冗余，单位了提高查询效率也允许一定的冗余度，而数据仓库在设计上更偏向采用反范式设计。</li>
</ul>
</li>
</ul>
<h3 id="BCNF-巴斯范式"><a href="#BCNF-巴斯范式" class="headerlink" title="BCNF (巴斯范式)"></a>BCNF (巴斯范式)</h3><p>人们在 3NF 的基础上进行了改进，提出了巴斯范式 (BCNF)，也叫做巴斯-科德范式 (Boyce-Codd Normal Form)。BCNF 被认为没有新的设计规范加入，只是对第三范式中设计规范要求更强，使得数据库冗余度更小。所以，称为是修正的第三范式，或扩充的第三范式，BCNF 不被称为第四范式。</p>
<p>若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到 BC 范式。一般来说，一个数据库设计符合 3NF 或 BCNF 就可以了。</p>
<h3 id="第四范式"><a href="#第四范式" class="headerlink" title="第四范式"></a>第四范式</h3><p>多值依赖的概念：</p>
<ul>
<li>多值依赖即属性之间的一对多关系，记为 K→→A。</li>
<li>函数依赖事实上是单值依赖，所以不能表达属性值之间的一对多关系。</li>
<li>平凡的多值依赖：全集 U &#x3D; K + A，一个 K 可以对应于多个 A，即 K→→A。此时整个表就是一组一对多关系。</li>
<li>非平凡的多值依赖：全集 U &#x3D; K + A + B，一个 K 可以对应于多个 A，也可以对应于多个 B，A 与 B 互相独立，即 K→→A，K→→B。整个表有多组一对多关系，且有：“一”部分是相同的属性集合，“多”部分是互相独立的属性集合。</li>
</ul>
<p>第四范式即在满足巴斯-科德范式 (BCNF) 的基础上，消除非平凡且非函数依赖的多值依赖 (即把同一表内的多对多关系删除)。</p>
<h3 id="第五范式"><a href="#第五范式" class="headerlink" title="第五范式"></a>第五范式</h3><p>除了第四范式外，还有更高级的第五范式 (又称完美范式) 和域键范式 (DKNF)。</p>
<p>在满足第四范式 (4NF) 的基础上，消除不是由候选键所蕴含的连接依赖。如果关系模式 R 中的每一个连接依赖均由 R 的候选键所隐含，则称此关系模式符合第五范式。</p>
<p>函数依赖是多值依赖的一种特殊的情况，而多值依赖实际上依赖的一种特殊情况。但连接依赖不像函数依赖和多值依赖可以由语义直接导出，而是在关系连接运算时才反映出来。存在连接依赖的关系模式仍可能遇到数据冗余及插入、修改、删除异常等问题。</p>
<p>第五范式处理的是无损连接问题，这个范式基本没有任何实际意义，因为无损连接很少出现，而且难以察觉。而域键范式试图定义一个终极范式，该范式考虑所有的依赖和约束类型，但是实际价值也是最小的，只存在理论研究中。</p>
<h3 id="ER-模型"><a href="#ER-模型" class="headerlink" title="ER 模型"></a>ER 模型</h3><p>数据库设计是牵一发而动全身的。那有没有什么办法提前看到数据库的全貌呢？比如需要哪些数据表、数据表中应该有哪些字段，数据表与数据表之间有什么关系、通过什么字段进行连接，等等。这样我们才能进行整体的梳理和设计。</p>
<p>其实，ER 模型就是一个这样的工具。ER 模型也叫作实体关系模型，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。<strong>在开发基于数据库的信息系统的设计阶段，通常使用 ER 模型来描述信息需求和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库</strong>。</p>
<h4 id="ER-模型包括哪些要素？"><a href="#ER-模型包括哪些要素？" class="headerlink" title="ER 模型包括哪些要素？"></a>ER 模型包括哪些要素？</h4><p><strong>ER 模型中有三个要素，分别是实体、属性和关系</strong>。</p>
<p><strong>实体</strong>，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用矩形来表示。实体分为两类，分别是强实体和弱实体。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。</p>
<p><strong>属性</strong>，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用 椭圆形来表示。</p>
<p><strong>关系</strong>，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模型中用菱形来表示。</p>
<p>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，<strong>可以独立存在的是实体，不可再分的是属性</strong>。也就是说，属性不能包含其他属性。</p>
<h4 id="关系的类型"><a href="#关系的类型" class="headerlink" title="关系的类型"></a>关系的类型</h4><p>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是一对一、一对多、多对多。</p>
<p>一对一：指实体之间的关系一一对应的，比如个人与身份证信息之间的关系就是一对一的关系。一个人只能有一个身份证信息，一个身份证信息也只属于一个人。</p>
<p>一对多：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体。比如说，我们新建一个班级表，而每个班级都有多个学生，每个学生则对应一个班级，班级对学生就是一对多的关系。</p>
<p>多对多：指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购商品。再比如一个选课表，有许多科目，每个科目有很多学生选，而每个学生又可以选择多个科目，这就是多对多的关系。</p>
<h4 id="建模分析"><a href="#建模分析" class="headerlink" title="建模分析"></a>建模分析</h4><p>ER 模型看起来比较麻烦，但是对我们把控项目整体非常重要。如果你只是开发一个小应用，或许简单设计几个表够用了，一旦要设计有一定规模的应用，在项目的初始阶段，建立完整的 ER 模型就非常关键了。开发应用项目的实质，其实就是建模。</p>
<p>我们设计的案例是电商业务，由于电商业务太过庞大且复杂，所以我们做了业务简化，比如针对 SKU (StockKeepingUnit，库存量单位) 和 SPU (Standard Product Unit，标准化产品单元) 的含义上，我们直接使用了 SKU，并没有提及 SPU 的概念。本次电商业务涉及总共有 8 个实体：</p>
<ul>
<li>地址实体</li>
<li>用户实体</li>
<li>购物车实体</li>
<li>评论实体</li>
<li>商品实体</li>
<li>商品分类实体</li>
<li>订单实体</li>
<li>订单详情实体</li>
</ul>
<p>其中，用户和商品分类是强实体，因为他们不需要依赖其他任何实体。而其他属于弱实体，因为他们虽然都可以独立存在，但是他们都依赖用户这个实体，因此都是弱实体。知道了这些要素，我们就可以给电商业务创建 ER 模型了，如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1ER%E6%A8%A1%E5%9E%8B-1.png" alt="电商业务ER模型-1"></p>
<p>在这个图中，地址和用户之间的添加关系，是一对多的关系，而商品和商品详情是一对一的关系，商品和订单是多对多的关系。这个 ER 模型，包括了 8 个实体之间的 8 种关系。</p>
<ul>
<li>用户可以在电商平台添加多个地址；</li>
<li>用户只能拥有一个购物车；</li>
<li>用户可以生成多个订单；</li>
<li>用户可以发表多条评论；</li>
<li>一件商品可以有多条评论；</li>
<li>每一个商品分类包含多种商品；</li>
<li>一个订单可以包含多个商品，一个商品可以在多个订单里。</li>
<li>订单中又包含多个订单详情，因为一个订单中可能包含不同种类的商品。</li>
</ul>
<h4 id="ER-模型的细化"><a href="#ER-模型的细化" class="headerlink" title="ER 模型的细化"></a>ER 模型的细化</h4><p>有了这个 ER 模型，我们就可以从整体上理解电商的业务了。刚刚的 ER 模型展示了电商业务的框架，但是只包括了订单，地址，用户，购物车，评论，商品，商品分类和订单详情这八个实体，以及它们之间的关系，还不能对应到具体的表，以及表于表之间的关联。我们需要把属性加上，用椭圆来表示，这样我们得到的 ER 模型就更加完整了。</p>
<p>因此，我们需要进一步去设计一下这个 ER 模型的各个局部，也就是细化下电商的业务流程，然后把它们综合到一起，形成一个完整的 ER 模型。这样可以帮助我们理清数据库的设计思路。</p>
<p>接下来分析一下各个实体都有哪些属性，如下所示。</p>
<ul>
<li><strong>地址实体</strong>包括用户编号、省、市、地区、收件人、联系电话、是否是默认地址。</li>
<li><strong>用户实体</strong>包括用户编号、用户名称、昵称、用户密码、手机号、邮箱、头像、用户级别。</li>
<li><strong>购物车实体</strong>包括购物车编号、用户编号、商品编号、商品数量、图片文件 URL。</li>
<li><strong>订单实体</strong>包括订单编号、收货人、收件人电话、总金额、用户编号、付款方式、送货地址、下单时间。</li>
<li><strong>订单详情实体</strong>包括订单详情编号、订单编号、商品名称、商品编号、商品数量。</li>
<li><strong>商品实体</strong>包括商品编号、价格、商品名称、分类编号、是否销售、规格、颜色。</li>
<li><strong>评论实体</strong>包括评论 ID、评论内容、评论时间、用户编号、商品编号。</li>
<li><strong>商品分类实体</strong>包括类别编号、类别名称、父类别编号。</li>
</ul>
<p>这样细分之后，我们就可以重新设计电商业务了，ER 模型如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1ER%E6%A8%A1%E5%9E%8B-2.png" alt="电商业务ER模型-2"></p>
<h4 id="ER-模型图转换成数据表"><a href="#ER-模型图转换成数据表" class="headerlink" title="ER 模型图转换成数据表"></a>ER 模型图转换成数据表</h4><p>通过绘制 ER 模型，我们已经理清了业务逻辑，现在，我们就要进行非常重要的一步了：把绘制好的 ER 模型，转换成具体的数据表，下面介绍下转换的原则：</p>
<ul>
<li>一个实体通常转换成一个数据表；</li>
<li>一个多对多的关系，通常也转换成一个数据表；</li>
<li>一个一对一或者一对多的关系，往往通过表的外键来表达，而不是设计一个新的数据表；</li>
<li>属性转换成表的字段。</li>
</ul>
<p>下面结合前面的 ER 模型，具体讲解一下怎么运用这些转换的原则，把 ER 模型转换成具体的数据表，从而把抽象出来的数据模型，落实到具体的数据库设计当中。</p>
<p><strong>一个实体转换成一个数据表</strong></p>
<p><strong>首先是强实体转换成数据表</strong>：用户实体转换成用户表 (user_info) 的代码如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_info` (</span><br><span class="line">	`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `user_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名称&#x27;</span>,</span><br><span class="line">  `nick_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户昵称&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户密码&#x27;</span>,</span><br><span class="line">  `phone_num` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  `head_imd` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;头像&#x27;</span>,</span><br><span class="line">  `user_level` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户级别&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>商品分类实体转换成商品分类表 (base_category)，由于商品分类可以有一级分类和二级分类，比如一级分类有家居、手机等等分类，二级分类可以根据手机的一级分类分为手机配件，运营商等，这里我们把商品分类实体规划为两张表，分别是一级分类表和二级分类表，之所以这么规划是因为一级分类和二级分类都是有限的，存储为两张表业务结构更加清晰。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 一级分类表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `base_category1` (</span><br><span class="line">	`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>，</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类名称&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;一级分类表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 二级分类表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `base_category2` (</span><br><span class="line">	`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;二级分类名称&#x27;</span>,</span><br><span class="line">  `category1_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;一级分类编号&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;二级分类表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>那么如果规划一张表，表结构如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `base_category` (</span><br><span class="line">	`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;二级分类名称&#x27;</span>,</span><br><span class="line">  `category1_parent_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;父分类编号&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;分类表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果这样分类的话，那么查询一级分类的时候，就需要判断父分类编号是否为空，但是如果插入二级分类的时候也是空，就容易造成业务数据混乱。而且查询二级分类的时候 <code>IS NOT NULL</code> 条件是无法使用到索引的。同时，这样的设计也不符合第二范式 (因为父分类编号并不依赖分类编号 ID，因为父分类编号可以有很多数据为 NULL)，所以就需要进行表的拆分。因此无论是业务需求还是数据库表的规范来看都应该拆分为两张表。</p>
<p><strong>再把弱实体转换成数据表</strong>：</p>
<p>地址实体转换成地址表 (user_address)，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_address` (</span><br><span class="line">	`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `province` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;省&#x27;</span>,</span><br><span class="line">  `city` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;市&#x27;</span>,</span><br><span class="line">  `user_address` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;具体地址&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">  `consignee` <span class="type">varchar</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;收件人&#x27;</span>,</span><br><span class="line">  `phone_num` <span class="type">varchar</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;联系方式&#x27;</span>,</span><br><span class="line">  `is_fefault` <span class="type">varchar</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;是否是默认&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;用户地址表；&#x27;</span></span><br></pre></td></tr></table></figure>

<p>订单实体转换成订单表 (order_info)，如下所示，实际业务中订单的信息会非常多，这里做了简化。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `order_info` (</span><br><span class="line">	`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `consignee` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;收货人&#x27;</span>,</span><br><span class="line">  `consignee_tel` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;收件人电话&#x27;</span>,</span><br><span class="line">  `total_amount` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;总金额&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `payment_way` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;付款方式&#x27;</span>,</span><br><span class="line">  `delivery_address` <span class="type">varchar</span>(<span class="number">1000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;送货地址&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;下单时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;订单表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>订单详情实体转换成订单详情表 (order_detail)，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 订单详情表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `order_detail` (</span><br><span class="line">	`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;订单详情编号&#x27;</span>,</span><br><span class="line">  `order_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单编号&#x27;</span>,</span><br><span class="line">  `sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku_id&#x27;</span>,</span><br><span class="line">  `sku_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku 名称&#x27;</span>,</span><br><span class="line">  `sku_num` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;购买个数&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;订单明细表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>购物车实体转换成购物车表 (cart_info)，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `cart_info` (</span><br><span class="line">	`cart_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku_id&#x27;</span>,</span><br><span class="line">  `sku_num` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;数量&#x27;</span>,</span><br><span class="line">  `img_url` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;图片文件&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;购物车表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>评论实体转换成评论表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sku_comments` (</span><br><span class="line">	`comment_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;评论编号&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户编号&#x27;</span>,</span><br><span class="line">  `sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku_id&#x27;</span>,</span><br><span class="line">  `comment` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;评论内容&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;评论时间&#x27;</span>,</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">45</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;商品评论表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>商品实体转换成商品表 (members)，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sku_info` (</span><br><span class="line">	`sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;商品编号itemID&#x27;</span>,</span><br><span class="line">  `price` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;价格&#x27;</span>,</span><br><span class="line">  `sku_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku 名称&#x27;</span>,</span><br><span class="line">  `sku_desc` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品规格描述&#x27;</span>,</span><br><span class="line">  `category3_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;三级分类id(冗余)&#x27;</span>,</span><br><span class="line">  `color` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;颜色&#x27;</span>,</span><br><span class="line">  `is_sale` tinyint(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;是否销售(1:是 0:否)&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">45</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;商品表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>一个多对多的关系转换成一个数据表</strong></p>
<p>这个 ER 模型中的多对多的关系有 一个，即商品和订单之间的关系，同品类的商品可以出现在不同的订单中，不同的订单也可以包含同一类型的商品，所以它们之间的关系是多对多。针对这种情况需要设计一个独立的表来表示，这种表一般称为中间表。</p>
<p>我们可以设计一个独立的订单详情表，来代替商品和订单之间的包含关系。这个表关联到两个实体，分别是订单、商品。所以，表中必须要包括这两个实体转换成的表的主键。除此之外，我们还要包括该关系自有的属性：商品数量，商品下单价格以及商品名称。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 订单详情表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `order_detail` (</span><br><span class="line">	`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;订单详情编号&#x27;</span>,</span><br><span class="line">  `order_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单编号&#x27;</span>,</span><br><span class="line">  `sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku_id&#x27;</span>,</span><br><span class="line">  `sku_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku名称&#x27;</span>,</span><br><span class="line">  `sku_num` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;购买个数&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;订单明细表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>通过外键来表达一对多的关系</strong></p>
<p>在上面的表的设计中，我们可以用外键来表达一对多的关系。比如在商品评论表 sku_comments 中，分别把 user_id、sku_id 定义成外键，以使用下面的语句设置外键。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONSTRAINT</span> fk_comment_user <span class="keyword">FOREIGN</span> KEY (user_id) <span class="keyword">REFERENCES</span> user_info (id),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_comment_sku <span class="keyword">FOREIGN</span> KEY (sku_id) <span class="keyword">REFERENCES</span> sku_info (sku_id)</span><br></pre></td></tr></table></figure>

<p>外键约束主要是在数据库层面上保证数据的一致性，但是因为插入和更新数据需要检查外键，理论上性能会有所下降，对性能是负面的影响。</p>
<p>实际的项目，不建议使用外键，一方面是降低开发的复杂度 (有外键的话主从表类的操作必须是先操作主表)，另外是有外键在处理数据的时候非常麻烦。在电商平台，由于并发业务量比较大，所以一般不设置外键，以免影响数据库性能。</p>
<p>在应用层面做数据的一致性检查，本来就是一个正常的功能需求。如学生选课的场景，课程肯定不是输入的，而是通过下来或者查找等方式从系统中进行选取，就能保证是合法的课程 ID，因此就不需要靠数据库的外键来检查了。</p>
<p><strong>把属性转换成表的字段</strong></p>
<p>在刚刚的设计中，我们也完成了把属性都转换成了表的字段，比如把商品属性转换成了商品信息表中的字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sku_info` (</span><br><span class="line">	`sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;商品编号itemID&#x27;</span>,</span><br><span class="line">  `price` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;价格&#x27;</span>,</span><br><span class="line">  `sku_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku 名称&#x27;</span>,</span><br><span class="line">  `sku_desc` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品规格描述&#x27;</span>,</span><br><span class="line">  `category3_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;三级分类id(冗余)&#x27;</span>,</span><br><span class="line">  `color` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;颜色&#x27;</span>,</span><br><span class="line">  `is_sale` tinyint(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;是否销售(1:是 0:否)&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">45</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;商品表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>到这里，我们通过创建电商项目业务流程的 ER 模型，再把 ER 模型转换成具体的数据表的过程，完成了利用 ER 模型设计电商项目数据库的工作。</p>
<p>其实，任何一个机遇数据库的应用项目，都可以通过这种先建立 ER 模型，再转换成数据表的方式，完成数据库的设计工作。创建 ER 模型不是目的，目的是把业务逻辑梳理清楚，设计出优秀的数据库。建议不是为了建模而建模，要利用创建 ER 模型的过程来整理思路，这样创建 ER 模型才有意义。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/er%E6%A8%A1%E5%9E%8B.png" alt="er模型"></p>
<h3 id="数据表的设计原则"><a href="#数据表的设计原则" class="headerlink" title="数据表的设计原则"></a>数据表的设计原则</h3><p>综合以上内容，总结出数据表设计的一般原则：三少一多</p>
<ul>
<li><p>数据表的个数越少越好</p>
<p>  RDBMS 的核心在于对实体和联系的定义，也就是 E-R 图 (Entity Relationship Diagram)，数据表越少，证明实体和联系设计得越简洁，既方便理解又方便操作。</p>
</li>
<li><p>数据表中的字段个数越少越好</p>
<p>  字段个数越多，数据冗余的可能性越大。设置字段个数的前提是各个字段相互独立，而不是某个字段的取值可以由其他字段计算出来。当然字段个数少是相对的，我们通常会在数据冗余和检索效率中进行平衡。</p>
</li>
<li><p>数据表中联合主键的字段个数越少越好</p>
<p>  设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式 (也就是用多个字段来定义一个主键)。联合主键中的字段越多，占用的索引空间越大，不仅会加大理解难度，还会增加运行时间和索引空间，因此联合主键的字段个数越少越好。</p>
</li>
<li><p>使用主键和外键越多越好</p>
<p>  数据库的设计实际上就是定义各种表，以及各种字段之间的关系。这些关系越多，证明这些实体之间的冗余度越低，利用度越高。这样做的好处在于不仅保证了数据表之间的独立性，还能提升相互之间的关联使用率。</p>
</li>
</ul>
<p>三少一多原则的核心就是简单可复用。简单指的是用更少的表、更少的字段、更少的联合主键字段来完成数据表的设计。可复用则是通过主键、外键的使用来增强数据表之间的复用率。因为一个主键可以理解是一张表的代表。键设计得越多，证明它们之间的利用率越高。</p>
<blockquote>
<p>注意：这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。</p>
</blockquote>
<h3 id="数据库对象编写建议"><a href="#数据库对象编写建议" class="headerlink" title="数据库对象编写建议"></a>数据库对象编写建议</h3><h4 id="关于库"><a href="#关于库" class="headerlink" title="关于库"></a>关于库</h4><ul>
<li><p>【强制】库的名称必须控制在 32 个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。</p>
</li>
<li><p>【强制】库名中英文一律小写，不同单词采用下划线分割。须见名知意。</p>
</li>
<li><p>【强制】库的名称格式：业务系统名称_子系统名。</p>
</li>
<li><p>【强制】库名禁止使用关键字，如 type，order 等。</p>
</li>
<li><p>【强制】创建数据库时必须显示指定字符集，并且字符集只能是 utf8 或者 utf8mb4.</p>
<p>  创建数据库 SQL 举例：<code>CREATE DATABASE crm_fund DEFAULT CHARACTER SET &#39;utf8&#39;;</code></p>
</li>
<li><p>【建议】对于程序连接数据库账号，遵循权限最小原则</p>
<p>  使用数据库账号只能在一个 DB 下使用，不准跨库。程序使用的账号原则上不准有 DROP 权限。</p>
</li>
<li><p>【建议】临时库以 tmp_ 为前缀，并以日期为后缀。备份库以 bak_ 为前缀，并以日期为后缀。</p>
</li>
</ul>
<h4 id="关于表、列"><a href="#关于表、列" class="headerlink" title="关于表、列"></a>关于表、列</h4><ul>
<li><p>【强制】表和列的名称必须控制在 32 个字符以内，表明只能使用英文字母、数字和下划线，建议以英文字母开头。</p>
</li>
<li><p>【强制】表明、列名一律小写，不同单词采用下划线分割。须见名知意。</p>
</li>
<li><p>【强制】表明要求有模块名强相关，同一模块的表明尽量使用统一前缀。比如：crm_fund_item</p>
</li>
<li><p>【强制】创建表时必须显式指定字符集为 utf8 或 utf8mb4。</p>
</li>
<li><p>【强制】表名、列名禁止使用关键字 (如 type、order 等)</p>
</li>
<li><p>【强制】创建表时必须显式指定表存储引擎类型。如无特殊需求，一律为 InnoDB。</p>
</li>
<li><p>【强制】建表必须有 comment。</p>
</li>
<li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或缩写。如：公司 ID，不要使用 corporation_id，而用 corp_id。</p>
</li>
<li><p>【强制】布尔值类型的字段命名为 is_描述。如 member 表上表示是否为 enabled 的会员的字段命名为 is_enabled。</p>
</li>
<li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据。</p>
<p>  通常文件很大，短时间内造成数据量快速增长，数据库进行数据读取时，通常会进行大量的随机 I&#x2F;O 操作，文件很大时，IO 操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</p>
</li>
<li><p>【建议】建表时关于主键：表必须有主键</p>
<ul>
<li>强制要求主键为 id，类型为 int 或 bigint，且为 AUTO_INCREMENT 建议使用 UNSIGNED 无符号型。</li>
<li>标识表里每一行主体的字段不要设为主键，建议设为其他字段如 user_id，order_id 等，并建立 unique key 索引。因为如果设为主键且主键值为随机插入，则会导致 innodb 内部页分裂和大量随机 I&#x2F;O，性能下降。</li>
</ul>
</li>
<li><p>【建议】核心表 (如用户表) 必须有行数据的创建时间字段 (create_time) 和最后更新时间字段 (update_time)，便于查问题。</p>
</li>
<li><p>【建议】表中所有字段尽量都是 NOT NULL 属性，业务可以根据需要定义 DEFAULT 值。</p>
<p>  因为使用 NULL 值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</p>
</li>
<li><p>【建议】所有存储相同数据的列名和列类型必须一致 (一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，到值查询效率降低)。</p>
</li>
<li><p>【建议】中间表 (或临时表) 用于保留中间结果集，名称以 tmp_ 开头。备份表用于备份或抓取原表快照，名称以 bak_ 开头。中间表和备份表定期清理。</p>
</li>
<li><p>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语句，方便数据库和数据表结构的导出和导入。</p>
</li>
</ul>
<h4 id="关于索引"><a href="#关于索引" class="headerlink" title="关于索引"></a>关于索引</h4><ul>
<li><p>【强制】InnoDB 表必须主键为 id int &#x2F; bigint auto_increment，且主键值禁止被更新。</p>
</li>
<li><p>【强制】InnoDB 和 MyISAM 存储引擎表，索引类型必须为 BTREE。</p>
</li>
<li><p>【建议】主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_ 开头，一律使用小写格式，以字段的名称或缩写作为后缀。</p>
</li>
<li><p>【建议】多单词组成的 columnname，取前几个单词首字母，加末单词组成 column_name。如：sample 表member_id 上的索引：idx_sample_mid。</p>
</li>
<li><p>【建议】单个表上的索引个数不能超过 6 个。</p>
</li>
<li><p>【建议】在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面。</p>
</li>
<li><p>【建议】在多表 JOIN 的 SQL 里，保证被驱动表的连接列上有索引，这样 JOIN 执行效率最高。</p>
</li>
<li><p>【建议】建表或加索引时，保证表里互相不存在冗余索引。</p>
<p>  比如：如果表里已经存在 key(a,b)，则 key(a) 为冗余索引，需要删除。</p>
</li>
</ul>
<h4 id="SQL-编写"><a href="#SQL-编写" class="headerlink" title="SQL 编写"></a>SQL 编写</h4><ul>
<li><p>【强制】程序端 SELECT 语句必须指定具体字段名称，禁止写成 *。</p>
</li>
<li><p>【建议】程序端 INSERT 语句制定具体字段名称，不要写成 INSERT INTO t1 VALUES(…)。</p>
</li>
<li><p>【建议】除静态表或小表 (100 行以内)，DML 语句必须有 WHERE 条件，且使用索引查找。</p>
</li>
<li><p>【建议】INSERT INTO … VALUES(xx),(xx),(xx).. 这里 xx 的值不要超过 5000 个。值过多虽然上线很快，但会引起主从同步延迟。</p>
</li>
<li><p>【建议】SELECT 语句不要使用 UNION，推荐使用 UNION ALL，并且 UNION 字句个数限制在 5 个以内。</p>
</li>
<li><p>【建议】线上环境，多表 JOIN 不要超过 5 个表。</p>
</li>
<li><p>【建议】减少使用 ORDER BY，和业务沟通能不排序就不排序，获奖排序放到程序段去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费 CPU，数据库的 CPU 资源是极其宝贵的。</p>
</li>
<li><p>【建议】包含了 ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在 1000 行以内，否则 SQL 会很慢。</p>
</li>
<li><p>【建议】对单表的多次 ALTER 操作必须合并为一次</p>
<p>  对于超过 100w 行的大表进行 alter table，必须经过 DBA 审核，并在业务低峰期执行，多个 alter 需整合在一起。因为 alter table 会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</p>
</li>
<li><p>【建议】批量操作数据时，需要控制事物处理间隔时间，进行必要的 sleep。</p>
</li>
<li><p>【建议】事物里包含 SQL 不超过 5 个。</p>
<p>  因为过长的事物会导致锁数据较久，MySQL 内部缓存、连接消耗过多等问题。</p>
</li>
<li><p>【建议】事物里更新语句尽量基于主键或 UNIQUE KEY，如 UPDATE … WHERE id &#x3D; xxx;</p>
<p>  否则会产生间隙锁，内部扩大锁定范围，到值系统性能下降，产生死锁。</p>
</li>
</ul>
<h2 id="数据库其它调优策略"><a href="#数据库其它调优策略" class="headerlink" title="数据库其它调优策略"></a>数据库其它调优策略</h2><h3 id="数据库调优的措施"><a href="#数据库调优的措施" class="headerlink" title="数据库调优的措施"></a>数据库调优的措施</h3><h4 id="调优的目标"><a href="#调优的目标" class="headerlink" title="调优的目标"></a>调优的目标</h4><ul>
<li>尽可能节省系统资源，以便系统可以提供更大负荷的服务。(吞吐量更大)</li>
<li>合理的结构设计和参数调整，以提高用户操作响应的速度。(响应速度更快)</li>
<li>减少系统的瓶颈，提高 MySQL 数据库整体的性能。</li>
</ul>
<h4 id="如何定位调优问题"><a href="#如何定位调优问题" class="headerlink" title="如何定位调优问题"></a>如何定位调优问题</h4><p>不过随着用户量的不断增加，以及应用程序复杂度的提升，我们很难用更快取定义数据库调优的目标，因为用户在不同时间段访问服务器遇到的瓶颈不同，比如双十一促销的时候会带来大规模的并发访问；还有用户在进行不同业务操作的时候，数据库的事物处理和 SQL 查询都会有所不同。因此我们还需要更加精细的定位，取确定调优的目标。一般情况下，有如下几种方式：</p>
<ul>
<li><p>用户的反馈 (主要)</p>
<p>  用户是我们服务对象，因此它们的反馈是最直接的。虽然它们不会直接提出技术建议，但是有些问题往往是用户第一时间发现的。我们要重视用户的反馈，找到和数据相关的问题。</p>
</li>
<li><p>日志分析 (主要)</p>
<p>  可以通过查看数据库日志和操作系统日志等方式找出异常情况，通过它们来定位遇到的问题。</p>
</li>
<li><p>服务器资源使用监控</p>
<p>  通过监控服务器的 CPU、内存、I&#x2F;O 等使用情况，可以实时了解服务器的性能使用，与历史情况进行对比。</p>
</li>
<li><p>数据库内部状况监控</p>
<p>  在数据库的监控中，活动会话 (Active Session) 监控是一个重要的指标。通过它，可以清楚地了解数据库当前是否处于非常繁忙的状态，是否存在 SQL 堆积等。</p>
</li>
<li><p>其它</p>
<p>  除了活动会话监控以外，我们也可以对事物、锁等待等进行监控，这些都可以帮助我们对数据库的运行状态有更全面的认识。</p>
</li>
</ul>
<h4 id="调优的维度和步骤"><a href="#调优的维度和步骤" class="headerlink" title="调优的维度和步骤"></a>调优的维度和步骤</h4><p>我们需要调优的对象是整个数据库管理系统，它不仅包括 SQL 查询，还包括数据库的部署配置、架构等。从这个角度来说，我们思考的维度就不仅仅局限在 SQL 优化上了。通过如下的步骤我们进行梳理：</p>
<p><strong>第一步：选择适合的 DBMS</strong></p>
<p>如果对事务性处理以及安全性要求高的话，可以选择商业的数据库产品。这些数据库在事物处理和查询性能上都比较强，比如采用 SQL Server、Oracle，那么单表存储上亿条数据是没有问题的。如果数据表设计得好，即使不采用分库分表的方式，查询效率也不差。</p>
<p>出此以外，也可以采用开源的 MySQL 进行存储，他有很多存储引擎可以选择，如果进行事物处理的话可以选择 InnoDB，非事物处理可以选择 MyISAM。</p>
<p>NoSQL 阵营包括键值型数据库、文档型数据库、搜索引擎、列式存储和图形数据库。这些数据库的优缺点和使用场景各有不同，比如列式存储数据库可以大幅度降低系统的 I&#x2F;O，适合于分布式文件系统，但如果数据需要频繁地增删改，那么列式存储就不太适用了。</p>
<p>DBMS 的选择关系到了后面的整个设计过程，所以第一步就是要选择合适的 DBMS。如果已经确定了 DBMS，那么这步可以跳过。</p>
<p><strong>第二步：优化表设计</strong></p>
<p>选择了 DBMS 之后，我们就需要进行表设计了。而数据表的设计方式也直接影响了后续的 SQL 查询语句。RDBMS 中，每个对象都可以定义为一张表，表于表之间的关系代表了对象之间的关系。如果用的是 MySQL，我们还可以根据不同的使用需求，选择不同的存储引擎。除此以外，还有一些优化的原则可以参考：</p>
<ul>
<li>表结构要尽量遵循三范式的原则。这样可以让数据结构更加清晰规范，减少冗余字段，同时也减少了在更新、插入和删除数据时等异常情况的发生。</li>
<li>如果查询应用比较多，尤其是需要进行多表联查的时候，可以采用反范式进行优化。反范式采用空间换时间的方式，通过增加冗余字段提高查询的效率。</li>
<li>表字段的数据类型选择，关系到了查询效率的高低以及存储空间的大小。一般来说，如果字段可以采用数值类型就不要采用字符类型；字符长度要尽可能设计得短一些。针对字符类型来说，当确定字符长度固定时，就可以采用 CHAR 类型；当长度不固定时，通常采用 VARCHAR 类型。</li>
</ul>
<p>数据表的结构设计很基础，也很关键。好的表结构可以在业务发展和用户量增加的情况下依然发挥作用，不好的表结构设计会让数据表变得非常臃肿，查询效率也会降低。</p>
<p><strong>第三步：优化逻辑查询</strong></p>
<p>当我们建立好数据表之后，就可以对数据表进行增删改查的操作了。这时我们首先需要考虑的是逻辑查询优化。SQL 查询优化，可以分为逻辑查询优化和物理查询优化。逻辑查询优化就是通过改变 SQL 语句的内容让 SQL 执行效率更高效，采用的方式是对 SQL 语句进行等价变换，对查询进行重写。</p>
<p><strong>SQL 的查询重写包括了子查询优化、等价谓词重写、视图重写、条件简化、连接消除和嵌套连接消除等</strong>。</p>
<p>比如用到 EXISTS 子查询和 IN 子查询的时候，会根据小表驱动大表的原则选择适合的子查询。在 WHERE 字句中会尽量避免对字段进行函数运算，它们会让字段的索引失效。</p>
<p>举例：查询评论内容开头为 abc 的内容都有哪些，如果在 WHERE 字句中使用了函数，语句就会写成下面这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> comment_id, comment_text, comment_time <span class="keyword">FROM</span> product_comment <span class="keyword">WHERE</span> <span class="built_in">SUBSTRING</span>(comment_text, <span class="number">1</span>, <span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>采用查询重写的方式进行等价替换：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> comment_id, comment_text, comment_time <span class="keyword">FROM</span> product_comment <span class="keyword">WHERE</span> comment_text <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>第四步：优化物理查询</strong></p>
<p>物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术 (比如索引等)，通过计算代价模型对各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。<strong>在这个部分中，我们需要掌握的重点是对索引的创建和使用</strong>。</p>
<p>但索引不是万能的，我们需要根据实际情况来创建索引。SQL 查询时需要对不同的数据表进行查询，因此在屋里查询优化阶段也需要确定这些查询所采用的路径，具体的情况包括：</p>
<ul>
<li>单表扫描：对于单表扫描来说，我们可以全表扫描所有的数据，也可以局部扫描。</li>
<li>两张表的连接：常用的连接方式包括了嵌套循环连接、HASH 连接和合并连接。</li>
<li>多张表的连接：多张数据表进行连接的时候，顺序很重要，因为不同的连接路径查询的效率不同，搜索空间也会不同。我们在进行多表连接的时候，搜索空间可能会达到很高的数据量级，巨大的搜索空间显然会占用更多的资源，因此我们需要通过调整连接顺序，将搜索空间调整在一个可接受的范围内。</li>
</ul>
<p><strong>第五步：使用 Redis 或 memcached 作为缓存</strong></p>
<p>除了可以对 SQL 本身进行优化以外，我们还可以请外援提升查询的效率。</p>
<p>因为数据都是存放到数据库中，我们需要从数据库层中取出数据放到内存中进行业务逻辑的操作，当用户量增大的时候，如果频繁地进行数据查询，会消耗数据库的很多资源。如果我们将常用的数据直接放到内存中，就会大幅提升查询的效率。</p>
<p>常用的键值存储数据库有 Redis 和 Memcached，它们都可以将数据存放到内存中。</p>
<p>从可靠性来说，Redis 支持持久化，可以让我们的数据保存在硬盘上，不过这样一来性能消耗也会比较大。而 Memcache 仅仅是内存存储，不支持持久化。</p>
<p>从支持的数据类型来说，Redis 比 Memcached 要多，它不仅支持 key-value 类型的数据，还支持 List、Set、Hash等数据结构。当我们有持久化需求或者是更高级的数据处理需求的时候，就可以使用 Redis。如果是简单的 key-value 存储，则可以使用 Memcached。</p>
<p><strong>通常我们对于查询响应要求高的场景 (响应时间短，吞吐量大)，可以考虑内存数据库，毕竟术业有专攻</strong>。传统的 RDBMS 都是将数据存储在硬盘上，而内存数据库则存放在内存中，查询起来要快得多。不过使用不同的工具，也增加了开发人员的使用成本。</p>
<p><strong>第六步：库级优化</strong></p>
<p>库级优化是站在数据库的维度上进行的优化策略，比如控制一个库中的数据表数量。另外，单一的数据库总会遇到各种限制，不如取长补短，利用外援的方式。通过主从架构优化我们的读写策略，通过对数据库进行垂直或者水平切分，突破单一数据库或数据表的访问限制，提升查询的性能。</p>
<p><strong>读写分离</strong></p>
<p>如果读和写的业务量都很大，并且它们都在同一个数据库服务器中进行操作，那么数据库的性能就会出现瓶颈，这时为了提升系统的性能，优化用户体验，我们可以采用读写分离的方式降低主数据库的负载，比如用主数据库 (master) 完成写操作，用从数据库 (slave) 完成读操作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E4%B8%80%E4%B8%BB%E4%B8%80%E4%BB%8E%E6%A8%A1%E5%BC%8F.png" alt="一主一从模式"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/myslq/%E5%8F%8C%E4%B8%BB%E5%8F%8C%E4%BB%8E%E6%A8%A1%E5%BC%8F.png" alt="双主双从模式"></p>
<p><strong>数据分片</strong></p>
<p>对数据库分库分表。当数据量级达到千万级以上时，有时候我们需要把一个数据库切分成多份，放到不同的数据库服务器上，减少对单一数据库服务器的访问压力。如果你使用的是 MySQL，就可以使用 MySQL 自带的分区表功能，当然你也可以考虑自己做垂直拆分 (分库)、水平拆分 (分表)、垂直+水平拆分 (分库分表)。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87-1.png" alt="数据分片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87-2.png" alt="数据分片"></p>
<blockquote>
<p>但需要注意的是，拆分在提升数据库性能的同时，也会增加维护和使用成本。</p>
</blockquote>
<h3 id="优化-MySQL-服务器"><a href="#优化-MySQL-服务器" class="headerlink" title="优化 MySQL 服务器"></a>优化 MySQL 服务器</h3><p>优化 MySQL 服务器主要从两个方面来优化，一方面是对硬件进行优化；另一方面是对 MySQL 服务的参数进行优化。这部分的内容需要较全面的知识，一般只有专业的数据库管理员才能进行这一类的优化。对于可以定制参数的操作系统，也可以针对 MySQL 进行操作系统优化。</p>
<h4 id="优化服务器硬件"><a href="#优化服务器硬件" class="headerlink" title="优化服务器硬件"></a>优化服务器硬件</h4><p><strong>服务器的硬件性能直接决定着 MySQL 数据库的性能</strong>。硬件的性能瓶颈直接决定 MySQL 数据库的运行速度和效率。针对性能瓶颈提高硬件配置，可以提高 MySQL 数据库查询、更新的速度。</p>
<ul>
<li>配置较大的内存。足够大的内存是提高 MySQL 数据库性能的方法之一。内存的速度比磁盘 I&#x2F;O 快得多，可以通过增加系统的缓冲区容量使数据在内存中停留的时间更长，以减少磁盘 I&#x2F;O。</li>
<li>配置高速磁盘系统，以减少读盘的等待时间，提高响应速度。磁盘的 I&#x2F;O 能力，也就是它的寻道能力，目前的 SCSI 高速旋转的是 7200 转&#x2F;分钟，这样的速度，一旦访问的用户量上去，磁盘的压力就会过大，如果是每天的网站 pv (page view) 在 150w，这样的一般配置就无法满足这样的需求了。现在 SSD 盛行，在 SSD 上随机访问和顺序访问性能几乎差不多，使用SSD 可以减少随机 I&#x2F;O 带来的性能损耗。</li>
<li>合理分布磁盘 I&#x2F;O，把磁盘 I&#x2F;O 分散在多个设备上，以减少资源竞争，提高并行操作能力。</li>
<li>配置多处理器，MySQL 是多线程的数据库，多处理器可同时执行多个线程。</li>
</ul>
<h4 id="优化-MySQL-的参数"><a href="#优化-MySQL-的参数" class="headerlink" title="优化 MySQL 的参数"></a>优化 MySQL 的参数</h4><p>通过优化 MySQL 的参数可以提高资源利用率，从而达到提高 MySQL 服务器性能的目的。</p>
<p>MySQL 服务的配置参数都在 my.cnf 或者 my.ini 文件的 [mysqld] 组中。配置完参数以后，需要重新启动 MySQL 服务器才会生效。下面对几个对性能影响比较大的参数进行详细介绍。</p>
<ul>
<li><p><code>innodb_buffer_pool_size</code>：这个参数是 My SQL 数据库最重要的参数之一，表示 InnoDB 类型的表和索引的最大缓存。它不仅仅缓存索引数据，还会缓存表的数据。这个值越大，查询的速度就会越快。但是这个值太大会影响操作系统的性能。</p>
</li>
<li><p><code>key_buffer_size</code>：表示索引缓冲区的大小。索引缓冲区是所有的线程共享。增加索引缓冲区可以得到更好处理的索引 (对所有读和多重写)。当然，这个值不是越大越好，它的大小取决于内存的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在 4GB 左右的服务器该参数可设置为 256M 或 384M。</p>
</li>
<li><p><code>table_cache</code>：表示同时打开的表的个数。这个值越大，能够同时打开的表的个数越多。物理内存越大，设置就越大。默认为2402，调到 512-1024 最佳。这个值不是越大越好，因为同时打开的表太多会影响操作系统的性能。</p>
</li>
<li><p><code>query_cache_size</code>：表示查询缓冲区的大小。可以通过 MySQL控制台观察，如果 Cache_lowmem_prunes 的值非常大，则表明经常出现缓冲不够的情况，就要增加 Query_cache_size 的值；如果 Qcache_hits 的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区碎片很多。MySQL 8.0 之后失效。该参数需要和 query_cache_type 配合使用。</p>
</li>
<li><p><code>query_cache_type</code> 的值是 0 时，所有的查询都不使用查询缓存区。但是 query_cache_type&#x3D;0 并不会导致 MySQL 释放 query_cache_size 所配置的缓存区内存。</p>
<ul>
<li>当 query_cache_type&#x3D;1 时，所有的查询都将使用查询缓存区，除非在查询语句中指定 SQL_NO_CACHE，如果 SELECT SQL_NO_CACHE * FROM tel_name。</li>
<li>当 query_cache_type&#x3D;2 时，只有在查询语句中使用 SQL_CACHE 关键字，查询才会使用查询缓存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的查询操作的情况。</li>
</ul>
</li>
<li><p><code>sort_buffer_size</code>：表示每个需要进行排序的线程分配的缓冲区的大小。增加这个参数的值可以提高 ORDER BY 或 GROUP BY 操作的速度。默认数值是 2097144字节 (约 2MB)。对于内存在 4GB 左右的服务器推荐设置为 6-8M，如果有 100个连接，那么实际分配的总共排序缓冲区大小为 100 * 6 &#x3D; 600MB。</p>
</li>
<li><p><code>join_buffer_size=8M</code>：表示联合查询操作所能使用的缓冲区大小，和 sort_buffer_size 一样，该参数对应的分配内存也是每个连接独享。</p>
</li>
<li><p><code>read_buffer_size</code>：表示每个线程连续扫描时为扫描的每个表分配的缓冲区的大小 (字节)。当线程从表中连续读取记录时需要用到这个缓冲区。 SET SESSION read_buffer_size&#x3D;n 可以临时设置该参数的值。默认为 64k，可以设置为 4M。</p>
</li>
<li><p><code>innodb_flush_log_at_trx_commit</code>：表示何时将缓冲区的数据写入日志文件，并且将日志文件写入磁盘中。该参数对于 InnoDB 引擎非常重要。该参数有 3 个值，分别为 0、1 和 2 该参数的默认值为 1。</p>
<ul>
<li>值为 0 时，表示每秒 1 次的频率将数据写入日志文件并将日志文件写入磁盘。每个事物的 COMMIT 并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld 进程的崩溃会导致上一秒钟所有事物数据的丢失。</li>
<li>值为 1 时，表示每次提交事物时将数据写入日志文件并将日志文件写入磁盘进行同步。该模式是最安全的，但也是最慢的一种方式。因为每次事物提交或事物外的指令都需要把日志写入 (flush) 磁盘。</li>
<li>值为 2 时，表示每次提交事物时将数据写入日志文件，每隔 1 秒将日志文件写入磁盘。该模式速度较快，也比 0 安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事物数据才可能丢失。</li>
</ul>
</li>
<li><p><code>innodb_log_buffer_size</code>：这是 InnoDB 存储引擎的 事物日志所使用的缓冲区。为了提高性能，也是先将信息写入 InnoDB Log Buffer 中，当满足 in no d b_flush_log_trx_commit 参数所设置的相应条件 (或者日志缓冲区写满) 之后，才会将日志写到文件 (或者同步到磁盘) 中。</p>
</li>
<li><p><code>max_connections</code>：表示允许连接到 MySQL 数据库的最大数量，默认值是 151。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这时可以考虑增大 max_connections 的值。在 Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数不是越大越好，因为这些连接会浪费内存的资源。过多的连接可能会导致 MySQL 服务器僵死。</p>
</li>
<li><p><code>back_log</code>：用于控制 MySQL 监听 TCP 端口时设置的积压请求栈大小。如果 MySQL 的连接数达到 max_connections 时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即 back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50，之后的版本默认为 50 + (max_connections &#x2F; 5)，对于 Linux 系统推荐设置为小于 512 的整数，但最大不超过 900。如果需要数据库在较短的时间内处理大量连接请求，可以考虑适当增大 back_log 的值。</p>
</li>
<li><p><code>thread_cache_size</code>：线程池缓存线程数量的大小，当客户端断开链接后将当前线程缓存起来，当在接到新的连接请求时快速响应无需创建新的线程。这尤其对那些使用短连接的应用程序来说可以极大的提高创建连接的效率。那么为了提高可以增大该参数的值。默认为 60，可以设置为 120。</p>
<p>  可以通过如下几个 MySQL 状态值来适当调整线程池的大小：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Thread%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>  当 Thread_cached 越来越少，但 Threads_connected 始终不降，且 Threads_created 持续升高，可适当增加 thread_cache_size 的大小。</p>
</li>
<li><p><code>wait_timeout</code>：指定一个请求的最大连接时间，对于 4GB 左右内存的服务器可以设置为 5-10。</p>
</li>
<li><p><code>interactive_timeout</code>：表示服务器在关闭连接前等待行动的秒数。</p>
</li>
</ul>
<p>这里给出一份 my.cnf 的参考配置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">port<span class="operator">=</span><span class="number">3306</span></span><br><span class="line">serverid<span class="operator">=</span><span class="number">1</span></span><br><span class="line">socket<span class="operator">=</span><span class="operator">/</span>tmp<span class="operator">/</span>mysql.sock</span><br><span class="line"><span class="keyword">skip</span><span class="operator">-</span>locking</span><br><span class="line"># 避免 MySQL 的外部锁定，减少出错几率增强稳定性。</span><br><span class="line"><span class="keyword">skip</span><span class="operator">-</span>name<span class="operator">-</span>resolve</span><br><span class="line"># 禁止 MySQL 对外部连接进行 DNS 解析，使用这一选项可以消除 MySQL 进行 DNS 解析的时间。但需要注意，如果开启该选项，则所有远程主机授权都要使用 IP 地址方式，否则 MySQL 将无法正常处理连接请求！</span><br><span class="line">back_log<span class="operator">=</span><span class="number">384</span></span><br><span class="line">key_buffer_size<span class="operator">=</span><span class="number">256</span>M</span><br><span class="line">max_allowed_packet<span class="operator">=</span><span class="number">4</span>M</span><br><span class="line">thread_stack<span class="operator">=</span><span class="number">256</span>k</span><br><span class="line">table_cache<span class="operator">=</span><span class="number">128</span>k</span><br><span class="line">sort_buffer_size<span class="operator">=</span><span class="number">6</span>M</span><br><span class="line">read_buffer_size<span class="operator">=</span><span class="number">4</span>M</span><br><span class="line">read_rnd_buffer_size<span class="operator">=</span><span class="number">16</span>M</span><br><span class="line">join_buffer_size<span class="operator">=</span><span class="number">8</span>M</span><br><span class="line">myisam_sort_buffer_size<span class="operator">=</span><span class="number">64</span>M</span><br><span class="line">table_cache<span class="operator">=</span><span class="number">512</span></span><br><span class="line">thread_cache_size<span class="operator">=</span><span class="number">64</span></span><br><span class="line">query_cache_size<span class="operator">=</span><span class="number">64</span>M</span><br><span class="line">tmp_table_size<span class="operator">=</span><span class="number">256</span>M</span><br><span class="line">max_connections<span class="operator">=</span><span class="number">768</span></span><br><span class="line">max_connect_errors<span class="operator">=</span><span class="number">10000000</span></span><br><span class="line">wait_timeout<span class="operator">=</span><span class="number">10</span></span><br><span class="line">thread_concurrency<span class="operator">=</span><span class="number">8</span></span><br><span class="line"># 该参数取值为服务器逻辑CPU数量<span class="operator">*</span><span class="number">2</span>，在本例中，服务器有两颗物理CPU，而每颗物理CPU又支持H.T超线程，所以实际取值为<span class="number">4</span><span class="operator">*</span><span class="number">2</span><span class="operator">=</span><span class="number">8</span></span><br><span class="line"><span class="keyword">skip</span><span class="operator">-</span>networking</span><br><span class="line"># 开启该选项可以彻底关闭 MYSQL 的 TCP<span class="operator">/</span>IP 连接方式，如果 WEB 服务器是以远程连接的方式访问 MYSQL 数据库服务器则不要开启该选项！否则将无法正常连接</span><br><span class="line">table_cache<span class="operator">=</span><span class="number">1024</span></span><br><span class="line">innodb_additional_mem_pool_size<span class="operator">=</span><span class="number">4</span>M</span><br><span class="line"># 默认为 <span class="number">2</span>M</span><br><span class="line">innodb_flush_log_at_trx_commit<span class="operator">=</span><span class="number">1</span></span><br><span class="line">innodb_log_buffer_size<span class="operator">=</span><span class="number">2</span>M</span><br><span class="line"># 默认为 <span class="number">1</span>M</span><br><span class="line">innodb_thread_concurrency<span class="operator">=</span><span class="number">8</span></span><br><span class="line"># 你的服务器 CPU 有几个就设置为几。建议用默认一般为 <span class="number">8</span></span><br><span class="line">tmp_table_size<span class="operator">=</span><span class="number">64</span>M</span><br><span class="line"># 默认为 <span class="number">16</span>M，调到 <span class="number">64</span>～<span class="number">256</span> 最佳</span><br><span class="line">thread_cache_size<span class="operator">=</span><span class="number">120</span></span><br><span class="line">query_cache_size<span class="operator">=</span><span class="number">32</span>M</span><br></pre></td></tr></table></figure>

<p>很多情况还需要具体情况具体分析！</p>
<p><strong>举例</strong>：</p>
<p>下面是一个电商平台，类似京东或天猫这样的平台。商家购买服务，入驻平台，开通之后，商家可以在系统中上架各种商品，客户通过手机 App、微信小程序等渠道购买商品，商家接到订单以后安排快递送货。</p>
<p>刚刚上线的时候，系统运行状态良好。但是，随着入住的商家不断增多，使用系统的用户量越来越多，每天的订单数据达到了 5 万条以上。这个时候，系统开始出现问题，CPU 使用率不断飙升。终于，双十一或者 618 活动高峰的时候，CPU 使用率达到 99%，这实际上就意味着，系统的计算资源已经耗尽，再也无法处理任何新的订单了。换句话说，系统已经崩溃了。</p>
<p>这个时候，我们想到了对系统参数进行调整，因为参数的值决定了资源配置的方式和投放的程度。</p>
<p>为了解决这个问题，一共调整了 3 个系统参数，分别是</p>
<ul>
<li>InnoDB_flush_log_at_trx_commit</li>
<li>InnoDB_buffer_pool_size</li>
<li>InnoDB_buffer_pool_instances</li>
</ul>
<p>下面我们就说一说调整这三个参数的原因是什么。</p>
<p><strong>调整系统参数 InnoDB_flush_log_at_trx_commit</strong></p>
<p>这个参数适用于 InnoDB 存储引擎，电商平台系统中的表用的存储引擎都是 InnoDB。默认的值是 1，意思是每次提交事物的时候，都把数据写入日志，并把日志写入磁盘。这样做的好处是数据安全性最佳，不足之处在于每次提交事物，都要进行磁盘写入的操作。在大并发的场景下，过于频繁的磁盘读写会导致 CPU 资源浪费，系统效率变低。</p>
<p>这个参数的值还有 2 个可能的选项，分别是 0 和 2。我们把这个参数的值改成了 2.这样就不用每次提交事物的时候都启动磁盘读写了，在大并发的场景下，可以改善系统效率，降低 CPU 使用率。即便出现故障，损失的数据也比较小。</p>
<p><strong>调整系统参数 InnoDB_buffer_pool_size</strong></p>
<p>这个参数的意思是，InnoDB 存储引擎使用缓存来存储索引和数据。这个值越大，可以加载到缓存区的索引和数据量就越多，需要的磁盘读写就越少。</p>
<p>因为我们的 MySQL 服务器是数据库专属服务器，只用来运行 MySQL 数据库服务，没有其他应用了，而我们的计算机是 64 位机器，内存也有 128G。于是我们把这个参数的值调整为 64G。这样一来，磁盘读写次数可以大幅降低，我们就可以充分利用内存，释放出一些 CPU 的资源。</p>
<p><strong>调整系统参数 InnoDB_buffer_pool_instances</strong></p>
<p>这个参数可以讲 InnoDB 的缓存区分成几个部分，这样可以提高系统的并行处理能力，因为可以允许多个进程同时处理不同部分的缓存区。</p>
<p>我们把 InnoDB_buffer_pool_instances 的值修改为 64，意思就是把 InnoDB 的缓存区分成 64 个分区，这样就可以同时有多个进程进行数据操作，CPU 的效率就高多了。修改好了系统参数的值，要重启 MySQL 数据库服务器。</p>
<blockquote>
<p>总结一下就是遇到 CPU 资源不足的问题，可以从下面两个思路去解决。</p>
<ul>
<li>疏通拥堵路段，消除瓶颈，让等待的时间更短；</li>
<li>开拓新的通道，增加并行处理能力。</li>
</ul>
</blockquote>
<h3 id="优化数据库结构"><a href="#优化数据库结构" class="headerlink" title="优化数据库结构"></a>优化数据库结构</h3><p>一个好的数据库设计方案对于数据库的性能常常会起到事半功倍的效果。合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p>
<h4 id="拆分表：冷热数据分离"><a href="#拆分表：冷热数据分离" class="headerlink" title="拆分表：冷热数据分离"></a>拆分表：冷热数据分离</h4><p>拆分表的思路是，把一个包含很多字段的表拆分成 2 个或者多个相对较小的表。这样做的原因是，这些表中某些字段的操作频率很高 (热数据)，经常要进行查询或者更新操作，而另外一些字段的使用频率却很低 (冷数据)，冷热数据分离，可以减小表的宽度。如果放在一个表里面，每次查询都要读取大记录，会消耗较多的资源。</p>
<p>MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。表越宽，把表装载进内存缓冲池时所占用的内存也就越大，会消耗更多的 IO。冷热数据分离的目的是：减少磁盘 IO，保证热数据的内存缓存命中率；更有效的利用缓存，避免读入无用的冷数据。</p>
<p>举例：会员 members 存储会员登录认证信息，该表中有很多字段，如 id、姓名、密码、地址、电话、个人描述字段。其中地址、电话、个人描述等字段并不常用，可以将这些不常用的字段分解出另一个表。将这个表取名叫 members_detail，表中有 member_id、address、telephone、description 等字段。这样就把会员表分成了两个表，分别为 members 和 members_detail 表。</p>
<p>创建这两个表的 SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> members (</span><br><span class="line">	id <span class="type">int</span>() <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  username <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  password <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  last_login_time datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  last_login_ip <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> members_detail (</span><br><span class="line">	member_id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  address <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  telephone <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  description text</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果需要查询会员的基本信息或详细信息，那么可以用会员的 id 来查询。如果需要将会员的基本信息和详细信息同时显示，那么可以将 members 表和 members_detail 表进行联合查询，查询语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> members <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> members_detail <span class="keyword">ON</span> members.id <span class="operator">=</span> members_detail.member_id;</span><br></pre></td></tr></table></figure>

<p>通过这种分解可以提高表的查询效率。对于字段很多且有些字段使用不频繁的表，可以通过这种分解的方式来优化数据库的性能。</p>
<h4 id="增加中间表"><a href="#增加中间表" class="headerlink" title="增加中间表"></a>增加中间表</h4><p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，<strong>把需要经常李娜和查询的数据插入中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率</strong>。</p>
<p>首先，分析经常联合查询表中的字段；然后，使用这些字段建立一个中间表，并将原来联合查询的表的数据插入中间表中；最后，使用中间表来进行查询。</p>
<p>举例：学生信息表和班级表的 SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `class` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `className` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `address` <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `monitor` <span class="type">INT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `stuno` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `classId` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>现在有一个模块需要经常查询带有学生名称 (name)、学生所在班级名称 (className)、学生班级班长 (monito) 的学生信息。根据这种情况可以创建一个 temp_student 表。temp_student 表中存储学生名称 (stu_name)、学生所在班级名称 (className) 和学生班级班长 (monitor) 信息。创建表的语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `temp_student` (</span><br><span class="line">	`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `stu_name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `className` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `monitor` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>接下来，从学生信息表和班级表中查询相关信息存储到临时表中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_student(stu_name, clasName, monitor)</span><br><span class="line"><span class="keyword">SELECT</span> s.name, c.className, c.monitor</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">as</span> s, class <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">WHERE</span> s.classId <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure>

<p>以后，可以直接从 temp_student 表中查询学生名称、班级名称和班级班长，而不用每次都进行联合查询。这样可以提高数据库的查询速度。</p>
<blockquote>
<p>如果用户信息修改了，是不是会导致 temp_vip 中的数据不一致的问题呢？如何同步数据呢？</p>
<p>方式1: 清空数据 -&gt; 重新添加数据</p>
<p>方式2: 使用视图</p>
</blockquote>
<h4 id="增加冗余字段"><a href="#增加冗余字段" class="headerlink" title="增加冗余字段"></a>增加冗余字段</h4><p>设计数据库表时应尽量遵循范式理论的规约，尽可能减少冗余字段，让数据库设计看起来精致、优雅。但是，合理地加入冗余字段可以提高查询速度。</p>
<p>表的规范化程度越高，表于表之间的关系就越多，需要连接查询的情况也就越多。尤其在数据量大，而且需要频繁进行连接的时候，为了提升效率，我们也可以考虑增加冗余字段来减少连接。</p>
<p>改进表的设计时，可以考虑优化字段的数据类型。这个问题在打架刚从事开发时进本不算是问题。但是，随着你的经验越来越丰富，参与的项目越来越大，数据量也越来越多的时候，你就不能只从系统稳定性的角度来思考问题了，还要考虑懂啊系统整体的稳定性和效率。此时，优先选择符合存储需要的最小的数据类型。</p>
<p>列的字段越大，建立索引时所需要的空间也就越大。这样一页中所能存储的索引节点的数据量也就越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。</p>
<p>具体来说：</p>
<ul>
<li><p>情况一：对整数类型数据进行优化。</p>
<p>  遇到整数类型的字段可以用 INT 型。这样做的理由是，INT 型数据有足够大的取值范围，不用担心数据超出取值范围的问题。刚开始做项目的时候，首先要保证系统的稳定性，这样设计字段类型是可以的。但在数据量很大的时候，数据类型的定义，在很大程度上会影响到系统整体的执行效率。</p>
<p>  对于非负型的数据 (如自增 ID、整型 IP) 来说，要优先使用无符号整型 UNSIGNED 来存储。因为无符号相对于有符号，同样的字节数，存储的数值范围更大。如 tinyint 有符号为 -128～127，无符号为 0～255，多出一倍的存储空间。</p>
</li>
<li><p>情况二：既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型。</p>
<p>  跟文本类型数据相比，大整数往往占用更少的存储空间，因此，在存取和比对的时候，可以占用更少的内存空间。所以，在二者皆可用的情况下，尽量使用整数类型，这样可以提高查询的效率。如：将 IP 地址转换成整型数据。</p>
</li>
<li><p>情况三：避免使用 TEXT、BLOB 数据类型</p>
<p>  MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用 磁盘临时表进行。并且对于这种数据，MySQL 还是要进行二次查询，会使 SQL 性能表的很差，但是不是说一定不能使用这样的数据类型。</p>
<p>  如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select *，而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p>
</li>
<li><p>情况四：避免使用 ENUM 类型</p>
<p>  修正 ENUM 值需要使用 ALTER 语句。</p>
<p>  ENUM 类型的 OPDER BY 操作效率低，需要额外操作。使用 TINYINT 来代替 ENUM 类型。</p>
</li>
<li><p>情况五：使用 TIMESTAMP 存储时间</p>
<p>  TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19 03:14:07。TIMESTAMP 使用 4 字节，DATETIME 使用 8 个字节，同时 TIMESTAMP 具有自动赋值以及自动更新的特性。</p>
</li>
<li><p>情况六：用 DECIMAL 代替 FLOAT 和 DOUBLE 存储精确浮点数</p>
<ul>
<li>非精准浮点：float、double</li>
<li>精准浮点：decimal</li>
</ul>
<p>  Decimal 类型为精准浮点数，在计算时不会丢失精度，尤其是财务相关的金融类数据。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。可以用于存储比 bigint 更大的整型数据。</p>
</li>
</ul>
<p>总之，遇到数据量大的项目时，一定要在充分连接业务需求的前提下，合理优化数据类型，这样才能充分发挥资源的效率，使系统达到最优。</p>
<h4 id="优化插入记录的速度"><a href="#优化插入记录的速度" class="headerlink" title="优化插入记录的速度"></a>优化插入记录的速度</h4><p>插入记录时，影响插入速度的主要时索引、唯一性校验、一次插入记录条数等。根据这些情况可以分别进行优化。这里我们分为 MyISAM 引擎和 InnoDB 存储引擎来讲。</p>
<ul>
<li><p>MyISAM 引擎的表：</p>
<ul>
<li><p>禁用索引</p>
<p>  对于非空表，插入记录时，MySQL 会根据表的索引对插入的记录建立索引。如果插入大量数据，建立索引就会降低插入记录的速度。为了解决这种问题，可以再插入记录之前禁用索引，数据插入完毕后再开启索引。禁用索引的语句如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name DISABLE KEYS;</span><br></pre></td></tr></table></figure>

<p>  重新开启索引的语句如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name ENABLE KEYS;</span><br></pre></td></tr></table></figure>

<p>  若对于空表批量导入数据，则不需要进行此操作，因为 MyISAM 引擎的表是在导入数据之后才建立索引的。</p>
</li>
<li><p>禁用唯一性检查</p>
<p>  插入数据时，MySQL 会对插入的记录进行唯一性校验。这种唯一性校验会降低插入记录的速度。为了降低这种情况对查询速度的影响，可以在插入记录之前禁用唯一性检查，等到记录插入完毕后再开启。禁用唯一性检查的语句如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> UNIQUE_CHECKS<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>  开启唯一性检查的语句如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> UNIQUE_CHECKS<span class="operator">=</span><span class="number">1</span>；</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用批量插入</p>
<p>  插入多条记录时，可以使用一条 INSERT 语句插入一条记录，也可以使用一条 INSERT 语句插入多条记录。插入一条记录的 INSERT 语句情形如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;wangwu&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">&#x27;zhaoliu&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>  使用一条 INSERT 插入多条记录的情形如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;wangwu&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;zhaoliu&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>  第二种情形的插入速度要比第一种情形快。</p>
</li>
<li><p>使用 LOAD DATA INFILE 批量导入</p>
<p>  当需要批量导入数据时，如果能用 LOAD DATA INFILE 语句，就尽量使用。因为 LOAD DATA INFILE 语句导入数据的速度比 INSERT 语句快。</p>
</li>
</ul>
</li>
<li><p>InnoDB 引擎的表：</p>
<ul>
<li><p>禁用唯一性检查</p>
<p>  插入数据之前执行 <code>set unique_checks=0</code> 来禁止对唯一索引的检查，数据导入完成之后再运行 <code>set unique_checks=1</code>。这个和 MyISAM 引擎的使用方法一样。</p>
</li>
<li><p>禁用外键检查</p>
<p>  插入数据执勤啊执行禁止对外键的检查，数据插入完成之后再恢复对外键的检查。禁用外键检查的语句如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> foreign_key_checks<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>  恢复对外键的检查语句如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> foreign_key_checks<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁止自动提交</p>
<p>  插入数据之前禁止事物的自动提交，数据导入完成之后，执行恢复自动提交操作。禁止自动提交的语句如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>  恢复自动提交的语句如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="使用非空约束"><a href="#使用非空约束" class="headerlink" title="使用非空约束"></a>使用非空约束</h4><p>在设计字段的时候，如果业务允许，建议尽量使用非空约束。这样做的好处是：</p>
<ul>
<li>进行比较和计算时，省去要对 NULL 值的字段判断是否为空的开销，提高存储效率。</li>
<li>非空字段也容易创建索引。因为索引 NULL 列需要额外的空间来保存，所以要占用更多的空间。使用非空约束，就可以节省存储空间 (每个字段 1 个 bit)。</li>
</ul>
<h4 id="分析表、检查表与优化表"><a href="#分析表、检查表与优化表" class="headerlink" title="分析表、检查表与优化表"></a>分析表、检查表与优化表</h4><p>MySQL 提供了分析表、检查表和优化表的语句。分析表主要是分析关键字的分布，检查表主要是检查表是否存在错误，优化表主要是消除删除或者更新造成的空间浪费。</p>
<ul>
<li><p>分析表</p>
<p>  MySQL 中提供了 ANALYZE TABLE 语句分析包，ANALYZE TABLE 语句的基本语法如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> tbl_name[, tbl_name]...</span><br></pre></td></tr></table></figure>

<p>  默认的，MySQL 服务会讲 ANALYZE TABLE 语句写到 BINLOG 中，以便在主从架构中，从服务能够同步数据。可以添加参数 LOCAL 或者 NO_WRITE_TO_BINLOG 取消将语句写到 BINLOG 中。</p>
<p>  使用 ANALYZE TABLE 分析表的过程中，数据库系统会自动对表加一个只读锁。在分析期间，只能读取表中的记录，不能更新和插入记录。ANALYZE TABLE 语句能够分析 InnoDB 和 MyISAM 类型的表，但是不能作用于视图。</p>
<p>  ANALYZE TABLE 分析后的统计结果会反应到 cardinality 的值，该值统计了表中某一键所在的列不重复的值的个数。<strong>该值越接近表中的总行数，则在表连接查询或者索引查询时，就越优先被优化器选择使用</strong>。也就是索引列的 cardinality 的值愈表中数据的总条数差距越大，即使查询的时候使用了该索引作为查询条件，存储引擎实际查询的时候使用的概率就越小。下面通过例子来验证下。cardinality 可以通过 SHOW INDEX FROM 表名查看。</p>
</li>
<li><p>检查表</p>
<p>  MySQL 中可以使用 CHECK TABLE 语句来检查表。CHECK TABLE 语句能够检查 InnoDB 和 MyISAM 类型的表是否存在错误。CHECK TABLE 语句在执行过程中也会给表加上只读锁。</p>
<p>  对于 MyISAM 类型的表，CHECK TABLE 语句还会更新关键字统计数据。而且，CHECK TABLE 也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在。该语句的基本语法如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHECK</span> <span class="keyword">TABLE</span> tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option <span class="operator">=</span> &#123;QUICK <span class="operator">|</span> FAST <span class="operator">|</span> MEDIUM <span class="operator">|</span> EXTENDED <span class="operator">|</span> CHANGED&#125;</span><br></pre></td></tr></table></figure>

<p>  其中，tbl_name 是表名；option 参数有 5 个取值，分别是 QUICK、FAST、MEDIUM、EXTENDED 和 CHANGED。各个选项的意义分别是：</p>
<ul>
<li>QUICK：不扫描行，不检查错误的连接。</li>
<li>FAST：只检查没有被正确关闭的表。</li>
<li>CHANGED：值检查上次检查后被更改的表和没有被正确关闭的表。</li>
<li>MEDIUM：扫描行，以验证被删除的连接是有效的。也可以计算各行的关键字校验和，并使用计算出的校验和验证这一点。</li>
<li>EXTENDED：对每行的所有关键字进行一个全面的关机那字查找。这可以确保表时 100% 一致的，但是画的时间较长。</li>
</ul>
<p>  option 只对 MyISAM 类型的表有效，对 InnoDB 类型的表无效。</p>
</li>
<li><p>优化表</p>
<ul>
<li><p>OPTIMIZE TABLE</p>
<p>  MySQL 中使用 OPTIMIZE TABLE 语句来优化表。但是 OPTIMIZE TABLE 语句只能优化表中的 VARCHAR、BLOB 或 TEXT 类型的字段。一个表使用了这些字段的数据类型，若已经删除了表的一大部分数据，或者已经对含有可变长度行的表 (含有 VARCHAR、BLOB 或 TEXT 列的表) 进行了很多更新，则应使用 OPTIMIZE TABLE 来重新利用未使用的空间，并整理数据文件的碎片。</p>
<p>  OPTIMIZE TABLE 语句对 InnoDB 和 MyISAM 类型的表都有效。该语句在执行过程中也会给表加上只读锁。</p>
<p>  OPTIMIZE TABLE 语句的基本语法如下：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> tbl_name[, tbl_name] ...</span><br></pre></td></tr></table></figure>

<p>  LOCAL ｜ NO_WRITE_TO_BINLOG 关键字的意义和分析表相同，都是指定不写入二进制日志。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> optimize <span class="keyword">table</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+----------+----------+-------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>              <span class="operator">|</span> Op       <span class="operator">|</span> Msg_type <span class="operator">|</span> Msg_text                                                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+----------+----------+-------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> mysql_test.student <span class="operator">|</span> optimize <span class="operator">|</span> note     <span class="operator">|</span> <span class="keyword">Table</span> does <span class="keyword">not</span> support optimize, doing recreate <span class="operator">+</span> analyze instead <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql_test.student <span class="operator">|</span> optimize <span class="operator">|</span> status   <span class="operator">|</span> OK                                                                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+----------+----------+-------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">1.17</span> sec)</span><br></pre></td></tr></table></figure>

<p>  Msg_text 显示</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Table</span> does <span class="keyword">not</span> support optimize, doing recreate <span class="operator">+</span> analyze instead</span><br></pre></td></tr></table></figure>

<p>  是因为该表的存储引擎是 InnoDB。根据官网介绍，在 MyISAM中，实现分析这张表，然后会整理相关的 MySQL datafile，之后回收未使用的空间；在 InnoDB 中，回收空间是简单通过 Alter table 进行整理空间。在优化期间，MySQL 会创建一个临时表，优化完成之后会删除原始表，然后会将临时表 rename 成为原始表。</p>
<blockquote>
<p>说明：</p>
<p>在多数的设置中，根本不需要运行 OPTIMIZE TABLE。即使对可变长度的行进行了大量的更新，也不需要经常运行，每周一次或每月一次即可，并且只需要对特定的表运行。</p>
</blockquote>
</li>
<li><p>方式二：使用 mysqlcheck 命令</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlcheck <span class="operator">-</span>o DatabaseName TableName <span class="operator">-</span>uroot <span class="operator">-</span>p<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br></pre></td></tr></table></figure>

<p>  mysqlcheck 是 Linux 中的 rompt，-o 是代表 Optimize。</p>
</li>
</ul>
</li>
</ul>
<h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p>上述这些方法都是有利有弊的。比如：</p>
<ul>
<li>修改数据类型，节省存储空间的同时，要考虑到数据不能超过取值范围；</li>
<li>增加冗余字段的时候，不要忘了确保数据一致性；</li>
<li>把大表拆分，也意味着你的查询会增加新的连接，从而增加额外的开销和运维的成本。</li>
</ul>
<p>因此，你一定要结合实际的业务需求进行权衡。</p>
<h3 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h3><p>当 MySQL 单表记录数过大时，数据库的 CRUD 性能会明显下降，一些常见的优化措施如下：</p>
<h4 id="限定查询的范围"><a href="#限定查询的范围" class="headerlink" title="限定查询的范围"></a>限定查询的范围</h4><p><strong>禁止不带任何限制数据范围条件的查询语句</strong>。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。</p>
<h4 id="读-x2F-写分离"><a href="#读-x2F-写分离" class="headerlink" title="读&#x2F;写分离"></a>读&#x2F;写分离</h4><p>经典的数据库拆分方案，主库负责写，从库负责读。</p>
<ul>
<li><p>一主一从模式</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E4%B8%80%E4%B8%BB%E4%B8%80%E4%BB%8E%E6%A8%A1%E5%BC%8F.png" alt="一主一从模式"></p>
</li>
<li><p>双主双从模式</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E5%8F%8C%E4%B8%BB%E5%8F%8C%E4%BB%8E%E6%A8%A1%E5%BC%8F.png" alt="双主双从模式"></p>
</li>
</ul>
<h4 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h4><p>当数据量达到千万级以上时，有时候我们需要把一个数据库切分成多份，放到不同的数据库服务器上，减少对单一数据库服务器的访问压力。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87-1.png" alt="垂直拆分"></p>
<ul>
<li>如果数据库中的数据表过多，可以采用垂直分库的方式，将关联的数据表部署在同一个数据库上。</li>
<li>如果数据表中的列过多，可以采用垂直分表的方式，将一张数据表分拆成多张数据表，把经常一起使用的列放到同一张表里。</li>
</ul>
<p><strong>垂直拆分的有点</strong>：可以是的列数据变小，在查询时减少读取的 BLOCK 数，减少 IO 次数。此外，垂直分区可以简化表的结构，易于维护。</p>
<p><strong>垂直拆分的缺点</strong>：主键会出现冗余，需要管理冗余列，并会引起 JOIN 操作。此外，垂直拆分会让事物变得更加复杂。</p>
<h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><ul>
<li>尽量控制单表数据量的大小，建议控制在 1000 万以内。1000 万并不是 MySQL 数据库的限制，过大会造成修改表结构、备份、恢复都会有很大的问题。此时可以用历史数据归档 (应用于日志数据)，水平分表 (应用于业务数据) 等手段来控制数据量大小。</li>
<li>这里我们主要考虑业务数据的水平分表策略。将大的数据表按照某个属性维度分拆成不同的小表，每张小表保持相同的表结构。比如你可以按照年份来划分，把不同年份的数据放到不同的数据表中。2017 年、2018 年和 2019 年的数据就可以分别放到三张数据表中。</li>
<li>水平分表近视解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升 MySQL 并发能力没有什么意义，所以水平拆分最好分库，从而达到分布式的目的。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87-2.png" alt="水平拆分"></p>
<p>水平拆分能够支持非常大的数据量存储，应用端改造也少，但分片事物难以解决，跨界点 Join 性能较差，逻辑复杂。《Java 工程师修炼之道》 的作者推荐<strong>尽量不要对数据进行分片，因为拆分会到来逻辑、部署、运维的各种复杂度</strong>，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络 IO。</p>
<p>下面补充一下数据库分片的两种常见方案：</p>
<ul>
<li><strong>客户端代理：分片逻辑在应用端，封装在 jar 包里，通过修改或着封装 JDBC 层来实现</strong>。当当网的 Sharding-JDBC、阿里的 TDDL 是两种比较常用的实现。</li>
<li><strong>中间件代理：在应用层和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中</strong>。我们现在谈的 Mycat、360 的 Atlas、网易的 DDB 等等都是这种架构的实现。</li>
</ul>
<h3 id="其它调优策略"><a href="#其它调优策略" class="headerlink" title="其它调优策略"></a>其它调优策略</h3><h4 id="服务器语句超时处理"><a href="#服务器语句超时处理" class="headerlink" title="服务器语句超时处理"></a>服务器语句超时处理</h4><p>在 MySQL 8.0 中可以设置服务器语句超时的限制，单位可以达到毫秒级别。当中断的执行语句超过设置的毫秒数后，服务器将终止查询影响不大的事物或连接，然后将错误报给客户端。</p>
<p>设置服务器语句超时的限制，可以通过设置系统变量 MAX_EXECUTION_TIME 来实现。默认情况下，MAX_EXECUTION_TIME 的值为 0，代表没有时间限制。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> MAX_EXECUTION_TIME<span class="operator">=</span><span class="number">2000</span>;</span><br><span class="line"><span class="keyword">SET</span> SESSION MAX_EXECUTION_TIME<span class="operator">=</span><span class="number">2000</span>; # 指定该会话中 <span class="keyword">SELECT</span> 语句的超时时间</span><br></pre></td></tr></table></figure>

<h4 id="创建全局通用表空间"><a href="#创建全局通用表空间" class="headerlink" title="创建全局通用表空间"></a>创建全局通用表空间</h4><p>MySQL 8.0 使用 CREATE TABLESPACE 语句来创建一个全局通用表空间。全局表空间可以被所有的数据库的表共享，而且相比于独享表空间，<strong>使用手动创建共享空间可以节约元数据方面的内存</strong>。可以在创建表的时候，指定属于哪个表空间，也可以对已有表进行表空间修改等。</p>
<p>下面创建名为 test1 的共享表空间，SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE test1 <span class="keyword">ADD</span> datafile `test1.ibd` file_block_size<span class="operator">=</span><span class="number">16</span>k;</span><br><span class="line"></span><br><span class="line"># 指定表空间，<span class="keyword">SQL</span> 语句如下：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">10</span>)) engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset utf8mb4 tablespace test1;</span><br><span class="line"></span><br><span class="line"># 也可以通过 <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 语句指定表空间</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test tablespace test1;</span><br></pre></td></tr></table></figure>

<p>因为是共享表空间，所以不能直接通过 drop table tbname 删除，这样操作并不能回收空间。当确定共享表空间的数据都没用，并且依赖该表空间的表均已经删除时，可以通过 drop tablespace 删除共享表空间来释放空间，如果依赖该共享表空间的表存在，就会删除失败。如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> TABLESPACE test1;</span><br><span class="line">Tablespace <span class="string">&#x27;test1&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> empty.</span><br></pre></td></tr></table></figure>

<p>所以应该首先删除依赖该表空间的数据表，SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> test;</span><br></pre></td></tr></table></figure>

<p>最后即可删除表空间，SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> TABLESPACE test1;</span><br></pre></td></tr></table></figure>

<h4 id="MySQL-8-0-新特性：隐藏索引对调优的帮助"><a href="#MySQL-8-0-新特性：隐藏索引对调优的帮助" class="headerlink" title="MySQL 8.0 新特性：隐藏索引对调优的帮助"></a>MySQL 8.0 新特性：隐藏索引对调优的帮助</h4><p>不可见索引的特性对于性能调试非常有用。在 MySQL 8.0 中，索引可以被隐藏和显示。当一个索引被隐藏时，它不会被查询优化器所使用。也就是说，管理员可以隐藏一个索引，然后观察对数据库的影响。如果数据库性能有所下降，就说明这个索引是有用的，于是将其恢复显示即可；如果数据库性能看不出变化，就说明这个索引是多余的，可以删掉了。</p>
<p>需要注意的是当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p>
<p>数据表中的主键不能被设置为 invisible。</p>
<h2 id="事务基础知识"><a href="#事务基础知识" class="headerlink" title="事务基础知识"></a>事务基础知识</h2><h3 id="数据库事务概述"><a href="#数据库事务概述" class="headerlink" title="数据库事务概述"></a>数据库事务概述</h3><p>事务是数据库区别于文件系统的重要特性之一，当我们有了事务就会让数据库始终保持一致性，同时我们还能通过事务的机制恢复到某个时间点，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失。</p>
<h4 id="存储引擎支持情况"><a href="#存储引擎支持情况" class="headerlink" title="存储引擎支持情况"></a>存储引擎支持情况</h4><p>SHOW ENGINES 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> engines;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> Engine             <span class="operator">|</span> Support <span class="operator">|</span> Comment                                                        <span class="operator">|</span> Transactions <span class="operator">|</span> XA   <span class="operator">|</span> Savepoints <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> ARCHIVE            <span class="operator">|</span> YES     <span class="operator">|</span> Archive storage engine                                         <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLACKHOLE          <span class="operator">|</span> YES     <span class="operator">|</span> <span class="operator">/</span>dev<span class="operator">/</span><span class="keyword">null</span> storage engine (anything you write <span class="keyword">to</span> it disappears) <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MRG_MYISAM         <span class="operator">|</span> YES     <span class="operator">|</span> Collection <span class="keyword">of</span> identical MyISAM tables                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FEDERATED          <span class="operator">|</span> <span class="keyword">NO</span>      <span class="operator">|</span> Federated MySQL storage engine                                 <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MyISAM             <span class="operator">|</span> YES     <span class="operator">|</span> MyISAM storage engine                                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> PERFORMANCE_SCHEMA <span class="operator">|</span> YES     <span class="operator">|</span> Performance Schema                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> InnoDB             <span class="operator">|</span> <span class="keyword">DEFAULT</span> <span class="operator">|</span> Supports transactions, <span class="type">row</span><span class="operator">-</span>level locking, <span class="keyword">and</span> <span class="keyword">foreign</span> keys     <span class="operator">|</span> YES          <span class="operator">|</span> YES  <span class="operator">|</span> YES        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MEMORY             <span class="operator">|</span> YES     <span class="operator">|</span> Hash based, stored <span class="keyword">in</span> memory, useful <span class="keyword">for</span> temporary tables      <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CSV                <span class="operator">|</span> YES     <span class="operator">|</span> CSV storage engine                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br></pre></td></tr></table></figure>

<p>能看出在 MySQL中国呢，只有 InnoDB 是支持事务的。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>事务</strong>：一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p>
<p><strong>事物处理的原则</strong>：保证所有事物都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事物都被提交 (commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事物回滚 (rollback) 到最初状态。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 案例：AA用户给BB用户转账<span class="number">100</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;AA&#x27;</span>;</span><br><span class="line"># 服务器宕机</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;BB&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="事物的-ACID-特性"><a href="#事物的-ACID-特性" class="headerlink" title="事物的 ACID 特性"></a>事物的 ACID 特性</h4><ul>
<li><p><strong>原子性 (Atomicity)</strong></p>
<p>  原子性是指事物是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。即要么转账成功，要么转账失败，是不存在中间的状态。如果无法保证原子性会怎么样？就会出现数据不一致的情形，A 账户减去 100 元，而 B 账户增加 100 元操作失败，系统将无故丢失 100 元。</p>
</li>
<li><p><strong>一致性 (Consistency)</strong></p>
<p>  根据定义，一致性是指事务执行前后，数据从一个合法性状态变换到另一个合法性状态。这种状态是语义上的而不是语法上的，跟具体的业务有关。</p>
<p>  满足约定的约束的状态就叫做合法的状态。通俗一点，这状态是由自己来定义的 (比如满足现实世界中的约束)。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的！如果事物中的某个操作失败了，系统就会自动撤销当前正在执行的事物，返回到事物操作之前的状态。</p>
<p>  举例：A 账户有 200 元，转账 300 元出去，此时 A 账户余额为 -100 元。你自然就发现了此时数据是不一致的，为什么呢？因为你定义了一个状态，余额这列必须 &gt;&#x3D; 0。如果 A 转账 50 给 B 账户，但是 B 账户由于种种原因没有收到，此时数据也是不一致的，因为 A 和 B 账户的总金额必须不变。</p>
</li>
<li><p><strong>隔离性 (Isolation)</strong></p>
<p>  事物的隔离性是指一个事务的执行不能被其他事物干扰，即一个事务内部的操作及使用的数据对并发的其它事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>  如果无法保证隔离性会怎么样？假设 A 账户有 200 元，B 账户 0 元。A 账户往 B 账户转账两次，每次金额为 50 元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">50</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;AA&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">50</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;BB&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E9%9A%94%E7%A6%BB%E6%80%A7%E6%A1%88%E4%BE%8B.png" alt="隔离性案例"></p>
</li>
<li><p><strong>持久性 (Durability)</strong></p>
<p>  持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其它操作和数据库故障不应该对其有任何影响。</p>
<p>  持久性是通过事务日志来保证的。日志包括了重做日志和回滚日志。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p>
<blockquote>
<p>总结</p>
<p>ACID 是事务的四大特性，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件，而持久性时我们的目的。</p>
<p>数据库事务，其实就是数据库设计者为了方便起见，把需要保证原子性、隔离性、一致性和持久性的一个或多个数据库操作称为一个事务。</p>
</blockquote>
</li>
</ul>
<h4 id="事务的状态"><a href="#事务的状态" class="headerlink" title="事务的状态"></a>事务的状态</h4><p>事务是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL 根据这些操作所执行的不同阶段把事务大致划分成几个状态：</p>
<ul>
<li><p><strong>活动的 (Active)</strong></p>
<p>  事务对应的数据库操作正在执行过程中时，该事务处于活动的状态。</p>
</li>
<li><p><strong>部分提交的 (Partially committed)</strong></p>
<p>  当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态。</p>
</li>
<li><p><strong>失败的 (Failed)</strong></p>
<p>  当事务处在活动的活着部分提交的状态时，可能遇到了某些错误 (数据库自身的错误、操作系统错误或者直接断电等) 而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态。</p>
</li>
<li><p><strong>中止的 (Aborted)</strong></p>
<p>  如果事务执行了一部分而变为失败的状态，那么就需要把意境修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为回滚。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。</p>
</li>
<li><p><strong>提交的 (Committed)</strong></p>
<p>  当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了提交的状态。一个基本的状态转换图如下所示：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt="状态转换图"></p>
</li>
</ul>
<h3 id="如何使用事物"><a href="#如何使用事物" class="headerlink" title="如何使用事物"></a>如何使用事物</h3><p>使用事务有两种方式，分别为显式事务和隐式事务。</p>
<h4 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h4><p><strong>步骤一</strong>：<code>START TRANSACTION</code> 或者 <code>BEGIN</code>，作用是显式开启一个事务。</p>
<p><code>START TRANSACTION</code> 语句相较于 <code>BEGIN</code> 特别之处在于，后边能跟随几个修饰符：</p>
<ul>
<li><p><code>READ ONLY</code>：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p>
<blockquote>
<p>补充：只读事务中知识不允许修改那些其它事务也能访问到的表中的数据，对于临时表来说 (我们使用 <code>CREATE TMEPORARY TABLE</code> 创建的表)，由于它们只能在当前会话中可见，所有只读事务其实也是可以对临时表进行增、删、改操作的。</p>
</blockquote>
</li>
<li><p><code>READ WRITE</code>：标识当前事务是一个读写事务，也就是属于该事务的数据库操作即可以读取数据，也可以修改数据。</p>
</li>
<li><p><code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读。</p>
</li>
</ul>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION READ <span class="keyword">ONLY</span>;# 开启一个只读事务</span><br><span class="line"><span class="keyword">START</span> TRANSACTION READ <span class="keyword">ONLY</span>, <span class="keyword">WITH</span> CONSISTENT SNAPSHOT;# 开启只读事务和一致性读</span><br><span class="line"><span class="keyword">START</span> TRANSACTION READ WRITE, <span class="keyword">WITH</span> CONSISTENT SNAPSHOT;# 开启读写事务和一致性读</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p><code>READ ONLY</code> 和 <code>READ WRITE</code> 是用来设置所谓的事务访问模式的，就是以只读还是读写的方式来访问数据库中的数据，一个事务的访问模式不能同时既设置为只读的也设置为读写的，所以不能同时把 <code>READ ONLY</code> 和 <code>READ WRITE</code> 放到 <code>START TRANSACTION</code> 语句后边。如果我们不显式指定事务的访问模式，那么该事务的访问模式就是读写模式。</p>
<p><strong>步骤二</strong>：一系列事务中的操作 (主要是 DML，不含 DDL)</p>
<p><strong>步骤三</strong>：提交事务或中止事务 (即回滚事务)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 提交事务。当提交事务后，对数据库的修改是永久性的。</span><br><span class="line"><span class="keyword">COMMIT</span>；</span><br><span class="line"># 回滚事务，即撤销正在进行的所有没有提交的修改</span><br><span class="line"><span class="keyword">ROLLBACK</span>；</span><br><span class="line"># 将事务回滚到某个保存点</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> [<span class="keyword">SAVEPOINT</span>]</span><br></pre></td></tr></table></figure>

<p>其中关于 SAVEPOINT 相关操作有：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。</span><br><span class="line"><span class="keyword">SAVEPOINT</span> 保存点名称;</span><br><span class="line"># 删除某个保存点</span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> 保存点名称;</span><br></pre></td></tr></table></figure>

<h4 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h4><p>MySQL 中有一个系统变量 <code>autocommit</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;autocommit&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> autocommit    <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，如我我们不显式的使用 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的自动提交。也就是说，不以 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 语句显式的开启一个事务，那么下边这两条语句就相当于放到两个独立的事务中去执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">10</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">10</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>当然，如果我们想关闭这种自动提交的功能，可以使用下边两种方法之一：</p>
<ul>
<li><p>显式的使用 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</p>
</li>
<li><p>把系统变量 autocommit 的值设置为 off，就像这样：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> OFF;</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这样的话，我们写入的多条语句就算是属于同一个事务了，直到我们显式的写出 COMMIT 语句来把这个事务提交掉，或者显式的写出 ROLLBACK 语句来把这个事务回滚掉。</p>
<blockquote>
<p>补充：Oracle 默认不自动提交，需要手写 COMMIT 命令，而 MySQL 默认自动提交。</p>
</blockquote>
<h4 id="隐式提交数据的情况"><a href="#隐式提交数据的情况" class="headerlink" title="隐式提交数据的情况"></a>隐式提交数据的情况</h4><ul>
<li><p><strong>数据定义语言 (DDL)</strong></p>
<p>  数据库对象，指的就是数据库、表、视图、存储过程等结构。当我们使用 CREATE、ALTER、DROP 等语句去修改数据库对象时，就会隐式的提交前边语句所属于的事务。即：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">SELECT...</span><br><span class="line">UPDATE...</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ...# 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>隐式使用或修改 mysql 数据库中的表</strong></p>
<p>  当我们使用 <code>ALTER USER</code>、<code>UPDATE USER</code>、<code>DROP USER</code>、<code>GRANT</code>、<code>RENAME USER</code>、<code>ALTER USER</code>、<code>REVOKE</code>、<code>SET PASSWORD</code> 等语句时也会隐式的提交前边语句所属于的事务。</p>
</li>
<li><p>事务控制或关于锁定的语句</p>
<p>  当我们在一个事务还没提交或者回滚时就又使用 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 语句开启了另一个事务时，会隐式的提交上一个事务。即：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">UPDATE</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;# 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure>

<p>  当前的 autocommit 系统变量的值为 OFF，我们手动把它调整为 ON 时，也会隐式的提交前边语句所属的事务。</p>
<p>  使用 <code>LOCK TABLES</code>、<code>UNLOCK TABLES</code> 等关于锁定的语句也会隐式的提交前边语句所属的事务。</p>
</li>
<li><p>加载数据的语句</p>
<p>  使用 <code>LOAD DATA</code> 语句来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务。</p>
</li>
<li><p>关于 MySQL 复制的一些语句</p>
<p>  使用 <code>START SLAVE</code>、<code>STOP SLAVE</code>、<code>RESET SLAVE</code>、<code>CHANGE MASTER TO</code> 等语句时会隐式的提交前边语句所属的事务。</p>
</li>
<li><p>其它的一些语句</p>
<p>  使用 <code>ANALYZE TABLE</code>、<code>CACHE INDEX</code>、<code>CHECK TABLE</code>、<code>FLUSH</code>、<code>LOAD INDEX INTO CACHE</code>、<code>OPTIMIZE TABLE</code>、<code>REPAIR TABLE</code>、<code>RESET</code> 等语句也会隐式的提交前边语句所属的事务。</p>
</li>
</ul>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>MySQL 是一个客户端 &#x2F; 服务器架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接之后，就可以称为一个会话 (Session)。每个客户端都可以在自己的会话中想服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。事务由隔离性的特性，理论上在某个事务对某个数据进行访问时，其它事务应该进行 排队，当该事务提交之后，其它事务才可以继续访问这个数据。但是这样对性能影响太大，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，那就看二者如何权衡取舍了。</p>
<h4 id="数据准备-4"><a href="#数据准备-4" class="headerlink" title="数据准备"></a>数据准备</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">	studentno <span class="type">INT</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  class <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (studentno)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;小姑娘&#x27;</span>, <span class="string">&#x27;1班&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="数据并发问题"><a href="#数据并发问题" class="headerlink" title="数据并发问题"></a>数据并发问题</h4><p>针对事务的隔离性和并发性，我们怎么做取舍呢？先看一下访问相同数据的事务在不保证串行执行 (也就是执行完一个在执行另一个) 的情况下可能会出现哪些问题：</p>
<ul>
<li><p><strong>脏写 (Dirty Write)</strong></p>
<p>  对于两个事务 Session A、Session B，如果事务 Session A 修改了另一个未提交事务 Session B 修改过的数据，那就意味着发生了脏写，示意图如下：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E8%84%8F%E5%86%99%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="脏写示意图"></p>
<p>  Session A 和 Session B 各开启了一个事务，Session B 中的事务先将 studentno 列为 1 的记录的 name 列更新为 ‘李四’，然后 Session A 中的事务接着又把这条 studentno 列为 1 的记录的 name 列更新为 ‘张三’。如果之后 Session B 中的事务进行了回滚，那么 Session A 中的更新也将不复存在，这种现象就称之为脏写。这时 Session A 中的事务就没有效果了，明明把数据更新了，最后也提交事物了，最后看到的数据什么变化也没有。这里大家对事务的隔离级别比较了解的话，会发现默认隔离级别下，上面 Session A 中的更新语句会处于等待状态，这里知识跟大家说明一下会出现这样现象。</p>
</li>
<li><p><strong>脏读 (Dirty Read)</strong></p>
<p>  对于两个事务 Session A、Session B，Session A 读取了已经被 Session B 更新但还没有被提交的字段。之后若 Session B 回滚，Session A 读取的内容就是临时且无效的。</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E8%84%8F%E8%AF%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="脏读示意图"></p>
<p>  Session A 和 Session B 各开启了一个事务，Session B 中的事务先将 studentno 列为 1 的记录的 name 列更新为 ‘张三’，然后 Session A 中的事务再去查询这条 studentno 为 1 的记录，如果读到列 name 的值为 ‘张三’，而 Session B 中的事务稍后进行了回滚，那么 Session A 中的事务相当于读到了一个不存在的数据，这种现象就称之为脏读。</p>
</li>
<li><p><strong>不可重复读 (Non-Repeatable Read)</strong></p>
<p>  对于两个事务 Session A、Session B，Session A 读取了一个字段，然后 Session B 更新了该字段。之后 Session A 再次读取同一个字段，值就不同了。那就意味着发生了不可重复读。</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="不可重复读示意图"></p>
<p>  我们在 Session B 中提交了几个 隐式事务 (注意是隐式事务，意味着语句结束事务就提交了)，这些事务都修改了 studentno 列为 1 的记录的列 name 的值，每次事物提交之后，如果 Session A 中的事务都可以查看到最新的值，这种现象也被称之为 不可重复读。</p>
</li>
<li><p><strong>幻读 (Phantom)</strong></p>
<p>  对于两个事务 Session A、Session B，Session A 从一个表中读取了一个字段，然后 Session B 在该表中插入了一些新的行。之后，如果 Session A 再次读取同一个表，就会多出几行。那就意味着发生了幻读。</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/myslq/%E5%B9%BB%E8%AF%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="幻读示意图"></p>
<p>  Session A 中的事务先根据条件 studentno &gt; 0 这个条件查询表 student，得到了列值为 ‘张三’ 的记录；之后 Session B 中提及哦啊了一个隐式事务，该事务向表 student 中插入了一条新纪录；之后 Session A 中的事务再根据相同的条件 studentno &gt; 0 查询表 student，得到的结果集中包含 Session B 中的事务新插入的那条记录，这种现象也被称之为幻读。我们把新插入的那些记录称之为 幻影记录。</p>
<p>  <strong>注意 1</strong>：</p>
<p>  如果 Session B 中删除了一些符合 studentno &gt; 0 的记录而不是插入新纪录，那 Session A 之后再根据 studentno &gt; 0 的条件读取的记录变少了，这种现象算不算幻读呢？这种现象不属于幻读，幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</p>
<p>  <strong>注意 2</strong>：</p>
<p>  那对于先前已经读到的记录，之后又读不到的情况呢？这相当于对每一条记录都发生了不可重复读的现象。幻读只是重点强调了读取到了之前读取没有获取到的记录。</p>
</li>
</ul>
<h4 id="SQL-中的四种隔离级别"><a href="#SQL-中的四种隔离级别" class="headerlink" title="SQL 中的四种隔离级别"></a>SQL 中的四种隔离级别</h4><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题按照严重性来排一下序 ：</p>
<blockquote>
<p>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p>
</blockquote>
<p>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。SQL 标准中设立了 4 个隔离级别：</p>
<ul>
<li><code>READ UNCOMMITTED</code>：读未提交，在该隔离级别，所有事物都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li>
<li><code>READ COMMITTED</code>：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别 (但不是 MySQL 默认的)。可以避免脏读，但不可重复读、幻读问题仍然存在。</li>
<li><code>REPEATABLE READ</code>：可重复读，事务 A 在读到一条数据之后，此时事务 B 对该数据进行了修改并提交，那么事务 A 再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这时 MySQL 的默认隔离级别。</li>
<li><code>SERIALIZABLE</code>：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其它事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li>
</ul>
<p>SQL 标准中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读可能性</th>
<th>不可重复读可能性</th>
<th>幻读可能性</th>
<th>加锁读</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCONMITED</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>READ COMMITED</td>
<td>NO</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
</tr>
</tbody></table>
<p>脏写怎么没涉及到？因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</p>
<p>不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4 种事务隔离级别与并发性能的关系如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="四种事务隔离级别与并发性能的关系.png"></p>
<h4 id="MySQL-支持的四种隔离级别"><a href="#MySQL-支持的四种隔离级别" class="headerlink" title="MySQL 支持的四种隔离级别"></a>MySQL 支持的四种隔离级别</h4><p>不同的数据库厂商对 SQL 标准中规定的四种隔离级别支持不一样。比如，Oracle 就只支持 <code>READ COMMITTED (默认隔离级别)</code> 和 <code>SERIALIZABLE 隔离级别</code>。MySQL 虽然支持 4 种隔离级别，但与 SQL 标准中所规定的各级隔离级别允许发生的问题却有些出入，MySQL 在 REPEATABLE READ 隔离级别下，是可以禁止幻读问题的发生的。</p>
<p>MySQL 的默认隔离级别为 REPEATABLE READ，可以手动修改一下事务的隔离级别。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 查看隔离级别，MySQL <span class="number">5.7</span><span class="number">.20</span> 的版本之前：</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;tx_isolation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name         <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> tx_isolation 					<span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"></span><br><span class="line"># MySQL <span class="number">5.7</span><span class="number">.20</span> 版本之后，引入 transaction_isolation 来替换 tx_isolation</span><br><span class="line"></span><br><span class="line"># 查看隔离级别，MySQL <span class="number">5.7</span><span class="number">.20</span> 的版本及之后：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name         <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> transaction_isolation <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"></span><br><span class="line"># 或者不同 MySQL 版本中都可以使用的：</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br></pre></td></tr></table></figure>

<h4 id="如何设置事务的隔离级别"><a href="#如何设置事务的隔离级别" class="headerlink" title="如何设置事务的隔离级别"></a>如何设置事务的隔离级别</h4><p>通过下面的语句修改事务的隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span> <span class="operator">|</span> SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;</span><br><span class="line"># 其中，隔离级别格式：</span><br><span class="line"><span class="operator">&gt;</span> READ UNCOMMITTED</span><br><span class="line"><span class="operator">&gt;</span> READ COMMITTED</span><br><span class="line"><span class="operator">&gt;</span> REPEATABLE READ</span><br><span class="line"><span class="operator">&gt;</span> SERIALIZABLE</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span> <span class="operator">|</span> SESSION] TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;隔离级别&#x27;</span></span><br><span class="line"># 其中，隔离级别格式：</span><br><span class="line"><span class="operator">&gt;</span> READ<span class="operator">-</span>UNCOMMITTED</span><br><span class="line"><span class="operator">&gt;</span> READ<span class="operator">-</span>COMMITTED</span><br><span class="line"><span class="operator">&gt;</span> REPEATABLE<span class="operator">-</span>READ</span><br><span class="line"><span class="operator">&gt;</span> SERIALIZABLE</span><br></pre></td></tr></table></figure>

<p>关于设置时使用 GLOBAL 或 SESSION 的影响：</p>
<ul>
<li><p>使用 GLOBAL 关键字 (在全局范围影响)：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line"># 或</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;SERIALIZABLE&#x27;</span></span><br></pre></td></tr></table></figure>

<p>  则：</p>
<ul>
<li>当前已经存在的会话无效</li>
<li>只对执行完该语句之后产生的会话起作用</li>
</ul>
</li>
<li><p>使用 SESSION 关键字 (在会话范围影响)：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line"># 或</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;SERIALIZABLE&#x27;</span></span><br></pre></td></tr></table></figure>

<p>  则：</p>
<ul>
<li>对当前会话的所有后续的事务有效</li>
<li>如果在事物之间执行，则对后续的事务有效</li>
<li>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</li>
</ul>
</li>
</ul>
<p>如果在服务器启动时想改变事务的默认隔离级别，可以修改启动参数 <code>TRANSACTION_ISOLATION</code> 的值。比如，在启动服务器时制定了 <code>TRANSACTION_ISOLATION = SERIALIZABLE</code>，那么事务的默认隔离级别就从原来的 <code>REPEATABLE-READ</code> 变成了 <code>SERIALIZABLE</code>。</p>
<h2 id="MySQL-事务日志"><a href="#MySQL-事务日志" class="headerlink" title="MySQL 事务日志"></a>MySQL 事务日志</h2><p>事务有 4 种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p>
<ul>
<li>事务的隔离性由锁机制实现。</li>
<li>而事务的原子性、一致性和持久性由事务的 redo 日志和 undo 日志来保证。<ul>
<li>REDO LOG 称为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li>
<li>UNDO LOG 称为回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li>
</ul>
</li>
</ul>
<p>有的 DBA 或许会认为 UNDO 是 REDO 的逆过程，其实不然。REDO 和 UNDO 都可以视为一种恢复操作，但是：</p>
<ul>
<li>REDO LOG：是存储引擎层 (innodb) 生成的日志，记录的是物理级别上的页修改操作，比如页号xxx、偏移量yyy写入了zzz数据。主要为了保证数据的可靠性；</li>
<li>UNDO LOG：是存储引擎层 (innodb) 生成的日志，记录的是逻辑操作日志，比如对某一行数据进行了 INSERT 语句操作，那么 UNDO LOG 就记录一条与之相反的 DELETE 操作。主要用于事务的回滚 (UNDO LOG 记录的是每个修改操作的逆操作) 和一致性非锁定读 (UNDO LOG 回滚行记录到某种特定的版本——MVCC，即多版本并发控制)。</li>
</ul>
<h3 id="redo-日志"><a href="#redo-日志" class="headerlink" title="redo 日志"></a>redo 日志</h3><p>InnoDB 存储引擎是以页为单位来管理存储空间的。在真正访问页面之前，需要把磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访问。所有的变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页会以一定的频率被刷入磁盘 (checkPoint 机制)，通过缓冲池来优化 CPU 和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p>
<h4 id="为什么需要-REDO-日志"><a href="#为什么需要-REDO-日志" class="headerlink" title="为什么需要 REDO 日志"></a>为什么需要 REDO 日志</h4><p>一方面，缓冲池可以帮助我们消除 CPU 和磁盘之间的鸿沟，checkpoint 机制可以保证数据的最终落盘，然而由于 checkpoint 并不是每次变更的时候就触发的，而是 master 线程隔一段时间去处理的。所以最坏的情况是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就丢失的，无法恢复。</p>
<p>另一方面，事务包含持久性的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库所做的更改也不能丢失。</p>
<p>那么如何保证这个持久性呢？一个简单的做法：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题：</p>
<ul>
<li><p>修改量与刷新磁盘工作量严重不成比例</p>
<p>  有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在 InnoDB 中是以页为单位来进行磁盘 IO 的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是 16KB 大小，只修改一个字节就要刷新 16KB 的数据到磁盘上显然是太小题大做了。</p>
</li>
<li><p>随机 IO 刷新较慢</p>
<p>  一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的 Buffer Pool 中的页面刷新到磁盘时，需要进行很多的随机 IO，随机 IO 比顺序 IO 要慢，尤其对于传统的机械硬盘来说。</p>
</li>
</ul>
<p>另一个解决的思路：我们只是想让已经提交了的事务对数据库中数据所作的修改永久有效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好。比如，某个事务将系统表空间中第 10 号页面中偏移量为 100 处的那个字节的值 1 改为 2。我们只需要记录一下：将第 0 号表空间的 10 号页面的偏移量为 100 处的值更新为 2。</p>
<p>InnoDB 引擎的事务采用了 WAL (Write-Ahead Logging)，这种技术的思想就是先写日志，在写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是 redo log。当发生宕机且数据未刷到磁盘的时候，可以通过 redo log 来回复，保证 ACID 中的 D，这就是 redo log 的作用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/redo%E6%A6%82%E5%BF%B5%E5%9B%BE.png" alt="redo概念图"></p>
<h4 id="REDO-日志的好处、特点"><a href="#REDO-日志的好处、特点" class="headerlink" title="REDO 日志的好处、特点"></a>REDO 日志的好处、特点</h4><p><strong>好处</strong>：</p>
<ul>
<li>redo 日志降低了刷盘频率</li>
<li>redo 日志占用的空间非常小</li>
</ul>
<p>存储表空间 ID、页号、偏移量以及需要更新的值，所需的存储空间是很小的，刷盘快。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>redo 日志是顺序写入磁盘的</li>
</ul>
<p>在执行事务的过程中，没执行一条语句，就可能产生若干条 redo 日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序 IO，效率比随机 IO 快。</p>
<ul>
<li>事务执行过程中，redo log 不断记录</li>
</ul>
<p>redo log 跟 bin log 的区别，redo log 是存储引擎层产生的，而 bin log 是数据库层产生的。假设一个事务，对表做 10 万行的记录插入，在这个过程中，一直不断往 redo log 顺序记录，而 bin log 不会记录，直到这个事务提交，才会一次写入到 bin log 文件中。</p>
<h4 id="redo-的组成"><a href="#redo-的组成" class="headerlink" title="redo 的组成"></a>redo 的组成</h4><p>Redo log 可以简单分为以下两个部分：</p>
<ul>
<li><p>重做日志的缓冲 (redo log buffer)，保存在内存中，是易失的。</p>
<p>  在服务器启动时就向操作系统申请了一大片称之为 redo log buffer 的连续内存空间，翻译成中文就是 redo 日志缓冲区。这片内存空间被划分成若干个连续的 redo log block。一个 redo log block 占用 512 字节大小。</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/logbuffer%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="logbuffer结构示意图"></p>
<p>  <strong>参数设置：innodb_log_buffer_size：</strong></p>
<p>  redo log buffer 大小，默认 16M，最大值时 4096M，最小值为 1M。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%innodb_log_buffer_size%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name          <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_log_buffer_size <span class="operator">|</span> <span class="number">16777216</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重做日志文件 (redo log file)，保存在硬盘中，是持久的。</p>
<p>  REDO 日志文件如图所示，其中的 ib_logfile0 和 ib_logfile1 即为 REDO 日志。</p>
</li>
</ul>
<h4 id="redo-的整体流程"><a href="#redo-的整体流程" class="headerlink" title="redo 的整体流程"></a>redo 的整体流程</h4><p>以一个更新事务为例，redo log 流转过程，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/%E6%9B%B4%E6%96%B0%E4%BA%8B%E5%8A%A1redolog.png" alt="更新事务"></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝</span><br><span class="line">第二步：生成一条重做日志并写入 redo log buffer，记录的是数据被修改后的值</span><br><span class="line">第三步：当事务 commit 时，将 redo log buffer 中的内容刷新到 redo log file，对 redo log file 采用追加写的方式</span><br><span class="line">第四步：定期将内存中修改的数据刷新到磁盘中</span><br></pre></td></tr></table></figure>

<blockquote>
<p>体会：</p>
<p>Write-Ahead Log (预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。</p>
</blockquote>
<h4 id="redo-log-的刷盘策略"><a href="#redo-log-的刷盘策略" class="headerlink" title="redo log 的刷盘策略"></a>redo log 的刷盘策略</h4><p>redo log 的写入并不是直接写入磁盘的，InnoDB 引擎会在写 redo log 的时候先写 redo log buffer，之后以一定的频率刷入到真正的 redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/redolog%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5.png" alt="redo刷盘"></p>
<p>注意，redo log buffer 刷盘到 redo log file 的过程并不是真正的刷到磁盘中去，只是刷入到文件系统缓存 (page cache) 中去 (这是现代操作系统为了提高文件写入效率做的一个优化)，真正的写入会交给系统自己来决定 (比如 page cache 足够大了)。那么对于 InnoDB 来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了 (虽然整个系统宕机的概率还是比较小的)。</p>
<p>针对这种情况，InnoDB 给出 <code>innodb_flush_log_at_trx_commit</code> 参数，该参数控制 commit 提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p>
<ul>
<li>设置为 0：表示每次事务提交时不进行刷盘操作。(系统默认 master thread 每隔 1s 进行一次重做日志的同步)</li>
<li>设置为 1：表示每次事务提交时都将进行同步，刷盘操作 (默认值)</li>
<li>设置为 2：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由 os 自己决定什么时候同步到磁盘文件。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_flush_log_at_trx_commit&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                  <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_flush_log_at_trx_commit <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+-------+</span></span><br></pre></td></tr></table></figure>

<p>另外，InnoDB 存储引擎有一个后台线程，每隔 1 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存 (page cache)，然后调用刷盘操作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/redolog%E5%88%B7%E7%9B%98-1.png" alt="redolog刷盘"></p>
<p>也就是说，一个没有提交事务的 redo log 记录，也可能会刷盘。因为在事务执行过程 redo log 记录是会写入 redo log buffer 中，这些 redo log 记录会被后台线程刷盘。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/redolog%E5%88%B7%E7%9B%98-2.png" alt="redolog刷盘"></p>
<p>除了后台线程每秒 1 次的轮训操作，还有一种情况，当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size (这个参数默认是 16M) 的一半的时候，后台线程会主动刷盘。</p>
<h4 id="不同刷盘策略演示"><a href="#不同刷盘策略演示" class="headerlink" title="不同刷盘策略演示"></a>不同刷盘策略演示</h4><ul>
<li><p>流程图</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/innodb_flush_log_at_trx_commit%E4%B8%BA1.png" alt="刷盘策略流程图"></p>
<blockquote>
<p>小结：innodb_flush_log_at_trx_commit&#x3D;1</p>
<p>为 1 时，只要事务提交成功，redo log 记录就一定在硬盘里，不会有任何数据丢失。</p>
<p>如果事务执行期间 MySQL 挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。可以保证 ACID 的 D，数据绝对不会丢失，但是效率最差的。</p>
<p>建议使用默认值，虽然操作系统宕机的概率理论小于数据库宕机的概率，但是一般既然使用了事务，那么数据的安全相对来说更重要些。</p>
</blockquote>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/innodb_flush_log_at_trx_commit%E4%B8%BA2.png" alt="innodb_flush_log_at_trx_commit=2"></p>
<blockquote>
<p>小结：innodb_flush_log_at_trx_commit&#x3D;2</p>
<p>为 2 时，只要事务提交成功，redo log buffer 中的内容只写入文件系统缓存 (page cache)。</p>
<p>如果仅仅只是 MySQL 挂了不会有任何数据丢失，但是操作系统宕机可能会有 1 秒数据的丢失，这种情况下无法满足 ACID 中的 D。但是数值 2 肯定是效率最高的。</p>
</blockquote>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../img/mysql/innodb_flush_log_at_trx_commit%E4%B8%BA0.png" alt="innodb_flush_log_at_trx_commit为0"></p>
<blockquote>
<p>小结：innodb_flush_log_at_trx_commit&#x3D;0</p>
<p>为 0 时，master thread 中每 1 秒进行一次重做日志的 fsync 操作，因此实例 crash 最多丢失 1 秒钟内的事务。(master thread 是负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性)</p>
<p>数值 0 的话，是一种折中的做法，它的 IO 效率理论是高于 1 的，低于 2 的，这种策略也有丢失数据的风险，也无法保证 D。</p>
</blockquote>
</li>
</ul>
<h4 id="写入-redo-log-buffer-过程"><a href="#写入-redo-log-buffer-过程" class="headerlink" title="写入 redo log buffer 过程"></a>写入 redo log buffer 过程</h4><p>**1. **</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/28/kafka/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Kafka</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/25/mysql-basic/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL 基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/10/25/mysql-basic/" title="MySQL 基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-25</div><div class="title">MySQL 基础</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">用户与权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">用户管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BB%E5%BD%95-MySQL-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">登录 MySQL 服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7"><span class="toc-number">1.1.2.</span> <span class="toc-text">创建用户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7"><span class="toc-number">1.1.3.</span> <span class="toc-text">修改用户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7"><span class="toc-number">1.1.4.</span> <span class="toc-text">删除用户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81"><span class="toc-number">1.1.5.</span> <span class="toc-text">设置当前用户密码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%85%B6%E5%AE%83%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81"><span class="toc-number">1.1.6.</span> <span class="toc-text">修改其它用户密码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-8-%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.7.</span> <span class="toc-text">MySQL 8 密码管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E5%88%97%E8%A1%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">权限列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%88%E4%BA%88%E6%9D%83%E9%99%90%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">1.2.2.</span> <span class="toc-text">授予权限的原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%88%E4%BA%88%E6%9D%83%E9%99%90"><span class="toc-number">1.2.3.</span> <span class="toc-text">授予权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9D%83%E9%99%90"><span class="toc-number">1.2.4.</span> <span class="toc-text">查看权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E5%9B%9E%E6%9D%83%E9%99%90"><span class="toc-number">1.2.5.</span> <span class="toc-text">收回权限</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">权限表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">访问控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%92%E8%89%B2%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">角色管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%92%E8%89%B2"><span class="toc-number">1.5.1.</span> <span class="toc-text">创建角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E8%A7%92%E8%89%B2%E8%B5%8B%E4%BA%88%E6%9D%83%E9%99%90"><span class="toc-number">1.5.2.</span> <span class="toc-text">给角色赋予权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%A7%92%E8%89%B2%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-number">1.5.3.</span> <span class="toc-text">查看角色的权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E8%A7%92%E8%89%B2%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-number">1.5.4.</span> <span class="toc-text">回收角色的权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A7%92%E8%89%B2"><span class="toc-number">1.5.5.</span> <span class="toc-text">删除角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E7%94%A8%E6%88%B7%E8%B5%8B%E4%BA%88%E8%A7%92%E8%89%B2"><span class="toc-number">1.5.6.</span> <span class="toc-text">给用户赋予角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB%E8%A7%92%E8%89%B2"><span class="toc-number">1.5.7.</span> <span class="toc-text">激活角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E7%94%A8%E6%88%B7%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-number">1.5.8.</span> <span class="toc-text">撤销用户的角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%BC%BA%E5%88%B6%E8%A7%92%E8%89%B2-mandatory-role"><span class="toc-number">1.5.9.</span> <span class="toc-text">设置强制角色 (mandatory role)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.5.10.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">逻辑架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%89%96%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">逻辑架构剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82"><span class="toc-number">2.1.1.</span> <span class="toc-text">服务器处理客户端请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Connectors"><span class="toc-number">2.1.2.</span> <span class="toc-text">Connectors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E5%B1%82%EF%BC%9A%E8%BF%9E%E6%8E%A5%E5%B1%82"><span class="toc-number">2.1.3.</span> <span class="toc-text">第一层：连接层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%B1%82%EF%BC%9A%E6%9C%8D%E5%8A%A1%E5%B1%82"><span class="toc-number">2.1.4.</span> <span class="toc-text">第二层：服务层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E5%B1%82%EF%BC%9A%E5%BC%95%E6%93%8E%E5%B1%82"><span class="toc-number">2.1.5.</span> <span class="toc-text">第三层：引擎层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%B1%82"><span class="toc-number">2.1.6.</span> <span class="toc-text">存储层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">2.1.7.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">SQL 执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-%E4%B8%AD%E7%9A%84-SQL-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">MySQL 中的 SQL 执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-8-%E4%B8%AD-SQL-%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.2.</span> <span class="toc-text">MySQL 8 中 SQL 执行原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%86%B2%E6%B1%A0-buffer-pool"><span class="toc-number">2.3.</span> <span class="toc-text">数据库缓冲池 (buffer pool)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0-vs-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">2.3.1.</span> <span class="toc-text">缓冲池 vs 查询缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">2.3.2.</span> <span class="toc-text">缓冲池如何读取数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-x2F-%E8%AE%BE%E7%BD%AE%E7%BC%93%E5%86%B2%E6%B1%A0%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.3.3.</span> <span class="toc-text">查看&#x2F;设置缓冲池的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA-Buffer-Pool-%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.3.4.</span> <span class="toc-text">多个 Buffer Pool 实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%B3%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.5.</span> <span class="toc-text">引申问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.1.</span> <span class="toc-text">查看存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.2.</span> <span class="toc-text">设置系统默认的存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.3.</span> <span class="toc-text">设置表的存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%97%B6%E6%8C%87%E5%AE%9A%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.3.1.</span> <span class="toc-text">创建表时指定存储引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.3.2.</span> <span class="toc-text">修改表的存储引擎</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.4.</span> <span class="toc-text">引擎介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB-%E5%BC%95%E6%93%8E%EF%BC%9A%E5%85%B7%E5%A4%87%E5%A4%96%E9%94%AE%E6%94%AF%E6%8C%81%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.4.1.</span> <span class="toc-text">InnoDB 引擎：具备外键支持功能的事务存储引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyISAM-%E5%BC%95%E6%93%8E%EF%BC%9A%E4%B8%BB%E8%A6%81%E7%9A%84%E9%9D%9E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.4.2.</span> <span class="toc-text">MyISAM 引擎：主要的非事务处理存储引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Archive-%E5%BC%95%E6%93%8E%EF%BC%9A%E7%94%A8%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E6%A1%A3"><span class="toc-number">3.4.3.</span> <span class="toc-text">Archive 引擎：用于数据存档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Blackhole-%E5%BC%95%E6%93%8E%EF%BC%9A%E4%B8%A2%E5%BC%83%E5%86%99%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%AF%BB%E6%93%8D%E4%BD%9C%E4%BC%9A%E8%BF%94%E5%9B%9E%E7%A9%BA%E5%86%85%E5%AE%B9"><span class="toc-number">3.4.4.</span> <span class="toc-text">Blackhole 引擎：丢弃写操作，读操作会返回空内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSV-%E5%BC%95%E6%93%8E%EF%BC%9A%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E4%BB%A5%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94%E5%90%84%E4%B8%AA%E6%95%B0%E6%8D%AE%E9%A1%B9"><span class="toc-number">3.4.5.</span> <span class="toc-text">CSV 引擎：存储数据时，以逗号分隔各个数据项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Memory-%E5%BC%95%E6%93%8E%EF%BC%9A%E7%BD%AE%E4%BA%8E%E5%86%85%E5%AD%98%E7%9A%84%E8%A1%A8"><span class="toc-number">3.4.6.</span> <span class="toc-text">Memory 引擎：置于内存的表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Federated-%E5%BC%95%E6%93%8E%EF%BC%9A%E8%AE%BF%E9%97%AE%E8%BF%9C%E7%A8%8B%E8%A1%A8"><span class="toc-number">3.4.7.</span> <span class="toc-text">Federated 引擎：访问远程表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Merge-%E5%BC%95%E6%93%8E%EF%BC%9A%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AA-MyISAM-%E8%A1%A8%E6%9E%84%E6%88%90%E7%9A%84%E8%A1%A8%E9%9B%86%E5%90%88"><span class="toc-number">3.4.8.</span> <span class="toc-text">Merge 引擎：管理多个 MyISAM 表构成的表集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NDB-%E5%BC%95%E6%93%8E%EF%BC%9AMySQL-%E9%9B%86%E7%BE%A4%E4%B8%93%E7%94%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.4.9.</span> <span class="toc-text">NDB 引擎：MySQL 集群专用存储引擎</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM-%E5%92%8C-InnoDB"><span class="toc-number">3.5.</span> <span class="toc-text">MyISAM 和 InnoDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E3%80%81%E6%B7%98%E5%AE%9D%E7%94%A8%E5%93%AA%E4%B8%AA"><span class="toc-number">3.6.</span> <span class="toc-text">阿里巴巴、淘宝用哪个</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">3.7.</span> <span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB-%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">3.7.1.</span> <span class="toc-text">InnoDB 表的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB-%E5%92%8C-ACID-%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.7.2.</span> <span class="toc-text">InnoDB 和 ACID 模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB-%E6%9E%B6%E6%9E%84"><span class="toc-number">3.7.3.</span> <span class="toc-text">InnoDB 架构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">索引的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">4.1.</span> <span class="toc-text">为什么使用索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">索引及其优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%A6%82%E8%BF%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">索引概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">4.2.2.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">4.2.3.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%A8%E6%BC%94"><span class="toc-number">4.3.</span> <span class="toc-text">InnoDB 中索引的推演</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B9%8B%E5%89%8D%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">4.3.1.</span> <span class="toc-text">索引之前的查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%B4%A2%E5%BC%95"><span class="toc-number">4.3.2.</span> <span class="toc-text">设计索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5"><span class="toc-number">4.3.3.</span> <span class="toc-text">常见索引概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB-%E7%9A%84-B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.3.4.</span> <span class="toc-text">InnoDB 的 B+ 树索引的注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM-%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="toc-number">4.4.</span> <span class="toc-text">MyISAM 中的索引方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MyISAM-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.4.1.</span> <span class="toc-text">MyISAM 索引的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyISAM-%E4%B8%8E-InnoDB-%E5%AF%B9%E6%AF%94"><span class="toc-number">4.4.2.</span> <span class="toc-text">MyISAM 与 InnoDB 对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">4.5.</span> <span class="toc-text">索引的代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E6%8B%A9%E7%9A%84%E5%90%88%E7%90%86%E6%80%A7"><span class="toc-number">4.6.</span> <span class="toc-text">MySQL 数据结构选择的合理性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E8%A1%A8%E9%81%8D%E5%8E%86"><span class="toc-number">4.6.1.</span> <span class="toc-text">全表遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash-%E7%BB%93%E6%9E%84"><span class="toc-number">4.6.2.</span> <span class="toc-text">Hash 结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">4.6.3.</span> <span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AVL-%E6%A0%91"><span class="toc-number">4.6.4.</span> <span class="toc-text">AVL 树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BTree"><span class="toc-number">4.6.5.</span> <span class="toc-text">BTree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Tree"><span class="toc-number">4.6.6.</span> <span class="toc-text">B + Tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#R-%E6%A0%91"><span class="toc-number">4.6.7.</span> <span class="toc-text">R 树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">4.6.8.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">InnoDB 数据存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A%E9%A1%B5"><span class="toc-number">5.1.</span> <span class="toc-text">数据库的存储结构：页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E4%B8%8E%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D%EF%BC%9A%E9%A1%B5"><span class="toc-number">5.1.1.</span> <span class="toc-text">磁盘与内存交互基本单位：页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.2.</span> <span class="toc-text">页结构概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">5.1.3.</span> <span class="toc-text">页的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E7%9A%84%E4%B8%8A%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.4.</span> <span class="toc-text">页的上层结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">页的内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#File-Header-%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8-%E5%92%8C-File-Trailer-%E6%96%87%E4%BB%B6%E5%B0%BE%E9%83%A8"><span class="toc-number">5.2.1.</span> <span class="toc-text">File Header (文件头部) 和 File Trailer (文件尾部)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#User-Records-%E7%94%A8%E6%88%B7%E8%AE%B0%E5%BD%95-%E3%80%81%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%AE%B0%E5%BD%95%E3%80%81Free-Space-%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4"><span class="toc-number">5.2.2.</span> <span class="toc-text">User Records (用户记录)、最大最小记录、Free Space (空闲空间)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Page-Directory-%E9%A1%B5%E7%9B%AE%E5%BD%95-%E3%80%81Page-Header-%E9%A1%B5%E9%9D%A2%E5%A4%B4%E9%83%A8"><span class="toc-number">5.2.3.</span> <span class="toc-text">Page Directory (页目录)、Page Header (页面头部)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B-B-%E6%A0%91%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.2.4.</span> <span class="toc-text">从数据页的角度看 B+ 树如何查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E8%A1%8C%E6%A0%BC%E5%BC%8F-%E6%88%96%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">InnoDB 行格式 (或记录格式)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">5.3.1.</span> <span class="toc-text">指定行格式的语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#COMPACT-%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.3.2.</span> <span class="toc-text">COMPACT 行格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dynamic-%E5%92%8C-Compressed-%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.3.3.</span> <span class="toc-text">Dynamic 和 Compressed 行格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redundant-%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.3.4.</span> <span class="toc-text">Redundant 行格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E3%80%81%E6%AE%B5%E4%B8%8E%E7%A2%8E%E7%89%87%E5%8C%BA"><span class="toc-number">5.4.</span> <span class="toc-text">区、段与碎片区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8C%BA%EF%BC%9F"><span class="toc-number">5.4.1.</span> <span class="toc-text">为什么要有区？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E6%AE%B5%EF%BC%9F"><span class="toc-number">5.4.2.</span> <span class="toc-text">为什么要有段？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%A2%8E%E7%89%87%E5%8C%BA%EF%BC%9F"><span class="toc-number">5.4.3.</span> <span class="toc-text">为什么要有碎片区？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">5.4.4.</span> <span class="toc-text">区的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">5.5.</span> <span class="toc-text">表空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">5.5.1.</span> <span class="toc-text">独立表空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">5.5.2.</span> <span class="toc-text">系统表空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%BD%95%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">5.6.</span> <span class="toc-text">附录：数据页加载的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%AF%BB%E5%8F%96"><span class="toc-number">5.6.1.</span> <span class="toc-text">内存读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%8F%96"><span class="toc-number">5.6.2.</span> <span class="toc-text">随机读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%8F%96"><span class="toc-number">5.6.3.</span> <span class="toc-text">顺序读取</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">6.</span> <span class="toc-text">索引的创建与设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%94%9F%E5%91%BD%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">6.1.</span> <span class="toc-text">索引的生命与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">6.1.1.</span> <span class="toc-text">索引的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">6.1.2.</span> <span class="toc-text">创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">6.1.3.</span> <span class="toc-text">删除索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-8-0-%E7%B4%A2%E5%BC%95%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text">MySQL 8.0 索引新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E9%99%8D%E5%BA%8F%E7%B4%A2%E5%BC%95"><span class="toc-number">6.2.1.</span> <span class="toc-text">支持降序索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E7%B4%A2%E5%BC%95"><span class="toc-number">6.2.2.</span> <span class="toc-text">隐藏索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">6.3.</span> <span class="toc-text">索引的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87"><span class="toc-number">6.3.1.</span> <span class="toc-text">数据准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">6.3.2.</span> <span class="toc-text">哪些情况适合创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">6.3.3.</span> <span class="toc-text">限制索引的数目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">6.3.4.</span> <span class="toc-text">哪些情况不适合创建索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">6.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">性能分析工具的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="toc-number">7.1.</span> <span class="toc-text">数据库服务器的优化步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">查看系统性能参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1-SQL-%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%88%90%E6%9C%AC%EF%BC%9Alast-query-cost"><span class="toc-number">7.3.</span> <span class="toc-text">统计 SQL 的查询成本：last_query_cost</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E6%89%A7%E8%A1%8C%E6%85%A2%E7%9A%84-SQL%EF%BC%9A%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">7.4.</span> <span class="toc-text">定位执行慢的 SQL：慢查询日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%8F%82%E6%95%B0"><span class="toc-number">7.4.1.</span> <span class="toc-text">开启慢查询日志参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-long-query-time-%E9%98%88%E5%80%BC"><span class="toc-number">7.4.2.</span> <span class="toc-text">修改 long_query_time 阈值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">7.4.3.</span> <span class="toc-text">案例演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%9Amysqldumpslow"><span class="toc-number">7.4.4.</span> <span class="toc-text">慢查询日志分析工具：mysqldumpslow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">7.4.5.</span> <span class="toc-text">关闭慢查询日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">7.4.6.</span> <span class="toc-text">删除慢查询日志</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-SQL-%E6%89%A7%E8%A1%8C%E6%88%90%E6%9C%AC%EF%BC%9ASHOW-PROFILE"><span class="toc-number">7.5.</span> <span class="toc-text">查看 SQL 执行成本：SHOW PROFILE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%EF%BC%9AEXPLAIN"><span class="toc-number">7.6.</span> <span class="toc-text">分析查询语句：EXPLAIN</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">7.6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">7.6.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-1"><span class="toc-number">7.6.3.</span> <span class="toc-text">数据准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EXPLAIN-%E5%90%84%E5%88%97%E4%BD%9C%E7%94%A8"><span class="toc-number">7.6.4.</span> <span class="toc-text">EXPLAIN 各列作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXPLAIN-%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BD%BF%E7%94%A8"><span class="toc-number">7.7.</span> <span class="toc-text">EXPLAIN 的进一步使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EXPLAIN-%E5%9B%9B%E7%A7%8D%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-number">7.7.1.</span> <span class="toc-text">EXPLAIN 四种输出格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SHOW-WARNINGS-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.7.2.</span> <span class="toc-text">SHOW WARNINGS 的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96%E5%99%A8%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%9Atrace"><span class="toc-number">7.8.</span> <span class="toc-text">分析优化器执行计划：trace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E7%9B%91%E6%8E%A7%E5%88%86%E6%9E%90%E8%A7%86%E5%9B%BE-sys-schema"><span class="toc-number">7.9.</span> <span class="toc-text">MySQL 监控分析视图 - sys schema</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Sys-schema-%E8%A7%86%E5%9B%BE%E6%91%98%E8%A6%81"><span class="toc-number">7.9.1.</span> <span class="toc-text">Sys schema 视图摘要</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sys-schema-%E8%A7%86%E5%9B%BE%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.9.2.</span> <span class="toc-text">Sys schema 视图使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">索引优化与查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-2"><span class="toc-number">8.1.</span> <span class="toc-text">数据准备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E8%A1%A8"><span class="toc-number">8.1.1.</span> <span class="toc-text">建表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">8.1.2.</span> <span class="toc-text">设置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">8.1.3.</span> <span class="toc-text">创建函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">8.1.4.</span> <span class="toc-text">创建存储过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">8.1.5.</span> <span class="toc-text">调用存储过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9F%90%E8%A1%A8%E4%B8%8A%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">8.1.6.</span> <span class="toc-text">删除某表上的索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%A1%88%E4%BE%8B"><span class="toc-number">8.2.</span> <span class="toc-text">索引失效案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%80%BC%E5%8C%B9%E9%85%8D"><span class="toc-number">8.2.1.</span> <span class="toc-text">全值匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="toc-number">8.2.2.</span> <span class="toc-text">最佳左前缀法则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E6%8F%92%E5%85%A5%E9%A1%BA%E5%BA%8F"><span class="toc-number">8.2.3.</span> <span class="toc-text">主键插入顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%88%B0%E5%80%BC%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">8.2.4.</span> <span class="toc-text">计算、函数、类型转换到值索引失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%88%B0%E5%80%BC%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">8.2.5.</span> <span class="toc-text">类型转换到值索引失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E6%9D%A1%E4%BB%B6%E5%8F%B3%E8%BE%B9%E7%9A%84%E5%88%97%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">8.2.6.</span> <span class="toc-text">范围条件右边的列索引失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E7%AD%89%E4%BA%8E-x3D-%E6%88%96-lt-gt-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">8.2.7.</span> <span class="toc-text">不等于 (!&#x3D; 或 &lt;&gt;) 索引失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IS-NULL-%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%8CIS-NOT-NULL-%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">8.2.8.</span> <span class="toc-text">IS NULL 可以使用索引，IS NOT NULL 无法使用索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#like-%E4%BB%A5%E9%80%9A%E9%85%8D%E7%AC%A6-%E5%BC%80%E5%A4%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">8.2.9.</span> <span class="toc-text">like 以通配符 % 开头索引失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OR-%E5%89%8D%E5%90%8E%E5%AD%98%E5%9C%A8%E9%9D%9E%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%97%EF%BC%8C%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">8.2.10.</span> <span class="toc-text">OR 前后存在非索引的列，索引失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BB%9F%E4%B8%80%E4%BD%BF%E7%94%A8-utf8mb4"><span class="toc-number">8.2.11.</span> <span class="toc-text">数据库和表的字符集统一使用 utf8mb4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AE"><span class="toc-number">8.2.12.</span> <span class="toc-text">建议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">8.3.</span> <span class="toc-text">关联查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-3"><span class="toc-number">8.3.1.</span> <span class="toc-text">数据准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">8.3.2.</span> <span class="toc-text">采用左外连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="toc-number">8.3.3.</span> <span class="toc-text">采用内连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JOIN-%E8%AF%AD%E5%8F%A5%E5%8E%9F%E7%90%86"><span class="toc-number">8.3.4.</span> <span class="toc-text">JOIN 语句原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-number">8.3.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">8.4.</span> <span class="toc-text">子查询优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-number">8.5.</span> <span class="toc-text">排序优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GROUP-BY-%E4%BC%98%E5%8C%96"><span class="toc-number">8.6.</span> <span class="toc-text">GROUP BY 优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.7.</span> <span class="toc-text">优化分页查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">8.8.</span> <span class="toc-text">优先考虑覆盖索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">8.8.1.</span> <span class="toc-text">什么是覆盖索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%A9%E5%BC%8A"><span class="toc-number">8.8.2.</span> <span class="toc-text">覆盖索引的利弊</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">8.9.</span> <span class="toc-text">如何给字符串添加索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">8.10.</span> <span class="toc-text">索引下推</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%89%8D%E5%90%8E%E5%AF%B9%E6%AF%94"><span class="toc-number">8.10.1.</span> <span class="toc-text">使用前后对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ICP-%E7%9A%84%E5%BC%80%E5%90%AF-x2F-%E5%85%B3%E9%97%AD"><span class="toc-number">8.10.2.</span> <span class="toc-text">ICP 的开启&#x2F;关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ICP-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">8.10.3.</span> <span class="toc-text">ICP 使用案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%AD-ICP-%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">8.10.4.</span> <span class="toc-text">开启和关闭 ICP 的性能对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ICP-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">8.10.5.</span> <span class="toc-text">ICP 的使用条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">8.11.</span> <span class="toc-text">其他查询优化策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EXISTS-%E5%92%8C-IN-%E7%9A%84%E5%8C%BA%E5%88%86"><span class="toc-number">8.11.1.</span> <span class="toc-text">EXISTS 和 IN 的区分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#COUNT-%E4%B8%8E-COUNT-%E5%85%B7%E4%BD%93%E5%AD%97%E6%AE%B5-%E6%95%88%E7%8E%87"><span class="toc-number">8.11.2.</span> <span class="toc-text">COUNT(*) 与 COUNT(具体字段) 效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-SELECT"><span class="toc-number">8.11.3.</span> <span class="toc-text">关于 SELECT(*)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LIMIT-1-%E5%AF%B9%E4%BC%98%E5%8C%96%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">8.11.4.</span> <span class="toc-text">LIMIT 1 对优化的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%BD%BF%E7%94%A8-COMMIT"><span class="toc-number">8.11.5.</span> <span class="toc-text">多使用 COMMIT</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%98%E5%AE%9D%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%9A%84%EF%BC%9F"><span class="toc-number">8.12.</span> <span class="toc-text">淘宝数据库，主键如何设计的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E-ID-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.12.1.</span> <span class="toc-text">自增 ID 的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%AD%97%E6%AE%B5%E5%81%9A%E4%B8%BB%E9%94%AE"><span class="toc-number">8.12.2.</span> <span class="toc-text">业务字段做主键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%98%E5%AE%9D%E7%9A%84%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.12.3.</span> <span class="toc-text">淘宝的主键设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E7%9A%84%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.12.4.</span> <span class="toc-text">推荐的主键设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-number">9.</span> <span class="toc-text">数据库的设计规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.1.</span> <span class="toc-text">为什么需要数据库设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E5%BC%8F%E7%AE%80%E4%BB%8B"><span class="toc-number">9.2.1.</span> <span class="toc-text">范式简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E5%BC%8F%E9%83%BD%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B"><span class="toc-number">9.2.2.</span> <span class="toc-text">范式都包括哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%AE%E5%92%8C%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">9.2.3.</span> <span class="toc-text">键和相关属性的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F-1st-NF"><span class="toc-number">9.2.4.</span> <span class="toc-text">第一范式 (1st NF)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F-2nd-NF"><span class="toc-number">9.2.5.</span> <span class="toc-text">第二范式 (2nd NF)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F-3rd-NF"><span class="toc-number">9.2.6.</span> <span class="toc-text">第三范式 (3rd NF)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="toc-number">9.2.7.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%8C%83%E5%BC%8F%E5%8C%96"><span class="toc-number">9.3.</span> <span class="toc-text">反范式化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">9.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-number">9.3.2.</span> <span class="toc-text">应用举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E8%8C%83%E5%BC%8F%E7%9A%84%E6%96%B0%E9%97%AE%E9%A2%98"><span class="toc-number">9.3.3.</span> <span class="toc-text">反范式的新问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E8%8C%83%E5%BC%8F%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.3.4.</span> <span class="toc-text">反范式的适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BCNF-%E5%B7%B4%E6%96%AF%E8%8C%83%E5%BC%8F"><span class="toc-number">9.4.</span> <span class="toc-text">BCNF (巴斯范式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F"><span class="toc-number">9.5.</span> <span class="toc-text">第四范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%8C%83%E5%BC%8F"><span class="toc-number">9.6.</span> <span class="toc-text">第五范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ER-%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.7.</span> <span class="toc-text">ER 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ER-%E6%A8%A1%E5%9E%8B%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E8%A6%81%E7%B4%A0%EF%BC%9F"><span class="toc-number">9.7.1.</span> <span class="toc-text">ER 模型包括哪些要素？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.7.2.</span> <span class="toc-text">关系的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E6%A8%A1%E5%88%86%E6%9E%90"><span class="toc-number">9.7.3.</span> <span class="toc-text">建模分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ER-%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%86%E5%8C%96"><span class="toc-number">9.7.4.</span> <span class="toc-text">ER 模型的细化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ER-%E6%A8%A1%E5%9E%8B%E5%9B%BE%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">9.7.5.</span> <span class="toc-text">ER 模型图转换成数据表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">9.8.</span> <span class="toc-text">数据表的设计原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1%E7%BC%96%E5%86%99%E5%BB%BA%E8%AE%AE"><span class="toc-number">9.9.</span> <span class="toc-text">数据库对象编写建议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%BA%93"><span class="toc-number">9.9.1.</span> <span class="toc-text">关于库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%A1%A8%E3%80%81%E5%88%97"><span class="toc-number">9.9.2.</span> <span class="toc-text">关于表、列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95"><span class="toc-number">9.9.3.</span> <span class="toc-text">关于索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL-%E7%BC%96%E5%86%99"><span class="toc-number">9.9.4.</span> <span class="toc-text">SQL 编写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E5%AE%83%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5"><span class="toc-number">10.</span> <span class="toc-text">数据库其它调优策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98%E7%9A%84%E6%8E%AA%E6%96%BD"><span class="toc-number">10.1.</span> <span class="toc-text">数据库调优的措施</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">10.1.1.</span> <span class="toc-text">调优的目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E8%B0%83%E4%BC%98%E9%97%AE%E9%A2%98"><span class="toc-number">10.1.2.</span> <span class="toc-text">如何定位调优问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E7%9A%84%E7%BB%B4%E5%BA%A6%E5%92%8C%E6%AD%A5%E9%AA%A4"><span class="toc-number">10.1.3.</span> <span class="toc-text">调优的维度和步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-MySQL-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">10.2.</span> <span class="toc-text">优化 MySQL 服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E4%BB%B6"><span class="toc-number">10.2.1.</span> <span class="toc-text">优化服务器硬件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-MySQL-%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">10.2.2.</span> <span class="toc-text">优化 MySQL 的参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84"><span class="toc-number">10.3.</span> <span class="toc-text">优化数据库结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%86%E5%88%86%E8%A1%A8%EF%BC%9A%E5%86%B7%E7%83%AD%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB"><span class="toc-number">10.3.1.</span> <span class="toc-text">拆分表：冷热数据分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E4%B8%AD%E9%97%B4%E8%A1%A8"><span class="toc-number">10.3.2.</span> <span class="toc-text">增加中间表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E5%86%97%E4%BD%99%E5%AD%97%E6%AE%B5"><span class="toc-number">10.3.3.</span> <span class="toc-text">增加冗余字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%8F%92%E5%85%A5%E8%AE%B0%E5%BD%95%E7%9A%84%E9%80%9F%E5%BA%A6"><span class="toc-number">10.3.4.</span> <span class="toc-text">优化插入记录的速度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%9E%E7%A9%BA%E7%BA%A6%E6%9D%9F"><span class="toc-number">10.3.5.</span> <span class="toc-text">使用非空约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E8%A1%A8%E3%80%81%E6%A3%80%E6%9F%A5%E8%A1%A8%E4%B8%8E%E4%BC%98%E5%8C%96%E8%A1%A8"><span class="toc-number">10.3.6.</span> <span class="toc-text">分析表、检查表与优化表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-6"><span class="toc-number">10.3.7.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="toc-number">10.4.</span> <span class="toc-text">大表优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E5%AE%9A%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-number">10.4.1.</span> <span class="toc-text">限定查询的范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB-x2F-%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">10.4.2.</span> <span class="toc-text">读&#x2F;写分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86"><span class="toc-number">10.4.3.</span> <span class="toc-text">垂直拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86"><span class="toc-number">10.4.4.</span> <span class="toc-text">水平拆分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5"><span class="toc-number">10.5.</span> <span class="toc-text">其它调优策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%AD%E5%8F%A5%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86"><span class="toc-number">10.5.1.</span> <span class="toc-text">服务器语句超时处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%85%A8%E5%B1%80%E9%80%9A%E7%94%A8%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">10.5.2.</span> <span class="toc-text">创建全局通用表空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-8-0-%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E9%9A%90%E8%97%8F%E7%B4%A2%E5%BC%95%E5%AF%B9%E8%B0%83%E4%BC%98%E7%9A%84%E5%B8%AE%E5%8A%A9"><span class="toc-number">10.5.3.</span> <span class="toc-text">MySQL 8.0 新特性：隐藏索引对调优的帮助</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">11.</span> <span class="toc-text">事务基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">11.1.</span> <span class="toc-text">数据库事务概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5"><span class="toc-number">11.1.1.</span> <span class="toc-text">存储引擎支持情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">11.1.2.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E7%89%A9%E7%9A%84-ACID-%E7%89%B9%E6%80%A7"><span class="toc-number">11.1.3.</span> <span class="toc-text">事物的 ACID 特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">11.1.4.</span> <span class="toc-text">事务的状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8B%E7%89%A9"><span class="toc-number">11.2.</span> <span class="toc-text">如何使用事物</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">11.2.1.</span> <span class="toc-text">显式事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">11.2.2.</span> <span class="toc-text">隐式事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">11.2.3.</span> <span class="toc-text">隐式提交数据的情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">11.3.</span> <span class="toc-text">事务隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-4"><span class="toc-number">11.3.1.</span> <span class="toc-text">数据准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">11.3.2.</span> <span class="toc-text">数据并发问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL-%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">11.3.3.</span> <span class="toc-text">SQL 中的四种隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-%E6%94%AF%E6%8C%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">11.3.4.</span> <span class="toc-text">MySQL 支持的四种隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">11.3.5.</span> <span class="toc-text">如何设置事务的隔离级别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="toc-number">12.</span> <span class="toc-text">MySQL 事务日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-%E6%97%A5%E5%BF%97"><span class="toc-number">12.1.</span> <span class="toc-text">redo 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-REDO-%E6%97%A5%E5%BF%97"><span class="toc-number">12.1.1.</span> <span class="toc-text">为什么需要 REDO 日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#REDO-%E6%97%A5%E5%BF%97%E7%9A%84%E5%A5%BD%E5%A4%84%E3%80%81%E7%89%B9%E7%82%B9"><span class="toc-number">12.1.2.</span> <span class="toc-text">REDO 日志的好处、特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">12.1.3.</span> <span class="toc-text">redo 的组成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">12.1.4.</span> <span class="toc-text">redo 的整体流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log-%E7%9A%84%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5"><span class="toc-number">12.1.5.</span> <span class="toc-text">redo log 的刷盘策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5%E6%BC%94%E7%A4%BA"><span class="toc-number">12.1.6.</span> <span class="toc-text">不同刷盘策略演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%85%A5-redo-log-buffer-%E8%BF%87%E7%A8%8B"><span class="toc-number">12.1.7.</span> <span class="toc-text">写入 redo log buffer 过程</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Zhang Jian</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="xxxx"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>