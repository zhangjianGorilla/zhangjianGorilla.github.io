<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring</title>
      <link href="/2022/12/12/Spring/"/>
      <url>/2022/12/12/Spring/</url>
      
        <content type="html"><![CDATA[<p><strong>控制反转 Ioc  , 面向切面 Aop</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--bean就是java对象 , 由Spring创建和管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gorilla.pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于注解开发"><a href="#基于注解开发" class="headerlink" title="基于注解开发"></a>基于注解开发</h3><blockquote><p>@Component</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;user&quot;)</span></span><br><span class="line"><span class="comment">//相当于配置文件中的&lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    <span class="comment">//@Value(&quot;zhangsan&quot;)</span></span><br><span class="line">    <span class="comment">//public String name;</span></span><br><span class="line">    <span class="comment">//@Value(&quot;zhangsan&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Component三个衍生注解</strong></p><blockquote><p>@Controller : web层</p></blockquote><blockquote><p>@Service : service层</p></blockquote><blockquote><p>@Repository : dao层</p></blockquote><p>加上这些注解，就相当于这个类交给了Spring管理装配了</p><p><strong>自动装配</strong></p><p>@Autowired : 根据byType自动装配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//允许字段为空，默认是true，不允许</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br></pre></td></tr></table></figure><p>@Qualifier : 不能单独使用，搭配@Autowired可以实现根据byName自动装配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;bean id&quot;)</span></span><br></pre></td></tr></table></figure><p>@Resource : 如果指定了name属性，则先根据该属性进行byName装配；其次进行默认的byName方式进行装配；如果都不成功，则按byType自动转配，在不成功就报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果允许对象为空，设置required = false，默认为true</span></span><br><span class="line"><span class="meta">@Resource(name = &quot;bean id&quot;, required = false)</span></span><br></pre></td></tr></table></figure><blockquote><p>@Scope    作用域</p></blockquote><ul><li>singleton : 默认的，Spring会采用单例模式创建这个对象。关闭工厂，所有的对象都会销毁。</li><li>prototype : 多例模式，关闭工厂，所有的对象不会销毁。内部的垃圾回收机制会回收。</li></ul><blockquote><p>@Configuration</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//代表这是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//通过方法注册一个bean，这里的返回值就是Bean的类型，方法名就是bean的id</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴JAVA开发手册</title>
      <link href="/2022/12/12/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4JAVA%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/"/>
      <url>/2022/12/12/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4JAVA%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="一、编程规约"><a href="#一、编程规约" class="headerlink" title="一、编程规约"></a>一、编程规约</h3><h4 id="一-命名风格"><a href="#一-命名风格" class="headerlink" title="(一) 命名风格"></a>(一) 命名风格</h4><ul><li><p>类名使用大驼峰(UpperCamelCase)风格，但是如果类名包含&#x3D;&#x3D;DO&#x2F;BO&#x2F;DTO&#x2F;VO&#x2F;AO&#x2F;PO&#x2F;UID&#x3D;&#x3D;等，以下必须大写。例如：UserDO&#x2F;UserDTO</p></li><li><p>方法名、参数名、成员变量、局部变量统一使用小驼峰(lowerCamelCase)风格，必须遵从驼峰形式。</p></li><li><p>常量命名全部大写，单词间用下划线隔开，要求语义表达完整，即使名字长也没关系。</p></li><li><p>抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类 命名以它要测试的类的名称开始，以 Test 结尾。</p></li><li><p>包名统一使用小写，单数形式，类名如果有复数含义，类名可以使用复数形式。例如：应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils</p></li><li><p>杜绝完全不规范的缩写，避免望文不知义。</p></li><li><p>接口类中的方法和属性不要加任何修饰符号。</p></li><li><p>各层命名规约： </p><ul><li>A) Service&#x2F;DAO 层方法命名规约 <ul><li>1） 获取单个对象的方法用 get 做前缀。</li><li>2） 获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。 </li><li>3） 获取统计值的方法用 count 做前缀。 </li><li>4） 插入的方法用 save&#x2F;insert 做前缀。 </li><li>5） 删除的方法用 remove&#x2F;delete 做前缀。 </li><li>6） 修改的方法用 update 做前缀。</li></ul></li><li>B) 领域模型命名规约 <ul><li>1） &#x3D;&#x3D;数据对象：xxxDO，xxx 即为数据表名&#x3D;&#x3D;。 </li><li>2） &#x3D;&#x3D;数据传输对象：xxxDTO，xxx 为业务领域相关的名称&#x3D;&#x3D;。 </li><li>3） &#x3D;&#x3D;展示对象：xxxVO，xxx 一般为网页名称&#x3D;&#x3D;。 </li><li>4） &#x3D;&#x3D;POJO 是 DO&#x2F;DTO&#x2F;BO&#x2F;VO 的统称，禁止命名成 xxxPOJO&#x3D;&#x3D;。</li></ul></li></ul></li></ul><h4 id="二-常量定义"><a href="#二-常量定义" class="headerlink" title="(二) 常量定义"></a>(二) 常量定义</h4><ul><li>在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数 字 1 混淆，造成误解。</li></ul><h4 id="三-代码格式"><a href="#三-代码格式" class="headerlink" title="(三) 代码格式"></a>(三) 代码格式</h4><ul><li><p>如果是大括号内为空，则简洁地写成{}即可，大括号中间无需换行和空格</p></li><li><p>左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格；而左 大括号前需要空格。</p></li><li><p>&#x3D;&#x3D;if&#x2F;for&#x2F;while&#x2F;switch&#x2F;do&#x3D;&#x3D; 等保留字&#x3D;&#x3D;与括号之间都必须加空格&#x3D;&#x3D;。</p></li><li><p>任何二目、三目运算符的左右两边都需要加一个空格。(“+”  “-“  “*”  “&#x2F;“  “&#x3D;”  “&amp;&amp;”  “||”)</p></li><li><p>注释的双斜线与注释内容之间有且仅有一个空格。</p></li><li><p>在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开。<code>long first = 1000000000000L; int second = (int)first + 2; </code></p></li><li><p>方法参数在定义和传入时，多个参数逗号后边必须加空格。</p></li></ul><h4 id="四-规约"><a href="#四-规约" class="headerlink" title="(四) 规约"></a>(四) 规约</h4><ul><li><p>避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析 成本，直接用类名来访问即可。</p></li><li><p>所有的覆写方法，必须加@Override 注解。</p></li><li><p>相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。&#x3D;&#x3D;可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）&#x3D;&#x3D;</p></li><li><p>外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产 生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什 么。</p></li><li><p>不能使用过时的类或方法。</p></li><li><p>Object 的 &#x3D;&#x3D;equals 方法容易抛空指针异常&#x3D;&#x3D;，应使用常量或确定有值的对象来调用 equals。</p></li><li><p>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</p></li><li><p>定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。&#x3D;&#x3D;数据库字段的 bigint 必须与类属性的 Long 类型相对应&#x3D;&#x3D;。</p></li><li><p>所有的 POJO 类属性必须使用包装数据类型。RPC 方法的返回值和参数必须使用包装数据类型。所有的局部变量使用基本数据类型。</p></li><li><p>定义 DO&#x2F;DTO&#x2F;VO 等 POJO 类时，不要设定任何属性默认值。</p></li><li><p>序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果 完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。</p></li><li><p>构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。</p></li><li><p>POJO 类必须写 toString 方法。</p></li><li><p>类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter &#x2F; setter 方法。</p></li></ul><h4 id="五-集合处理"><a href="#五-集合处理" class="headerlink" title="(五) 集合处理"></a>(五) 集合处理</h4><h4 id="六-并发处理"><a href="#六-并发处理" class="headerlink" title="(六) 并发处理"></a>(六) 并发处理</h4><ul><li><p>获取单例对象需要保证线程安全，其中的方法也要保证线程安全</p></li><li><p>创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</p></li><li><p>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p></li><li><p>高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁； 能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</p></li><li><p>对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会 造成死锁。</p></li><li><p>在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代 码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。</p></li></ul><h4 id="七-控制语句"><a href="#七-控制语句" class="headerlink" title="(七) 控制语句"></a>(七) 控制语句</h4><ul><li>在一个 switch 块内，每个 case 要么通过 continue&#x2F;break&#x2F;return 等来终止，要么 注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。&#x3D;&#x3D;注意 break 是退出 switch 语句块，而 return 是退出方法体。&#x3D;&#x3D;</li><li>在 if&#x2F;else&#x2F;for&#x2F;while&#x2F;do 语句中必须使用大括号。</li><li>在高并发场景中，避免使用”等于”判断作为中断或退出的条件。</li></ul><h4 id="八-注释规约"><a href="#八-注释规约" class="headerlink" title="(八) 注释规约"></a>(八) 注释规约</h4><ul><li>类、类属性、类方法的注释必须使用 Javadoc 规范，使用&#x2F;*<em>内容</em>&#x2F;格式，不得使用 &#x2F;&#x2F; xxx 方式。</li><li>所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。</li><li>所有的类都必须添加创建者和创建日期。</li><li>方法内部单行注释，在被注释语句上方另起一行，使用&#x2F;&#x2F;注释。方法内部多行注释 使用&#x2F;* *&#x2F;注释，注意与代码对齐。</li><li>所有的枚举类型字段必须要有注释，说明每个数据项的用途。</li></ul><h4 id="九-其他"><a href="#九-其他" class="headerlink" title="(九) 其他"></a>(九) 其他</h4><ul><li>在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。</li><li>注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够 取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后 取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。</li><li>获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();</li><li>日期格式化时，传入 pattern 中表示年份统一使用小写的 y。表示月份是大写的 M；表示分钟则是小写的 m；24 小时制的是大写的 H；12 小时制的则是小写的 h。&#x3D;&#x3D;new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);&#x3D;&#x3D;</li></ul><h3 id="二、异常日志"><a href="#二、异常日志" class="headerlink" title="二、异常日志"></a>二、异常日志</h3><h4 id="一-异常处理"><a href="#一-异常处理" class="headerlink" title="(一) 异常处理"></a>(一) 异常处理</h4><ul><li>Java 类库中定义的可以通过预检查方式规避的 RuntimeException 异常不应该通 过 catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等 等。</li><li>异常不要用来做流程控制，条件控制。</li><li>catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。 对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。</li><li>捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它， 请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理 解的内容。</li><li>有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回 滚事务。</li><li>finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。</li><li>不要在 finally 块中使用 return。</li><li>捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类</li><li>在调用 RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用 Throwable 类来进行拦截。</li></ul><h4 id="二-日志规约"><a href="#二-日志规约" class="headerlink" title="(二) 日志规约"></a>(二) 日志规约</h4><ul><li>应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</li><li>所有日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。网络 运行状态、安全相关信息、系统监测、管理后台操作、用户敏感操作需要留存相关的网络日 志不少于 6 个月。</li><li>应用中的扩展日志（如打点、临时监控、访问日志等）命名方式： appName_logType_logName.log。logType:日志类型，如 stats&#x2F;monitor&#x2F;access 等；logName:日志 描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归 类查找。</li><li>在日志输出时，字符串变量之间的拼接使用占位符的方式。</li><li>对于 trace&#x2F;debug&#x2F;info 级别的日志输出，必须进行日志级别的开关判断。</li><li>避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity&#x3D;false。</li><li>异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通 过关键字 throws 往上抛出。</li></ul><h3 id="三、单元测试"><a href="#三、单元测试" class="headerlink" title="三、单元测试"></a>三、单元测试</h3><ul><li>好的单元测试必须遵守 AIR 原则。</li><li>单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的， 执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。 单元测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。</li><li>保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之 间决不能互相调用，也不能依赖执行的先后次序。</li><li>单元测试是可以重复执行的，不能受到外界环境的影响。</li><li>对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类 级别，一般是方法级别。</li><li>核心业务、核心应用、核心模块的增量代码确保单元测试通过。</li><li>单元测试代码必须写在如下工程目录：src&#x2F;test&#x2F;java，不允许写在业务代码目录下。</li></ul><h3 id="四、安全规约"><a href="#四、安全规约" class="headerlink" title="四、安全规约"></a>四、安全规约</h3><ul><li>隶属于用户个人的页面或者功能必须进行权限控制校验。</li><li>用户敏感数据禁止直接展示，必须对展示数据进行脱敏。&#x3D;&#x3D;中国大陆个人手机号码显示为:137****0969，隐藏中间 4 位，防止隐私泄露。&#x3D;&#x3D;</li><li>用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注 入，禁止字符串拼接 SQL 访问数据库。</li><li>用户请求传入的任何参数必须做有效性验证。</li><li>禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。</li><li>表单、AJAX 提交必须执行 CSRF 安全验证。</li><li>在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的 机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。</li></ul><h3 id="五、MySQL数据库"><a href="#五、MySQL数据库" class="headerlink" title="五、MySQL数据库"></a>五、MySQL数据库</h3><h4 id="一-建表规约"><a href="#一-建表规约" class="headerlink" title="(一) 建表规约"></a>(一) 建表规约</h4><ul><li>表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。&#x3D;&#x3D;POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在设置从 is_xxx 到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取 值含义与取值范围。&#x3D;&#x3D;</li><li>表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间 只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重 考虑。</li><li>表名不使用复数名词。</li><li>禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</li><li>主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。</li><li>小数类型为 decimal，禁止使用 float 和 double。</li><li>如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</li><li>varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长 度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。</li><li>表必备三字段：id, create_time, update_time。</li></ul><h4 id="二-索引规约"><a href="#二-索引规约" class="headerlink" title="(二) 索引规约"></a>(二) 索引规约</h4><ul><li>业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。</li><li>超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询 时，保证被关联的字段需要有索引。</li><li>在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度即可。</li><li>页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</li></ul><h4 id="三-SQL语句"><a href="#三-SQL语句" class="headerlink" title="(三) SQL语句"></a>(三) SQL语句</h4><ul><li>不要使用 count(列名)或 count(常量)来替代 count(<em>)，count(</em>)是 SQL92 定义的 标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。</li><li>count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</li><li>当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果 为 NULL，因此使用 sum()时需注意 NPE 问题。</li><li>使用 ISNULL()来判断是否为 NULL 值。</li><li>代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</li><li>不得使用外键与级联，一切外键概念必须在应用层解决。</li><li>禁止使用存储过程，存储过程难以调试和扩展，更没有移植性</li><li>数据订正（特别是删除、修改记录操作）时，要先 select，避免出现误删除，确认无 误才能执行更新语句。</li></ul><h4 id="四-ORM映射"><a href="#四-ORM映射" class="headerlink" title="(四) ORM映射"></a>(四) ORM映射</h4><ul><li>在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。</li><li>POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行 字段与属性之间的映射。</li><li>不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要 定义；反过来，每一个表也必然有一个 POJO 类与之对应。</li><li>sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。</li><li>iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。</li><li>不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。</li><li>更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。</li></ul><h3 id="六、工程结构"><a href="#六、工程结构" class="headerlink" title="六、工程结构"></a>六、工程结构</h3><h4 id="一-应用分层"><a href="#一-应用分层" class="headerlink" title="(一) 应用分层"></a>(一) 应用分层</h4><ul><li>图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于 Web 层，也可以直接依赖于 Service 层，依此类推：</li></ul><p><img src="/../../Users/10466/AppData/Roaming/Typora/typora-user-images/image-20210728111353914.png" alt="image-20210728111353914"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 开放接口层：可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；进行网关安全控制、流量控制等。</span><br><span class="line"><span class="bullet">-</span> 终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。</span><br><span class="line"><span class="bullet">-</span> Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</span><br><span class="line"><span class="bullet">-</span> Service 层：相对具体的业务逻辑服务层。</span><br><span class="line"><span class="bullet">-</span> Manager 层：通用业务处理层，它有如下特征：</span><br><span class="line"><span class="bullet">-</span> 对第三方平台封装的层，预处理返回结果及转化异常信息。</span><br><span class="line"><span class="bullet">-</span> 对 Service 层通用能力的下沉，如缓存方案、中间件通用处理。</span><br><span class="line"><span class="bullet">-</span> 与 DAO 层交互，对多个 DAO 的组合复用。 </span><br><span class="line"><span class="bullet">-</span> DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase 等进行数据交互。</span><br><span class="line"><span class="bullet">-</span> 外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。</span><br></pre></td></tr></table></figure><ul><li>分层领域模型规约：<ul><li>DO（Data Object）：此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</li><li>DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。</li><li>BO（Business Object）：业务对象，由 Service 层输出的封装业务逻辑的对象。</li><li>AO（Application Object）：应用对象，在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</li><li>VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li><li>Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类 来传输。</li></ul></li></ul><h4 id="二-二方库依赖"><a href="#二-二方库依赖" class="headerlink" title="(二) 二方库依赖"></a>(二) 二方库依赖</h4><ul><li><p>定义 GAV 遵从以下规则： </p><ul><li>GroupID 格式：com.{公司&#x2F;BU }.业务线 [.子业务线]，最多 4 级。 </li><li>ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。  </li><li>Version：详细规定参考下方。</li></ul></li><li><p>二方库版本号命名方式：主版本号.次版本号.修订号</p><ul><li>主版本号：产品方向改变，或者大规模 API 不兼容，或者架构不兼容升级。</li><li>次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的 API 不兼容修改。</li><li>修订号：保持完全兼容性，修复 BUG、新增次要功能特性等。</li></ul></li><li><p>线上应用不要依赖 SNAPSHOT 版本（安全包除外）。</p></li><li><p>二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变， 必须明确评估和验证。</p></li><li><p>二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用 枚举类型或者包含枚举类型的 POJO 对象。</p></li><li><p>依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。</p></li><li><p>禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的 Version。</p></li></ul><h4 id="三-服务器"><a href="#三-服务器" class="headerlink" title="(三) 服务器"></a>(三) 服务器</h4><ul><li>高并发服务器建议调小 TCP 协议的 time_wait 超时时间。</li><li>调大服务器所支持的最大文件句柄数（File Descriptor，简写为 fd）。</li><li>给 JVM 环境参数设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出 dump 信息。</li><li>在线上生产环境，JVM 的 Xms 和 Xmx 设置一样大小的内存容量，避免在 GC 后调整 堆大小带来的压力。</li></ul><h3 id="七、设计规约"><a href="#七、设计规约" class="headerlink" title="七、设计规约"></a>七、设计规约</h3><ul><li><p>存储方案和底层数据结构的设计获得评审一致通过，并沉淀成为文档。 说明：有缺陷的底层数据结构容易导致系统风险上升，可扩展性下降，重构成本也会因历史数据迁移和系 统平滑过渡而陡然增加，所以，存储方案和数据结构需要认真地进行设计和评审，生产环境提交执行后， 需要进行 double check。</p></li><li><p>在需求分析阶段，如果与系统交互的 User 超过一类并且相关的 User Case 超过 5 个，使用用例图来表达更加清晰的结构化需求。</p></li><li><p>如果某个业务对象的状态超过 3 个，使用状态图来表达并且明确状态变化的各个触 发条件。</p></li><li><p>如果系统中某个功能的调用链路上的涉及对象超过 3 个，使用时序图来表达并且明 确各调用环节的输入与输出。</p></li><li><p>如果系统中模型类超过 5 个，并且存在复杂的依赖关系，使用类图来表达并且明确 类之间的关系。</p></li><li><p>如果系统中超过 2 个对象之间存在协作关系，并且需要表示复杂的处理流程，使用 活动图来表示。</p></li></ul><h4 id="附1-专有名词解释"><a href="#附1-专有名词解释" class="headerlink" title="附1 : 专有名词解释"></a>附1 : 专有名词解释</h4><ul><li>POJO（Plain Ordinary Java Object）: 在本手册中，POJO 专指只有 setter &#x2F; getter &#x2F; toString 的简单类，包括 DO&#x2F;DTO&#x2F;BO&#x2F;VO 等。</li><li>GAV（GroupId、ArtifactctId、Version）: Maven 坐标，是用来唯一标识 jar 包。</li><li>OOP（Object Oriented Programming）: 本手册泛指类、对象的编程处理方式。</li><li>ORM（Object Relation Mapping）: 对象关系映射，对象领域模型与底层数据之间的转换， 本文泛指 iBATIS, mybatis 等框架。</li><li>NPE（java.lang.NullPointerException）: 空指针异常。</li><li>SOA（Service-Oriented Architecture）: 面向服务架构，它可以根据需求通过网络对松散耦合 的粗粒度应用组件进行分布式部署、组合和使用，有利于提升组件可重用性，可维护性。</li><li>IDE（Integrated Development Environment）: 用于提供程序开发环境的应用程序，一般包括 代码编辑器、编译器、调试器和图形用户界面等工具，本《手册》泛指 IntelliJ IDEA 和 eclipse。</li><li>OOM（Out Of Memory）: 源于 java.lang.OutOfMemoryError，当 JVM 没有足够的内存来 为对象分配空间并且垃圾回收器也无法回收空间时，系统出现的严重状况。</li><li>一方库：本工程内部子项目模块依赖的库（jar 包）。</li><li>二方库：公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar 包）。</li><li>三方库：公司之外的开源库（jar 包）</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
