<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>24 大设计模式 和 7 个原则</title>
      <link href="/2022/12/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/12/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="7个原则"><a href="#7个原则" class="headerlink" title="7个原则"></a>7个原则</h2><p>单一职责原则【SINGLE RESPONSIBILITY PRINCIPLE】：一个类负责一项职责。</p><p>里氏替换原则【LISKOV SUBSTITUTION PRINCIPLE】: 继承与派生的规则。</p><p>依赖倒置原则【DEPENDENCE INVERSION PRINCIPLE】: 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。</p><p>接口隔离原则【INTERFACE SEGREGATION PRINCIPLE】: 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。</p><p>迪米特法则【LOW OF DEMETER】: 低耦合，高内聚。</p><p>开闭原则【OPEN CLOSE PRINCIPLE】: 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p><p>组合&#x2F;聚合复用原则【Composition&#x2F;Aggregation Reuse Principle(CARP) 】: 尽量使用组合和聚合少使用继承的关系来达到复用的原则。</p><h2 id="24大设计模式"><a href="#24大设计模式" class="headerlink" title="24大设计模式"></a>24大设计模式</h2><h3 id="1-创建型-单例模式-Singleton-Pattern"><a href="#1-创建型-单例模式-Singleton-Pattern" class="headerlink" title="1. 创建型 - 单例模式(Singleton Pattern)"></a>1. 创建型 - 单例模式(Singleton Pattern)</h3><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</p><p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p><p><img src="/../img/designPatterns/562f2844-d77c-40e0-887a-28a7128abd42.png" alt="562f2844-d77c-40e0-887a-28a7128abd42"></p><h4 id="6种实现方式"><a href="#6种实现方式" class="headerlink" title="6种实现方式"></a>6种实现方式</h4><p><img src="/../img/designPatterns/2_singleton_1.png" alt="2_singleton_1"></p><h4 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式 - 线程不安全"></a>懒汉式 - 线程不安全</h4><p>以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化，从而节约资源。</p><p>这个实现再多线程环境下是不安全的，如果多个线程能够同时进入<code>if(uniqueInstance == null)</code>, 并且此时 uniqueInstance 为 null，那么会有多个线程执行<code>uniqueInstance = new Singleton();</code>语句，这将导致多次实例化 uniqueInstance。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern001</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonPattern001 uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonPattern001</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonPattern001 <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> <span class="title class_">SingletonPattern001</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="饿汉式-线程安全"><a href="#饿汉式-线程安全" class="headerlink" title="饿汉式 - 线程安全"></a>饿汉式 - 线程安全</h4><p>线程不安全的问题主要是由于 uniqueInstance 被多次实例化，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全的问题。</p><p>但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern002</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonPattern002</span> <span class="variable">uniqueInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonPattern002</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonPattern002 <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉式-线程安全"><a href="#懒汉式-线程安全" class="headerlink" title="懒汉式 - 线程安全"></a>懒汉式 - 线程安全</h4><p>只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了多次实例化 uniqueInstance 的问题。</p><p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，因此性能上有一定的损耗。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern003</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonPattern003 uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonPattern003</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonPattern003 <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> <span class="title class_">SingletonPattern003</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双重校验锁-线程安全"><a href="#双重校验锁-线程安全" class="headerlink" title="双重校验锁 - 线程安全"></a>双重校验锁 - 线程安全</h4><p>uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern004</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonPattern004 uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonPattern004</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonPattern004 <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonPattern004.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">SingletonPattern004</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance &#x3D;&#x3D; null 的情况下，如果两个线程同时执行 if 语句，那么两个线程就会同时进入 if 语句块内。虽然在 if 语句内有加锁操作，但是两个线程都会执行<code>uniqueInstance = new Singleton();</code>这条语句，只是先后的问题，那么就会进行两次实例化，从而产生了两个实例。因此必须使用双重校验锁，也就是需要使用两个 if 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SingletonPattern004.class) &#123;</span><br><span class="line">          uniqueInstance = <span class="keyword">new</span> <span class="title class_">SingletonPattern004</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的。<code>uniqueInstance = new SingletonPattern004();</code>这段代码其实是分为三步执行。</p><ol><li>分配内存空间</li><li>初始化对象</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，有可能执行顺序变为了 1&gt;3&gt;2，这在单线程情况下自然是没有问题。但如果是多线程下，有可能获得是一个还没有被初始化的实例，以至于程序出错。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>当 SingletonPattern005 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用<code>getUniqueInstance()</code>方法从而触发<code>SingletonHolder.INSTANCE</code>时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例。</p><p>这种方式不仅具有延迟初始化的好处，而且由虚拟机提供了对线程安全的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern005</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonPattern005</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonPattern005</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonPattern005</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonPattern005 <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h4><p>这是单例模式的最佳实践，他实现简单，并且在面对复杂的序列化或者反射攻击的时候，能够防止实例化多次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SingletonPattern006</span> &#123;</span><br><span class="line">    uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑一下单例模式的实现，该 Singleton 在每次序列化的时候都会创建一个新的实例，为了保证只创建一个实例，必须声明所有字段都是transient，并且提供一个 readResolve() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用枚举来实现单例模式，会出现反射攻击，因为通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象。如果要防止这种攻击，需要在构造函数中添加防止实例化对二个对象的代码。从上面的讨论可以看出，解决序列化和反射攻击很麻烦，而枚举实现不会出现这两种问题，所以说枚举实现单例模式是最佳实践。</p><h3 id="2-创建型-简单工厂-Simple-Factory"><a href="#2-创建型-简单工厂-Simple-Factory" class="headerlink" title="2. 创建型 - 简单工厂(Simple Factory)"></a>2. 创建型 - 简单工厂(Simple Factory)</h3><h4 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h4><p>再创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p><h4 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h4><p>简单工厂不是设计模式，更像一种编程习惯。它把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</p><p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。因为客户类往往有多个，如果不使用简单工厂，所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p><p><img src="/../img/designPatterns/c79da808-0f28-4a36-bc04-33ccc5b83c13.png" alt="c79da808-0f28-4a36-bc04-33ccc5b83c13"></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下的 Client 类中包含了实例化的代码，这是一种错误的实现，如果在客户类中存在实例化代码，就需要将代码放到简单工厂中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        Product product;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleFactory</span> <span class="variable">simpleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleFactory</span>();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> simpleFactory.createProduct(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-创建型-工厂方法-Factory-Method"><a href="#3-创建型-工厂方法-Factory-Method" class="headerlink" title="3. 创建型 - 工厂方法(Factory Method)"></a>3. 创建型 - 工厂方法(Factory Method)</h3><h4 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h4><p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p><h4 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h4><p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</p><p>下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。</p><p><img src="/../img/designPatterns/1818e141-8700-4026-99f7-900a545875f5.png" alt="1818e141-8700-4026-99f7-900a545875f5"></p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> factoryMethod();</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-创建型-抽象工厂-Abstract-Factory"><a href="#4-创建型-抽象工厂-Abstract-Factory" class="headerlink" title="4. 创建型 - 抽象工厂(Abstract Factory)"></a>4. 创建型 - 抽象工厂(Abstract Factory)</h3><h4 id="意图-2"><a href="#意图-2" class="headerlink" title="意图"></a>意图</h4><p>提供一个接口，用于创建 相关的对象家族。</p><h4 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h4><p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p><p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p><p>至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</p><p>从高层次来看，抽象工厂使用了组合，即 Client 组合了 AbstractFactory，而工厂方法模式使用了继承。</p><p><img src="/../img/designPatterns/8668a3e1-c9c7-4fcb-98b2-a96a5d841579.png" alt="8668a3e1-c9c7-4fcb-98b2-a96a5d841579"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductA1</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductA2</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductB1</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductB2</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">abstractFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory1</span>();</span><br><span class="line">        <span class="type">AbstractProductA</span> <span class="variable">productA</span> <span class="operator">=</span> abstractFactory.createProductA();</span><br><span class="line">        <span class="type">AbstractProductB</span> <span class="variable">productB</span> <span class="operator">=</span> abstractFactory.createProductB();</span><br><span class="line">        <span class="comment">// do something with productA and productB</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-创建型-生成器-Builder"><a href="#5-创建型-生成器-Builder" class="headerlink" title="5. 创建型 - 生成器(Builder)"></a>5. 创建型 - 生成器(Builder)</h3><h4 id="意图-3"><a href="#意图-3" class="headerlink" title="意图"></a>意图</h4><p>封装一个对象的构造过程，并允许按步骤构造。</p><h4 id="类图-4"><a href="#类图-4" class="headerlink" title="类图"></a>类图</h4><p><img src="/../img/designPatterns/13b0940e-d1d7-4b17-af4f-b70cb0a75e08.png" alt="13b0940e-d1d7-4b17-af4f-b70cb0a75e08"></p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>以下是一个简易的 StringBuilder 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractStringBuilder</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(count + <span class="number">1</span>);</span><br><span class="line">        value[count++] = c;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>)</span><br><span class="line">            expandCapacity(minimumCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">expandCapacity</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> value.length * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minimumCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">            newCapacity = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilder</span> <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Create a copy, don&#x27;t share the array</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            sb.append((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcdefghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure><h3 id="6-创建型-原型模式-Prototype"><a href="#6-创建型-原型模式-Prototype" class="headerlink" title="6. 创建型 - 原型模式(Prototype)"></a>6. 创建型 - 原型模式(Prototype)</h3><h4 id="意图-4"><a href="#意图-4" class="headerlink" title="意图"></a>意图</h4><p>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。</p><h4 id="类图-5"><a href="#类图-5" class="headerlink" title="类图"></a>类图</h4><p><img src="/../img/designPatterns/a40661e4-1a71-46d2-a158-ff36f7fc3331.png"></p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> Prototype <span class="title function_">myClone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcretePrototype</span><span class="params">(String filed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filed = filed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Prototype <span class="title function_">myClone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(filed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> filed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">clone</span> <span class="operator">=</span> prototype.myClone();</span><br><span class="line">        System.out.println(clone.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br></pre></td></tr></table></figure><h3 id="7-结构型-外观-Facade"><a href="#7-结构型-外观-Facade" class="headerlink" title="7. 结构型 - 外观(Facade)"></a>7. 结构型 - 外观(Facade)</h3><h4 id="意图-5"><a href="#意图-5" class="headerlink" title="意图"></a>意图</h4><p>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</p><h4 id="类图-6"><a href="#类图-6" class="headerlink" title="类图"></a>类图</h4><p><img src="/../img/designPatterns/f9978fa6-9f49-4a0f-8540-02d269ac448f.png"></p><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>观看电影需要操作很多电器，使用外观模式实现一键看电影功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOnTV</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;turnOnTV()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCD</span><span class="params">(String cd)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setCD( &quot;</span> + cd + <span class="string">&quot; )&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">starWatching</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;starWatching()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystem</span> <span class="variable">subSystem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystem</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchMovie</span><span class="params">()</span> &#123;</span><br><span class="line">        subSystem.turnOnTV();</span><br><span class="line">        subSystem.setCD(<span class="string">&quot;a movie&quot;</span>);</span><br><span class="line">        subSystem.starWatching();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Facade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Facade</span>();</span><br><span class="line">        facade.watchMovie();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p>最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。</p><h3 id="8-结构性-适配器-Adapter"><a href="#8-结构性-适配器-Adapter" class="headerlink" title="8. 结构性 - 适配器(Adapter)"></a>8. 结构性 - 适配器(Adapter)</h3><h4 id="意图-6"><a href="#意图-6" class="headerlink" title="意图"></a>意图</h4><p>把一个类接口转换成另一个用户需要的接口。</p><p><img src="/../img/designPatterns/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png"></p><h4 id="类图-7"><a href="#类图-7" class="headerlink" title="类图"></a>类图</h4><p><img src="/../img/designPatterns/0f754c1d-b5cb-48cd-90e0-4a86034290a1.png"></p><h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Turkey</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WildTurkey</span> <span class="keyword">implements</span> <span class="title class_">Turkey</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;gobble!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    Turkey turkey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        turkey.gobble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Turkey</span> <span class="variable">turkey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WildTurkey</span>();</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TurkeyAdapter</span>(turkey);</span><br><span class="line">        duck.quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-结构型-桥接-Bridge"><a href="#9-结构型-桥接-Bridge" class="headerlink" title="9. 结构型 - 桥接(Bridge)"></a>9. 结构型 - 桥接(Bridge)</h3><h4 id="意图-7"><a href="#意图-7" class="headerlink" title="意图"></a>意图</h4><p>将抽象与实现分离开来，使他们可以独立变化。</p><h4 id="类图-8"><a href="#类图-8" class="headerlink" title="类图"></a>类图</h4><ul><li>Abstracttion：定义抽象类的接口</li><li>Implementor：定义实现类接口</li></ul><p><img src="/../img/designPatterns/c2cbf5d2-82af-4c78-bd43-495da5adf55f.png"></p><h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><p>RemoteControl 表示遥控器，指代 Abstraction。</p><p>TV 表示电视，指代 Implementor。</p><p>桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">tuneChannel</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sony</span> <span class="keyword">extends</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sony.on()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sony.off()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tuneChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sony.tuneChannel()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RCA</span> <span class="keyword">extends</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RCA.on()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RCA.off()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tuneChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RCA.tuneChannel()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteControl</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">tuneChannel</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteRemoteControl1</span> <span class="keyword">extends</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteRemoteControl1</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(tv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteRemoteControl1.on()&quot;</span>);</span><br><span class="line">        tv.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteRemoteControl1.off()&quot;</span>);</span><br><span class="line">        tv.off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tuneChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteRemoteControl1.tuneChannel()&quot;</span>);</span><br><span class="line">        tv.tuneChannel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteRemoteControl2</span> <span class="keyword">extends</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteRemoteControl2</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(tv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteRemoteControl2.on()&quot;</span>);</span><br><span class="line">        tv.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteRemoteControl2.off()&quot;</span>);</span><br><span class="line">        tv.off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tuneChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteRemoteControl2.tuneChannel()&quot;</span>);</span><br><span class="line">        tv.tuneChannel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RemoteControl</span> <span class="variable">remoteControl1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteRemoteControl1</span>(<span class="keyword">new</span> <span class="title class_">RCA</span>());</span><br><span class="line">        remoteControl1.on();</span><br><span class="line">        remoteControl1.off();</span><br><span class="line">        remoteControl1.tuneChannel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-结构型-组合-Composite"><a href="#10-结构型-组合-Composite" class="headerlink" title="10. 结构型 - 组合(Composite)"></a>10. 结构型 - 组合(Composite)</h3><h4 id="意图-8"><a href="#意图-8" class="headerlink" title="意图"></a>意图</h4><p>将对象组合成树形结构来表示”整体&#x2F;部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。</p><h4 id="类图-9"><a href="#类图-9" class="headerlink" title="类图"></a>类图</h4><p>组件(Component)类是组合类(Composite)和叶子类(Leaf)的父类，可以把组合类堪称是树的中间节点。</p><p>组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。</p><p><img src="/../img/designPatterns/3fb5b255-b791-45b6-8754-325c8741855a.png"></p><h4 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Component</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        print(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> level)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Composite</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        child = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Composite:&quot;</span> + name);</span><br><span class="line">        <span class="keyword">for</span> (Component component : child) &#123;</span><br><span class="line">            component.print(level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        child.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        child.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;left:&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(); <span class="comment">// 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Composite</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        root.add(node1);</span><br><span class="line">        root.add(node2);</span><br><span class="line">        root.add(node3);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">node21</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;21&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">node22</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&quot;22&quot;</span>);</span><br><span class="line">        node2.add(node21);</span><br><span class="line">        node2.add(node22);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">node221</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;221&quot;</span>);</span><br><span class="line">        node22.add(node221);</span><br><span class="line">        root.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Composite:root</span><br><span class="line">--left:1</span><br><span class="line">--Composite:2</span><br><span class="line">----left:21</span><br><span class="line">----Composite:22</span><br><span class="line">------left:221</span><br><span class="line">--left:3</span><br></pre></td></tr></table></figure><h3 id="11-结构型-装饰-Decorator"><a href="#11-结构型-装饰-Decorator" class="headerlink" title="11. 结构型 - 装饰(Decorator)"></a>11. 结构型 - 装饰(Decorator)</h3><h4 id="意图-9"><a href="#意图-9" class="headerlink" title="意图"></a>意图</h4><p>为对象动态添加功能。</p><h4 id="类图-10"><a href="#类图-10" class="headerlink" title="类图"></a>类图</h4><p>装饰者(Decorator)和具体组件(ConcreteComponent)都继承自组件(Component)，具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其他装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于他的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。</p><p><img src="/../img/designPatterns/137c593d-0a9e-47b8-a9e6-b71f540b82dd.png"></p><h4 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h4><p>设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。</p><p>下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。</p><p><img src="/../img/designPatterns/c9cfd600-bc91-4f3a-9f99-b42f88a5bb24.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DarkRoast</span> <span class="keyword">implements</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseBlend</span> <span class="keyword">implements</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CondimentDecorator</span> <span class="keyword">implements</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Beverage beverage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Milk</span> <span class="keyword">extends</span> <span class="title class_">CondimentDecorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Milk</span><span class="params">(Beverage beverage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mocha</span> <span class="keyword">extends</span> <span class="title class_">CondimentDecorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mocha</span><span class="params">(Beverage beverage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Beverage</span> <span class="variable">beverage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseBlend</span>();</span><br><span class="line">        beverage = <span class="keyword">new</span> <span class="title class_">Mocha</span>(beverage);</span><br><span class="line">        beverage = <span class="keyword">new</span> <span class="title class_">Milk</span>(beverage);</span><br><span class="line">        System.out.println(beverage.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.0</span><br></pre></td></tr></table></figure><h4 id="设计原则-1"><a href="#设计原则-1" class="headerlink" title="设计原则"></a>设计原则</h4><p>类应该对扩展开放，对修改关闭: 也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。</p><p>不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。</p><h3 id="12-结构型-享元-Flyweight"><a href="#12-结构型-享元-Flyweight" class="headerlink" title="12. 结构型 - 享元(Flyweight)"></a>12. 结构型 - 享元(Flyweight)</h3><h4 id="意图-10"><a href="#意图-10" class="headerlink" title="意图"></a>意图</h4><p>利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。</p><h4 id="类图-11"><a href="#类图-11" class="headerlink" title="类图"></a>类图</h4><ul><li>Flyweight: 享元对象</li><li>IntrinsicState: 内部状态，享元对象共享内部状态</li><li>ExtrinsicState：外部状态，每个享元对象的外部状态不同</li></ul><p><img src="/../img/designPatterns/d52270b4-9097-4667-9f18-f405fc661c99.png"></p><h4 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyweight</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doOperation</span><span class="params">(String extrinsicState)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title class_">Flyweight</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String intrinsicState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteFlyweight</span><span class="params">(String intrinsicState)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.intrinsicState = intrinsicState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOperation</span><span class="params">(String extrinsicState)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Object address: &quot;</span> + System.identityHashCode(<span class="built_in">this</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;IntrinsicState: &quot;</span> + intrinsicState);</span><br><span class="line">        System.out.println(<span class="string">&quot;ExtrinsicState: &quot;</span> + extrinsicState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyweightFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Flyweight&gt; flyweights = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Flyweight <span class="title function_">getFlyweight</span><span class="params">(String intrinsicState)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flyweights.containsKey(intrinsicState)) &#123;</span><br><span class="line">            <span class="type">Flyweight</span> <span class="variable">flyweight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFlyweight</span>(intrinsicState);</span><br><span class="line">            flyweights.put(intrinsicState, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweights.get(intrinsicState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FlyweightFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlyweightFactory</span>();</span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweight1</span> <span class="operator">=</span> factory.getFlyweight(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweight2</span> <span class="operator">=</span> factory.getFlyweight(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        flyweight1.doOperation(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">        flyweight2.doOperation(<span class="string">&quot;y&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object address: 356573597</span><br><span class="line">IntrinsicState: aa</span><br><span class="line">ExtrinsicState: x</span><br><span class="line">Object address: 356573597</span><br><span class="line">IntrinsicState: aa</span><br><span class="line">ExtrinsicState: y</span><br></pre></td></tr></table></figure><h3 id="13-结构型-代理-Proxy"><a href="#13-结构型-代理-Proxy" class="headerlink" title="13. 结构型 - 代理(Proxy)"></a>13. 结构型 - 代理(Proxy)</h3><h4 id="意图-11"><a href="#意图-11" class="headerlink" title="意图"></a>意图</h4><p>控制对其他对象的访问。</p><h4 id="类图-12"><a href="#类图-12" class="headerlink" title="类图"></a>类图</h4><p>代理有以下四类：</p><ul><li>远程代理(Remote Proxy)：控制对远程对象(不同地址空间)的访问，他负责将请求及其参数进行编码，并向不通过地址空间中的对象发送已经编码的请求。</li><li>虚拟代理(Virtual Proxy)：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。</li><li>保护代理(Protection Proxy)：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。</li><li>智能代理(Smart Reference)：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个持久化对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。</li></ul><p><img src="/../img/designPatterns/a6c20f60-5eba-427d-9413-352ada4b40fe.png"></p><h4 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h4><p>以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighResolutionImage</span> <span class="keyword">implements</span> <span class="title class_">Image</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> URL imageURL;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> startTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HighResolutionImage</span><span class="params">(URL imageURL)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.imageURL = imageURL;</span><br><span class="line">        <span class="built_in">this</span>.startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="built_in">this</span>.width = <span class="number">600</span>;</span><br><span class="line">        <span class="built_in">this</span>.height = <span class="number">600</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLoad</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟图片加载，延迟 3s 加载完成</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> endTime - startTime &gt; <span class="number">3000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Real Image: &quot;</span> + imageURL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProxy</span> <span class="keyword">implements</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HighResolutionImage highResolutionImage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageProxy</span><span class="params">(HighResolutionImage highResolutionImage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.highResolutionImage = highResolutionImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!highResolutionImage.isLoad()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Temp Image: &quot;</span> + highResolutionImage.getWidth() + <span class="string">&quot; &quot;</span> + highResolutionImage.getHeight());</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        highResolutionImage.showImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageViewer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">image</span> <span class="operator">=</span> <span class="string">&quot;http://image.jpg&quot;</span>;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(image);</span><br><span class="line">        <span class="type">HighResolutionImage</span> <span class="variable">highResolutionImage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HighResolutionImage</span>(url);</span><br><span class="line">        <span class="type">ImageProxy</span> <span class="variable">imageProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageProxy</span>(highResolutionImage);</span><br><span class="line">        imageProxy.showImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-行为型-责任链-Chain-Of-Responsibility"><a href="#14-行为型-责任链-Chain-Of-Responsibility" class="headerlink" title="14. 行为型 - 责任链(Chain Of Responsibility)"></a>14. 行为型 - 责任链(Chain Of Responsibility)</h3><h4 id="意图-12"><a href="#意图-12" class="headerlink" title="意图"></a>意图</h4><p>十多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，知道有一个对象处理它为止。</p><h4 id="类图-13"><a href="#类图-13" class="headerlink" title="类图"></a>类图</h4><p>Handler：定义处理请求的接口，并且实现后续链(successor)</p><p><img src="/../img/designPatterns/691f11eb-31a7-46be-9de1-61f433c4b3c7.png"></p><h4 id="实现-11"><a href="#实现-11" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler successor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteHandler1</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(successor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getType() == RequestType.type1) &#123;</span><br><span class="line">            System.out.println(request.getName() + <span class="string">&quot; is handle by ConcreteHandler1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (successor != <span class="literal">null</span>) &#123;</span><br><span class="line">            successor.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler2</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteHandler2</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(successor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getType() == RequestType.type2) &#123;</span><br><span class="line">            System.out.println(request.getName() + <span class="string">&quot; is handle by ConcreteHandler2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (successor != <span class="literal">null</span>) &#123;</span><br><span class="line">            successor.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RequestType type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Request</span><span class="params">(RequestType type, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RequestType <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestType</span> &#123;</span><br><span class="line">    type1, type2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">handler1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler1</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">handler2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler2</span>(handler1);</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(RequestType.type1, <span class="string">&quot;request1&quot;</span>);</span><br><span class="line">        handler2.handleRequest(request1);</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(RequestType.type2, <span class="string">&quot;request2&quot;</span>);</span><br><span class="line">        handler2.handleRequest(request2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request1 is handle by ConcreteHandler1</span><br><span class="line">request2 is handle by ConcreteHandler2</span><br></pre></td></tr></table></figure><h3 id="15-行为型-策略-Strategy"><a href="#15-行为型-策略-Strategy" class="headerlink" title="15. 行为型 - 策略(Strategy)"></a>15. 行为型 - 策略(Strategy)</h3><h4 id="意图-13"><a href="#意图-13" class="headerlink" title="意图"></a>意图</h4><p>定义一系列算法，封装每个算法，并使他们可以互换。</p><p>策略模式可以让算法独立于使用他的客户端。</p><h4 id="类图-14"><a href="#类图-14" class="headerlink" title="类图"></a>类图</h4><ul><li>Strategy 接口定义一个算法族，它们都具有 behavior() 方法。</li><li>Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(in Strategy) 方法可以动态地改变 strategy() 对象，也就是说能动态地改变 Context 所使用的算法。</li></ul><p><img src="/../img/designPatterns/strategy%E7%B1%BB%E5%9B%BE.png"></p><h4 id="与状态模式的笔记哦啊"><a href="#与状态模式的笔记哦啊" class="headerlink" title="与状态模式的笔记哦啊"></a>与状态模式的笔记哦啊</h4><p>状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 锁组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。</p><p>状态模式主要是用来解决状态转的的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。</p><h4 id="实现-12"><a href="#实现-12" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">QuackBehavior</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Quack</span> <span class="keyword">implements</span> <span class="title class_">QuackBehavior</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;quack!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Squeak</span> <span class="keyword">implements</span> <span class="title class_">QuackBehavior</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;squeak!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> QuackBehavior quackBehavior;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performQuack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (quackBehavior != <span class="literal">null</span>) &#123;</span><br><span class="line">            quackBehavior.quack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setQuackBehavior</span><span class="params">(QuackBehavior quackBehavior)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.quackBehavior = quackBehavior;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line">        duck.setQuackBehavior(<span class="keyword">new</span> <span class="title class_">Squeak</span>());</span><br><span class="line">        duck.performQuack();</span><br><span class="line">        duck.setQuackBehavior(<span class="keyword">new</span> <span class="title class_">Quack</span>());</span><br><span class="line">        duck.performQuack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">squeak!</span><br><span class="line">quack!</span><br></pre></td></tr></table></figure><h3 id="16-行为型-模版方法-Template-Method"><a href="#16-行为型-模版方法-Template-Method" class="headerlink" title="16. 行为型 - 模版方法(Template Method)"></a>16. 行为型 - 模版方法(Template Method)</h3><h4 id="意图-14"><a href="#意图-14" class="headerlink" title="意图"></a>意图</h4><p>定义算法框架，并将一些步骤的实现延迟到子类。</p><p>通过模版方法，子类可以重新定义的某些步骤，而不用改变算法的结构。</p><h4 id="类图-15"><a href="#类图-15" class="headerlink" title="类图"></a>类图</h4><p><img src="/../img/designPatterns/templateMethod%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-13"><a href="#实现-13" class="headerlink" title="实现"></a>实现</h4><p>冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。</p><p><img src="/../img/designPatterns/11236498-1417-46ce-a1b0-e10054256955.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CaffeineBeverage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">prepareRecipe</span><span class="params">()</span> &#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">boilWater</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;boilWater&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pourInCup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;pourInCup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> <span class="keyword">extends</span> <span class="title class_">CaffeineBeverage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Coffee.brew&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Coffee.addCondiments&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tea</span> <span class="keyword">extends</span> <span class="title class_">CaffeineBeverage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tea.brew&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tea.addCondiments&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CaffeineBeverage</span> <span class="variable">caffeineBeverage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Coffee</span>();</span><br><span class="line">        caffeineBeverage.prepareRecipe();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        caffeineBeverage = <span class="keyword">new</span> <span class="title class_">Tea</span>();</span><br><span class="line">        caffeineBeverage.prepareRecipe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">boilWater</span><br><span class="line">Coffee.brew</span><br><span class="line">pourInCup</span><br><span class="line">Coffee.addCondiments</span><br><span class="line">-----------</span><br><span class="line">boilWater</span><br><span class="line">Tea.brew</span><br><span class="line">pourInCup</span><br><span class="line">Tea.addCondiments</span><br></pre></td></tr></table></figure><h3 id="17-行为型-命令模式-command"><a href="#17-行为型-命令模式-command" class="headerlink" title="17. 行为型 - 命令模式(command)"></a>17. 行为型 - 命令模式(command)</h3><h4 id="意图-15"><a href="#意图-15" class="headerlink" title="意图"></a>意图</h4><p>将命令封装在对象中，以便使用命令来参数化其它对象，或者将命令对象放入队列中进行排队，或者将命对象的操作记录到日志中，以及支持可撤销的操作。</p><h4 id="类图-16"><a href="#类图-16" class="headerlink" title="类图"></a>类图</h4><ul><li>Command：命令</li><li>Receiver：命令接受者，也就是命令真正的执行者</li><li>Invoker：通过它来调用命令</li><li>Client：可以设置命令与命令的接受者</li></ul><p><img src="/../img/designPatterns/Command%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-14"><a href="#实现-14" class="headerlink" title="实现"></a>实现</h4><p>设计一个遥控器，可以控制电灯开关。</p><p><img src="/../img/designPatterns/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-01.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOnCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    Light light;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightOnCommand</span><span class="params">(Light light)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOffCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    Light light;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightOffCommand</span><span class="params">(Light light)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        light.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Light is on!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Light is off!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command[] onCommands;</span><br><span class="line">    <span class="keyword">private</span> Command[] offCommands;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">slotNum</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onCommands = <span class="keyword">new</span> <span class="title class_">Command</span>[slotNum];</span><br><span class="line">        <span class="built_in">this</span>.offCommands = <span class="keyword">new</span> <span class="title class_">Command</span>[slotNum];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnCommand</span><span class="params">(Command command, <span class="type">int</span> slot)</span> &#123;</span><br><span class="line">        onCommands[slot] = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOffCommand</span><span class="params">(Command command, <span class="type">int</span> slot)</span> &#123;</span><br><span class="line">        offCommands[slot] = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onButtonWasPushed</span><span class="params">(<span class="type">int</span> slot)</span> &#123;</span><br><span class="line">        onCommands[slot].execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offButtonWasPushed</span><span class="params">(<span class="type">int</span> slot)</span> &#123;</span><br><span class="line">        offCommands[slot].execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invoker</span>();</span><br><span class="line">        <span class="type">Light</span> <span class="variable">light</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">        <span class="type">Command</span> <span class="variable">lightOnCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightOnCommand</span>(light);</span><br><span class="line">        <span class="type">Command</span> <span class="variable">lightOffCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightOffCommand</span>(light);</span><br><span class="line">        invoker.setOnCommand(lightOnCommand, <span class="number">0</span>);</span><br><span class="line">        invoker.setOffCommand(lightOffCommand, <span class="number">0</span>);</span><br><span class="line">        invoker.onButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">        invoker.offButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-行为型-观察者-Observer"><a href="#18-行为型-观察者-Observer" class="headerlink" title="18. 行为型 - 观察者(Observer)"></a>18. 行为型 - 观察者(Observer)</h3><h4 id="意图-16"><a href="#意图-16" class="headerlink" title="意图"></a>意图</h4><p>主题(Subject)是被观察的对象，而其所有依赖者(Observer)称为观察者。</p><p><img src="/../img/designPatterns/%E8%A7%82%E5%AF%9F%E8%80%85-01.jpeg"></p><h4 id="类图-17"><a href="#类图-17" class="headerlink" title="类图"></a>类图</h4><p>主题(Subject)具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p><p>观察者(Observer)的注册功能需要调用主题的 registerObserver()方法。</p><p><img src="/../img/designPatterns/Observer%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-15"><a href="#实现-15" class="headerlink" title="实现"></a>实现</h4><p>天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。</p><p><img src="/../img/designPatterns/%E8%A7%82%E5%AF%9F%E8%80%85-02.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">resisterObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherData</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherData</span><span class="params">()</span> &#123;</span><br><span class="line">        observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMeasurements</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resisterObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer o : observers) &#123;</span><br><span class="line">            o.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatisticsDisplay</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StatisticsDisplay</span><span class="params">(Subject weatherData)</span> &#123;</span><br><span class="line">        weatherData.resisterObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;StatisticsDisplay.update: &quot;</span> + temp + <span class="string">&quot; &quot;</span> + humidity + <span class="string">&quot; &quot;</span> + pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CurrentConditionsDisplay</span><span class="params">(Subject weatherData)</span> &#123;</span><br><span class="line">        weatherData.resisterObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CurrentConditionsDisplay.update: &quot;</span> + temp + <span class="string">&quot; &quot;</span> + humidity + <span class="string">&quot; &quot;</span> + pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherStation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WeatherData</span> <span class="variable">weatherData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherData</span>();</span><br><span class="line">        <span class="type">CurrentConditionsDisplay</span> <span class="variable">currentConditionsDisplay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CurrentConditionsDisplay</span>(weatherData);</span><br><span class="line">        <span class="type">StatisticsDisplay</span> <span class="variable">statisticsDisplay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StatisticsDisplay</span>(weatherData);</span><br><span class="line"></span><br><span class="line">        weatherData.setMeasurements(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CurrentConditionsDisplay.update: 0.0 0.0 0.0</span><br><span class="line">StatisticsDisplay.update: 0.0 0.0 0.0</span><br><span class="line">CurrentConditionsDisplay.update: 1.0 1.0 1.0</span><br><span class="line">StatisticsDisplay.update: 1.0 1.0 1.0</span><br></pre></td></tr></table></figure><h3 id="19-行为型-访问者-Visitor"><a href="#19-行为型-访问者-Visitor" class="headerlink" title="19. 行为型 - 访问者(Visitor)"></a>19. 行为型 - 访问者(Visitor)</h3><h4 id="意图-17"><a href="#意图-17" class="headerlink" title="意图"></a>意图</h4><p>为一个对象结构(比如组合结构)增加新能力</p><h4 id="类图-18"><a href="#类图-18" class="headerlink" title="类图"></a>类图</h4><ul><li>Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作</li><li>ConcreteVisitor：具体访问者，存储遍历过程中的累积结果</li><li>ObjectStructure：对象结构，可以是组合结构，或者是一个集合</li></ul><p><img src="/../img/designPatterns/Visitor%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-16"><a href="#实现-16" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomerGroup</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Customer&gt; customers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Customer customer : customers) &#123;</span><br><span class="line">            customer.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addCustomer</span><span class="params">(Customer customer)</span> &#123;</span><br><span class="line">        customers.add(customer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">Element</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Customer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        orders.add(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">for</span> (Order order : orders) &#123;</span><br><span class="line">            order.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> <span class="keyword">implements</span> <span class="title class_">Element</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Item&gt; items = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">    Order(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Order(String name, String itemName) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.addItem(<span class="keyword">new</span> <span class="title class_">Item</span>(itemName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        items.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">            item.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> <span class="keyword">implements</span> <span class="title class_">Element</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Item(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Customer customer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Order order)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Item item)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralReport</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> customersNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ordersNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> itemsNo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Customer customer)</span> &#123;</span><br><span class="line">        System.out.println(customer.getName());</span><br><span class="line">        customersNo++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        System.out.println(order.getName());</span><br><span class="line">        ordersNo++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        System.out.println(item.getName());</span><br><span class="line">        itemsNo++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayResults</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Number of customers: &quot;</span> + customersNo);</span><br><span class="line">        System.out.println(<span class="string">&quot;Number of orders:    &quot;</span> + ordersNo);</span><br><span class="line">        System.out.println(<span class="string">&quot;Number of items:     &quot;</span> + itemsNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;customer1&quot;</span>);</span><br><span class="line">        customer1.addOrder(<span class="keyword">new</span> <span class="title class_">Order</span>(<span class="string">&quot;order1&quot;</span>, <span class="string">&quot;item1&quot;</span>));</span><br><span class="line">        customer1.addOrder(<span class="keyword">new</span> <span class="title class_">Order</span>(<span class="string">&quot;order2&quot;</span>, <span class="string">&quot;item1&quot;</span>));</span><br><span class="line">        customer1.addOrder(<span class="keyword">new</span> <span class="title class_">Order</span>(<span class="string">&quot;order3&quot;</span>, <span class="string">&quot;item1&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="string">&quot;order_a&quot;</span>);</span><br><span class="line">        order.addItem(<span class="keyword">new</span> <span class="title class_">Item</span>(<span class="string">&quot;item_a1&quot;</span>));</span><br><span class="line">        order.addItem(<span class="keyword">new</span> <span class="title class_">Item</span>(<span class="string">&quot;item_a2&quot;</span>));</span><br><span class="line">        order.addItem(<span class="keyword">new</span> <span class="title class_">Item</span>(<span class="string">&quot;item_a3&quot;</span>));</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;customer2&quot;</span>);</span><br><span class="line">        customer2.addOrder(order);</span><br><span class="line"></span><br><span class="line">        <span class="type">CustomerGroup</span> <span class="variable">customers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomerGroup</span>();</span><br><span class="line">        customers.addCustomer(customer1);</span><br><span class="line">        customers.addCustomer(customer2);</span><br><span class="line"></span><br><span class="line">        <span class="type">GeneralReport</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralReport</span>();</span><br><span class="line">        customers.accept(visitor);</span><br><span class="line">        visitor.displayResults();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">customer1</span><br><span class="line">order1</span><br><span class="line">item1</span><br><span class="line">order2</span><br><span class="line">item1</span><br><span class="line">order3</span><br><span class="line">item1</span><br><span class="line">customer2</span><br><span class="line">order_a</span><br><span class="line">item_a1</span><br><span class="line">item_a2</span><br><span class="line">item_a3</span><br><span class="line">Number of customers: <span class="number">2</span></span><br><span class="line">Number of orders:    <span class="number">4</span></span><br><span class="line">Number of items:     <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="20-行为型-状态-State"><a href="#20-行为型-状态-State" class="headerlink" title="20. 行为型 - 状态(State)"></a>20. 行为型 - 状态(State)</h3><h4 id="意图-18"><a href="#意图-18" class="headerlink" title="意图"></a>意图</h4><p>允许对象在内部状态改变时，改变它的行为，对象看起来好像修改了它所属的类。</p><h4 id="类图-19"><a href="#类图-19" class="headerlink" title="类图"></a>类图</h4><p><img src="/../img/designPatterns/State%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-17"><a href="#实现-17" class="headerlink" title="实现"></a>实现</h4><p>糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。</p><p><img src="/../img/designPatterns/%E7%8A%B6%E6%80%81-01.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 投入 25 分钱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 退回 25 分钱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转动曲柄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发放糖果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HasQuarterState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HasQuarterState</span><span class="params">(GumballMachine gumballMachine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You can&#x27;t insert another quarter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Quarter returned&quot;</span>);</span><br><span class="line">        gumballMachine.setState(gumballMachine.getNoQuarterState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You turned...&quot;</span>);</span><br><span class="line">        gumballMachine.setState(gumballMachine.getSoldState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;No gumball dispensed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoQuarterState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    GumballMachine gumballMachine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NoQuarterState</span><span class="params">(GumballMachine gumballMachine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You insert a quarter&quot;</span>);</span><br><span class="line">        gumballMachine.setState(gumballMachine.getHasQuarterState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You haven&#x27;t insert a quarter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You turned, but there&#x27;s no quarter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You need to pay first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoldOutState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    GumballMachine gumballMachine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SoldOutState</span><span class="params">(GumballMachine gumballMachine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You can&#x27;t insert a quarter, the machine is sold out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You can&#x27;t eject, you haven&#x27;t inserted a quarter yet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You turned, but there are no gumballs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;No gumball dispensed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoldState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    GumballMachine gumballMachine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SoldState</span><span class="params">(GumballMachine gumballMachine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Please wait, we&#x27;re already giving you a gumball&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sorry, you already turned the crank&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Turning twice doesn&#x27;t get you another gumball!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span> &#123;</span><br><span class="line">        gumballMachine.releaseBall();</span><br><span class="line">        <span class="keyword">if</span> (gumballMachine.getCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            gumballMachine.setState(gumballMachine.getNoQuarterState());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Oops, out of gumballs&quot;</span>);</span><br><span class="line">            gumballMachine.setState(gumballMachine.getSoldOutState());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GumballMachine</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> State soldOutState;</span><br><span class="line">    <span class="keyword">private</span> State noQuarterState;</span><br><span class="line">    <span class="keyword">private</span> State hasQuarterState;</span><br><span class="line">    <span class="keyword">private</span> State soldState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GumballMachine</span><span class="params">(<span class="type">int</span> numberGumballs)</span> &#123;</span><br><span class="line">        count = numberGumballs;</span><br><span class="line">        soldOutState = <span class="keyword">new</span> <span class="title class_">SoldOutState</span>(<span class="built_in">this</span>);</span><br><span class="line">        noQuarterState = <span class="keyword">new</span> <span class="title class_">NoQuarterState</span>(<span class="built_in">this</span>);</span><br><span class="line">        hasQuarterState = <span class="keyword">new</span> <span class="title class_">HasQuarterState</span>(<span class="built_in">this</span>);</span><br><span class="line">        soldState = <span class="keyword">new</span> <span class="title class_">SoldState</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numberGumballs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            state = noQuarterState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            state = soldOutState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        state.insertQuarter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        state.ejectQuarter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span> &#123;</span><br><span class="line">        state.turnCrank();</span><br><span class="line">        state.dispense();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseBall</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A gumball comes rolling out the slot...&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            count -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getSoldOutState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> soldOutState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getNoQuarterState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> noQuarterState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getHasQuarterState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hasQuarterState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getSoldState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> soldState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GumballMachine</span> <span class="variable">gumballMachine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GumballMachine</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        gumballMachine.insertQuarter();</span><br><span class="line">        gumballMachine.turnCrank();</span><br><span class="line"></span><br><span class="line">        gumballMachine.insertQuarter();</span><br><span class="line">        gumballMachine.ejectQuarter();</span><br><span class="line">        gumballMachine.turnCrank();</span><br><span class="line"></span><br><span class="line">        gumballMachine.insertQuarter();</span><br><span class="line">        gumballMachine.turnCrank();</span><br><span class="line">        gumballMachine.insertQuarter();</span><br><span class="line">        gumballMachine.turnCrank();</span><br><span class="line">        gumballMachine.ejectQuarter();</span><br><span class="line"></span><br><span class="line">        gumballMachine.insertQuarter();</span><br><span class="line">        gumballMachine.insertQuarter();</span><br><span class="line">        gumballMachine.turnCrank();</span><br><span class="line">        gumballMachine.insertQuarter();</span><br><span class="line">        gumballMachine.turnCrank();</span><br><span class="line">        gumballMachine.insertQuarter();</span><br><span class="line">        gumballMachine.turnCrank();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">You insert a quarter</span><br><span class="line">You turned...</span><br><span class="line">A gumball comes rolling out the slot...</span><br><span class="line">You insert a quarter</span><br><span class="line">Quarter returned</span><br><span class="line">You turned, but there<span class="string">&#x27;s no quarter</span></span><br><span class="line"><span class="string">You need to pay first</span></span><br><span class="line"><span class="string">You insert a quarter</span></span><br><span class="line"><span class="string">You turned...</span></span><br><span class="line"><span class="string">A gumball comes rolling out the slot...</span></span><br><span class="line"><span class="string">You insert a quarter</span></span><br><span class="line"><span class="string">You turned...</span></span><br><span class="line"><span class="string">A gumball comes rolling out the slot...</span></span><br><span class="line"><span class="string">You haven&#x27;</span>t insert a quarter</span><br><span class="line">You insert a quarter</span><br><span class="line">You can<span class="string">&#x27;t insert another quarter</span></span><br><span class="line"><span class="string">You turned...</span></span><br><span class="line"><span class="string">A gumball comes rolling out the slot...</span></span><br><span class="line"><span class="string">You insert a quarter</span></span><br><span class="line"><span class="string">You turned...</span></span><br><span class="line"><span class="string">A gumball comes rolling out the slot...</span></span><br><span class="line"><span class="string">Oops, out of gumballs</span></span><br><span class="line"><span class="string">You can&#x27;</span>t insert a quarter, the machine is sold out</span><br><span class="line">You turned, but there are no gumballs</span><br><span class="line">No gumball dispensed</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="21-行为型-解释器-Interpreter"><a href="#21-行为型-解释器-Interpreter" class="headerlink" title="21. 行为型 - 解释器(Interpreter)"></a>21. 行为型 - 解释器(Interpreter)</h3><h4 id="意图-19"><a href="#意图-19" class="headerlink" title="意图"></a>意图</h4><p>为语言创建解释器，通常由语言的语法和语法分析来定义。</p><h4 id="类图-20"><a href="#类图-20" class="headerlink" title="类图"></a>类图</h4><ul><li>TerminalExpression：终结符表达式，每个终结符都需要一个 TerminalExpression</li><li>Context：上下文，包含解释器之外的一些全局信息</li></ul><p><img src="/../img/designPatterns/Interpreter%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-18"><a href="#实现-18" class="headerlink" title="实现"></a>实现</h4><p>以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。</p><p>例如一颗解析树为 D And (A or (B C))，文本 “D A”满足该解析树定义的规则。</p><p>这里的 Context 指的是 String。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TerminalExpression</span> <span class="keyword">extends</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">literal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TerminalExpression</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        literal = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">StringTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(str);</span><br><span class="line">        <span class="keyword">while</span> (st.hasMoreTokens()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> st.nextToken();</span><br><span class="line">            <span class="keyword">if</span> (test.equals(literal)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AndExpression</span> <span class="keyword">extends</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Expression</span> <span class="variable">expression1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Expression</span> <span class="variable">expression2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AndExpression</span><span class="params">(Expression expression1, Expression expression2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.expression1 = expression1;</span><br><span class="line">        <span class="built_in">this</span>.expression2 = expression2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> expression1.interpret(str) &amp;&amp; expression2.interpret(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrExpression</span> <span class="keyword">extends</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Expression</span> <span class="variable">expression1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Expression</span> <span class="variable">expression2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrExpression</span><span class="params">(Expression expression1, Expression expression2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.expression1 = expression1;</span><br><span class="line">        <span class="built_in">this</span>.expression2 = expression2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> expression1.interpret(str) || expression2.interpret(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建解析树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title function_">buildInterpreterTree</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Literal</span></span><br><span class="line">        <span class="type">Expression</span> <span class="variable">terminal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TerminalExpression</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="type">Expression</span> <span class="variable">terminal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TerminalExpression</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="type">Expression</span> <span class="variable">terminal3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TerminalExpression</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        <span class="type">Expression</span> <span class="variable">terminal4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TerminalExpression</span>(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">        <span class="comment">// B C</span></span><br><span class="line">        <span class="type">Expression</span> <span class="variable">alternation1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrExpression</span>(terminal2, terminal3);</span><br><span class="line">        <span class="comment">// A Or (B C)</span></span><br><span class="line">        <span class="type">Expression</span> <span class="variable">alternation2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrExpression</span>(terminal1, alternation1);</span><br><span class="line">        <span class="comment">// D And (A Or (B C))</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AndExpression</span>(terminal4, alternation2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Expression</span> <span class="variable">define</span> <span class="operator">=</span> buildInterpreterTree();</span><br><span class="line">        <span class="type">String</span> <span class="variable">context1</span> <span class="operator">=</span> <span class="string">&quot;D A&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">context2</span> <span class="operator">=</span> <span class="string">&quot;A B&quot;</span>;</span><br><span class="line">        System.out.println(define.interpret(context1));</span><br><span class="line">        System.out.println(define.interpret(context2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h3 id="22-行为型-迭代器-Iterator"><a href="#22-行为型-迭代器-Iterator" class="headerlink" title="22. 行为型 - 迭代器(Iterator)"></a>22. 行为型 - 迭代器(Iterator)</h3><h4 id="意图-20"><a href="#意图-20" class="headerlink" title="意图"></a>意图</h4><p>提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。</p><h4 id="类图-21"><a href="#类图-21" class="headerlink" title="类图"></a>类图</h4><ul><li>Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator；</li><li>Iterator 主要定义了 ha sNext() 和 next() 方法。</li><li>Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。</li></ul><p><img src="/../img/designPatterns/Iterator%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-19"><a href="#实现-19" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line">    Iterator <span class="title function_">createIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer[] items;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteAggregate</span><span class="params">()</span> &#123;</span><br><span class="line">        items = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            items[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>&lt;Integer&gt;(items);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;Item&gt; &#123;</span><br><span class="line">    Item <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span>&lt;Item&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Item[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">(Item[] items)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[position++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; items.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Aggregate</span> <span class="variable">aggregate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteAggregate</span>();</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = aggregate.createIterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-行为型-中介者-Mediator"><a href="#23-行为型-中介者-Mediator" class="headerlink" title="23. 行为型 - 中介者(Mediator)"></a>23. 行为型 - 中介者(Mediator)</h3><h4 id="意图-21"><a href="#意图-21" class="headerlink" title="意图"></a>意图</h4><p>集中相关对象之间复杂的沟通和控制方式。</p><h4 id="类图-22"><a href="#类图-22" class="headerlink" title="类图"></a>类图</h4><ul><li>Mediator：中介者，定义一个接口用于与各同时(Colleague)对象通信。</li><li>Colleague：同事，相关对象</li></ul><p><img src="/../img/designPatterns/Mediator%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-20"><a href="#实现-20" class="headerlink" title="实现"></a>实现</h4><p>Alarm(闹钟)、CoffeePot(咖啡壶)、Calendar(日历)、Sprinkler(喷头)是一组相关的对象，在某个对象的时间产生时需要去操作其它对象，形成了下面这种依赖结构：</p><p><img src="/../img/designPatterns/%E4%B8%AD%E4%BB%8B%E8%80%85-01.jpeg"></p><p><img src="/../img/designPatterns/%E4%B8%AD%E4%BB%8B%E8%80%85-02.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Mediator mediator)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alarm</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        mediator.doEvent(<span class="string">&quot;alarm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAlarm</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doAlarm()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeePot</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        mediator.doEvent(<span class="string">&quot;coffeePot&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCoffeePot</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doCoffeePot()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calender</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        mediator.doEvent(<span class="string">&quot;calender&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCalender</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doCalender()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sprinkler</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        mediator.doEvent(<span class="string">&quot;sprinkler&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSprinkler</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSprinkler()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doEvent</span><span class="params">(String eventType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Alarm alarm;</span><br><span class="line">    <span class="keyword">private</span> CoffeePot coffeePot;</span><br><span class="line">    <span class="keyword">private</span> Calender calender;</span><br><span class="line">    <span class="keyword">private</span> Sprinkler sprinkler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteMediator</span><span class="params">(Alarm alarm, CoffeePot coffeePot, Calender calender, Sprinkler sprinkler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.alarm = alarm;</span><br><span class="line">        <span class="built_in">this</span>.coffeePot = coffeePot;</span><br><span class="line">        <span class="built_in">this</span>.calender = calender;</span><br><span class="line">        <span class="built_in">this</span>.sprinkler = sprinkler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doEvent</span><span class="params">(String eventType)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;alarm&quot;</span>:</span><br><span class="line">                doAlarmEvent();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;coffeePot&quot;</span>:</span><br><span class="line">                doCoffeePotEvent();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;calender&quot;</span>:</span><br><span class="line">                doCalenderEvent();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                doSprinklerEvent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAlarmEvent</span><span class="params">()</span> &#123;</span><br><span class="line">        alarm.doAlarm();</span><br><span class="line">        coffeePot.doCoffeePot();</span><br><span class="line">        calender.doCalender();</span><br><span class="line">        sprinkler.doSprinkler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCoffeePotEvent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCalenderEvent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSprinklerEvent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Alarm</span> <span class="variable">alarm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Alarm</span>();</span><br><span class="line">        <span class="type">CoffeePot</span> <span class="variable">coffeePot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CoffeePot</span>();</span><br><span class="line">        <span class="type">Calender</span> <span class="variable">calender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calender</span>();</span><br><span class="line">        <span class="type">Sprinkler</span> <span class="variable">sprinkler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sprinkler</span>();</span><br><span class="line">        <span class="type">Mediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteMediator</span>(alarm, coffeePot, calender, sprinkler);</span><br><span class="line">        <span class="comment">// 闹钟事件到达，调用中介者就可以操作相关对象</span></span><br><span class="line">        alarm.onEvent(mediator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doAlarm()</span><br><span class="line">doCoffeePot()</span><br><span class="line">doCalender()</span><br><span class="line">doSprinkler()</span><br></pre></td></tr></table></figure><h3 id="24-行为型-备忘录-Memento"><a href="#24-行为型-备忘录-Memento" class="headerlink" title="24. 行为型 - 备忘录(Memento)"></a>24. 行为型 - 备忘录(Memento)</h3><h4 id="意图-22"><a href="#意图-22" class="headerlink" title="意图"></a>意图</h4><p>在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。</p><h4 id="类图-23"><a href="#类图-23" class="headerlink" title="类图"></a>类图</h4><ul><li>Originator：原始对象</li><li>Caretaker：负责保存好备忘录</li><li>Memento：备忘录，存储原始对象的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况下只允许 Originator 访问本备忘录的内部状态。</li></ul><p><img src="/../img/designPatterns/Memento%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-21"><a href="#实现-21" class="headerlink" title="实现"></a>实现</h4><p>以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create Memento</span></span><br><span class="line">    PreviousCalculationToCareTaker <span class="title function_">backupLastCalculation</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setMemento</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">restorePreviousCalculation</span><span class="params">(PreviousCalculationToCareTaker memento)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getCalculationResult</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setFirstNumber</span><span class="params">(<span class="type">int</span> firstNumber)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setSecondNumber</span><span class="params">(<span class="type">int</span> secondNumber)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorImp</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> firstNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> secondNumber;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PreviousCalculationToCareTaker <span class="title function_">backupLastCalculation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// create a memento object used for restoring two numbers</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PreviousCalculationImp</span>(firstNumber, secondNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restorePreviousCalculation</span><span class="params">(PreviousCalculationToCareTaker memento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstNumber = ((PreviousCalculationToOriginator) memento).getFirstNumber();</span><br><span class="line">        <span class="built_in">this</span>.secondNumber = ((PreviousCalculationToOriginator) memento).getSecondNumber();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCalculationResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// result is adding two numbers</span></span><br><span class="line">        <span class="keyword">return</span> firstNumber + secondNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirstNumber</span><span class="params">(<span class="type">int</span> firstNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstNumber = firstNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecondNumber</span><span class="params">(<span class="type">int</span> secondNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.secondNumber = secondNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PreviousCalculationToOriginator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getFirstNumber</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getSecondNumber</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PreviousCalculationToCareTaker</span> &#123;</span><br><span class="line">    <span class="comment">// no operations permitted for the caretaker</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreviousCalculationImp</span> <span class="keyword">implements</span> <span class="title class_">PreviousCalculationToCareTaker</span>,</span><br><span class="line">        PreviousCalculationToOriginator &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> firstNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> secondNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PreviousCalculationImp</span><span class="params">(<span class="type">int</span> firstNumber, <span class="type">int</span> secondNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstNumber = firstNumber;</span><br><span class="line">        <span class="built_in">this</span>.secondNumber = secondNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirstNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSecondNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> secondNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// program starts</span></span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalculatorImp</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// assume user enters two numbers</span></span><br><span class="line">        calculator.setFirstNumber(<span class="number">10</span>);</span><br><span class="line">        calculator.setSecondNumber(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find result</span></span><br><span class="line">        System.out.println(calculator.getCalculationResult());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Store result of this calculation in case of error</span></span><br><span class="line">        <span class="type">PreviousCalculationToCareTaker</span> <span class="variable">memento</span> <span class="operator">=</span> calculator.backupLastCalculation();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// user enters a number</span></span><br><span class="line">        calculator.setFirstNumber(<span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// user enters a wrong second number and calculates result</span></span><br><span class="line">        calculator.setSecondNumber(-<span class="number">290</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// calculate result</span></span><br><span class="line">        System.out.println(calculator.getCalculationResult());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// user hits CTRL + Z to undo last operation and see last result</span></span><br><span class="line">        calculator.restorePreviousCalculation(memento);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// result restored</span></span><br><span class="line">        System.out.println(calculator.getCalculationResult());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">110</span><br><span class="line">-273</span><br><span class="line">110</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2022/12/12/Spring/"/>
      <url>/2022/12/12/Spring/</url>
      
        <content type="html"><![CDATA[<p><strong>控制反转 Ioc  , 面向切面 Aop</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--bean就是java对象 , 由Spring创建和管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gorilla.pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于注解开发"><a href="#基于注解开发" class="headerlink" title="基于注解开发"></a>基于注解开发</h3><blockquote><p>@Component</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;user&quot;)</span></span><br><span class="line"><span class="comment">//相当于配置文件中的&lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    <span class="comment">//@Value(&quot;zhangsan&quot;)</span></span><br><span class="line">    <span class="comment">//public String name;</span></span><br><span class="line">    <span class="comment">//@Value(&quot;zhangsan&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Component三个衍生注解</strong></p><blockquote><p>@Controller : web层</p></blockquote><blockquote><p>@Service : service层</p></blockquote><blockquote><p>@Repository : dao层</p></blockquote><p>加上这些注解，就相当于这个类交给了Spring管理装配了</p><p><strong>自动装配</strong></p><p>@Autowired : 根据byType自动装配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//允许字段为空，默认是true，不允许</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br></pre></td></tr></table></figure><p>@Qualifier : 不能单独使用，搭配@Autowired可以实现根据byName自动装配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;bean id&quot;)</span></span><br></pre></td></tr></table></figure><p>@Resource : 如果指定了name属性，则先根据该属性进行byName装配；其次进行默认的byName方式进行装配；如果都不成功，则按byType自动转配，在不成功就报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果允许对象为空，设置required = false，默认为true</span></span><br><span class="line"><span class="meta">@Resource(name = &quot;bean id&quot;, required = false)</span></span><br></pre></td></tr></table></figure><blockquote><p>@Scope    作用域</p></blockquote><ul><li>singleton : 默认的，Spring会采用单例模式创建这个对象。关闭工厂，所有的对象都会销毁。</li><li>prototype : 多例模式，关闭工厂，所有的对象不会销毁。内部的垃圾回收机制会回收。</li></ul><blockquote><p>@Configuration</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//代表这是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//通过方法注册一个bean，这里的返回值就是Bean的类型，方法名就是bean的id</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴JAVA开发手册</title>
      <link href="/2022/12/12/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4JAVA%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/"/>
      <url>/2022/12/12/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4JAVA%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="一、编程规约"><a href="#一、编程规约" class="headerlink" title="一、编程规约"></a>一、编程规约</h3><h4 id="一-命名风格"><a href="#一-命名风格" class="headerlink" title="(一) 命名风格"></a>(一) 命名风格</h4><ul><li><p>类名使用大驼峰(UpperCamelCase)风格，但是如果类名包含<code>DO/BO/DTO/VO/AO/PO/UID</code>等，以下必须大写。例如：UserDO&#x2F;UserDTO</p></li><li><p>方法名、参数名、成员变量、局部变量统一使用小驼峰(lowerCamelCase)风格，必须遵从驼峰形式。</p></li><li><p>常量命名全部大写，单词间用下划线隔开，要求语义表达完整，即使名字长也没关系。</p></li><li><p>抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类 命名以它要测试的类的名称开始，以 Test 结尾。</p></li><li><p>包名统一使用小写，单数形式，类名如果有复数含义，类名可以使用复数形式。例如：应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils</p></li><li><p>杜绝完全不规范的缩写，避免望文不知义。</p></li><li><p>接口类中的方法和属性不要加任何修饰符号。</p></li><li><p>各层命名规约： </p><ul><li>A) Service&#x2F;DAO 层方法命名规约 <ul><li>1） 获取单个对象的方法用 get 做前缀。</li><li>2） 获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。 </li><li>3） 获取统计值的方法用 count 做前缀。 </li><li>4） 插入的方法用 save&#x2F;insert 做前缀。 </li><li>5） 删除的方法用 remove&#x2F;delete 做前缀。 </li><li>6） 修改的方法用 update 做前缀。</li></ul></li><li>B) 领域模型命名规约 <ul><li>1） 数据对象：xxxDO，xxx 即为数据表名。 </li><li>2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。 </li><li>3） 展示对象：xxxVO，xxx 一般为网页名称。 </li><li>4） POJO 是 DO&#x2F;DTO&#x2F;BO&#x2F;VO 的统称，禁止命名成 xxxPOJO。</li></ul></li></ul></li></ul><h4 id="二-常量定义"><a href="#二-常量定义" class="headerlink" title="(二) 常量定义"></a>(二) 常量定义</h4><ul><li>在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数 字 1 混淆，造成误解。</li></ul><h4 id="三-代码格式"><a href="#三-代码格式" class="headerlink" title="(三) 代码格式"></a>(三) 代码格式</h4><ul><li><p>如果是大括号内为空，则简洁地写成{}即可，大括号中间无需换行和空格</p></li><li><p>左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格；而左 大括号前需要空格。</p></li><li><p>if&#x2F;for&#x2F;while&#x2F;switch&#x2F;do 等保留字与括号之间都必须加空格。</p></li><li><p>任何二目、三目运算符的左右两边都需要加一个空格。(“+”  “-“  “*”  “&#x2F;“  “&#x3D;”  “&amp;&amp;”  “||”)</p></li><li><p>注释的双斜线与注释内容之间有且仅有一个空格。</p></li><li><p>在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开。<code>long first = 1000000000000L; int second = (int)first + 2; </code></p></li><li><p>方法参数在定义和传入时，多个参数逗号后边必须加空格。</p></li></ul><h4 id="四-规约"><a href="#四-规约" class="headerlink" title="(四) 规约"></a>(四) 规约</h4><ul><li><p>避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析 成本，直接用类名来访问即可。</p></li><li><p>所有的覆写方法，必须加@Override 注解。</p></li><li><p>相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）</p></li><li><p>外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产 生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。</p></li><li><p>不能使用过时的类或方法。</p></li><li><p>Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</p></li><li><p>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</p></li><li><p>定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。数据库字段的 bigint 必须与类属性的 Long 类型相对应。</p></li><li><p>所有的 POJO 类属性必须使用包装数据类型。RPC 方法的返回值和参数必须使用包装数据类型。所有的局部变量使用基本数据类型。</p></li><li><p>定义 DO&#x2F;DTO&#x2F;VO 等 POJO 类时，不要设定任何属性默认值。</p></li><li><p>序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果 完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。</p></li><li><p>构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。</p></li><li><p>POJO 类必须写 toString 方法。</p></li><li><p>类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter &#x2F; setter 方法。</p></li></ul><h4 id="五-集合处理"><a href="#五-集合处理" class="headerlink" title="(五) 集合处理"></a>(五) 集合处理</h4><h4 id="六-并发处理"><a href="#六-并发处理" class="headerlink" title="(六) 并发处理"></a>(六) 并发处理</h4><ul><li><p>获取单例对象需要保证线程安全，其中的方法也要保证线程安全</p></li><li><p>创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</p></li><li><p>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p></li><li><p>高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁； 能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</p></li><li><p>对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会 造成死锁。</p></li><li><p>在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代 码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。</p></li></ul><h4 id="七-控制语句"><a href="#七-控制语句" class="headerlink" title="(七) 控制语句"></a>(七) 控制语句</h4><ul><li>在一个 switch 块内，每个 case 要么通过 continue&#x2F;break&#x2F;return 等来终止，要么 注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。注意 break 是退出 switch 语句块，而 return 是退出方法体。</li><li>在 if&#x2F;else&#x2F;for&#x2F;while&#x2F;do 语句中必须使用大括号。</li><li>在高并发场景中，避免使用”等于”判断作为中断或退出的条件。</li></ul><h4 id="八-注释规约"><a href="#八-注释规约" class="headerlink" title="(八) 注释规约"></a>(八) 注释规约</h4><ul><li>类、类属性、类方法的注释必须使用 Javadoc 规范，使用&#x2F;*<em>内容</em>&#x2F;格式，不得使用 &#x2F;&#x2F; xxx 方式。</li><li>所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。</li><li>所有的类都必须添加创建者和创建日期。</li><li>方法内部单行注释，在被注释语句上方另起一行，使用&#x2F;&#x2F;注释。方法内部多行注释 使用&#x2F;* *&#x2F;注释，注意与代码对齐。</li><li>所有的枚举类型字段必须要有注释，说明每个数据项的用途。</li></ul><h4 id="九-其他"><a href="#九-其他" class="headerlink" title="(九) 其他"></a>(九) 其他</h4><ul><li>在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。</li><li>注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够 取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后 取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。</li><li>获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();</li><li>日期格式化时，传入 pattern 中表示年份统一使用小写的 y。表示月份是大写的 M；表示分钟则是小写的 m；24 小时制的是大写的 H；12 小时制的则是小写的 h。new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);</li></ul><h3 id="二、异常日志"><a href="#二、异常日志" class="headerlink" title="二、异常日志"></a>二、异常日志</h3><h4 id="一-异常处理"><a href="#一-异常处理" class="headerlink" title="(一) 异常处理"></a>(一) 异常处理</h4><ul><li>Java 类库中定义的可以通过预检查方式规避的 RuntimeException 异常不应该通 过 catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等 等。</li><li>异常不要用来做流程控制，条件控制。</li><li>catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。 对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。</li><li>捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它， 请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理 解的内容。</li><li>有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回 滚事务。</li><li>finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。</li><li>不要在 finally 块中使用 return。</li><li>捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类</li><li>在调用 RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用 Throwable 类来进行拦截。</li></ul><h4 id="二-日志规约"><a href="#二-日志规约" class="headerlink" title="(二) 日志规约"></a>(二) 日志规约</h4><ul><li>应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</li><li>所有日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。网络 运行状态、安全相关信息、系统监测、管理后台操作、用户敏感操作需要留存相关的网络日 志不少于 6 个月。</li><li>应用中的扩展日志（如打点、临时监控、访问日志等）命名方式： appName_logType_logName.log。logType:日志类型，如 stats&#x2F;monitor&#x2F;access 等；logName:日志 描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归 类查找。</li><li>在日志输出时，字符串变量之间的拼接使用占位符的方式。</li><li>对于 trace&#x2F;debug&#x2F;info 级别的日志输出，必须进行日志级别的开关判断。</li><li>避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity&#x3D;false。</li><li>异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通 过关键字 throws 往上抛出。</li></ul><h3 id="三、单元测试"><a href="#三、单元测试" class="headerlink" title="三、单元测试"></a>三、单元测试</h3><ul><li>好的单元测试必须遵守 AIR 原则。</li><li>单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的， 执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。 单元测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。</li><li>保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之 间决不能互相调用，也不能依赖执行的先后次序。</li><li>单元测试是可以重复执行的，不能受到外界环境的影响。</li><li>对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类 级别，一般是方法级别。</li><li>核心业务、核心应用、核心模块的增量代码确保单元测试通过。</li><li>单元测试代码必须写在如下工程目录：src&#x2F;test&#x2F;java，不允许写在业务代码目录下。</li></ul><h3 id="四、安全规约"><a href="#四、安全规约" class="headerlink" title="四、安全规约"></a>四、安全规约</h3><ul><li>隶属于用户个人的页面或者功能必须进行权限控制校验。</li><li>用户敏感数据禁止直接展示，必须对展示数据进行脱敏。中国大陆个人手机号码显示为:137****0969，隐藏中间 4 位，防止隐私泄露。</li><li>用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注 入，禁止字符串拼接 SQL 访问数据库。</li><li>用户请求传入的任何参数必须做有效性验证。</li><li>禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。</li><li>表单、AJAX 提交必须执行 CSRF 安全验证。</li><li>在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的 机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。</li></ul><h3 id="五、MySQL数据库"><a href="#五、MySQL数据库" class="headerlink" title="五、MySQL数据库"></a>五、MySQL数据库</h3><h4 id="一-建表规约"><a href="#一-建表规约" class="headerlink" title="(一) 建表规约"></a>(一) 建表规约</h4><ul><li>表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在设置从 is_xxx 到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取 值含义与取值范围。</li><li>表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间 只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重 考虑。</li><li>表名不使用复数名词。</li><li>禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</li><li>主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。</li><li>小数类型为 decimal，禁止使用 float 和 double。</li><li>如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</li><li>varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长 度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。</li><li>表必备三字段：id, create_time, update_time。</li></ul><h4 id="二-索引规约"><a href="#二-索引规约" class="headerlink" title="(二) 索引规约"></a>(二) 索引规约</h4><ul><li>业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。</li><li>超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询 时，保证被关联的字段需要有索引。</li><li>在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度即可。</li><li>页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</li></ul><h4 id="三-SQL语句"><a href="#三-SQL语句" class="headerlink" title="(三) SQL语句"></a>(三) SQL语句</h4><ul><li>不要使用 count(列名)或 count(常量)来替代 count(<em>)，count(</em>)是 SQL92 定义的 标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。</li><li>count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</li><li>当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果 为 NULL，因此使用 sum()时需注意 NPE 问题。</li><li>使用 ISNULL()来判断是否为 NULL 值。</li><li>代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</li><li>不得使用外键与级联，一切外键概念必须在应用层解决。</li><li>禁止使用存储过程，存储过程难以调试和扩展，更没有移植性</li><li>数据订正（特别是删除、修改记录操作）时，要先 select，避免出现误删除，确认无 误才能执行更新语句。</li></ul><h4 id="四-ORM映射"><a href="#四-ORM映射" class="headerlink" title="(四) ORM映射"></a>(四) ORM映射</h4><ul><li>在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。</li><li>POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行 字段与属性之间的映射。</li><li>不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要 定义；反过来，每一个表也必然有一个 POJO 类与之对应。</li><li>sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。</li><li>iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。</li><li>不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。</li><li>更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。</li></ul><h3 id="六、工程结构"><a href="#六、工程结构" class="headerlink" title="六、工程结构"></a>六、工程结构</h3><h4 id="一-应用分层"><a href="#一-应用分层" class="headerlink" title="(一) 应用分层"></a>(一) 应用分层</h4><ul><li>图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于 Web 层，也可以直接依赖于 Service 层，依此类推：</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 开放接口层：可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；进行网关安全控制、流量控制等。</span><br><span class="line"><span class="bullet">-</span> 终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。</span><br><span class="line"><span class="bullet">-</span> Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</span><br><span class="line"><span class="bullet">-</span> Service 层：相对具体的业务逻辑服务层。</span><br><span class="line"><span class="bullet">-</span> Manager 层：通用业务处理层，它有如下特征：</span><br><span class="line"><span class="bullet">-</span> 对第三方平台封装的层，预处理返回结果及转化异常信息。</span><br><span class="line"><span class="bullet">-</span> 对 Service 层通用能力的下沉，如缓存方案、中间件通用处理。</span><br><span class="line"><span class="bullet">-</span> 与 DAO 层交互，对多个 DAO 的组合复用。 </span><br><span class="line"><span class="bullet">-</span> DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase 等进行数据交互。</span><br><span class="line"><span class="bullet">-</span> 外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。</span><br></pre></td></tr></table></figure><ul><li>分层领域模型规约：<ul><li>DO（Data Object）：此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</li><li>DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。</li><li>BO（Business Object）：业务对象，由 Service 层输出的封装业务逻辑的对象。</li><li>AO（Application Object）：应用对象，在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</li><li>VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li><li>Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类 来传输。</li></ul></li></ul><h4 id="二-二方库依赖"><a href="#二-二方库依赖" class="headerlink" title="(二) 二方库依赖"></a>(二) 二方库依赖</h4><ul><li><p>定义 GAV 遵从以下规则： </p><ul><li>GroupID 格式：com.{公司&#x2F;BU }.业务线 [.子业务线]，最多 4 级。 </li><li>ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。  </li><li>Version：详细规定参考下方。</li></ul></li><li><p>二方库版本号命名方式：主版本号.次版本号.修订号</p><ul><li>主版本号：产品方向改变，或者大规模 API 不兼容，或者架构不兼容升级。</li><li>次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的 API 不兼容修改。</li><li>修订号：保持完全兼容性，修复 BUG、新增次要功能特性等。</li></ul></li><li><p>线上应用不要依赖 SNAPSHOT 版本（安全包除外）。</p></li><li><p>二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变， 必须明确评估和验证。</p></li><li><p>二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用 枚举类型或者包含枚举类型的 POJO 对象。</p></li><li><p>依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。</p></li><li><p>禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的 Version。</p></li></ul><h4 id="三-服务器"><a href="#三-服务器" class="headerlink" title="(三) 服务器"></a>(三) 服务器</h4><ul><li>高并发服务器建议调小 TCP 协议的 time_wait 超时时间。</li><li>调大服务器所支持的最大文件句柄数（File Descriptor，简写为 fd）。</li><li>给 JVM 环境参数设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出 dump 信息。</li><li>在线上生产环境，JVM 的 Xms 和 Xmx 设置一样大小的内存容量，避免在 GC 后调整 堆大小带来的压力。</li></ul><h3 id="七、设计规约"><a href="#七、设计规约" class="headerlink" title="七、设计规约"></a>七、设计规约</h3><ul><li><p>存储方案和底层数据结构的设计获得评审一致通过，并沉淀成为文档。 说明：有缺陷的底层数据结构容易导致系统风险上升，可扩展性下降，重构成本也会因历史数据迁移和系 统平滑过渡而陡然增加，所以，存储方案和数据结构需要认真地进行设计和评审，生产环境提交执行后， 需要进行 double check。</p></li><li><p>在需求分析阶段，如果与系统交互的 User 超过一类并且相关的 User Case 超过 5 个，使用用例图来表达更加清晰的结构化需求。</p></li><li><p>如果某个业务对象的状态超过 3 个，使用状态图来表达并且明确状态变化的各个触 发条件。</p></li><li><p>如果系统中某个功能的调用链路上的涉及对象超过 3 个，使用时序图来表达并且明 确各调用环节的输入与输出。</p></li><li><p>如果系统中模型类超过 5 个，并且存在复杂的依赖关系，使用类图来表达并且明确 类之间的关系。</p></li><li><p>如果系统中超过 2 个对象之间存在协作关系，并且需要表示复杂的处理流程，使用 活动图来表示。</p></li></ul><h4 id="附1-专有名词解释"><a href="#附1-专有名词解释" class="headerlink" title="附1 : 专有名词解释"></a>附1 : 专有名词解释</h4><ul><li>POJO（Plain Ordinary Java Object）: 在本手册中，POJO 专指只有 setter &#x2F; getter &#x2F; toString 的简单类，包括 DO&#x2F;DTO&#x2F;BO&#x2F;VO 等。</li><li>GAV（GroupId、ArtifactctId、Version）: Maven 坐标，是用来唯一标识 jar 包。</li><li>OOP（Object Oriented Programming）: 本手册泛指类、对象的编程处理方式。</li><li>ORM（Object Relation Mapping）: 对象关系映射，对象领域模型与底层数据之间的转换， 本文泛指 iBATIS, mybatis 等框架。</li><li>NPE（java.lang.NullPointerException）: 空指针异常。</li><li>SOA（Service-Oriented Architecture）: 面向服务架构，它可以根据需求通过网络对松散耦合 的粗粒度应用组件进行分布式部署、组合和使用，有利于提升组件可重用性，可维护性。</li><li>IDE（Integrated Development Environment）: 用于提供程序开发环境的应用程序，一般包括 代码编辑器、编译器、调试器和图形用户界面等工具，本《手册》泛指 IntelliJ IDEA 和 eclipse。</li><li>OOM（Out Of Memory）: 源于 java.lang.OutOfMemoryError，当 JVM 没有足够的内存来 为对象分配空间并且垃圾回收器也无法回收空间时，系统出现的严重状况。</li><li>一方库：本工程内部子项目模块依赖的库（jar 包）。</li><li>二方库：公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar 包）。</li><li>三方库：公司之外的开源库（jar 包）</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2022/09/02/dsa/"/>
      <url>/2022/09/02/dsa/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构绪论"><a href="#数据结构绪论" class="headerlink" title="数据结构绪论"></a>数据结构绪论</h2><blockquote><p>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</p><p>程序设计 &#x3D; 数据结构 + 算法</p></blockquote><h3 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h3><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p><strong>描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</strong></p><p>比如我们现在常用的搜索引擎，一般会有网页、MP3、图片、视频等分类。MP3就是声音数据，图片是图像数据，而网页其实指的就是全部数据的搜索，包括最重要的数字和字符等文字数据。</p><p>也就是说，这里说的数据，其实就是符号，而且这些符号必须具备两个前提：</p><ul><li>可以输入到计算机中。</li><li>能被计算机程序处理。</li></ul><p>对于整型、实型等数值类型，可以进行数值计算。</p><p>对于字符数据类型，就需要进行非数值的处理。而声音、图像、视频等其实是可以通过编码的手段编程字符数据来处理的。</p><h4 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h4><p><strong>组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</strong></p><p>比如，在人类中，什么是数据元素呀？当然是人了。</p><p>畜类呢？牛、马、羊、狗等动物就是禽类的数据元素。</p><h4 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h4><p><strong>一个数据元素可以由若干个数据项组成。</strong></p><p>比如人这样的数据元素，可以有眼、耳、鼻、嘴、手等这些数据项，也可以有姓名、年龄、性别等数据项，具体有哪些数据项，要视你做的系统来决定。</p><p><strong>数据项是数据不可分割的最小单位</strong>。把数据项定义为最小单位是为了更好地解决问题。但真正讨论问题是，数据元素才是数据结构中建立数据模型的着眼点。就像讨论一部电影是，是讨论这部电影角色这样的“数据元素”，而不是针对这个角色的姓名或年龄这样的“数据项”去研究分析。</p><h4 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h4><p><strong>是性质相同的数据元素的集合，是数据的子集。</strong></p><p>性质相同指数据元素具有相同数量和类型的数据项，比如，人都有姓名、生日、性别等相同的数据项。</p><p>既然数据对象是数据的子集，在实际应用中，处理的数据元素通常具有相同性质，在不产生混淆的情况下，我们豆浆数据对象简称为数据。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>结构，简单的理解就是关系，比如分子结构，就是说组成分子的原子之间的排列方式。严格点说，结构是指各个组成部分相互搭配和排列的方式。在现实世界中，<strong>不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构。</strong></p><blockquote><p>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</p></blockquote><p>在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。</p><h3 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h3><p>按照视点的不同，把数据结构分为逻辑结构和物理结构。</p><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p><strong>是指数据对象中数据元素之间的相互关系</strong>。逻辑结构分为以下四种：</p><ol><li><p>集合结构</p><p> <strong>集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系</strong>。各个数据元素是“平等”的，它们的共同属性是“同属于一个集合”。数据结构中的集合关系就类似于数学中的集合。</p><p> <img src="/../img/dsa/%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84.png" alt="集合结构"></p></li><li><p>线性结构</p><p> <strong>线性结构中的数据元素之间是一对一的关系</strong>。</p><p> <img src="/../img/dsa/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.png" alt="线性结构"></p></li><li><p>树形结构</p><p> <strong>树形结构中的数据元素之间存在一种一对多的层次关系</strong>。</p><p> <img src="/../img/dsa/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.png" alt="树形结构"></p></li><li><p>图形结构</p><p> <strong>图形结构的数据元素是多对多的关系</strong>。</p><p> <img src="/../img/dsa/%E5%9B%BE%E5%BD%A2%E7%BB%93%E6%9E%84.png" alt="图形结构"></p></li></ol><p>在用示意图表示数据的逻辑结构时，要注意两点：</p><ul><li>将每个数据元素看作一个结点，用圆圈表示。</li><li>元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，那么用带箭头的连线表示。</li></ul><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p><strong>也叫存储结构，是指数据的逻辑结构在计算机中的存储形式</strong>。</p><p>数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。存储器主要是针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。</p><p>数据的存储结构应正确反应数据元素之间的逻辑关系，这才是最为关键的，如何存储数据元素之间的逻辑关系，是实现物理结构的重点和难点。</p><p>数据元素的存储结构形式有两种：顺序结构和链式结构。</p><ol><li><p>顺序存储结构</p><p> <strong>是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的</strong>。</p><p> <img src="/../img/dsa/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="顺序存储结构"></p><p> 这种存储结构其实很简单，就是排队占位。大家都按顺序排好，每个人站一段空间，大家谁也别插谁的队。数组就是这样的顺序存储结构。当你告诉计算机，你要建立一个有9个整型数据的数组时，计算机就在内存中找了片空地，按照一个整型所站位置的大小乘9，开辟一段连续的空间，于是第一个数组数据就放在第一个位置，第二个数据放在第二个，这样一次摆放。</p></li><li><p>链式存储结构</p><p> 但是并不是一直都像顺序存储结构这样简单和有规律，实际上，总会有人插队，也会有人要上厕所、有人会放弃排队。所以这个队伍当中会添加新成员，也有可能会去掉老元素，整个结构时刻都处于变化中。显然，面对这样时常要变化的结构，顺序存储结构是不科学的。</p><p> 现在如银行、医院等地方，设置了排队系统，也就是每个人去了，先领一个号，等着叫号，叫到时去办理业务或看病。在等待的时候，你爱在哪就在哪，可以坐着、站着或者走动，甚至出去逛一圈，只要及时回来就行。你关注的是前一个号有没有被叫到，叫到了，下一个就轮到了。、</p><p> <strong>链式存储结构是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的</strong>。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关数据元素的位置。</p><p> <img src="/../img/dsa/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="链式存储结构"></p><p> 显然，链式存储结构灵活多了，数据存在哪里不重要，只要有一个指针存放了相应的地址就能找到它了。</p><p> 逻辑结构是面向问题的，而物理结构就是面向计算机的，其基本的目标就是将数据及其逻辑关系存储到计算机的内存中。</p></li></ol><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><strong>是指一组性质相同的值的集合及定义在此集合上的一些操作的总称</strong>。</p><p>数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。</p><p>在计算机中，内存也不是无限大的，如果要计算一个如 1 + 1 &#x3D; 2、3 + 5 &#x3D; 8 这样的整型数字的加减乘除运算，显然不需要开辟很大的适合小数甚至字符运算的内存空间。于是计算机的研究者们就考虑，要对数据进行分类，分出来多种数据类型。</p><p>在C语言中，按照取值的不同，数据类型可以分为两类：</p><ul><li>原子类型：是<strong>不可以再分解的基本类型</strong>，包括整型、实型、字符型等。</li><li>结构类型：由<strong>若干个类型组合而成，是可以再分解的</strong>。例如，整型数组是由若干整型数据组成。</li></ul><p>比如，在C语言中变量声明 int a, b, 这就意味着，再给变量 a 和 b 赋值时不能超出 int 的取值范围，变量 a 和 b 之间的运算只能是 int 类型所允许的运算。</p><p>因为不同的计算机又不同的硬件系统，这就要求程序语言最终通过编译器或解释器转换成底层语言，如汇编语言甚至是通过机器语言的数据类型来实现的。可事实上，高级语言的编程者不管最终程序运行在什么计算机上，他的目的就是为了实现两个整型数字的运算，如 a + b、a - b、 a × b、a &#x2F; b 等，他才不关心在计算机内部是如何表示的，也不想知道 CPU 为了实现 1 + 2 进行几次开关操作，这些操作是如何实现的，对高级语言开发者来讲根本不重要。于是我们就会考虑，无论什么计算机、什么计算机语言，大都会面临着如整数运算、实数运算、字符运算等操作，我们可以考虑把它们都抽象出来。</p><p><strong>抽象是指抽取出事物具有的普遍性的本质</strong>。它是抽出问题的特征而忽略非本质的细节，是对具体事务的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。</p><h4 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><p>对已有的数据类型进行抽象，就有了抽象数据类型。</p><p><strong>抽象数据类型(Abstract Data Type, ADT)：是指一个数字模型及定义在该模型上的一组操作</strong>。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</p><p>比如，各个计算机，不管是大型机、小型机、PC、平板电脑、PDA，甚至智能手机都拥有“整数”类型，也需要整数间的运算，那么整型其实就是一个抽象数据类型，尽管它在上面提到的这些在不同计算机中实现方法上可能不一样，但由于其定义的数学特性相同，在计算机编程者看来，他们都是相同的。因此，<strong>“抽象”的意义在于数据类型的数学抽象特性</strong>。</p><p>而且，抽象数据类型不仅仅指那些已经定义并实现的数据类型，还可以是计算机编程者在设计软件程序时自己定义的数据类型，比如我们编写关于计算机绘图或者地图类的软件系统，经常都会用到坐标。也就是说，总是有成对出现的 x 和 y ，在 3D 系统中还有 z 出现，既然这三个整型数字始终在一起出现，我们就定义一个叫 ponit 的抽象数据类型，它有 x、y、z 三个整型变量，这样我们很方便地操作一个 point 数据变量就能知道这一点的坐标了。</p><p>事实上，<strong>抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性</strong>。抽象数据类型把实际生活中的问题分解为多个规模小且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。</p><p>抽象数据类型的标准格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名</span><br><span class="line">Data</span><br><span class="line">  抽象元素之间逻辑关系的定义</span><br><span class="line">Operation</span><br><span class="line">  操作 <span class="number">1</span></span><br><span class="line">  初始条件</span><br><span class="line">  操作结果描述</span><br><span class="line">  操作 <span class="number">2</span></span><br><span class="line">  ……</span><br><span class="line">  操作 n</span><br><span class="line">  ……</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>用图表示数据结构的相关概念</p><p><img src="/../img/dsa/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5.png" alt="数据结构概念"></p><p>由这些概念，给出了数据结构的定义：数据结构是相互之间存在一种或多种特定关系的数据元素的集合。同样是结构，从不同的角度来讨论，会有不同的分类。</p><p><img src="/../img/dsa/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88.png" alt="数据元素集合"></p><p>最后，还介绍了抽象数据类型及它的描述方法。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p></blockquote><h3 id="两种算法的比较"><a href="#两种算法的比较" class="headerlink" title="两种算法的比较"></a>两种算法的比较</h3><p>要求写一个求 1 + 2 + 3 + …… + 100 结果的程序。</p><p>常规方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br></pre></td></tr></table></figure><p>伟大数学家高斯童年方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;</span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br></pre></td></tr></table></figure><p>高斯所用方法相当于另一种等差数列的算法，不仅仅可以用于计算 1 到 100，就是加到 一千，一万（需要更改整型变量类型为长整型，否则会溢出），也很快速。但是用常规循环方式，计算机要循环一千，一万次的加法运算。</p><h3 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h3><p>如今普遍认可的对算法的定义是：<strong>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</strong></p><p>算法定义中，提到了指令，指令能被人或机器等计算装置执行。它可以是计算机指令，也可以是我们平时的语言文字。</p><p>为了解决某个或某类问题，需要把指令表示成一定的操作序列，操作序列包括一组操作，每一个操作都完成特定的功能，这就是算法了。</p><h3 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h3><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>输入和输出特性比较容易理解，<strong>算法具有零个或多个输入</strong>。尽管对于绝大多数算法来说，输入参数都是必要的，但对于个别情况，如打印“Hello World”这样的代码，不需要任何输入参数，因此算法的输入可以是零个。<strong>算法至少有一个或多个输出</strong>，算法是一定需要输出的，不需要输出，你用这个算法干嘛？输出的形式可以是打印输出，也可以是返回一个或多个值等。</p><h4 id="有穷性"><a href="#有穷性" class="headerlink" title="有穷性"></a>有穷性</h4><p><strong>指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成</strong>。现实中经常会写出死循环的代码，这就是不满足有穷性。当然这里有穷的概念并不是纯数学意义的，而是在实际应用当中合理的、可以接受的“有边界”。</p><h4 id="确定性"><a href="#确定性" class="headerlink" title="确定性"></a>确定性</h4><p><strong>算法的每一步骤都具有确定的含义，不会出现二义性</strong>。算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义。</p><h4 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h4><p><strong>算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成</strong>。可行性意味着算法可以转换为程序上机运行，并得到正确的结果。尽管在目前计算机界也存在那种没有实现的极为复杂的算法，不是说理论上不能实现，而是因为过于复杂，我们当前的编程方法、工具和大脑限制了这个工作，不过这都是理论研究领域的问题，不属于我们现在要考虑的范围。</p><h3 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h3><h4 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h4><p><strong>算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案</strong>。</p><p>但是算法的“正确”通常在用法上有很大的差别，大体分为以下四个层次。</p><ol><li>算法程序没有语法错误。</li><li>算法程序对于合法的输入数据能够产生满足要求的输出结果。</li><li>算法程序对于非法的输入数据能够得出满足规格说明的结果。</li><li>算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。</li></ol><p>对于这四层含义，层次 1 要求最低，但是仅仅没有语法错误实在谈不上是好算法。而层次 4 是最困难的，我们几乎不可能逐一验证所有的输入都得到正确的结果。</p><p>因此算法的正确性在大部分情况下都不可能用程序来证明，而是用数学方法证明的。证明一个复杂算法在所有层次上都是正确的，代价非常昂贵。所以一般情况下，我们把层次 3 作为一个算法是否正确的标准。</p><h4 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h4><p><strong>算法设计的另一目的就是为了便于阅读、理解和交流</strong>。</p><p>可读性高有助于人们理解算法，晦涩难懂的算法往往隐含错误，不易被发现，并且难于调试和修改。我们写代码的目的，一方面是为了让计算机执行，但还有一个重要的目的是为了便于他人阅读，让人理解和交流，自己将来也可能阅读，如果可读性不好，时间长了自己都不知道写了些什么。可读性是算法好坏很重要的标志。</p><h4 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h4><p>一个好的算法还应该能对输入数据不合法的情况做合适的处理。比如输入的时间或者距离不应该是负数等。</p><p><strong>当输入数据不合法时，算法也能做出相关处理，而不是产生异常或命名奇妙的结果</strong>。</p><h4 id="时间效率高和存储量低"><a href="#时间效率高和存储量低" class="headerlink" title="时间效率高和存储量低"></a>时间效率高和存储量低</h4><p>好的算法还应该具备时间效率高和存储量低的特点。</p><p>时间效率指的是算法的执行时间，对于同一个问题，如果有多个算法能够解决，执行时间短的算法效率高，执行时间长的效率低。存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间。<strong>设计算法应该尽量满足时间效率高和存储量低的需求</strong>。在生活中，人们都希望花最少的钱，用最短的时间，办最大的事，算法也是一样的思想，最好用最少的存储空间，花最少的时间，办成同样的事就是好的算法。</p><p>综上，好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征。</p><h3 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h3><h4 id="事后统计方法"><a href="#事后统计方法" class="headerlink" title="事后统计方法"></a>事后统计方法</h4><p><strong>这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低</strong>。</p><p>缺点：</p><ul><li>必须依据算法事先编制好程序，这通常需要花费大量的时间和精力。</li><li>时间的比较依赖计算机硬件和软件等环境因素，有时会掩盖算法本身的优劣。</li><li>算法的测试数据设计困难，并且程序的运行时间往往还与测试数据的规模有很大关系，效率高的算法在小的测试数据面前往往得不到提现。</li></ul><h4 id="事前分析估算法"><a href="#事前分析估算法" class="headerlink" title="事前分析估算法"></a>事前分析估算法</h4><p><strong>在计算机程序编制前，依据统计方法对算法进行估算</strong>。</p><p>一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：</p><ol><li>算法采用的策略、方法。</li><li>编译产生的代码质量。</li><li>问题的输入规模。</li><li>机器执行指令的速度。</li></ol><p>第 1 条时算法好坏的根本，第 2 条要由软件来支持，第 4 条要看硬件性能。抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间，<strong>依赖于算法的好坏和问题的输入规模</strong>。所谓<strong>问题输入规模是指输入量的多少</strong>。</p><p>比较两种求和算法：</p><p>第一种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;<span class="comment">// 执行 1 次</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">// 执行了 n + 1 次</span></span><br><span class="line">  sum = sum + i;<span class="comment">// 执行 n 次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);<span class="comment">// 执行 1 次</span></span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;<span class="comment">// 执行 1 次</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;<span class="comment">// 执行 1 次</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);<span class="comment">// 执行 1 次</span></span><br></pre></td></tr></table></figure><p>显然，第一种算法，执行了 1 + (n + 1) + n + 1 &#x3D; 2n + 3 次；而第二种算法，是 1 + 1 + 1 &#x3D; 3 次。事实上，两个算法的第一条和最后一条语句是一样的，所以我们关注的代码其实是中间的那部分，我们把循环看做一个整体，忽略头尾循环判断的开销，那么这两个算法其实就是 n 次与 1 次的差距。算法好坏显而易见。</p><p>我们不关心编写程序所用的程序设计语言是什么，也不关心这些程序将跑在什么样的计算机中，我们只关心它所实现的算法。这样，不计那些循环索引的递增和循环终止条件、变量声明、打印结果等操作，<strong>最终，在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤</strong>。</p><h3 id="函数的渐近增长"><a href="#函数的渐近增长" class="headerlink" title="函数的渐近增长"></a>函数的渐近增长</h3><p>判断算法 A 和算法 B 哪个更好。假设两个算法的输入规模都是 n，算法 A 要做 2n + 3 次操作，你可以理解为先有一个 n 次的循环，执行完成后，再有一个 n 次循环，最后有三次赋值或运算，共 2n + 3 次操作。算法 B 要做 3n + 1 次操作。</p><table><thead><tr><th align="center">次数</th><th align="center">算法 A (2n + 3)</th><th align="center">算法A’ (2n)</th><th align="center">算法 B (3n + 1)</th><th align="center">算法 B’ (3n)</th></tr></thead><tbody><tr><td align="center">n &#x3D; 1</td><td align="center">5</td><td align="center">2</td><td align="center">4</td><td align="center">3</td></tr><tr><td align="center">n &#x3D; 2</td><td align="center">7</td><td align="center">4</td><td align="center">7</td><td align="center">6</td></tr><tr><td align="center">n &#x3D; 3</td><td align="center">9</td><td align="center">6</td><td align="center">10</td><td align="center">9</td></tr><tr><td align="center">n &#x3D; 10</td><td align="center">23</td><td align="center">20</td><td align="center">31</td><td align="center">30</td></tr><tr><td align="center">n &#x3D; 100</td><td align="center">203</td><td align="center">200</td><td align="center">301</td><td align="center">300</td></tr></tbody></table><p>当 n &#x3D; 1 时，算法 A 效率不如算法 B (次数比算法 B 要多一次)。而当 n &#x3D; 2 时，两者效率相同；当 n &gt; 2 时，算法 A 就开始优于算法 B 了，随着 n 的增加，算法 A比算法 B 越来越好了(执行的次数比 B 要少)。于是可以得出结论，算法 A 总体上要好过算法 B。</p><p>输入规模 n 在没有限制的情况下，只要超过一个数值 N，这个函数就总是大于另一个函数，我们称函数时渐近增长的。</p><blockquote><p>函数的渐近增长：给定两个函数 f(n) 和 g(n)，如果存在一个整数 N, 使得对于所有的 n &gt; N，f(n) 总是比 g(n) 大，那么，就说 f(n) 的增长渐近快于 g(n)。</p></blockquote><p>从中可以发现，随着 n 的增大，后面的 +3 还是 +1 其实是不影响最重的算法变化的，例如算法 A’ 与算法 B’，所以，<strong>可以忽略这些加法常数</strong>。</p><p>第二个例子，算法 C 是 4n + 8，算法 D 是 2n<sup>2</sup> + 1</p><table><thead><tr><th align="center">次数</th><th align="center">算法 C (4n + 8)</th><th align="center">算法C’ (n)</th><th align="center">算法 D (2n<sup>2</sup> + 1)</th><th align="center">算法 D’ (n<sup>2</sup>)</th></tr></thead><tbody><tr><td align="center">n &#x3D; 1</td><td align="center">12</td><td align="center">1</td><td align="center">3</td><td align="center">1</td></tr><tr><td align="center">n &#x3D; 2</td><td align="center">16</td><td align="center">2</td><td align="center">9</td><td align="center">4</td></tr><tr><td align="center">n &#x3D; 3</td><td align="center">20</td><td align="center">3</td><td align="center">19</td><td align="center">9</td></tr><tr><td align="center">n &#x3D; 10</td><td align="center">48</td><td align="center">10</td><td align="center">201</td><td align="center">100</td></tr><tr><td align="center">n &#x3D; 100</td><td align="center">408</td><td align="center">100</td><td align="center">20001</td><td align="center">10000</td></tr><tr><td align="center">n &#x3D; 1000</td><td align="center">4008</td><td align="center">1000</td><td align="center">2000001</td><td align="center">1000000</td></tr></tbody></table><p>当 n ≤ 3 的时候，算法 C 要差于算法 D (因为算法 C 次数比较多)，但当 n &gt; 3后，算法 C 的优势就越来越优于算法 D 了，到后来更是远远胜过。而当后面的常数去掉后，我们发现其实结果没有发生改变。甚至哪怕去掉与 n 相乘的常数，这样的结果也没发生改变，算法 C’ 的次数随着 n 的增长，还是远小于算法 D’。也就是说，<strong>与最高次项相乘的常数并不重要</strong>。</p><p>第三个例子。算法 E 是 2n<sup>2</sup> + 3n + 1，算法 F 是 2n<sup>3</sup> + 3n + 1。</p><table><thead><tr><th align="center">次数</th><th align="center">算法 E (2n<sup>2</sup> + 3n + 1)</th><th align="center">算法E’ (n<sup>2</sup>)</th><th align="center">算法 F (2n<sup>3</sup> + 3n + 1)</th><th align="center">算法 F’ (n<sup>3</sup>)</th></tr></thead><tbody><tr><td align="center">n &#x3D; 1</td><td align="center">6</td><td align="center">1</td><td align="center">6</td><td align="center">1</td></tr><tr><td align="center">n &#x3D; 2</td><td align="center">15</td><td align="center">4</td><td align="center">23</td><td align="center">8</td></tr><tr><td align="center">n &#x3D; 3</td><td align="center">28</td><td align="center">9</td><td align="center">64</td><td align="center">27</td></tr><tr><td align="center">n &#x3D; 10</td><td align="center">231</td><td align="center">100</td><td align="center">2031</td><td align="center">1000</td></tr><tr><td align="center">n &#x3D; 100</td><td align="center">20301</td><td align="center">10000</td><td align="center">2000301</td><td align="center">1000000</td></tr></tbody></table><p>当 n &#x3D; 1的时候，算法 E 与算法 F 结果相同，但当 n &gt; 1后，算法 E 的优势就要开始优于算法 F，随着 n 的增大，差异非常明显。通过观察发现，<strong>最高次项的指数大的，函数随着 n 的增大，结果也会变得增长特别快</strong>。</p><p>最后一个例子，算法 G 是 2n<sup>2</sup>，算法 H 是 3n + 1，算法 I 是 2n<sup>2</sup> + 3n + 1 。</p><table><thead><tr><th align="center">次数</th><th align="center">算法 G (2n<sup>2</sup>)</th><th align="center">算法H (3n + 1)</th><th align="center">算法 I (2n<sup>2</sup> + 3n + 1)</th></tr></thead><tbody><tr><td align="center">n &#x3D; 1</td><td align="center">2</td><td align="center">4</td><td align="center">6</td></tr><tr><td align="center">n &#x3D; 2</td><td align="center">8</td><td align="center">7</td><td align="center">15</td></tr><tr><td align="center">n &#x3D; 5</td><td align="center">50</td><td align="center">16</td><td align="center">66</td></tr><tr><td align="center">n &#x3D; 10</td><td align="center">200</td><td align="center">31</td><td align="center">231</td></tr><tr><td align="center">n &#x3D; 100</td><td align="center">20000</td><td align="center">301</td><td align="center">20301</td></tr><tr><td align="center">n &#x3D; 1000</td><td align="center">2000000</td><td align="center">3001</td><td align="center">2003001</td></tr><tr><td align="center">n &#x3D; 10000</td><td align="center">200000000</td><td align="center">30001</td><td align="center">200030001</td></tr><tr><td align="center">n &#x3D; 100000</td><td align="center">20000000000</td><td align="center">300001</td><td align="center">20000300001</td></tr><tr><td align="center">n &#x3D; 1000000</td><td align="center">2000000000000</td><td align="center">3000001</td><td align="center">2000003000001</td></tr></tbody></table><p>当 n 的值越来越大时，3n + 1 已经没法和 2n<sup>2</sup> 的结果相比较，最终几乎可以忽略不计。也就是说，随着 n 值变得非常大以后，算法 G 其实已经很趋近于算法 I。于是我们可以得到这样一个结论，<strong>一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项(最高阶项)的阶数</strong>。</p><p>判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的。根据几个例子，如果可以对比这几个算法的关键执行次数函数的渐近增长性，基本就可以分析出：<strong>某个算法，随着 n 的增大，它会越来越优于另一个算法，或者越来越差于另一算法</strong>。这其实就是事前估算方法的理论依据，通过算法时间复杂度来估算算法时间效率。</p><h3 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h3><h4 id="算法时间复杂度定义"><a href="#算法时间复杂度定义" class="headerlink" title="算法时间复杂度定义"></a>算法时间复杂度定义</h4><blockquote><p>在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间量度，计作：T(n) &#x3D; O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函数。</p></blockquote><p>这样用大写 O() 来体现算法时间复杂度的方法，我们称之为大 O 记法。</p><p>一般情况下，随着 n 的增大，T(n) 增长最慢的算法为最优算法。</p><p>显然，由此算法时间复杂度的定义可知，我们的三个求和算法的时间复杂度分别为 O(n)，O(1)，O(n<sup>2</sup>)。O(1) 叫作常数阶、O(n) 叫作线性阶、O(n<sup>2</sup>)叫作平方阶。</p><h4 id="推导大-O-阶方法"><a href="#推导大-O-阶方法" class="headerlink" title="推导大 O 阶方法"></a>推导大 O 阶方法</h4><ol><li>用常数 1 取代运行时间中的所有加法常数。</li><li>在修改后的运行次数函数中，只保留最高阶项。</li><li>如果最高阶项存在且不是 1，则去除与这个项相乘的常数。得到的结果就是大 O 阶。</li></ol><h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4><p>首先顺序结构的时间复杂度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;<span class="comment">// 执行 1 次</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;<span class="comment">// 执行 1 次</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);<span class="comment">// 执行 1 次</span></span><br></pre></td></tr></table></figure><p>这个算法的运行次数是 f(n) &#x3D; 3。根据推到大 O 阶的方法，第一步就是把常数项 3 改为 1。在保留最高阶项时，发现更本没有最高阶项，所以这个算法的时间复杂度为 O(1)。</p><p>对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着 n 的变大而发生改变，所以单纯的分支结构(不包含在循环结构中)，其时间复杂度也是 O(1)。</p><h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><p>线性阶的循环结构会复杂很多。要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集运行的次数。因此，我们要<strong>分析算法的复杂度，关键就是要分析循环结构的运行情况</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码，它的循环的时间复杂度为 O(n)，因为循环体中的代码需要执行 n 次。</p><h4 id="常数阶-1"><a href="#常数阶-1" class="headerlink" title="常数阶"></a>常数阶</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt; n) &#123;</span><br><span class="line">  count = count * <span class="number">2</span>;</span><br><span class="line">  <span class="comment">/* 时间复杂度为 O(1) 的程序步骤序列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于每次 count 乘以 2 之后，就距离 n 更近了一分。也就是说，有多少个 2 相乘后大于 n，则会退出循环。由 2<sup>x</sup> &#x3D; n 得到 x &#x3D; log<sub>2</sub>n。所以这个循环的时间复杂度为O(logn)。</p><h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个循环嵌套，它的内循环的时间复杂度为 O(n)，外层的循环，不过是内部这个时间复杂度为 O(n) 的语句，在循环 n 次。所以这段代码的时间复杂度为 O(n<sup>2</sup>)。</p><p>如果外循环的循环次数改为了 m，时间复杂度就变为 O(m × n)。</p><h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><table><thead><tr><th align="center">执行次数函数</th><th align="center">阶</th><th align="center">非正式术语</th></tr></thead><tbody><tr><td align="center">12</td><td align="center">O(1)</td><td align="center">常数阶</td></tr><tr><td align="center">2n + 3</td><td align="center">O(n)</td><td align="center">线性阶</td></tr><tr><td align="center">3n<sup>2</sup> + 2n + 1</td><td align="center">O(n<sup>2</sup>)</td><td align="center">平方阶</td></tr><tr><td align="center">5log<sub>2</sub>n + 20</td><td align="center">O(logn)</td><td align="center">对数阶</td></tr><tr><td align="center">2n + 3nlog<sub>2</sub>n + 19</td><td align="center">O(nlogn)</td><td align="center">nlogn阶</td></tr><tr><td align="center">6n<sup>3</sup> + 2n<sup>2</sup> + 3n + 4</td><td align="center">O(n<sup>3</sup>)</td><td align="center">立方阶</td></tr><tr><td align="center">2<sup>n</sup></td><td align="center">O(2<sup>n</sup>)</td><td align="center">指数阶</td></tr></tbody></table><p>常用的时间复杂度所含飞的时间从小到大依次是：</p><p><strong>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</strong></p><blockquote><p>O(n<sup>3</sup>)，过大的 n 会使得结果变得不现实。O(2<sup>n</sup>) 和 O(n!) 等除非是很小的 n 值，否则哪怕 n 只是 100，都是噩梦般的运行时间。所以这种不切实际的算法时间复杂度，一般不讨论。</p></blockquote><h3 id="最坏情况与平均情况"><a href="#最坏情况与平均情况" class="headerlink" title="最坏情况与平均情况"></a>最坏情况与平均情况</h3><p>查找一个有 n 个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度为 O(1)，但也有可能这个数字就在最后一个位置上待着，那么算法的时间复杂度就是O(n)，这是最坏的一种情况了。</p><p><strong>最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间</strong>。</p><p>而平均运行时间也就是从概率的角度看，这个数字在每一个位置的可能性是相同的，所以平均的查找时间为 n &#x2F; 2 次后发现这个目标元素。</p><p><strong>平均运行时间是所有情况中最有意义的，因为它是期望的运行时间</strong>。也即是说，我们运行一段程序代码时，是希望看到平均运行时间。可现实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。</p><p>对算法的分析，一种方法时计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。另一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。<strong>一般在没有特殊说明的情况下，都是指最坏时间复杂度</strong>。</p><h3 id="算法空间复杂度"><a href="#算法空间复杂度" class="headerlink" title="算法空间复杂度"></a>算法空间复杂度</h3><p>我们在写代码时，完全可以用空间来换取时间，比如说，要判断某某年是不是闰年，你可能会花一点心思写了一个算法，而且由于是一个算法，也就意味着，每次给一个年份，都是要通过计算得到是否是闰年的结果。还有另一个办法就是，事先建立一个有 2050 个元素的数组(年数略比现实多一点)，然后把所有的年份按下标的数字对应，如果是闰年，此数组项的值就是 1，如果不是值为 0。这样，所谓的判断某一年是否是闰年，就变成了查找这个数组的某一项的值是多少的问题。此时，我们运算是最小化了，但是硬盘上或者内存中需要存储这个 2050 个 0 和 1。</p><p>这是通过一笔空间上的开销来换取计算时间的小技巧。到底哪一个好，其实要看用在什么地方。</p><p><strong>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) &#x3D; O(f(n))，其中，n 为问题的规模，f(n) 为语句所占存储空间的函数。</strong></p><p>一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为 O(1)。</p><p>通常，我们都使用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求。当不用限定词地使用“复杂度”时，通常都是指时间复杂度。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>算法的定义：算法时解决特定问题求解步骤的描述，在计算机中为指令的有限序列，并且每条指令表示一个或多个操作。</p><p>算法的特性：有穷性、确定性、可行性、输入、输出</p><p>算法的设计的要求：正确性、可读性、健壮性、高效率和低存储量需求</p><p>算法的度量方法：事后统计方法(不科学、不准确)、事前分析估算方法</p><p>函数的渐近增长：给定两个函数 f(n) 和 g(n)，如果存在一个整数 N, 使得对于所有的 n &gt; N，f(n) 总是比 g(n) 大，那么，就说 f(n) 的增长渐近快于 g(n)。于是我们可以得出一个结论，判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的，如果我们可以对比算法的关键执行次数函数的渐近增长性，基本就可以分析出：某个算法，随着 n 的变大，它会越来越优于另一算法，或者越来越差于另一算法。</p><p>推导大 O 阶：</p><ol><li>用常数 1 取代运行时间中的所有加法常数。</li><li>在修改后的运行次数函数中，只保留最高阶项。</li><li>如果最高阶项存在且不是 1，则去除与这个项相乘的常数。得到的结果就是大 O 阶。</li></ol><p>常见的时间复杂度所耗时间的大小排列：</p><p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><blockquote><p>零个或多个数据元素的有限序列。</p></blockquote><p>首先它是一个序列。也就是说，元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继。</p><p>然后，线性表强调是有限的，元素个数当然也是有限的。事实上，在计算机中处理的对象都是有限的，那种无限的数据，只存在于数学的概念中。</p><p>用数学语言来进行定义：<strong>若将线性表记为 (a<sub>1</sub>, ···, a<sub>i-1</sub>, a<sub>i</sub>, a<sub>i+1</sub>, ···, a<sub>n</sub>), 则表中  a<sub>i-1</sub> 领先于 a<sub>i</sub>，a<sub>i</sub> 领先于 a<sub>i+1</sub>，称 a<sub>i+1</sub> 是 a<sub>i</sub> 的直接前驱元素，a<sub>i+1</sub> 是 a<sub>i</sub> 的直接后继元素。当 i &#x3D; 1，2，……，n-1 时，a<sub>i</sub> 有且仅有一个直接后继，当 i &#x3D; 2，3，……，n 时，a<sub>i</sub> 有且仅有一个直接前驱。</strong> 。</p><p><strong>所以线性表元素的个数 n (n ≥ 0) 定义为线性表的长度，当 n &#x3D; 0 时，称为空表</strong>。</p><p>在非空表中的每个数据元素都有一个确定的位置，如 a<sub>i</sub> 是第一个数据元素，a<sub>n</sub> 是最后一个数据元素，a<sub>i</sub> 是第 i 个数据元素，称 i 为数据元素 a<sub>i</sub> 在线性表中的位序。</p><h3 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT线性表(<span class="built_in">list</span>)</span><br><span class="line">Data</span><br><span class="line">  线性表的数据对象集合为&#123;a₁, a₂, ···, an&#125;，每个元素的类型均为 DataType。其中，除第一个元素 a₁ 外，每一个元素有且只有一个直接前驱元素，除了最后一个元素 an 外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。</span><br><span class="line">Operation</span><br><span class="line">  <span class="title function_">InitList</span><span class="params">(*L)</span>:初始化操作，建立一个空的线性表L</span><br><span class="line">  ListEmpty（L):若线性表为空，返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span></span><br><span class="line">    <span class="title function_">ClearList</span><span class="params">(*L)</span>:将线性表清空</span><br><span class="line">    <span class="title function_">GetElem</span><span class="params">(L, i, *e)</span>:将线性表 L 中的第 i 个位置元素值返回给 e</span><br><span class="line">    <span class="title function_">LocateElem</span><span class="params">(L, e)</span>:在线性表 L 中查找于给定值 e 相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回 0 表示失败</span><br><span class="line">    <span class="title function_">ListInsert</span><span class="params">(*L, i, e)</span>:在线性表 L 中的第 i 个位置插入新元素 e</span><br><span class="line">    <span class="title function_">ListDelete</span><span class="params">(*L, i, *e)</span>:删除线性表 L 中第 i 个位置元素，并用 e 返回其值</span><br><span class="line">    <span class="title function_">ListLength</span><span class="params">(L)</span>:返回线性表 L 的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p>对于不同的应用，线性表的基本操作是不同的，上述操作是最基本的，对于实际问题中涉及的关于线性表的更复杂操作，完全可以用这些基本操作的组合来实现。</p><h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3><h4 id="顺序存储定义"><a href="#顺序存储定义" class="headerlink" title="顺序存储定义"></a>顺序存储定义</h4><blockquote><p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p></blockquote><p>线性表 (a<sub>1</sub>, a<sub>1</sub>, ……, a<sub>n</sub>) 的顺序存储结构</p><p><img src="/dsa/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png" alt="顺序存储"></p><h4 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h4><p>线性表的顺序存储结构，就是在内存中找了块区域，通过占位的形式，把一定的内存空间给占了，然后把相同数据类型的数据元素一次存放在这块空地种。既然线性表的每个数据元素的类型都相同，所以可以用 C 语言(其他语言也相同)的一维数组来实现顺序存储结构，即把第一个数据元素存到数组下标为 0 的位置中，接着把线性表相邻的元素存储在数组中相邻的位置。</p><p>线性表顺序存储的结构代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20<span class="comment">// 存储空间初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;<span class="comment">// ElemType 类型根据实际情况而定，这里假设为 int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> ElemType data[MAXSIZE];<span class="comment">// 数组存储数据元素，最大值为MAXSIZE</span></span><br><span class="line">  <span class="type">int</span> length;<span class="comment">// 线性表当前长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>顺序存储结构需要三个属性：</p><ul><li>存储空间的起始位置：数据 data，它的存储位置就是存储空间的存储位置</li><li>线性表的最大存储容量：数组长度 MaxSize</li><li>线性表的当前长度</li></ul><h4 id="数据长度于线性表长度区别"><a href="#数据长度于线性表长度区别" class="headerlink" title="数据长度于线性表长度区别"></a>数据长度于线性表长度区别</h4><p>数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。</p><p>在任一时刻，线性表的长度应该小于等于数组的长度。</p><h4 id="地址计算方法"><a href="#地址计算方法" class="headerlink" title="地址计算方法"></a>地址计算方法</h4><p>由于我们数数都是从 1 开始开始数的，线性表的定义起始也是 1，在程序设计中，数组的小表是从 0 开始的，所以线性表的第 i 个元素要存储在数组下标为 i-1 的位置，即数据元素的序号和存放它的数组下标之间存在对应关系。</p><p>用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，因此分配的数组空间要大于等于当前线性表的长度。</p><p><strong>存储器中的每个存储单元都有自己的编号，这个编号称为地址</strong>。由于每个数据元素，不管它是整型、实型还是字符型，它都是需要占用一定的存储单元空间的。假设占用的是 c 个存储单元，那么线性表中第 i+1 个数据元素的存储位置和第 i 个数据元素的存储位置满足下列关系(LOC 表示获得存储位置的函数)。</p><blockquote><p>LOC(a<sub>i+1</sub>) &#x3D; LOC(a<sub>i</sub>) + c</p></blockquote><p>所以对于第 i 个数据元素 a<sub>i</sub> 的存储位置可以由 a<sub>1</sub> 推算得出：</p><blockquote><p>LOC(a<sub>i</sub>) &#x3D; LOC(a<sub>1</sub>) + (i - 1) * c</p></blockquote><p>通过这个公式，随时可以算出线性表中任意位置的地址，不管它是第一个还是最后一个，都是相同的时间。那么对每个线性表位置的存入或者取出数据，对于计算机来说都是相等的时间，也就是一个常数，因此从时间复杂度的概念来看，它的存取时间性能为 O(1)。通常把具有这一特点的存储结构称为随机存取结构。</p><h3 id="顺序存储结构的插入和删除"><a href="#顺序存储结构的插入和删除" class="headerlink" title="顺序存储结构的插入和删除"></a>顺序存储结构的插入和删除</h3><h4 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h4><p>对于线性表的顺序存储结构来说，如果我们要实现 GetElem 操作，即将线性表 L 中第 i 个位置元素值返回，其实是非常简单的。只要 i 的数值在数组下标范围内，就是把数组第 i-1 下标的值返回即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line">Status <span class="title function_">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i, ElemType *e)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(L.length == <span class="number">0</span> || i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e = L.data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps: 这里的返回值类型 Status 是一个整数，返回 OK 代表 1，ERROR 代表 0。**时间复杂度为O(1)**。</p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>插入算法的思路：</p><ul><li>如果插入位置不合理，抛出异常；</li><li>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；</li><li>从最后一个元素开始向前遍历到第 i 歌位置，分别将它们都向后移动一个位置；</li><li>将要插入元素填入位置 i 处；</li><li>表长加 1。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(SqList *L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  <span class="keyword">if</span>(L -&gt; length == MAXSIZE)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L -&gt; length + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span>(i &lt;= L -&gt; length) &#123;</span><br><span class="line">    <span class="keyword">for</span>(k = L -&gt; length - <span class="number">1</span>; k &gt;= i <span class="number">-1</span>; k--)</span><br><span class="line">      L -&gt; data[k + <span class="number">1</span>] = L -&gt; data[k];</span><br><span class="line">  &#125;</span><br><span class="line">  L -&gt; data[i - <span class="number">1</span>] = e;</span><br><span class="line">  L -&gt; length++;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>删除算法的思路：</p><ul><li>如果删除位置不合理，抛出异常；</li><li>取出删除元素；</li><li>从删除元素位置开始便利到最后一个元素位置，分别将它们都向前移动一个位置；</li><li>表长减1。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(SqList *L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  <span class="keyword">if</span>(L -&gt; length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L -&gt; length)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  *e = L -&gt; data[i - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span>(i &lt; L -&gt; length) &#123;</span><br><span class="line">    <span class="keyword">for</span>(k = i;k &lt; L -&gt; length; k++)</span><br><span class="line">      L -&gt; data[k<span class="number">-1</span>] = L -&gt; data[k];</span><br><span class="line">  &#125;</span><br><span class="line">  L -&gt; length--;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入和删除操作的时间复杂度：</p><p>最好的情况是，如果元素要插入到最后一个位置，或者删除最后一个元素，此时时间复杂度为 O(1)，因为不需要移动元素。</p><p>最坏的情况是，如果元素要插入到第一个位置或者删除第一个元素，那就意味着要移动所有的元素向后或者向前，所以这个时间复杂度为 O(n)。</p><p>至于平均的情况，由于元素插入到第 i 个位置，或删除第 i 个元素，需要移动 n-1 个元素。根据概率原理，每个位置插入或删除的可能性是相同的，也就说位置靠前，移动元素多，位置靠后，移动元素少。最终平均移动次数和最中间的那个元素的移动次数相等，为 (n-1)&#x2F;2。根据时间复杂度的推导，平均时间复杂度还是 O(n)。</p><p>这说明线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是 O(1)；而插入或删除时，时间复杂度都是 O(n)。</p><h4 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h4><p>优点：</p><ul><li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间</li><li>可以快速地存取表中任一位置的元素</li></ul><p>缺点：</p><ul><li>插入和删除操作需要移动大量元素</li><li>当线性表长度变化较大时，难以确定存储空间的容量</li><li>造成存储空间的“碎片”</li></ul><h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h3><h4 id="线性表链式存储结构定义"><a href="#线性表链式存储结构定义" class="headerlink" title="线性表链式存储结构定义"></a>线性表链式存储结构定义</h4><p><img src="/../img/dsa/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="链式存储结构"></p><p>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。意味着，这些数据元素可以存在内存未被占用的任意位置。</p><p>顺序存储结构每个元素之需要存数据元素信息就可以了。链式存储结构除了要存数据元素信息外，还要存储他的后继元素的存储地址。</p><p>因此， <strong>为了表示每个数据元素 a<sub>i</sub> 与其直接后继数据元素 a<sub>i+1</sub> 之间的逻辑关系，对数据元素 a<sub>i</sub> 来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素 a<sub>i</sub> 的存储映像，称为结点(Node)。</strong></p><p><strong>n 个结点(a<sub>i</sub> 的存储映像)链结成一个链表，即为线性表 (a<sub>1</sub>, a<sub>2</sub>, ···, a<sub>n</sub>) 的链式存储结构，因为此链表的每个节点中只包含一个指针域，所以叫做单链表</strong>。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起。</p><p>对于线性表来说，总得有个头有个尾，链表也不例外。把<strong>链表中第一个结点的存储位置叫做头指针</strong>，那么整个链表的存取就必须是从头指针开始进行了。之后的每一个结点，其实就是上一个的后继指针指向的位置。最后一个，当然就意味着直接后继不存在了，所以规定，线性链表的最后一个结点指针为“空” (通常用 NULL 或 “^” 符号表示)。</p><p>有时为了更加方便地对链表进行操作，会在<strong>单链表的第一个结点前附设一个结点，称为头结点</strong>。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针。</p><h4 id="头指针域头结点的异同"><a href="#头指针域头结点的异同" class="headerlink" title="头指针域头结点的异同"></a>头指针域头结点的异同</h4><p>头指针：</p><ul><li>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针；</li><li>头指针具有标识作用，所以常用头指针冠以链表的名字</li><li>无论链表是否为空，头指针均不为空。头指针是链表的必要元素</li></ul><p>头结点：</p><ul><li>头结点是为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义(也可存放链表的长度)</li><li>有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了</li><li>头结点不一定是链表必须要素</li></ul><h4 id="线性表链式存储结构代码描述"><a href="#线性表链式存储结构代码描述" class="headerlink" title="线性表链式存储结构代码描述"></a>线性表链式存储结构代码描述</h4><p>单链表中，在 C 语言中可用结构指针来描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure><p>从这个结构定义中，<strong>结点由存放数据元素的数据域存放后继结点地址的指针域组成</strong>。假设 p 是指向线性表第 i 个元素的指针，则该结点 a<sub>i</sub> 的数据域可以用 p -&gt; data 来表示，p -&gt; data 的值是一个数据元素，结点 a<sub>i</sub> 的指针域可以用 p -&gt; next 来表示，p -&gt; next 的值是一个指针。指向第 i+1 个元素，即指向 a<sub>i+1</sub> 的指针。也就是说，如果 p -&gt; data &#x3D; a<sub>i</sub>，那么 p -&gt; next -&gt; data &#x3D; a<sub>i+1</sub>。</p><h3 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h3><p>获得链表第 i 个数据的算法思路：</p><ul><li>声明一个结点 p 指向链表第一个结点，初始化 j 从 1 开始；</li><li>当 j &lt; i 时，就遍历链表，让 P 的指针向后移动，不断指向下一结点，j 累加 1；</li><li>若到链表末尾 p 为空，则说明第 i 个元素不存在；</li><li>否则查找成功，返回结点 p 的数据。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i, ElemType *e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  LinkList p;<span class="comment">// 声明一结点 p</span></span><br><span class="line">  p = L -&gt; next;<span class="comment">// 让 p 指向链表 L 的第一个结点</span></span><br><span class="line">  j = <span class="number">1</span>;<span class="comment">// j 为计数器</span></span><br><span class="line">  <span class="keyword">while</span>(p &amp;&amp; j &lt; i) &#123;<span class="comment">// p 不为空或者计数器 j 还没有等于 i 时，循环继续</span></span><br><span class="line">    p = p -&gt; next;<span class="comment">// 让 p 指向下一个结点</span></span><br><span class="line">    ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!p || j &gt; i)</span><br><span class="line">    <span class="keyword">return</span> ERROR;<span class="comment">// 第 i 个元素不存在</span></span><br><span class="line">  *e = p -&gt; data;<span class="comment">// 取第 i 个元素的数据</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简而言之就是从头开始找，知道第 i 个元素为止。这个算法的时间复杂度取决于 i 的位置，当 i &#x3D; 1 时，则不需要遍历，第一个取出数据；当 i &#x3D; n 时则遍历 n - 1 次才可以。因此最坏情况的时间复杂度时 O(n)。</p><p>由于单链表的结构中没有定义表长，所以不能事先知道要循环多少次，因此就不方便使用 for 循环来控制循环。主要核心思想就是“<strong>工作指针后移</strong>“。</p><h3 id="单链表的插入和删除"><a href="#单链表的插入和删除" class="headerlink" title="单链表的插入和删除"></a>单链表的插入和删除</h3><h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><p>假设存储元素 e 的结点为 s，要实现结点 p、p -&gt; next 和 s 之间逻辑关系的变化，只需将结点 s 插入到结点 p 和 p -&gt; next 之间即可。只需要让 s -&gt; next 和 p -&gt; next 的指针做一点改变即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s -&gt; next = p -&gt; next;</span><br><span class="line">p -&gt; next = s;</span><br></pre></td></tr></table></figure><p>这两句代码就是让 p 的后继结点改成 s 的 后继结点，再把结点 s 变成 p 的后继结点</p><p>单链表第 i 个数据插入结点的算法思路：</p><ol><li>声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始；</li><li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1；</li><li>若到链表末尾 p 为空，则说明第 i 个元素不存在；</li><li>否则查找成功，在系统中生成一个空结点 s；</li><li>将数据元素 e 赋值给 s -&gt; data；</li><li>单链表的插入标准语句 s -&gt; next &#x3D; p -&gt; next; p -&gt; next &#x3D; s;</li><li>返回成功。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(LinkList *L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  LinkList p, s;</span><br><span class="line">  p = *L;</span><br><span class="line">  j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(p &amp;&amp; j &lt; i) &#123;</span><br><span class="line">    p = p -&gt; next;<span class="comment">// 寻找第 i 个结点</span></span><br><span class="line">    ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!p || j&gt; i) </span><br><span class="line">    <span class="keyword">return</span> ERROR;<span class="comment">// 第 i 个元素不存在</span></span><br><span class="line">  s = (LinkList) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(Node));<span class="comment">// 生成新结点（C 标准函数）</span></span><br><span class="line">  s -&gt; data = e;</span><br><span class="line">  s -&gt; next = P -&gt; next;<span class="comment">// 将 p 的后继结点赋值给 s 的后继</span></span><br><span class="line">  p -&gt; next = s;<span class="comment">// 将 s 赋值给 p 的后继</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mallloc 标准函数的作用是生成一个新的结点，其类型与 Node 是一样，其实质就是在内存中找了一块空地，准备用来存放 e 数据 s 结点。</p><h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><p>单链表第 i 个数据删除结点的算法思路：</p><ol><li>声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始；</li><li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一个结点，j 累加 1；</li><li>若到链表末尾 p 为空，则说明第 i 个元素不存在；</li><li>否则查找成功，将欲删除的结点 p -&gt; next 赋值给 q；</li><li>单链表的删除标准语句 p -&gt; next &#x3D; q -&gt; next；</li><li>将 q 结点中的数据赋值给 e，作为返回；</li><li>释放 q 结点；</li><li>返回成功。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(LinkList *L, <span class="type">int</span> i, ElemType *e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  LinkList p, q;</span><br><span class="line">  p = *L;</span><br><span class="line">  j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(p -&gt; next &amp;&amp; j &lt; i) &#123;<span class="comment">// 遍历寻找第 i 个元素</span></span><br><span class="line">    p = p -&gt; next;</span><br><span class="line">    ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!(p -&gt;next) || j &gt; i)</span><br><span class="line">    <span class="keyword">return</span> ERROR;<span class="comment">// 第 i 个元素不存在</span></span><br><span class="line">  q = p -&gt; next;</span><br><span class="line">  p -&gt; next = q -&gt; next;<span class="comment">// 将 q 的后继赋值给 p 的后继</span></span><br><span class="line">  *e = q -&gt; next;<span class="comment">// 将 q 结点中的数据给 e</span></span><br><span class="line">  <span class="built_in">free</span>(q);<span class="comment">// 让系统回收此结点，释放内存</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free 标准函数的作用是让系统回收一个 Node 结点，释放内存。</p><p>不管是单链表插入还是删除算法，其实都是由两个部分组成：遍历查找第 i 个元素；插入和删除元素。</p><p>从整个算法来看，它们的时间复杂度都是 O(n)。如果在不知道第 i 个元素的指针位置，单链表数据结构在插入和删除操作上，与线性表的顺序存储结构没有太大优势。但是如果知道第 i 个元素为止，对于顺序存储结构来说，每一次插入或删除都需要移动 n - i 个元素，每次都是 O(n)。而单链表，只需要在第一次时，找到第 i 个位置的指针，此时为 O(n)，接下来只是简单地通过赋值移动指针而已，时间复杂度都是 O(1)。所以，<strong>对于插入或删除数据越频繁的操作，单链表的效率优势越明显</strong>。</p><h3 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h3><p>顺序存储结构的创建，其实就是一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。而单链表和顺序存储结构就不一样，它不像顺序存储结构这么集中，它可以很散，是一种动态结构。对于每个链表来说，它所占空间的大小和位置是不需要预先分配划定的，可以根据系统的情况和实际的需求及时生成。</p><p>创建单链表的过程就是一个动态生成链表的过程。即从“空表”的初始状态起，一次建立各元素结点，并逐个插入链表。</p><p>单链表整表创建的算法思路：</p><ol><li>声明一结点 p 和计数器变量 i；</li><li>初始化一空链表 L；</li><li>让 L 的头结点的指针指向 NULL，即建立一个带头结点的单链表；</li><li>循环：<ul><li>生成一个新结点赋值给 p；</li><li>随机生成一数字赋值给 p 的数据域 p -&gt; data;</li><li>将 p 插入到头结点与前一新结点之间。</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateListHead</span><span class="params">(LinkList *L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  LinkList p;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  srand(time(<span class="number">0</span>));<span class="comment">// 初始化随机数种子</span></span><br><span class="line">  *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">  (*L) -&gt; next = <span class="literal">NULL</span>;<span class="comment">// 先建立一个带头结点的单链表</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">// 生成新结点</span></span><br><span class="line">    p -&gt; data = rand() % <span class="number">100</span> + <span class="number">1</span>;<span class="comment">// 随机生成 100 以内的数字</span></span><br><span class="line">    p -&gt; next = (*L) -&gt; next;</span><br><span class="line">    (*L) -&gt; next = p;<span class="comment">// 插入到表头</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种算法用的是插队的方法，就是始终让新结点在第一的位置。称为头插法。</p><p>也可以把新结点放到最后，称为尾插法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateListTail</span><span class="params">(LinkList *L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  LinkList p, r;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  srand(time(<span class="number">0</span>));<span class="comment">// 初始化随机数种子</span></span><br><span class="line">  *L (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">// 为整个线性表</span></span><br><span class="line">  r = *L;<span class="comment">// r 为指向尾部的结点</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">// 生成新结点</span></span><br><span class="line">    p -&gt; data = rand() % <span class="number">100</span> + <span class="number">1</span>;<span class="comment">// 随机生成 100 以内的数字</span></span><br><span class="line">    r -&gt; next = p;<span class="comment">// 将表尾终端结点的指针指向新结点</span></span><br><span class="line">    r = p;<span class="comment">// 将当前的新结点定义为表尾终端结点</span></span><br><span class="line">  &#125;</span><br><span class="line">  r -&gt; next = <span class="literal">NULL</span>;<span class="comment">// 表示当前链表结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>L 与 r 的关系，L 是指整个单链表，而 r 是指向尾结点的变量，r 会随着循环不断地变化结点，而 L 则是随着循环增长为一个多结点的链表。</p><h3 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h3><p>单链表整表删除的算法思路：</p><ol><li>声明一结点 p 和 q；</li><li>降低一个结点赋值给 P；</li><li>循环：<ul><li>将下一结点赋值给 q；</li><li>释放 p；</li><li>将 q 赋值给 p。</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ClearList</span><span class="params">(LinkList *L)</span> &#123;</span><br><span class="line">  LinkList p,q;</span><br><span class="line">  p = (*L) -&gt; next;<span class="comment">// p 指向第一个结点</span></span><br><span class="line">  <span class="keyword">while</span>(p) &#123;<span class="comment">// 没到表尾</span></span><br><span class="line">    q = p -&gt; next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = q;</span><br><span class="line">  &#125;</span><br><span class="line">  (*L) -&gt; next = <span class="literal">NULL</span>;<span class="comment">// 头结点指针域为空</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h3><p>单链表结构和顺序存储结构对比：</p><ul><li>存储分配方式<ul><li>顺序存储结构用一段连续的存储单元依次存储线性表的数据元素</li><li>单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素</li></ul></li><li>时间性能<ul><li>查找<ul><li>顺序存储结构 O(1)</li><li>单链表 O(n)</li></ul></li><li>插入和删除<ul><li>顺序存储结构需要平均移动表长一半的元素，时间为 O(n)</li><li>单链表在现出某位置的指针后，插入和删除时间仅为 O(1)</li></ul></li></ul></li><li>空间性能<ul><li>顺序存储结构需要与分配存储空间，分大了，浪费，分小了易发生上溢</li><li>单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制</li></ul></li></ul><p>结论：</p><ul><li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。</li><li>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。</li></ul><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>让数组的元素都是由两个数据域组成，data 和 cur。也就是说，数组的每个下标都对应一个 data 和一个 cur。数据域 data，用来存放数据元素，也就是通常要处理的数据；而游标 cur 相当于单链表中的 next 指针，存放该元素的后继在数组中的下标。称这种<strong>用数组描述的链表叫做静态链表</strong>，这种描述方法叫做游标实现法。</p><p>为了我们方便插入数据，可以把数组建立得大一些，以便有一些空闲空间可以便于插入时不至于溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">// 假设链表的最大长度是 1000</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="type">int</span> cur;<span class="comment">// 游标(Cursor)，为 0 时表示无指向</span></span><br><span class="line">&#125; Component, StaticLinkList[MAXSIZE]</span><br></pre></td></tr></table></figure><p>另外对数组第一个和最后一个元素作为特殊元素处理，不存数据。把未被使用的数组元素称为备用链表。而数组第一个元素，即下标为 0 的元素的 cur 就存放备用链表的第一个结点的下标；而数组的最后一个元素的 cur 则存放第一个有数值的元素的下标，相当于单链表中的头结点作用，当整个链表为空时，则为 O<sup>2</sup>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// space[0].cur 为头指针，“0” 表示空指针</span></span><br><span class="line">Status <span class="title function_">InitList</span><span class="params">(StaticLinkList space)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)</span><br><span class="line">    space[i].cur = i + <span class="number">1</span>;</span><br><span class="line">  space[MAXSIZE - <span class="number">1</span>].cur = <span class="number">0</span>;<span class="comment">// 目前静态链表为空，最后一个元素的 cur 为 0</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态链表的插入操作"><a href="#静态链表的插入操作" class="headerlink" title="静态链表的插入操作"></a>静态链表的插入操作</h4><p>静态链表中要解决的是如何用静态模拟动态链表结构的存储空间的分配，需要时申请，无用时释放。</p><p>动态链表中，结点的申请和释放分别用 malloc() 和 free() 两个函数来实现。在静态链表中，操作的是数组，不存在像动态链表的结点申请和释放问题，要自己实现两个函数，才能做插入和删除的操作。</p><p>为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若备用空间链表非空，则返回分配的结点下标，否则返回 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Malloc_SLL</span><span class="params">(StaticLinkList space)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = space[<span class="number">0</span>].cur;<span class="comment">// 当前数组第一个元素的 cur 存的值，就是要返回的第一个备用空闲的下标</span></span><br><span class="line">  <span class="keyword">if</span>(space[<span class="number">0</span>].cur)</span><br><span class="line">    space[<span class="number">0</span>].cur = space[i].cur;<span class="comment">// 由于要拿出一个分量来使用了，所以我们就得把它的下一个分量用来做备用</span></span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码一方面它的作用就是返回一个下标值，这个值就是数组头元素的 cur 存的空闲的下标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 L 中第 i 个元素之前插入新的数据元素 e</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(StaticLinkList L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j, k, l;</span><br><span class="line">  k = MAX_SIZE - <span class="number">1</span>；<span class="comment">// 注意 k 首先是最后一个元素的下标</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; ListLength(L) + <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> ERROR;</span><br><span class="line">  j = Malloc_SSL(L);<span class="comment">// 获得空闲分量的下标</span></span><br><span class="line">  <span class="keyword">if</span>(j) &#123;</span><br><span class="line">    L[j].data = e;<span class="comment">// 将数据赋值给此分量的 data</span></span><br><span class="line">    <span class="keyword">for</span>(l = <span class="number">1</span>; l &lt;= i - <span class="number">1</span>; l++)<span class="comment">// 找到第 i 个元素之前的位置</span></span><br><span class="line">      k = L[k].cur;</span><br><span class="line">    L[j].cur = L[k].cur;<span class="comment">// 把第 i 个元素之前的 cur 赋值给新元素的 cur</span></span><br><span class="line">    L[k].cur = j;<span class="comment">// 把新元素的下标赋值给第 i 个元素之前元素的 cur</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态链表的删除操作"><a href="#静态链表的删除操作" class="headerlink" title="静态链表的删除操作"></a>静态链表的删除操作</h4><p>删除元素是，原来需要释放结点的函数 free()，也由自己实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除在 L 中第 i 个数据元素 e</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(StaticLinkList L, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j, k;</span><br><span class="line">  <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; ListLength(L))</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  k = MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)</span><br><span class="line">    k = L[k].cur;</span><br><span class="line">  j = L[k].cur;</span><br><span class="line">  L[k].cur = L[j].cur;</span><br><span class="line">  Free_SSL(L, j);</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将下标为 k 的空闲结点回收到备用链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Free_SSL</span><span class="params">(StaticLinkList space, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">  space[k].cur = space[<span class="number">0</span>].cur;<span class="comment">//把第一个元素 cur 值赋给要删除的分量</span></span><br><span class="line">  space[<span class="number">0</span>].cur = k;<span class="comment">// 把要删除的分量下标赋值给第一个元素的 cur</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始条件：静态链表 L 已存在。操作结果：返回 L 中数据元素个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(StaticLinkList L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = L[MAXSIZE - <span class="number">1</span>].cur;</span><br><span class="line">  <span class="keyword">while</span>(i) &#123;</span><br><span class="line">    i = L[i].cur;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态链表的优缺点"><a href="#静态链表的优缺点" class="headerlink" title="静态链表的优缺点"></a>静态链表的优缺点</h4><p>优点：</p><ul><li>在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。</li></ul><p>缺点：</p><ul><li>没有解决连续存储分配带来的表长难以确定的问题</li><li>失去了顺序存储结构随机存取的特性</li></ul><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>**将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linked list)**。</p><p>其实循环链表和单链表的主要差异在于循环的判断条件上，原来是判断 p -&gt; next 是否为空，现在则是 p -&gt; next 不等于头结点，则循环未结束。</p><p>在单链表中，有了头结点时，可以用 O(1) 的时间访问第一个结点，但对于要访问到最后一个结点，却需要 O(n) 时间，因为需要将单链表全部扫描一遍。</p><p>有没有可能用 O(1) 的时间由链表指针访问到最后一个结点呢？</p><p>需要改造一下循环链表，不用头指针，而是用指向终端结点的为指针来表示循环链表。终端结点用尾指针 rear 指示，则查找终端结点是 O(1)，而开始结点，其实就是 rear -&gt; next -&gt; next，其时间复杂度也为 O(1)。</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>在单链表中，有了 next 指针，这使得要查找下一结点的时间复杂度为 O(1)。可是如果要查找的是上一结点的话，那最坏的时间复杂度就是 O(n)了，因为每次都要从头开始遍历查找。为了克服单一性这一缺点，设计了双向链表。<strong>双向链表 (double linked list) 是在单链表的每个结点中，在设置一个指向其前驱结点的指针域</strong>。所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性表的双向链表存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> &#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">prior</span>;</span><span class="comment">// 直接前驱指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">next</span>;</span><span class="comment">// 直接后继指针</span></span><br><span class="line">&#125; DulNode, *DuLinkList;</span><br></pre></td></tr></table></figure><p>双向链表是单链表中扩展出来的结构，所以它的很多操作是和单链表相同的，比如求长度 ListLength，查找元素的 GetElem，获得元素位置的 LocateElem 等，这些操作都只要涉及一个方向的指针即可，另一个指针多了也不能提供什么帮助。</p><p>插入操作时，假设存储元素 e 的结点为 s，要实现将结点 s 插入到结点 p 和 p -&gt; next 之间需要以下几步：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s -&gt; prior = p;<span class="comment">// 把 p 赋值给 s 的前驱</span></span><br><span class="line">s -&gt; next = p -&gt; next;<span class="comment">// 把 p -&gt; next 赋值给 s 的后继</span></span><br><span class="line">p -&gt; next -&gt; prior = s;<span class="comment">// 把 s 赋值给 p -&gt; next 的前驱</span></span><br><span class="line">p -&gt; next = s;<span class="comment">// 把 s 赋值给 p 的后继</span></span><br></pre></td></tr></table></figure><p>删除操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; prior -&gt; next = p -&gt; next;<span class="comment">// 把 p -&gt; next 赋值给 p -&gt; prior 的后继</span></span><br><span class="line">p -&gt; next -&gt; prior = p -&gt; prior;<span class="comment">// 把 p -&gt; prior 赋值给 p -&gt; next 的前驱</span></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">// 释放结点</span></span><br></pre></td></tr></table></figure><p>双向链表对于单链表来说，多了 prior 指针。另外它由于每个结点都需要记录两份指针，所以在空间上是要占用略多一些的。不过由于它良好的对称性，使得对某个结点的前后结点的操作，带来了方便，可以有效提高算法的时间性能。也就是用空间来换时间。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>线性表：是零个或多个相同类型的数据元素的有限序列。</p><p>由与顺序存储结构的插入和删除操作不方便，引出了链式存储结构，它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点。、</p><p>链式存储结构的不同形式：单链表、循环链表和双向链表。</p><p><img src="/../img/dsa/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%88%86%E7%B1%BB.png" alt="线性表分类"></p><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><blockquote><p>栈与队列：</p><p>栈是限定仅在表尾进行插入和删除操作的线性表。</p><p>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。</p></blockquote><h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><h4 id="栈的定义-1"><a href="#栈的定义-1" class="headerlink" title="栈的定义"></a>栈的定义</h4><blockquote><p>栈 (stack) 是限定仅在表尾进行插入和删除操作的线性表。</p></blockquote><p>把允许插入和删除的一端称为栈顶 (top)，另一端称为栈底 (bottom)，不含任何数据元素的栈称为空栈。栈又称为后进先出 (Last In First Out) 的线性表，简称 LIFO 结构。</p><p>栈是一个线性表，也就是说栈元素具有线性关系，即前驱后继关系。只不过它是一种特殊的线性表而已。定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。</p><p><strong>栈的插入操作，叫作进栈，也成压栈、入栈。栈的删除操作，叫作出栈，也有的叫作弹栈。</strong></p><p><img src="/../img/dsa/%E8%BF%9B%E6%A0%88%E5%87%BA%E6%A0%88.png" alt="进栈出栈"></p><h4 id="进栈出栈变化形式"><a href="#进栈出栈变化形式" class="headerlink" title="进栈出栈变化形式"></a>进栈出栈变化形式</h4><blockquote><p>是不是最先进栈的元素就只能是最后出栈呢？</p></blockquote><p>在不是所有元素都进栈的情况下，事先进去的元素也可以出栈，只要保证栈顶元素出栈即可。</p><p>例如有 3 个整型数字 1、2、3 一次进栈，会有一下几种出栈次序。</p><ul><li>1、2、3 进，再 3、2、1 出。出栈顺序为 321。</li><li>1 进，1 出，2 进，2 出，3 进，3 出。出栈顺序为 123。</li><li>1 进，2 进，2 出，1 出，3 进，3 出。出栈顺序为 213。</li><li>1 进，1 出，2 进，3 进，3 出，2 出。出栈顺序为 132。</li><li>1 进，2 进，2 出，3 进，3 出，1 出。出栈顺序为 231。</li></ul><p>没有可能出现 312 这种出栈顺序，因为 3 先出栈，说明 3 曾经进栈，意味着 1 和 2 已经进栈了，此时 2 一定在 1 的上面。</p><h3 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h3><p>对于栈来讲，理论上线性表的操作特性他都具备，可由于它的特殊性，所以针对它在操作上会有些变化。特别是插入和删除操作，push 和 pop，一般叫作进栈和出栈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 栈(<span class="built_in">stack</span>)</span><br><span class="line">Data</span><br><span class="line">  同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">  <span class="title function_">InitStack</span><span class="params">(*S)</span>: 初始化操作，建立一个空栈 S。</span><br><span class="line">  <span class="title function_">DestroyStack</span><span class="params">(*S)</span>: 若栈存在，则销毁它。</span><br><span class="line">  <span class="title function_">ClearStack</span><span class="params">(*S)</span>: 将栈清空。</span><br><span class="line">  <span class="title function_">StackEmpty</span><span class="params">(S)</span>: 若栈为空，返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line">  <span class="title function_">GetTop</span><span class="params">(S, *e)</span>: 若栈存在且为空，用 e 返回 S 的栈顶元素。</span><br><span class="line">  <span class="title function_">Push</span><span class="params">(*S, e)</span>: 若栈 s 存在，插入新元素 e 到栈 S 中并成为栈顶元素。</span><br><span class="line">  <span class="title function_">Pop</span><span class="params">(*S, *e)</span>: 删除栈 S 中栈顶元素，并用 e 返回其值。</span><br><span class="line">  <span class="title function_">StackLength</span><span class="params">(S)</span>: 返回栈 S 的元素个数。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p>栈本身就是线性表，所以线性表的顺序存储和链式存储对于栈来说，也是同样适用的。</p><h3 id="栈的顺序存储结构及实现"><a href="#栈的顺序存储结构及实现" class="headerlink" title="栈的顺序存储结构及实现"></a>栈的顺序存储结构及实现</h3><h4 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h4><blockquote><p>线性表使用数组实现的，但是栈只能一头插入删除，所以要考虑用数组的哪一端作为栈顶和栈底比较好。</p></blockquote><p>下标为 0 的一端作为栈底比较好，因为首元素都存在栈底，变化最小，所以让它做栈底。</p><p>定义一个 top 变量来指示栈顶元素在数组中的位置，这 top 就如同中学物理学过的游标卡尺的游标，可以来回移动，意味着栈顶的 top 可以变大变小，但无论如何游标不能超出尺的长度。同理，若存储栈的长素为 StackSize，则栈顶位置 top 必须小于 StackSize。当栈存在一个元素时，top 等于 0，因此通常把空栈的判定条件定为 top 等于 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;<span class="comment">// SElemType 类型根据实际情况而定，这里假设为 int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  SElemType data[MAXSIZE];</span><br><span class="line">  <span class="type">int</span> top;<span class="comment">// 用于栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><h4 id="栈的顺序存储结构——进栈操作"><a href="#栈的顺序存储结构——进栈操作" class="headerlink" title="栈的顺序存储结构——进栈操作"></a>栈的顺序存储结构——进栈操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入元素 e 为新的栈顶元素</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqStack *S, SElemType e)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(S -&gt; top == MAXSIZE - <span class="number">1</span>) &#123;<span class="comment">// 栈满</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">  S -&gt; top++;<span class="comment">// 栈顶指针增加 1</span></span><br><span class="line">  S -&gt; data[S -&gt; top] = e;<span class="comment">// 将新元素赋值给栈顶空间</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈的顺序存储结构——出栈操作"><a href="#栈的顺序存储结构——出栈操作" class="headerlink" title="栈的顺序存储结构——出栈操作"></a>栈的顺序存储结构——出栈操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若栈不空，则删除 S 的栈顶元素，用 e 返回其值，并返回 OK；否则返回 ERROR</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqStack *S, SElemType *e)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(S -&gt; top == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  *e = S -&gt; data[S -&gt; top];<span class="comment">// 将要删除的栈顶元素赋值给 e</span></span><br><span class="line">  S -&gt; top--;<span class="comment">// 栈顶指针减 1</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入栈和出栈操作都没有涉及到任何循环语句，时间复杂度均是 O(1)。</p><h3 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h3><p>如果有两个相同类型的栈，为它们各自开辟了数组空间，极有可能是第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。可以用一个数组来存储两个栈。数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为 0 处，另一个栈的栈底为数组的末端，即下标为为数组长度 n - 1 处。这样，两个栈如果增加元素，就是两端点向中间延伸。</p><p><img src="/../img/dsa/%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4.png" alt="两栈共享空间"></p><p>它们在数组的两端，向中间靠拢。top1 和 top2 是栈 1 和 栈 2 的栈顶指针。当栈 1 为空时，就是 top1 &#x3D; -1 时；而当 top2 等于 n 时，即是栈 2 为空时。若栈 2 是空栈，栈 1 的 top1 &#x3D; n - 1 时，就是栈 1 满了。反之，当栈 1 为空栈时，top2  &#x3D; 0 时，为栈 2 满。但更多的情况是两个指针之间相差 1 时，即 top1 + 1 &#x3D;&#x3D; top2 为栈满。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两栈共享空间结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  SElemType data[MAXSIZE];</span><br><span class="line">  <span class="type">int</span> top1;<span class="comment">// 栈 1 栈顶指针</span></span><br><span class="line">  <span class="type">int</span> top2;<span class="comment">// 栈 2 栈顶指针</span></span><br><span class="line">&#125;SqDoubleStack;</span><br></pre></td></tr></table></figure><p>对于两栈共享空间的 push 方法，除了要插入元素值参数外，还需要有一个判断是栈 1 还是栈 2 的栈号 stackNumber。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入元素 e 为新的栈顶元素</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqDoubleStack *S, SElemType e, <span class="type">int</span> stackNumber)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(S -&gt; top1 + <span class="number">1</span> == S -&gt; top2)<span class="comment">// 栈已满，不能再 push 新元素了</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span>(stackNumber == <span class="number">1</span>)<span class="comment">// 栈 1 有元素进栈</span></span><br><span class="line">    S -&gt; data[++S -&gt; top1] = e;<span class="comment">// 若栈 1 则先 top1 + 1 后给数组元素赋值</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(stackNumber == <span class="number">2</span>)<span class="comment">// 栈 2 有元素进栈</span></span><br><span class="line">    S -&gt; data[--S -&gt; top2] = e;<span class="comment">// 若栈 2 则先 top2 - 1 后给数组元素赋值</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在开始已经判断了是否有栈满的情况，所以后面的 top1 + 1 或 top2 -1 是不担心溢出问题的。</p><p>对于两栈共享空间的 pop方法，参数就只是判断栈 1 栈 2 的参数 stackNumber。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若栈不空，则删除 S 的栈顶元素，用 e 返回其值，并返回 OK；否则返回 ERROR</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqDoubleStack *S, SElemType *e, <span class="type">int</span> stackNumber)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(stackNumber == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(S -&gt; top1 == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">return</span> ERROR;<span class="comment">// 说明栈 1 已经是空栈，溢出</span></span><br><span class="line">    *e = S -&gt; data[S -&gt; top1--];<span class="comment">// 将栈 1 的栈顶元素出栈</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(stackNumber == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(S -&gt; top2 == MAXSIZE)</span><br><span class="line">      <span class="keyword">return</span> ERROR;<span class="comment">// 说明栈 2 已经是空栈，溢出</span></span><br><span class="line">    *e = S -&gt; data[S -&gt; top2++];<span class="comment">// 将栈 2 的栈顶元素出栈</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，使用这样的数据结构，通常都是当两个栈的空间需求有相反的关系时，也就是一个栈增长时另一个栈在缩短的情况。当然，这只是针对两个具有相同数据类型的栈的一个设计上的技巧，如果不是相同数据类型的栈，这种办法不但不能更好地处理问题，反而会使问题变得更复杂。</p><h3 id="栈的链式存储结构及实现"><a href="#栈的链式存储结构及实现" class="headerlink" title="栈的链式存储结构及实现"></a>栈的链式存储结构及实现</h3><h4 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h4><p><strong>栈的链式存储结构，简称链栈</strong>。对于链栈来说，栈顶是放在单链表的头部，栈顶在头部，单链表中的中结点也失去了意义，所以是不需要头结点的。</p><p><img src="/../img/dsa/%E9%93%BE%E6%A0%88.png" alt="链栈"></p><p>对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间，如果真的发生，那此时的计算机操作系统已经面临司机崩溃的情况，而不是这个链栈是否溢出的问题。</p><p>但对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是 top &#x3D; NULL 的时候。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">  SElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode, *LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span> &#123;</span></span><br><span class="line">  LinkStackPtr top;</span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure><p>链栈的操作绝大部分都和单链表类似，指示在插入和删除上，特殊一些。</p><h4 id="栈的链式存储结构——进栈操作"><a href="#栈的链式存储结构——进栈操作" class="headerlink" title="栈的链式存储结构——进栈操作"></a>栈的链式存储结构——进栈操作</h4><p>对于链栈的进栈 push 操作，假设元素值为 e 的新结点是 s，top 为栈顶指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入元素 e 为新的栈顶元素</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(LinkStack *S, SElemType e)</span> &#123;</span><br><span class="line">  LinkStackPtr s = (LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">  s -&gt; data = e;</span><br><span class="line">  s -&gt; next = S -&gt; top;<span class="comment">// 把当前的栈顶元素赋值给新结点的直接后继</span></span><br><span class="line">  S -&gt; top = s;<span class="comment">// 将新的结点 s 赋值给栈顶指针</span></span><br><span class="line">  S -&gt; count++;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈的链式存储结构——出栈操作"><a href="#栈的链式存储结构——出栈操作" class="headerlink" title="栈的链式存储结构——出栈操作"></a>栈的链式存储结构——出栈操作</h4><p>至于链栈的出栈 pop操作，也是很简单的三句操作。假设变量 p 用来存储要删除的栈顶结点，将栈顶指针下移一位，最后释放 p 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若栈不空，则删除 S 的栈顶元素，用 e 返回其值，并返回 OK；否则返回 ERROR</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(LinkStack *S, SElemType *e)</span> &#123;</span><br><span class="line">  LinkStackPtr p;</span><br><span class="line">  <span class="keyword">if</span>(StackEmpty(*S))</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  *e = S -&gt; top -&gt; data;</span><br><span class="line">  p = S -&gt; top;<span class="comment">// 将栈顶结点赋值给 p</span></span><br><span class="line">  S -&gt; top = S -&gt; top -&gt; next;<span class="comment">// 使得栈顶指针下移一位，指向后一结点</span></span><br><span class="line">  <span class="built_in">free</span>(p);<span class="comment">// 释放结点 p</span></span><br><span class="line">  S -&gt; count--;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链栈的进栈 push 和出栈 pop操作都没有任何循环，时间复杂度都是 O(1)。</p><p>对比一下顺序栈和链栈，它们在时间复杂度上是一样的，均为 O(1)。对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。所以它们的区别和线性表中讨论的一样，<strong>如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些</strong>。</p><h3 id="栈的作用"><a href="#栈的作用" class="headerlink" title="栈的作用"></a>栈的作用</h3><p>栈的引入简化了程序设计的问题，划分了不同关注层次，是的思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。</p><p>所以现在的很多高级语言，比如 Java、C# 等都有对栈结构的封装，不用关心它的实现细节，就可以直接使用 Stack 的 push 和 pop 方法，很方便。</p><h3 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h3><blockquote><p>栈有一个很重要的应用：在程序设计语言中实现了递归。</p></blockquote><h4 id="斐波那契数列实现"><a href="#斐波那契数列实现" class="headerlink" title="斐波那契数列实现"></a>斐波那契数列实现</h4><table><thead><tr><th align="center">1</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">5</th><th align="center">8</th><th align="center">13</th><th align="center">21</th><th align="center">34</th><th align="center">55</th><th align="center">89</th><th align="center">144</th></tr></thead></table><p>表格中的数据特点：前两相邻两项之和，构成了后一项。</p><p>用数学函数定义：</p><p>F(n) &#x3D; 0，当 n &#x3D; 0；</p><p>F(n) &#x3D; 1，当 n &#x3D; 1；</p><p>F(n) &#x3D; F(n -1) + F(n - 2)，当 n &gt; 1</p><p>常用迭代方法实现，输出前 40 位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">40</span>];</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    System.out.print(a[<span class="number">0</span>] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.print(a[<span class="number">1</span>] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">        a[i] = a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>];</span><br><span class="line">        System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契的递归函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fbi</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fbi(i - <span class="number">1</span>) + fbi(i - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">40</span>; j++)</span><br><span class="line">        System.out.print(fbi(j) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归的定义"><a href="#递归的定义" class="headerlink" title="递归的定义"></a>递归的定义</h4><p><strong>把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，乘坐递归函数。每个递归定义必须至少有一个条件，满足时递归不再进行，既不再引用自身而是返回值退出</strong>。</p><p>迭代和递归的区别：迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会消耗大量的时间和内存。迭代则不需要反复调用和占用额外的内存。因此应该视不同情况选择不同的代码实现方式。</p><h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><blockquote><p>队列 (queue) 是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p></blockquote><p><strong>队列是一种先进先出 (First In First Out) 的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头</strong>。</p><p><img src="/../img/dsa/%E9%98%9F%E5%88%97.png" alt="队列"></p><h3 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h3><p>同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 队列(Queue)</span><br><span class="line">Data</span><br><span class="line">  同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">  <span class="title function_">InitQueue</span><span class="params">(*Q)</span>: 初始化操作，建立一个空队列 Q。</span><br><span class="line">  <span class="title function_">DestroyQueue</span><span class="params">(*Q)</span>: 若队列 Q 存在，则销毁它。</span><br><span class="line">  <span class="title function_">ClearQueue</span><span class="params">(*Q)</span>: 将队列 Q 清空。</span><br><span class="line">  <span class="title function_">QueueEmpty</span><span class="params">(Q)</span>: 若队列 Q 为空，返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line">  <span class="title function_">GetHead</span><span class="params">(Q, *e)</span>: 若队列 Q 存在且非空，用 e 返回队列 Q 的队头元素。</span><br><span class="line">  <span class="title function_">EndQueue</span><span class="params">(*Q, e)</span>: 若队列 Q 存在，插入新元素 e 到队列 Q 中并成为队尾元素。</span><br><span class="line">  <span class="title function_">DeQueue</span><span class="params">(*Q, *e)</span>: 删除队列 Q 中队头元素，并用 e 返回其值。</span><br><span class="line">  <span class="title function_">QueueLength</span><span class="params">(Q)</span>: 返回队列 Q 的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><h4 id="队列顺序存储的不足"><a href="#队列顺序存储的不足" class="headerlink" title="队列顺序存储的不足"></a>队列顺序存储的不足</h4><p>假设一个队列有 n 个元素，则顺序存储的队列需建立一个大于 n 的数组，并把队列的所有元素存储在数组的前 n 个单元，数组下标为 0 的一端即是队头。所谓的入队列操作，其实就是在队尾追加一个元素，不需要移动任何元素，因此时间复杂度为 O(1)。</p><p>与栈不同的是，队列元素的出列是在队头，即下标为 0 的位置，那也就意味着，队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为 0 的位置不为空，此时时间复杂度为 O(n)。</p><p>队列不限制元素必须存储在数组的前 n 个单元这一条件，出队的性能就会大大增加。也就是说，队头不需要一定在下标为 0 的位置。</p><p>为了避免当只有一个元素时，队头和队尾重合使得处理变得麻烦，所以引入两个指针，front 指针指向队头元素，rear 指针指向队尾元素的下一个位置，这样当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列。</p><p>假设是长度为 5 的数组，初始状态，front 与 rear 指针均指向下标为 0 的位置。然后入队 a1、a2、a3、a4，front 指针依然指向下标为 0 位置，而 rear 指针指向下标为 4 的位置。</p><p>出队 a1、a2，则 front 指针指向下标为 2 的位置，rear 不变，在入队 a5，此时 front 指针不变，rear 指针移动到数组之外。因为此时数组末尾元素已经占用，再向后加，就会产生数组越界的错误。可实际上，队列在下标为 0 和 1 的地方还是空闲的。这种现象叫做“假溢出”。</p><h4 id="循环队列定义"><a href="#循环队列定义" class="headerlink" title="循环队列定义"></a>循环队列定义</h4><p>解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。<strong>我们把队列的这种头尾相接的顺序存储结构称为循环队列</strong>。</p><p>继续上面的例子，入队 a5 时，rear 改为指向下标为 0 的位置，这样就不会造成指针指向不明的问题了。</p><p>接着入队 a6，将它放置于下标为 0 处，rear 指针指向下标为 1 处。若再入队a7，则 rear 指针就与 front 指针重合，同时指向下标为 2 的位置。</p><p>空队列时，front 等于 rear， 但是现在队列满时，也是 front 等于 rear，如何判断此时的队列究竟是空还是满呢？</p><ul><li>方法一：设置一个标志变量 flag，当 front &#x3D;&#x3D; rear，且 flag &#x3D; 0 时为空队列，当 front &#x3D;&#x3D; rear，且 flag &#x3D; 1 时为满队列。</li><li>方法二：当队列空时，条件就是 front &#x3D;&#x3D; rear，当队列满时，修改其条件，保留一个元素空间。队列满时，数组中还有一个空闲单元。</li></ul><p>方法二中，由于 rear 可能比 front 大，也可能比 front 小，所以尽管指向差一个位置时就是满的情况，但也可能是相差整整一圈。所以队列的最大尺寸为 QueueSize，那么<strong>队列满的条件是 (rear + 1) % QueueSize &#x3D;&#x3D; front</strong> (取模 “%” 的目的就是为了整合 rear 与 front 大小为一个问题)。</p><p>另外，当 rear &gt; front 时，此时队列的长度为 rear - front。但当 rear &lt; front 时，队列长度分为两段，一段是 QueueSize - front，另一段是 0 + rear，加在一起，队列长度为 rear - front + QueueSize。因此通用的计算队列长度公式为：</p><p><strong>(rear - front + QueueSize) % QueueSize</strong></p><p>循环队列的顺序存储结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;<span class="comment">// QElemType 类型根据实际情况而定，这里假设为 int </span></span><br><span class="line"><span class="comment">// 循环队列的顺序存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  QElemType data[MAXSIZE];</span><br><span class="line">  <span class="type">int</span> front;<span class="comment">// 头指针</span></span><br><span class="line">  <span class="type">int</span> rear;<span class="comment">// 尾指针，若队列不空，指向队列尾元素的下一个位置</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p>循环队列的初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个空队列</span></span><br><span class="line">Status <span class="title function_">InitQueue</span><span class="params">(SqQueue *Q)</span> &#123;</span><br><span class="line">  Q -&gt; front = <span class="number">0</span>;</span><br><span class="line">  Q -&gt; rear = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环队列求队列长度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 Q 的元素个数，也就是队列的当前长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueLength</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (Q.rear - Q.front + MAXSIZE) % MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环队列的入队列操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若队列未满，则插入元素 e 为 Q 新的队列元素</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(SqQueue *Q, QElemType e)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>((Q -&gt; rear + <span class="number">1</span>) % MAXSIZE == Q -&gt; front)<span class="comment">// 队列满的判断</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  Q -&gt; data[Q -&gt; rear] = e;<span class="comment">// 将元素 e 赋值给队尾</span></span><br><span class="line">  Q -&gt; rear = (Q -&gt; rear + <span class="number">1</span>) % MAXSIZE;<span class="comment">// rear 指针向后移一位置，若到最后则转到数组头部</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环队列的出队操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(SqQueue *Q, QElemType *e)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(Q -&gt; front == Q -&gt; rear)<span class="comment">// 队列空的判断</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  *e = Q -&gt; data[Q -&gt; front];<span class="comment">// 将队列元素赋值给 e</span></span><br><span class="line">  Q -&gt; front = (Q -&gt; front + <span class="number">1</span>) % MAXSIZE;<span class="comment">// front 指针向后移一位置，若到最后则转到数组头部</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的链式存储结构及实现"><a href="#队列的链式存储结构及实现" class="headerlink" title="队列的链式存储结构及实现"></a>队列的链式存储结构及实现</h3><p><strong>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，把它称为链队列</strong>。为了操作上的方便，我们将队头指针指向链队列的头结点，而队列指针指向终端结点。</p><p><img src="/../img/dsa/%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0.png" alt="队列的链式存储结构及实现"></p><p>空队列时，front 和 rear 都指向头结点。</p><p>链队列的结构为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;<span class="comment">// QElemType 类型根据实际情况而定，这里假设为 int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span><span class="comment">// 结点结构</span></span><br><span class="line">  QElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">// 队列的链表结构</span></span><br><span class="line">  QueuePtr front, rear;<span class="comment">// 队头、队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><h4 id="队列的链式存储结构——入队操作"><a href="#队列的链式存储结构——入队操作" class="headerlink" title="队列的链式存储结构——入队操作"></a>队列的链式存储结构——入队操作</h4><p>入队操作就是在链表尾部插入结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入元素 e 为 Q 的新的队尾元素</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(LinkQueue *Q, QElemType e)</span> &#123;</span><br><span class="line">  QueuePtr s = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">  <span class="keyword">if</span>(!s)<span class="comment">// 存储分配失败</span></span><br><span class="line">    <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">  s -&gt; data = e;</span><br><span class="line">  s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">  Q -&gt; rear -&gt; next = s;<span class="comment">// 把拥有元素 e 新结点 s 赋值给原队尾结点的后继</span></span><br><span class="line">  Q -&gt; rear = s;<span class="comment">// 把当前的 s 设置为队尾结点，rear 指向 s</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="队列的链式存储结构——出队操作"><a href="#队列的链式存储结构——出队操作" class="headerlink" title="队列的链式存储结构——出队操作"></a>队列的链式存储结构——出队操作</h4><p>出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素时，则需将 rear 指向头结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若队列不空，删除 Q 的队列元素，用 e 返回其值，并返回 OK，否则返回 ERROR</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(LinkQueue *Q, QElemType *e)</span> &#123;</span><br><span class="line">  QueuePtr p;</span><br><span class="line">  <span class="keyword">if</span>(Q -&gt; front == Q -&gt; rear)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  p = Q -&gt; front -&gt; next;<span class="comment">// 将预删除的队头结点暂存给 p</span></span><br><span class="line">  *e = p -&gt; data;<span class="comment">// 将预删除的队头结点的值赋值给 e</span></span><br><span class="line">  Q -&gt; front -&gt; next = p -&gt; next;<span class="comment">// 将原队头结点后继 p -&gt; next 赋值给头结点后继</span></span><br><span class="line">  <span class="keyword">if</span>(Q -&gt; rear == p)<span class="comment">// 若队头是队尾，则删除后将 rear 指向头结点</span></span><br><span class="line">    Q -&gt; rear = Q -&gt; front;</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于循环队列与链队列的比较，可以从两方面来考虑， 从时间上，其实它们的基本操作都是常数时间，即都为 O(1) 的，不过循环队列是实现申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。对于空间上来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵活。总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果无法预估队列的长度时，则用链队列。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>栈 (Stack) 是限定仅在表尾进行插入和删除操作的线性表。</p><p>队列 (queue) 是只允许在一段进行插入操作，而在另一端进行删除操作的线性表。</p><p>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。</p><p>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得插入和删除是 O(n) 的时间复杂度变成了 O(1)。</p><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h3><blockquote><p>串：是由零个或多个字符组成的有限序列，又名叫字符串。</p></blockquote><p><strong>一般记为 s &#x3D; “a<sub>1</sub>a<sub>2</sub> …… a<sub>n</sub>“ (n ≥ 0)<strong>，其中，s 是串的名称，用双引号括起来的字符序列是串的值，注意单引号不属于串的内容。a<sub>i</sub> (1 ≤ i ≤ n) 可以是字母、数字或其他字符，i 就是该字符在串中的位置。</strong>串中的字符数目 n 称为串的长度</strong>，定义中谈到的“有限”是指长度 n 是一个有限的数值。**零个字符的串称为空串 (null string)**，它的长度为零，可以直接用两双引号 “” 表示，也可以用希腊字母 𝛟 来表示。所谓的序列，说明串的相邻字符之间具有前驱和后继的关系。</p><p>空格串，是只包含空格的串。注意它与空串的区别，空格串是有内容长度的，而且可以不止一个空格。</p><p>子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。</p><p>子串在主串中的位置就是子串的第一个字符在主串中的序号。</p><p>“over”、“end“、”lie“ 其实可以认为是 ”lover“、”friend“、”believe“ 这些单词字符串的子串。</p><h3 id="串的比较"><a href="#串的比较" class="headerlink" title="串的比较"></a>串的比较</h3><p>两个数字，很容易比较大小。2 比 1 大，这完全正确，可是两个字符串如何比较？比如 ”silly“、”stupid“ 这样的同样表达”愚蠢的“的单词字符串，它们在计算机中的大小其实取决于它们挨个字母的前后顺序。它们的第一个字母都是 ”s”，我们认为不存在大小差异，而第二个字母，由于 “i” 字母比 “t” 字母要靠前，所以 “i“ &lt; “t”，于是我们说 “silly” &lt; “stupid”。</p><p>事实上，串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的是字符在对应字符集中的序号。</p><p>计算机中的常用字符是使用标准的 ASCII 编码，更准确一点，由 7 位二进制数表示一个字符，总共可以表示 128 个字符。后来发现一些特殊符号的出现，128 个不够用，于是扩展 ASCII 码由 8 位二进制数表示一个字符，总共可以表示 256 个字符，这已经足够满足以英语为主的语言和特殊符号进行输入、存储、输出等操作的字符需要了。可是，单我们国家就有除汉族外的满、回、藏、蒙古、维吾尔等多个少数民族文字，换作全世界估计要有成百上千种语言与文字，显然这 256 个字符是不够的，因此后来就有了 Unicode 编码，比较常用的是由 16 位二进制数表示一个字符，这样总共就可以表示 216 个字符，约是 65 万多个字符，足够表示世界上所有语言的所有字符了。当然，为了和 ASCII 码兼容，Unicode 的前 256 个字符与 ASCII 码完全相同。</p><p>所以如果在 C 语言中比较两个串是否相等，必须是它们串的长度以及它们各个对应位置的字符都相等时，才算是相等的。即给定两个串：s &#x3D; “a<sub>1</sub>a<sub>2</sub> …… a<sub>n</sub>“，t &#x3D; “b<sub>1</sub>b<sub>2</sub> …… b<sub>m</sub>“，当且仅当 n &#x3D; m，且 a<sub>1</sub> &#x3D; b<sub>1</sub>，a<sub>2</sub> &#x3D; b<sub>2</sub>，…… ，a<sub>n</sub> &#x3D; a<sub>m</sub> 时，我们认为 s &#x3D; t。</p><blockquote><p>那么对于两个串不相等时，如何判定它们的大小？</p></blockquote><p><strong>给定两个串：s &#x3D; “a<sub>1</sub>a<sub>2</sub> …… a<sub>n</sub>“，t &#x3D; “b<sub>1</sub>b<sub>2</sub> …… b<sub>m</sub>“，当满足一下条件之一时，s &lt; t。</strong></p><ol><li><p>**n &lt; m，且 a<sub>i</sub> &#x3D; b<sub>i</sub> (i &#x3D; 1, 2, …… , n)**。</p><p> 例如当 s &#x3D; “hap”，t &#x3D; “happy”，就有 s &lt; t。因为 t 比 s 多出了两个字母。</p></li><li><p>**存在某个 k ≤ min(m, n)，使得 <sub>i</sub> &#x3D; b<sub>i</sub> (i &#x3D; 1, 2, ……, k - 1)，且a<sub>k</sub> &lt; b<sub>k</sub>**。</p><p> 例如当 s &#x3D; “happen”，t &#x3D; “happy”，因为两串的前 4 个字母均相同，而两串第 5 个字母 (k 值)，字母 e 的 ASCII 码是 101，而字母 y 的 ASCII 码是 121，显然 e &lt; y，所以 s &lt; t。</p></li></ol><h3 id="串的抽象数据类型"><a href="#串的抽象数据类型" class="headerlink" title="串的抽象数据类型"></a>串的抽象数据类型</h3><p>串的逻辑结构和线性表很相似，不同之处在于串针对的是字符集，也就是串中的元素都是字符，哪怕串中的字符是 “123” 这样的数字组成，或者 “2022-08-08” 这样的日期组成，它们都只能理解为长度为 3 和长度为 10 的字符串，每个元素都是字符而已。</p><p>因此，对于串的基本操作与线性表是有很大差别的。线性表更关注的是单个元素的操作，比如查找一个元素，插入或删除一个元素，但串中更多的是查找子串位置、得到指定位置子串、替换子串等操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ADT 串(<span class="built_in">string</span>)</span><br><span class="line">Data</span><br><span class="line">  串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">  <span class="title function_">StrAssign</span><span class="params">(T, *chars)</span>: 生成一个其值等于字符串常量 chars 的串 T。</span><br><span class="line">  <span class="title function_">StrCopy</span><span class="params">(T, S)</span>: 串 S 存在，由串 S 复制得串 T。</span><br><span class="line">  <span class="title function_">ClearString</span><span class="params">(S)</span>: 串 S 存在，将串清空。</span><br><span class="line">  <span class="title function_">StringEmpty</span><span class="params">(S)</span>: 若串 S 为空，返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line">  <span class="title function_">StrCompare</span><span class="params">(S, T)</span>: 若 S &gt; T，返回值 &gt; 0，若 S = T，返回 <span class="number">0</span>，若 S &lt; T，返回值 &lt; <span class="number">0</span>。</span><br><span class="line">  StrLength(S): 返回串 S 的元素个数，即串的长度。</span><br><span class="line">  Concat(T, S1, S2): 用 T 返回由 S1 和 S2 连接而成的新串。</span><br><span class="line">  SubString(Sub, S, pos, len): 串 S 存在，<span class="number">1</span> ≤ pos ≤ StrLength(S)，且 <span class="number">0</span> ≤ len ≤ StrLength(S) - pos + <span class="number">1</span>，用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串。</span><br><span class="line">  Index(S, T, pos): 串 S 和 T 存在，T 是非空串，<span class="number">1</span> ≤ pos ≤ StrLength(S)。若主串 S 中存在和串 T 值相同的子串，则返回它在主串 S 中第 pos 个字符之后第一次出现的位置，否则返回 <span class="number">0</span>。</span><br><span class="line">  Replace(S, T, V): 串 S、T 和 V 存在，T 是非空串。用 V 替换主串 S 中出现的所有与 T 相等的不重叠的子串。</span><br><span class="line">  StrInsert(S, pos, T): 串 S 和 T 存在，<span class="number">1</span> ≤ pos ≤ StrLength(S) + <span class="number">1</span>。在串 S 的第 pos 个字符之前插入串 T。</span><br><span class="line">  StrDelete(S, pos, len): 串 S 存在，<span class="number">1</span> ≤ pos ≤StrLength(S) - len + <span class="number">1</span>。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p>操作 Index 的实现算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 为非空串。若主串 S 中第 pos 个字符之后存在与 T 相等的子串，则返回第一个这样的子串在 S 中的位置，否则返回 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(String S, String T, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n, m, i;</span><br><span class="line">  String sub;</span><br><span class="line">  <span class="keyword">if</span>(pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    n = StrLength(S);<span class="comment">// 得到主串 S 的长度</span></span><br><span class="line">    m = StrLength(T);<span class="comment">// 得到子串 T 的长度</span></span><br><span class="line">    i = pos;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n - m + <span class="number">1</span>) &#123;</span><br><span class="line">      SubString(sub, S, i, m);<span class="comment">// 取主串第 i 个位置，长度与 T 相等子串给 sub</span></span><br><span class="line">      <span class="keyword">if</span>(StrCompare(sub, T) != <span class="number">0</span>)<span class="comment">// 如果两串不相等</span></span><br><span class="line">        ++i;</span><br><span class="line">      <span class="keyword">else</span><span class="comment">// 如果两串相等</span></span><br><span class="line">        <span class="keyword">return</span> i;<span class="comment">// 则返回 i 值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 若无子串与 T 相等，返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h3><h4 id="串的顺序存储结构"><a href="#串的顺序存储结构" class="headerlink" title="串的顺序存储结构"></a>串的顺序存储结构</h4><p>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义。</p><p>既然是定长数组，就存在一个预定义的最大串长度，一般可以将实际的串长度值保存在数组的 0 下标位置 (也可以定义存储在数组的最后一个下标位置)。有些编程语言觉得存个数字占个空间麻烦。它规定在串值后面加一个不计入串长度的结束标记字符，比如 “\0“ 来表示串值的终结。但是，当遍历计算串长度时，会发现结束标记字符也是占用了一个空间的。</p><p>以上所说的串的顺序存储方式其实是有问题的，因为字符串的操作，比如两串的连接 Concat、新串的插入 StrInsert，以及字符串的替换 Replace，都有可能使得串序列的长度超过了数组的长度 MaxSize。</p><h4 id="串的链式存储结构"><a href="#串的链式存储结构" class="headerlink" title="串的链式存储结构"></a>串的链式存储结构</h4><p>对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用 “#” 或其它非串值字符补全。</p><p><img src="/../img/dsa/%E4%B8%B2%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="串的链式存储结构"></p><p>当然，这里一个结点存多少个字符才合适就变得很重要，这会直接影响着串处理的效率，需要根据实际情况做出选择。但串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。</p><h3 id="朴素的模式匹配算法"><a href="#朴素的模式匹配算法" class="headerlink" title="朴素的模式匹配算法"></a>朴素的模式匹配算法</h3><p><strong>子串的定位操作通常称做串的模式匹配</strong>。</p><p>假设要从下面的主串 S &#x3D; “goodgoogle” 中，找到 T &#x3D; “google” 这个子串的位置。步骤如下：</p><ol><li>主串 S 第一位开始，S 与 T 前三个字母都匹配成功，但 S 第四个字母是 d 而 T 的是 g。第一位匹配失败。</li><li>主串 S 第二位开始，主串 S 首字母是 o，要匹配的 T 首字母是 g，匹配失败。</li><li>主串 S 第三位开始，主串 S 首字母是 o，要匹配 T 首字母是 g，匹配失败。</li><li>主串 S 第四位开始，主串 S 首字母是 d，要匹配的 T 首字母是 g，匹配失败。</li><li>主串 S 第五位开始，S 与 T，6 个字母全匹配，匹配成功。</li></ol><p>简单的说，就是对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做 T 的长度的小循环，直到匹配成功或全部遍历完成为止。</p><p>假设主串 S 和要匹配的子串 T 的长度存在 S[0] 与 T[0] 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回子串 T 在主串中第 pos 个字符之后的位置。若不存在，则函数返回值为 0。T 非空，1 ≤ pos ≤ StrLength(S)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(String s, String T, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = pos;<span class="comment">// i 用于主串 S 中当前位置下标，若 pos 不为 1，则从 pos 位置开始匹配</span></span><br><span class="line">  <span class="type">int</span> j = <span class="number">1</span>;<span class="comment">// j 用于子串 T 中当前位置下标值</span></span><br><span class="line">  <span class="keyword">while</span>(i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) &#123;<span class="comment">// 若 i 小于 S 长度且 j 小于 T 的长度时循环</span></span><br><span class="line">    <span class="keyword">if</span>(S[i] == T[j]) &#123;<span class="comment">// 两字母相等则继续</span></span><br><span class="line">      ++i;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 指针后退重新开始匹配</span></span><br><span class="line">      i = i - j + <span class="number">2</span>;<span class="comment">// i 退回到上次匹配首位的下一位</span></span><br><span class="line">      j = <span class="number">1</span>;<span class="comment">// j 退回到子串 T 的首位</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(j &gt; T[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好的情况是一开始就匹配成功，比如 “googlegood” 中去找 “google”，时间复杂度为 O(1)。如果在 “abcdefgoogle” 中去找 “google”，那么时间复杂度为 O(n + m)，其中 n 为主串长度，m 为要匹配的子串长度。根据等概率原则，平均是 (n + m) &#x2F; 2 次查找，时间复杂度为 O(n + m)。</p><p>最坏的情况是每次不成功的匹配都发生在串 T 的最后一个字符。例如主串为 S &#x3D; “00000000000000000000000000000000000001”，而要匹配的子串为 T &#x3D; ”0000000001“，前者是有 49 个 ”0“ 和 1 个 ”1“ 的主串，后者是有 9 个 ”0“ 和 1 个 ”1“ 的子串。在匹配时，每次都得将 T 中字符循环到最后一位才发现它们不匹配。这样等于 T 串需要在 S 串 的前 40 个位置都需要判断 10 次，并得出不匹配的结论。</p><p>知道最后第 41 个位置，因为全部匹配相等，所以不需要再继续进行下去。如果最终没有课匹配的子串，比如是 T &#x3D; ”0000000002“，到了第 41 位置判断不匹配后同样不需要继续比对下去。因此最坏情况的时间复杂度为 O((n - m + 1) * m)。</p><p>对于计算机来说，处理的都是二进位的 0 和 1 的串，一个字符的 ASCII 码也可以看成是 8 位的二进位 01 串，当然，汉字等所有的字符也都可以看成是多个 0 和 1 串。再比如像计算机图形也可以理解为是由许许多多个 0 和 1 的串组成。所以在计算机的运算当中，模式匹配操作可说是随处可见，而刚才的这个算法，就显得太低效了。</p><h3 id="KMP-模式匹配算法"><a href="#KMP-模式匹配算法" class="headerlink" title="KMP 模式匹配算法"></a>KMP 模式匹配算法</h3><p>D.EKnuth、J.H.Morris 和 V.R.Pratt (其中 Knuth 和 Pratt 共同研究，Morris 独立研究) 发表了一个<strong>匹配模式算法，可以大大避免重复遍历的情况，称之为克努特——莫里斯——普拉特算法，简称 KMP 算法</strong>。</p><h4 id="KMP-模式匹配算法原理"><a href="#KMP-模式匹配算法原理" class="headerlink" title="KMP 模式匹配算法原理"></a>KMP 模式匹配算法原理</h4><p>如果主串 S &#x3D; “abcdefgab”，匹配 T &#x3D; “abcdex”，如果用朴素算法的话，前 5 个字母，两个串完全相等，知道第 6 个字母，”f“ 与 ”x“ 不等，如 ① 所示。</p><p><img src="/../img/dsa/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%951.png" alt="朴素模式匹配算法"></p><p>接下来，按照朴素模式匹配算法，应该是图中 ②③④⑤⑥的顺序。即主串 S 中当 i &#x3D; 2、3、4、5、6 时，首字符与子串 T 的首字符均不等。</p><p>对于要匹配的子串 T 来说，“abcdex” 首字母 “a“ 与后面的串 ”bcdex“ 中任意一个字符都不相等。也就是说，既然 ”a“ 不与自己后面的子串中任何一个字符相等，那么对于图中 ① 来说，前五位字符分别相等，意味着子串 T 的首字符 ”a“ 不可能与 S 串的第 2 位到第 5 位的字符相等。②③④⑤ 的判断都是多余的。</p><p>这是理解 KMP 算法的关键。如果 T 串中首字符 ”a” 与 T 中后面的字符均不相等。而 T 串的第二位的 “b” 与 S 串中第二位的 “b”在 ① 中已经判断是相等的，那么也就意味着，T 串中首字符 “a“ 与 S 串中的第二位 ”b“ 是不需要判断也知道它们是不可能相等了，这样 ② 这一步判断是可以省略的。</p><p>同样道理，在知道 T 串中首字符 ”a” 与 T 中后面的字符均不相等的前提下，T 串的 “a” 与 S 串后面的 “c”、“d”、“e” 也都可以在 ① 之后就可以确定是不相等的，所以这个算法当中 ②③④⑤ 没有必要，只保留 ①⑥ 即可。</p><p>之所以保留 ⑥ 中的判断是因为在 ① 中 T[6] ≠ S[6]，尽管已经知道 T[1] ≠ T[6]，但也不能判定 T[1] 一定不等于 S[6]，因此需要保留 ⑥ 这一步。</p><blockquote><p>如果 T 串后面也含有首字符 “a” 的字符怎么办？</p></blockquote><p>假设 S &#x3D; “abcabcabc”，T &#x3D; “abcabx”。对于开始的判断，前 5 个字符完全相等，第6个字符不等，如图中的 ①。此时，T 的首字符 “a” 与 T 的第二位字符 “b”、第三位字符 “c” 均不相等，所以不需要做判断，步骤 ②③ 都是多余的。</p><p><img src="/../img/dsa/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%952.png" alt="朴素模式匹配算法2"></p><p>因为 T 的首位 “a” 与 T 第四位的 “a” 相等，第二位的 “b” 与第五位的 “b” 相等。而在 ① 时，第四位的 “a” 与 第五位的 “b” 已经与主串 S 中相应位置比较过了，是相等的，因此可以判定，T 的首字符 “a”、第二位的字符 “b” 与 S 的第四位字符和第五位字符也不需要比较了，肯定也是相等的。所以 ④⑤ 这两个比较得出字符相等的步骤也可以省略。</p><p>也就是说，对于在子串中有与首字符相等的字符，也是可以省略一部分不必要的判断步骤。省略掉 ⑥ 中 T 串前两位 “a” 与 “b” 同 S 串中的 4、5位置字符匹配操作。</p><p>对比这两个例子，会发现在 ① 时，我们的 i 值，也就是主串当前位置的下标是 6，②③④⑤，i 值是2、3、4、5，到了 ⑥，i 值才又回到了 6.即我们在朴素的模式匹配算法中，主串的 i 值是不断地回溯来完成的。而分析发现，这种回溯其实是可以不需要的，KMP 模式匹配算法就是为了让这没必要的回溯不发生。</p><p>既然 i 值不回溯，也就是不可以变小，那么要考虑的变化就是 j 值了。通过观察也发现，T 串的首字符与自身后面字符的比较，发现如果有相等字符，j 值的变化就会不相同。也就是说，这个 j 值的变化与主串起时没什么关系，关键就取决于 T 串的结构中是否有重复的问题。</p><p>第一个例子中，由于 T &#x3D; “abcdex”，当中没有任何重读的字符，所以 j 就由 6 变为 1。而第二个例子中 T &#x3D; “abcabx”，前缀的 “ab” 与最后 “x” 之前串的后缀 “ab” 是相等的。因此 j 就由 6 变为了 3。可以得出规律，j 值的多少取决于当前字符之前的串的前后缀的相似度。</p><p>把 T 串各个位置的 j 值的变化定义为一个数组 next，那么 next 的长度就是 T 串的长度。得出下面的函数定义：</p><p>next[j] &#x3D; 0，当 j &#x3D; 1 时，</p><p>next[j] &#x3D; Max{ k | 1 &lt; k &lt; j, 且 ‘p<sub>1 ··· k - 1</sub>‘ &#x3D; ‘p<sub>j - k + 1</sub> ··· p<sub>j - 1</sub>‘} 当集合和不空时，</p><p>next[j] &#x3D; 1，其他情况</p><h4 id="next-数组值推导"><a href="#next-数组值推导" class="headerlink" title="next 数组值推导"></a>next 数组值推导</h4><blockquote><p>具体如何推导出一个串的 next 数组值？</p></blockquote><ol><li><p>T &#x3D; “abcdex”</p><table><thead><tr><th align="center">j</th><th align="center">123456</th></tr></thead><tbody><tr><td align="center">模式串 T</td><td align="center">abcdex</td></tr><tr><td align="center">next[j]</td><td align="center">011111</td></tr></tbody></table><ul><li>当 j &#x3D; 1 时，next[1] &#x3D; 0；</li><li>当 j &#x3D; 2 时，j 由 1 到 j - 1 就只有字符 “a”，属于其他情况 next[2] &#x3D; 1；</li><li>当 j &#x3D; 3 时，j 由 1 到 j - 1 串是 “ab”，显然 ”a“ 与 ”b“ 不相等，属其他情况，next[3] &#x3D; 1；</li><li>以后同理，所以最终此 T 串的 next[j] &#x3D; 011111。</li></ul></li><li><p>T &#x3D; “abcabx”</p><table><thead><tr><th align="center">j</th><th align="center">123456</th></tr></thead><tbody><tr><td align="center">模式串 T</td><td align="center">abcabx</td></tr><tr><td align="center">next[j]</td><td align="center">011123</td></tr></tbody></table><ul><li>当 j &#x3D; 1 时，next[1] &#x3D; 0；</li><li>当 j &#x3D; 2 时，同上例说明，next[2] &#x3D; 1；</li><li>当 j &#x3D; 3 时，同上，next[3] &#x3D; 1；</li><li>当 j &#x3D; 4 时，同上，next[4] &#x3D; 1；</li><li>当 j &#x3D; 5 时，此时 j 由 j - 1 的串是 “abca”，前缀字符 “a” 与后缀字符 “a” 相等，因此可推算出 k 值为2 (由 p<sub>1 ··· k - 1</sub>‘ &#x3D; ‘p<sub>j - k + 1</sub> ··· p<sub>j - 1</sub>，得到 p<sub>1</sub> &#x3D; p<sub>4</sub>)，因此 next[5] &#x3D; 2；</li><li>当 j &#x3D; 6 时，j 由 1 到 j - 1 的串是 “abcab”，由于前缀字符 “ab” 与后缀 “ab” 相等，所以 next[6] &#x3D; 3。</li></ul><p> 我们可以根据经验得到如果前后缀一个字符相等，k 值是 2，两个字符 k 值是 3，n 个相等 k 值就是 n + 1。</p></li><li><p>T &#x3D; “ababaaaba”</p><table><thead><tr><th align="center">j</th><th align="center">123456789</th></tr></thead><tbody><tr><td align="center">模式串 T</td><td align="center">ababaaaba</td></tr><tr><td align="center">next[j]</td><td align="center">011234223</td></tr></tbody></table><ul><li>当 j &#x3D; 1 时，next[1] &#x3D; 0；</li><li>当 j &#x3D; 2 时，同上，next[2] &#x3D; 1；</li><li>当 j &#x3D; 3 时，同上，next[3] &#x3D; 1；</li><li>当 j &#x3D; 4 时，j 由 1 到 j - 1 的串是 “aba”，前缀字符 “a” 与后缀字符 “a“ 相等，next[4] &#x3D; 2；</li><li>当 j &#x3D; 5 时，此时 j 由 j - 1 的串是 “abab”，前缀字符 “ab” 与后缀字符 “ab” 相等，所以 next[5] &#x3D; 3；</li><li>当 j &#x3D; 6 时，j 由 1 到 j - 1 的串是 “ababa”，由于前缀字符 “aba” 与后缀 “aba” 相等，所以 next[6] &#x3D; 4；</li><li>当 j &#x3D; 7 时，j 由 1 到 j - 1 的串是 “ababaa”，由于前缀字符 “ab” 与后缀 “aa” 并不相等，只有 ”a“ 相等，所以 next[7] &#x3D; 2；</li><li>当 j &#x3D; 8 时，j 由 1 到 j - 1 的串是 “ababaaa”，只有 “a” 相等，所以 next[8] &#x3D; 2；</li><li>当 j &#x3D; 9 时，j 由 1 到 j - 1 的串是 “ababaaab”，由于前缀字符 “ab” 与后缀 “aba” 相等，所以 next[9] &#x3D; 3。</li></ul></li><li><p>T &#x3D; “aaaaaaaab”</p><table><thead><tr><th align="center">j</th><th align="center">123456789</th></tr></thead><tbody><tr><td align="center">模式串 T</td><td align="center">aaaaaaaab</td></tr><tr><td align="center">next[j]</td><td align="center">012345678</td></tr></tbody></table><ul><li>当 j &#x3D; 1 时，next[1] &#x3D; 0；</li><li>当 j &#x3D; 2 时，同上，next[2] &#x3D; 1；</li><li>当 j &#x3D; 3 时，j 由 1 到 j - 1 的串是 “aa”，前缀字符 “a” 与后缀字符 “a“ 相等，next[3] &#x3D; 2；</li><li>当 j &#x3D; 4 时，j 由 1 到 j - 1 的串是 “aaa”，前缀字符 “aa” 与后缀字符 “aa“ 相等，next[4] &#x3D; 3；</li><li>……</li><li>当 j &#x3D; 9 时，j 由 1 到 j - 1 的串是 “aaaaaaaa”，由于前缀字符 “aaaaaaa” 与后缀 “aaaaaaa” 相等，所以 next[9] &#x3D; 8。</li></ul></li></ol><h4 id="KMP-模式匹配算法实现"><a href="#KMP-模式匹配算法实现" class="headerlink" title="KMP 模式匹配算法实现"></a>KMP 模式匹配算法实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过计算返回子串的 next 数组。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(String T, <span class="type">int</span> *next)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i,j;</span><br><span class="line">  i = <span class="number">1</span>;</span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; T[<span class="number">0</span>]) &#123;<span class="comment">// 此处 T[0] 表示串 T 的长度</span></span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">0</span> || T[i] == T[j]) &#123;<span class="comment">// T[i] 表示后缀的单个字符；T[j] 表示前缀的单个字符</span></span><br><span class="line">      ++i;</span><br><span class="line">      ++j;</span><br><span class="line">      next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      j = next[j];<span class="comment">// 若字符不相同，则 j 值回溯</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是为了计算出当前要匹配的串 T 的 next 数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回子串 T 在主串 S 中第 pos 个字符之后的位置。若不存在，则函数返回值为 0。T 非空，1 ≤ pos ≤ StrLength(S)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(String S, String T, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = pos;<span class="comment">// i 用于主串 S 当前位置下标值，若 pos 不为 1，则从 pos 位置开始匹配</span></span><br><span class="line">  <span class="type">int</span> j = <span class="number">1</span>;<span class="comment">// j 用于子串 T 中当前位置下标值</span></span><br><span class="line">  <span class="type">int</span> next[<span class="number">255</span>];<span class="comment">// 定义一 next 数组</span></span><br><span class="line">  get_next(T, next);<span class="comment">// 对串 T 作分析，得到 next 数组</span></span><br><span class="line">  <span class="keyword">while</span>(i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) &#123;<span class="comment">// 若 i 小于 S 的长度且 j 小于 T 的长度时，循环继续</span></span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">0</span> || S[i] == T[j]) &#123;<span class="comment">// 两字母相等则继续，与朴素算法增加了 j = 0 判断</span></span><br><span class="line">      ++i;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">// 指针后退重新开始匹配</span></span><br><span class="line">      j = next[j];<span class="comment">// j 退回合适的位置，i 值不变</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(j &gt; T[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 get_next 函数来说，若 T 的长度为 m，因只涉及到简单的单循环，其时间复杂度为 O(m)，而由于 i 值的不回溯，是的 index_KMP 算法效率得到了提高，while 循环的时间复杂度为 O(n)。因此整个算法的时间复杂度为 O(n + m)。相较于朴素模式匹配算法的 O((n - m + 1) * m) 来说，好一些。KMP算法仅当模式与主串之间存在许多 “部分匹配” 的情况下才体现出它的优势，否则两者差异并不明显。</p><h4 id="KMP-模式匹配算法改进"><a href="#KMP-模式匹配算法改进" class="headerlink" title="KMP 模式匹配算法改进"></a>KMP 模式匹配算法改进</h4><p>KMP 算法是有缺陷的，比如当主串 S &#x3D; “aaaabcde”，子串 T &#x3D; “aaaaax”，其 next 数组分别为 012345，在开始时，当 i &#x3D; 5、j &#x3D; 5 时，发现 “b“ 与 “a” 不相等，如图中的 ①，因此 j &#x3D; next[5] &#x3D; 4，如图中的 ②，此时 “b” 与第 4 位置的 “a” 依然不相等，j &#x3D; next[4] &#x3D; 3，如果中的 ③，后依次是 ④⑤，直到 j &#x3D; next[1] &#x3D; 0 时，根据算法，此时 ++i、j++，得到 i &#x3D; 6、j &#x3D; 1，如图中的 ⑥。</p><p><img src="/../img/dsa/KMP%E7%AE%97%E6%B3%95.png" alt="KMP算法"></p><p>但是可以看出 ②③④⑤ 步骤其实是多余的的判断。由于 T 串的第二、三、四、五位置的字符都与首位 “a” 相等，那么可以用首位 next[1] 的值去取代与它相等的字符后续 next[j] 的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求模式串 T 的 next 函数修正值并存入数组 nextval</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_nextval</span><span class="params">(String T, <span class="type">int</span> *nextval)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  i = <span class="number">1</span>;</span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; T[<span class="number">0</span>]) &#123;<span class="comment">// 此处 T[0] 表示串 T 的长度</span></span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">0</span> || T[i] == T[j]) &#123;<span class="comment">// T[i] 表示后缀的单个字符，T[j] 表示前缀的单个字符</span></span><br><span class="line">      ++i;</span><br><span class="line">      ++j;</span><br><span class="line">      <span class="keyword">if</span>(T[i] != T[j])<span class="comment">// 若当前字符与前缀字符不同</span></span><br><span class="line">        nextval[i] = j;<span class="comment">// 则当前的 j 为 nextval 在 i 位置的值</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        nextval[i] = nextval[j];<span class="comment">// 如果与前缀字符相同，则将前缀字符的 nextval值赋值给nextval 在 i 位置的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      j = nextval[i];<span class="comment">// 若字符不相同，则 j 值回溯</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际匹配算法，只需要将 “get_next(T, next);” 改为 “get_nextval(T, next);” 即可。</p><h4 id="nextval-数组值推导"><a href="#nextval-数组值推导" class="headerlink" title="nextval 数组值推导"></a>nextval 数组值推导</h4><p>经过优化后，nextval 值与 next 值不完全相同了。</p><ol><li><p>T &#x3D; “ababaaaba”</p><table><thead><tr><th align="center">j</th><th align="center">123456789</th></tr></thead><tbody><tr><td align="center">模式串 T</td><td align="center">ababaaaba</td></tr><tr><td align="center">next[j]</td><td align="center">011234223</td></tr><tr><td align="center">nextval[j]</td><td align="center">010104210</td></tr></tbody></table><p> 先算出 next 数组的值分别为 001234223，然后再分别判断。</p><ul><li>当 j &#x3D; 1 时，nextval[1] &#x3D; 0；</li><li>当 j &#x3D; 2 时，因第二位字符 “b“ 的 next 值是 1，而第一位就是 ”a”，它们不相等，所以 nextval[2] &#x3D; next[1] &#x3D; 1；</li><li>当 j &#x3D; 3 时，因第三位字符 “a“ 的 next 值是 1，所以与第一位就是 ”a” 比较相等，所以 nextval[3] &#x3D; nextval[1] &#x3D; 0；</li><li>当 j &#x3D; 4 时，第四位的字符 “b” next 值为 2，所以与第二位的 “b” 相比较得到结果是相等，因此 nextval[4] &#x3D; nextval[2] &#x3D; 1；</li><li>当 j &#x3D; 5 时，next 值为 3，第五个字符 “a” 与第三个字符 ”a” 相等，所以 nextval[5] &#x3D; nextval[3] &#x3D; 0；</li><li>当 j &#x3D; 6 时，next 值为 4，第六个字符 “a” 与第四个字符 “b” 不相等，所以 nextval[6] &#x3D; 4；</li><li>当 j &#x3D; 7 时，next 值为 2，第七个字符 “a“ 与第二个字符 ”b“ 不相等，所以 nextval[7] &#x3D; 2；</li><li>当 j &#x3D; 8 时，next 值为 2，第八个字符 “b” 与第二个字符 ”b“ 相等，所以 nextval[8] &#x3D; nextval[2] &#x3D; 1；</li><li>当 j &#x3D; 9 时，next 值为 3，第九个字符 “a” 与第三个字符 ”a” 相等，所以 nextval[9] &#x3D; nextval[3] &#x3D; 1。</li></ul></li><li><p>T &#x3D; “aaaaaaaab”</p><table><thead><tr><th align="center">j</th><th align="center">123456789</th></tr></thead><tbody><tr><td align="center">模式串 T</td><td align="center">aaaaaaaab</td></tr><tr><td align="center">next[j]</td><td align="center">012345678</td></tr><tr><td align="center">Nextval[j]</td><td align="center">00000008</td></tr></tbody></table><p> 先算出 next 数组的值分别为 012345678，然后再分别判断。</p><ul><li>当 j &#x3D; 1 时，nextval[1] &#x3D; 0；</li><li>当 j &#x3D; 2 时，next 值为 1，第二个字符与第一个字符相等，所以 nextval[2] &#x3D; nextval[1] &#x3D; 0；</li><li>同样的道理，其后都为 0……</li><li>当 j &#x3D; 9，next 值为 8，第九个字符 “b” 与第八个字符 “a” 不相等，所以 nextval[9] &#x3D; 8。、</li></ul><p> 改进后的 KMP 算法，它是在计算出 next 值的同时，如果 a 位字符与它 next 值指向的 b 位字符相等，则该 a 位的 nextval 就指向 b 位的 nextval 值，如果不等，则该 a 位的 nextval 值就是它自己 a 位的next 的值。</p></li></ol><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>串 (string) 是由零个或多个字符组成的有限序列，又名叫字符串。本质上，它是一种线性表的扩展，但相对于线性表关注一个个元素来说说，串这种结构更多的是关注它子串的应用问题，如查找、替换等操作。KMP 算法的学习，要有效地去理解 index 函数当中的实现细节。</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><blockquote><p>树 (Tree) 是 n (n ≥ 0) 个结点的有限集。n &#x3D; 0 时称为空树。在任意一棵非空树中：(1) 有且仅有一个特定的称为根 (Root) 的结点； (2) 当 n &gt; 1 时，其余结点可分为 m (m &gt; 0) 个互不相交的有限集 T<sub>1</sub>、T<sub>2</sub>、······、T<sub>m</sub>，其中每个集合本身又是一棵树，并且称为根的子树 (SubTree)。</p></blockquote><p><img src="/../img/dsa/%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89.png" alt="树的定义"></p><ol><li>n &gt; 0 时根结点是唯一的，不可能存在多个根结点，别和现实中的大树混在一起，现实中的树有很多根须，那是真实的树，数据结构中的树是只能有一个根结点。</li><li>m &gt; 0 时，子树的个数没有限制，但它们一定是互不相交的。</li></ol><h4 id="结点分类"><a href="#结点分类" class="headerlink" title="结点分类"></a>结点分类</h4><p>树的结点包含一个数据元素及若干指向其子树的分支。<strong>结点拥有的子树称为结点的度 (Degree)。度为 0 的结点称为叶结点 (Leaf) 或终端结点；度不为 0 的结点称为非终端结点或分支结点。除根结点外，分支结点也称为内部结点。树的度是树内各结点的度的最大值</strong>。</p><p><img src="/../img/dsa/%E7%BB%93%E7%82%B9%E5%92%8C%E5%BA%A6.png" alt="结点和度"></p><h4 id="结点间关系"><a href="#结点间关系" class="headerlink" title="结点间关系"></a>结点间关系</h4><p><strong>结点的子树的根称为该结点的孩子 (Child)，相应地，该结点称为孩子的双亲 (Parent)。同一个双亲的孩子之间互称兄弟 (Sibling)。结点的祖先是从根到该结点所经分枝上的所有结点。以某结点为根的子树中的任一结点都称为该结点的子孙</strong>。</p><h4 id="树的其它相关概念"><a href="#树的其它相关概念" class="headerlink" title="树的其它相关概念"></a>树的其它相关概念</h4><p><strong>结点的层次 (Level) 从根开始定义起，根为第一层，跟的孩子为第二层。双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度 (Depth) 或高度。</strong></p><p><img src="/../img/dsa/%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1.png" alt="树的层次"></p><p><strong>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树</strong>。</p><p><strong>森林 (Forest) 是 m (m ≥ 0) 棵互不相交的树的集合</strong>。对树中每个结点而言，其子树的集合即为森林。</p><h3 id="树的抽象数据类型"><a href="#树的抽象数据类型" class="headerlink" title="树的抽象数据类型"></a>树的抽象数据类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ADT 树 (tree)</span><br><span class="line">Data</span><br><span class="line">  树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系。</span><br><span class="line">Operation</span><br><span class="line">  <span class="title function_">InitTree</span><span class="params">(*T)</span>: 构造空树 T。</span><br><span class="line">  <span class="title function_">DestroyTree</span><span class="params">(*T)</span>: 销毁树 T。</span><br><span class="line">  <span class="title function_">CreateTree</span><span class="params">(*T, definition)</span>: 按 definition 中给出树的定义来构造树。</span><br><span class="line">  <span class="title function_">ClearTress</span><span class="params">(*T)</span>: 若树 T 存在，则将树 T 清为空树。</span><br><span class="line">  <span class="title function_">TreeEmpty</span><span class="params">(T)</span>: 若 T 为空树，返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line">  <span class="title function_">TreeDepth</span><span class="params">(T)</span>: 返回 T 的深度。</span><br><span class="line">  <span class="title function_">Root</span><span class="params">(T)</span>: 返回 T 的根结点。</span><br><span class="line">  <span class="title function_">Value</span><span class="params">(T, cur_e)</span>: cur_e 是树 T 中一个结点，返回此结点的值。</span><br><span class="line">  <span class="title function_">Assign</span><span class="params">(T, cur_e, value)</span>: 给树 T 的结点 cur_e 赋值为 value。</span><br><span class="line">  <span class="title function_">Parent</span><span class="params">(T, cur_e)</span>: 若 cur_e 是树 T 的非根结点，则返回它的双亲，否则返回空。</span><br><span class="line">  <span class="title function_">LeftChild</span><span class="params">(T, cur_e)</span>: 若 cur_e 是树 T 的非叶结点，则返回它的最左孩子，否则返回空。</span><br><span class="line">  <span class="title function_">RightSibling</span><span class="params">(T, cur_e)</span>: 若 cur_e 有右兄弟，则返回它的右兄弟，否则返回空。</span><br><span class="line">  <span class="title function_">InsertChild</span><span class="params">(*T, *p, i, c)</span>: 其中 p 指向树 T 的某个结点，i 为所指结点 p 的度加上 1，非空树 c 与 T 不相交，操作结果为插入 c 为树 T 中 p 指结点的第 i 棵子树。</span><br><span class="line">  <span class="title function_">DeleteChild</span><span class="params">(*T, *p, i)</span>: 其中 p 指向树 T 的某个结点，i 为所指结点 p 的度，操作结果为删除 T 中 p 所指结点的第 i 棵子树。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p>树这种结构，除了根结点外，其余每个结点，他不一定有孩子，但是一定有且仅有一个双亲。假设以一组连续空间存储树的结点，同时<strong>在每个结点中，附设一个指示器指示其双亲结点到链表中的位置</strong>。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。结点结构如下表所示。</p><table><thead><tr><th align="center">data</th><th align="center">parent</th></tr></thead></table><p>其中 data 是数据域，存储结点的数据信息。而 parent 是指针域，存储该结点的双亲在数组中的下标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树的双亲表示法结点结构定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> TElemType;<span class="comment">// 树结点的数据类型，目前暂定为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span> &#123;</span><span class="comment">// 结点结构</span></span><br><span class="line">  TElemType data;<span class="comment">// 结点数据</span></span><br><span class="line">  <span class="type">int</span> parent;<span class="comment">// 双亲位置</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">// 树结构</span></span><br><span class="line">  PTNode nodes[MAX_TREE_SIZE];<span class="comment">// 结点数组</span></span><br><span class="line">  <span class="type">int</span> r, n;<span class="comment">// 根的位置和结点数</span></span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure><p>由于根结点是没有双亲的，所以我们约定根结点的位置域设置为 -1，所有的结点都存有它双亲的位置。</p><p><img src="/../img/dsa/%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89.png" alt="树的定义"></p><table><thead><tr><th align="center">下标</th><th align="center">data</th><th align="center">parent</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">A</td><td align="center">-1</td></tr><tr><td align="center">1</td><td align="center">B</td><td align="center">0</td></tr><tr><td align="center">2</td><td align="center">C</td><td align="center">0</td></tr><tr><td align="center">3</td><td align="center">D</td><td align="center">1</td></tr><tr><td align="center">4</td><td align="center">E</td><td align="center">2</td></tr><tr><td align="center">5</td><td align="center">F</td><td align="center">2</td></tr><tr><td align="center">6</td><td align="center">G</td><td align="center">3</td></tr><tr><td align="center">7</td><td align="center">H</td><td align="center">3</td></tr><tr><td align="center">8</td><td align="center">I</td><td align="center">3</td></tr><tr><td align="center">9</td><td align="center">J</td><td align="center">4</td></tr></tbody></table><p>这样的存储结构，可以根据结点的 parent 指针很容易找到它的双亲结点，所用的时间复杂度为 O(1)，直到 parent 为 -1 时，表示找到了树结点的根。可是如果要知道结点的孩子是谁，就需要遍历整个结构才行。可以增加一个结点最左边孩子的域，这里叫作长子域，这样就很容易得到结点的孩子。如果没有孩子的结点，这个长子域就设置为 -1。</p><table><thead><tr><th align="center">下标</th><th align="center">data</th><th align="center">parent</th><th align="center">firstchild</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">A</td><td align="center">-1</td><td align="center">-1</td></tr><tr><td align="center">1</td><td align="center">B</td><td align="center">0</td><td align="center">3</td></tr><tr><td align="center">2</td><td align="center">C</td><td align="center">0</td><td align="center">4</td></tr><tr><td align="center">3</td><td align="center">D</td><td align="center">1</td><td align="center">6</td></tr><tr><td align="center">4</td><td align="center">E</td><td align="center">2</td><td align="center">9</td></tr><tr><td align="center">5</td><td align="center">F</td><td align="center">2</td><td align="center">-1</td></tr><tr><td align="center">6</td><td align="center">G</td><td align="center">3</td><td align="center">-1</td></tr><tr><td align="center">7</td><td align="center">H</td><td align="center">3</td><td align="center">-1</td></tr><tr><td align="center">8</td><td align="center">I</td><td align="center">3</td><td align="center">-1</td></tr><tr><td align="center">9</td><td align="center">J</td><td align="center">4</td><td align="center">-1</td></tr></tbody></table><p>对于有 0 个或 1 个孩子结点来说，这样的结构是解决了要找结点孩子的问题了。甚至是有 2 个孩子，知道了长子是谁，另一个当然就是次子了。</p><p>另外一个问题场景，我们很关注各兄弟之间的关系，双亲表示法无法体现这样的关系，可以增加一个右兄弟域来体现兄弟关系，每一个结点如果它存在右兄弟，则记录下右兄弟的下标。如果右兄弟不存在，则复制为 -1。</p><table><thead><tr><th align="center">下标</th><th align="center">data</th><th align="center">parent</th><th align="center">rightsib</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">A</td><td align="center">-1</td><td align="center">-1</td></tr><tr><td align="center">1</td><td align="center">B</td><td align="center">0</td><td align="center">2</td></tr><tr><td align="center">2</td><td align="center">C</td><td align="center">0</td><td align="center">-1</td></tr><tr><td align="center">3</td><td align="center">D</td><td align="center">1</td><td align="center">-1</td></tr><tr><td align="center">4</td><td align="center">E</td><td align="center">2</td><td align="center">5</td></tr><tr><td align="center">5</td><td align="center">F</td><td align="center">2</td><td align="center">-1</td></tr><tr><td align="center">6</td><td align="center">G</td><td align="center">3</td><td align="center">7</td></tr><tr><td align="center">7</td><td align="center">H</td><td align="center">3</td><td align="center">8</td></tr><tr><td align="center">8</td><td align="center">I</td><td align="center">3</td><td align="center">-1</td></tr><tr><td align="center">9</td><td align="center">J</td><td align="center">4</td><td align="center">-1</td></tr></tbody></table><p>但如果结点的孩子很多，超过了 2 个。我们又关注结点的双亲、又关注结点的孩子、还关注结点的兄弟，而且对时间遍历要求还比较高，那么我们还可以把此结构扩展为有双亲域、长子域、再有右兄弟域。<strong>存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于给予该存储结构的运算是否适合、是否方便，时间复杂度好不好等</strong>。</p><h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><p>由于树中每个结点可能有多棵子树，可以考虑用多重链表，即<strong>每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫作多重表表示法</strong>。树的每个结点的度，也就是它的孩子个数是不同的。所以可以设计两种方案来解决。</p><ul><li><p>方案一</p><p>  一种是指针域的个数就等于树的度，树的度是树各个结点度的最大值。</p><table><thead><tr><th align="center">data</th><th align="center">child1</th><th align="center">child2</th><th align="center">child3</th><th align="center">……</th><th align="center">childd</th></tr></thead></table><p>  其中 data 是数据域。child1 到 childd 是指针域，用来指向该结点的孩子结点。</p><p>  <img src="/../img/dsa/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%951.png" alt="孩子表示法1"></p><p>  这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。但是如果树的各结点度相差很小时，那就意味着开辟的空间被充分利用了，这时存储结构的缺点反而变成了优点。</p></li><li><p>方案二</p><p>  第二种方案每个结点指针域的个数等于该结点的度，专门取一个位置来存储结点指针域的个数，其结构如表。</p><table><thead><tr><th align="center">data</th><th align="center">degree</th><th align="center">child1</th><th align="center">child2</th><th align="center">……</th><th align="center">childd</th></tr></thead></table><p>  其中 data 为数据域，degree 为度域，也就是存储该结点的孩子结点的个数，child1 到 childd 为指针域，指向该结点的各个孩子的结点。</p><p>  <img src="/../img/dsa/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%952.png" alt="孩子表示法2"></p><p>  这种方法克服了浪费空间的缺点，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上会带来时间上的损耗。</p><p>  为了要遍历整棵树，把每个结点放到一个顺序存储结构的数组中是合理的，但每个结点的孩子有多少是不确定的，所以我们再对每个结点的孩子建立一个单链表体现它们的关系。</p><p>  <strong>孩子表示法把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</strong>。</p><p>  <img src="/../img/dsa/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%953.png" alt="孩子表示法3"></p><p>  孩子链表的孩子结点：</p><table><thead><tr><th align="center">child</th><th align="center">next</th></tr></thead></table><p>  其中 child 是数据域，用来存储某个结点在表头数组中的下标。next 是指针域，用来存储指向某结点的下一个孩子结点的指针。</p><p>  表头数组的表头结点：</p><table><thead><tr><th align="center">data</th><th align="center">firstchild</th></tr></thead></table><p>  其中 child 是数据域，存储某结点的数据信息。firstchild 是头指针域，存储该结点的孩子链表的头指针。</p><p>  孩子表示法的结构定义：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树的孩子表示法结构定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> &#123;</span><span class="comment">// 孩子结点</span></span><br><span class="line">  <span class="type">int</span> child;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">// 表头结构</span></span><br><span class="line">  TElemType data;</span><br><span class="line">  ChildPtr firstchild;</span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">// 树结构</span></span><br><span class="line">  CTBox nodes[MAX_TREE_SIZE];<span class="comment">// 结点数组</span></span><br><span class="line">  <span class="type">int</span> r, n;<span class="comment">// 根的位置和结点树</span></span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure><p>  这样的结构对于要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。</p><p>  但是也存在问题，如何知道某个结点的双亲是谁？将双亲表示法和孩子表示法综合一下。</p><p>  <img src="/../img/dsa/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%954.png" alt="孩子表示法4"></p><p>  把这种算法称为双亲孩子表示法，是孩子表示法的改进。</p></li></ul><h4 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h4><p><strong>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</strong>。</p><table><thead><tr><th align="center">data</th><th align="center">firstchild</th><th align="center">rightsib</th></tr></thead></table><p>其中 data 是数据域，firstchild 为指针域，存储该结点的第一个孩子结点的存储地址，rightsib 是指针域，存储该结点的右兄弟结点的存储地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树的孩子兄弟表示法结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">  TElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">rightsib</span>;</span></span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure><p>示意图：</p><p><img src="/../img/dsa/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%951.png" alt="孩子兄弟表示法1"></p><p>这种表示法，给查找某个结点的某个孩子带来了方便，只需要通过 firstchild 找到此结点的长子，然后再通过长子结点的 rightsib 找到它的二弟，接着一直下去，直到找到具体的孩子。当然想找某个结点的双亲，这个表示法也是有缺陷的。</p><p>其实这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树。</p><p><img src="/../img/dsa/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%952.png" alt="孩子兄弟表示法2"></p><p>这样就可以充分利用二叉树的特性和算法来处理这棵树了。</p><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><blockquote><p>二叉树 (Binary Tree) 是 n (n ≥ 0) 个结点的有限集合，该集合或者为空集 (称为空二叉树)，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p></blockquote><p><img src="/../img/dsa/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树"></p><h4 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h4><p>特点：</p><ul><li>每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。</li><li>左子树和右子树是有顺序的，次序不能任意颠倒。</li><li>即是树中某结点只有一棵子树，也要区分它是左子树还是右子树。</li></ul><p>二叉树具有五种基本形态：</p><ol><li>空二叉树。</li><li>只有一个根结点。</li><li>根结点只有左子树。</li><li>根结点只有右子树。</li><li>根结点既有左子树又有右子树。</li></ol><h4 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h4><ul><li><p><strong>斜树</strong></p><p>  <strong>所有结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树</strong>。</p></li><li><p><strong>满二叉树</strong></p><p>  <strong>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树</strong>。</p><p>  满二叉树的特点有：</p><ul><li>叶子只能出现在最下一层。出现在其他层就不可能达成平衡。</li><li>非叶子结点的度一定是 2。</li><li>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</li></ul></li><li><p><strong>完全二叉树</strong></p><p>  <strong>对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i (1 ≤ i ≤ n) 的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树</strong>。</p><p>  完全二叉树的特点：</p><ul><li>叶子结点只能出现在最下两层。</li><li>最下层的叶子一定集中在左部连续位置。</li><li>倒数二层，若有叶子结点，一定都在右部连续位置。</li><li>如果结点度为 1，则该结点只有左孩子，既不存在只有右子树的情况。</li><li>同样结点树的二叉树，完全二叉树的深度最小。</li></ul></li></ul><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质 1"></a>性质 1</h4><p>**在二叉树的第 i 层上至多有 2<sup>i - 1</sup> 个结点 (i ≥ 1)**。</p><h4 id="性质-2"><a href="#性质-2" class="headerlink" title="性质 2"></a>性质 2</h4><p>**深度为 k 的二叉树至多有 2<sup>k</sup> - 1 个结点 (k ≥ 1)**。</p><h4 id="性质-3"><a href="#性质-3" class="headerlink" title="性质 3"></a>性质 3</h4><p><strong>对任何一棵二叉树 T，如果其终端结点数为 n<sub>0</sub>，度为 2 的结点树为 n<sub>2</sub>，则 n<sub>0</sub> &#x3D; n<sub>2</sub> + 1</strong>。</p><h4 id="性质-4"><a href="#性质-4" class="headerlink" title="性质 4"></a>性质 4</h4><p>**具有 n 个结点的完全二叉树的深度为 [log<sub>2</sub>n] + 1 ([x] 表示不大于 x 的最大整数)**。</p><h4 id="性质-5"><a href="#性质-5" class="headerlink" title="性质 5"></a>性质 5</h4><p><strong>如果对一棵有 n 个结点的完全二叉树 (其深度为 [log<sub>2</sub>n] + 1) 的结点按层序编号 (从第 1 层到第 [log<sub>2</sub>n] + 1 层，每层从左到右)，对任一结点 i (1 ≤ i ≤ n) 有：</strong></p><ol><li><strong>如果 i &#x3D; 1，则结点 i 是二叉树的根，无双亲；如果 i &gt; 1，则其双亲是结点 [i &#x2F; 2]。</strong></li><li><strong>如果 2i &gt; n，则结点 i 无左孩子 (结点 i 为叶子结点)；否则其左孩子是结点 2i。</strong></li><li><strong>如果 2i + 1 &gt; n，则结点 i 无右孩子；否则其右孩子是结点 2i + 1。</strong></li></ol><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="二叉树顺序存储结构"><a href="#二叉树顺序存储结构" class="headerlink" title="二叉树顺序存储结构"></a>二叉树顺序存储结构</h4><p>二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等。</p><p><img src="/../img/dsa/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A81.png" alt="完全二叉树顺序存储1"></p><p>将这棵二叉树存入到数组中，相应的下标对应其同样的位置。</p><p><img src="/../img/dsa/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A82.png" alt="完全二叉树顺序存储2"></p><p>由于完全二叉树严格的定义，所以用顺序结构也可以表现出二叉树的结构。对于一般的二叉树，尽管层序编号不能反映逻辑关系，但是可以将其按完全二叉树编号，只不过，把不存在的结点设置为 “^” 而已。浅色结点表示不存在。</p><p><img src="/../img/dsa/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A83.png" alt="完全二叉树顺序存储3"></p><p><img src="/../img/dsa/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A84.png" alt="完全二叉树顺序存储4"></p><p>考虑一种极端的情况，一棵深度为 k 的右斜树，它只有 k 个结点，却需要分配 2<sup>k</sup> - 1 个存储单元空间，这显然是对存储空间的浪费。</p><p><img src="/../img/dsa/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A85.png" alt="完全二叉树顺序存储5"></p><p>所以顺序存储结构一般只用于完全二叉树。</p><h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p><strong>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域</strong>是比较自然的想法，<strong>称这样的链表叫作二叉链表</strong>。结点结构如图。</p><table><thead><tr><th align="center">lchild</th><th align="center">data</th><th align="center">child</th></tr></thead></table><p>其中 data 是数据域，lchild 和 rchild 都是指针域，分别存放指向左孩子和右孩子的指针。</p><p>二叉链表的结点结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的二叉链表结点结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span><span class="comment">// 结点结构</span></span><br><span class="line">  TElemType data;<span class="comment">// 结点数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125; BiTnode, *BiTree;</span><br></pre></td></tr></table></figure><p>结构示意图：</p><p><img src="/../img/dsa/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8.png" alt="二叉链表"></p><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><blockquote><p>二叉树的遍历 (traversing binary tree) 是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p></blockquote><h4 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a>二叉树遍历方法</h4><ol><li><p><strong>前序遍历</strong></p><p> <strong>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。</strong></p><p> <img src="/../img/dsa/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="前序遍历"></p></li><li><p><strong>中序遍历</strong></p><p> <strong>规则是若树为空，则空操作返回，否则从根结点开始 (注意并不是先访问根结点)，中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树</strong>。</p><p> <img src="/../img/dsa/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="中序遍历"></p></li><li><p><strong>后序遍历</strong></p><p> <strong>规则是若树为空，则空操作返回，否则从左到右线叶子后结点的方式遍历访问左右子树，最后是访问根结点</strong>。</p><p> <img src="/../img/dsa/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="后序遍历"></p></li><li><p><strong>层序遍历</strong></p><p> <strong>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问</strong>。</p><p> <img src="/../img/dsa/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="层序遍历"></p></li></ol><h4 id="前序遍历算法"><a href="#前序遍历算法" class="headerlink" title="前序遍历算法"></a>前序遍历算法</h4><p>二叉树的定义是用递归的方式，所以，实现遍历算法也可以采用递归，而且极其简洁明了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的前序遍历递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraverse</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T -&gt; data);<span class="comment">// 显示结点数据，可以更改为其它对结点操作</span></span><br><span class="line">  PreOrderTraverse(T -&gt; lchild);<span class="comment">// 在先序遍历左子树</span></span><br><span class="line">  PreOrderTraverse(T -&gt; rchild);<span class="comment">// 最后先序遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历算法"><a href="#中序遍历算法" class="headerlink" title="中序遍历算法"></a>中序遍历算法</h4><p>中序遍历算法和前序遍历算法仅仅只是在代码的顺序上的差异。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的中序遍历递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  InOrderTraverse(T -&gt; lchild);<span class="comment">// 中序遍历左子树</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T -&gt; data);<span class="comment">// 显示结点数据，可以更改为其它对结点操作</span></span><br><span class="line">  InOrderTraverse(T -&gt; rchild);<span class="comment">// 最后中序遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历算法"><a href="#后序遍历算法" class="headerlink" title="后序遍历算法"></a>后序遍历算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的后序遍历递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderTraverse</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  PostOrderTraverse(T -&gt; lchild);<span class="comment">// 先后序遍历左子树</span></span><br><span class="line">  PostOrderTraverse(T -&gt; rchild);<span class="comment">// 再后序遍历右子树</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T -&gt; data);<span class="comment">// 显示结点数据，可以更改为其它对结点操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="推导遍历结果"><a href="#推导遍历结果" class="headerlink" title="推导遍历结果"></a>推导遍历结果</h4><p>二叉树遍历的两个性质：</p><ul><li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li><li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li></ul><p><strong>已知前序和后序遍历，是不能确定一棵二叉树的</strong>。因为无法确定子结点是左还是右。</p><h3 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h3><p>要在内存中建议一个树，为了能让每个结点确认是否有左右孩子，将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值，比如 ‘#’。称这种处理后的二叉树为原二叉树的扩展二叉树。扩展二叉树就可以做到一个遍历序列确定一棵二叉树了。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按前序输入二叉树中结点的值 (一个字符)</span></span><br><span class="line"><span class="comment">// &#x27;#&#x27; 表示空树，构造二叉链表表示二叉树 T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree *T)</span> &#123;</span><br><span class="line">  TElemType ch;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">  <span class="keyword">if</span>(ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    *T = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    *T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">if</span>(!*T)</span><br><span class="line">      <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    (*T) -&gt; data = ch;<span class="comment">// 生成根结点</span></span><br><span class="line">    CreateBiTree(&amp;(*T) -&gt; lchild);<span class="comment">// 构造左子树</span></span><br><span class="line">    CreateBiTree(&amp;(*T) -&gt; rchild);<span class="comment">// 构造右子树</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立二叉树也是利用了递归的原理。只不过在原来应该是打印结点的地方，改成了生成结点、给结点赋值的操作而已。</p><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h4 id="线索二叉树原理"><a href="#线索二叉树原理" class="headerlink" title="线索二叉树原理"></a>线索二叉树原理</h4><p><strong>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树 (Threaded Binary Tree)。对二叉树以某种次序遍历使其变为线索二叉树的过程称作是线索化</strong>。</p><p>结点结构：</p><table><thead><tr><th align="center">lchild</th><th align="center">ltag</th><th align="center">data</th><th align="center">rtag</th><th align="center">rchild</th></tr></thead></table><ul><li>ltag 为 0 时指向该结点的左孩子，为 1 时 指向该结点的前驱。</li><li>rtag 为 0 时指向该结点的右孩子，为 1 时 指向该结点的后继。</li></ul><h4 id="线索二叉树结构实现"><a href="#线索二叉树结构实现" class="headerlink" title="线索二叉树结构实现"></a>线索二叉树结构实现</h4><p>二叉树的线索存储结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的二叉线索存储结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>Link, Thread&#125; PointerTag;<span class="comment">// Link == 0 表示指向左右孩子指针，Threed == 1 表示指向前驱或后继的线索</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode</span> &#123;</span><span class="comment">// 二叉线索存储结点结构</span></span><br><span class="line">  TElemType data;<span class="comment">// 结点数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">// 左右孩子指针</span></span><br><span class="line">  PointerTag LTag;</span><br><span class="line">  PointerTag RTag;<span class="comment">// 左右标志</span></span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure><p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以<strong>线索化的过程就是在遍历的过程中修改空指针的过程</strong>。</p><p>中序遍历线索化的递归函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BiThrTree pre;<span class="comment">// 全局变量，始终指向刚刚访问过的结点</span></span><br><span class="line"><span class="comment">// 中序遍历进行中序线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThreading</span><span class="params">(BiThrTree p)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(p) &#123;</span><br><span class="line">    InThreading(p -&gt; lchild);<span class="comment">// 递归左子树线索化</span></span><br><span class="line">    <span class="keyword">if</span>(!p -&gt; lchild) &#123;</span><br><span class="line">      p -&gt; LTag = Thread;<span class="comment">// 前驱线索</span></span><br><span class="line">      p -&gt; lchild = pre;  <span class="comment">// 左孩子指针指向前驱</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!pre -&gt; rchild) &#123;</span><br><span class="line">      pre -&gt; RTag = Thread;<span class="comment">// 后继线索</span></span><br><span class="line">      pre -&gt; rchild = p;<span class="comment">// 前驱右孩子指针指向后继 (当前结点 p)</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre = p;<span class="comment">// 保持 pre 指向 p 的前驱</span></span><br><span class="line">    InThreading(p -&gt; rchild);  <span class="comment">// 递归右子树线索化</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 指向头结点，头结点左链 lchild 指向根结点，头结点右链 rchild 指向中序遍历的最后一个结点。中序遍历二叉线索链表表示的二叉树 T</span></span><br><span class="line">Status <span class="title function_">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span> &#123;</span><br><span class="line">  BiThrTree p;</span><br><span class="line">  p = T -&gt; lchild;<span class="comment">// p 指向根结点</span></span><br><span class="line">  <span class="keyword">while</span>(p != T) &#123;<span class="comment">// 空树或遍历结束时</span></span><br><span class="line">    <span class="keyword">while</span>(p -&gt; LTag == Link)<span class="comment">// 当 LTag == 0 时循环到中序序列第一个结点</span></span><br><span class="line">      p = p -&gt; lchild;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p -&gt; data);<span class="comment">// 显示结点数据，可以更改为其它对结点操作</span></span><br><span class="line">    <span class="keyword">while</span>(p -&gt; RTag == Thread &amp;&amp; p -&gt; rchild != T) &#123;</span><br><span class="line">      p = p -&gt; rchild;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p -&gt; data);</span><br><span class="line">    &#125;</span><br><span class="line">    p = p -&gt; rchild;<span class="comment">// p 进至其右子树根</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</p><h3 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h3><h4 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h4><p>将树转换为二叉树的步骤如下：</p><ol><li>加线。在所有兄弟结点之间加一条连线。</li><li>去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其它孩子结点之间的连线。</li><li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。</li></ol><h4 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h4><p>森林是由若干树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。</p><ol><li>把每个树转换为二叉树。</li><li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。</li></ol><h4 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h4><p>二叉树转换为树是树转换为二叉树的逆过程，也就是反过来做而已。</p><ol><li>加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……，反正就是左孩子的 n 个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。、</li><li>去线。删除原二叉树中所有结点与其右孩子结点的连线。</li><li>层次调整。使之结构层次分明。</li></ol><h4 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h4><p>判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。</p><ol><li>从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。</li><li>再将每棵分离后的二叉树转换为树即可。</li></ol><h4 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h4><p>树的遍历分为两种方式</p><ol><li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。</li><li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。</li></ol><p>森林的遍历也分为两种方式：</p><ol><li><strong>前序遍历</strong>：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。</li><li><strong>后序遍历</strong>：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。</li></ol><h3 id="赫夫曼树及其应用"><a href="#赫夫曼树及其应用" class="headerlink" title="赫夫曼树及其应用"></a>赫夫曼树及其应用</h3><h4 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h4><p>例子：对于老师来讲，对试卷评分的时候，根据统一的标准换算得出五级分制的成绩。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &lt; <span class="number">60</span>)</span><br><span class="line">  b = <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a &lt; <span class="number">70</span>)</span><br><span class="line">  b = <span class="string">&quot;及格&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a &lt; <span class="number">80</span>)</span><br><span class="line">  b = <span class="string">&quot;中等&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a &lt; <span class="number">90</span>)</span><br><span class="line">  b = <span class="string">&quot;良好&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  b = <span class="string">&quot;优秀&quot;</span>;</span><br></pre></td></tr></table></figure><p>上面的程序，使得所有的成绩都需要先判断是否及格，再逐级而上得到结果。输入量很大的时候，其实算法是有效率问题的。</p><p><img src="/../img/dsa/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%912.png" alt="赫夫曼树2"></p><p>如果在实际的学习生活中，学生的成绩在 5 个等级上的分布规律如表所示</p><table><thead><tr><th align="center">分数</th><th align="center">0 ~ 59</th><th align="center">60 ~ 69</th><th align="center">70 ~ 79</th><th align="center">80 ~ 89</th><th align="center">90 ~ 100</th></tr></thead><tbody><tr><td align="center">所占比例</td><td align="center">5%</td><td align="center">15%</td><td align="center">40%</td><td align="center">30%</td><td align="center">10%</td></tr></tbody></table><p>那么 70 分以上大约占总数 80% 的成绩都需要经过 3 次以上的判断才可以得到结果，这很不合理。中等成绩 (70 ~ 79 分之间) 比例最高，其次是良好成绩，不及格的所占比例最小。重新把这棵二叉树进行分配：</p><p><img src="/../img/dsa/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%913.png" alt="赫夫曼树3"></p><h4 id="赫夫曼树定义与原理"><a href="#赫夫曼树定义与原理" class="headerlink" title="赫夫曼树定义与原理"></a>赫夫曼树定义与原理</h4><p>把上面两棵二叉树简化成叶子结点带权的二叉树。其中 A 表示不及格、B 表示及格、C 表示中等、D 表示良好、E 表示优秀。每个叶子的分支线上的数字就是5级分制的成绩所占比例数。</p><p><img src="/../img/dsa/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%911.png" alt="赫夫曼树1"></p><p><strong>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度</strong>。上图二叉树 a 中，根结点到结点 D 的路径长度为 4，二叉树 b 中根结点到结点 D 的路径长度为 2。<strong>树的路径长度就是从树根到每一结点的路径长度之和</strong>。二叉树 a 的树路径长度就为 1 + 1 + 2 + 2 + 3 + 3 +4 + 4 &#x3D; 20。二叉树 b 的树路径长度就为 1 + 2 +3 + 3 + 2 + 1 + 2 + 2 &#x3D; 16。</p><p>如果考虑到带权的结点，结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。假设有 n 个权值 {W<sub>1</sub>, W<sub>2</sub>, ……, W<sub>n</sub>}，构造一棵有 n 个叶子结点的二叉树，每个叶子结点带权 W<sub>k</sub>，每个叶子的路径长度为 1k，通常记作，则其中<strong>带权路径长度 WPL 最小的二叉树称作赫夫曼树</strong>。</p><p>赫夫曼算法描述：</p><ol><li>根据给定的 n 个权值 {W<sub>1</sub>, W<sub>2</sub>, ……, W<sub>n</sub>} 构成 n 棵二叉树的集合 F &#x3D; {T<sub>1</sub>, T<sub>2</sub>, ……, T<sub>n</sub>}，其中每棵二叉树 T<sub>i</sub> 中只有一个带权为 W<sub>i</sub> 根结点，其左右子树均为空。</li><li>在 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</li><li>在 F 中删除这两棵树，同时将新得到的二叉树加入 F 中。</li><li>重复 2 和 3 步骤，知道 F 只含一棵树为止。这棵树便是赫夫曼树。</li></ol><h4 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h4><p>赫夫曼树更大的目的是为了解决当年远距离通信 (主要是电报) 的数据传输的最优化问题。</p><p>比如有一段文字内容为 “BADCADFEED“ 要网络传输给别人，显然用二进制的数字 (0 和 1) 来表示是很自然的想法。这段文字只有六个字母 ABCDEF，可以用相应的二进制数据表示。</p><table><thead><tr><th align="center">字母</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th></tr></thead><tbody><tr><td align="center">二进制字符</td><td align="center">000</td><td align="center">001</td><td align="center">010</td><td align="center">011</td><td align="center">100</td><td align="center">101</td></tr></tbody></table><p>这样真正传输的数据就是编码后的 “001000011010000011101100100011”，对方接收时可以按照 3 位 一分来译码。如果一篇文章很长，这样的二进制串也将非常的可怕。而且事实上，不管是英文、中文或是其它语言，字母或汉字的出现频率是不相同的，比如英语中的几个元音字母 “a e i o u”，中文中的 “的 了 有 在” 等汉字都是频率极高。</p><p>假设六个字母的频率为 A 27，B 8，C 15，D 15，E 30，F 5，合起来正好是 100%。那就意味着，可以完全重新按照赫夫曼树来规划它们。</p><p><img src="/../img/dsa/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%914.png" alt="赫夫曼树4"></p><p>左图为构造赫夫曼树的过程的权值显示，右图为将权值左分支改为 0，右分支改为 1 后的赫夫曼树。</p><p>对这六个字母用其从树根到叶子所经过路径的 0 或 1 来编码，可以得到如表所示的定义。</p><table><thead><tr><th align="center">字母</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th></tr></thead><tbody><tr><td align="center">二进制字符</td><td align="center">01</td><td align="center">1001</td><td align="center">101</td><td align="center">00</td><td align="center">11</td><td align="center">1000</td></tr></tbody></table><p>将文字内容为 “BADCADFEED” 再次编码，对比可以发现结果串变小了。</p><ul><li>原编码二进制串：001000011010000011101100100011 ( 共 30 个字符 )</li><li>新编码二进制串：1001010010101001000111100 ( 共 25 个字符 )</li></ul><p>也就是说，数据被压缩了，节约了大约 17% 的存储或传输成本。随着字符的增多和多字符权重的不同，这种压缩会更加显出其优势。</p><p>当接收到 1001010010101001000111100 这样压缩过的新编码时，应该怎么解码？</p><p>编码中非 0 即 1，长短不等的话其实是很容易混淆的，所以<strong>若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称作前缀编码</strong>。</p><p>在解码时，要用到赫夫曼树，己发送发和接收方必须要约定好同样的复合曼编码规则。</p><p>当接收到 1001010010101001000111100 时，由约定好的赫夫曼树可知，1001 得到第一个字母是 B，接下来 01 意味着第二个字符是 A。其余的也相应的可以得到，从而成功解码。</p><p><strong>一般地，设需要编码的字符集为 { d<sub>1</sub>, d<sub>2</sub>, …… , d<sub>n</sub> }，各个字符在电文中出现的次数或频率集合为  { w<sub>1</sub>, w<sub>2</sub>, …… , w<sub>n</sub> }，以 d<sub>1</sub>, d<sub>2</sub>, …… , d<sub>n</sub> 作为叶子结点，以 w<sub>1</sub>, w<sub>2</sub>, …… , w<sub>n</sub> 作为相应叶子结点的权值来构造一颗赫夫曼树。规定赫夫曼树的左右分支代表 0，右分支代表 1，则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码</strong>。</p><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>树的相关概念：子树、结点、度、叶子、分支结点、双亲、孩子、层次、深度、森林。</p><p>树的存储结构：双亲表示法、孩子表示法、孩子兄弟表示法。</p><p>二叉树每个结点最多两棵子树，有左右之分，提到了斜树、满二叉树、完全二叉树等。</p><p>二叉树的存储结构由于其特殊性是的既可以用顺序存储结构又可以用链式存储结构表示。</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p>在线性表中， 数据元素之间是被串起来的，仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继。在树形结构中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关。折合一对父母可以有多个孩子，但每个孩子却只能有一对父母是一个道理。在图形结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。</p><blockquote><p>图 (Graph) 是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为: G (V, E)，其中 G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。</p></blockquote><p>对于图的定义，需要明确几个注意的地方：</p><ul><li>线性表中我们把数据元素叫元素，树中将数据元素叫结点，**在图中数据元素，称之为顶点 (Vertex)**。</li><li>线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。在图结构中，不允许没有丁点。在定义中，若 V 是顶点的集合，则强调了顶点集合 V 有穷非空。</li><li>线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而<strong>图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示</strong>，边集可以是空的。</li></ul><h4 id="各种图定义"><a href="#各种图定义" class="headerlink" title="各种图定义"></a>各种图定义</h4><p><strong>无向边：若顶点 v<sub>i</sub> 到 v<sub>j</sub> 之间的边没有方向，则称这条边为无向边 (Edge)，用无序偶对 (v<sub>i</sub>, v<sub>j</sub>)来表示</strong>。如果图中任意两个顶点之间的边都是无向边，则称该图为**无向图 (Undirected graphs)**。</p><p><img src="/../img/dsa/%E6%97%A0%E5%90%91%E8%BE%B9.png" alt="无向边"></p><p>由于是无向的，连接顶点 A 与 D 的边，可以表示成无序对 (A, D)，也可以写成 (D, A)。对于图中无向图 G<sub>1</sub> 来说，G<sub>1</sub>  &#x3D; (V<sub>1</sub>, {E<sub>1</sub>})，其中顶点集合 V<sub>1</sub> &#x3D; {A, B, C, D}；边集合 E<sub>1</sub> &#x3D; {(A, B), {B, C}, (C, D), (D, A), (A, C)}。</p><p><img src="/../img/dsa/%E6%9C%89%E5%90%91%E8%BE%B9.png" alt="有向边"></p><p>**有向边：若从顶点 V<sub>i</sub> 到V<sub>j</sub> 的边有方向，则称这条边为有向边，也称为弧 (Arc)<strong>。用有序偶 &lt;V<sub>i</sub>, V<sub>j</sub>&gt; 来表示，V<sub>i</sub> 称为弧尾 (Tail)，V<sub>j</sub> 称为弧头 (Head)。如果图中任意两个顶点之间的边都是有向边，则称该图为</strong>有向图 (Directed graphs)<strong>。上图是一个有向图，</strong>连接顶点 A 到 D 的有向边就是弧，A 是弧尾，D 是弧头，&lt;A, D&gt; 表示弧，注意不能写成&lt;D, A&gt;**。对于图中的有向图 G<sub>2</sub> 来说，G<sub>2</sub> &#x3D; (V<sub>2</sub>, {E<sub>2</sub>})，其中顶点集合 V<sub>2</sub> &#x3D; {A, B, C, D}；弧集合 E<sub>2</sub> &#x3D; {&lt;A, D&gt;, &lt;B, A&gt;, &lt;C, A&gt;, &lt;B, C&gt;}。</p><p><strong>无向边有小括号 “( )” 表示，而有向边则是用尖括号 “&lt;&gt;”表示</strong>。</p><p><strong>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图</strong>。</p><p><strong>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图</strong>。含有 n 个顶点的无向完全图有 n*(n-1)&#x2F;2 条边。</p><p><strong>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图</strong>。含有 n 个顶点的有向完全图有 n*(n-1) 条边。<br>从这里也可以得到结论，对于具有 n 个顶点和 e 条边数的图，无向图 0 ≤ e ≤ n(n-1)&#x2F;2，有向图 0 ≤ e ≤ n(n-1)。</p><p><strong>又很少条边或弧的图称为稀疏图，反之称为稠密图</strong>。这里稀疏和稠密是模糊的概念，都是相对而言的。</p><p>有些图的边或弧具有与它相关的数字，这种**与图的边或弧相关的数叫做权 (weight)<strong>。这些权可以表示从一个顶点到另一个顶点的距离或耗费。</strong>这种带权的图通常称为网 (Network)**。</p><p>**假设有两个图 G &#x3D; (V, {E}) 和 G’ &#x3D; (V’, {E’})，如果 V’⊆ V 且 E’ ⊆ E，则称 G’ 为 G 的子图 (Subgraph)**。</p><h4 id="图的顶点与边间关系"><a href="#图的顶点与边间关系" class="headerlink" title="图的顶点与边间关系"></a>图的顶点与边间关系</h4><p>**对于无向图 G &#x3D; (V, {E})，如果边 (v, v’) ∈ E，则称顶点 v 和 v’ 互为邻接点 (Adjacent)，即 v 和 v’ 相邻接。边 (v, v’) 依附 (incident) 与顶点 v 和 v’，或者说 (v, v’) 与顶点 v 和 v’ 相关联。顶点 v 的度 (Degree) 是和 v 相关联的边的数目，记为TD(v)**。</p><p>**对于有向图 G &#x3D; (V, {E})，如果弧 &lt;v, v’&gt; ∈ E，则称顶点 v 邻接到顶点 v’，顶点 v’ 邻接自顶点 v。弧 &lt;v, v’&gt; 和顶点 v，v’相关联。以顶点 v 为头的弧的数目称为 v 的入度 (InDegree)，记为 ID(v)；以 v 为尾的弧的数目称为 v 的出度 (OutDegree)，记为OD(v)；顶点 v 的度为 TD(v) &#x3D; ID(v) + OD(v)**。</p><p><strong>无向图 G &#x3D; (V, {E}) 中从顶点 v 到顶点 v’ 的路径 (Path) 是一个顶点序列 (v&#x3D;v<sub>i,0</sub>, v<sub>i,1</sub>, ···, v<sub>i,m</sub>)，其中 (v<sub>i,j-1</sub>) ∈ E，1 ≤ j ≤ m</strong>。</p><p><strong>路径的长度是路径上的边或弧的数目。第一个顶点到最后一个顶点相同的路径称为回路或环 (Cycle)。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环</strong>。</p><h4 id="连通图相关术语"><a href="#连通图相关术语" class="headerlink" title="连通图相关术语"></a>连通图相关术语</h4><p>**图中任意两个顶点 v<sub>i</sub>、v<sub>j</sub> ∈ E，v<sub>i</sub> 和 v<sub>j</sub> 都是连通的，则称 G 是连通图 (Connected Graph)**。</p><p><strong>无向图中的极大连通子图称为连通分量</strong>。注意连通分量的概念，它强调：</p><ul><li>要是子图；</li><li>子图要是连通的；</li><li>连通子图含有极大顶点数；</li><li>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</li></ul><p><strong>在有向图 G 中，如果对于每一对 v<sub>i</sub>、v<sub>j</sub> ∈ V、v<sub>i</sub> ≠ v<sub>j</sub>，从 v<sub>i</sub> 到 v<sub>j</sub> 和从v<sub>j</sub> 到 v<sub>i</sub> 都存在路径，则称 G 是强连通图。有向图中的极大强连通子图称做有向图的强连通分量</strong>。</p><p>所谓的<strong>一个连通图的生成树是一个极小的连通子图，它含有图中全部的 n 个顶点，但只有足以构成一棵树的 n-1 条边。如果一个有向图恰有一个顶点的入度为 0，其余顶点的入度均为 1，则是一颗有向树</strong>。对有向树的理解比较容易，所谓入度为 0 其实就是相当于树中的根结点，其余顶点入度为 1 就是说树的非根结点的双亲只有一个。<strong>一个有向图的生成森林由若干棵有向数组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧</strong>。</p><h4 id="图的定义与术语总结"><a href="#图的定义与术语总结" class="headerlink" title="图的定义与术语总结"></a>图的定义与术语总结</h4><p><strong>图</strong>按照有无方向分为<strong>无向图</strong>和<strong>有向图</strong>。无向图由<strong>顶点</strong>和<strong>边</strong>构成，有向图由<strong>顶点</strong>和<strong>弧</strong>构成。弧有<strong>弧尾</strong>和<strong>弧头</strong>之分。</p><p>图按照边或弧的多少分<strong>稀疏图</strong>和<strong>稠密图</strong>。如果任意两个顶点之间都存在边叫<strong>完全图</strong>，有向的叫<strong>有向完全图</strong>。若无重复的边或顶点到自身的边则叫<strong>简单图</strong>。</p><p>图中顶点之间有<strong>邻接点</strong>、<strong>依附</strong>的概念。无向图顶点的边数叫做<strong>度</strong>，有向图顶点分为<strong>入度</strong>和<strong>出度</strong>。</p><p>图上的边或弧上带权则称为<strong>网</strong>。</p><p>图中顶点间存在<strong>路径</strong>，两顶点存在路径则说明是<strong>连通</strong>的，如果路径最终回到起始点则称为<strong>环</strong>，当中不重复叫<strong>简单路径</strong>。若任意两顶点都是连通的，则图就是<strong>连通图</strong>，有向则称<strong>强连通图</strong>。图中有子图，若子图极大连通则就是<strong>连通分量</strong>，有向的则称<strong>强连通分量</strong>。</p><p>无向图中连通且 n 个顶点 n - 1 条边叫<strong>生成树</strong>。有向图中一顶点入度为 0 其余顶点入度为 1 的叫<strong>有向树</strong>。一个有向图由若干棵有向树构成生成<strong>森林</strong>。</p><h3 id="图的抽象数据类型"><a href="#图的抽象数据类型" class="headerlink" title="图的抽象数据类型"></a>图的抽象数据类型</h3><p>图作为一种数据结构，它的抽象数据类型带有自己特点，正因为它的复杂，运用广泛，使得不同的应用需要不同的运算集合，构成不同的抽象数据操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ADT 图 (Graph)</span><br><span class="line">Data</span><br><span class="line">  顶点的有穷非空集合和边的集合</span><br><span class="line">Operation</span><br><span class="line">  <span class="title function_">CreateGraph</span><span class="params">(*G, V, VR)</span>: 按照顶点集合 V 和边弧集 VR 的定义构造图 G。</span><br><span class="line">  <span class="title function_">DestroyGraph</span><span class="params">(*G)</span>: 图 G 存在则销毁。</span><br><span class="line">  <span class="title function_">LocateVex</span><span class="params">(G, u)</span>: 若图 G 中存在顶点 u，则返回图中的位置。</span><br><span class="line">  <span class="title function_">GetVex</span><span class="params">(G, v)</span>: 返回图 G 中顶点 v 的值。</span><br><span class="line">  <span class="title function_">PutVex</span><span class="params">(G, v, value)</span>: 将图 G 中顶点 v 赋值 value。</span><br><span class="line">  <span class="title function_">FirstAdjVex</span><span class="params">(G, *v)</span>: 返回顶点 v 的一个邻接点，若顶点在 G 中无邻接顶点返回空。</span><br><span class="line">  <span class="title function_">NextAdVex</span><span class="params">(G, v, *w)</span>: 返回顶点 v 相对于顶点 w 的下一个邻接顶点，若 w 是 v 的最后一个邻接点则返回“空”。</span><br><span class="line">  <span class="title function_">InsertVex</span><span class="params">(*G, v)</span>: 在图 G 中增添新顶点 v。</span><br><span class="line">  <span class="title function_">DeleteVex</span><span class="params">(*G, v)</span>: 删除图 G 中顶点 v 及其相关的弧。</span><br><span class="line">  <span class="title function_">InsertArc</span><span class="params">(*G, v, w)</span>: 在图 G 中增添弧 &lt;v, w&gt;，若 G 是无向图，还需要增添对称弧 &lt;w, v&gt;。</span><br><span class="line">  <span class="title function_">DeleteArc</span><span class="params">(*G, v, w)</span>: 在图 G 中删除弧 &lt;v, w&gt;，若 G 是无向图，则还删除对称弧 &lt;w, v&gt;。</span><br><span class="line">  <span class="title function_">DFSTraverse</span><span class="params">(G)</span>: 对图 G 中进行深度优先遍历，在遍历过程对每个顶点调用。</span><br><span class="line">  <span class="title function_">HFSTraverse</span><span class="params">(G)</span>: 对图 G 中进行广度优先遍历，在遍历过程对每个顶点调用。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><p>图的存储结构相较线性表与树来说就复杂了，平时所说的“顶点的位置”或“邻接点的位置”只是一个相对的概念。其实从图的逻辑结构定义来看，图上任何一个顶点都可被看成是第一个顶点，任一顶点的临界点之间也不存在次序关系。正由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在内存中的物理位置来表示元素之间的关系，也就是说，图不可能用简单的顺序存储结构来表示。而多重链表的方式，即以一个数据域和多个指针域组成的结点表示图中的一个顶点，尽管可以实现图结构。如果各顶点的度数相差很大，按度数最大的顶点设计结点结构会造成很多存储单元的浪费，而若按每个顶点自己的度数设计不同的顶点结构，又带来操作的不变。</p><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>考虑到图是顶点和边或弧两部分组成。合在一起比较困难，那就很自然地考虑到分两个结构来分别存储。顶点不分大小、主次，所以用一个一维数组来存储是很不错的选择。而边或弧由于是顶点与顶点之间的关系，一维搞不定，那就考虑用一个二维数组来存储。</p><p><strong>图的邻接矩阵 (Adjacency Matrix) 存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组 (称为邻接矩阵) 存储图中的边或弧的信息</strong>。</p><p>设图 G 有 n 个顶点，则邻接矩阵是一个 n*n 的方阵，定义为：</p><p>Arc[i][j] &#x3D; 1, 若 (v<sub>i</sub>, v<sub>j</sub>) ∈ E 或 &lt; v<sub>i</sub>, v<sub>j</sub> &gt;∈ E</p><p>Arc[i][j] &#x3D; 0，反之</p><p><img src="/../img/dsa/%E6%97%A0%E5%90%91%E5%9B%BE.png" alt="无向图"></p><p>可以设置两个数组，顶点数组为 vertex[4] &#x3D; {v<sub>0</sub>, v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>}，边数组 arc[4][4] 为上面右图中的一个矩阵。对于矩阵的主对角线的值，即 arc[0][0] 、arc[1][1]、arc[2][2]、arc[3][3]，全为 0 是因为不存在顶点到自身的边，比如 v<sub>0</sub> 到 v<sub>0</sub>。arc[0][1] &#x3D; 1 是因为 v<sub>0</sub> 到 v<sub>1</sub> 的边存在，而 arc[1][3] &#x3D; 0 是因为 v<sub>1</sub> 到 v<sub>3</sub> 的边不存在。并且由于是无向图， v<sub>1</sub> 到 v<sub>3</sub> 的边不存在，意味着 v<sub>3</sub> 到 v<sub>1</sub> 的边也不存在。所以无向图的边数组是一个对称矩阵。</p><p>要知道某个顶点的度，其实就是这个顶点 v<sub>i</sub> 在邻接矩阵中第 i 行 (或第 i 列) 的元素之和。求顶点 v<sub>i</sub> 的所有邻接点就是将矩阵中第 i 行元素扫描一遍，arc[i][j] 为 1 就是邻接点。</p><p>邻接矩阵的创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;<span class="comment">// 顶点类型应由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;<span class="comment">// 边上的权值类型应由用户定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVEX 100<span class="comment">// 最大顶点数，应由用户定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 65535<span class="comment">// 用 65535 来代表 ∞</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  VertexType vexs[MAXVEX];<span class="comment">// 顶点表</span></span><br><span class="line">  EdgeType arc[MAXVEX][MAXVEX];<span class="comment">// 邻接矩阵，可看作边表</span></span><br><span class="line">  <span class="type">int</span> numVertexes, numEdges;<span class="comment">// 图中当前的顶点数和边数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><p>无向网图的创建代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立无向网图的邻接矩阵表示</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateMGraph</span><span class="params">(MGraph *G)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j, k, w;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输入顶点数和边数:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d, %d&quot;</span>, &amp;G -&gt; numVertexes, &amp;G -&gt; numEdges);<span class="comment">// 输入顶点数和边数</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G -&gt; numVertexes; i++)<span class="comment">// 读入顶点信息，建立顶点表</span></span><br><span class="line">    <span class="built_in">scanf</span>(&amp;G -&gt; vexs[i]);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G -&gt; numVertexes; i++)</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G -&gt; numVertexes; j++)</span><br><span class="line">      G -&gt; arc[i][j] = INFINITY;<span class="comment">// 邻接矩阵初始化</span></span><br><span class="line">  <span class="keyword">for</span>(k = <span class="number">0</span>; k -&gt; numEdges; k++) &#123;<span class="comment">// 读入 numEdges条边，建立邻接矩阵</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入边 (vi, vj) 上的下标 i，下标 j 和权 w: \n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d, %d, %d&quot;</span>, &amp;i, &amp;j, &amp;w);<span class="comment">// 输入边 (vi, vj) 上的权 w</span></span><br><span class="line">    G -&gt; arc[i][j] = w;</span><br><span class="line">    G -&gt; arc[i][j] = G -&gt; arc[i][j];<span class="comment">// 因为是无向图，矩阵对称</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中也可以得到，n 个顶点和 e 条边的无向网图的创建，时间复杂度为 O(n + n<sup>2</sup> + e)，其中对邻接矩阵 Garc 的初始化耗费了 O(n<sup>2</sup>) 的时间。</p><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>邻接矩阵是不错的一种图存储结构，对于边数相对顶点较少的图，这种结构是存在对存储空间的极大浪费的。</p><p>**数组与链表相结合的存储方法称为邻接表 (Adjacency List)**。</p><p>邻接表的处理办法：</p><ol><li>图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个令结点的指针，以便于查找该顶点的边信息。</li><li>图中每个顶点 v<sub>i</sub> 的所有令结点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点 v<sub>i</sub> 的边表，有向图则称为顶点 v<sub>i</sub> 作为弧尾的出边表。</li></ol><p><img src="/../img/dsa/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="无向图的邻接表结构"></p><p>上图是一个无向图的邻接表结构。从图中知道，顶点表的各个结点由 data 和 firstedge 两个域表示，data 是数据域，存储顶点的信息，firstedge 是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。边表结点由 adjvex 和 next 两个域组成。adjvex 是临界点域，存储某顶点的临接点在顶点表中的下标，next 则存储指向边表中下一个结点的指针。比如 v<sub>1</sub> 顶点与 v<sub>0</sub>、v<sub>2</sub> 互为邻接点，则在 v<sub>1</sub> 的边表中，adjvex 分别为 v<sub>0</sub> 的 0 和 v<sub>2</sub> 的 2。</p><p>这样的结构，对于要获得图的相关信息也是很方便的。比如想要知道某个顶点的度，就去查找这个顶点的边表中结点的个数。若要判断顶点 v<sub>ℹ</sub> 到 v<sub>j</sub> 是否存在边，只需要测试顶点 v<sub>i</sub> 的边表中 adjvex 是否存在结点 v<sub>j</sub>的下标 j 就行了。若求顶点的所有邻接点，其实就是对此顶点的边表进行遍历，得到 adjvex 域对应的顶点就是邻接点。</p><p><img src="/../img/dsa/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E9%80%86%E9%82%BB%E6%8E%A5%E8%A1%A8.png" alt="有向图的逆邻接表"></p><p>若是有向图，邻接表结构是类似的，比如上图中第一幅图的邻接表就是第二幅图。但要注意的是有向图由于有方向，是以顶点为弧尾来存储边表的，这样很容易就可以得到每个顶点的出度。但也有时为了便于确定顶点的入度或以顶点为弧头的弧，可以建立<strong>一个有向图的逆邻接表，即对每个顶点 v<sub>1</sub> 都建立一个链接为 v<sub>i</sub> 为弧头的表</strong>。如上图的第三幅图。</p><p>此时很容易就可以算出某个顶点的入度和出度是多少，判断两顶点是否存在弧也很容易实现。</p><p>对于带权值的网图，可以在边表结点定义中再增加一个 weight 的数据域，存储权值信息即可。</p><p>结点定义的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;<span class="comment">// 顶点类型应由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;<span class="comment">// 边上的权值类型应由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span><span class="comment">// 边表结点</span></span><br><span class="line">  <span class="type">int</span> adjvex;<span class="comment">// 临界点域，存储该顶点对应的下标</span></span><br><span class="line">  EdgeType weight;<span class="comment">// 用于存储权值，对于非网图可以不需要</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span><span class="comment">// 链域，指向下一个邻接点</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> &#123;</span><span class="comment">// 顶点表结点</span></span><br><span class="line">  VertexType data;<span class="comment">// 顶点域，存储顶点信息</span></span><br><span class="line">  EdgeNode *firstedge;<span class="comment">// 边表头指针</span></span><br><span class="line">&#125;VertexNode, AdjList[MAXVEX];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  AdjList adjList;</span><br><span class="line">  <span class="type">int</span> numVertexes, numEdges;<span class="comment">// 图中当前顶点数和边数</span></span><br><span class="line">&#125;GraphAdjList;</span><br></pre></td></tr></table></figure><p>无向图的邻接表创建代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立图的邻接表结构</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateALGraph</span><span class="params">(GraphAdjList *G)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j, k;</span><br><span class="line">  EdgeNode *e;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输入顶点数和边数:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;G -&gt; numVertexes, &amp;G -&gt; numEdges);<span class="comment">// 输入顶点数和边数</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G -&gt; numVertexes; i++) &#123;<span class="comment">// 读入顶点信息，建立顶点表</span></span><br><span class="line">    <span class="built_in">scanf</span>(&amp;G -&gt; adjList[i].data);<span class="comment">// 输入顶点信息</span></span><br><span class="line">    G -&gt; adjList[i].firstedge = <span class="literal">NULL</span>;<span class="comment">// 将边表置为空表</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G -&gt; numEdges; k++) &#123;<span class="comment">// 建立边表</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输入边（vi, vj) 上的顶点序号: \n&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d, %d&quot;</span>, &amp;i, &amp;j);<span class="comment">// 输入边 (vi, vj) 上的顶点序号</span></span><br><span class="line">  e = (EdgeNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));<span class="comment">// 向内存中申请空间，生成边表结点</span></span><br><span class="line">  e -&gt; adjvex = j;<span class="comment">// 邻接序号为 j</span></span><br><span class="line">  e -&gt; next = G -&gt; adjList[i].firstedge = e;<span class="comment">// 将 e 指针指向当前顶点指向的结点</span></span><br><span class="line">  G -&gt; adjList[i].firstedge = e;<span class="comment">// 将当前顶点的指针指向 e</span></span><br><span class="line">  e = (EdgeNode *)nalloc(<span class="keyword">sizeof</span>(EdgeNode));<span class="comment">// 向内存申请空间，生成边表结点</span></span><br><span class="line">  e -&gt; adjvex = i;<span class="comment">// 邻接序号为 i</span></span><br><span class="line">  e -&gt; next = G -&gt; adjList[j].firstedge;<span class="comment">// 将 e 指针指向当前顶点指向的结点</span></span><br><span class="line">  G -&gt; adjList[j].firstedge = e;<span class="comment">// 将当前顶点的指针指向 e</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>15 开始的代码是应用了在单链表创建中的头插法，由于对于无向图，一条边对应都是两个顶点，所以在循环中，一次就针对 i 和 j 分别进行了插入。本算法的时间复杂度，对于 n 个顶点 e 条边来说，很容易得出是 O(n+e)。</p><h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><p><strong>把邻接表与逆邻接表结合起来的存储方法叫做十字链表</strong>。</p><p>重新定义顶点表结点结构。</p><table><thead><tr><th align="center">data</th><th align="center">firstin</th><th align="center">firstout</th></tr></thead></table><p>其中 first 表示入边表头指针，指向该顶点的入边表中第一个结点，firstout 表示出边表头指针，指向该顶点的出边表中的第一个结点。</p><p>重新定义的边表结点结构。</p><table><thead><tr><th align="center">tailvex</th><th align="center">headvex</th><th align="center">headlink</th><th align="center">taillink</th></tr></thead></table><p>其中 tailvex 是指起点在顶点表的下标，headvex 是指弧终点在顶点表中的下标，headlink 是指入边表指针域，指向终点相同的下一条边，taillink 是指边表指针域，指向起点相同的下一条边。如果是网，还可以再增加一个 weight 域来存储权值。</p><p><img src="/../img/dsa/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8.png" alt="十字链表"></p><p>上图顶点依然是存入一个一位数组 {v<sub>0</sub>, v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>}，实线箭头指针的图示完全与之前的邻接表相同。就以顶点 v<sub>0</sub> 来说，firstout 指向的是出边表中的第一个结点 v<sub>3</sub>。所以 v<sub>0</sub> 边表结点的 headvex &#x3D; 3，而 tailvex 其实就是当前顶点 v<sub>0</sub> 的下标 0，由于 v<sub>0</sub> 只有一个出边顶点，所以 headlink 和 taillink 都是空。</p><p>图中虚线箭头的含义，它其实就是此图的逆邻接表的表示。对于 v<sub>0</sub> 来说，它有两个顶点 v<sub>1</sub> 和 v<sub>2</sub> 的入边。因此 v<sub>0</sub> 的 firstin 指向顶点 v<sub>1</sub> 的边表结点中 headvex 为 0 的结点，如图中的 ①。接着由入边结点的 headlink 指向下一个入边顶点 v<sub>2</sub>，如图中的 ②。对于顶点 v<sub>1</sub>，它有一个入边顶点 v<sub>2</sub>，所以它的 firstin 指向顶点 v<sub>2</sub> 的边表结点中 headvex 为 1 的结点，如图中的 ③。顶点 v<sub>2</sub> 和 v<sub>3</sub> 也是同样有一个入边顶点，如图中 ④ 和 ⑤。</p><p>十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以 v<sub>i</sub> 为尾的弧，也容易找到以 v<sub>i</sub> 为头的弧，因而容易求得顶点的出度和入度。而且它除了结构复杂一点外，其实创建图算法的时间复杂度和邻接表相同，因此，在有向图的应用中，十字链表是非常好的数据结构模型。</p><h4 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h4><p><img src="/../img/dsa/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A81.png" alt="邻接多重表"></p><p>若要删除左图的 (v<sub>0</sub>, v<sub>2</sub>) 这条边，需要对邻接表结构中右边表的阴影两个结点进行删除操作，显然这是比较繁琐的。所以仿照十字链表的方式，对边表结点的结构进行一些改造，也许就可以避免刚才提到的问题。</p><p>重新定义的边表结点结构：</p><table><thead><tr><th align="center">ivex</th><th align="center">ilink</th><th align="center">jvex</th><th align="center">jlink</th></tr></thead></table><p>其中 <strong>ivex 和 jvex 是与某条边依附的两个顶点表中下标。ilink 指向依附顶点 ivex 的下一条边，jlink 指向依附顶点 jvex 的下一条边。这就是邻接多重表结构</strong>。</p><p><img src="/../img/dsa/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A82.png" alt="邻接多重表"></p><p>左图中有 4 个顶点和 5 条边，显然，应该先将 4 个顶点和 5 条边的边表结点画出来。由于是无向图，所以 ivex 是 0、jvex 是1 还是反过来都是无所谓的，不过为了绘图方便，都将 ivex 值设置得与一旁的顶点下标相同。</p><p><img src="/../img/dsa/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A83.png" alt="邻接多重表"></p><p>首先连线的 ①②③④ 就是将顶点的 firstedge 指向一条边，顶点下标要与 ivex 的值相同，这很好理解。接着，由于顶点 v<sub>0</sub> 的 (v<sub>0</sub>, v<sub>1</sub>) 边的邻边有 (v<sub>0</sub>, v<sub>3</sub>) 和 (v<sub>0</sub>, v<sub>2</sub>)。因此 ⑤⑥ 的连线就是满足指向下一条依附于顶点 v<sub>0</sub> 的边的目标，注意 ilink 指向的结点的 jvex 一定要和它本身的 ivex 的值相同。同样的道理，连线 ⑦ 就是指 (v<sub>1</sub>, v<sub>0</sub>) 这条边，它是相当于顶点 v<sub>1</sub> 指向 (v<sub>1</sub>, v<sub>2</sub>) 边后的下一条。v<sub>2</sub> 有三条边依附，所以在 ③ 之后就有了 ⑧⑨。连线 ⑩ 的就是顶点 v<sub>3</sub> 在连线 ④ 之后的下一条边。左图一共有 5 条边，所以右图有 10 条连线，完全符合预期。</p><p>邻接多重边与邻接表的差别，仅仅是在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。这样对边的操作就方便多了，若要删除左图的 (v<sub>0</sub>, v<sub>2</sub>) 这条边，只需要将右图的 ⑥⑨ 的链接指向改为 ^ 即可。</p><h4 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h4><p><strong>边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标 (begin)、终点下标 (end) 和权 (weight) 组成</strong>。显然边集数组关注的是边的集合，在边集数组中要查找一个顶点的度需要扫描整个边数组，效率并不高。因此它更适合对边依次进行处理的操作，而不适合对顶点相关的操作。</p><p><img src="/../img/dsa/%E8%BE%B9%E9%9B%86%E6%95%B0%E7%BB%84.png" alt="边集数组"></p><p>定义的边数组结构如表</p><table><thead><tr><th align="center">begin</th><th align="center">end</th><th align="center">weight</th></tr></thead></table><p>其中 begin 是存储起点下标，end 是存储终点下标，weight 是存储权值。</p><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>图的遍历和树的遍历类似，**从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历 (Traversing Graph)**。</p><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p><strong>深度优先遍历 (Depth_First_Search)，也有称为深度优先搜索，简称 DFS</strong>。深度优先遍历其实就是一个递归的过程，其实就像一棵树的前序遍历。<strong>它从图中某个顶点 v 出发，访问此顶点，然后从 v 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 v 有路径相通的顶点都被访问到</strong>。事实上，这是连通图，对于非连通图，只需要对它的连通分量分别进行深度优先遍历，即在先前一个顶点进行一次深度优先遍历后，<strong>若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点做起始点，重复上述过程，直至图中所有顶点都被访问到为止</strong>。</p><p>邻接矩阵方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Boolean;<span class="comment">// Boolean 是布尔类型，其值是 TRUE 或 FALSE</span></span><br><span class="line">Boolean visited[MAX];<span class="comment">// 访问标志的数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(MGraph G, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  visited[i] = TRUE;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G.vexs[i]);<span class="comment">// 打印顶点，也可以其它操作</span></span><br><span class="line">  <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.numVertexes; j++) </span><br><span class="line">    <span class="keyword">if</span>(G.arc[i][j] == <span class="number">1</span> &amp;&amp; !visited[j])</span><br><span class="line">      DFS(G, j);<span class="comment">// 对未访问的邻接顶点递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 邻接矩阵的深度遍历操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(MGraph G)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++)</span><br><span class="line">    visited[i] = FALSE;<span class="comment">// 初始所有顶点状态都是未访问过状态</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++)</span><br><span class="line">    <span class="keyword">if</span>(!visited[i])<span class="comment">// 对未访问过的顶点调用 DFS， 若是连通图，只会执行一次</span></span><br><span class="line">      DFS(G, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果图结构是邻接表结构，其 DFSTraverse 函数的代码是几乎相同的，只是在递归函数中因为将数组换成了链表而有不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接表的深度优先递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphAdjList GL, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  EdgeNode *p;</span><br><span class="line">  visited[i] = TRUE;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, GL -&gt; adjList[i].data);<span class="comment">// 打印顶点，也可以其它操作</span></span><br><span class="line">  p = GL -&gt; adjList[i].firstedge;</span><br><span class="line">  <span class="keyword">while</span>(p) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[p -&gt; adjvex])</span><br><span class="line">      DFS(GL, p -&gt; adjvex);<span class="comment">// 对未访问的邻接点递归调用</span></span><br><span class="line">    p = p -&gt; next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 邻接表的深度遍历操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(GraphAdjList GL)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL -&gt; numVertexes; i++) </span><br><span class="line">    visited[i] = FALSE;<span class="comment">// 初始所有顶点状态都是未访问过状态</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL -&gt; numVertexes; i++)  </span><br><span class="line">    <span class="keyword">if</span>(!visited[i])<span class="comment">// 对未访问过的顶点调用 DFS，若是连通图，只会执行一次</span></span><br><span class="line">    DFS(GL, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比两个不同存储结构的深度优先遍历算法，对于 n 个顶点 e 条边的图来说，邻接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此都需要 O(n<sup>2</sup>) 的时间。而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是 O(n + e)。显然对于点多少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。</p><p>对于有向图而言，由于它只是对通道存在可行或不可行，算法上没有变化，是完全可以通用的。</p><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p><strong>广度优先遍历 (Breadth_First_Search)，又称为广度优先搜索，简称 BFS</strong>。</p><p>如果说图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似于树的层序遍历了。将下图的第一幅图稍微变形，变形原则是顶点 A 放置在最上第一层，让与它有边的顶点 B、F 为第二层，再让与 B 和 F 有边的顶点 C、I、G、E 为第三层，再将这四个顶点有边的 D、H 放在第四层，如第二幅图所示。此时在视觉上感觉图的形状发生了变化，其实顶点和边的关系是完全相同的。</p><p><img src="/../img/dsa/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.png" alt="广度优先遍历"></p><p>邻接矩阵结构的广度优先遍历算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵的广度遍历算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(MGraph G)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  Queue Q ;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++) </span><br><span class="line">    visited[i] = FALSE;</span><br><span class="line">  InitQueue(&amp;Q);<span class="comment">// 初始化一辅助用的队列</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++) &#123;<span class="comment">// 对每一个顶点做循环</span></span><br><span class="line">    <span class="keyword">if</span>(!visited[i]) &#123;<span class="comment">// 若是未访问过就处理</span></span><br><span class="line">      visited[i] = TRUE;<span class="comment">// 设置当前顶点访问过</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G.vexs[i]);<span class="comment">// 打印顶点，也可以其它操作</span></span><br><span class="line">      EnQueue(&amp;Q, i);<span class="comment">// 将此顶点如队列</span></span><br><span class="line">      <span class="keyword">while</span>(!QueueEmpty(Q)) &#123;<span class="comment">// 若当前队列不为空</span></span><br><span class="line">        DeQueue(&amp;Q, &amp;i);<span class="comment">// 将队中元素出队列，赋值给 i</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.numVertexes;j++) &#123;</span><br><span class="line">          <span class="comment">// 判断其他顶点若与当前顶点存在边且未访问过</span></span><br><span class="line">          <span class="keyword">if</span>(G.arc[i][j] == <span class="number">1</span> ** !visited[j]) &#123;</span><br><span class="line">            visited[j] = TRUE;<span class="comment">// 将找到的此顶点标记为已访问</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G.vexs[j]);<span class="comment">// 打印顶点</span></span><br><span class="line">            EnQueue(&amp;Q, j);<span class="comment">// 将找到的此顶点入队列</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于邻接表的广度优先遍历，代码与邻接矩阵差异不大。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接表的广度遍历算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(GraphAdjList GL)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  EdgeNode *p;</span><br><span class="line">  Queue Q;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL -&gt; numVertexes; i++)</span><br><span class="line">    visited[i] = FALSE;</span><br><span class="line">  InitQueue(&amp;Q);</span><br><span class="line">  <span class="keyword">for</span>(i= <span class="number">0</span>; i &lt; GL -&gt; numVertexes; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">      visited[i] = TRUE;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, GL -&gt; adjList[i].data);<span class="comment">// 打印顶点，也可以其它操作</span></span><br><span class="line">      EnQueue(&amp;Q, i);</span><br><span class="line">      <span class="keyword">while</span>(!QueueEmpty(Q)) &#123;</span><br><span class="line">        DeQueue(&amp;Q, &amp;i);</span><br><span class="line">        p = GL -&gt; adjList[i].firstedge;<span class="comment">// 找到当前顶点边表链表头指针</span></span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">          <span class="keyword">if</span>(!visited[p -&gt; adjvex]) &#123;<span class="comment">// 若此顶点未被访问</span></span><br><span class="line">            visited[p -&gt; adjvex] = TRUE;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, GL - &gt; adjList[p -&gt; adjvex].data);</span><br><span class="line">            EnQueue(&amp;Q, p -&gt; adjvex);<span class="comment">// 将此顶点入队列</span></span><br><span class="line">          &#125;</span><br><span class="line">          p = p -&gt; next;<span class="comment">// 指针指向先一个邻接点</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比图的深度优先遍历与广度优先遍历算法，它们在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同。可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。不过如果图顶点和边非常多，不能在短时间内遍历完成，遍历的目的是为了寻找合适的顶点，那么选择哪种遍历就要仔细斟酌了。深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况。</p><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>**把构造连通网的最小代价生成树称为最小生成树 (Minimum Cost Spanning Tree)**。</p><h4 id="普里姆-Prim-算法"><a href="#普里姆-Prim-算法" class="headerlink" title="普里姆 (Prim) 算法"></a>普里姆 (Prim) 算法</h4><p><img src="/../img/dsa/Prim-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png" alt="Prim-邻接矩阵"></p><p>构造邻接矩阵，一个存储结构为 MGraph 的 G。G 有 9 个顶点，它的 arc 二维数组如右图所示。数组中的65535 用 ∞ 表示。</p><p>于是普里姆 (Prim) 算法代码如下，左侧数字为行号。其中 INFINITY 为权值极大值，不妨是 65535，MAXVEX 为顶点个数最大值，此处大于等于 9 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prim 算法生成最小生成树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MiniSpanTree_Prim</span><span class="params">(MGraph G)</span> &#123;</span><br><span class="line">  <span class="type">int</span> min, i, j, k;</span><br><span class="line">  <span class="type">int</span> adjvex[MAXVEX];<span class="comment">// 保存相关顶点下标</span></span><br><span class="line">  <span class="type">int</span> lowcost[MAXVEX];<span class="comment">// 保存相关顶点间边的权值</span></span><br><span class="line">  lowcost[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">// 初始化第一个权值为 0，即 v0加入生成树，lowcost 的值为 0，在这里就是此下标的顶点已经加入生成树</span></span><br><span class="line">  adjvex[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">// 初始化第一个顶点下标为 0 </span></span><br><span class="line">  <span class="keyword">for</span>(i = i; i &lt; G.numVertexes; i++) &#123;<span class="comment">// 循环除下标为 0 外的全部顶点</span></span><br><span class="line">    lowcost[i] = G.arc[<span class="number">0</span>][i];<span class="comment">// 将 v0 顶点与之有边的权值存入数组</span></span><br><span class="line">    adjvex[i] = <span class="number">0</span>;<span class="comment">// 初始化都为 v0 的下标</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; G.numVertexes; i++) &#123;</span><br><span class="line">    min = INFINITY;<span class="comment">// 初始化最小权值为 ∞，通常设置为不可能的大数字入 32767、65535 等</span></span><br><span class="line">    j = <span class="number">1</span>; k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; G.numVertexes) &#123;<span class="comment">// 循环全部顶点</span></span><br><span class="line">      <span class="keyword">if</span>(lowcost[j] != <span class="number">0</span> &amp;&amp; lowcost[j] &lt; min) &#123;<span class="comment">// 如果权值不为 0 且权值小于 min</span></span><br><span class="line">        min = lowcost[j];<span class="comment">// 则让当前权值称为最小值</span></span><br><span class="line">        k = j;<span class="comment">// 将当前最小值的下标存入 k</span></span><br><span class="line">      &#125;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)&quot;</span>, adjvex[k], k);<span class="comment">// 打印当前顶点边中权值最小边</span></span><br><span class="line">    lowcost[k] = <span class="number">0</span>;<span class="comment">// 将当前顶点的权值设置为 0，表示此顶点已经完成任务</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; G.numVertexes; j++) &#123;<span class="comment">// 循环所有顶点</span></span><br><span class="line">      <span class="keyword">if</span>(lowcost[j] != <span class="number">0</span> &amp;&amp; G.arc[k][j] &lt; lowcost[j]) &#123;<span class="comment">// 若下标为 k 顶点各边权值小于此前这些顶点未被加入生成树权值</span></span><br><span class="line">        lowcost[j] = G.arc[k][j];<span class="comment">// 将较小权值存入 lowcost</span></span><br><span class="line">        adjvex[j] = k;<span class="comment">// 将下标为 k 的顶点存入 adjvex</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>程序开始运行，由 4～5 行，创建了两个一维数组 lowcost 和 adjvex，长度都为顶点个数 9。</p></li><li><p>第 6～7 行分别给这两个数组的第一个下标位赋值为 0，arjvex[0] &#x3D; 0 其实意思就是现在从顶点 v<sub>0</sub> 开始 (事实上，最小生成树从哪个顶点开始计算都无所谓，假定从 v<sub>0</sub> 开始)，lowcost[0] &#x3D; 0 就表示 v<sub>0</sub> 已经被纳入到最小生成树中，之后凡是 lowcost 数组中的值被设置为 0 就是表示此下标的顶点被纳入最小生成树。</p></li><li><p>第 8～11 行表示读取右图邻接矩阵的第一行数据。将数值赋值给 lowcost 数组，所以此时 lowcost 数组值为{0, 10, 65535, 65535, 65535, 11,65535, 65535, 65535}，而 arjvex 则全部为 0。此时，我们已经完成了整个初始化的工作，准备开始生成。</p></li><li><p>第 12～31 行，整个循环过程就是构造最小生成树的过程。</p></li><li><p>第 13～14 行，将 min 设置为了一个极大值 65535，它的目的是为了之后找到一定范围内的最小权值。j 是用来做顶点下标循环的变量，k 是用来存储最小权值的顶点下标。</p></li><li><p>第 15～21行，循环中不断修改 min 为当前 lowcost 数组中最小值，并用 k 保留此最小值的顶点下标。经过循环后，min &#x3D; 10，k &#x3D; 1。 注意16行 if 判断的lowcost[j] !&#x3D; 0 表示已经是生成树的顶点不参与最小权值的查找。</p></li><li><p>第 22 行，因 k &#x3D; 1，adjvex[1] &#x3D; 0，所以打印结果为 (0, 1)，表示 v<sub>0</sub> 至 v<sub>1</sub> 边为最小生成树的第一条边。如下图</p><p> <img src="/../img/dsa/Prim-2.png" alt="Prim-2"></p></li><li><p>第 23 行，此时因 k &#x3D; 1 将 lowcost[k] &#x3D; 0 就是说顶点 v<sub>1</sub> 纳入到最小生成树中。此时 lowcost 数组值为 {0, 0, 65535, 65535, 65535, 11, 65535, 65535, 65535}。</p></li><li><p>第 24～30 行，j 循环由 1 至 8，因 k &#x3D; 1，查找邻接矩阵的第 v<sub>1</sub> 行的各个权值，与 lowcost 的对应值比较，若更小则修改 lowcost 值，并将 k 值存入 adjvex 数组中。因第 v<sub>1</sub> 行有 18、16、12 均比 65535 小，所以最终 lowcost 数组的值为：{0, 0, 18, 65535, 65535, 11, 16, 655365, 12}。adjvex 数组的值为：{0, 0, 1, 0, 0, 0, 1, 0, 1}。这里第 25 行 if 判断的 lowcost[j] !&#x3D; 0 也说明 v<sub>0</sub> 和 v<sub>1</sub> 已经是生成树的顶点不参与最小权值的比对了。</p></li><li><p>再次循环，由第 13～22 行，此时 min &#x3D; 11，k &#x3D; 5，adjvex[5] &#x3D; 0。因此打印结构为 (0, 5)。表示 v<sub>0</sub> 至 v<sub>5</sub> 边为最小生成树的第二条边，如下图所示。</p><p><img src="/../img/dsa/Prim-3.png" alt="Prim-3"></p></li><li><p>接下来执行到 31 行，lowcost 数组的值为：{0, 0, 18, 65535, 26, 0, 16, 65535, 12}。adjvex 数组的值为：{0, 0, 1, 0, 5, 0, 1, 0, 1}。</p></li><li><p>之后，通过不断的转换，构造的过程如下图所示。</p><p><img src="/../img/dsa/Prim-4.png" alt="Prim-4"></p></li></ol><p>普里姆 (Prim) 算法定义：假设 N &#x3D; (P, {E}) 是连通网，TE 是 N 上最小生成树中边的集合。算法从 U &#x3D; {u<sub>0</sub>} (u<sub>0</sub> ∈ V)，TE &#x3D; {} 开始。重复执行下述操作。在所有 u ∈ U，v ∈ V - U 的边(u, v) ∈ E 中找一条代价最小的边(u<sub>0</sub>, v<sub>0</sub>) 并入集合 TE，同时 v<sub>0</sub> 并入 U，直至 U &#x3D; V 为止。此时 TE 中必有 n - 1 条边，则 T &#x3D; (V, {TE}) 为 N 的最小生成树。</p><p>由算法代码中的循环嵌套可得知此算法的时间复杂度为 O(n<sup>2</sup>)。</p><h4 id="克鲁斯卡尔-Kruskal-算法"><a href="#克鲁斯卡尔-Kruskal-算法" class="headerlink" title="克鲁斯卡尔 (Kruskal) 算法"></a>克鲁斯卡尔 (Kruskal) 算法</h4><p>直接以边为目标去构建，因为权值是在边上，直接去找最小权值的边来构建生成树也是很自然的想法，只不过构建时要考虑是否会形成环流而已。此时就用到了图的存储结构中的边集数组结构。以下是 edge 边集数组结构的定义代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对边集数组 Edge 结构的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> begin;</span><br><span class="line">  <span class="type">int</span> end;</span><br><span class="line">  <span class="type">int</span> weight;</span><br><span class="line">&#125;Edge;</span><br></pre></td></tr></table></figure><p><img src="/../img/dsa/Kruskal-1.png" alt="Kruskal-1"></p><p>将在普里姆算法构建的邻接矩阵通过程序转化为上图的右图的边集数组，并且对它们安全值从小到大排序。</p><p>克鲁斯卡尔算法代码如下。其中 MAXEDGE 为边数量的极大值，此处大于等于 15 即可，MAXVEX 为顶点个数最大值，此处大于等于 9 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kruskal 算法生成最小生成树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MiniSpanTree_Kruskal</span><span class="params">(MGraph G)</span> &#123;<span class="comment">// 生成最小生成树</span></span><br><span class="line">  <span class="type">int</span> i, n, m;</span><br><span class="line">  Edge edges[MAXEDGE];<span class="comment">// 定义边集数组</span></span><br><span class="line">  <span class="type">int</span> parent[MAXVEX];<span class="comment">// 定义一数组用来判断边与边是否形成环路</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++) </span><br><span class="line">    parent[i] = <span class="number">0</span>;<span class="comment">// 初始化数组值为 0</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++) &#123;<span class="comment">// 循环每一条边</span></span><br><span class="line">    n = Find(parent, edges[i].begin);</span><br><span class="line">    m = Find(parent, edges[i].end);</span><br><span class="line">    <span class="keyword">if</span>(n != m) &#123;<span class="comment">// 假如 n 与 m 不等，说明此边没有与现有生成树形成环路</span></span><br><span class="line">      parent[n] = m;<span class="comment">// 将此边的结尾顶点放入下标为起点的 parent 中，表示此顶点已经在生成树集合中</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d) %d&quot;</span>, edges[i].begin, edges[i].end, edges[i].weight);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> *parent, <span class="type">int</span> f)</span> &#123;<span class="comment">// 查找连线顶点的尾部下标</span></span><br><span class="line">  <span class="keyword">while</span>(parent[f] &gt; <span class="number">0</span>)</span><br><span class="line">    f = parent[f];</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>程序开始运行，第 5 行之后，省略掉颇占篇幅但却很容易实现的将邻接矩阵转换为边集数组，并按权值从小到大排序的代码，也就是说，从第 5 行开始，已经有了结构为 edge，数据内容是上图有边的一维数组 edges。</p></li><li><p>第 5～7 行，生命一个数组 parent，并将它的值都初始化为 0。</p></li><li><p>第 8～15 行，开始对边集数组做循环遍历，开始时，i &#x3D; 0。</p></li><li><p>第 9 行，调用了第 17～21 行的函数 Find，传入的参数是数组 parent 和当前权值最小边 (v<sub>4</sub>, v<sub>7</sub>) 的 begin：4。因为 parent 中全都是 0 所以传出值使得 n &#x3D; 4。</p></li><li><p>第 10 行，传入 (v<sub>4</sub>, v<sub>7</sub>) 的 end：7。传出值使得 m &#x3D; 7。</p></li><li><p>第 11～14 行，很显然 n 与 m 不等，因此 parent[4] &#x3D; 7。此时 parent 数组值为 {0, 0, 0, 0, 7, 0, 0, 0, 0}，并且打印得到 “(4, 7) 7”。此时已经将边  (v<sub>4</sub>, v<sub>7</sub>) 纳入到最小生成树中。如下图。</p><p> <img src="/../img/dsa/Kruskal-2.png" alt="Kruskal-2"></p></li><li><p>循环返回，执行 9～14 行，此时 i &#x3D; 1，edge[1] 得到边 (v<sub>2</sub>, v<sub>8</sub>)，n &#x3D; 2，m &#x3D; 8，parent[2] &#x3D; 8，打印结果为 “(2, 8) 8”，此时 parent 数组值为 {0, 0, 8, 0, 7, 0, 0, 0, 0}，这也就表示边 (v<sub>4</sub>, v<sub>7</sub>) 和 边 (v<sub>2</sub>, v<sub>8</sub>) 已经纳入到最小生成树。如下图。</p><p> <img src="/../img/dsa/Kruskal-3.png" alt="Kruskal-3"></p></li><li><p>再次执行 9～14 行，此时 i &#x3D; 2，edge[2] 得到边 (v<sub>0</sub>, v<sub>1</sub>)，n &#x3D; 0，m &#x3D; 1，parent[0] &#x3D; 1，打印结果为 “(0, 1) 10”，此时 parent 数组值为 {1, 0, 8, 0, 7, 0, 0, 0, 0}，此时边 (v<sub>4</sub>, v<sub>7</sub>)、(v<sub>2</sub>, v<sub>8</sub>) 和 (v<sub>0</sub>, v<sub>1</sub>) 已经纳入到最小生成树，如图。</p><p> <img src="/../img/dsa/Kruskal-4.png" alt="Kruskal-4"></p></li><li><p>当 i &#x3D; 3、4、5、6 时，分别将边 (v<sub>0</sub>, v<sub>5</sub>)、(v<sub>1</sub>, v<sub>8</sub>)、(v<sub>3</sub>, v<sub>7</sub>) 和 (v<sub>1</sub>, v<sub>6</sub>) 纳入到最小生成树中。</p><p> <img src="/../img/dsa/Kruskal-5.png" alt="Kruskal-5"></p><p> 从上图的最右图 i &#x3D; 6 的粗线连线可以得到，其实是有两个连通的边集合 A 与 B 中纳入到最小生成树中的。如下图所示。当 parent[0] &#x3D; 1，表示 v<sub>0</sub> 和 v<sub>1</sub> 已经在生成树的边集合 A 中。此时将 parent[0] &#x3D; 1 的 1 改为下标，由 parent[1] &#x3D; 5, 表示 v<sub>1</sub> 和 v<sub>5</sub> 在边集合 A 中，parent[5] &#x3D; 8 表示 v<sub>5</sub> 与 v<sub>8</sub> 在边集合 A 中，parent[8] &#x3D; 6 表示 v<sub>8</sub> 与v<sub>6</sub> 在边集合 A 中，parent[6] &#x3D; 0 表示集合 A 暂时到头，此时边集合 A 有 v<sub>0</sub>、v<sub>1</sub>、v<sub>5</sub>、v<sub>8</sub>、v<sub>6</sub>。查看 parent 中没有查看的值，parent[2] &#x3D; 8 表示 v<sub>2</sub> 与v<sub>8</sub> 在一个集合中，因此 v<sub>2</sub> 也在边集合 A 中。再由 parent[3] &#x3D; 7、parent[4] &#x3D; 7 和 parent[7] &#x3D; 0 可知 v<sub>3</sub>、v<sub>4</sub>、v<sub>7</sub> 在另一个边集合 B 中。</p><p> <img src="/../img/dsa/Kruskal-6.png" alt="Kruskal-6"></p></li><li><p>当 i &#x3D; 7 时，第 10 行，调用 Find 函数，会传入参数 edges[7].begin &#x3D; 5。此时第 18 行，parent[5] &#x3D; 8 &gt; 0，所以 f &#x3D; 8，再循环得 parent[8] &#x3D; 6。因 parent[6] &#x3D; 0 所以 Find 返回后第 10 行得到 n &#x3D; 6.而此时第 11 行，传入参数 edges[7].end &#x3D; 6 得到 m &#x3D; 6。此时 n &#x3D; m，不再打印，继续下一循环。这就告诉我们，因为边 (v<sub>5</sub>, v<sub>6</sub>) 使得边集合 A 形成了环路。因此不能将它纳入到最小生成树中，如上图所示。</p></li><li><p>当 i &#x3D; 8 时，与上面相同，由于边 (v<sub>1</sub>, v<sub>2</sub>) 使得边集合 A 形成了环路。因此不能将它纳入到最小生成树中。</p></li><li><p>当 i &#x3D; 9 时，边 (v<sub>6</sub>, v<sub>7</sub>)，第 10 行得到 n &#x3D; 6，第 11 行得到 m &#x3D; 7，因此 parent[6] &#x3D; 7，打印 “(6, 7) 19”。此时 parent 数组值为 {1, 5, 8, 7, 7, 8, 7, 0, 6}，如下图。</p><p> <img src="/../img/dsa/Kruskal-7.png" alt="Kruskal-7"></p></li><li><p>此后边的循环均造成环路，最终最小生成树即为上图。</p></li></ol><p>克鲁斯卡尔 (Kruskal) 算法的定义：假设 N &#x3D; (V, {E}) 是连通图，则令最小生成树的初始状态为只有 n 个顶点而无边的非连通图 T &#x3D; {V, {}}，图中每个顶点自成一个连通分量。在 E 中选择代价最小的边，若该边依附的顶点落在 T 中不同的连通分量上，则将此边加入到 T 中，否则舍去此边而选择下一条代价最小的边。以此类推，直至 T 中所有顶点都在同一连通分量上为止。</p><p>此算法的 Find 函数由边数 e 决定，时间复杂度为 O(loge)，而外面有一个 for 循环 e 次。所以克鲁斯卡尔算法的时间复杂度为 O(eloge)。</p><p>对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以对于稀疏图有很大优势；而普里姆算法对于稠密图，即边数非常多的情况会更好一些。</p><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>在网图和非网图中，最短路径的含义是不同的。由于非网图它没有边上的权值，所谓的最短路径，其实就是指两顶点之间经过的边数最少的路径；而<strong>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点</strong>。显然，研究网图更有实际意义，就地图来说，距离就是两顶点间的权值之和。而非网图完全可以理解为所有的边的权值都为 1 的网。</p><h4 id="迪杰斯特拉-Dijkstra-算法"><a href="#迪杰斯特拉-Dijkstra-算法" class="headerlink" title="迪杰斯特拉 (Dijkstra) 算法"></a>迪杰斯特拉 (Dijkstra) 算法</h4><p>这是一个按路径长度递增的次序产生最短路径的算法。它的思路大体是这样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVEX 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 65535</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Pathmatirx[MAXVEX];<span class="comment">// 用于存储最短路径下标的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ShortPathTable[MAXVEX];<span class="comment">// 用于存储到各点最短路径的权值和</span></span><br><span class="line"><span class="comment">// Dijkstra 算法，求有向网 G 的 v0 顶点到其余顶点 v 最短路径 P[v] 及带权长度 D[v], P[v] 的值为前驱顶点下标，D[v] 表示 v0 到 v 的最短路径长度和。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath_Dijkstra</span><span class="params">(MGraph G, <span class="type">int</span> v0, Pathmatirx *P, ShortPathTable *D)</span> &#123;</span><br><span class="line">  <span class="type">int</span> v, w, k, min;</span><br><span class="line">  <span class="type">int</span> final[MAXVEX];<span class="comment">// final[w] = 1 表示求得顶点 v0 至 vw 的最短路径</span></span><br><span class="line">  <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.numVertexes; v++) &#123;<span class="comment">// 初始化数据</span></span><br><span class="line">    final[v] = <span class="number">0</span>;<span class="comment">// 全部顶点初始化为未知最短路径状态</span></span><br><span class="line">    (*D)[v] = G.matirx[v0][v];<span class="comment">// 将与 v0 点有连线的顶点加上权值</span></span><br><span class="line">    (*P)[v] = <span class="number">0</span>;<span class="comment">// 初始化路径数组 p 为 0</span></span><br><span class="line">  &#125;</span><br><span class="line">  (*D)[v0] = <span class="number">0</span>;<span class="comment">// v0 至 v0 路径为 0</span></span><br><span class="line">  final[v0] = <span class="number">1</span>;<span class="comment">// v0 至 v0 不需要求路径</span></span><br><span class="line">  <span class="comment">// 开始主循环，每次求得 v0 到某个 v 顶点的最短路径</span></span><br><span class="line">  <span class="keyword">for</span>(v = <span class="number">1</span>; v &lt; G.numVertexes; v++) &#123;</span><br><span class="line">    min = INFINITY;<span class="comment">// 当前所知离 v0 顶点的最近距离</span></span><br><span class="line">    <span class="keyword">for</span>(w = <span class="number">0</span>;w &lt; G.numVertexes; w++) &#123;<span class="comment">// 寻找离 v0 最近的顶点</span></span><br><span class="line">      <span class="keyword">if</span>(!final[w] &amp;&amp; (*D)[w] &lt; min) &#123;</span><br><span class="line">        k = w;</span><br><span class="line">        min = (*D)[w];<span class="comment">// w 顶点离 v0 顶点更近</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    final[k] = <span class="number">1</span>;<span class="comment">// 将目前找到的最近的顶点位置为 1</span></span><br><span class="line">    <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.numVertexes; w++) &#123;<span class="comment">// 修正当前最短路径及距离</span></span><br><span class="line">      <span class="comment">// 如果经过 v 顶点的路径比现在这条路径的长度短的话</span></span><br><span class="line">      <span class="keyword">if</span>(!final[w] &amp;&amp; (min + G.matirx[k][w] &lt; (*D)[w])) &#123;</span><br><span class="line">        <span class="comment">// 说明找到了更短的路径，修改 D[w] 和 P[w]</span></span><br><span class="line">        (*D)[w] = min + G.matirx[k][w];<span class="comment">// 修改当前路径长度</span></span><br><span class="line">        (*P)[w] = k;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用此函数前，需要为下图中的左图准备邻接矩阵 MGraph 的 G，如右图，并且定义参数 v<sub>0</sub> 为 0。</p><p><img src="/../img/dsa/Dijkstra-1.png" alt="Dijkstra"></p><ol><li><p>程序开始运行，第 4 行final 数组是为了 v<sub>0</sub> 到某顶点是否已经求得最短路径的标记，如果 v<sub>0</sub> 到 v<sub>w</sub> 已经有结果，则 final[w] &#x3D; 1。</p></li><li><p>第 9～13 行，是在对数据进行初始化的工作。此时 final 数组值均为 0，表示所有的点都未求得最短路径。D 数组为 {65535, 1, 5, 65535, 65535, 65535, 65535, 65535, 65535}。因为 v<sub>0</sub> 到 v<sub>1</sub> 和 v<sub>2</sub> 的边权值为 1 和 5。P 数组全为0，表示目前没有路径。</p></li><li><p>第 14 行，表示 v<sub>0</sub> 到 v<sub>0</sub> 自身，权值和结果为 0。D 数组为 {0, 1, 5, 65535, 65535, 65535, 65535, 65535, 65535}。第 15 行，表示 v<sub>0</sub> 点算是已经求得最短路径，因此 final[0] &#x3D; 1。此时 final 数组为 {1, 0, 0, 0, 0, 0, 0, 0, 0}。此时整个初始化工作完成。</p></li><li><p>第 17～35 行，为主循环，每次循环求得 v<sub>0</sub> 与一个顶点的最短路径。因此 v 从 1 而不是 0 开始。</p></li><li><p>第 18～24 行，先令 min 为 65535 的极大值，通过 w 循环，与 D[w] 比较找到最小值 min &#x3D; 1, k &#x3D; 1。</p></li><li><p>第 25 行，由 k &#x3D; 1，表示与 v<sub>0</sub> 最近的顶点是 v<sub>1</sub>，并且由 D[1] &#x3D; 1，知道此时 v<sub>0</sub> 到 v<sub>1</sub> 的最短距离是 1。因此将 v<sub>1</sub> 对应的 final[1] 设置为 1。此时 final 数组为 {1, 1, 0, 0, 0, 0, 0, 0, 0}。</p></li><li><p>第 26～34 行是一循环，此循环甚为关键。它的目的是在刚才已经找到 v<sub>0</sub> 与 v<sub>1</sub> 的最短路径的基础上，对 v<sub>1</sub> 与其他顶点的边进行计算，得到 v<sub>0</sub> 与它们的当前最短距离，如下图。因为 min &#x3D; 1，所以本来 D[2] &#x3D; 5，现在 v<sub>0</sub> → v<sub>1</sub> → v<sub>2</sub> &#x3D; D[2] &#x3D; min + 3 &#x3D; 4，v<sub>0</sub> → v<sub>1</sub> → v<sub>3</sub> &#x3D; D[3] &#x3D; min + 7 &#x3D; 8，v<sub>0</sub> → v<sub>1</sub> → v<sub>4</sub> &#x3D; D[4] &#x3D; min + 5 &#x3D; 6，因此，D 数组当前值为 {0, 1, 4, 8, 6, 65535, 65535, 65535, 65535}。而 P[2] &#x3D; 1，P[3] &#x3D; 1，P[4] &#x3D; 1，它表示的意思是 v<sub>0</sub> 到 v<sub>2</sub>、v<sub>3</sub>、v<sub>4</sub> 点的最短路径它们的前驱均是 v<sub>1</sub>。此时 P 数组值为：{0, 0, 1, 1, 1, 0, 0, 0, 0}。</p><p> <img src="/../img/dsa/Dijkstra-2.png" alt="Dijkstra-2"></p></li><li><p>重新开始循环，此时 i &#x3D; 2。第 18～24 行，对 w 循环，注意因为 final[0] &#x3D; 1 和final[1] &#x3D; 1，由第 20 行的 !final[w] 可知，v<sub>0</sub> 与 v<sub>1</sub> 并不参与最小值的获取。通过循环比较，找到最小值 min &#x3D; 4，k &#x3D; 2。</p></li><li><p>第 25 行，由 k &#x3D; 2，表示已经求出 v<sub>0</sub> 与 v<sub>2</sub> 的最短路径，并且由 D[2] &#x3D; 4，知道最短距离是 4。因此将 v<sub>2</sub> 对应的 final[2] 设置为 1，此时 final 数组为：{1, 1, 1, 0, 0, 0, 0, 0, 0}。</p></li><li><p>第 26～34 行。在刚才已经找到 v<sub>0</sub> 与 v<sub>2</sub> 的最短路径的基础上，对 v<sub>2</sub> 与其它顶点的边，进行计算，得到 v<sub>0</sub> 与它们的当前最短距离，如下图。因为 min &#x3D; 4，所以本来 D[4] &#x3D; 6，现在 v<sub>0</sub> → v<sub>2</sub> → v<sub>4</sub> &#x3D; D[4] &#x3D; min + 1 &#x3D; 5，v<sub>0</sub> → v<sub>2</sub> → v<sub>5</sub> &#x3D; D[5] &#x3D; min + 7 &#x3D; 11，因此，D 数组当前值为：{0, 1, 3, 8, 5, 11, 65535, 65535, 65535}。而原本 P[4] &#x3D; 1，此时 P[4] &#x3D; 2，P[5] &#x3D; 2，它表示 v<sub>0</sub> 到 v<sub>4</sub>、v<sub>5</sub> 点的最短路径它们的前驱均是 v<sub>2</sub>。此时 P 数组值为：{0, 0, 1, 1, 2, 2, 0, 0, 0}。</p><p><img src="/../img/dsa/Dijkstra-3.png" alt="Dijkstra"></p></li><li><p>重新开始循环，此时 i &#x3D; 3。第 18～24 行，通过对 w 循环比较找到最小值 min &#x3D; 5， k &#x3D; 4。</p></li><li><p>第 25 行，由 k &#x3D; 4，表示已经求出 v<sub>0</sub> 到 v<sub>4</sub> 的最短路径，并且由 D[4] &#x3D; 5，知道最短距离是 5。因此将 v<sub>4</sub> 对应的 final[4] 设置为 1。此时 final 数组为：{1, 1, 1, 0, 1, 0, 0, 0, 0}。</p></li><li><p>第 26～24 行。对 v<sub>4</sub> 与其他顶点的边进行计算，得到 v<sub>0</sub> 与它们的当前最短距离，如下图所示。因为 min &#x3D; 5，所以本来 D[3] &#x3D; 8，现在 v<sub>0</sub> → v<sub>4</sub> → v<sub>3</sub> &#x3D; D[3] &#x3D; min + 2 &#x3D; 7，本来 D[5] &#x3D; 11，现在 v<sub>0</sub> → v<sub>4</sub> → v<sub>5</sub> &#x3D; D[5] &#x3D; min + 3 &#x3D; 8，另外 v<sub>0</sub> → v<sub>4</sub> → v<sub>6</sub> &#x3D; D[6] &#x3D; min + 6 &#x3D; 11，v<sub>0</sub> → v<sub>4</sub> → v<sub>7</sub> &#x3D; D[7] &#x3D; min + 9 &#x3D; 14，因此，D 数组当前值为：{0, 1, 4, 7, 5, 8, 11, 14, 65535}。而原本 P[3] &#x3D; 1，此时 P[3] &#x3D; 4，原本 P[5] &#x3D; 2，此时 P[5] &#x3D;  4，另外 P[6] &#x3D; 4，P[7] &#x3D; 4，它表示 v<sub>0</sub> 到 v<sub>3</sub>、v<sub>5</sub>、v<sub>6</sub>、v<sub>7</sub> 点的最短路径它们的前驱均是 v<sub>4</sub>。此时 P 数组值为：{0, 0, 1, 4, 2, 4, 4, 4, 0}。</p><p> <img src="/../img/dsa/Dijkstra-4.png" alt="Dijkstra"></p></li><li><p>之后的循环就完全类似了。得到最终的结果，如下图。此时 final 数组为：{1, 1, 1, 1, 1, 1, 1, 1, 1}，它表示所有的顶点均完成了最短路径的查找工作。此时D数组为：{0, 1, 4, 7, 5, 8, 10, 12, 16}，它表示 v<sub>0</sub> 到各个顶点的最短路径数，比如 D[8]-1+3+1+2+3+2+4 &#x3D; 16。此时的 P 数组为：{0, 0, 1, 4, 2, 4, 3, 6, 7}，这串数字可能略为难理解一些。比如 P[8] &#x3D; 7，它的意思是 v<sub>0</sub> 到 v<sub>8</sub> 的最短路径，顶点 v<sub>8</sub> 的前驱顶点是 v<sub>7</sub>，再由 P[7] &#x3D; 6 表示 v<sub>7</sub> 的前驱是 v<sub>6</sub>， P[6] &#x3D; 3，表示 v<sub>6</sub> 的前驱是 v<sub>3</sub>。这样就可以得到，v<sub>0</sub>到 v<sub>8</sub> 的最短路径为v<sub>8</sub> ← v<sub>7</sub> ← v<sub>6</sub> ← v<sub>3</sub> ← v<sub>4</sub> ← v<sub>2</sub> ← v<sub>1</sub> ← v<sub>0</sub>。</p><p> <img src="/../img/dsa/Dijkstra-5.png" alt="Dijkstra"></p></li></ol><p>其实最终返回的数组 D 和数组 P，是可以得到 v<sub>0</sub> 到任意一个顶点的最短路径和路径长度的。例如 v<sub>0</sub> 到 v<sub>8</sub> 的最短路径并没有经过 v<sub>5</sub>，但我们已经知道 v<sub>0</sub> 到 v<sub>5</sub> 的最短路径了。由 D[5] &#x3D; 8 可知它的路径长度为 8，由P[5] &#x3D; 4 可知 v<sub>5</sub> 的前驱顶点是 v<sub>4</sub>，所以 v<sub>0</sub> 到 v<sub>5</sub> 的最短路径是 v<sub>0</sub> → v<sub>1</sub> → v<sub>2</sub> → v<sub>4</sub> → v<sub>5</sub>。</p><p>也就是说，我们通过迪杰斯特拉（Dijkstra）算法解决了从某个源点到其余各顶点的最短路径问题。从循环嵌套可以很容易得到此算法的时间复杂度为 0(n<sup>2</sup>)，尽管有同学觉得，可不可以只找到从源点到某一个特定终点的最短路径，其实这个问题和求源点到其他所有顶点的最短路径一样复杂，时间复杂度依然是 0(n<sup>2</sup>)。</p><h4 id="佛洛依德-Floyd-算法"><a href="#佛洛依德-Floyd-算法" class="headerlink" title="佛洛依德 (Floyd) 算法"></a>佛洛依德 (Floyd) 算法</h4><p><img src="/../img/dsa/Floyd-1.png" alt="Floyd"></p><p>上图是一个最简单的 3 个顶点连通网图。先定义两个二维数组 D[3][3] 和 P[3][3]，D 代表顶点到顶点的最短路径权值和的矩阵。P 代表 对应顶点的最小路径的前驱矩阵。在未分析任何顶点之前，将 D 命名为 D<sup>-1</sup>，其实他就是初始的图的邻接矩阵。将 P 命名为 P<sup>-1</sup>，初始化为图中所示的矩阵。</p><p>首先，所有的顶点经过 v<sub>0</sub> 后到达另一顶点的最短路径。因为只有三个顶点，因此需要查看 v<sub>1</sub> → v<sub>0</sub> → v<sub>2</sub>， 得到 D<sup>-1</sup>[1][0] + D<sup>-1</sup>[0][2] &#x3D; 2 + 1 &#x3D; 3。D<sup>-1</sup>[1][2] 表示的是 v<sub>1</sub> → v<sub>2</sub> 的权值为 5，发现 D<sup>-1</sup>[1][2] &gt; D<sup>-1</sup>[1][0] + D<sup>-1</sup>[0][2]，通俗的话讲就是 v<sub>1</sub> → v<sub>0</sub> → v<sub>2</sub> 比直接 v<sub>1</sub> → v<sub>2</sub> 距离还要近。所以让 D-1[1][2] &#x3D; D<sup>-1</sup>[1][0] + D<sup>-1</sup>[0][2] &#x3D; 3，同样的 D<sup>-1</sup>[2][1] &#x3D; 3，于是就有了 D<sup>0</sup> 的矩阵。因为有变化，所以 P 矩阵对应的 P<sup>-1</sup>[1][2] 和 P<sup>-1</sup>[2][1] 也修改为当前中转的顶点 v<sub>0</sub> 的下标 0，于是就有了 P<sup>0</sup>。也就是说 D<sup>0</sup>[v][w] &#x3D; min{D<sup>-1</sup>[v][w], D<sup>-1</sup>[v][0] + D<sup>-1</sup>[0][w]}。</p><p>接下来，其实也就是在 D<sup>0</sup> 和 P<sup>0</sup> 的基础上继续处理所有顶点经过 v<sub>1</sub> 和 v<sub>2</sub> 后到达另一顶点的最短路径，得到 D<sup>1</sup> 和 P<sup>1</sup>，D<sup>2</sup> 和 P<sup>2</sup> 完成所有顶点到所有顶点的最短路径计算工作。</p><p><img src="/../img/dsa/Floyd-2.png" alt="Floyd"></p><p>首先针对上图的做网图准备两个矩阵 D<sup>-1</sup> 和 P<sup>-1</sup> ，D<sup>-1</sup> 就是网图的邻接矩阵，P<sup>-1</sup> 初设为 P[i][j] &#x3D; j 这样的矩阵，它主要用来存储路径。</p><p>求所有顶点到所有顶点的最短路径代码如下，Pathmatirx 和 ShortPathTable 都是二维数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Pathmatirx[MAXVEX][MAXVEX];</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ShortPathTable[MAXVEX][MAXVEX];</span><br><span class="line"><span class="comment">// Floyd 算法，求网图 G 中个顶点 v 到其余顶点 w 最短路径 P[v][w] 及带权长度 D[v][w]</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath_Floyd</span><span class="params">(MGraph G, Pathmatirx *P, ShortPathTable *D)</span> &#123;</span><br><span class="line">  <span class="type">int</span> v, w, k;</span><br><span class="line">  <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.numVertexes; ++v) &#123;</span><br><span class="line">    <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.numVertexes; ++w) &#123;</span><br><span class="line">      (*D)[v][w] = G.matirx[v][w];<span class="comment">// (*D)[v][w] 值即为对应点间的权值</span></span><br><span class="line">      (*P)[v][w] = w;<span class="comment">// 初始化 P</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.numVertexes; ++k) &#123;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.numVertexes; ++v) &#123;</span><br><span class="line">      <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.numVertexes; ++w) &#123;</span><br><span class="line">        <span class="keyword">if</span>((*D)[v][w] &gt; (*D)[v][k] + (*D)[k][w]) &#123;</span><br><span class="line">          <span class="comment">// 如果经过下标为 k 顶点路径比原来两点间路径更短，将当前两点间权值设为更小的一个</span></span><br><span class="line">          (*D)[v][w] &gt; (*D)[v][k] + (*D)[k][w];</span><br><span class="line">          (*P)[v][w] &gt; (*P)[v][k];<span class="comment">// 路径设置经过下标为 k 的顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>程序开始运行，第 6～11 行就是初始化了 D 和 P，使得它们称为上图的两个矩阵。从矩阵也得到，v<sub>0</sub> → v<sub>1</sub> 路径权值是 1，v<sub>0</sub> → v<sub>2</sub> 路径权值是 5，v<sub>0</sub> → v<sub>3</sub> 无边连线，所以路径权值为极大值 65535。</p></li><li><p>第 12～22 行，是算法的主循环，一共三层嵌套，k 代表的就是中转顶点的下标。v 代表起始顶点，w 代表结束顶点。</p></li><li><p>当 K &#x3D; 0 时，也就是所有的顶点都经过 v<sub>0</sub> 中转，计算是否有最短路径的变化。可惜结果是，没有任何变化，如下图。</p><p> <img src="/../img/dsa/Floyd-3.png" alt="Floyd"></p></li><li><p>当 K &#x3D; 1 时，也就是所有的顶点都经过 v<sub>1</sub> 中转。此时，当 v &#x3D; 0 时，原本D[0][2] &#x3D; 5，现在由于 D[0][1] + D[1][2] &#x3D; 4。因此由第 17 行代码，二者取其最小值，得到 D[0][2] &#x3D; 4，同理可得 D[0]p3] &#x3D; 8、D[0][4] &#x3D; 6，当 v &#x3D; 2、3、4 时，也修改了一些数据，如下左图虚线框数据。由于这些最小权值的修正，所以在路径矩阵 P 上，也要做处理，将它们都改为当前的 P[v][k] 值，如代码的 18 行。</p><p> <img src="/../img/dsa/Floyd-4.png" alt="Floyd"></p></li><li><p>接下来就是 k &#x3D; 2 一直到 8 结束，表示针对每个顶点做中转得到的计算结果，当然，D<sup>0</sup> 是以 D<sup>1</sup> 为基础，D<sup>1</sup> 是以 D<sup>0</sup> 为基础，……，D<sup>8</sup> 是以 D<sup>7</sup> 为基础。最终当 k &#x3D; 8 时，两矩阵数据如下图所示。</p><p> <img src="/../img/dsa/Floyd-5.png" alt="Floyd"></p></li></ol><p>​至此，最短路就算是完成了，可以看到矩阵第 v<sub>0</sub> 行的数值与迪杰斯特拉 (Dijkstra) 算法求得的 D 数组的数值是完全相同，都是 {0, 1, 4, 7, 5, 8, 10, 12, 16}。而且这里是所有顶点到所有顶点的最短路径权值和都可以计算出。</p><p>如何由 P 这个路径数组的出具体的最短路径？以 v<sub>0</sub> 到 v<sub>8</sub> 为例，从上图的右图第 v<sub>8</sub> 列，P[0][8] &#x3D; 1，得到要经过顶点 v<sub>1</sub>，然后将 1 取代 0 得到 P[1][8] &#x3D; 2，说明要经过 v<sub>2</sub>，然后将 2 取代 1 得到 P[2][8] &#x3D; 4，说明要经过 v<sub>4</sub>，然后将 4 取代 2 得到 P[4][8] &#x3D; 3，说明要经过 v<sub>3</sub>，……，这样很容易就推导出最终的最短路径值为 v<sub>0</sub> → v<sub>1</sub> → v<sub>2</sub> → v<sub>4</sub> → v<sub>3</sub> → v<sub>6</sub> → v<sub>7</sub> → v<sub>8</sub>。</p><p>求最短路径的显示代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(v = <span class="number">0</span>;v &lt; G.numVertexes; ++v) &#123;</span><br><span class="line">  <span class="keyword">for</span>(w = v + <span class="number">1</span>; w &lt; G.numVertexes; w++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;v%d-v%d weight: %d &quot;</span>, v, w, D[v][w]);</span><br><span class="line">    k = P[v][w];<span class="comment">// 获得第一个路径顶点下标</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; path: %d&quot;</span>, v);<span class="comment">// 打印源点</span></span><br><span class="line">    <span class="keyword">while</span>(k != w) &#123;<span class="comment">// 如果路径顶点下标不是终点</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot; -&gt; %d&quot;</span>, k);<span class="comment">// 打印路径顶点</span></span><br><span class="line">      k = P[k][w];<span class="comment">// 获得下一个路径顶点下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; -&gt; %d\n&quot;</span>, w);<span class="comment">// 打印终点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果面临需要求所有顶点致所有顶点的最短路径问题时，弗洛伊德 (Floyd) 算法应该是不错的选择。</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><h4 id="拓扑排序介绍"><a href="#拓扑排序介绍" class="headerlink" title="拓扑排序介绍"></a>拓扑排序介绍</h4><p>**在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为 AOV 网 (Activity On Vertex Network)**。AOV 网中的弧表示活动之间存在的某种制约关系。另外就是 AOV 网中不能存在回路。</p><p><strong>设 G &#x3D; (V, E) 是一个具有 n 个顶点的有向图，V 中的顶点序列 v<sub>1</sub>，v<sub>2</sub>，……，v<sub>n</sub>，满足若从顶点 v<sub>i</sub> 到 v<sub>j</sub> 有一条路径，则在顶点序列中顶点 v<sub>i</sub> 必在顶点 v<sub>j</sub> 之前。则称这样的顶点序列为一个拓扑序列</strong>。</p><p>所谓<strong>拓扑排序，其实就是对一个有向图构造拓扑序列的过程</strong>。构造时会有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环 (回路) 的 AOV 网；如果输出顶点数少了，哪怕是少了一个，也说明这个网存在环 (回路)，不是 AOV 网。</p><p>一个不存在回路的 AOV 网，可以将它应用在各种各样的工程或项目的流程图中，满足各种应用场景的需要，所以实现拓扑排序的算法就很有价值了。</p><h4 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h4><p>对 AOV 网进行拓扑排序的基本思路是：从 AOV 网中选择一个入度为。的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者 AOV 网中不存在入度为 0 的顶点为止。</p><p>首先我们需要确定一下这个图需要使用的数据结构。前面求最小生成树和最短路径时，我们用的都是邻接矩阵，但由于拓扑排序的过程中，需要删除顶点，显然用邻接表会更加方便。因此我们需要为 A0V 网建立一个邻接表。考虑到算法过程中始终要查找入度为 0 的顶点，我们在原来顶点表结点结构中，增加一个入度域 in，结构如下表所示，其中 in 就是入度的数字。</p><table><thead><tr><th align="center">in</th><th align="center">data</th><th align="center">firstedge</th></tr></thead></table><p><img src="/../img/dsa/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-1.png" alt="拓扑排序"></p><p>因此对于上图的 AOV 网，可以得到下图的邻接表数据结构。</p><p><img src="/../img/dsa/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-2.png" alt="拓扑排序"></p><p>在拓扑排序算法中，涉及的结构代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span><span class="comment">// 边表结点</span></span><br><span class="line">  <span class="type">int</span> adjvex;<span class="comment">// 邻接点域，存储该顶点对应的下标</span></span><br><span class="line">  <span class="type">int</span> weight;<span class="comment">// 用于存储权值，对于非网图可以不需要</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span><span class="comment">// 链域，指向下一个邻接点</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> &#123;</span><span class="comment">// 顶点表结点</span></span><br><span class="line">  <span class="type">int</span> in;<span class="comment">// 顶点入度</span></span><br><span class="line">  <span class="type">int</span> data;<span class="comment">// 顶点域，存储顶点信息</span></span><br><span class="line">  EdgeNode *firstedge;<span class="comment">// 边表头指针</span></span><br><span class="line">&#125;VertexNode, AdjList[MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  AdjList adjList;</span><br><span class="line">  <span class="type">int</span> numVertexes, numEdges;<span class="comment">// 图中当前顶点数和边数</span></span><br><span class="line">&#125;graphAdjList, *GraphAdjList;</span><br></pre></td></tr></table></figure><p>在算法中，还需要辅助的数据结构——栈，用来存储处理过程中入度为 0 的顶点，木的是为了避免每个查找时都要去遍历顶点表找有没有入度为 0 的顶点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序，若 GL 无回路，则输出拓扑排序序列并返回 OK，若有回路返回 ERROR</span></span><br><span class="line">Status <span class="title function_">TopologicalSort</span><span class="params">(GraphAdjList GL)</span> &#123;</span><br><span class="line">  EdgeNode *e;</span><br><span class="line">  <span class="type">int</span> i, k, gettop;</span><br><span class="line">  <span class="type">int</span> top = <span class="number">0</span>;<span class="comment">// 用于栈指针下标</span></span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">// 用于统计输出顶点的个数</span></span><br><span class="line">  <span class="type">int</span> *<span class="built_in">stack</span>;<span class="comment">// 建栈存储入度为 0 的顶点</span></span><br><span class="line">  <span class="built_in">stack</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(GL -&gt; numVertexes * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL -&gt; numVertexes; i++)</span><br><span class="line">    <span class="keyword">if</span>(GL -&gt; adjList[i].in == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">stack</span>[++top] = i;<span class="comment">// 将入度为 0 的顶点入栈</span></span><br><span class="line">  <span class="keyword">while</span>(top != <span class="number">0</span>) &#123;</span><br><span class="line">    gettop = <span class="built_in">stack</span>[top--];<span class="comment">// 出栈</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, GL -&gt; adjList[gettop].data);<span class="comment">// 打印此顶点</span></span><br><span class="line">    count++;<span class="comment">// 统计输出顶点数</span></span><br><span class="line">    <span class="keyword">for</span>(e = GL -&gt; adjList[gettop].firstedge; e; e = e -&gt; next) &#123;<span class="comment">// 对此顶点弧表遍历</span></span><br><span class="line">      k = e -&gt; adjvex;</span><br><span class="line">      <span class="keyword">if</span>(!(--GL -&gt; adjList[k].in))<span class="comment">// 将 k 号顶点邻接点的入度减 1</span></span><br><span class="line">        <span class="built_in">stack</span>[++top] = k;<span class="comment">// 若为 0 则入栈，以便于下次循环输出</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(count &lt; GL -&gt; numVertexes)<span class="comment">// 如果 count 小于顶点数，说明存在环</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>程序开始运行，第 3～7 行都是变量的定义，其中 stack 是一个栈，用来存储整型的数字。</p></li><li><p>第 8～10 行，作了一个循环判断，把入度为 0 的顶点下标都入栈，如下右图邻接表可知，此时 stack 应该为：{0, 1, 3}，即 v<sub>0</sub>、v<sub>1</sub>、v<sub>3</sub> 的顶点入度为 0，如下图。</p><p> <img src="/../img/dsa/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-3.png" alt="拓扑排序"></p></li><li><p>第 12～21 行，while 循环，当栈中有数据元素时，始终循环。</p></li><li><p>第 13～15 行，v<sub>3</sub> 出栈得到 gettop &#x3D; 3。并打印此顶点，然后 count 加 1。</p></li><li><p>第 16～20 行，循环其实是对 v<sub>3</sub> 顶点对应的弧链表进行遍历，即下图中的灰色部分，找到 v<sub>3</sub> 连结的两个顶点 v<sub>2</sub> 和 v<sub>13</sub>，并将它们的入度减少一位，此时 v<sub>2</sub> 和 v<sub>13</sub> 的 in 值都为 1。它的目的是为了将 v<sub>3</sub> 顶点上的弧删除。</p><p> <img src="/../img/dsa/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-4.png" alt="拓扑排序"></p></li><li><p>再次循环，第 12～21 行。此时处理的是顶点 v<sub>1</sub>。经过出栈、打印、count &#x3D; 2 后，我们对 v<sub>1</sub> 到 v<sub>2</sub>、v<sub>4</sub>、v<sub>8</sub> 的弧进行了遍历。并同样减少了它们的入度数，此时， v<sub>2</sub> 入度为 0，于是由第 18～19 行知，v<sub>2</sub> 入栈，如下图所示。试想，如果没有在顶点表中加入 in 这个入度数据域，18 行的判断就必须要是循环，这显然是要消耗时间的，利用空间换取了时间。</p><p> <img src="/../img/dsa/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-5.png" alt="拓扑排序"></p></li><li><p>接下来就是同样的处理方式了。下图展示了 v<sub>2</sub>、v<sub>6</sub>、v<sub>5</sub>、v<sub>8</sub> 的打印删除过程，后面还剩几个顶点都类似。</p><p> <img src="/../img/dsa/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-6.png" alt="拓扑排序">   <img src="/../img/dsa/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-7.png" alt="拓扑排序"></p></li><li><p>最终拓扑排序打印结果为 3 -&gt; 1 -&gt; 2 -&gt; 6-&gt; 0 -&gt; 4 -&gt; 5 -&gt; 8 -&gt; 7 -&gt; 12 -&gt; 9 -&gt; 10 -&gt; 13 -&gt; 11。当然这结果并不是唯一的一种拓扑排序方案。</p></li></ol><p>分析整个算法，对一个具有 n 个顶点 e 条弧的 AOV 网来说，第 8～10 行扫描顶点表，将入度为 0 的顶点入栈的时间复杂度为 O(n)，而之后的 while 循环中，每个顶点进一次栈，出一次栈，入度减 1 的操作共执行了 e 次，所以整个算法的时间复杂度为 O(n + e)。</p><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>**在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，称之为 AOE 网 (Acticity On Edge Network)**。把 AOE 网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点。由于一个工程，总有一个开始，一个结束，所以正常情况下，AOE 网只有一个源点一个汇点。</p><p>AOE 网时表示工程流程的，所以它就具有明显的工程的特性。如有在某顶点所代表的事件发生后，从该顶点出发的各活动才能开始。只有在进入某点的各活动都已结束，该顶点代表的事件才能发生。</p><p>尽管 AOE 网与 AOV 网都是用来对工程建模的，但他们还是有很大的不同，主要体现在 AOV 网是顶点表示活动的网，他只描述活动之际拿的制约关系，而 AOE 网是用边表示活动的网，边上的权值表示活动持续的时间。</p><p><strong>路径上各个活动所持续的时间之河称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动</strong>。</p><h4 id="关键路径算法原理"><a href="#关键路径算法原理" class="headerlink" title="关键路径算法原理"></a>关键路径算法原理</h4><p>定义如下几个参数：</p><ol><li>时间的最早发生时间 etv (earliest time of vertex)：即顶点 v<sub>k</sub> 的最早发生时间。</li><li>时间的最晚发生时间 ltv (latest time of vertex)：即顶点 v<sub>k</sub> 的最晚发生时间。也就是每个顶点对应的事件最晚需要开始的时间，超出此事件将会延误整个工期。</li><li>活动的最早开工时间 ete (earliest time of edge)：即弧 a<sub>k</sub> 的最早发生时间。</li><li>活动的最晚开工时间 lte (latest time of edge)：即弧 a<sub>k</sub> 的最晚发生时间，也就是不推迟工期的最晚开工时间。</li></ol><p>由 1 和 2 可以求得 3 和 4，然后再根据 ete[k] 是否与 lte[k] 相等来判断 a<sub>k</sub> 是否是关键活动。</p><h4 id="关键路径算法"><a href="#关键路径算法" class="headerlink" title="关键路径算法"></a>关键路径算法</h4><p>将下图的 AOE 网转化为邻接表结构，注意与拓扑排序时邻接表结构不同的地方在于，这里弧链表增加了 weight 域，用来存储弧的权值。</p><p><img src="/../img/dsa/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-1.png" alt="关键路径算法"></p><p>求事件的最早发生时间 etv 的过程，就是从头至尾找拓扑序列的过程，因此，在求关键路径之前，需要先调用一次拓扑序列算法的代码来计算 etv 和拓扑序列列表。为此，在程序开始处声明几个全局变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *etv, *ltv;<span class="comment">// 事件最早发生时间和最迟发生时间数组</span></span><br><span class="line"><span class="type">int</span> *stack2;<span class="comment">// 用于存储拓扑序列的栈</span></span><br><span class="line"><span class="type">int</span> top2;<span class="comment">// 用于 stack2 的指针</span></span><br></pre></td></tr></table></figure><p>其中 stack2 用来存储拓扑序列，以便后面求关键路径时使用。</p><p>改进过的求拓扑序列算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序，用于关键路径计算</span></span><br><span class="line">Status <span class="title function_">TopologicalSort</span><span class="params">(GraphAdjList GL)</span> &#123;</span><br><span class="line">  EdgeNode *e;</span><br><span class="line">  <span class="type">int</span> i, k, gettop;</span><br><span class="line">  <span class="type">int</span> top = <span class="number">0</span>;<span class="comment">// 用于栈指针下标</span></span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">// 用于统计输出顶点的个数</span></span><br><span class="line">  <span class="type">int</span> *<span class="built_in">stack</span>;<span class="comment">// 建栈将入度为 0 的顶点入栈</span></span><br><span class="line">  <span class="built_in">stack</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(GL -&gt; numVertexes * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL -&gt; adjList[i].in)</span><br><span class="line">    <span class="built_in">stack</span>[++top] = i;</span><br><span class="line">  top2 = <span class="number">0</span>;<span class="comment">// 初始化为 0</span></span><br><span class="line">  etv = (<span class="type">int</span> *)<span class="built_in">malloc</span>(GL -&gt; numVertexes * <span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">// 事件最早发生时间</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; GL -&gt; numVertexes; i++)</span><br><span class="line">    etv[i] = <span class="number">0</span>;<span class="comment">// 初始化为 0</span></span><br><span class="line">  stack2 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(GL -&gt; numVertexes * <span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">// 初始化</span></span><br><span class="line">  <span class="keyword">while</span>(top != <span class="number">0</span>) &#123;</span><br><span class="line">    gettop = <span class="built_in">stack</span>[top--];</span><br><span class="line">    count++;</span><br><span class="line">    stack2[++top2] = gettop;<span class="comment">// 将弹出的顶点序号压入拓扑序列的栈</span></span><br><span class="line">    <span class="keyword">for</span>(e = GL -&gt; adkList[gettop].firstedge; e; e = e -&gt; next) &#123;</span><br><span class="line">      k = e -&gt; adjvex;</span><br><span class="line">      <span class="keyword">if</span>(!(--GL -&gt; adjList[k].in))</span><br><span class="line">        <span class="built_in">stack</span>[++top] = k;</span><br><span class="line">      <span class="keyword">if</span>((etv[gettop] + e -&gt; weigth) &gt; etv[k])<span class="comment">// 求各顶点事件最早发生时间值</span></span><br><span class="line">        etv[k] = etv[gettop] + e -&gt; weight;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(count &lt; GL -&gt; numVertexes)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 10～14 行为初始化全局变量 etv 数组、top2 和 stack2 的过程。第 19 行就是将本是要输出的拓扑序列压入全局栈 stack2 中。第 24～25 行很关键，它是求 etv 数组的每一个元素的值。比如，加入已经求得顶点 v<sub>0</sub> 对应的 etv[0] &#x3D; 0，顶点 v<sub>1</sub> 对应的 etv[1] &#x3D; 3，顶点 v<sub>2</sub> 对应的 etv[2] &#x3D; 4，现在我们需要求顶点 v<sub>3</sub> 对应的 etv[3]，其实就是求 etv[1] + len&lt;v<sub>1</sub>, v<sub>3</sub>&gt; 与 etv[2] + len&lt;v<sub>2</sub>, v<sub>3</sub>&gt; 的较大值。显然 3 + 5 &lt; 4 +8，得到 etv[3] &#x3D; 12，如下图。在代码中 e -&gt; weight 就是当前弧的长度。</p><p><img src="/../img/dsa/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-2.png" alt="关键路径算法"></p><p>由此得出计算顶点 v<sub>k</sub> 即求 etv[k] 的最早发生时间的公式是：</p><p>etc[k] &#x3D; 0, 当 k &#x3D; 0 时；</p><p>etc[k] &#x3D; max{etc[i] + len&lt;v<sub>i</sub>, v<sub>k</sub>&gt;}，当 k ≠ 0 且 &lt;v<sub>i</sub>, v<sub>k</sub>&gt; ∈ P[k] 时</p><p>其中 P[K] 表示所有到达顶点 v<sub>k</sub> 的弧的集合。</p><p>求关键路径的算法代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求关键路径，GL 为有向图，输出 GL 的各项关键活动</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CriticalPath</span><span class="params">(GraphAdjList GL)</span> &#123;</span><br><span class="line">  EdgeNode *e;</span><br><span class="line">  <span class="type">int</span> i, gettop, k, j;</span><br><span class="line">  <span class="type">int</span> ete, lte;<span class="comment">// 声明活动最早发生时间和最迟发生时间变量</span></span><br><span class="line">  TopologicalSort(GL);<span class="comment">// 求拓扑序列，计算数组 etv 和 stack2 的值</span></span><br><span class="line">  ltv = (<span class="type">int</span> *)<span class="built_in">malloc</span>(GL -&gt; numVertexes * <span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">// 事件最晚发生时间</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Gl -&gt; numVertexes; i++)</span><br><span class="line">    ltv[i] = tev[GL -&gt; numVertexes - <span class="number">1</span>];<span class="comment">// 初始化 ltv</span></span><br><span class="line">  <span class="keyword">while</span>(top2 != <span class="number">0</span>) &#123;<span class="comment">// 计算 ltv</span></span><br><span class="line">    gettop = stack2[top2--];<span class="comment">// 将拓扑序列出栈，后进先出</span></span><br><span class="line">    <span class="keyword">for</span>(e = GL -&gt; adjList[gettop].firstedge; e; e = e -&gt; next) &#123; <span class="comment">// 求各顶点事件的最迟发生时间 ltv 值</span></span><br><span class="line">      k = e -&gt; adjvex;</span><br><span class="line">      <span class="keyword">if</span>(ltv[k] - e -&gt; weight &lt; ltv[gettop])<span class="comment">// 求各顶点事件最晚发生时间 ltv</span></span><br><span class="line">        ltv[gettop] = ltv[k] - e -&gt; weight;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; Gl -&gt; numVertexes; j++) &#123;<span class="comment">// 求 ete，lte 和关键活动</span></span><br><span class="line">    <span class="keyword">for</span>(e = GL -&gt; adjList[j].firstedge; e; e = e -&gt; next) &#123;</span><br><span class="line">      k = e -&gt; adjvex;</span><br><span class="line">      ete = etv[j];<span class="comment">// 活动最早发生时间</span></span><br><span class="line">      lte = ltv[k] - e -&gt; weight;<span class="comment">// 活动最迟发生时间</span></span><br><span class="line">      <span class="keyword">if</span>(ete == lte)<span class="comment">// 两者相等即在关键路径上</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;v%d, v%d&gt; length: %d , &quot;</span>, GL - adjList[j].data, GL -&gt; adjList[k].data, e -&gt; weight);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>程序开始执行。第 5 行 声明了 ete 和 lte 两个活动最早最晚发生时间变量。</p></li><li><p>第 6 行，调用求拓扑序列的函数。执行完毕后，全局变量数组 etv 和 栈 stack 的值如下图所示，top2 &#x3D; 10。</p><p> <img src="/../img/dsa/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-3.png" alt="关键路径算法"></p></li><li><p>第 7～9 行为初始化全局变量 ltv 数组，因为 etv[9] &#x3D; 27，所以数组 ltv 当前的值为：{27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27}</p></li><li><p>∈第 10～17 行为 ltv 的循环。第 11 行，先讲 stack2 的栈头出栈，由后进先出得到 gettop &#x3D; 9。根据邻接表中，v<sub>9</sub> 没有弧表，所以 12～16 行循环体未执行。</p></li><li><p>再次来到 11 行，gettop &#x3D; 8，在第 12～16 行的循环中，v<sub>8</sub> 的弧表只有一条 &lt;v<sub>8</sub>, v<sub>9</sub>&gt;，第 13 行得到 k &#x3D; 9，因为 ltv[9] - 3 &lt; ltv[8]，所以 ltv[8] &#x3D; ltv[9] - 3 &#x3D; 24，如下图。</p><p> <img src="/../img/dsa/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-4.png" alt="关键路径算法"></p></li><li><p>再次循环，当 gettop &#x3D; 7、5、6 时，同理可算出 ltv 相对应的值为19、25、13，此时 ltv 值为：{27, 27, 27, 27, 27, 13, 25, 19, 24, 27}</p></li><li><p>当 gettop &#x3D; 4 时，由邻接表可得到 v<sub>4</sub> 有两条弧 &lt;v<sub>4</sub>, v<sub>6</sub>&gt;、&lt;v<sub>4</sub>, v<sub>7</sub>&gt;，通过第 12～16 行的循环，可以得到 ltv[4] &#x3D; min(ltv[7] - 4, ltv[6] - 9) &#x3D; min(19 - 4, 25 - 9) &#x3D; 15，如下图所示。</p><p> <img src="/../img/dsa/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-5.png" alt="关键路径算法"></p><p> 得出计算顶点 v<sub>k</sub> 即求 ltv[k] 的最晚发生的公式是：</p><p> ltv[k] &#x3D; etc[k]，当 k &#x3D; n - 1；</p><p> ltv[k] &#x3D; min{ltv[j] + len &lt; &lt;v<sub>k</sub>, v<sub>j</sub>&gt;}，当 k &lt; n - 1 且 &lt;v<sub>k</sub>, v<sub>j</sub>&gt; ∈ S[k] 时</p><p> 其中 S[K] 表示所有从顶点 v<sub>k</sub> 出发的弧的集合。</p></li><li><p>第 18～26 行是来求另两个变量活动最早开始事件 ete 和活动最晚开始事件 lte，并对相同下标的它们做比较。两重循环嵌套是对邻接表的顶点和每个顶点的弧表遍历。</p></li><li><p>当 j &#x3D; 0，从 v<sub>0</sub> 点开始，有 &lt;v<sub>0</sub>, v<sub>2</sub>&gt; 和 &lt;v<sub>0</sub>, v<sub>1</sub>&gt; 两条弧。当 k &#x3D; 2 时，ete &#x3D; etv[j] &#x3D; etv[0] &#x3D; 0。lte &#x3D; ltv[k] - e -&gt; weight &#x3D; ltv[2] -len &lt;v<sub>0</sub>, v<sub>2</sub>&gt; &#x3D; 4 - 4 &#x3D; 0，此时 ete &#x3D; lte，表示弧 &lt;v<sub>0</sub>, v<sub>2</sub>&gt; 是关键活动，因此打印。当 k &#x3D; 1时，ete &#x3D; etv[j] &#x3D; etv[0] &#x3D; 0。lte &#x3D; liv[k] -e -&gt; weight &#x3D; ltv[1] -len&lt;v<sub>0</sub>, v<sub>1</sub>&gt; &#x3D; 7 - 3 &#x3D; 4，此时 ete ≠ lte，因此 &lt;v<sub>0</sub>, v<sub>1</sub>&gt; 并不是关键活动，如下图。</p><p> <img src="/../img/dsa/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-6.png" alt="关键路径算法"></p></li><li><p>j &#x3D; 1 一直到 j &#x3D; 9 为止，做法是完全相同的，关键路径打印结果为 “&lt;v<sub>0</sub>, v<sub>2</sub>&gt; 4，&lt;v<sub>2</sub>, v<sub>3</sub>&gt; 8， &lt;v<sub>3</sub>, v<sub>4</sub>&gt; 3，&lt;v<sub>4</sub>, v<sub>7</sub>&gt; 4，&lt;v<sub>7</sub>, v<sub>8</sub>&gt; 5， &lt;v<sub>8</sub>, v<sub>9</sub>&gt; 3，”，最终关键路径如下图。</p><p><img src="/../img/dsa/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-7.png" alt="关键路径算法"></p></li></ol><p>分析整个求关键路径的算法，第 6 行诗 拓扑排序，时间复杂度为 O(n + e)，第 8～9 行时间复杂度为 O(n) ，第 10～17 行时间复杂度为 O(n + e)，第 18～ 26 行时间复杂度也为 O(n + e)，最终求关键路径算法的时间复杂度依然是 O(n + e)。</p><h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>图的存储结构一种阐述了 五种，其中比较重要的是邻接矩阵和邻接表，它们分别代表着边集是用数组还是链表的方式存储。十字链表是邻接矩阵的一种升级，而邻接多重表则是邻接表的升级。边集数组更多考虑的是对边的关注。用什么存储结构需要具体问题具体分析，通常稠密图，或读存数据较多，结构修改较少的图，用邻接矩阵要更合适，反之则应该考虑邻接表。</p><p>图的遍历分为深度和广度两种，各有优缺点。图的三种应用：最小生成树、最短路径和有向无环图的应用。</p><p>最小生成树，两种算法：普里姆 (Prim) 算法和克鲁斯卡尔 (Kruskal) 算法。普里姆算法像是走一步看一步的思维方式，逐步生成最小生成树。而克鲁斯卡尔算法则更有全局意识，直接从图中最短权值的边入手，找寻最后的答案。</p><p>最短路径的显示应用非常多。迪杰斯特拉 (Dijkstra) 算法更强调单源顶点查找路径的方式，比较符合我们正常的思路，容易理解原理，但算法代码相对复杂。而弗洛伊德 (Floyd) 算法则完全抛开了单点的局限思维方式，巧妙地应用矩阵的变换，用最清爽的代码实现了多顶点间最短路径求解的方案，原理理解有难度，但算法编写很简洁。</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="查找概论"><a href="#查找概论" class="headerlink" title="查找概论"></a>查找概论</h3><p><strong>查找表 (Search Table) 是由同一类型的数据元素 (或记录) 构成的集合。关键字 (Key) 是数据元素中某个数据项的值</strong>，又称为键值，用它可以标识一个数据元素。也可以标识一个记录的某个数据项 (字段)，称为关键码。**若此关键字可以唯一地标识一个记录，则称此关键字为主关键字 (Primary Key)<strong>。注意这也意味着，对不同的记录，其主关键字均不相同。主关键字所在的数据项称为主关键码。</strong>对于那些可以识别多个数据元素 (或记录) 的关键字，称为次关键字 (Secondary Key)。次关键字也可以理解为是不以唯一标识一个数据元素或记录的关键字，它对应的数据项就是次关键码。</p><blockquote><p>查找 (Searching) 就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素 (或记录)。</p></blockquote><p>查找表按照操作方式来分有两大种：静态查找表和动态查找表。<br><strong>静态查找表 (Static Search Table)：只作查找操作的查找表</strong>。它的主要操作有：</p><ol><li>查询某个“特定的”数据元素是否在查找表中。</li><li>检索某个“特定的”数据元素和各种属性。</li></ol><p><strong>动态查找表 (Dynamic Search Table)：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素</strong>。显然动态查找表的操作就是两个：</p><ol><li>查找时插入数据元素。</li><li>查找时删除数据元素。</li></ol><h3 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h3><p><strong>顺序查找 (Sequential Search) 又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个或最后一个记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果知道最后一个或第一个记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功</strong>。</p><h4 id="顺序表查找算法"><a href="#顺序表查找算法" class="headerlink" title="顺序表查找算法"></a>顺序表查找算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序查找，a 为数组，n 为要查找的数组个数，key 为要查找的关键字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sequential_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i] == key)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码非常简单，就是在数组 a (注意元素值从下标 1 开始) 中查看有没有关键字 (key)，当需要查找复杂表结构的记录时，只需要把数组 a 与关键字 key 定义成需要的表结构和数据类型即可。</p><h4 id="顺序表查找优化"><a href="#顺序表查找优化" class="headerlink" title="顺序表查找优化"></a>顺序表查找优化</h4><p>到这里并非足够完美，因为每次循环时都需要对 i 是否越界，即是否小于等于 n 做判断。事实上，还可以有更好一点的办法，设置一个哨兵，可以解决不需要每次让 i 与 n 做比较。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有哨兵顺序查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sequential_Search2</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  a[<span class="number">0</span>] = key;<span class="comment">// 设置 a[0] 为关键字值，称之为哨兵</span></span><br><span class="line">  i = n;<span class="comment">// 循环从数组尾部开始</span></span><br><span class="line">  <span class="keyword">while</span>(a[i] != key) &#123;</span><br><span class="line">    i--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;<span class="comment">// 返回 0 则说明查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时代码是从尾部开始查找，由于 a[0] &#x3D; key，也就是说，如果在 a[i] 中有 key 则返回 i 值，查找成功。否则一定在最终的 a[0] 处等于 key，此时返回的是 0，即说明 a[1]~a[n] 中没有关键字 key，查找失败。</p><p>这种在查找方向的尽头放置哨兵面去了在查找过程中每一次比较后都要判断查找位置是否越界的小技巧，看似与原先差别不大，但在总数据较多时，效率提高很大，是非常好的编码技巧。当然，哨兵也不一定就一定要在数组开始，也可以在末端。</p><p>对于这种顺序查找算法来说，查找成功最好的情况就是在第一个位置就找到了，算法时间复杂度为 O(1)，最坏的情况是在最后一位置才找到，需要 n 次比较，时间复杂度为 O(n)，当查找不成功时，需要 n+1 次比较，时间复杂度为 O(n)。所以最终的时间复杂度还是 O(n)。</p><p>很显然，顺序查找技术是有很大缺点的，n 很大时，查找效率极为低下，不过优点也是有的，这个算法非常简单，对静态查找表的记录没有任何要求，在一些小型数据的查找时，是可以适用的。另外，也正由于查找概率的不同，完全可以将容易查找到的记录放在前面，而不常用的记录放置在后面，效率就可以有大幅提高。</p><h3 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h3><h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><p><strong>折半查找 (Binary Search) 技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序 (通常从小到大有序)，线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止</strong>。</p><p>假如在一个有序表数组 {0, 1, 16, 24, 35, 47, 59, 62, 73, 88, 99} 中查找是否存在 62 这个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 折半查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> low, high, mid;</span><br><span class="line">  low = <span class="number">1</span>;<span class="comment">// 定义最低下标为记录首位</span></span><br><span class="line">  high = n;<span class="comment">// 定义最高下标为记录末位</span></span><br><span class="line">  <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">    mid = (low + high) / <span class="number">2</span>;<span class="comment">// 折半</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; a[mid])<span class="comment">// 若查找值比中值小</span></span><br><span class="line">      high = mid - <span class="number">1</span>;<span class="comment">// 最高下标调整到中位下标小一位</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; a[mid])<span class="comment">// 若查找值比中值大</span></span><br><span class="line">      low = mid + <span class="number">1</span>;<span class="comment">// 最低下标调整到中位下标大一位</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> mid;<span class="comment">// 若相等则说明 mid 即为查找到的位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>折半查找算法的时间复杂度为 O(logn)，它显然远远好于顺序查找的 O(n) 时间复杂度了。</p><h4 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h4><p>**插值查找 (Interpolation Search) 是根据要查找的关键字 key 与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式 <code>(key - a[low])/(a[high] - a[low])</code>**。只需要将查办查找算法代码中第 7 行更改成以下就可以了<code>mid = low + (high -low) * (key - a[low]) / (a[high] - a[low]);</code>。应该说，从时间复杂度来看，他也是 O(logn)，但对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多。</p><h4 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h4><p>斐波那契查找 (Fibonacci Search) 利用了黄金分割原理来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契数列</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fibonacci_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> low, high, mid, i, k;</span><br><span class="line">  low = <span class="number">1</span>;<span class="comment">// 定义最低下标为记录首位</span></span><br><span class="line">  high = n;<span class="comment">// 定义最高下标为记录末位</span></span><br><span class="line">  k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n &gt; F[k] - <span class="number">1</span>)<span class="comment">// 计算 n 位于斐波那契数列的位置</span></span><br><span class="line">    k++;</span><br><span class="line">  <span class="keyword">for</span>(i = n; i &lt; F[k] - <span class="number">1</span>; i++)<span class="comment">// 将不满的数值补全</span></span><br><span class="line">    a[i] = a[n];</span><br><span class="line">  <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">    mid = low + F[k - <span class="number">1</span>] - <span class="number">1</span>;<span class="comment">// 计算当前分割的下标</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; a[mid]) &#123;<span class="comment">// 若查找记录小于当前分割记录</span></span><br><span class="line">      high = mid <span class="number">-1</span>;<span class="comment">// 最高下标调整到分割下标 mid - 1 处</span></span><br><span class="line">      k = k - <span class="number">1</span>;<span class="comment">// 斐波那契数列下标减一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; a[mid]) &#123;<span class="comment">// 若查找记录大于当前分割记录</span></span><br><span class="line">      low = mid + <span class="number">1</span>;<span class="comment">// 最低下标调整到分割下标 mid + 1 处</span></span><br><span class="line">      k = k - <span class="number">2</span>;<span class="comment">// 斐波那契数列下标减两位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(mid &lt;= n)</span><br><span class="line">        <span class="keyword">return</span> mid;<span class="comment">// 若相等则说明 mid 即为查找到的位置</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n;<span class="comment">// 若 mid &gt; n 说明是补全数值，返回 n</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>斐波那契查找算法的核心在于：</p><ol><li>当 key &#x3D; a[mid] 时，查找就成功；</li><li>当 key &lt; a[mid] 时，新范围是第 low 个到 mid - 1 个，此时范围个数为 F[k - 1] - 1 个；</li><li>当 key &gt; a[mid] 时，新范围是第 m + 1 个到第 high 个，此时范围个数为 F[k - 2] - 1个。</li></ol><p>也就是说，如果要查找的记录在右侧，则左侧的数据都不用再判断了，不断反复进行下去，对处于当中的大部分数据，其工作效率要高一些。所以尽管斐波那契查找的时间复杂也为 O(logn)，但就平均性能来说，斐波那契查找要优于折半查找。可惜如果是最坏情况，比如这里 key &#x3D; 1，那么始终都处于左侧长半区在查找，则查找效率要低于折半查找。</p><p>还有比较关键的一点，折半查找是进行加法于除法运算 (mid &#x3D; (low + high) &#x2F; 2)，插值查找进行复杂的四则运算 (mid &#x3D; low + (high - low) * (key - a[low]) &#x2F; (a[high] - a[low]))，而斐波那契查找只是最简单加减法运算 (mid &#x3D; low + F[k - 1] - 1)，在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率。</p><h3 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h3><p>以上几种比较高效的查找方法都是基于有序的基础之上的，但事实上，很多数据集可以增长非常快，如果要保证记录全部是按照当中某个关键字有序，其时间代价是非常昂贵的，所以这种数据通常都是按先后顺序存储。</p><p>数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构。<strong>索引就是把一个关键字与它对应的记录相关联的过程</strong>，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。</p><p>索引按照结构可以分为线性索引、树形索引和多级索引。<strong>所谓线性索引就是将索引项集合组织为线性结构，也称为索引表</strong>。</p><h4 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h4><p><strong>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项</strong>，如下图。</p><p><img src="/../img/dsa/%E7%A8%A0%E5%AF%86%E7%B4%A2%E5%BC%95.png" alt="稠密索引"></p><p><strong>对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列</strong>。</p><p>索引项有序也就意味着，要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高了效率。这显然是稠密索引有点，但是如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说，可能就需要反复去访问磁盘，查找性能反而大大下降了。</p><h4 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h4><p><strong>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件</strong>：</p><ul><li><strong>块内无序</strong>，即每一块内的记录不要求有序。当然，如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间的代价，因此通常不要求块内有序。</li><li><strong>块间有序</strong>，例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字……因为只有块间有序，才有可能在查找时带来效率。</li></ul><p>对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。如下图。定义的分块索引结构分三个数据项：</p><ul><li>最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块的关键字要大；</li><li>存储了块中的记录个数，以便于循环时使用；</li><li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。</li></ul><p><img src="/../img/dsa/%E5%88%86%E5%9D%97%E7%B4%A2%E5%BC%95.png" alt="分块索引"></p><p>在分块索引表查找，就是分两步进行：</p><ol><li>在分块索引表中查找要查关键字所在的块。由于分块索引表是块间有序的，因此很容易利用折半、插值等算法得到结果。</li><li>根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查找。</li></ol><p>分析一下分块索引的平均查找长度。设 n 个记录的数据集被平均分成 m 块，每个块中有 t 条记录，显然 n &#x3D; m * t，或者说 m &#x3D; n &#x2F; t。再假设 L<sub>b</sub> 为查找索引表的平均查找长度，因最好于最差的等概率原则，所以 L<sub>b</sub> 的平均长度为 (m + 1) &#x2F; 2。L<sub>w</sub> 为块中查找记录的平均查找长度，同理可知它的平均查找长度为 (t + 1) &#x2F; 2。</p><p>这样分块索引查找的平均查找长度为：</p><p>ASL<sub>w</sub> &#x3D; L<sub>b</sub> + L<sub>w</sub> &#x3D; (m + 1) &#x2F; 2 + (t + 1) &#x2F; 2 &#x3D; 1 &#x2F; 2(m + t) + 1 &#x3D; 1 &#x2F; 2(n &#x2F; t + t) + 1</p><p>注意上面这个式子的推导是为了让整个分块索引查找长度依赖 n 和 t 两个变量。从这里我们也就得到，平均长度不仅仅取决于数据集的总记录数 n，还和每一块的记录个数 t 相关。最佳的情况就是分的块数 m 与块中的记录数 t 相同，此时意味着 n &#x3D; m * t &#x3D; t<sup>2</sup>，即 ASL<sub>w</sub> &#x3D; 1 &#x2F; 2(n &#x2F; t + t) + 1 &#x3D; t + 1 &#x3D; √n + 1</p><p>可见，分块索引的效率比之顺序查找的 O(n) 是高了不少，不过显然它与折半查找的 O(long) 相比还有不小的差距。因此在确定所在块的过程中，由于块间有序，所以可以应用折半、插值等手段来提高效率。</p><p>总的来说，分块索引在兼顾了对细分块不需要有序的情况下，大大增加了整体查找的速度，所以普遍被用于数据库表查找等技术的应用当中。</p><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>索引项的通用结构是：</p><ul><li>次关键码</li><li>记录号表</li></ul><p>**其中记录号表存储具有相同次关键字的所有记录的记录号 (可以是指向记录的指针或者是该记录的主关键字)。这样的索引方法就是倒排索引 (inverted index)**。倒排索引源于实际应用中需要根据属性或字段、次关键码的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因为称为倒排索引。</p><p>倒排索引的优点显然就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果。但它的缺点是这个记录号不定长。</p><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p><strong>二叉排序树 (Binary Sort Tree)，又称为二叉查找树。它或者是一颗空树，或者是具有下列性质的二叉树</strong>。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树。</li></ul><p>从二叉排序树的定义可以知道，它前提是二叉树，然后它采用了递归的定义方法，再者，它的结点间满足一定的次序关系，左子树结点一定比其双亲结点小，右子树结点一定比其双亲结点大。</p><p>构造一棵二叉排序树的目的，其实并不是为了排序，而是为了提高查找和插入删除关键字的速度。不管怎么说，在一个有序数据集上的查找，速度总是要快于无序的数据集的，而二叉排序树这种非线性的结构，也有利于插入和删除的实现。</p><h4 id="二叉排序树查找操作"><a href="#二叉排序树查找操作" class="headerlink" title="二叉排序树查找操作"></a>二叉排序树查找操作</h4><p>提供一个二叉树的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的二叉链表结点结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span><span class="comment">// 结点结构</span></span><br><span class="line">  <span class="type">int</span> data;<span class="comment">// 结点数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><p>二叉排序树的查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归查找二叉排序树 T 中是否存在 key，指针 f 指向 T 的双亲，其初始调用值为 NULL。若查找成功，则指针 p 指向查找路径上访问的最后一个结点并返回 FALSE</span></span><br><span class="line">Status <span class="title function_">SearchBST</span><span class="params">(BiTree T, <span class="type">int</span> key, BiTree f, BiTree *p)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!T) &#123;<span class="comment">// 查找不成功</span></span><br><span class="line">    *p = f;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(key == T -&gt; data) &#123;<span class="comment">// 查找成功</span></span><br><span class="line">    *p = T;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T -&gt; data)</span><br><span class="line">    <span class="keyword">return</span> SearchBST(T -&gt; lchild, key, T, p);<span class="comment">// 在左子树继续查找</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> SearchBST(T -&gt; rchild, key, T, p);<span class="comment">// 在右子树继续查找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉排序树插入操作"><a href="#二叉排序树插入操作" class="headerlink" title="二叉排序树插入操作"></a>二叉排序树插入操作</h4><p>有了二叉排序树的查找函数，那么所谓的二叉排序树的插入，其实也就是将关键字放到树中的合适位置而已。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当二叉排序树 T 中不存在关键字等于 key 的数据元素时，插入 key 并返回 TRUE，否则返回 FALSE</span></span><br><span class="line">Status <span class="title function_">InsertBST</span><span class="params">(BiTree *T, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  BiTree p, s;</span><br><span class="line">  <span class="keyword">if</span>(!SearchBST(*T, key, <span class="literal">NULL</span>, &amp;p)) &#123;<span class="comment">// 查找不成功</span></span><br><span class="line">    s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    s -&gt; data = key;</span><br><span class="line">    s -&gt; lchild = s -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">      *T = s;<span class="comment">// 插入 s 为新的根结点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; p -&gt; data)</span><br><span class="line">      p -&gt; lchild = s;<span class="comment">// 插入 s 为左孩子</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      p -&gt; rchild = s;<span class="comment">// 插入 s 为右孩子</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;<span class="comment">// 树中已有关键字相同的结点，不再插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了二叉排序树的插入代码，是心啊二叉排序树的构建就非常容易了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">62</span>, <span class="number">88</span>, <span class="number">58</span>, <span class="number">47</span>, <span class="number">35</span>, <span class="number">73</span>, <span class="number">51</span>, <span class="number">99</span>, <span class="number">37</span>, <span class="number">93</span>&#125;;</span><br><span class="line">BiTree T = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  InsertBST(&amp;T, a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉排序树删除操作"><a href="#二叉排序树删除操作" class="headerlink" title="二叉排序树删除操作"></a>二叉排序树删除操作</h4><p>对删除结点三种情况的分析：</p><ul><li>叶子结点；</li><li>仅有左或右子树的结点；</li><li>左右子树都有的结点。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若二叉排序树 T 中存在关键字等于 key 的数据元素时，则删除该数据元素结点，并返回 TRUE；否则返回 FALSE</span></span><br><span class="line">Status <span class="title function_">DeleteBST</span><span class="params">(BiTree *T, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!*T)<span class="comment">// 不存在关键字等于 key 的数据元素</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(key == (*T) -&gt; data)<span class="comment">// 找到关键字等于 key 的数据元素</span></span><br><span class="line">      <span class="keyword">return</span> Delete(T);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; (*T) -&gt; data)</span><br><span class="line">      <span class="keyword">return</span> DeleteBST(&amp;(*T) -&gt; lchild, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> DeleteBST(&amp;(*T) -&gt; rchild, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码和前面的二叉排序树查找几乎完全相同，唯一的区别在于第 7 行，此时执行的是 Delete 方法，对当前结点进行删除操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从二叉排序树中删除结点 p，并重接它的左或右子树。</span></span><br><span class="line">status <span class="title function_">Delete</span><span class="params">(BiTree *p)</span> &#123;</span><br><span class="line">  BiTree q, s;</span><br><span class="line">  <span class="keyword">if</span>((*p) -&gt; rchild == <span class="literal">NULL</span>) &#123;<span class="comment">// 右子树空则只需重接它的左子树</span></span><br><span class="line">    q = *p; </span><br><span class="line">    *p = (*p) -&gt; lchild; </span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((*p) -&gt; lchild == <span class="literal">NULL</span>) &#123;<span class="comment">// 只需重接它的右子树</span></span><br><span class="line">    q = *p;</span><br><span class="line">    *p = (*p) -&gt; rchild;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">// 左右子树均不空</span></span><br><span class="line">    q = *p;</span><br><span class="line">    s = (*p) -&gt; lchild;</span><br><span class="line">    <span class="keyword">while</span>(s -&gt; rchild) &#123;<span class="comment">// 转左，然后向右到尽头 (找待删结点的前驱)</span></span><br><span class="line">      q = s;</span><br><span class="line">      s = s -&gt; rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    (*p) -&gt; data = s -&gt; data;<span class="comment">// s 指向被删结点的直接前驱</span></span><br><span class="line">    <span class="keyword">if</span>(q != *p)</span><br><span class="line">      q -&gt; rchild = s -&gt; lchild;<span class="comment">// 重接 q 的右子树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      q -&gt; lchild = s -&gt; lchild;<span class="comment">// 重接 q 的左子树</span></span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> TRUE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉排序树总结"><a href="#二叉排序树总结" class="headerlink" title="二叉排序树总结"></a>二叉排序树总结</h4><p>总之，二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可。插入删除的时间性能比较好。而对于二叉排序树的查找，走的就是从根结点到要查找的结点的路径，其比较次数等于给定值的结点在二叉排序树的层数。极端情况，最少为 1 次，几根结点就是要找的结点，最多也不会超过树的深度。也就是说，二叉排序树的查找性能取决于二叉树排序树的形状。可问题在于，二叉排序树的形状是不确定的。</p><p>也就是说，希望二叉排序树是比较平衡的，即其深度与完全二叉树相同，均为 log<sub>2</sub>n + 1，那么查找的时间复杂度也就为 O(logn)，近似于折半查找。因此希望对一个集合按二叉排序树查找，最好是把它构建成一棵平衡二叉树。</p><h3 id="平衡二叉树-AVL-树"><a href="#平衡二叉树-AVL-树" class="headerlink" title="平衡二叉树 (AVL 树)"></a>平衡二叉树 (AVL 树)</h3><p><strong>平衡二叉树 (Self-Balancing Binary Search Tree 或 Height-Balanced Binary Search Tree)，是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于 1</strong>。</p><p>从平衡二叉树的英文名，可以体会到，它是<strong>一种高度平衡的二叉排序树</strong>。那什么叫做高度平衡呢？意思是说，要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过 1。**将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子 BF (Balance Factor)**，那么平衡二叉树上所有结点的平衡因子只可能是 -1， 0 和 1。只要二叉树上有一个结点的平衡因子的绝对值大于 1，则该二叉树就是不平衡的。</p><p><strong>距离插入结点最近的，且平衡因子的绝对值大于 1 的结点为根的子树，称为最小不平衡子树</strong>。</p><h4 id="平衡二叉树实现原理"><a href="#平衡二叉树实现原理" class="headerlink" title="平衡二叉树实现原理"></a>平衡二叉树实现原理</h4><p>平衡二叉树构建的基本思想就是在构建二叉树排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。</p><h4 id="平衡二叉树的实现算法"><a href="#平衡二叉树的实现算法" class="headerlink" title="平衡二叉树的实现算法"></a>平衡二叉树的实现算法</h4><p>改进二叉排序树的结点结构，增加一个 bf，用来存储平衡因子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的二叉链表结点结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span><span class="comment">// 结点结构</span></span><br><span class="line">  <span class="type">int</span> data;<span class="comment">// 结点数据</span></span><br><span class="line">  <span class="type">int</span> bf;<span class="comment">// 结点的平衡因子</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><p>然后，对于右旋操作，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对以 p 为根的二叉排序树作右旋处理，处理之后 p 指向新的树根结点，即旋转处理之前的左子树的根结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">R_Rotate</span><span class="params">(BiTree *P)</span> &#123;</span><br><span class="line">  BiTree L;</span><br><span class="line">  l = (*P) -&gt; lchild;<span class="comment">// L 指向 p 的左子树根结点</span></span><br><span class="line">  (*P) -&gt; lchild = L -&gt; rchild;<span class="comment">// L 的右子树挂接为 p 的左子树</span></span><br><span class="line">  L -&gt; rchild = (*p);</span><br><span class="line">  *p = L;<span class="comment">// p 指向新的根结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数代码的意思是说，当传入一个二叉排序树 p，将它的左孩子结点定义为 L，将 L 的右子树变成 p 的左子树，再将 p 改成 L 的右子树，最后将 L 替换 P 成为根结点。这样就完成了一次右旋操作。</p><p>左旋操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对以 p 为根的二叉排序树作左旋处理，处理之后 p 指向新的树根结点，即旋转处理之前的右子树的根结点 0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">L_Rotate</span><span class="params">(BiTree *p)</span> &#123;</span><br><span class="line">  BiTree R;</span><br><span class="line">  R = (*p) -&gt; rchild;<span class="comment">// R 指向 p 的右子树根结点</span></span><br><span class="line">  (*p) -&gt; rchild = R -&gt; lchild;<span class="comment">// R 的左子树挂接为 P 的右子树</span></span><br><span class="line">  R -&gt; lchild = (*p);</span><br><span class="line">  *p = R;<span class="comment">// P 指向新的根结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左平衡旋转处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LH +1<span class="comment">/* 左高 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EH 0<span class="comment">/* 等高 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RH -1<span class="comment">/* 右高 */</span></span></span><br><span class="line"><span class="comment">/* 对以指针 T 所指结点为根的二叉树作左平衡旋转处理，本算法结束时，指针 T 指向新的根结点 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LeftBalance</span><span class="params">(BiTree *T)</span> &#123;</span><br><span class="line">  BiTree L, Lr;</span><br><span class="line">  L = (*T) -&gt; lchild;<span class="comment">// L 指向 T 的左子树的根结点</span></span><br><span class="line">  <span class="keyword">switch</span>(L -&gt; bf) &#123;<span class="comment">// 检查 T 的左子树的平衡度，并做相应平衡处理</span></span><br><span class="line">    <span class="keyword">case</span> LH:<span class="comment">// 新结点插入在 T 的左孩子的左子树上，要做单右旋处理</span></span><br><span class="line">      (*T) -&gt; bf = L -&gt; bf = EH;</span><br><span class="line">      R_Rotate(T);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RH:     <span class="comment">// 新结点插入在 T 的左孩子的右子树上，要做双旋处理</span></span><br><span class="line">      Lr = L -&gt; rchild;<span class="comment">// Lr 指向 T 的左孩子的右子树根</span></span><br><span class="line">      <span class="keyword">switch</span>(Lr -&gt; bd) &#123;<span class="comment">// 修改 T 及其左孩子的平衡因子</span></span><br><span class="line">        <span class="keyword">case</span> LH:</span><br><span class="line">          (*T) -&gt; bf = RH;</span><br><span class="line">          L -&gt; bf = EH;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EH:</span><br><span class="line">          (*T) -&gt; bf = L -&gt; bf = EH;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RH:</span><br><span class="line">          (*T) -&gt; bf = EH;</span><br><span class="line">          L -&gt; bf = LH;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Lr -&gt; bf = EH;</span><br><span class="line">      L_Rotate(&amp;(*T) -&gt; lchild);<span class="comment">// 对 T 的左子树作左旋平衡处理</span></span><br><span class="line">      R_Rotate(T);<span class="comment">// 对 T 作右旋平衡处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若在平衡的二叉排序树 T 中不存在和 e 有相同关键字的结点，则插入一个数据元素为 e 的新结点并返回 1，否则返回 0。 */</span></span><br><span class="line"><span class="comment">/* 若因插入而使二叉排序树失去平衡，则作平衡旋转处理，布尔变量 taller 反应 T 长高与否 */</span></span><br><span class="line">Status <span class="title function_">InsertAVL</span><span class="params">(BiTree *T, <span class="type">int</span> e, Status *taller)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!*T) &#123;<span class="comment">// 插入新结点，树“长高”，置 taller 为 TRUE</span></span><br><span class="line">    *T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T) -&gt; data = e;</span><br><span class="line">    (*T) -&gt; lchild = (*T) -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">    (*T) -&gt; bf = EH;</span><br><span class="line">    *taller = TRUE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(e == (*T) -&gt; data) &#123;<span class="comment">// 树中已存在和 e 有相同关键字的结点则不再插入</span></span><br><span class="line">      *taller = FALSE;</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(e &lt; (*T) -&gt; data) &#123;<span class="comment">// 应继续在 T 的左子树中进行搜索</span></span><br><span class="line">      <span class="keyword">if</span>(!InsertAVL(&amp;(*T) -&gt; lchild, e, taller))<span class="comment">// 未插入</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">      <span class="keyword">if</span>(taller) &#123;<span class="comment">// 已插入到 T 的左子树中且左子树“长高”</span></span><br><span class="line">        <span class="keyword">switch</span>((*T) -&gt; bf) &#123;<span class="comment">//检查 T 的平衡度</span></span><br><span class="line">          <span class="keyword">case</span> LH:<span class="comment">// 原本左子树比右子树高，需要作左平衡处理</span></span><br><span class="line">            LeftBalance(T);</span><br><span class="line">            *taller = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> EH:<span class="comment">// 原本左右子树等高，现因左子树增高而树增高</span></span><br><span class="line">            (*T) -&gt; bf = LH;</span><br><span class="line">            *taller = TRUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> RH:<span class="comment">// 原本右子树比左子树高，现左右子树等高</span></span><br><span class="line">            (*T) -&gt; bf = EH;</span><br><span class="line">            *taller = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 应继续在 T 的右子树中进行搜索</span></span><br><span class="line">      <span class="keyword">if</span>(!InsertAVL(&amp;(*T) -&gt; rchild, e, taller))<span class="comment">// 未插入</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">      <span class="keyword">if</span>(*taller) &#123;<span class="comment">// 已插入到 T 的右子树且右子树“长高”</span></span><br><span class="line">        <span class="keyword">switch</span>((*T) -&gt; bf) &#123;<span class="comment">// 检查 T 的平衡度</span></span><br><span class="line">          <span class="keyword">case</span> LH:<span class="comment">// 原本左子树比右子树高，现左、右子树等高</span></span><br><span class="line">            (*T) -&gt; bf = EH;</span><br><span class="line">            *taller = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> EH:<span class="comment">// 原本右右子树等高，现因右子树增高而树增高</span></span><br><span class="line">            (*T) -&gt; bf = RH;</span><br><span class="line">            *taller = TRUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> RH:<span class="comment">// 原本右子树比左子树高，需要作右平衡处理</span></span><br><span class="line">            RightBalance(T);</span><br><span class="line">            *taller = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成一棵平衡二叉树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>,  <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">BiTree T = <span class="literal">NULL</span>;</span><br><span class="line">Status taller;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  InsertAVL(&amp;T, a[i], &amp;taller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要查找的集合本身没有顺序，在频繁查找的同时也需要经常的插入和删除操作，显然需要构建一棵二叉排序树，但是不平衡的二叉排序树，查找效率是非常低的，因此需要在构建时，就让这棵二叉排序树是平衡二叉树，此时的查找时间复杂度就为 O(logn)，而插入和删除也为 O(logn)。显然这是比较理想的一种动态查找表算法。</p><h3 id="多路查找树-B-树"><a href="#多路查找树-B-树" class="headerlink" title="多路查找树 (B 树)"></a>多路查找树 (B 树)</h3><p><strong>多路查找树 (muitl-way search tree)，其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素</strong>。由于它是查找树，所有元素之间存在某种特定的排序关系。</p><h4 id="2-3-树"><a href="#2-3-树" class="headerlink" title="2-3 树"></a>2-3 树</h4><p>**2-3 树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子 (称它为 2 结点) 或三个孩子 (称它为 3 结点)**。</p><p><strong>一个 2 结点包含一个元素和两个孩子或没有孩子</strong>，且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。不过，与二叉排序树不同的是，这个 2 结点要么没有孩子，要有就有两个，不能只有一个孩子。</p><p><strong>一个 3 结点包含一小一大两个元素和三个孩子或没有孩子</strong>，一个 3 结点要么没有孩子，要么具有 3 个孩子。如果某个 3 结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。</p><p>并且 2-3 树中所有的叶子都在同一层次上。事实上，2-3 树复杂的地方就在于新结点的插入和已有结点的删除。毕竟，每个结点可能是 2 结点也可能是 3 结点，要保证所有叶子都在同一层次，是需要进行一番复杂操作的。</p><p><img src="/../img/dsa/2-3%E6%A0%91.png" alt="2-3树"></p><ul><li><p><strong>2-3树的插入实现</strong></p><p>  对于 2-3 树的插入来说，与二叉排序树相同，插入操作一定是发生在叶子结点上。可与二叉排序树不同的是，2-3 树插入一个元素的过程有可能会对该树的其余结构产生连锁反应。</p><p>  2-3 树插入可分为三种情况：</p><ol><li>对于空树，插入一个 2 结点即可。</li><li>插入结点到一个 2 结点的叶子上。应该说，由于其本身就只有一个元素，所以只需要将其升级为 3 结点即可。</li><li>要往 3 结点中插入一个新元素。因为 3 结点本身已经是 2-3 树的结点最大容量 (已经有两个元素)，因此就需要将其拆分，且将树中两元素或插入元素的三者中选择其一向上移动一层。复杂的情况也正在于此。</li></ol></li><li><p><strong>2-3 树的删除实现</strong></p><p>  2-3 树的删除也分为三种情况</p><ol><li>所删除元素位于一个 3 结点的叶子结点上，只需要在该结点处删除该元素即可，不会影响到整棵树的其他结点结构。</li><li>所删除的元素位于一个 2 结点上，即要删除的是一个只有一个元素的结点。对于删除叶子是 2 结点的情况，需要分四种情形来处理。<ul><li>此结点的双亲也是 2 结点，且拥有一个 3 结点的右孩子。</li><li>此结点的双亲是 2 结点，它的右孩子也是 2 结点。</li><li>此结点的双亲是一个 3 结点。</li><li>如果当前树是一个满二叉树的情况，此时删除任何一个叶子都会使得整棵树不能满足 2-3 树的定义。</li></ul></li><li>所删除的元素位于非叶子的分支结点。 通常是将树按中序遍历后得到此元素的前驱或后继元素，考虑让它们来补位即可。</li></ol></li><li><p><strong>2-3-4 树</strong></p><p>  <strong>2-3-4 树就是 2-3 树的概念扩展，包括了 4 结点的使用。一个 4 结点包含小中大三个元素和四个孩子或没有孩子</strong>，一个 4 结点要么没有孩子，要么具有 4 个孩子。如果某个 4 结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素。</p></li></ul><h4 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h4><p><strong>B 树 (B Tree) 是一种平衡的多路查找树，2-3 树和 2-3-4 树都是 B 树的特例。结点最大的孩子数目称为 B 树的阶 (order)，因此，2-3 树是 3 阶 B 树，2-3-4 树是 4 阶 B 树。</strong></p><p>一个 m 阶的 B 树具有如下属性：</p><ul><li>如果根结点不是叶结点，则其至少有两棵子树。</li><li>每一个非根的分支结点都有 k - 1 个元素和 k 个孩子，其中 (m &#x2F; 2) ≤ k ≤ m。每一个叶子结点 n 都有 k - 1 个元素，其中 (m &#x2F; 2) ≤ k ≤ m。</li><li>所有叶子结点都位于同一层次。</li><li>所有分支结点包含下列信息数据 (n, A<sub>0</sub>, K<sub>1</sub>, A<sub>1</sub>, K<sub>2</sub>, A<sub>2</sub>, ···, K<sub>n</sub>, A<sub>n</sub>)，其中：K<sub>i</sub> (i &#x3D; 1, 2, ……, n) 为关键字，且 K<sub>i</sub> &lt; K<sub>i + 1</sub> (i &#x3D; 1, 2, ···， n-1)；A<sub>i</sub> (i &#x3D; 0, 2, ···, n-1)；A<sub>i</sub> (i &#x3D; 0, 2, ···, n) 为指向子树根结点的指针，且指针 A<sub>i - 1</sub> 所指子树中所有结点的关键字均小于 K<sub>i</sub> (i &#x3D; 1, 2, ……, n)，A<sub>n</sub> 所指子树中所有结点的关键字均大于 K<sub>n</sub>，n · ((m &#x2F; 2) - 1 ≤ n ≤ m - 1) 为关键字的个数或 n + 1 为子树的个数。</li></ul><h4 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h4><p>B+ 树适应文件系统所需而出的一种 B 树的变形树。在 B 树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在 B+ 树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者 (叶子结点) 中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针。</p><p>一棵 m 阶的 B+ 树和 m 阶的 B 树的差异在于：</p><ul><li>有 n 棵子树的结点中包含有 n 个关键字；</li><li>所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接；</li><li>所有分支结点可以看成是索引，结点中仅含有其子树中的最大或最小关键字。</li></ul><p>这样的数据结构最大的好处就在于，如果是要随机查找，就从根结点出发，与 B 树的查找方式相同，只不过即使在分支结点找到了待查找的关键字，它也只是用来索引的，不能提供实际记录的访问，还是需要到达包含此关键字的终端结点。</p><p>如果是需要从最小关键字进行从小到大的顺序查找，就可以从最左侧的叶子结点出发，不经过分子结点，而是延着指向下一叶子的指针就可遍历所有的关键字。</p><p>B+ 树的结构特别适合带有范围的查找。B+ 树的插入、删除过程也都与 B 树类似，只不过插入和删除的元素都是在叶子结点上进行而已。</p><h3 id="散列表查找-哈希表-概述"><a href="#散列表查找-哈希表-概述" class="headerlink" title="散列表查找 (哈希表) 概述"></a>散列表查找 (哈希表) 概述</h3><h4 id="散列表查找定义"><a href="#散列表查找定义" class="headerlink" title="散列表查找定义"></a>散列表查找定义</h4><p>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得每个关键字 key 对应一个存储位置 f(key)。查找时，根据这个确定的对应关系找到给定值 key 的映射 f(key)，若查找集合中存在这个记录，则必定在 f(key) 的位置上。</p><p>这里把这种对应<strong>关系 f 称为散列函数，又称为哈希 (Hash) 函数</strong>。按这个思想，**采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表 (Hash Table)**。那么关键字对应的记录存储位置称为散列地址。</p><h4 id="散列表查找步骤"><a href="#散列表查找步骤" class="headerlink" title="散列表查找步骤"></a>散列表查找步骤</h4><p>整个散列过程其实就是两步。</p><ol><li>在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。</li><li>当查找记录时，通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。</li></ol><p>所以说，<strong>散列技术即是一种存储方法，也是一种查找方法</strong>。然而它与线性表、树、图等结构不同的是，前面几种结构，数据元素之间都存在某种逻辑关系，可以用连线图示表示出来，而散列技术的记录之间不存在什么逻辑关系，它只与关键字有关联。因此，散列主要是面向查找的存储结构。</p><p><strong>散列技术最适合的求解问题是查找与给定值相等的记录</strong>。对于查找来说，简化了比较过程，效率就会大大提高。</p><p>在理想情况下，每一个关键字，通过散列函数计算出来的地址都是不一样的，可现实中，这只是一个理想。时长会碰到**两个关键字 key<sub>1</sub> ≠ key<sub>2</sub>，但是却有 f(key<sub>1</sub>) &#x3D; f(key<sub>2</sub>)，这种现象称为冲突 (collision)，并把 key<sub>1</sub> 和 key<sub>2</sub> 称为这个散列函数的同义词 (synonym)**。出现了冲突当然非常糟糕，那将造成数据查找错误。</p><h3 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h3><p>什么才算是好的散列函数？</p><ol><li><p><strong>计算简单</strong></p><p> 设计一个算法可以保证所有的关键字都不会产生冲突，但是这个算法需要很复杂的计算，会耗费很多时间，这对于需要频繁地查找来说，就会大大降低查找的效率了。因此散列函数的计算时间不应超过其他查找技术与关键字比较的时间。</p></li><li><p><strong>散列地址分布均匀</strong></p><p> 解决冲突最好的办法就是尽量让散列地址均匀地分布在存储空间中，这样可以保证存储空间的有效利用，并减少为处理冲突而耗费的时间。</p></li></ol><p>几种常用的散列函数构造方法：</p><h4 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h4><p><strong>取关键字的某个线性函数值为散列地址</strong>。即</p><p><code>f(key) = a × key + b (a、b 为常数)</code></p><p>这样的散列函数优点就是检点、均匀，也不会产生冲突，但问题是这需要事先知道此关键字的分布情况，适合查找表较小且连续的情况。由于这样的限制，在显示应用中，此方法虽然简单，但却并不常用。</p><h4 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h4><p>如果关键字是位数较多的数字，比如 11 位手机号 “131xxxx1234”，其中前三位是接入号，一般对应不同运营商公司的子品牌，如 130 是连通如意通、136 是移动神州行、153 是电信等；中间四位是 HLR 识别号，表示用户号的归属地；后四位才是真正的用户号。</p><p>若现在要存储某家公司员工登记表，如果用手机号作为关键字，那么极有可能前 7 位都是相同的。那么选择后面的四位称为散列地址就是不错的选择。如果这样的抽取工作还是容易出现冲突，还可以对抽取出来的数字在进行反转 (如 1234 改成 4321)、右环位移 (如 1234 改成 4123)、左环位移、甚至前两数与后两数叠加 (如 1234 改成 12 + 34 &#x3D; 46) 等方法。总的目的就是为了提供一个散列函数，能能够合理地将关键字分配到散列表的各位置。</p><p>这里提到了一个关键词——抽取。抽取方法是使用关键字的一部分来计算散列存储位置的方法，这在散列函数中是常常用到的手段。</p><p>数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干分布比较均匀，就可以考虑用这个方法。</p><h4 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h4><p>这个方法计算很简单，假设关键字是 1234，那么它的平方就是 1522756，再抽取中间的 3 位就是 227，用做散列地址。再比如关键字是 4321，那么它的平方就是 18671041，抽取中间的 3 位就可以是 671，也可以是 710，用做散列地址。平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况。</p><h4 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h4><p>折叠法是将关键字从左到右分割成位数相等的几部分 (注意最后一部分位数不够时可以短些)，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。</p><p>比如关键字是 9876543210，散列表表长为三位，将它分为四组，987｜654｜321｜0，然后将它们叠加求和 987 + 654 + 321 + 0 &#x3D; 1962，在求后 3 位得到散列地址为 962。</p><p>有时可能这还不能保证分布均匀，不妨从一端向另一端来回折叠后对齐相加。比如将 987 和 321 反转，再与 654 和 0 相加，变成 789 + 654 + 123 + 0 &#x3D; 1566，此时散列地址为 566。</p><p>折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。</p><h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><p>此方法为最常用的构造散列函数方法。对于散列表长为 m 的散列函数公式为：</p><p><code>f(key) = key mod p (p ≤ m)</code></p><p>mod 是取模 (求余数) 的意思。事实上，这方法不仅可以对关键字直接取模，也可以在折叠、平方取中后再取模。</p><p>很显然，本方法的关键就在于选择合适的 p，p如果选得不好，就可能会容易产生同义词。</p><p>根据经验，若散列表表长为 m，通常 p 为小于或等于表长 (最好接近 m) 的最小质数或不包含小于 20 质因子的合数。</p><h4 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h4><p>选择一个随机数，取关键字的随机函数值为它的散列地址。也就是 f(key) &#x3D; random(key)。这里 random 是随机函数。当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。</p><p>总之，现实中，应该视不同的情况采用不同的散列函数。通过综合以下因素，可以决策选择哪种散列函数更合适。</p><ol><li>计算散列地址所需的时间。</li><li>关键字的长度。</li><li>散列表的大小。</li><li>关键字的分布情况。</li><li>记录查找的频率。</li><li>……</li></ol><h3 id="处理散列冲突的方法"><a href="#处理散列冲突的方法" class="headerlink" title="处理散列冲突的方法"></a>处理散列冲突的方法</h3><h4 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h4><p>所谓的<strong>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入</strong>。</p><p>它的公式是：</p><p><code>fi(key) = (f(key) + di) MOD m (di = 1, 2, 3, ……, m - 1)</code></p><p>解决冲突的开放定址法称为线性探测法。有时还会出现本来都不是同义词却需要争夺一个地址的情况，称这种现象为堆积。很显然，堆积的出现，使得我们需要不断处理冲突，无论是存入还是查找效率都会大大降低。</p><p><strong>增加平方运算的目的是为了不让关键字都聚集在某一块区域。称这种方法为二次探测法</strong>。</p><p><code>fi(key) = (f(key) + di) MOD m (di = 1, 1, 4, 4, ……, q^2, -q^2, q ≤ m / 2)</code></p><p>还有一种方法是，<strong>在冲突时，对于位移量 d<sub>i</sub> 采用随机函数计算得到，称之为随机探测法</strong>。</p><p>既然是随机，那么查找的时候不也随机生成 d<sub>i</sub> 吗？如果可以获得相同的地址？这里的随机其实是伪随机数。伪随机数是说，如果设置随机种子相同，则不断调用随机函数可以生成不会重复的数列，在查找时，用同样的随机种子，他每次得到的数列是相同的，相同的 d<sub>i</sub> 当然可以得到相同的散列地址。</p><p><code>fi(keyi) = (f(key) + di) MOD m (di 是一个随机数列)</code></p><p>总之，开放定址法只要在散列表未填满时，总是能找到不发生冲突的地址，是我们常用的解决冲突的方法。</p><h4 id="再散列函数法"><a href="#再散列函数法" class="headerlink" title="再散列函数法"></a>再散列函数法</h4><p>用买房子来举例，如果看房时的选择标准总是以市中心、交通便利、价格适中为指标，这样的房子凤毛麟角，基本上当你看到时，都已经被人买去了。</p><p>换一种思维，选择市郊的房子，交通尽管要差一些，但价格便宜很多，也许房子还可以买得大一些、质量好一些，并且由于更换了选房的想法，很快就找到了你需要的房子了。</p><p>对于散列表来说，事先准备多个散列函数。</p><p><code>fi(key) = RHi(key) (i = 1, 2, ···， k)</code></p><p>这里 RH<sub>i</sub> 就是不同的散列函数，可以把前面说的什么除留余数、折叠、平方取中全部用上。每当发生散列地址冲突时，就换一个散列函数计算，相信总会有一个可以把冲突解决掉。这种方法能够使得关键字不产生聚集，当然，相应地也增加了计算的时间。</p><h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>将所有关键字为同义词的记录存储在一个单链表中，称这种表为同义词字表，在散列表中只存储所有同义词字表的头指针。对于关键字集合 {12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34}，用 12 为除数，进行除留余数法，可得到如下图所示结构，此时，已经不存在什么冲突换址的问题，无论有多少个冲突，都只是在当前位置给单链表增加结点的问题。</p><p><img src="/../img/dsa/%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95.png" alt="链地址法"></p><p>链地址法给予可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保障。当然，这也就带来了查找时需要遍历单链表的性能损耗。</p><h4 id="公共溢出区法"><a href="#公共溢出区法" class="headerlink" title="公共溢出区法"></a>公共溢出区法</h4><p>这个方法其实就更好即理解，凡是冲突的都跟我走，我给你们这些冲突找个地呆着。这就如同孤儿院收留所有无家可归的孩子一样，我们为所有冲突的关键字建立了一个公共的溢出区来存放。</p><p>就前面的例子而言，共有三个关键字 {37, 48, 34} 与之前的关键字位置有冲突，那么就将它们存储到溢出表中，如下图。</p><p><img src="/../img/dsa/%E5%85%AC%E5%85%B1%E6%BA%A2%E5%87%BA%E5%8C%BA%E6%B3%95.png" alt="公共溢出区法"></p><p>在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功；如果不相等，则到溢出表去进行顺序查找。如果相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还时非常高的。</p><h3 id="散列表查找实现"><a href="#散列表查找实现" class="headerlink" title="散列表查找实现"></a>散列表查找实现</h3><h4 id="散列表查找算法实现"><a href="#散列表查找算法实现" class="headerlink" title="散列表查找算法实现"></a>散列表查找算法实现</h4><p>首先需要定义一个散列表的结构以及一些相关的常数。其中 HashTable 就是散列表结构。结构当中的 elem 为一个动态数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASHSIZE 12<span class="comment">// 定义散列表长为数组的长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULLKEY -32768</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> *elem;<span class="comment">// 数据元素存储基址，动态分配数组</span></span><br><span class="line">  <span class="type">int</span> count;<span class="comment">// 当前数据元素个数</span></span><br><span class="line">&#125;HashTable;</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;<span class="comment">// 散列表表长，全局变量</span></span><br></pre></td></tr></table></figure><p>有了结构的定义，可以对散列表进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化散列表 */</span></span><br><span class="line">Status <span class="title function_">InitHashTable</span><span class="params">(HashTable *H)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  m = HASHSIZE;</span><br><span class="line">  H -&gt; count = m;</span><br><span class="line">  H -&gt; elem = (<span class="type">int</span> *)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    H -&gt; elem[i] = NULLKEY;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了插入时计算地址，需要定义散列函数，散列函数可以根据不同情况更改算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 散列函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> key % m;<span class="comment">// 除留余数法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化完成后，可以对散列表进行插入操作。设计插入的关键字集合就是前面的 {12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34}。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入关键字进行散列表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertHash</span><span class="params">(HashTable *H, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> addr = Hash(key);<span class="comment">// 求散列地址</span></span><br><span class="line">  <span class="keyword">while</span>(H -&gt; elem[addr] != NULLKEY)<span class="comment">// 如果不为空，则冲突</span></span><br><span class="line">    addr = (addr + <span class="number">1</span>) % m;<span class="comment">// 开放定址法的线性探测</span></span><br><span class="line">  H -&gt; elem[addr] = key;<span class="comment">// 直到有空位后插入关键字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中插入关键字时，首先算出散列地址，如果当前地址不为空关键字，则说明有冲突。此时应用开放定址法的线性探测进行重新寻址，此处也可更改为链地址法等其它解决冲突的办法。</p><p>散列表存在后，在需要时就可以通过散列表查找要的记录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 散列表查找关键字 */</span></span><br><span class="line">Status <span class="title function_">SearchHash</span><span class="params">(HashTable H, <span class="type">int</span> key, <span class="type">int</span> *addr)</span> &#123;</span><br><span class="line">  *addr = Hash(key);<span class="comment">// 求散列地址</span></span><br><span class="line">  <span class="keyword">while</span>(H.elem[*addr] != key) &#123;<span class="comment">// 如果不为空，则冲突</span></span><br><span class="line">    *addr = (*addr + <span class="number">1</span>) % m;<span class="comment">// 开放定址法的线性探测</span></span><br><span class="line">    <span class="keyword">if</span>(H.elem[*addr] == NULLKEY || *addr == Hash(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> UNSUCCESS;<span class="comment">// 则说明关键字不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找的代码与插入的代码非常相似，只需做一个不存在关键字的判断而已。</p><h4 id="散列表查找性能分析"><a href="#散列表查找性能分析" class="headerlink" title="散列表查找性能分析"></a>散列表查找性能分析</h4><ol><li><p><strong>散列函数是否均匀</strong></p><p> 散列函数的好坏直接影响着出现冲突的频繁程度，不过，由于不同的散列函数对同一组随机的关键字，产生冲突的可能性是相同的，因此我们可以不考虑它对平均查找长度的影响。</p></li><li><p><strong>处理冲突的方法</strong></p><p> 相同的关键字、相同的散列函数，但处理冲突的方法不同，会是的平均查找长度不同。比如线性探测处理冲突可能会产生堆积，显然就没有二次探测法好，而链地址法处理冲突不会产生任何堆积，因而具有更佳的平均查找性能。</p></li><li><p><strong>散列表的装填因子</strong></p><p> 所谓的装填因子 𝛂 &#x3D; 填入表中的记录个数 &#x2F; 散列表长度。𝛂 标志着散列表的装满的程度。当填入表中的记录越多，𝛂 就越大，产生冲突的可能性就越大。比如前面的例子，如果你的散列表长度是 12，而填入表中的记录个数为 11，那么此时的装填因子 𝛂 &#x3D; 11 &#x2F; 12 &#x3D; 0.9167，再填入最后一个关键字产生冲突的可能性就非常之大。也就是说，散列表的平均查找长度取决于装填因子，而不是取决于查找集合中的记录个数。</p><p> 不管记录个数 n 有多大，我们总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围之内，此时我们散列查找的时间复杂度就真的是 O(1) 了。为了做到这一点，通常我们都是将散列表的空间设置得比查找集合大，此时虽然是浪费了一定的空间，但换来的是查找效率的大大提升，总的来说，还是非常值得的。</p></li></ol><h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><p>这一章的主题是 “查找” 。</p><p>首先，弄清楚查找表、记录、关键字、主关键字、静态查找表、动态查找表等概念。</p><p>然后，对于顺序表查找来说，尽管很简单，但它却是后面很多查找的基础，注意设置“哨兵”的技巧，可以使得本已经很难提升的算法里还是提高了性能。</p><p>有序查找，着重折半查找的思想，它在性能上比原来的顺序查找有了质的飞跃，由 O(n) 变成了 O(logn)。接着映出了两种优秀的有序查找：插值查找和斐波那契查找，它们三者各有优缺点。</p><p>线性索引查找，介绍了稠密索引、分块索引和倒排索引。索引技术被广泛的用于文件检索、数据库和搜索引擎等技术领域，是进一步学习这些技术的基础。</p><p>二叉排序树是动态查找最重要的数据结构，他可以在兼顾查找性能的基础上，让插入和删除也变得效率较高。不过为了达到最优的状态，二叉排序树是构造成平衡的二叉树才最佳。因此需要在学习关于平衡二叉树的数据结构，了解 AVL 树是如何处理平衡性的问题。</p><p>B 树这种数据结构是针对内存与外存之间的存取而专门设计的。由于内外存的查找性能更多取决于读取的次数，因此在设计中要考虑 B 树的平衡和层次。先通过最简单的 2-3 树来理解如果构建、插入、删除元素的操作，再通过 2-3-4 树的深化，最终来理解 B 树的原理，之后 介绍了 B+ 树的设计思想。</p><p>散列表是一种非常搞笑的查找数据结构，在原理上也与前面的查找不尽相同，它回避了关键字之间反复比较的繁琐，而是直接一步到位查找结果。当然，这也就带来了记录之间没有任何关联的弊端。应该说，散列表对于那种查找性能要求高，记录之间关系无要求的数据有非常好的适用性。在学习中要注意的是散列函数的选择和处理冲突的方法。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="排序的基本概念与分类"><a href="#排序的基本概念与分类" class="headerlink" title="排序的基本概念与分类"></a>排序的基本概念与分类</h3><blockquote><p>假设含有 n 个记录的序列为 {r<sub>1</sub>, r<sub>2</sub>, ···, r<sub>n</sub>}，其相应的关键字分别为 {k<sub>1</sub>, k<sub>2</sub>, ···, k<sub>n</sub>}，需确定 1，2，……，n 的一种排列 p<sub>1</sub>, p<sub>2</sub>, ···, p<sub>n</sub>，使其相应的关键字满足 k<sub>p1</sub> ≤ k<sub>p2</sub> ≤ …… ≤ k<sub>pn</sub> (非递减或递增) 关系，即使得序列成为一个按关键字有序的序列{r<sub>p1</sub>, r<sub>p2</sub>, ···, r<sub>pn</sub>}，这样的操作就称为排序。</p></blockquote><p>注意在排序问题中，通常将数据元素成为记录。显然输入的是一个记录集合，输出的也是一个记录集合，所以说，可以将排序看成是线性表的一种操作。</p><p>排序的一句是关键字之间的大小关系，那么，对于一个记录集合，针对不同的关键字进行排序，可以得到不同序列。</p><h4 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h4><p>也正是由于排序不仅是针对主关键字，那么对于次关键字，因为待排序的记录序列中可能存在两个或两个以上的关键字相等的记录，排序结果可能会存在不唯一的情况，给出了稳定与不稳定排序的定义。</p><p><strong>假设 k<sub>i</sub> &#x3D; k<sub>j</sub> (1 ≤ i ≤n, 1 ≤ j ≤ n, i ≠ j)，且在排序前的序列中 r<sub>i</sub> 领先于 r<sub>j</sub> (即 i &lt; j)。如果排序后 r<sub>i</sub> 仍领先于 r<sub>j</sub>，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中 r<sub>j</sub> 领先 r<sub>i</sub> ，则称所用的排序方法是不稳定的</strong>。</p><h4 id="内排序与外排序"><a href="#内排序与外排序" class="headerlink" title="内排序与外排序"></a>内排序与外排序</h4><p>根据在排序过程中待排序的记录是否全部被放置在内存中，排序分为：内排序和外排序。</p><p><strong>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行</strong>。</p><p>对于内排序来说，排序算法的性能主要是受 3 个方面影响：</p><ol><li><p><strong>时间性能</strong></p><p> 排序是数据处理中经常执行的一种操作，往往属于系统的核心部分，因此排序算法的时间开销是衡量其好坏的最重要的标志。在内排序中，主要进行两种操作：比较和移动。比较指关键字之间的比较，这是要做排序最起码的操作。移动指记录从一个位置移动到另一个位置，事实上，移动可以通过改变记录的存储方式来予以避免。总之，搞笑路的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。</p></li><li><p><strong>辅助空间</strong></p><p> 评价排序算法的另一个主要标准是执行算法所需要的辅助存储空间。辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。</p></li><li><p><strong>算法的复杂性</strong></p><p> 注意这里指的是算法本身的复杂度，而不是指算法的时间复杂度。显然算法过于复杂也会影响排序的性能。</p><p> 根据排序过程中截住的主要操作，把<strong>内排序分为：插入排序、交换排序、选择排序和归并排序</strong>。可以说，这些都是比较成熟的排序技术，已经被广泛地应用于许多的程序语言或数据库当中，甚至他们都已经封装了关于排序算法的实现代码。因此，学习这些排序算法的目的更多并不是为了去在现实中编程排序算法，而是通过学习来提升我们编写算法的能力，以便于去解决更多复杂和灵活的应用性问题。</p></li></ol><h4 id="排序用到的结构与函数"><a href="#排序用到的结构与函数" class="headerlink" title="排序用到的结构与函数"></a>排序用到的结构与函数</h4><p>为了讲清楚排序算法的代码，先提供一个用于排序用的顺序表结构，此结构也将用于之后的所有排序算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 10<span class="comment">// 用于要排序数组个数最大值，可根据需要修改</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> r[MAXSIZE + <span class="number">1</span>];<span class="comment">// 用于存储要排序数组，r[0] 用作哨兵或临时变量</span></span><br><span class="line">  <span class="type">int</span> length;<span class="comment">// 用于记录顺序表的长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>另外，由于排序最长用到的操作是数组两元素的交换，将它写成函数，在之后会大量用到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 交换 L 中数组 r 的下标为 i 和 j 的值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(SqList *L, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">  <span class="type">int</span> temp = L -&gt; r[i];</span><br><span class="line">  L -&gt; r[i] = L -&gt; r[j];</span><br><span class="line">  L -&gt; r[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="最简单排序实现"><a href="#最简单排序实现" class="headerlink" title="最简单排序实现"></a>最简单排序实现</h4><p><strong>冒泡排序 (Bubble Sort) 一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止</strong>。冒泡的视线在细节上可以有很多变化，我们将分别就 3 中不同的冒泡实现代码，来讲解冒泡排序的思想。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作交换排序 (冒泡排序初级版) */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort0</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; L -&gt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt;= L -&gt; length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(L -&gt;r[i] &gt; L -&gt; r[j]) &#123;</span><br><span class="line">        swap(L, i, j);<span class="comment">// 交换 L -&gt; r[i] 与 L -&gt; r[j] 的值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort1</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; L -&gt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(j = L -&gt; length - <span class="number">1</span>; j &gt;= i; j--) &#123;<span class="comment">// 注意 j 是从后往前循环</span></span><br><span class="line">      <span class="keyword">if</span>(L -&gt; r[j] &gt; L -&gt; r[j +<span class="number">1</span>]) &#123;<span class="comment">// 若前者大于后者 (注意这里与上一算法差异)</span></span><br><span class="line">        swap(L, j, j + <span class="number">1</span>);<span class="comment">// 交换 L -&gt; r[j] 与 L -&gt; r[j + 1] 的值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="冒泡排序优化"><a href="#冒泡排序优化" class="headerlink" title="冒泡排序优化"></a>冒泡排序优化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作改进冒泡算法 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort2</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  Status flag = TRUE;<span class="comment">// flag 用来作为标记</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; L -&gt; length &amp;&amp; flag; i++) &#123;<span class="comment">// 若 flag 为 true 则退出循环</span></span><br><span class="line">    flag = FLASE;<span class="comment">// 初始化为 false</span></span><br><span class="line">    <span class="keyword">for</span>(j = L -&gt; length - <span class="number">1</span>; j &gt;= i; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span>(L -&gt; r[j] &gt; L -&gt; r[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(L, j, j + <span class="number">1</span>);<span class="comment">// 交换 L -&gt; r[j] 与 L -&gt; r[j + 1] 的值</span></span><br><span class="line">        flag = TRUE;<span class="comment">// 如果有数据交换，则 flag 为 true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码改动的关键就是在 i 变量的 for 循环中，增加了对 flag 是否为 true 的判断。经过这样的改进，冒泡排序在性能上就有了一些提升，可以避免因已经有序的情况下的无意义循环判断。</p><h4 id="冒泡排序复杂度分析"><a href="#冒泡排序复杂度分析" class="headerlink" title="冒泡排序复杂度分析"></a>冒泡排序复杂度分析</h4><p>分析一下他的时间复杂度。当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据最后改进的代码，可以推断出就是 n - 1 次的比较，没有数据交换，时间复杂度为 O(n)。当最坏的情况，即待排序表是逆序的情况，此时需要比较n(n - 1) &#x2F; 2 次，并作等数量级的记录移动。因此，总的时间复杂度为 O(n<sup>2</sup>)。</p><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><h4 id="简单选择排序算法"><a href="#简单选择排序算法" class="headerlink" title="简单选择排序算法"></a>简单选择排序算法</h4><p><strong>简单选择排序法 (Simple Selection Sort) 就是通过 n - i 次关键字间的比较，从 n - i + 1 个记录中选出关键字最小的记录，并和第 i (1 ≤ i ≤ n) 个记录交换之</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作简单选择排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j, min;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; L -&gt; length; i++) &#123;</span><br><span class="line">    min = i;<span class="comment">// 将当前下标定义为最小值下标</span></span><br><span class="line">    <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; L -&gt; length; j++) &#123;<span class="comment">// 循环之后的数据</span></span><br><span class="line">      <span class="keyword">if</span>(L -&gt; r[min] &gt; L -&gt; r[j])<span class="comment">// 如果有小于当前最小值的关键字</span></span><br><span class="line">        min = j;<span class="comment">// 将此关键字的下标赋值给 min</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i != min)<span class="comment">// 若 min 不等于 i，说明找到最小值，交换</span></span><br><span class="line">      swap(L, i, min);<span class="comment">// 交换 L -&gt; r[i] 与 L -&gt; r[min] 的值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单选择排序复杂度分析"><a href="#简单选择排序复杂度分析" class="headerlink" title="简单选择排序复杂度分析"></a>简单选择排序复杂度分析</h4><p>从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，第 i 躺排序需要进行 n - i 次关键字的比较，此时需要比较 n(n - 1) &#x2F; 2 次。而对于交换次数而言，当最好的时候，交换为 0 次，最差的时候，也就初始降序时，交换次数为 n - 1 次，基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为 O(n<sup>2</sup>)。</p><p>应该说，尽管与冒泡排序同为 O(n<sup>2</sup>)，但简单选择排序的性能上还是要优于冒泡排序。</p><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><h4 id="直接插入排序算法"><a href="#直接插入排序算法" class="headerlink" title="直接插入排序算法"></a>直接插入排序算法</h4><p><strong>直接插入排序 (Straight Insertion Sort) 的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增 1 的有序表</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作直接插入排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= L -&gt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(L -&gt; r[i] &lt; L -&gt; r[i - <span class="number">1</span>]) &#123;<span class="comment">// 需将 L -&gt; r[i] 插入有序子表</span></span><br><span class="line">      L -&gt; r[<span class="number">0</span>] = L -&gt; r[i];<span class="comment">// 设置哨兵</span></span><br><span class="line">      <span class="keyword">for</span>(j = i - <span class="number">1</span>; L -&gt; r[j] &gt; L -&gt; r[<span class="number">0</span>]; j--)</span><br><span class="line">        L -&gt; r[j + <span class="number">1</span>] = L -&gt; r[j];<span class="comment">// 记录后移</span></span><br><span class="line">      L -&gt; r[j + <span class="number">1</span>] = L -&gt; r[<span class="number">0</span>];<span class="comment">// 插入到正确位置</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="直接插入排序复杂度分析"><a href="#直接插入排序复杂度分析" class="headerlink" title="直接插入排序复杂度分析"></a>直接插入排序复杂度分析</h4><p>从空间上看，它只需要一个记录的辅助空间，因此关键是看它的时间复杂度。</p><p>当最好的情况下，也就是要排序的表本身就是有序的，因此没有移动的记录，时间复杂度为 O(n)。最坏的情况是待排序表是逆序的情况，此时需要比较(n + 2)(n - 1) &#x2F; 2 次，而记录的移动次数也达到最大值 (n + 4)(n - 1) &#x2F; 2 次。</p><p>如果排序记录是随机的，那么根据概率相同的原则，平均比较和移动次数约为 n<sup>2</sup> &#x2F; 4 次。因此，得出直接插入排序法的时间复杂度为 O(n<sup>2</sup>)。从这里也看出，同样的 O(n<sup>2</sup>) 时间复杂度，直接插入排序比冒泡和简单选择排序性能要好一些。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>在这之前的排序算法的时间复杂度基本都是 O(n<sup>2</sup>) 的，希尔排序算法是突破这个时间复杂度的第一批算法之一。</p><p>直接插入排序的效率在某些时候是很高的，比如，记录本身就是基本有序的，只需要少量的插入操作，就可以完成整个记录集的排序工作，此时直接插入很高效。还有就是记录数比较少时，直接插入的优势也比较明显。可问题在于，两个条件本身就过于苛刻，现实中记录少或者基本有序都属于特殊情况。</p><p>科学家希尔研究出一种排序算法，对直接插入排序改进后可以增加效率。为了让待排序的记录个数较少？将原本有大量记录数的记录进行分组。分割成若干个字序列，此时每个字序列待排序的记录个数就比较少了，然后在这些字序列内分别进行直接插入排序，当整个序列都基本有序时，注意只是基本有序时，再对全体记录进行一次直接插入排序。<strong>所谓基本有序，就是小的关键字基本在前，大的基本在后面，不大不小的基本在中间，像{2, 1, 3, 6 ,4, 7, 5, 8, 9}</strong> 这样可以成为基本有序。问题其实也在这里，分割待排序记录的目的是为了减少待排序记录的个数，并使整个序列项基本有序发展。然后有些时候分完组后就各自排序的方法达不到要求。因此，需要采取跳跃分割的策略：<strong>将相距某个”增量“的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序</strong>。</p><h4 id="希尔排序算法"><a href="#希尔排序算法" class="headerlink" title="希尔排序算法"></a>希尔排序算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作希尔排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="type">int</span> increment = L -&gt; length;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    increment = increment / <span class="number">3</span> + <span class="number">1</span>;<span class="comment">// 增量序列</span></span><br><span class="line">    <span class="keyword">for</span>(i = increment + <span class="number">1</span>; i &lt;= L -&gt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(L -&gt; r[i] &lt; L -&gt; r[i - increment]) &#123;<span class="comment">// 需将 L -&gt; r[i] 插入有序增量字表</span></span><br><span class="line">        L -&gt; r[<span class="number">0</span>] = L -&gt; r[i];<span class="comment">// 暂存在 L -&gt; r[0]</span></span><br><span class="line">        <span class="keyword">for</span>(j = i - increment; j &gt; <span class="number">0</span> &amp;&amp; L -&gt; r[<span class="number">0</span>] &lt; L -&gt; r[j]; j -= increment)</span><br><span class="line">          L -&gt; r[j + increment] = L -&gt; r[j];<span class="comment">// 记录后移，查找插入位置</span></span><br><span class="line">        L -&gt; r[j + increment] = L -&gt; r[<span class="number">0</span>];<span class="comment">// 插入</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(increment &gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="希尔排序复杂度分析"><a href="#希尔排序复杂度分析" class="headerlink" title="希尔排序复杂度分析"></a>希尔排序复杂度分析</h4><p>通过这段代码的剖析，希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个字序列，实现跳跃式的移动，使得排序的效率提高。</p><p>这里的“增量”的选取就非常关键了。可究竟应该选取什么样的增量才是最好的，目前还是一个数学难题，迄今为止还没有人找到一个最好的增量序列。不过大量的研究表明，当增量序列为 dlta[k] &#x3D; 2<sup>t - k + 1</sup> - 1 (0 ≤ k ≤ t ≤ log<sub>2</sub>(n + 1)) 时，可以获得不错的效率，其时间复杂度为 O(n<sup>3 &#x2F; 2</sup>)，要好于直接排序的 O(n<sup>2</sup>)。需要注意的是，<strong>增量序列的最后一个增量值必须等于 1 才行</strong>。另外由于记录是跳跃式的移动，希尔排序并不是一种稳定的排序算法。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>简单选择排序，它在待排序的的 n 个记录中选择最小的记录需要比较 n - 1 次。可惜的是，这样的操作并没有把每一趟的比较结果保存下来，在后一趟的比较中，有许多比较在前一趟已经做过了，但由于前一趟排序时未保存这些比较结果，所以以后一趟排序时又重复执行了这些比较操作，因而记录的比较次数较多。</p><p>如果可以做到每次在选择到最小记录的同时，并根据比较结果对其他记录做出相应的调整，那样排序的总体效率就会非常高了。而堆排序 (Heap Sort)，就是对简单选择排序进行的一种改进，这种改进的效果是非常明显的。堆排序算法是 Floyd 和 Williams 在 1964 年共同发明的，同时，他们发明了 ”堆“ 这样的数据结构。</p><p><strong>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</strong>。</p><h4 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h4><p><strong>堆排序 (Heap Sort)</strong> 就是利用堆 (假设利用大顶堆) 进行排序的方法。它的基本思想是，<strong>将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走 (其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的 n - 1 个序列重新构造成一个堆，这样就会得到 n 个元素中的次小值。如果反复执行，便能得到一个有序序列了</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 进行堆排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = L -&gt; length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)<span class="comment">// 把 L 中的 r 构建成一个大顶堆</span></span><br><span class="line">    HeapAdjust(L, i, L -&gt; length);</span><br><span class="line">  <span class="keyword">for</span>(i = L -&gt; length; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">    swap(L, <span class="number">1</span>, i);<span class="comment">// 将堆顶记录和当前未经排序字序列的最后一个记录交换</span></span><br><span class="line">    HeapAdjust(L, <span class="number">1</span>, i - <span class="number">1</span>);<span class="comment">// 将 L -&gt; r[1..i - 1] 重新调整为大顶堆</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，整个排序过程分为两个 for 循环。第一个循环要完成的就是将现在的待排序序列构建成一个大顶堆。第二个循环要完成的就是逐步将每个最大值的根结点与末尾元素交换，并且再调整其成为大顶堆。</p><p>假设要排序的序列是 {50, 10, 90, 30, 70, 40, 80, 60, 20}，那么 L.length &#x3D; 9，第一个 for 循环，代码第 4 行，i 是从 9 &#x2F; 2 &#x3D; 4 开始，4 → 3 → 2 → 1 的变量变化。为什么不是从 1 到 9 或者从 9 到 1，而是从 4 到 1 呢？看了下图就明白了，他们都是有孩子的结点。注意灰色结点的下标编号就是 1、2、3、4。</p><p><img src="/../img/dsa/%E5%A0%86%E6%8E%92%E5%BA%8F.png" alt="堆排序"></p><p>所谓的将待排序的序列构建称为一个大顶堆，其实就是从下往上、从右到左，将每个非终端结点 (非叶结点) 当作根结点，将其和其子树调整成大顶堆。i 的 4 → 3 → 2 → 1 的变量变化，其实也就是 30，90，10，50 的结点调整过程。</p><p>既然已经弄清楚 i 的变化是在调整哪些元素了，现在来看关键的 HeadAdjust (堆调整) 函数是如何实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 已知 L -&gt; r[s..m] 中记录的关键字除 L -&gt;r[s] 之外均满足堆的定义 */</span></span><br><span class="line"><span class="comment">/* 本函数调整 L -&gt; r[s] 的关键字，使 L -&gt; r[s..m] 成为一个大顶堆 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapAdjust</span><span class="params">(SqList *L, <span class="type">int</span> s, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">  <span class="type">int</span> temp, j;</span><br><span class="line">  temp = L -&gt; r[s];</span><br><span class="line">  <span class="keyword">for</span>(j = <span class="number">2</span> * s; j &lt;= m; j *= <span class="number">2</span>) &#123;<span class="comment">// 沿关键字较大的孩子结点向下筛选</span></span><br><span class="line">    <span class="keyword">if</span>(j &lt; m &amp;&amp; L -&gt; r[j] &lt; L -&gt; r[j + <span class="number">1</span>])</span><br><span class="line">      ++j;<span class="comment">// j 为关键字中较大的记录的下标</span></span><br><span class="line">    <span class="keyword">if</span>(temp &gt;= L -&gt; r[j])</span><br><span class="line">      <span class="keyword">break</span>;<span class="comment">// rc 应插入在位置 s 上</span></span><br><span class="line">    L -&gt; r[s] = L -&gt; r[j];</span><br><span class="line">    s = j;</span><br><span class="line">  &#125;</span><br><span class="line">  L -&gt; r[s] = temp;<span class="comment">// 插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆排序复杂度分析"><a href="#堆排序复杂度分析" class="headerlink" title="堆排序复杂度分析"></a>堆排序复杂度分析</h4><p>它的运行时间主要是消耗在初始构建堆和在重建堆时的反复筛选上。在构建堆的过程中，因为是完全二叉树从最下层最右边的非终端结点开始构建，将它与其孩子进行比较和若有必要的互换，对于每个非终端结点来说，其实最多进行两次比较和互换操作，因此整个构建堆的时间复杂度为 O(n)。</p><p>在正式排序时，第 i 次取堆顶记录重建堆需要用 O(logi) 的时间 (完全二叉树的某个结点到根结点的距离为 log<sub>2</sub>i + 1)，并且须要取 n - 1 次堆顶记录，因此，重建堆的时间复杂度为 O(nlogn)。</p><p>所以总体来说，堆排序的时间复杂度为 O(nlogn)。由于堆排序对原始记录的排序状态并不敏感，因此它无论是最好、最坏和平均时间复杂度均为 O(nlogn)。这在性能上显然要远远好过于冒泡、简单选择、直接插入的 O(n<sup>2</sup>) 的时间复杂度了。</p><p>空间复杂度上，它只有一个用来交换的暂存单元，也非常不错。不过由于记录的比较与交换是跳跃式进行，因此堆排序也是一种不稳定的排序方法。另外，由于初始构建堆所需的比较次数较多，因此，它并不适合待排序序列个数较少的情况。</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="归并排序算法"><a href="#归并排序算法" class="headerlink" title="归并排序算法"></a>归并排序算法</h4><p>“归并” 一词的中文含义就是合并、并入的意思，而在数据结构中的定义是将两个或两个以上的有序表组合成一个新的有序表。</p><p><strong>归并排序 (Merging Sort)</strong> 就是利用归并的思想实现的排序方法。它的原理是<strong>假设初始序列含有 n 个记录，则可与看成是 n 个有序的字序列，每个字序列的长度为 1，然后两两归并，得到 ⎡n&#x2F;2⎤ (⎡x⎤ 表示不小于 x 的最小整数) 个长度为 2 或 1 的有序字序列；再两两归并，……，如此重复，直至得到一个长度为 n 的有序序列为止，这种排序方法称为 2 路归并排序</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作归并排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  MSort(L -&gt; r, L -&gt; r, <span class="number">1</span>, L -&gt; length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了与前面的排序算法同意，用了同样的参数定义 SqList *L，由于归并排序实现需要用到递归调用，因此在外封装了一个函数。假设现在要对数组 {50, 10, 90, 30, 70, 40, 80, 60, 20}  进行排序，L.length &#x3D; 9。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将 SR[s..t] 归并排序为 TR1[s..t] */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MSort</span><span class="params">(<span class="type">int</span> SR[], <span class="type">int</span> TR1[], <span class="type">int</span> s, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">  <span class="type">int</span> m;</span><br><span class="line">  <span class="type">int</span> TR2[MAXSIZE + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span>(s == t)</span><br><span class="line">    TR1[s] = SR[s];</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    m = (s + t) / <span class="number">2</span>;<span class="comment">// 将 SR[s..t] 平分为 SR[s..m] 和 SR[m + 1..t]</span></span><br><span class="line">    MSort(SR, TR2, s, m);<span class="comment">// 递归将 SR[s..m] 归并为有序的 TR2[s..m]</span></span><br><span class="line">    MSort(SR, TR2, m + <span class="number">1</span>, t);<span class="comment">// 递归将 SR[m + 1..t] 归并为有序 TR2[m + 1..t]</span></span><br><span class="line">    Merge(TR2, TR1, s, m, t);<span class="comment">// 将 TR2[s..m] 和 TR2[m + 1..t] 归并到 TR1[s..t]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Merge 函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将有序的 SR[i..m] 和 SR[m + 1..n] 归并为有序的 TR[i..n] */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> SR[], <span class="type">int</span>. TR[], <span class="type">int</span> i, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j, k, l;</span><br><span class="line">  <span class="keyword">for</span>(j = m + <span class="number">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++) &#123;<span class="comment">// 将 SR 中记录由小到大并入 TR</span></span><br><span class="line">    <span class="keyword">if</span>(SR[i] &lt; SR[j])</span><br><span class="line">      TR[k] = SR[i++];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      TR[k] = SR[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i &lt;= m) &#123;</span><br><span class="line">    <span class="keyword">for</span>(l = <span class="number">0</span>; l &lt; = m - <span class="number">1</span>; l++) </span><br><span class="line">      TR[k + <span class="number">1</span>] = SR[i + <span class="number">1</span>];<span class="comment">// 将剩余的 SR[i..m] 复制到 TR</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(j &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">for</span>(l = <span class="number">0</span>; l &lt;= n - j; l++)</span><br><span class="line">      TR[k + l] = SR[j + l];<span class="comment">// 将剩余的 SR[j..n] 复制到 TR</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序复杂度分析"><a href="#归并排序复杂度分析" class="headerlink" title="归并排序复杂度分析"></a>归并排序复杂度分析</h4><p>分析归并排序的时间复杂度，一趟归并需要将 SR[1]<del>SR[n] 中相邻的长度为 h 的有序序列进行两两归并。并将结果放到 TR1[1]</del>TR1[n] 中，这需要将待排序序列中的所有记录扫描一遍，因此耗费 O(n) 时间，而由完全二叉树的深度可知，整个归并排序需要进行 ⎡log<sub>2</sub>n⎤次，因此，总的时间复杂度为 O(nlogn)，而且这是归并排序算法中最好、最坏、平均的时间性能。</p><p>由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为 log<sub>2</sub>n 的栈空间，因此空间复杂度 O(n + logn)。</p><p>另外，对代码进行仔细研究，发现 Merge 函数中有 if(SR[i] &lt; SR[j]) 语句，这就说明它需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。</p><p>也就是说，归并排序是一种比较占用内存，但却效率高且稳定的算法。</p><h4 id="非递归实现归并排序"><a href="#非递归实现归并排序" class="headerlink" title="非递归实现归并排序"></a>非递归实现归并排序</h4><p>归并排序大量引用了递归，尽管在代码上比较清晰，容易理解，但这会造成时间和空间上的性能损耗。排序追求的就是效率，有没有可能将递归转化成迭代呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作归并非递归排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort2</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span>* TR = (<span class="type">int</span>*)<span class="built_in">malloc</span>(L -&gt; length * <span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">// 申请额外空间</span></span><br><span class="line">  <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(k &lt; L -&gt; length) &#123;</span><br><span class="line">    MergePass(L -&gt; r, TR, k, L -&gt; length);</span><br><span class="line">    k = <span class="number">2</span> * k;<span class="comment">// 字序列长度加倍</span></span><br><span class="line">    MergePass(TR, L -&gt; r, k, L -&gt; length);</span><br><span class="line">    k = <span class="number">2</span> * k;<span class="comment">// 字序列长度加倍</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MergePass 实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将 SR[] 中相邻长度为 s 的子序列两两归并到 TR[] */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergePass</span><span class="params">(<span class="type">int</span> SR[], <span class="type">int</span> TR[], <span class="type">int</span> s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  <span class="keyword">while</span>(i &lt;= n - <span class="number">2</span> * s + <span class="number">1</span>) &#123;</span><br><span class="line">    Merge(SR, TRk i, i + s - <span class="number">1</span>, i + <span class="number">2</span> * s - <span class="number">1</span>);<span class="comment">// 两两归并</span></span><br><span class="line">    i = i + <span class="number">2</span> * s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i &lt; n -s + <span class="number">1</span>)<span class="comment">// 归并最后两个序列</span></span><br><span class="line">    Merge(SR, TR, i, i + s - <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">else</span><span class="comment">// 若最后只剩下单个子序列</span></span><br><span class="line">    <span class="keyword">for</span>(j = i; j &lt;= n; j++)</span><br><span class="line">      TR[j] = SR[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>快速排序 (Quick Sort) 的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的</strong>。</p><p>假设现在要对数组 {50, 10, 90, 30, 70, 40, 80, 60, 20} 进行排序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对顺序表 L 作快速排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  QSort(L, <span class="number">1</span>, L -&gt; length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QSort</span><span class="params">(SqList *L, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pivot;</span><br><span class="line">  <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">    pivot = Partition(L, low, high);<span class="comment">// 将 L -&gt; r[low..high] 一分为二，算出枢轴值 pivot</span></span><br><span class="line">    QSort(L, low, pivot - <span class="number">1</span>);<span class="comment">// 对低子表递归排序</span></span><br><span class="line">    QSort(L, pivot + <span class="number">1</span>, high);<span class="comment">// 对高子表递归排序</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里的 <code>QSort(L, 1, L -&gt; length);</code> 中 1 和 L -&gt; length 相当于当前待排序的序列最小下标值 low 和最大下标值 high。</p><p>这一段代码的核心是<code>pivot = Partition(L, low, high);</code> 在执行它之前，L.r 的数组值为 {50, 10, 90, 30, 70, 40, 80, 60, 20} 。<strong>Partition 函数要做的，就是先选取当中的一个关键字</strong>，比如选择第一个关键字 50，然后**想尽办法将它放到一个位置，使得它左边的值都比它小，右边的值比它大，将这样的关键字称为枢轴 (pivot)**。</p><p>Partition 函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 交换顺序表 L 中子表的记录，使枢轴记录到位，并返回其所在位置。此时在它之前 (后) 的记录均不大 (小) 于它 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(SqList *L, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pivotkey;</span><br><span class="line">  pivotkey = L -&gt; r[low];<span class="comment">// 用子表的第一个记录作枢轴记录</span></span><br><span class="line">  <span class="keyword">while</span>(low &lt; high) &#123;<span class="comment">// 从表的两端交替向中间扫描</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; L -&gt; r[high] &gt;= pivotkey)</span><br><span class="line">      high--;</span><br><span class="line">    swap(L, low, high);<span class="comment">// 将比枢轴记录小的记录交换到低端</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; L -&gt; r[low] &lt;= pivotkey)</span><br><span class="line">      low++;</span><br><span class="line">    swap(L, low, high);<span class="comment">// 将比枢轴记录大的记录交换到高端</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> low;<span class="comment">// 返回枢轴所在位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速排序复杂度分析"><a href="#快速排序复杂度分析" class="headerlink" title="快速排序复杂度分析"></a>快速排序复杂度分析</h4><p>快速排序的时间性能取决于快速排序递归的深度，可以用递归树来描述递归算法的执行情况。{50, 10, 90, 30, 70, 40, 80, 60, 20} 在快速排序过程中，第一个关键字是 50，正好是待排序的序列的中间值，因此递归树是平衡的，此时性能也比较好。如下图</p><p><img src="/../img/dsa/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.png" alt="快速排序复杂度分析"></p><p>在最优情况下，Partition 每次都划分得很均匀，如果排序 n 个关键字，其递归树的深度就为 ⎣log<sub>2</sub>n⎦+ 1 (⎣x⎦表示不大于 x 的最大整数)，即仅需递归 log<sub>2</sub>n 次，需要时间为 T(n) 的话，第一次 Partition 应该是需要对整个数组扫描一遍，作 n 次比较。然后，获得的枢轴将数组一分为二，那么各自还需要 T(n &#x2F; 2) 的时间 (注意是最好情况，所以平分两半)。于是不断地划分下去。也就是说，在最优的情况下，快速排序算法的时间复杂度为 O(nlogn)。</p><p>在最坏的情况下，待排序的序列为正序或逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。如果递归树画出来，他就是一棵斜树。此时需要执行 n - 1 次递归调用，且第 i 次划分需要经过 n - 1 次关键字的比较才能找到第 i 个记录，也就是枢轴的位置，因此比较次数为 n(n - 1) &#x2F; 2，最终其时间复杂度为 O(n<sup>2</sup>)。</p><p>平均的情况，设枢轴的关键字应该在第 k 的位置 (1 ≤ k ≤ n)，由数学归纳法可证明，其数量级为 O(nlogn)。</p><p>就空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归树的深度为 log<sub>2</sub>n，其空间复杂度也就为 O(logn)，最坏情况，需要进行 n - 1 递归调用，其空间复杂度为 O(n)，平均情况，空间复杂度也为 O(logn)。</p><p>可惜的是，由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。</p><h4 id="快速排序优化"><a href="#快速排序优化" class="headerlink" title="快速排序优化"></a>快速排序优化</h4><ol><li><p><strong>优化选取枢轴</strong></p><p> 三数取中 (median-of-three) 法。即取三个关键字先进性排序，将中间数作为枢轴，一般是取左端、右端和中间三个数，也可以随机选取。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pivotkey;</span><br><span class="line"><span class="type">int</span> m = low + (high - low) / <span class="number">2</span>;<span class="comment">// 计算数组中间的元素的下标</span></span><br><span class="line"><span class="keyword">if</span>(L -&gt; r[low] &gt; L -&gt; r[high])</span><br><span class="line">  swap(L, low, high);<span class="comment">// 交换左端与右端数据，保证左端较小</span></span><br><span class="line"><span class="keyword">if</span>(L -&gt; r[m] &gt; L -&gt; r[high])</span><br><span class="line">  swap(L, high, m);<span class="comment">// 交换中间与右端数据，保证中间较小</span></span><br><span class="line"><span class="keyword">if</span>(L -&gt; r[m] &gt; L -&gt; r[low])</span><br><span class="line">  swap(L, m, low);<span class="comment">// 交换中间与左端数据，保证左端较小。此时 L.r[low] 已经为整个序列左中右三个关键字的中间值</span></span><br><span class="line">piovtkey = L -&gt; r[low];</span><br></pre></td></tr></table></figure></li><li><p><strong>优化不必要的交换</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 快速排序优化算法 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition1</span><span class="params">(SqList *L, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pivotkey;</span><br><span class="line">  <span class="comment">// 这里省略三数取中代码</span></span><br><span class="line">  piovtkey = L -&gt; r[low];<span class="comment">// 用子表的第一个记录作枢轴记录</span></span><br><span class="line">  L -&gt; r[<span class="number">0</span>] = pivotkey;<span class="comment">// 将枢轴关键字备份到 L -&gt; r[0]</span></span><br><span class="line">  <span class="keyword">while</span>(low &lt; high) &#123;<span class="comment">// 从表的两端交替向中间扫描</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; L -&gt; r[high] &gt;= pivotkey)</span><br><span class="line">      high--;</span><br><span class="line">    L -&gt; r[low] = L -&gt; r[high];<span class="comment">// 采用替换而不是交换的方式进行操作</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; L -&gt; r[low] &lt;= pivotkey)</span><br><span class="line">      low++;</span><br><span class="line">    L -&gt; r[high] = L -&gt; r[low];<span class="comment">// 采用替换而不是交换的方式进行操作</span></span><br><span class="line">  &#125;</span><br><span class="line">  L -&gt; r[low] = L -&gt; r[<span class="number">0</span>];<span class="comment">// 将枢轴数值替换回 L.r[low]</span></span><br><span class="line">  <span class="keyword">return</span> low;<span class="comment">// 返回枢轴所在位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>优化小数组时的排序方案</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LENGTH_INSERT_SORT 7<span class="comment">// 数组长度阀值</span></span></span><br><span class="line"><span class="comment">/* 对顺序表 L 中的子序列 L.r[low..high] 作快速排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pivot;</span><br><span class="line">  <span class="keyword">if</span>((high - low) &gt; MAX_LENGTH_INSERT_SORT) &#123;<span class="comment">// 当 high - low 大于常数时用快速排序</span></span><br><span class="line">    pivot = Partition(L, low, high);<span class="comment">// 将 L.r[low..high] 一分为二，并算出枢轴值 pivot</span></span><br><span class="line">    QSort(L, low, pivot - <span class="number">1</span>);<span class="comment">// 对低子表递归排序</span></span><br><span class="line">    QSort(L, pivot + <span class="number">1</span>, high);<span class="comment">// 对高子表递归排序</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">// 当 high - low 小于等于常数时用直接插入排序</span></span><br><span class="line">    InsertSort(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 增加了一个判断，当 high - low 不大于某个常数时，就用直接插入排序，这样就能保证最大化地利用两种排序的优势来完成排序工作。</p></li><li><p><strong>优化递归操作</strong></p><p> 递归对性能是有一定影响的，SQort 函数在其尾部有两次递归操作。如果待排序的序列划分极端不平衡，递归深度将趋近于 n，而不是平衡时的 log<sub>2</sub>n，这就不仅仅是速度快慢的问题了。栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。因此如果能减少递归，将会大大提高性能。</p><p> 对 QSort 实施<strong>尾递归</strong>优化：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 中的子序列 L.r[low..high] 作快速排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Qsort1</span><span class="params">(SqList *L, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pivot；</span><br><span class="line">  <span class="keyword">if</span>((high - low) &gt; MAX_LENGTH_INSERT_SORT) &#123;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">      pivot = Partition1(L, low, high);<span class="comment">// L.r[low..high] 一分为二，算出枢轴值 pivot</span></span><br><span class="line">      QSort1(L, low, pivot - <span class="number">1</span>);<span class="comment">// 对低子表递归排序</span></span><br><span class="line">      low = pivot + <span class="number">1</span>;<span class="comment">// 尾递归</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    InsertSort(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当将 if 改成 while 后，因为第一次递归后，变量 low 就没有用处了，所以可以讲 pivot + 1 赋值给 low，再循环后，来一次 <code>Partition(L, low, hith)</code>，其效果等同于 <code>QSort(L, pivot + 1, high)</code>。结果相同，但因采用迭代而不是递归的方法可以缩减堆栈深度，从而提高了整体性能。</p></li><li><p><strong>了不起的排序算法</strong></p><p> 以上算法中，有按照实现方法分类命名的，如简单选择排序、直接插入排序、归并排序，有按照其排序的方式类比现实世界命名的，比如冒泡排序、堆排序，还有用人命命名的，比如希尔排序。但是快速排序却用“快速”命名，也就意味着只要再有人找到更好的排序法，此“快速”就会名不符实，不过，至少今天，TonyHoare 发明的快速排序法经过多次的优化后，在整体性能上，依然是排序算法王者。</p></li></ol><h3 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h3><p>首先根据排序的定义，提到了排序的稳定性，排序稳定对于某些特殊需求来说是至关重要的，因此在排序算法中国呢，需要关注此算法的稳定性如何。</p><p>根据将排序记录是否全部被放置在内存中，将排序分为内排序与外排序两种，外排序需要在内外存之间多次交换数据才能进行。</p><p>根据排序过程中借助的主要操作，将内排序分为：插入排序、交换排序、选择排序和归并排序四类。</p><p><img src="/../img/dsa/%E6%8E%92%E5%BA%8F.png" alt="排序"></p><p>事实上，目前还没有十全十美的排序算法，有优点就会有缺点，即使是快速排序法，也只是在整体性能上优越了，它也存在排序不稳定、需要大量辅助空间、对少量数据排序无优势等不足。</p><p>将 7 中算法的各种指标进行对比，如下表。</p><table><thead><tr><th align="center">排序方法</th><th align="center">平均情况</th><th align="center">最好情况</th><th align="center">最坏情况</th><th align="center">辅助空间</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(n)</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">简单选择排序</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">直接插入排序</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(n)</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">希尔排序</td><td align="center">O(nlogn)~O(n<sup>2</sup>)</td><td align="center">O(n<sup>13</sup>)</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">堆排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">归并排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(n)</td><td align="center">稳定</td></tr><tr><td align="center">快速排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(logn)~O(n)</td><td align="center">不稳定</td></tr></tbody></table><p>从算法的简单性来看，将 7 种算法分为两类：</p><ul><li>简单算法：冒泡、简单选择、直接插入</li><li>改进算法：希尔、堆、归并、快速</li></ul><p>从平均情况来看，显然最后 3 种改进算法要胜过希尔排序，并远远胜过前 3 种简单算法。</p><p>从最好情况看，反而冒泡和直接插入排序要更胜一筹，也就是说，如果待排序序列总是基本有序，反而不应该考虑 4 种复杂的改进算法。</p><p>从最坏情况看，堆排序与归并排序又强过快速排序以及其它简单排序。</p><p>从这三组时间复杂度的数据对比中，可以得出这样一个人时。堆排序和归并排序就像两个参加奥数考试的优等生，心理素质强，发挥稳定。而快速排序像是很情绪化的天才，心情好时表现极佳，碰到较糟糕环境会变得差强人意。但是他们如果都来比赛计算个位数的加减法，他们反而算不过成绩普通的冒泡和直接插入。</p><p>从空间复杂度来说，归并排序强调要马跑得快，就得给马吃个饱。快速排序也有相应的空间要求，反而堆排序等却都是少量索取，大量付出，对空间要求是 O(1)。如果执行算法的软件所处的环境非常在乎内存使用量的多少，选择归并排序和快速排序就不是一个较好的决策了。</p><p>从稳定性来看，归并排序独占鳌头，对于非常在乎排序稳定性的应用中，归并排序是个好算法。</p><p>从待排序记录的个数上来说，待排序的个数 n 越小，采用简单排序方法越合适。反之，n 越大，采用改进排序方法越合适。这也就是为什么对快速排序优化时，增加了一个阀值，低于阀值时换作直接插入排序的原因。</p><p>从下表的数据中，似乎简单选择排序在 3 种简单排序中性能最差，其实也不完全是，比如，如果记录的关键字本身信息量比较大 (例如，关键字都是数十位的数字)，此时表明占用存储空间很大，这样移动记录所花费的时间也越多。下表是 3 中简单排序算法的移动次数比较。</p><table><thead><tr><th align="center">排序方法</th><th align="center">平均情况</th><th align="center">最好情况</th><th align="center">最坏情况</th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center">O(n<sup>2</sup>)</td><td align="center">0</td><td align="center">O(n<sup>2</sup>)</td></tr><tr><td align="center">简单选择排序</td><td align="center">O(n)</td><td align="center">0</td><td align="center">O(n)</td></tr><tr><td align="center">直接插入排序</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(n)</td><td align="center">O(n<sup>2</sup>)</td></tr></tbody></table><p>会发现，此时简单选择排序就变得非常有优势，原因在于它是通过大量比较厚选择明确记录进行移动，有的放矢。因此对于数据量不是很大而记录的关键字信息量较大的排序要求，简单排序算法是占优的。另外，记录的关键字信息量大小对那四个改进算法影响不大。</p><p>总之，从综合各项指标来说，经过优化的快速排序是性能最好的排序算法，但是不同的场合也应该考虑使用不同的算法来应对。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2022/07/31/operatingSystem/"/>
      <url>/2022/07/31/operatingSystem/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-1-1-概念、功能和目标"><a href="#1-1-1-概念、功能和目标" class="headerlink" title="1.1.1 概念、功能和目标"></a>1.1.1 概念、功能和目标</h3><p><strong>概念</strong></p><p>操作系统是控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。</p><p><strong>操作系统的功能和目标</strong></p><blockquote><p>进程是一个程序的执行过程。执行前需要将该程序放到内存中，才能被CPU处理。</p></blockquote><ul><li><p>作为系统资源的管理者</p><ul><li>处理机管理：为程序分配CPU资源</li><li>存储器管理：需要把程序相关数据放入内存中的某个位置</li><li>文件管理：对应用程序的相关文件进行分层级的管理</li><li>设备管理：将程序需要的硬件设备划分配给进程或者回收。</li><li>目标：安全、高效</li></ul></li><li><p>作为用户和计算机硬件之间的接口</p><ul><li>提供命令接口：联机命令接口（用户说一句，系统做一句）、脱机命令接口（用户说一堆，系统做一堆）</li><li>提供程序接口（允许用户通过程序间接使用）：由一组系统调用组成（程序接口&#x3D;系统调用）</li><li>提供GUI（图形用户界面）</li><li>目标：方便用户使用</li></ul></li><li><p>作为最接近硬件的层次</p><ul><li>实现对硬件机器的拓展</li></ul></li></ul><p>没有任何软件支持的计算机称为裸机。在裸机上安装的操作系统，可以提供资源管理和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。通常把覆盖了软件的机器称为扩充机器，又称为虚拟机。</p><h3 id="1-1-2-操作系统的特征"><a href="#1-1-2-操作系统的特征" class="headerlink" title="1.1.2 操作系统的特征"></a>1.1.2 操作系统的特征</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。</p><p>并行：指两个或多个事件在同一时刻发生。</p><p>操作系统的并发性指计算机系统中同时存在着多个运行着的程序。</p><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>共享即资源共享，是指系统中的资源可提供内存中多个并发执行的进程共同使用。</p><p>资源共享方式</p><ul><li><p>互斥共享方式</p><p>  系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源</p></li><li><p>同时共享方式</p><p>  系统中的某些资源，允许一个时间段内有多个进程“同时”对他们进行访问</p><p>  所谓的”同时“往往是宏观上的，而在微观上，这些进程可能是交替地对资源进行访问的（即分时复用）</p></li></ul><p><strong>并发性和共享性互为存在条件</strong>。如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义。如果失去共享性，则两个或多个程序不能同时访问硬盘资源，就无法实现比如同时发送文件，也就无法并发。</p><h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p><blockquote><p>一个程序需要放入内存并给它分配CPU才能执行。虚拟技术中的“时分复用技术”，微观上处理机在各个微小的时间段内交替着为各个进程服务。</p></blockquote><p>虚拟技术可分为空分复用技术（如虚拟存储区技术）和时分复用技术（如虚拟处理器）。如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<strong>没有并发性，就谈不上虚拟性</strong>。 </p><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>异步是指在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><p>如果失去了并发性，则系统只能串行地处理各个进程，每个进程的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。</p><h3 id="1-1-3-操作系统的发展和分类"><a href="#1-1-3-操作系统的发展和分类" class="headerlink" title="1.1.3 操作系统的发展和分类"></a>1.1.3 操作系统的发展和分类</h3><h4 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h4><p>手工操作阶段人们将程序写到纸带上，通过在纸带上打孔来区分0&#x2F;1。计算机通过读取纸带上的程序来执行，执行完后再将程序结果打印在纸带上。计算机读取和打印结果的过程很慢（输入&#x2F;输出慢），但是执行程序的时间很快（处理速度快）。</p><p>主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低。</p><h4 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h4><ul><li><p>单道批处理系统</p><p>  引入脱机输入&#x2F;输出技术（用磁带完成），并<strong>监督程序</strong>（操作系统的雏形）负责控制作业的输入、输出。</p><p>  程序员先将自己在纸带上的程序通过外围机读到磁带上面，计算机读取磁带里的程序进行执行，并将执行结果输出到磁带中，程序员再通过外围机将程序输出带纸带上。</p></li></ul><p>优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。</p><p>缺点：内存中仅能有一道程序运行，只有该程序运行结束后才能调入下一道程序。<strong>CPU仍有大量的时间是在空闲等待I&#x2F;O完成</strong>。资源利用率依然很低。</p><ul><li><p>多道批处理系统</p><p>   在单道批处理系统的基础上，每次网内存中输入多道程序，操作系统正式诞生，并引入了中断技术，有操作系统负责管理这些程序的运行。各个程序并发执行。</p></li></ul><p>优点：多道程序并发执行，贡献计算机资源。资源利用率大幅提升，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。</p><p>缺点：用户响应时间长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行）</p><h4 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h4><p>计算机以时间片为单位轮流为各个用户&#x2F;作业服务，各个用户可通过终端与计算机进行交互。</p><p>优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p><p>缺点：不能优先处理一些紧急任务。操作系统对各个用户&#x2F;作业都是完全公平的，循环地为每个用户&#x2F;作业一个时间片，不区分任务的紧急性。</p><h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><p>优点：能够优先响应一些紧急任务，某些紧急任务不需要时间片排队。</p><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。</p><ul><li>硬实时系统：必须在绝对严格的规定时间内完成处理（如：导弹控制系统、自动驾驶系统）</li><li>软实时系统：能接受偶尔违反时间规定（如：12306火车订票系统）</li></ul><h4 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h4><p>是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows NT就是一种典型的网络操作系统，网站服务器就可以使用）</p><h4 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h4><p>主要特点是分布性和并发性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由他们并行、协同完成这个任务。</p><h4 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h4><p>如Windows XP、MacOS，方便个人使用。</p><h3 id="1-1-4-操作系统的运行机制与体系结构"><a href="#1-1-4-操作系统的运行机制与体系结构" class="headerlink" title="1.1.4 操作系统的运行机制与体系结构"></a>1.1.4 操作系统的运行机制与体系结构</h3><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><blockquote><p>问题：“指令”和我们平时所说的“代码”有什么区别？</p></blockquote><p>一段C语言代码通过编译，形成机器语言指令。<strong>一条高级语言的代码编译过后可能会对应多条指令。</strong></p><p>简单来说，“指令”就是处理器CPU能识别、执行的最基本命令</p><p>比如：加法指令就是让CPU进行加法运算</p><blockquote><p>新的问题：有的指令“人畜无害”。比如：加、减、乘、除这些普通的运算指令。有的指令有很高的权限。比如内存清零指令。比如用户程序可以使用这个指令，就意味着一个用户可以将其他用户的内存数据随意清零，这样做显然是很危险的。</p></blockquote><p>指令可以分为：</p><ul><li>特权指令：如内存清零指令（不允许用户程序使用）</li><li>非特权指令：如普通的运算指令</li></ul><blockquote><p>问题：CPU如何判断当前是否可以执行特权指令？</p></blockquote><p>两种处理器状态（用程序状态字寄存器PSW中的某标志位来标识当前处理器处于什么状态。如0为用户态，1为核心态）</p><ul><li>用户态（目态），此时CPU只能执行非特权指令</li><li>核心态（管态），特权指令、非特权指令都可以执行</li></ul><p>两种程序</p><ul><li><p>内核程序</p><p>  操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。</p></li><li><p>应用程序</p><p>  为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态。</p></li></ul><blockquote><p>操作系统中的那些功能应该由内核程序实现呢？</p></blockquote><h4 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h4><p>计算机系统的层次结构</p><p><img src="/../img/operationSystem/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="计算机系统的层次结构"></p><p>时钟管理：实现计时功能</p><p>中断处理：负责实现中断机制</p><p>原语：</p><ul><li>一种特殊的程序。</li><li>是最接近硬件的部分。</li><li>这种程序的运行具有原子性——运行只能一气呵成，不可中断。</li><li>运行时间较短、调用频繁。</li></ul><p>内核是计算机配置的底层软件，是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是内核程序。</p><p>对系统资源进行管理的功能：</p><ul><li>进程管理</li><li>存储器管理</li><li>设备管理</li></ul><p>ps：有的系统不把这部分归为“内核功能”。也就是说，不同的操作系统，对内核功能的划分可能并不一样。</p><h4 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h4><p>操作系统的体系结构可分为：</p><ul><li><p>大内核</p><p>  将操作系统的主要功能模块都作为系统内核，运行在核心态</p><p>  优点：高性能</p><p>  缺点：内核代码庞大，结构混乱，难以维护</p></li><li><p>微内核</p><p>  只把最基本的功能保留在内核</p><p>  优点：内核功能少，结构清晰，方便维护</p><p>  缺点：需要频繁地在核心态和用户态之间切换，性能低</p></li></ul><p>类比：</p><p>操作系统的体系结构问题与企业的管理问题很相似。</p><p>内核就是企业的管理层，负责一些重要的工作。只有管理层才能执行特权指令，普通员工只能执行非特权指令。用户态、核心态之间的切换相当于普通员工和管理层之间的工作交接。</p><p>大内核：企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高；缺点是组织结构混乱，难以维护。</p><p>微内核：随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护；缺点是效率低。</p><h3 id="1-1-5-中断和异常"><a href="#1-1-5-中断和异常" class="headerlink" title="1.1.5 中断和异常"></a>1.1.5 中断和异常</h3><h4 id="中断机制的诞生"><a href="#中断机制的诞生" class="headerlink" title="中断机制的诞生"></a><strong>中断机制的诞生</strong></h4><p>为了解决各程序在早起的计算机中只能串行执行，系统资源利用率低的问题，人们发明了操作系统（作为计算机的管理者），引入中断机制，实现了多道程序并发执行。</p><p>本质：发生中断就意味着需要操作系统介入，开展管理工作。</p><h4 id="中断的概念和作用"><a href="#中断的概念和作用" class="headerlink" title="中断的概念和作用"></a><strong>中断的概念和作用</strong></h4><ol><li>当中断发生时，CPU立即进入核心态</li><li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理。</li><li>对于不同的中断信号，会进行不同的处理</li></ol><p>发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作（比如进程切换、分配I&#x2F;O设备等）需要使用特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行。</p><blockquote><p>问题：用户态、核心态之间的切换是怎么实现的？</p></blockquote><p>用户态 -&gt; 核心态是通过中断实现的。并且中断是唯一途径。</p><h4 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a><strong>中断的分类</strong></h4><p>中断可分为：</p><ul><li><p>内中断</p><p>  也称异常、例外、陷入。信号来源于CPU内部与当前执行的指令有关</p><ul><li><p>自愿中断——指令中断</p><p>  如系统调用时使用的访管指令（又叫陷入指令、trap指令）</p></li><li><p>强迫中断</p><ul><li>硬件故障（如缺页）</li><li>软件中断（如整数除0）</li></ul></li></ul></li><li><p>外中断</p><p>  信号来源于CPU外部。与当前执行的指令无关</p><ul><li>外设请求（如I&#x2F;O操作完成发出的中断信号）</li><li>人工干预（如用户强行终止一个进程）</li></ul></li></ul><p>另一种分类方式：</p><ul><li>内中断（内部异常）<ul><li>陷阱、陷入trap（有意而为之的异常，如系统调用）</li><li>故障fault（由错误条件引起的，可能被故障处理程序修复，如缺页）</li><li>终止abort（不可恢复的致命错误造成的结果，终止处理程序不再将控制返回给引发终止的应用程序，如整数除0）</li></ul></li><li>外中断<ul><li>I&#x2F;O中断请求</li><li>人工干预</li></ul></li></ul><h4 id="外中断的处理过程"><a href="#外中断的处理过程" class="headerlink" title="外中断的处理过程"></a><strong>外中断的处理过程</strong></h4><ol><li>执行完每个指令之后，CPU都要检查当前是否有外部中断信号</li><li>如果监测到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW、程序计数器PC、各种通用寄存器）</li><li>根据中断信号类型转入相应的中断处理程序</li><li>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</li></ol><h3 id="1-1-6-系统调用"><a href="#1-1-6-系统调用" class="headerlink" title="1.1.6 系统调用"></a>1.1.6 系统调用</h3><h4 id="什么是系统调用，有何作用？"><a href="#什么是系统调用，有何作用？" class="headerlink" title="什么是系统调用，有何作用？"></a><strong>什么是系统调用，有何作用？</strong></h4><p>系统调用是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为 一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获取操作系统的服务。</p><p>应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡事与资源有关的操作（如存储分配、I&#x2F;O操作、文件管理），都必须通过系统调用的方式来操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p><p>系统调用按功能可以分为：</p><ul><li>设备管理：完成设备的请求&#x2F;释放&#x2F;启动等功能</li><li>文件管理：完成文件的读&#x2F;写&#x2F;创建&#x2F;删除等功能</li><li>进程控制：完成进程的创建&#x2F;撤销&#x2F;阻塞&#x2F;唤醒等功能</li><li>进程通信：完成进程之间的消息传递&#x2F;信号传递等功能</li><li>内存管理：完成内存的分配&#x2F;回收等功能</li></ul><blockquote><p>系统调用相关处理涉及到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此系统调用的相关处理需要在核心态下进行。</p></blockquote><h4 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a><strong>系统调用和库函数的区别</strong></h4><p><img src="/../img/operationSystem/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8E%E5%BA%93%E5%87%BD%E6%95%B0.png" alt="系统调用与库函数"></p><table><thead><tr><th align="left">普通应用程序</th><th>可直接进行系统调用，也可以使用库函数。有的库函数设计系统调用，有的不涉及</th></tr></thead><tbody><tr><td align="left">编程语言</td><td>向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使上层进行系统调用更加方便。</td></tr><tr><td align="left">操作系统</td><td>向上提供系统调用</td></tr><tr><td align="left">裸机</td><td></td></tr></tbody></table><p>区别：</p><ul><li>系统调用是操作系统向上层提供的接口</li><li>有的库函数是对系统调用的进一步封装</li><li>当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用</li></ul><h4 id="系统调用背后的过程"><a href="#系统调用背后的过程" class="headerlink" title="系统调用背后的过程"></a><strong>系统调用背后的过程</strong></h4><p><img src="/../img/operationSystem/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="系统调用过程"></p><p>传递系统调用参数 -&gt; 执行陷入指令(用户态) -&gt; 执行系统调用相应服务程序(核心态) -&gt; 返回用户程序</p><p>注意：</p><ol><li>陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，从而CPU进入核心态。</li><li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</li><li>陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令</li></ol><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="2-1-1-进程的定义、组成、组织方式、特征"><a href="#2-1-1-进程的定义、组成、组织方式、特征" class="headerlink" title="2.1.1 进程的定义、组成、组织方式、特征"></a>2.1.1 进程的定义、组成、组织方式、特征</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>从不同的角度，进程可以有不同的定义，比较传统典型的定义有：</p><ol><li>进程是程序的一次执行过程。</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li><li>进程是具有独立功能的程序在数据集合上运行的过程，它是系统进程资源分配和调度的一个独立单位。</li></ol><p>不管从什么角度，它们都在强调进程是“动态性”的。</p><p>引入进程实体的概念后，可以把进程定义为：</p><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p><strong>程序：</strong>一个指令序列。</p><p>引入多道程序技术后，为了方便操作系统管理，完成各程序并发执行，引入了进程、进程实体的概念。</p><p>PCB、程序段、数据段三部分构成了进程实体 （进程映像）。</p><blockquote><p>PCB：系统为每个运行的程序配置一个数据结构，称为进程控制块(PCB)，用来描述进程的各种信息(如程序代码存放位置)</p><p>程序段：存放要执行的程序代码</p><p>数据段：存放程序运行过程中处理的各种数据，如全局变量、局部变量等。</p></blockquote><p>程序段、数据段、PCB三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体就简称为进程，例如：所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。</p><p><strong>PCB是进程存在的唯一标志！</strong></p><p>PCB中存放的信息：</p><ul><li><p>进程描述信息</p><ul><li>进程标识符PID：进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，用于区分不同的进程。</li><li>用户标识符UID</li></ul></li><li><p>进程控制和管理信息</p><ul><li>进程当前状态</li><li>进程优先级</li></ul></li><li><p>资源分配清单</p><ul><li>程序段指针</li><li>数据段指针</li><li>键盘</li><li>鼠标</li></ul></li><li><p>处理机相关信息</p><ul><li><p>各种寄存器值</p><p>  当进程切换时，需要把进程当前的运行情况记录下来保存在PCB中，如程序计数器的值表示了当前程序执行到那一句</p></li></ul></li></ul><h4 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h4><p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。</p><p>ps：进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题。</p><p>进程的组织方式包括：</p><ul><li><p>链接方式</p><p>  链接方式按照进程状态将PCB分为多个队列，操作系统有志向各个队列的指针</p></li><li><p>索引方式</p><p>  索引方式根据进程状态的不同，建立几张索引表，各表项指向一个PCB，操作系统持有指向各个索引表的指针</p></li></ul><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li><p>动态性</p><p>  进程是程序的一次执行过程，是动态地产生、变化和消亡的</p></li><li><p>并发性</p><p>  内存中有多个进程实体，各进程可并发执行</p></li><li><p>独立性</p><p>  进程是能独立运行、独立获得资源、独立接受调度的基本单位</p></li><li><p>异步性</p><p>  各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题</p></li><li><p>结构性</p><p>  每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</p></li></ul><blockquote><p>动态性是进程最基本的特征。进程是资源分配、接受调度的基本单位。异步性会导致并发程序执行结果的不确定性。</p></blockquote><h3 id="2-1-2-进程的状态与转换"><a href="#2-1-2-进程的状态与转换" class="headerlink" title="2.1.2 进程的状态与转换"></a>2.1.2 进程的状态与转换</h3><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化的。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。</p><p>进程的三种基本状态：</p><ul><li><p>就绪态（Ready）</p><p>  此时进程已经具备运行条件（除处理机之外所有需要的资源），但由于没有空闲的CPU，而暂时不能运行。一旦获得处理机，即可立即进入运行态开始运行。</p></li><li><p>运行态（Running）</p><p>  此时进程占有CPU，并在CPU上运行。单核处理机环境下，每一个时刻最多只有一个进程处于运行态。双核环境下可以同时有两个进程处于运行态。</p></li><li><p>阻塞态（Waiting&#x2F;Blocked，又称：等待态）</p><p>  因等待某一事件而暂时不能运行。如等待操作系统分配打印机、等待磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务。</p></li></ul><p>一个进程的诞生和消亡过程并不是一瞬间完成的，也有一个创建和消亡的过程，所以进程还有两种状态：</p><ul><li><p>创建态（New，又称：新建态）</p><p>  一个程序需要在计算机中运行，操作系统需要完成创建进程。操作系统为该进程分配所需要的内存空间等系统资源，并为其创建、初始化PCB（如为进程分配PID）</p></li><li><p>终止态（Terminated，又称：结束态）</p><p>  进程运行结束（或者由于bug导致进程无法继续执行下去，比如数组越界错误，整数除零），需要撤销进程。操作系统需要完成撤销进程的相关工作。完成将分配给进程的资源回收，撤销进程PCB等工作。</p></li></ul><h4 id="进程状态的转换"><a href="#进程状态的转换" class="headerlink" title="进程状态的转换"></a>进程状态的转换</h4><p><img src="/../img/operationSystem/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="进程状态的转换"></p><p>进程从运行态 -&gt; 阻塞态是一种进程自身作出的主动行为</p><p>进程从阻塞态 -&gt; 就绪态不是进程自身能控制的，是一种被动行为</p><p>ps: 不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态，因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求。</p><ul><li><p>就绪态 -&gt; 运行态</p><p>  进程被调度</p></li><li><p>运行态 -&gt; 就绪态</p><p>  时间片到，或CPU被其他高优先级的进程抢占</p></li><li><p>运行态 -&gt; 阻塞态</p><p>  等待系统资源分配，或等待某事件发生（主动行为）</p></li><li><p>阻塞态 -&gt; 就绪态</p><p>  资源分配到尾，等待的事件发生（被动行为）</p></li><li><p>创建态 -&gt; 就绪态</p><p>  系统完成创建进程相关的工作</p></li><li><p>运行态 -&gt; 终止态</p><p>  进程运行结束，或运行过程中遇到不可修复的错误</p></li></ul><h3 id="2-1-3-进程控制"><a href="#2-1-3-进程控制" class="headerlink" title="2.1.3 进程控制"></a>2.1.3 进程控制</h3><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><p>简化理解：反正进程控制就是要实现进程状态转换。</p><p><img src="/../img/operationSystem/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6.png" alt="进程控制"></p><p>创建进程：需要初始化PCB、分配系统资源。</p><p>创建态 -&gt; 就绪态：需要修改PCB内容和相应队列</p><p>就绪态 -&gt; 运行态：需要回复进程运行环境、修改PCB内容和相应队列</p><p>运行态 -&gt; 就绪态：需要保存进程运行环境、修改PCB内容和相应队列</p><p>运行态 -&gt; 阻塞态：需要保存进程运行环境、修改PCB内容和相应队列</p><p>阻塞态 -&gt; 就绪态：需要修改PCB内容和相应队列。如果等待的是资源，则还需为进程分配系统资源</p><p>运行态 -&gt; 终止态：需回收进程拥有的资源，撤销PCB</p><p>进程状态的切换，中间所做的事情是比较复杂的，需要修改PCB的内容和将PCB放入相应的队列。加入一个进程的PCB从一个队列放入另一个队列中，但是并没有修改PCB中状态标志成新的状态。这种情况会导致系统错误，为了解决这个问题，引入了原语。</p><h4 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h4><p>用原语实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。</p><p>这种不可被中断的操作称为原子操作。</p><p>原语采用“关中断指令”和“开中断指令”实现。</p><p><img src="/../img/operationSystem/%E5%8E%9F%E8%AF%AD.png" alt="原语"></p><p>关&#x2F;开中断指令的权限非常大，必然是只允许在核心态下执行的特权命令。</p><p>进程控制会导致进程状态的转换。无论哪个原语，要做的无非是三类事情：</p><ol><li><p>更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）</p><p> a. 所有的进程控制原语一定都会修改进程状态标志</p><p> b. 剥夺当前运行进程的CPU使用权，必然需要保存其运行环境</p><p> c. 某进程开始运行前必然要恢复其运行环境</p></li><li><p>将PCB插入合适的队列</p></li><li><p>分配&#x2F;回收资源</p></li></ol><h4 id="进程控制相关的原语"><a href="#进程控制相关的原语" class="headerlink" title="进程控制相关的原语"></a>进程控制相关的原语</h4><ol><li>进程的创建：</li></ol><p>创建原语（无 -&gt; 创建态 -&gt; 就绪态）</p><ul><li>申请空白PCB</li><li>为新进程分配所需资源</li><li>初始化PCB</li><li>将PCB插入就绪队列</li></ul><p>引起进程创建的事件</p><ul><li>用户登录：分时系统中，用户登录成功，系统会建立为其建立一个新的进程</li><li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li><li>提供服务：用户向操作系统提出某些请求时，会建立一个进程处理该请求</li><li>应用请求：由用户进程主动请求创建一个子进程</li></ul><ol start="2"><li>进程的终止：</li></ol><p>撤销原语（就绪态&#x2F;阻塞态&#x2F;运行态 -&gt; 终止态 -&gt; 无）</p><ul><li>从PCB集合中找到终止进程的PCB</li><li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li><li>终止其所有子进程</li><li>将该进程拥有的所有资源归还给父进程或操作系统</li><li>删除PCB</li></ul><p>引起进程终止的事件：</p><ul><li>正常结束</li><li>异常结束</li><li>外界干预</li></ul><ol start="3"><li>进程的阻塞和唤醒（阻塞和唤醒要成对出现）</li></ol><p>阻塞原语（运行态 -&gt; 阻塞态）</p><ul><li>找到要阻塞的进程对应的PCB</li><li>保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li><li>将PCB插入相应事件的等待队列</li></ul><p>引起进程阻塞的事件：</p><ul><li>需要等待系统分配某种资源</li><li>需要等待相互合作的其他进程完成工作</li></ul><p>唤醒原语（阻塞态 -&gt; 就绪态）</p><ul><li>在事件等待队列中找到PCB</li><li>将PCB从等待队列移除，设置进程为就绪态</li><li>将PCB插入就绪队列，等待被调度</li></ul><p>引起进程唤醒的事件：</p><ul><li>等待的事件发生</li></ul><ol start="4"><li>进程的切换</li></ol><p>切换原语（运行态 -&gt; 阻塞态&#x2F;就绪态；就绪态 -&gt; 运行态）：</p><ul><li><p>将运行环境信息存入PCB</p></li><li><p>PCB移入相应队列</p></li><li><p>选择另一个进程执行，并更新其PCB</p></li><li><p>根据PCB恢复新进程所需的运行环境</p></li></ul><p>引起进程切换的事件：</p><ul><li>当前进程时间片到</li><li>有更高优先级的进程到达</li><li>当前进程主动阻塞</li><li>当前进程终止</li></ul><h3 id="2-1-4-进程通信"><a href="#2-1-4-进程通信" class="headerlink" title="2.1.4 进程通信"></a>2.1.4 进程通信</h3><blockquote><p>什么是进程通信？</p></blockquote><p>顾名思义，进程通信指进程之间的信息交换。</p><p>进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程</strong>拥有的<strong>内存地址空间相互独立</strong>。</p><p>为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p><p>实现进程间的安全通信的方法有<strong>共享存储</strong>、<strong>消息传递</strong>、<strong>管道通信</strong>。</p><h4 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h4><p>共享存储要求两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）。</p><p>操作系统只负责提供共享空间和同步互斥工具（如P、V操作）。</p><p>共享存储可分为基于数据结构的共享和基于存储区的贡献。</p><p><strong>基于数据结构</strong>的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。</p><p><strong>基于存储区</strong>的共享：在内存中画出一块共享存储区，数据的形式、 存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。</p><h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><blockquote><p>“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。</p></blockquote><ol><li>管道只能采用半双工通信，某一时间段内只能实现单项的传输。如果要实现双向同时通信，则需要设置两个管道。</li><li>各进程要互斥地访问管道。</li><li>数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。</li><li>如果没写满，就不允许读。如果没读空，就不允许写。</li><li>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。</li></ol><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p>进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息&#x2F;接收消息”两个原语进行数据交换。</p><p>格式化的消息包括消息头、消息体。</p><p>消息头包括发送进程ID、接收进程ID、消息类型、消息长度等格式化的信息（计算机网络中发送的“报文”其实就是一种格式化的消息）</p><p>消息传递的两种方式：</p><ol><li><p>直接通信方式</p><p> 消息直接挂到接收进程的消息缓冲队列上</p></li><li><p>间接通信方式</p><p> 消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。eg：计算机网络中的电子邮件系统。</p></li></ol><h3 id="2-1-5-线程概念和多线程模型"><a href="#2-1-5-线程概念和多线程模型" class="headerlink" title="2.1.5 线程概念和多线程模型"></a>2.1.5 线程概念和多线程模型</h3><h4 id="什么是线程，为什么要引入线程？"><a href="#什么是线程，为什么要引入线程？" class="headerlink" title="什么是线程，为什么要引入线程？"></a>什么是线程，为什么要引入线程？</h4><p>可以把线程理解为“轻量级进程“。</p><p>线程是一个<strong>基本的CPU执行单元</strong>，也是<strong>程序执行流的最小单位</strong>。</p><p>引入线程后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步<strong>提升了系统的并发度</strong>，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）</p><p>引入线程之后，进程制作为<strong>除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间都是分配给进程的）。</p><h4 id="引入线程机制后，有什么变化？"><a href="#引入线程机制后，有什么变化？" class="headerlink" title="引入线程机制后，有什么变化？"></a>引入线程机制后，有什么变化？</h4><p>从资源分配、调度来看：</p><ul><li>传统进程机制中，进程是资源分配、调度的基本单位</li><li>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</li></ul><p>从并发性来看：</p><ul><li>传统进程机制中，只能进程间并发</li><li>引入线程后，各线程间也能并发，提升了并发度</li></ul><p>从系统开销来看：</p><ul><li>传统的进程间并发，需要切换进程的运行环境，系统开销很大</li><li>线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小</li><li>引入线程后，并发所带来的系统开销减小</li></ul><h4 id="线程有哪些重要的属性"><a href="#线程有哪些重要的属性" class="headerlink" title="线程有哪些重要的属性"></a>线程有哪些重要的属性</h4><ul><li>线程是处理机调度的单位，进程是资源分配的单位</li><li>同一进程的各线程共享拥有的资源</li><li>同一进程内的线程切换不会导致进程切换</li><li>多CPU计算机中，各线程可占用不同的CPU</li><li>每个线程都有一个线程ID、线程控制块（TCB）</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销很大</li></ul><h4 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h4><p><strong>用户级线程(User-Level Thread, ULT)</strong></p><p><img src="/../img/operationSystem/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B.png" alt="用户级线程"></p><p>用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换）</p><p>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</p><p>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明）</p><p>可以理解为，“用户级线程”就是“从用户视角看能看到的线程”。</p><p><strong>内核级线程(Kernel-Level Thread, KLT, 又称“内核支持的线程”</strong></p><p><img src="/../img/operationSystem/%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B.png" alt="内核级线程"></p><p>内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。可以理解为，“内核级线程”就是“从操作系统内核视角看能看到的线程”。</p><p>在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m个内核级线程上（n&gt;m）</p><p><img src="/../img/operationSystem/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%90%88.png" alt="用户级线程和内核级线程组合"></p><p><strong>重点</strong>：</p><p>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</p><p>例如上面的模型中，该进程有两个内核级线程，三个用户级线程，在用户看来，这个进程中有三个线程。但即使该进程在一个四核处理机的计算机上运行，也最多只能被分配到两个核，最多只能有两个用户线程并行执行。</p><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p>在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”为题。</p><p><strong>多对一模型</strong>：</p><p><img src="/../img/OperationSystem/%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B.png" alt="多对一模型"></p><p>多个用户级线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</p><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p><p><strong>一对一模型</strong>：</p><p><img src="/../img/operationSystem/%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B.png" alt="一对一模型"></p><p>一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p><p><strong>多对多模型</strong>：</p><p><img src="/../img/operationSystem/%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B.png" alt="多对多模型"></p><p>n用户级线程映射到m内核级线程（n≥m）。每个用户级进程对应m个内核级线程。</p><p>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p><h3 id="2-2-1-处理机调度的概念、层次"><a href="#2-2-1-处理机调度的概念、层次" class="headerlink" title="2.2.1 处理机调度的概念、层次"></a>2.2.1 处理机调度的概念、层次</h3><h4 id="调度的基本概念"><a href="#调度的基本概念" class="headerlink" title="调度的基本概念"></a>调度的基本概念</h4><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。</p><p>在多道程序系统中，进程的数量往往是多余处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</p><h4 id="调度的三个层次"><a href="#调度的三个层次" class="headerlink" title="调度的三个层次"></a>调度的三个层次</h4><p>::: tip<br>外存：指计算机随机存储器(RAM)和CPU缓存之外的存储器，例如，计算机硬盘、软盘、光盘、U盘等。<br>:::</p><p><strong>1. 高级调度</strong></p><p>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</p><p>高级调度(作业调度)。按一定的原则从外存上处于后备队列的作业中挑选一个(或多个)作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB)，以使它(们)获得竞争处理机的权利。</p><p>高级调度是辅存(外存)与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p><p><strong>2. 中级调度</strong></p><p>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。</p><p>这么做的目的是为了提高内存利用率和系统吞吐量。</p><p>暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到挂起队列中。</p><p>中级调度(内存调度)，就是要决定将哪个处于挂起状态的进程重新调入内存。</p><p>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</p><p><strong>3. 低级调度</strong></p><p>低级调度(进程调度)，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</p><p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</p><p>进程调度的频率很高，一般几十毫秒一次。</p><p><strong>补充：进程的挂起态与七状态模型</strong></p><p>暂时调到外存等待的进程状态为挂起状态(挂起态，suspend)</p><p>挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</p><p>五状态模型 -&gt; 七状态模型</p><p><img src="/../img/operationSystem/%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt="七状态模型"></p><p>注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但是挂起状态是将进程映像调到外存中去了，而阻塞态下的进程映像还在内存中。有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p><p><strong>三种调度的联系、对比</strong></p><table><thead><tr><th align="center"></th><th align="center">要做什么</th><th align="center">调度发生在</th><th align="center">发生频率</th><th align="center">对进程状态的影响</th></tr></thead><tbody><tr><td align="center">高级调度<br />(作业调度)</td><td align="center">按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td><td align="center">外存 -&gt; 内存<br />(面向作业)</td><td align="center">最低</td><td align="center">无 -&gt; 创建态 -&gt; 就绪态</td></tr><tr><td align="center">中级调度<br />(内存调度)</td><td align="center">按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td><td align="center">外存 -&gt; 内存<br />(面向进程)</td><td align="center">中等</td><td align="center">挂起态 -&gt; 就绪态<br />(阻塞挂起 -&gt; 阻塞态)</td></tr><tr><td align="center">低级调度<br />(进程调度)</td><td align="center">按照某种规则，从就绪队列中选择一个进程为其分配处理机</td><td align="center">内存 -&gt; CPU</td><td align="center">最高</td><td align="center">就绪态 -&gt; 运行态</td></tr></tbody></table><h3 id="2-2-2-进程调度的时机、切换与过程、方式"><a href="#2-2-2-进程调度的时机、切换与过程、方式" class="headerlink" title="2.2.2 进程调度的时机、切换与过程、方式"></a>2.2.2 进程调度的时机、切换与过程、方式</h3><h4 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a><strong>进程调度的时机</strong></h4><p>进程调度(低级调度)就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p><p>需要进行进程调度与切换的情况：</p><ul><li>当前运行的进程主动放弃处理机<ul><li>进程正常终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞(如等待I&#x2F;O)</li></ul></li><li>当前运行的进程被动放弃处理机<ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理(如I&#x2F;O中断)</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ul><p>不能进行进程调度与切换的情况：</p><ul><li>在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进程切换。</li><li>进程在操作系统内核程序临界区中。</li><li>在原子操作过程中(原语)。原子操作不可中断，要一气呵成(如修改PCB中进程状态标志，并把PCB放到相应队列)</li></ul><blockquote><p>进程在操作系统内核程序临界区中不能进行调度与切换。 ✓</p><p>进程处于临界区时不能进行处理机调度。✖︎</p><p>临界资源：一段时间内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。</p><p>临界区：访问临界资源的那段代码。</p><p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列(由各种就绪进程的PCB组成)。</p></blockquote><p><img src="/../img/operationSystem/%E5%86%85%E6%A0%B8%E4%B8%B4%E7%95%8C%E5%8C%BA%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.png" alt="内核临界区进程调度"></p><p>如果还没退出临界区(还没解锁)就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度。内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。</p><p><img src="/../img/operationSystem/%E6%99%AE%E9%80%9A%E4%B8%B4%E7%95%8C%E5%8C%BA.png" alt="普通临界区"></p><p>在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲。普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时，可以进行调度与切换。</p><h4 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a><strong>进程调度的方式</strong></h4><ul><li><p>非剥夺调度方式</p><p>  又称非抢占方式。即只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</p><p>  实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。</p></li><li><p>剥夺调度式</p><p>  又称抢占式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</p><p>  可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能(通过始终中断)。适合于分时操作系统、实时操作系统。</p></li></ul><h4 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a><strong>进程的切换与过程</strong></h4><p>“狭义的进程调度”与“进程切换”的区别：</p><p>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换)</p><p>进程切换指一个进程让出处理机，由另一个进程占用处理机的过程。</p><p>广义的进程调度包含了选择一个进程和进程切换两个步骤。</p><p>进程切换的过程主要完成了：</p><ol><li>对原来运行进程各种数据的保护</li><li>对新的进程各种数据的恢复</li></ol><p>​如程序计数器、程序状态字、各种数据寄存器等处理机线程信息，这些信息一般保存在进程控制块PCB）</p><p>ps：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p><h3 id="2-2-3-调度算法的评价指标"><a href="#2-2-3-调度算法的评价指标" class="headerlink" title="2.2.3 调度算法的评价指标"></a>2.2.3 调度算法的评价指标</h3><h4 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h4><p>指CPU“忙碌”的事件占总时间的比例。</p><p>利用率 &#x3D; 忙碌的事件 &#x2F; 总时间</p><h4 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h4><p>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业。</p><p>系统吞吐量指单位时间内完成作业的数量</p><p>系统吞吐量 &#x3D; 总共完成了多少道作业 &#x2F; 总共花了多少时间</p><h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h4><p>对于计算机来说，他很关心自己的作业从提交到完成花了多少时间。</p><p>周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。</p><p>它包括四个部分：作业在外存后备队列上等待作业调度(高级调度)的时间、进程在就绪队列上等待进程调度(低级调度)的时间、进程在CPU上执行的时间、进程等待I&#x2F;O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。</p><p>周转时间 &#x3D; 作业完成时间 - 作业提交时间</p><p>平均周转时间 &#x3D; 各作业周转时间之和 &#x2F; 作业数</p><p>带权周转时间 &#x3D; 作业周转时间 &#x2F; 作业实际运行的时间 &#x3D; (作业完成时间 - 作业提交时间) &#x2F; 作业实际运行的时间</p><h4 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h4><p>计算机的用户希望自己的作业尽可能少的等待处理机</p><p>等待时间是指进程&#x2F;作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</p><p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I&#x2F;O完成的期间其实进程也是在被服务的，所以不计入等待时间。</p><p>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p><p>一个作业总共需要被CPU服务多久，被I&#x2F;O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业&#x2F;进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。</p><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4><p>对于计算机用户来说，会希望自己提交的请求(比如通过键盘输入了一个调试命令)尽早地开始被系统服务、回应。</p><p>响应时间指从用户提交请求到首次产生响应所用的时间。</p><h3 id="2-2-4-调度算法"><a href="#2-2-4-调度算法" class="headerlink" title="2.2.4 调度算法"></a>2.2.4 调度算法</h3><h4 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务(FCFS)"></a><strong>先来先服务(FCFS)</strong></h4><ul><li><p>算法思想</p><p>  主要从“公平”的角度考虑(类似于我们生活中排队买东西的例子)</p></li><li><p>算法规则</p><p>  按照作业&#x2F;进程到达的先后顺序进行服务</p></li><li><p>用于作业&#x2F;进程调度</p><p>  用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列</p></li><li><p>是否可抢占？</p><p>  非抢占式的算法</p></li><li><p>优缺点</p><p>  优点：公平、算法实现简单</p><p>  缺点：排在长作业(进程)后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即FCFS算法对长作业有利，对短作业不利</p></li><li><p>是否会导致饥饿</p><p>  不会</p></li></ul><h4 id="短作业优先-SJF"><a href="#短作业优先-SJF" class="headerlink" title="短作业优先(SJF)"></a><strong>短作业优先(SJF)</strong></h4><ul><li><p>算法思想</p><p>  最求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间</p></li><li><p>算法规则</p><p>  最短的作业&#x2F;进程优先得到服务(所谓“最短”，是指要求服务时间最短)</p></li><li><p>用于作业&#x2F;进程调度</p><p>  既可用于作业调度，也可以用于进程调度。用于进程调度时称为“短进程优先”(SPF, Shortest Process First)算法。</p></li><li><p>是否可抢占</p><p>  SJF和SPF是非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法(SRTN， Shortest Remaining Time Next)</p></li><li><p>优缺点</p><p>  优点：“最短的”平均等待时间、平均周转时间</p><p>  缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业&#x2F;进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。</p></li><li><p>是否会导致饥饿</p><p>  会。如果源源不断的有短作业&#x2F;进程到来，可能是长作业&#x2F;进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”</p></li></ul><h4 id="高响应比优先-HRRN"><a href="#高响应比优先-HRRN" class="headerlink" title="高响应比优先(HRRN)"></a><strong>高响应比优先(HRRN)</strong></h4><ul><li><p>算法思想</p><p>  要综合考虑作业&#x2F;进程的等待时间和要求服务的时间</p></li><li><p>算法规则</p><p>  在每次调度时先计算各个作业&#x2F;进程的响应比，选择响应比最高的作业&#x2F;进程为其服务</p><p>  响应比 &#x3D; (等待时间 + 要求服务时间) &#x2F; 要求服务时间</p></li><li><p>用于作业&#x2F;进程调度</p><p>  既可用于作业调度，也可用于进程调度</p></li><li><p>是否可抢占</p><p>  非抢占式的算法。因此只有当前运行的作业&#x2F;进程主动放弃处理机时，才需要调度，才需要计算响应比。</p></li><li><p>优缺点</p><p>  综合考虑了等待时间和运行时间(要求服务时间)等待时间相同时，要求服务时间短的优先(SJF的优点)；要求服务时间相同时，等待时间长的优先(FCFS的优点)；对于长作业来说，随着等待时间越来越久，其响应也会越来越大，从而避免了长作业饥饿的问题。</p></li><li><p>是否会导致饥饿</p><p>  不会</p></li></ul><blockquote><p>ps: 这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于早期的批处理系统，当然，GCFS算法也结合其他的算法使用，在现在也扮演着很重要的角色。</p></blockquote><p>​    </p><h3 id="2-2-5-适合交互式系统的调度算法"><a href="#2-2-5-适合交互式系统的调度算法" class="headerlink" title="2.2.5 适合交互式系统的调度算法"></a>2.2.5 适合交互式系统的调度算法</h3><h4 id="时间片轮转-RR-Round-Robin"><a href="#时间片轮转-RR-Round-Robin" class="headerlink" title="时间片轮转(RR, Round-Robin)"></a>时间片轮转(RR, Round-Robin)</h4><ul><li><p>算法思想</p><p>  公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p></li><li><p>算法规则</p><p>  按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片(如100ms)。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</p></li><li><p>用于作业&#x2F;进程调度</p><p>  用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)</p></li><li><p>是否可抢占</p><p>  若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到。</p></li><li><p>优缺点</p><p>  优点：公平、响应快，适用于分时操作系统。</p><p>  缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</p></li><li><p>是否会导致饥饿</p><p>  不会</p></li><li><p>补充</p><p>  如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</p><p>  另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减小。可见时间片也不能太小。</p></li></ul><h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><ul><li><p>算法思想</p><p>  随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序。</p></li><li><p>算法规则</p><p>  调度时选择优先级最高的作业&#x2F;进程</p></li><li><p>用于作业&#x2F;进程调度</p><p>  既可用于作业调度，也可用于进程调度。甚至，还会用于I&#x2F;O调度中。</p></li><li><p>是否可抢占</p><p>  抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。</p></li><li><p>优缺点</p><p>  优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各个作业&#x2F;进程的偏好程度。</p><p>  缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</p></li><li><p>是否会导致饥饿</p><p>  会</p></li><li><p>补充</p><p>  就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近对头的位置。</p><p>  根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。</p><p>  静态优先级：创建进程时确定，之后一直不变。</p><p>  动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</p><blockquote><p>如何合理地设置各类进程的优先级？</p></blockquote><p>  通常系统进程优先级高于用户进程、前台进程优先级高于后台进程、操作系统更偏好I&#x2F;O型进程(或称I&#x2F;O繁忙型进程)</p><p>  Ps: 与I&#x2F;O型进程相对的是计算行进程(或称CPU繁忙型进程)</p><blockquote><p>如果采用的是动态优先级，什么时候应该调整？</p></blockquote><p>  可以从追求公平、提升资源利用率等角度考虑。如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级。如果某进程占用处理机运行了很长时间，则可适当降低其优先级。如果发现一个进程繁忙地进行I&#x2F;O操作，则可适当提升其优先级。</p></li></ul><h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><ul><li><p>算法思想</p><p>  对其他调度算法的折中权衡</p></li><li><p>算法规则</p><ol><li>设置多集就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾。</li><li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li></ol></li><li><p>用于作业&#x2F;进程调度</p><p>  用于进程调度</p></li><li><p>是否可抢占</p><p>  抢占式的算法。在k级队列的进程运行过程中，若更上级的队列(1～k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</p></li><li><p>优缺点</p><p>  对各类型进程相对公平(FCFS的优点)；每个新到达的进程都可以很快就得到响应(RR的优点)；短进程只用较少的十斤啊就可完成(SPF的优点)；不必实现估计进程的运行时间(避免用户作假)；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I&#x2F;O密集型进程(拓展：可以讲因I&#x2F;O而阻塞的进程重新放回原队列，这样I&#x2F;O型进程就可以保持较高优先级)</p></li><li><p>是否会导致饥饿</p><p>  会</p></li></ul><h3 id="2-3-1-进程同步、进程互斥"><a href="#2-3-1-进程同步、进程互斥" class="headerlink" title="2.3.1 进程同步、进程互斥"></a>2.3.1 进程同步、进程互斥</h3><h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><p>  同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于他们之间的相互合作。</p><h4 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h4><p>进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源(比如内存，又比如打印机、摄像头这样的I&#x2F;O设备)</p><p>资源共享的两种方式：</p><ul><li><p>互斥共享方式</p><p>  系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源</p></li><li><p>同时共享方式</p><p>  系统中的某些资源，允许一个时间段内有多个“同时”对它们进行访问。</p></li></ul><p>我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p><p>对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源后，另一个进程才能去访问临界资源。</p><p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  entry section;<span class="comment">// 进入区</span></span><br><span class="line">  critical section;<span class="comment">// 临界区</span></span><br><span class="line">  <span class="built_in">exit</span> section;<span class="comment">// 退出区</span></span><br><span class="line">  remainder section;<span class="comment">// 剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><ul><li>进入区：负责检查是否可进入临界区，若可以进入，则应设置<strong>正在访问临界资源的标志</strong>(可理解为“上锁”)，以阻止其他进程同时进入临界区</li><li>临界区：访问临界资源的那段代码</li><li>退出区：负责解除<strong>正在访问临界资源的标志</strong>(可理解为“解锁”)</li><li>剩余区：做其他处理</li></ul><p>ps：临界区是进程中访问临界资源的代码段。进入区和退出区是负责实现互斥的代码段。临界区也可称为“临界段”。</p><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p><ol><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)；</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ol><h3 id="2-3-2-进程互斥的软件实现方法"><a href="#2-3-2-进程互斥的软件实现方法" class="headerlink" title="2.3.2 进程互斥的软件实现方法"></a>2.3.2 进程互斥的软件实现方法</h3><h4 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h4><p>算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>; <span class="comment">// turn 表示当前允许进入临界区的进程号</span></span><br><span class="line"><span class="comment">// P0进程：</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">0</span>);<span class="comment">// ①</span></span><br><span class="line">critical section;<span class="comment">// ②</span></span><br><span class="line">turn = <span class="number">1</span>;<span class="comment">// ③</span></span><br><span class="line">remainder section;<span class="comment">// ④</span></span><br><span class="line"><span class="comment">// P1进程:</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">1</span>);<span class="comment">// ⑤ 进入区</span></span><br><span class="line">critical section;<span class="comment">// ⑥ 临界区</span></span><br><span class="line">turn = <span class="number">0</span>;<span class="comment">// ⑦ 退出区</span></span><br><span class="line">remainder section;<span class="comment">// ⑧ 剩余区</span></span><br></pre></td></tr></table></figure><p>turn的初值为0，即刚开始只允许0号进程进入临界区。</p><p>若P1先上处理机运行，则会一直卡在⑤。直到P1的时间片用完，发生调度，切换P0上处理机运行。</p><p>代码①不会卡住P0，P0可以正常访问临界区，在P0访问临界区期间及时切换回P1，P1依然会卡在⑤。</p><p>只有P0在退出区将turn改为1后，P1才能进入临界区。</p><p>因此，该算法可以实现“同一时刻最多只允许一个进程访问临界区”</p><p>turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。也就是说，对于临界区的访问，一定是按P0 -&gt; P1 -&gt; P0 -&gt; P1 -&gt; ……这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。</p><p>因此，单标志存在的主要问题是：违背“空闲让进”原则。</p><h4 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h4><p>算法思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程相进入临界区的意愿，比如<code>flag[0] = true</code>意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];<span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">// 刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"><span class="comment">// P0进程：</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);<span class="comment">// ①</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">// ②</span></span><br><span class="line">critical section;<span class="comment">// ③</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;<span class="comment">// ④</span></span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">// P1进程：</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);<span class="comment">// ⑤ 如果此时P0想进入临界区，P1就一直循环等待</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;<span class="comment">// ⑥ 标记为P1进程想要进入临界区</span></span><br><span class="line">critical section;<span class="comment">// ⑦ 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">// ⑧ 访问完临界区，修改标记为P1不想使用临界区</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>若按照①⑤②⑥③⑦……的顺序执行，P0和P1将会同时访问临界区。</p><p>因此，双标志先检查法的主要问题是：违反“忙则等待”原则。</p><p>原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</p><h4 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h4><p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临时区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];<span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">// 刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"><span class="comment">// P0进程：</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">// ①</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);<span class="comment">// ②</span></span><br><span class="line">critical section;<span class="comment">// ③</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;<span class="comment">// ④</span></span><br><span class="line">remainder = section;</span><br><span class="line"><span class="comment">// P1进程：</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;<span class="comment">// ⑤ 标记为P1进程都想要进入临界区</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);<span class="comment">// ⑥ 如果P0也想进入临界区，则P1循环等待</span></span><br><span class="line">critical section;<span class="comment">// ⑦ 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">// ⑧ 访问完临界区，修改标记为P1不想使用临界区</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>若按照①⑤②⑥……的顺序执行，P0和P1将都无法进入临界区</p><p>因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿“现象。</p><p>两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。</p><h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p>算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L. Peterson想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方使用临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];<span class="comment">// 表示进入临界区意愿的数组，初始值都是false</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;<span class="comment">// turn表示优先让哪个进程进入临界区</span></span><br><span class="line"><span class="comment">// P0进程：</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">// ①</span></span><br><span class="line">turn = <span class="number">1</span>;<span class="comment">// ②</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>);<span class="comment">// ③</span></span><br><span class="line">critical section;<span class="comment">// ④</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;<span class="comment">// ⑤</span></span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">// P1进程:</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;<span class="comment">// ⑥ 表示自己想进入临界区</span></span><br><span class="line">turn = <span class="number">0</span>;<span class="comment">// ⑦ 可以优先让对方进入临界区</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);<span class="comment">// ⑧ 对方想进，且最后一次是自己“让梨”，那自己就循环等待</span></span><br><span class="line">critical section;<span class="comment">// ⑨</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">// ⑩ 访问完临界区，表示自己已经不想访问临界区了</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>两种双标志法的问题都是由于进入区的几个操作不能一气呵成导致的。我们可以推理验证在Peterson算法中，两个进程进入区中的各个操作按不同的顺序穿插执行会发生什么情况：</p><p>①②③⑥⑦⑧……</p><p>①⑥②③……</p><p>Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。</p><h3 id="2-3-3-进程互斥的硬件实现方法"><a href="#2-3-3-进程互斥的硬件实现方法" class="headerlink" title="2.3.3 进程互斥的硬件实现方法"></a>2.3.3 进程互斥的硬件实现方法</h3><h4 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h4><p>利用“开&#x2F;关中断指令”实现(与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同事访问临界区的情况)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">关中断；<span class="comment">// 关中断后即不允许当前进程被中断，也必然不会发生进程切换</span></span><br><span class="line">临界区；</span><br><span class="line">开中断；<span class="comment">// 直到当前进程访问完临界区，在执行开中断指令，才有可能有别的进程上处理机并访问临界区</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>优点：简单、高效</p><p>缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程(因为开&#x2F;关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)。</p><h4 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h4><p>简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令。</p><p>TSL指令是硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 布尔型共享标量lock表示当前临界区是否被枷锁</span></span><br><span class="line"><span class="comment">// true表示已加锁，false表示未加锁</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span> <span class="params">(<span class="type">bool</span> *lock)</span> &#123;</span><br><span class="line">  <span class="type">bool</span> old;</span><br><span class="line">  old = *lock;<span class="comment">// old用来存放lock原来的值</span></span><br><span class="line">  *lock = <span class="literal">true</span>; <span class="comment">// 无论之前是否已加锁，都将lock设为true</span></span><br><span class="line">  <span class="keyword">return</span> old;<span class="comment">// 返回lock原来的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下是使用TSL指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span> (TestAndSet (&amp;lock));<span class="comment">// &quot;上锁&quot;并“检查”</span></span><br><span class="line">临界区代码段...</span><br><span class="line">lock = <span class="literal">false</span>;<span class="comment">// &quot;解锁&quot;</span></span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure><p>若刚开始lock是false，则TSL返回的old值为false，while循环条件不满足，直接跳过循环，进入临界区。若刚开始lock是true，则执行TLS后old返回的值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p><p>相比软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</p><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等“。</p><h4 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h4><p>有的地方也叫Exchange指令，或简称XCHG指令</p><p>Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swap指令的作用是交换两个变量的值</span></span><br><span class="line">Swap （<span class="type">bool</span> *a, <span class="type">bool</span> *b) &#123;</span><br><span class="line">  <span class="type">bool</span> temp;</span><br><span class="line">  temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下是用Swap指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="comment">// lock表示当前临界区是否被枷锁</span></span><br><span class="line"><span class="type">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (old == <span class="literal">true</span>)</span><br><span class="line">  Swap (&amp;lock, &amp;old);</span><br><span class="line">临界区代码段...</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure><p>逻辑上来看Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁(记录在old变量上)，再将上锁标记lock设置为true，最后检查old，如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p><p>优点：实现简单，无需像软件实现方法那样严格检查是否有逻辑漏洞；适用于多处理机环境</p><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等“。</p><h3 id="2-3-4-信号量机制"><a href="#2-3-4-信号量机制" class="headerlink" title="2.3.4 信号量机制"></a>2.3.4 信号量机制</h3><blockquote><p>进程互斥的解决方案包括软件实现方式：单标志法、双标志先检查、双标志后检查、Peterson算法；硬件实现方式：中断屏蔽方法、TS&#x2F;TSL指令、Swap&#x2F;XCHG指令。但是在双标志先检查法中，进入区的“检查”、“上锁”操作无法一气呵成，从而导致两个进程有可能同时进入临界区的问题；以上所有方法都无法实现“让权等待”原则。1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法——<strong>信号量机制</strong></p></blockquote><p>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</p><p>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。</p><p>原语是一种特殊的程序段，其执行职能一气呵成，不可被中断。原语是由关中断&#x2F;开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</p><p>一对原语：wait(S)原语和signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的信号量S其实就是函数调用时传入的一个参数。</p><p>wait、signal原语常简称为P、V操作(来自荷兰语proberen和verhogen)。因此，做题的时候常把wait(S)、signal(S)两个操作分别写为P(S)、V(S)</p><h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p>用一个<strong>整数型的变量</strong>作为信号量，用来<strong>表示系统中某种资源的数量</strong>。</p><p>与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作</p><p>eg：某计算机系统中有一台打印机……</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">1</span>;<span class="comment">// 初始化整型信号量S，表示当前系统中可用的打印机资源数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span> <span class="params">(<span class="type">int</span> S)</span> &#123;<span class="comment">// wait原语，相当于“进入区”</span></span><br><span class="line">  <span class="keyword">while</span> (S &lt;= <span class="number">0</span>);<span class="comment">// 如果资源数不够，就一直循环等待</span></span><br><span class="line">  S = S - <span class="number">1</span>; <span class="comment">// 如果资源数够，则占用一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(<span class="type">int</span> S)</span> &#123;<span class="comment">// signal原语，相当于“退出区”</span></span><br><span class="line">  S = S + <span class="number">1</span>;<span class="comment">// 使用完资源后，在退出区释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进程P0:</span></span><br><span class="line">...</span><br><span class="line">wati(S);<span class="comment">// 进入区，申请资源</span></span><br><span class="line">使用打印机资源... <span class="comment">// 临界区，访问资源</span></span><br><span class="line">signal(S);<span class="comment">// 退出区，释放资源</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//进程P1:</span></span><br><span class="line">...</span><br><span class="line">wati(S);</span><br><span class="line">使用打印机资源...</span><br><span class="line">signal(S);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//进程P2:</span></span><br><span class="line">...</span><br><span class="line">wati(S);</span><br><span class="line">使用打印机资源...</span><br><span class="line">signal(S);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>wait原语“检查”和“上锁”一气呵成，避免了并发、异步导致的问题。但是还是存在不满足“让权等待”原则，会发生“忙等”</p><h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>整型信号量的缺陷是存在“忙等”问题，因此又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记录型信号量的定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> value;<span class="comment">// 剩余资源数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span><span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"><span class="comment">/*某进程需要使用资源时，通过wait原语申请*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span> <span class="params">(semaphore S)</span> &#123;</span><br><span class="line">  S.value--;</span><br><span class="line">  <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    block(S.L)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*进程使用完资源后，通过signal原语释放*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(semaphore S)</span> &#123;</span><br><span class="line">  S.value++;</span><br><span class="line">  <span class="keyword">if</span> (S.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    wakeup(S.L);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// P0进程：</span></span><br><span class="line">...</span><br><span class="line">wait(S);</span><br><span class="line">使用打印机...</span><br><span class="line">signal(S);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// P1进程：</span></span><br><span class="line">...</span><br><span class="line">wait(S);</span><br><span class="line">使用打印机...</span><br><span class="line">signal(S);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// P2进程：</span></span><br><span class="line">...</span><br><span class="line">wait(S);</span><br><span class="line">使用打印机...</span><br><span class="line">signal(S);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列（即阻塞队列）中。</p><p>释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态。</p><p>wait(S)、signal(S)也可以记为P(S)、V(S)，用于<strong>实现系统资源的“申请”和“释放”</strong>。</p><p><strong>S.value的初值</strong>表示系统中<strong>某种资源的数目</strong>。</p><p>对信号量S的一次P操作意味着进程<strong>请求一个单位的该类资源</strong>，因此需要执行S.value–, 表示资源数减1，当S.value &lt; 0时表示该类资源已分配完毕，因此进程应<strong>调用block原语进行自我阻塞<strong>（当前运行的进程从</strong>运行态 -&gt; 阻塞态</strong>），主动放弃处理机，并插入该类资源的等待队列S.L中。可见，该机制<strong>遵循了“让权等待”原则</strong>，不会出现“忙等”现象。</p><p>对信号量S的<strong>一次V操作</strong>意味着进程<strong>释放一个单位的该类资源</strong>，因此需要执行S.value++, 表示资源数加1，若加1后仍是S.value &lt;&#x3D;. 0，表示仍然有进程在等待该类资源，因此应**调用wakeup原语唤醒等待队列中第一个进程**（被唤醒进程从阻塞态 -&gt; 就绪态）。</p><h3 id="2-3-5-信号量的应用"><a href="#2-3-5-信号量的应用" class="headerlink" title="2.3.5 信号量的应用"></a>2.3.5 信号量的应用</h3><h4 id="实现进程互斥"><a href="#实现进程互斥" class="headerlink" title="实现进程互斥"></a>实现进程互斥</h4><ol><li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</li><li>设置互斥信号量mutex，初始值为1</li><li>在临界区之前执行P(mutex)</li><li>在临界区之后执行V(mutex)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*信号量机制实现互斥*/</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">// 初始化信号量</span></span><br><span class="line">P1() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(mutex);<span class="comment">// 使用临界资源前需要加锁</span></span><br><span class="line">  临界区代码段...</span><br><span class="line">  V(mutex);<span class="comment">// 使用临界资源后需要解锁</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(mutex);</span><br><span class="line">  临界区代码段...</span><br><span class="line">  V(mutex);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ps: 对<strong>不同的临界资源</strong>需要<strong>设置不同的互斥信号量</strong>。<strong>P、V操作必须成对出现</strong>。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</p><h4 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a>实现进程同步</h4><p>进程同步：各并发进程按要求有序地推进。</p><p>用信号量实现进程同步：</p><ol><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作(或两句代码)</li><li>设置同步信号量S，初始值为0</li><li>在“前操作”之后执行V操作</li><li>在“后操作”之前执行P操作</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*信号量机制实现同步*/</span></span><br><span class="line">semaphore S = <span class="number">0</span>;<span class="comment">// 初始化同步信号量，初始值为0</span></span><br><span class="line">P1() &#123;</span><br><span class="line">  代码<span class="number">1</span>;</span><br><span class="line">  代码<span class="number">2</span>;</span><br><span class="line">  V(S);</span><br><span class="line">  代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">  P(S);</span><br><span class="line">  代码<span class="number">4</span>;</span><br><span class="line">  代码<span class="number">5</span>;</span><br><span class="line">  代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若先执行到V(S)操作，则S++后S &#x3D; 1。之后当执行到P(S)操作时，由于S &#x3D; 1，表示有可用资源，会执行S–，S的值变回0，P2进程不会执行block原语，而是继续往下执行代码4。</p><p>若先执行到P(S)操作，由于S&#x3D;0，S–后S &#x3D; -1，表示此时没有可用资源，因此P操作会执行block原语，主动请求阻塞。之后当执行完代码2，继而执行V(S)操作，S++，使S变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作执行wakeup原语，唤醒P2进程。这样P2就可以继续执行代码4了。</p><h4 id="实现进程的前驱关系"><a href="#实现进程的前驱关系" class="headerlink" title="实现进程的前驱关系"></a>实现进程的前驱关系</h4><p>进程P1中有句代码S1，P2中有句代码S2，… P3 …P6中有句代码S6。这些代码要求按如下前驱图所示的顺序来执行：</p><p><img src="/../img/operationSystem/%E5%89%8D%E9%A9%B1%E5%9B%BE.png" alt="前驱图"></p><p>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）</p><ol><li>要为每一对前驱关系各设置一个同步变量</li><li>在“前操作”之后对相应的同步变量执行V操作</li><li>在“后操作”之前对相应的同步变量执行P操作</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">P1() &#123;</span><br><span class="line">  ...</span><br><span class="line">  S1;</span><br><span class="line">  V(a);</span><br><span class="line">  V(b);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(a);</span><br><span class="line">  S2;</span><br><span class="line">  V(c);</span><br><span class="line">  V(d);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">P3() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(b);</span><br><span class="line">  S3;</span><br><span class="line">  V(g);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">P4() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(c);</span><br><span class="line">  S4;</span><br><span class="line">  V(e);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">P5() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(d);</span><br><span class="line">  S5;</span><br><span class="line">  V(f);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">P6() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(e);</span><br><span class="line">  P(f);</span><br><span class="line">  P(g);</span><br><span class="line">  S6;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-6-生产者-消费者问题"><a href="#2-3-6-生产者-消费者问题" class="headerlink" title="2.3.6 生产者-消费者问题"></a>2.3.6 生产者-消费者问题</h3><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区取出一个产品并使用。（这里的“产品”理解为某种数据）。</p><p>生产者、消费者共享一个初始为空、大小为n的缓冲区。</p><p>分析：</p><ul><li><p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</p><p>  同步关系。缓冲区满时，生产者要等待消费者取走产品</p></li><li><p>只有缓冲区不为空时，消费者才能从中取出产品，否则必须等待。</p><p>  同步关系。缓冲区空时，消费者要等待生产者放入产品</p></li><li><p>缓冲区是临界资源，各进程必须互斥地访问。</p><p>  互斥</p></li></ul><p>处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">// 互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore enpty = n;<span class="comment">// 同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;<span class="comment">// 同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br><span class="line">producer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    生产一个产品;</span><br><span class="line">    P(empty);<span class="comment">// ①</span></span><br><span class="line">    P(mutex);<span class="comment">// ②</span></span><br><span class="line">    把产品放入缓冲区;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(full);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(full);<span class="comment">// ③</span></span><br><span class="line">    P(mutex);<span class="comment">// ④</span></span><br><span class="line">    从缓冲区取出一个产品;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(empty);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：能够修改①和②，③和④的顺序。</p><p>如果修改，若此时缓冲区内已经放满产品，则empty &#x3D; 0，full &#x3D; n。</p><p>则生产者进程执行②使mutex &#x3D; 0，在执行①，由于已经没有空闲缓冲区，因此生产者被阻塞。由于生产者阻塞，因此切换回消费者进程。消费者进程执行④，由于mutex &#x3D; 0，即生产者还没有释放对临界资源的“锁”，因此消费者也被阻塞。</p><p>这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“死锁”。</p><p>同样的，若缓冲区中没有产品，即full &#x3D; 0，empty &#x3D; n。按④③②的顺序执行也会发生死锁。</p><p>因此，<strong>实现互斥的P操作一定要在实现同步的P操作之后</strong>。</p><p>V操作不会导致进程阻塞，因此两个V操作顺序可以交换。</p><h3 id="2-3-7-多生产者-多消费者问题"><a href="#2-3-7-多生产者-多消费者问题" class="headerlink" title="2.3.7 多生产者-多消费者问题"></a>2.3.7 多生产者-多消费者问题</h3><p> 桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可以向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</p><p><strong>分析：</strong></p><p>互斥关系：（mutex &#x3D; 1）</p><p>对缓冲区（盘子）的访问要互斥地进行</p><p>同步关系：（一前一后）</p><ol><li>父亲将苹果放入盘子后，女儿才能取苹果</li><li>母亲将橘子放入盘子后，儿子才能取橘子</li><li>只有盘子为空时，父亲或母亲才能放入水果</li></ol><p><strong>实现：</strong></p><p><img src="/../img/operationSystem/%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85.png" alt="多生产者多消费者"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">// 实现互斥访问盘子（缓冲区）</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;<span class="comment">// 盘子中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>;<span class="comment">// 盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;<span class="comment">// 盘子中还可以放多少个水果</span></span><br><span class="line">dad() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    准备一个苹果;</span><br><span class="line">    P(plate);</span><br><span class="line">    P(mutex);</span><br><span class="line">    把苹果放入盘子;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(apple);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">mom() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    准备一个橘子;</span><br><span class="line">    P(plate);</span><br><span class="line">    P(mutex);</span><br><span class="line">    把橘子放入盘子;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(orange);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">daughter() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(apple);</span><br><span class="line">    P(mutex);</span><br><span class="line">    从盘子中取出苹果;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(plate);</span><br><span class="line">    吃掉苹果;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">son() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(orange);</span><br><span class="line">    P(mutex);</span><br><span class="line">    从盘子中取出橘子;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(plate);</span><br><span class="line">    吃掉橘子;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考：</strong>可不可以不用互斥信号量</p><p><strong>分析：</strong>刚开始，儿子、女儿进程即使上处理机也会被阻塞。如果刚开始是父亲进程先上处理机，则：父亲P(plate)，可以访问盘子 -&gt; 母亲P(plate)，阻塞等待盘子 -&gt; 父亲放入苹果V(apple)，女儿进程被唤醒，其他进程即使运行也都会阻塞，暂时不可能访问临界资源(盘子) -&gt; 女儿P(apple)，访问盘子，V(plate)，等待盘子的母亲进程被唤醒 -&gt; 母亲进程访问盘子（其他进程暂时都无法进入临界区） -&gt; ……</p><p><strong>结论：</strong></p><p>当缓冲区的容量为1时，即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象。因为缓冲区的大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区……但是，当缓冲区的容量大于1时，会出现两个进程同时访问缓冲区的情况，有可能导致连个进程写入缓冲区的数据相互覆盖的情况。所以，如果缓冲区的大小大于1，就必须专门设置一个互斥信号量mutex来保证互斥访问缓冲区。</p><p><strong>总结：</strong></p><p>在生产者-消费者问题中，如果缓冲区大小为1，那么<strong>有可能</strong>不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</p><h3 id="2-3-8-吸烟者问题"><a href="#2-3-8-吸烟者问题" class="headerlink" title="2.3.8 吸烟者问题"></a>2.3.8 吸烟者问题</h3><p><strong>描述：</strong></p><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一只烟，抽烟者需要三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放在桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复（让三哥抽烟者轮流地抽烟）</p><p><strong>分析：</strong></p><ul><li>组合一：纸+胶水</li><li>组合二：烟草+胶水</li><li>组合三：烟草+纸</li></ul><p>同步关系：</p><ul><li>桌子上有组合一 -&gt; 第一个抽烟者取走东西</li><li>桌子上有组合二 -&gt; 第二个抽烟者取走东西</li><li>桌子上有组合三 -&gt; 第三个抽烟者取走东西</li><li>发出完成信号 -&gt; 供应者将下一个组合放到桌子上</li></ul><p><img src="/../img/operationSystem/%E6%8A%BD%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98.png" alt="抽烟者问题"></p><p><strong>实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>;<span class="comment">// 桌上组合一的数量</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>;<span class="comment">// 桌上组合二的数量</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>;<span class="comment">// 桌上组合三的数量</span></span><br><span class="line">semaphore finish = <span class="number">0</span>;<span class="comment">// 抽烟是否完成</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;<span class="comment">// 用于实现“三个抽烟者轮流抽烟”</span></span><br><span class="line">provider() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      将组合一放桌上;</span><br><span class="line">      V(offer1);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">      将组合二放桌上;</span><br><span class="line">      V(offer2);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>) &#123;</span><br><span class="line">      将组合三放桌上;</span><br><span class="line">      V(offer3);</span><br><span class="line">    &#125;</span><br><span class="line">    i = (i + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">    P(finish);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker1() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(offer1):</span><br><span class="line">    从桌上拿走组合一;</span><br><span class="line">    卷烟;</span><br><span class="line">    抽掉;</span><br><span class="line">    V(finish);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker2() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(offer2):</span><br><span class="line">    从桌上拿走组合二;</span><br><span class="line">    卷烟;</span><br><span class="line">    抽掉;</span><br><span class="line">    V(finish);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker3() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(offer3):</span><br><span class="line">    从桌上拿走组合三;</span><br><span class="line">    卷烟;</span><br><span class="line">    抽掉;</span><br><span class="line">    V(finish);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-9-读者-写者问题"><a href="#2-3-9-读者-写者问题" class="headerlink" title="2.3.9 读者-写者问题"></a>2.3.9 读者-写者问题</h3><p> <strong>问题</strong>：</p><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p><ol><li>允许多个读者可以同时对文件执行读操作；</li><li>只允许一个写者往文件中写信息；</li><li>任一写者在完成写操作之前不允许其他读者或写者工作；</li><li>写者执行写操作前，应让已有的读者和写者全部退出。</li></ol><p><strong>分析：</strong></p><p>两类进程：写进程、读进程</p><p>互斥关系：写进程—写进程、写进程—读进程。读进程与读进程不存在互斥关系。</p><ul><li><p>写者进程和任何进程都互斥，设置一个互斥信号量rw，在写者访问共享文件前后分别执行P、V操作。</p></li><li><p>读者进程和写者进程也要互斥，因此读者访问共享文件前后也要对rw执行P、V操作。</p></li><li><p>如果所有读者进程在访问共享文件之前都执行P(rw)操作，那么会导致各个读进程之间无法同时访问文件。</p></li><li><p><strong>读者写者问题的核心思想——怎么处理该问题呢？</strong></p><p>  P(rw)和V(rw)其实就是对共享文件的“加锁”和“解锁”。既然各个读进程需要同时访问，而读进程与写进程又必须互斥访问，那么我们可以让第一个访问文件的读进程“加锁”，让最后一个访问完文件的读进程“解锁”。可以设置一个整数变量count来记录当前有几个读进程在访问文件。</p></li></ul><p><strong>实现一：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>;<span class="comment">// 用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">writer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(rw);<span class="comment">// 写之前“加锁”</span></span><br><span class="line">    写文件...;</span><br><span class="line">    V(rw);<span class="comment">// 写之后“解锁”</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">      P(rw);<span class="comment">// 第一个读进程负责“加锁”</span></span><br><span class="line">    &#125;</span><br><span class="line">    count++;<span class="comment">// 访问文件的进程书+1</span></span><br><span class="line">    读文件...;</span><br><span class="line">    count--;<span class="comment">// 访问文件的读进程数-1</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">      V(rw);<span class="comment">// 最后一个读进程负责“解锁“</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考：</strong></p><p>若两个读进程并发执行，则两个读进程可能先后执行P(rw), 从而使第二个读进程阻塞的情况。</p><p>如何解决：</p><p>出现上述问题的原因在于对count变量的检查和赋值无法一气呵成，因此可以设置另一个互斥信号量来保证各读进程count的访问时互斥的。</p><p><strong>实现二：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>;<span class="comment">// 用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">// 用于保证对count变量的互斥访问 </span></span><br><span class="line">writer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(rw);<span class="comment">// 写之前“加锁”</span></span><br><span class="line">    写文件...;</span><br><span class="line">    V(rw);<span class="comment">// 写之后“解锁”</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(mutex);<span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">      P(rw);<span class="comment">// 第一个读进程负责“加锁”</span></span><br><span class="line">    &#125;</span><br><span class="line">    count++;<span class="comment">// 访问文件的进程书+1</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    读文件...;</span><br><span class="line">    P(mutex);<span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">    count--;<span class="comment">// 访问文件的读进程数-1</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">      V(rw);<span class="comment">// 最后一个读进程负责“解锁“</span></span><br><span class="line">    &#125;</span><br><span class="line">    V(mutex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>潜在的问题：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此，这种算法中，读进程是优先的。</p></blockquote><p><strong>实现三：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>;<span class="comment">// 用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">// 用于保证对count变量的互斥访问 </span></span><br><span class="line">semaphore w = <span class="number">1</span>;<span class="comment">// 用于实现“写优先”</span></span><br><span class="line">writer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(w);</span><br><span class="line">    P(rw);<span class="comment">// 写之前“加锁”</span></span><br><span class="line">    写文件...;</span><br><span class="line">    V(rw);<span class="comment">// 写之后“解锁”</span></span><br><span class="line">    V(w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(w);</span><br><span class="line">    P(mutex);<span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">      P(rw);<span class="comment">// 第一个读进程负责“加锁”</span></span><br><span class="line">    &#125;</span><br><span class="line">    count++;<span class="comment">// 访问文件的进程书+1</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    V(w);</span><br><span class="line">    读文件...;</span><br><span class="line">    P(mutex);<span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">    count--;<span class="comment">// 访问文件的读进程数-1</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">      V(rw);<span class="comment">// 最后一个读进程负责“解锁“</span></span><br><span class="line">    &#125;</span><br><span class="line">    V(mutex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><p>在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。也称为“读写公平法”。</p><h3 id="2-3-10-哲学家进餐问题"><a href="#2-3-10-哲学家进餐问题" class="headerlink" title="2.3.10 哲学家进餐问题"></a>2.3.10 哲学家进餐问题</h3><p><strong>问题：</strong></p><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌子摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子(一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p><p><img src="/../img/operationSystem/%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98.png" alt="哲学家进餐问题"></p><p><strong>分析：</strong></p><ol><li>关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</li><li>整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。</li><li>信号量设置。定义互斥信号量数组chopstick[5]&#x3D;{1,1,1,1,1}用于实现对5个筷子的互斥访问。并对哲学家按0～4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5。</li></ol><p><strong>思考：</strong></p><p>如何防止死锁的发生？</p><ol><li>可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。</li><li>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一支筷子，另一个会直接阻塞。这就避免了占有一只后再等待另一只的情况。</li><li>规定同时只有一个哲学家能拿起筷子吃饭</li></ol><p><strong>实现3：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">// 互斥地取筷子</span></span><br><span class="line">Pi() &#123;<span class="comment">// i号哲学家的进程</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    P(chopstick[i]);<span class="comment">// 拿左边的筷子</span></span><br><span class="line">    p(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">// 拿右边的筷子</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    吃饭...;</span><br><span class="line">    V(chopstick[i]);<span class="comment">// 放下左边的筷子</span></span><br><span class="line">    V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">// 放下右边的筷子</span></span><br><span class="line">    思考...;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-11-管程"><a href="#2-3-11-管程" class="headerlink" title="2.3.11 管程"></a>2.3.11 管程</h3><h4 id="为什么要引入管程"><a href="#为什么要引入管程" class="headerlink" title="为什么要引入管程"></a>为什么要引入管程</h4><p>信号量机制存在的问题：编写程序困难、易出错。程序员在编程时需要关注复杂的PV操作。</p><h4 id="管程的定义和基本特征"><a href="#管程的定义和基本特征" class="headerlink" title="管程的定义和基本特征"></a>管程的定义和基本特征</h4><p>管程是一种特殊的软件模块，有这些部分组成：</p><ol><li>局部于管程的<strong>共享数据结构</strong>说明；</li><li>对该数据结构进行操作的<strong>一组过程</strong>（“过程”就是“函数”）；</li><li>对局部于管程的<strong>共享数据设置初始值的语句</strong>；</li><li>管程有一个名字。</li></ol><p><strong>管程的基本特征</strong>：</p><ol><li>局部于管程的数据智能被局部于管程的过程所访问；</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li><li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong>。</li></ol><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p><strong>用管程解决生产中消费者问题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">  condition full, empty;<span class="comment">//条件变量用来实现同步（排队）</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">// 缓冲区中的产品数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(count == N) &#123;</span><br><span class="line">      wait(full);</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">    insert_item(item);</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">1</span>) &#123;</span><br><span class="line">      signal(empty);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">Item <span class="title function_">remove</span><span class="params">()</span> &#123;<span class="comment">// 从缓冲区中取出一个产品</span></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">      wait(empty);</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span>(count == N<span class="number">-1</span>) &#123;</span><br><span class="line">      signal(full);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> remove_item();</span><br><span class="line">  &#125;</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line">producer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    item = 生产一个产品;</span><br><span class="line">    ProducerConsumer.insert(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者进程</span></span><br><span class="line">consumer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    item = ProducerConsumer.remove();</span><br><span class="line">    消费产品item;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>管程中设置条件变量和等待&#x2F;唤醒操作，以解决同步问题。</p><p><strong>由编译器负责实现个进程互斥地进入管程中的过程。</strong></p></blockquote><p>引入管程的目的无非就是要更方便地实现进程互斥和同步。</p><ol><li>需要在管程中定义共享数据(如生产者消费者问题中的缓冲区)</li><li>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数（如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，在定义一个函数用于从缓冲区取出产品）</li><li>只有<strong>通过这些特定的“入口”才能访问共享数据</strong></li><li>管程中有很多“入口”，但是<strong>每次只能开放其中一个“入口”</strong>，并且<strong>只能让一个进程或线程进入</strong>（如生产者消费者问题中，个进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意：<strong>这种互斥特性是由编译器负责实现的，程序员不用关心</strong>。）</li><li>可在管程中设置条件变量即等待&#x2F;唤醒操作以解决同步问题。可以让一个进程或线程在田间变量上等待（此时，该进程应先释放管程的使用权，也就是让出“入口”）；可以通过唤醒操作将等待在条件上的进程或线程唤醒。</li></ol><p><strong>Java中，如果用关键字Synchronized来描述一个函数，那么这个函数同一时间段内只能被一个线程调用</strong>。</p><h3 id="2-4-1-死锁的概念"><a href="#2-4-1-死锁的概念" class="headerlink" title="2.4.1 死锁的概念"></a>2.4.1 死锁的概念</h3><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>在并发环境下，个进程因竞争资源而造成的一种**互相等待对方手里的资源，导致进程都阻塞，都无法向前推进的现象，就是死锁。</p><h4 id="死锁、饥饿、死循环的区别"><a href="#死锁、饥饿、死循环的区别" class="headerlink" title="死锁、饥饿、死循环的区别"></a>死锁、饥饿、死循环的区别</h4><p>死锁：各进程相互等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p><p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先(SPF)算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</p><p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。</p><table><thead><tr><th align="center"></th><th align="center">区别</th></tr></thead><tbody><tr><td align="center">死锁</td><td align="center">死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那至少<strong>有两个或两个以上的进程同时发生死锁</strong>。另外，发生死锁的进程一定处于阻塞态。</td></tr><tr><td align="center">饥饿</td><td align="center"><strong>可能只有一个进程发生饥饿</strong>。发生饥饿的进程既可能是阻塞态（如长期得不到需要的I&#x2F;O设备），也可能是就绪态（长期得不到处理机）</td></tr><tr><td align="center">死循环</td><td align="center">可能只有一个进程发生死循环。死循环的进程可以上处理机运行(可以是运行态)，只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。<strong>死锁和饥饿是管理者(操作系统)的问题，死循环是被管理者的问题</strong></td></tr></tbody></table><blockquote><p>共同点：都是进程无法顺利向前推进的现象（故意设计的死循环除外）。</p></blockquote><h4 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h4><p>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ol><li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源)。</li><li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ol><p>Tips：发生死锁时一定有循环等待，但是发生循环等待时未必死锁(循环等待是死锁的必要不充分条件)。如果同类资源数大于1，则及时有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p><h4 id="什么时候会发生死锁"><a href="#什么时候会发生死锁" class="headerlink" title="什么时候会发生死锁"></a>什么时候会发生死锁</h4><ol><li>对系统资源的竞争。各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的。</li><li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两种会因为申请的资源被对方占有而阻塞，从而发生死锁。</li><li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看作是一种抽象的系统资源）</li></ol><p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p><h3 id="2-4-2-死锁的处理策略-预防死锁"><a href="#2-4-2-死锁的处理策略-预防死锁" class="headerlink" title="2.4.2 死锁的处理策略-预防死锁"></a>2.4.2 死锁的处理策略-预防死锁</h3><h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。</p><p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如SPOOLing技术。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备……</p><p>该策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。</p><h4 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h4><p>不剥夺条件：进程所获得的资源在未使用完之前，不能有其他进程强行夺走，只能主动释放。</p><p>破坏不剥夺条件：</p><p>方案一：当某个进程请求新的资源得不到满足时，他必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p><p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级(比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)</p><p>该策略的缺点：</p><ol><li>实现起来比较复杂</li><li>释放已获得的资源可能造成前一阶段工作的实效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li></ol><h4 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h4><p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</p><p>可以采用静态分配方法，即进程在运行前一次申请完他所需要的全部资源，在他的资源为满足前，不让他投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p><p>该策略实现起来简单，但也有明显的缺点：</p><p>有些资源可能只需要很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</p><h4 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h4><p>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</p><p>可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（机编号相同的资源）一次申请完。</p><p>原理分析：一个进程只有已占有小编好的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编好的资源，从而就不会产生循环等待的现象。</p><p>该策略的缺点：</p><ol><li>不方便增加新的设备，因为可能需要重新分配所有的编号</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li><li>必须按规定次序申请资源，用户编程麻烦</li></ol><h3 id="2-4-3-死锁的处理策略-避免死锁"><a href="#2-4-3-死锁的处理策略-避免死锁" class="headerlink" title="2.4.3 死锁的处理策略-避免死锁"></a>2.4.3 死锁的处理策略-避免死锁</h3><h4 id="什么是安全序列"><a href="#什么是安全序列" class="headerlink" title="什么是安全序列"></a>什么是安全序列</h4><p><strong>银行家算法：</strong></p><p>你是一位成功的银行家，手里掌握着100个亿的资金……有三个企业想找你贷款，分别是企业B、企业A、企业T，为了方便描述，简称BAT。</p><ul><li>B表示：“大哥，我最多会跟你姐70亿……”</li><li>A表示：“大哥，我最多会跟你借40亿……”</li><li>T表示：“大哥，我最多会跟你借50亿……”</li></ul><p>然而江湖中有个不成文的规矩：如果你借给企业的钱总数达不到企业提出的最大要求，那么不管你之前给企业借了多少钱，那些钱都拿不回来了……</p><p>刚开始，BAT三个企业分别从你这借了20、10、30亿……</p><table><thead><tr><th align="center"></th><th align="center">最大需求</th><th align="center">已借走</th><th align="center">最多还会借</th></tr></thead><tbody><tr><td align="center">B</td><td align="center">70</td><td align="center">20</td><td align="center">50</td></tr><tr><td align="center">A</td><td align="center">40</td><td align="center">10</td><td align="center">30</td></tr><tr><td align="center">T</td><td align="center">50</td><td align="center">30</td><td align="center">20</td></tr></tbody></table><p>所谓<strong>安全序列</strong>，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</p><p>如果分配了资源之后，系统中找不到任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。</p><p>银行家算法是荷兰学者Dijkstra为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用来避免死锁。</p><p><strong>核心思想：</strong>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p><p>可以把单维的数字拓展为多维的向量。比如：系统中有5个进程P0～P4，3中资源R0～R2，初始数量为(10，5，7)。</p><p>假设系统中有n个进程，m种资源，每个进程在运行前先声明对各种资源的最大需求数，则可用一个n×m的矩阵(可用二维数组实现)表示所有进程对各种资源的最大需求数。不妨称为最大需求矩阵Max，Max[i,j]&#x3D;k表示进程Pi最多需要k个资源Rj。同理，系统可以用一个n×m的分配矩阵Allocation表示对所有进程的资源分配情况。Max-Allocation&#x3D;Need矩阵，表示各进程最多还需要多少各类子资源。</p><p>另外，还要用一个长度为m的一维数组Available表示当前系统中还有多少可用资源。</p><p>某进程Pi向系统申请资源，可用一个长度为m的一维数组Request<sub>i</sub>表示本次申请的各种资源量。</p><p>可用银行家算法预判本次分配是否会导致系统进入不安全状态：</p><ol><li><p>如果Request<sub>i</sub>[j]&lt;&#x3D;Need[i,j] (0&lt;&#x3D;j&lt;&#x3D;m) 便转向2；否则认为出错。</p></li><li><p>如果Request<sub>i</sub>[j]&lt;&#x3D;Available[j] (0&lt;&#x3D;j&lt;&#x3D;m)，便转向3；否则表示尚无足够资源，Pi必须等待。</p></li><li><p>系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判）：</p><p> Available &#x3D; Available - Request<sub>i</sub> ;</p><p> Allocation[i,j] &#x3D; Allocation[i, j] + Request<sub>i</sub>[j] ;</p><p> Need[i, j] &#x3D; Need[i, j] - Request<sub>i</sub>[j]</p></li><li><p>操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。</p></li></ol><h3 id="2-4-4-死锁的处理策略-检测和解除"><a href="#2-4-4-死锁的处理策略-检测和解除" class="headerlink" title="2.4.4 死锁的处理策略-检测和解除"></a>2.4.4 死锁的处理策略-检测和解除</h3><p>数据结构：资源分配图</p><p><img src="/../img/operationSystem/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png" alt="资源分配图"></p><ul><li>两种节点<ul><li>进程节点：对应一个进程</li><li>资源节点：对应一类资源，一类资源可能有多个</li></ul></li><li>两种边<ul><li>进程节点 -&gt; 资源节点：表示进程想申请几个资源（每条边代表一个）</li><li>资源节点 -&gt; 进程节点：表示已经为进程分配了几个资源（每条边代表一个）</li></ul></li></ul><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><p>为了能对系统是否已发生了死锁进行检测，必须：</p><p>①用某种数据结构来保存资源的请求和分配信息；</p><p>②提供一种算法，利用上述信息来检测系统是否已进入死锁状态。</p><p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程……</p><p>如果按上述过程分析，最终能消除所有边，就称这个图是<strong>可完全简化的</strong>。此时一定没有发生死锁（相当于能找到一个安全序列）</p><p>如果最终不能消除所有边，那么此时就是发生了死锁。</p><p>最终还连着边的那些进程就是处于死锁状态的进程。</p><p><strong>检测死锁的算法：</strong></p><ol><li>在资源分配图中，找出既不阻塞又不是孤点的进程Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。</li><li>进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。</li></ol><p>死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。</p><h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h4><p>一旦检测出死锁的发生，就应该立即揭出死锁。</p><p>补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法<strong>化简资源分配图后，还连着边的那些进程就是死锁进程</strong></p><p>解除死锁的主要方法有：</p><ol><li>资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占他的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li></ol><p>Tips：如何决定“对谁下手“</p><ol><li>进程优先级</li><li>已执行多长时间</li><li>还要多久能完成</li><li>进程已经使用了多少资源</li><li>进程是交互式的还是批处理式的</li></ol><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="3-1-1-内存的基础知识"><a href="#3-1-1-内存的基础知识" class="headerlink" title="3.1.1 内存的基础知识"></a>3.1.1 内存的基础知识</h3><h4 id="什么是内存，有何作用"><a href="#什么是内存，有何作用" class="headerlink" title="什么是内存，有何作用"></a>什么是内存，有何作用</h4><p>内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。</p><p><img src="/../img/operationSystem/%E5%86%85%E5%AD%98.png" alt="内存"></p><p>内存中各有一个一个的“小房间”，每个小房间就是一个“存储单元”。如果计算机“按字节编址”，则每个存储单元大小为1字节，即1B，即8个二进制位。</p><p>内存地址从0开始，每个地址对应一个存储单元</p><p><strong>常见的数量单位</strong></p><p>2<sup>10</sup> &#x3D; 1K(千)</p><p>2<sup>20</sup> &#x3D; 1M(兆，百万)</p><p>2<sup>30</sup> &#x3D; 1G(十亿，千兆)</p><p>Ps：一台手机&#x2F;电脑有4GB内存，是什么意思？</p><p>是指该内存中可以存放4*2<sup>30</sup>个字节。如果是按字节编址的话，也就是有4*<sup>30</sup> &#x3D; 2<sup>32</sup>个“小房间”。这么多“小房间”，需要2<sup>32</sup>个地址才能一一标识，所以地址需要用32个二进制位来表示（0～2<sup>32</sup>-1）。</p><h4 id="进程运行的基本原理"><a href="#进程运行的基本原理" class="headerlink" title="进程运行的基本原理"></a>进程运行的基本原理</h4><p><strong>指令</strong></p><p>我们平时写的代码通过编译成CPU能够识别的指令。指令会告诉CPU应该去内存的哪个地址存&#x2F;取数据，这个数据应该做怎样的处理。</p><p><strong>逻辑地址 &amp; 物理地址</strong></p><blockquote><p>宿舍四个人一起出去旅行，四个人的学号尾号分别是0、1、2、3。住酒店时，酒店给你们安排了4个房号相连的房间。四个人按学号递增次序入住房间。比如0、1、2、3号同学分别去住了5、6、7、8号房间。四个人的编号0、1、2、3、4其实就是一个“相对位置”，而各自入住的房间号是一个“绝对位置”。只要知道0号同学住的是房间号为N的房间，那么M号同学的房号一定是N+M。也就是说，只要知道各个同学的“相对位置”和“起始房号”，就一定可以算出所有同学的“绝对位置”</p></blockquote><p>指令中的地址也可以采用这种思想。编译时产生的指令只关心“相对地址”，实际放入内存中时再想办法根据起始位置得到“绝对地址”。</p><p>eg：编译时只需要确定变量x存放的相对地址是100（也就是说相对进程在内存中的起始地址而言的地址）。CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。</p><p><strong>相对地址</strong>又称<strong>逻辑地址</strong>，<strong>绝对地址</strong>又称<strong>物理地址</strong>。</p><p><strong>从写程序到程序运行</strong></p><p><img src="/../img/operationSystem/%E4%BB%8E%E5%86%99%E7%A8%8B%E5%BA%8F%E5%88%B0%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C.png" alt="从写程序到程序运行"></p><p>编译：由编译程序将用户源码编译成若干个目标模块(编译就是把高级语言翻译为机器语言)</p><p>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块</p><p>装入(装载)：由装入程序将装入模块装入内存运行</p><h4 id="三种链接方式："><a href="#三种链接方式：" class="headerlink" title="三种链接方式："></a>三种链接方式：</h4><ul><li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件(装入模块)，之后不再拆开。</li><li>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式。</li><li>运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</li></ul><h4 id="三种装入方式："><a href="#三种装入方式：" class="headerlink" title="三种装入方式："></a>三种装入方式：</h4><p><strong>绝对装入</strong></p><p>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。</p><p>绝对装入<strong>只适合用于单道程序环境</strong>。程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时在转换为绝对地址。</p><p><strong>静态重定位</strong></p><p>又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时依次完成的）。</p><p>静态重定位的特点是在一个作业装入内存时，必须分配器要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</p><p><strong>动态重定位</strong></p><p>又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。</p><p>重定位寄存器：存放装入模块存放的起始位置。</p><p>采用动态重定位时允许程序在内存中发生移动。并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</p><h3 id="3-1-2-内存管理的概念"><a href="#3-1-2-内存管理的概念" class="headerlink" title="3.1.2 内存管理的概念"></a>3.1.2 内存管理的概念</h3><blockquote><p>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？</p></blockquote><h4 id="内存空间的分配与回收"><a href="#内存空间的分配与回收" class="headerlink" title="内存空间的分配与回收"></a>内存空间的分配与回收</h4><p>操作系统负责内存空间的分配与回收</p><h4 id="内存空间的扩展"><a href="#内存空间的扩展" class="headerlink" title="内存空间的扩展"></a>内存空间的扩展</h4><p>操作系统需要提供某种技术从逻辑上对<strong>内存空间进行扩充</strong></p><h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而<strong>逻辑地址到物理地址的转换</strong>(这个过程称为地址定位)应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。</p><h4 id="存储保护"><a href="#存储保护" class="headerlink" title="存储保护"></a>存储保护</h4><p>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。</p><p>方法一：</p><p>在CPU设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</p><p>方法二：采用<strong>重定位寄存器</strong>(又称<strong>基址寄存器</strong>)和<strong>界地址寄存器</strong>(又称<strong>限长寄存器</strong>)进行越界检查。重定位寄存器中存放的是进程的<strong>起始物理地址</strong>。界地址寄存器中存放的是进程的<strong>最大逻辑地址</strong>。</p><h3 id="3-1-3-覆盖与交换"><a href="#3-1-3-覆盖与交换" class="headerlink" title="3.1.3 覆盖与交换"></a>3.1.3 覆盖与交换</h3><h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><blockquote><p>早起的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常会出现内存大小不够的情况。后来人们引入了覆盖技术，用来解决“程序大小超过物理内存综合”的问题。</p></blockquote><p>覆盖技术的思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时掉入内存。</p><p>内存中分为一个“固定区”和若干个“覆盖区”。</p><p>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）</p><p>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存。</p><p><img src="/../img/operationSystem/%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF.png" alt="覆盖技术"></p><p>按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一个覆盖区。</p><p>缺点：必须由程序员声明覆盖结构，操作系统完成自动覆盖。对用户不透明，增加了用户编程负担。覆盖技术只用于早起的操作系统中，现在已成为历史。</p><h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><p>交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</p><p>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</p><p>暂时换出外存等待的进程状态为挂起状态（挂起态，suspend）</p><p>挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</p><ol><li><p>应该在外存（磁盘）的什么位置保存被换出的进程？</p><p> <img src="/../img/operationSystem/%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4.png" alt="磁盘存储空间"></p><p> 具有对换功能的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分。文件区主要用于存放文件，<strong>主要追求存储空间的利用率</strong>，因此对文件区空间的管理<strong>采用离散分配方式</strong>；对换区空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理<strong>主要追求换入换出速度</strong>，因此通常对换区<strong>采用连续分配方式</strong>。总之，<strong>对换区的I&#x2F;O速度比文件区的更快</strong>。</p></li><li><p>什么时候应该交换？</p><p> 交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停，例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。</p></li><li><p>应该换出哪些进程？</p><p> 可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间……</p></li></ol><blockquote><p>Tip：PCB会常驻内存，不会被换出外存。</p></blockquote><h3 id="3-1-4-连续分配管理方式"><a href="#3-1-4-连续分配管理方式" class="headerlink" title="3.1.4 连续分配管理方式"></a>3.1.4 连续分配管理方式</h3><h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><p><img src="/../img/operationSystem/%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D.png" alt="单一连续分配"></p><p>在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。</p><p>内存中只能有一道用户程序，用户程序独占整个用户区空间。</p><p>优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早起的PC操作系统MS-DOS）。</p><p>缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。</p><h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><p><img src="/../img/operationSystem/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D.png" alt="固定分区分配"></p><p>20世纪60年代出现了多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会互相干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p><p>固定分区分配与两种方式：</p><ul><li><p>分区大小相等</p><p>  缺乏灵活性，但是很适用于一台计算机控制多个相同对象的场合（比如：钢铁厂有n个相同的锻钢炉，就可以把内存分为n个大小相等的区域存放n个炼钢炉控制程序）</p></li><li><p>分区大小不等</p><p>  增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区、适量中等分区、少量大分区）</p></li></ul><p>操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表象对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。</p><table><thead><tr><th align="center">分区号</th><th align="center">大小（MB）</th><th align="center">起始地址（M）</th><th align="center">状态</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">2</td><td align="center">8</td><td align="center">未分配</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">10</td><td align="center">未分配</td></tr><tr><td align="center">3</td><td align="center">4</td><td align="center">12</td><td align="center">已分配</td></tr><tr><td align="center">……</td><td align="center">……</td><td align="center">……</td><td align="center">……</td></tr></tbody></table><p>当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。</p><p>优点：实现简单，无外部碎片。</p><p>缺点：</p><ul><li>当用户程序太大时，可能所有的分区都不满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能</li><li>会产生内部碎片，内存利用率低。</li></ul><h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p>动态分区又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg：假设某计算机内存大小为64MB，系统区8MB，用户区共56MB……）</p><ol><li><p>系统要用什么样的数据结构记录内存的使用情况？</p><p> 两种常用的数据结构：空闲分区表和空闲分区链。</p><table><thead><tr><th align="center">分区号</th><th align="center">大小（MB）</th><th align="center">起始地址（M）</th><th align="center">状态</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">20</td><td align="center">8</td><td align="center">空闲</td></tr><tr><td align="center">2</td><td align="center">10</td><td align="center">32</td><td align="center">空闲</td></tr><tr><td align="center">3</td><td align="center">4</td><td align="center">64</td><td align="center">空闲</td></tr></tbody></table><p> 空闲分区表：每个空闲分区对应一个表项。表项中包含分区好、分区大小、分区起始地址等信息。</p><p> <img src="/../img/operationSystem/%E7%A9%BA%E9%97%B2%E5%88%86%E5%8C%BA%E9%93%BE.png" alt="空闲分区链"></p><p> 空闲分区链：每个分区的起始部分和末尾部分分别设置向前指针和向后指针。起始部分处还可记录分区大小等信息。</p></li><li><p>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p><p> 把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。</p></li><li><p>如何进行分区的分配与回收操作？</p><ul><li><p>回收区的后面又一个相邻的空闲分区</p><p>  两个相邻的空闲分区合并为一个</p></li><li><p>回收区的前面有一个相邻的空闲分区</p><p>  两个相邻的空闲分区合并为一个</p></li><li><p>回收区前后各有一个相邻的空闲分区</p><p>  三个相邻的空闲分区合并为一个</p></li><li><p>回收区的前后都没有相邻的空闲分区</p><p>  新增一个表项</p><p>  各表项的顺序不一定按照地址递增顺序排序，具体的排序方式需要依据动态分区分配算法来确定。</p></li></ul><p> 动态分区分配没有内部碎片，但是有外部碎片。</p><p> 内部碎片：分配给某进程的内存区域中，如果有些部分没有用上。</p><p> 外部碎片：是指内存中的某些空闲分区由于太小而难以利用。</p><p> 如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片“不能满足进程的需求。</p><p> 可通过紧凑（拼凑，Compaction）技术来解决外部碎片。</p></li></ol><h3 id="3-1-5-动态分区分配算法"><a href="#3-1-5-动态分区分配算法" class="headerlink" title="3.1.5 动态分区分配算法"></a>3.1.5 动态分区分配算法</h3><h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</p><p>实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲去，即，优先使用更小的空闲去。</p><p>实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。</p><h4 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h4><p>又称最大适应算法（Largest Fit）</p><p>算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p><p>实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后“大进程”到达，就没有内存分区可用了。</p><h4 id="临近适应算法"><a href="#临近适应算法" class="headerlink" title="临近适应算法"></a>临近适应算法</h4><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p><p>实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）。</p><p>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）</p><h3 id="3-1-6-基本分页存储管理的基本概念"><a href="#3-1-6-基本分页存储管理的基本概念" class="headerlink" title="3.1.6 基本分页存储管理的基本概念"></a>3.1.6 基本分页存储管理的基本概念</h3><p><strong>把“固定分区分配”改造为“非连续分配版本”</strong></p><p>假设进程A大小为23MB，但是每个分区大小只有10MB，如果进程只能占用一个分区，那显然放不下。</p><p>解决思路：如果允许进程占用多个分区，那么可以把进程拆分成10MB+10MB+3MB三个部分，再把这三个部分分别放到三个分区中（这些分区不要求连续）……</p><p>进程A的最后一个部分是3MB，放入分区后会残生7MB的内部碎片。</p><p>如果每个分区大小为2MB，那么进程A可以拆分成11*2MB + 1MB共12个部分，只有最后一部分1MB占不满分区，会产生1MB的内部碎片。</p><p>显然，如果把分区大小设置得更小一些，内存碎片会更小，内存利用率会更高。</p><blockquote><p>基本分页存储的思想：把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分。</p></blockquote><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>将内存空间分为一个个大小相等的分区（比如：每个分区4KB），每个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“页框号”（或者“内存块号”、“页帧号”、“物理块号”）页框号从0开始。</p><p>将用户进程的地址空间也分为与页框大小相等的一个个区域，称为”页“或”页面“。每个页面也有一个编号，即”页号“，页号也是从0开始。</p><p>ps：进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片）</p><p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。</p><p>各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。</p><h4 id="如何实现地址的转换"><a href="#如何实现地址的转换" class="headerlink" title="如何实现地址的转换"></a>如何实现地址的转换</h4><p>将进程地址空间分页后，操作系统该如何实现逻辑地址到物理地址的转换？</p><p><img src="/../img/operationSystem/%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="地址转换"></p><p>CPU执行指令1，需要访问逻辑地址为80的内存单元，如何转化为物理地址？</p><p>逻辑地址为80的内存单元：</p><p>应该在1号页，该页在内存中的起始位置为450，逻辑地址为80的内存单元相对于该页的起始地址而言，“偏移量”应该是30。实际物理地址 &#x3D; 450 + 30 &#x3D; 480</p><ol><li>要算出逻辑地址对应的页号</li><li>要知道该页号对应页面在内存中的起始地址</li><li>要算出逻辑地址在页面内的“偏移量”</li><li>物理地址 &#x3D; 页面地址 + 页内偏移量</li></ol><p>如何计算：</p><p>页号 &#x3D; 逻辑地址 &#x2F; 页面长度 （取除法的整数部分）</p><p>页内偏移量 &#x3D; 逻辑地址 % 页面长度 （取除法的余数部分）</p><p>页面在内存中的起始位置：操作系统需要某种数据结构记录进程各个页面的起始位置。</p><p>页号 &#x3D; 80 &#x2F; 50 &#x3D; 1</p><p>页内偏移量 &#x3D; 80 % 50 &#x3D; 30</p><p>1号页在内存中存放的起始位置450</p><p>为了方便计算页号、页内偏移量，页面大小一般设为2的整数幂</p><h4 id="如何知道该页号对应页面在内存中的起始地址"><a href="#如何知道该页号对应页面在内存中的起始地址" class="headerlink" title="如何知道该页号对应页面在内存中的起始地址"></a>如何知道该页号对应页面在内存中的起始地址</h4><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。</p><ol><li>一个进程对应一张页表</li><li>进程的每一页对应一个页表项</li><li>每个页表项由“页号”和“块号”组成</li><li>页表记录进程页面和实际存放的内存块之间的对应关系</li><li>每个页表项的长度是相同的，页号是“隐含“的</li></ol><h3 id="3-1-7基本地址变换机构"><a href="#3-1-7基本地址变换机构" class="headerlink" title="3.1.7基本地址变换机构"></a>3.1.7基本地址变换机构</h3><h4 id="页表寄存器的作用"><a href="#页表寄存器的作用" class="headerlink" title="页表寄存器的作用"></a>页表寄存器的作用</h4><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</p><p>通常会在系统中设置一个<strong>页表寄存器</strong>（PTR），存放<strong>页表在内存中的起始地址F</strong>和<strong>页表长度M</strong>。进程未执行时，页表的始值和页表长度<strong>放在进程控制块（PCB）</strong>中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><p>ps：页面大小事2的整数幂。</p><h4 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h4><p><img src="/../img/operationSystem/%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B.png" alt="基本地址变换过程"></p><p>设页面大小为L，逻辑地址A到物理地址E的变换过程如下：</p><ol><li>计算页号P和页内偏移量W（如果用十进制数手算，则P&#x3D;A&#x2F;L，W&#x3D;A%L；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）</li><li>比较页号P和页表长度M，若P≥M，则产生越界中断，否则继续执行。（注意：页号是从0开始的，而页表长度至少为1，因此P&#x3D;M时也会越界）</li><li>页表中页号P对应的页表项地址 &#x3D; 页表起始地址F + 页号P * 页表项长度，取出该页表项内容b，即为内存块号。（注意区分页表项长度、页表长度、页面大小的区别。页表长度是指这个页表中总共有几个页表项，即总共有几个页；页表项长度指的是每个页表项占多大的存储空间；页面大小指的是一个页面占多大的存储空间）</li><li>计算E &#x3D; b * L + W，用得到的物理地址E去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）</li></ol><p>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显示地告诉系统这个逻辑地址中，页内偏移量占多少位。</p><h3 id="3-1-8-具有快表的地址变换机构"><a href="#3-1-8-具有快表的地址变换机构" class="headerlink" title="3.1.8 具有快表的地址变换机构"></a>3.1.8 具有快表的地址变换机构</h3><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）</p><p><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）</p><p>在基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。可以利用这个特性减少访问页表的次数。</p><h4 id="什么是快表（TLB）"><a href="#什么是快表（TLB）" class="headerlink" title="什么是快表（TLB）"></a>什么是快表（TLB）</h4><p>快表，又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p><p><img src="/../img/operationSystem/%E5%BF%AB%E8%A1%A8.png" alt="快表"></p><h4 id="引入快表后，地址的变换过程"><a href="#引入快表后，地址的变换过程" class="headerlink" title="引入快表后，地址的变换过程"></a>引入快表后，地址的变换过程</h4><ol><li>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</li><li>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存。（注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</li></ol><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。由于局部性原理，一般来说快表的命中率可以达到90%以上。</p><h3 id="3-1-9-两级页表"><a href="#3-1-9-两级页表" class="headerlink" title="3.1.9 两级页表"></a>3.1.9 两级页表</h3><h4 id="单级页表存在什么问题？"><a href="#单级页表存在什么问题？" class="headerlink" title="单级页表存在什么问题？"></a>单级页表存在什么问题？</h4><ul><li><p>页表必须连续存放，因此当页表很大时，需要占用多个连续的页框</p><p>  可将长长的页表进行分组，使某个内存块刚好可以放入一个分组（比如：页面大小4KB，每个页表项4B，每个页面可存放1K个页表项，因此每1K个连续的页表项为一组，每组刚好占一个内存块，再将各族离散地放到各个内存块中）</p><p>  另外，要为离散分配的页表再建立一张页表，成为页目录表，或称外层页表，或称顶层页表</p></li><li><p>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面</p></li></ul><h4 id="两级页表的原理、逻辑地址结构"><a href="#两级页表的原理、逻辑地址结构" class="headerlink" title="两级页表的原理、逻辑地址结构"></a>两级页表的原理、逻辑地址结构</h4><table><thead><tr><th align="center">31             ……            22</th><th align="center">21         ……       12</th><th align="center">11       ……       0</th></tr></thead><tbody><tr><td align="center">一级页号</td><td align="center">二级页号</td><td align="center">页内偏移量</td></tr></tbody></table><p>10位一级页号刚好可表示0～1023</p><h4 id="如何实现地址变换？"><a href="#如何实现地址变换？" class="headerlink" title="如何实现地址变换？"></a>如何实现地址变换？</h4><p>例：将逻辑地址（0000000000, 0000000001, 111111111111）转换为物理地址（用十进制表示）。</p><ol><li>按照地址结构将逻辑地址拆分成三部分</li><li>从PCB中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置</li><li>根据二级页号查表，找到最终想访问的内存块号</li><li>结合页内偏移量得到物理地址</li></ol><h4 id="两级页表问题需要注意的几个细节"><a href="#两级页表问题需要注意的几个细节" class="headerlink" title="两级页表问题需要注意的几个细节"></a>两级页表问题需要注意的几个细节</h4><ol><li><p>若采用多级页表机制，则各级页表的大小不能超过一个页面</p></li><li><p>两级页表的访存次数分析（假设没有快表机构）</p><p> 第一次访存：访问内存中的页目录表</p><p> 第二次访存：访问内存中的二级页表</p><p> 第三次访存：访问目标内存单元</p></li></ol><h3 id="3-1-10-基本分段式存储管理方式"><a href="#3-1-10-基本分段式存储管理方式" class="headerlink" title="3.1.10 基本分段式存储管理方式"></a>3.1.10 基本分段式存储管理方式</h3><h4 id="什么是分段"><a href="#什么是分段" class="headerlink" title="什么是分段"></a>什么是分段</h4><p>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址</p><p>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。</p><p><img src="/../img/operationSystem/%E5%88%86%E6%AE%B5.png" alt="分段"></p><p>分段系统的逻辑地址就够由段号（段名）和段内地址（段内偏移量）所组成。如：</p><p><img src="/../img/operationSystem/%E5%88%86%E6%AE%B5%E7%B3%BB%E7%BB%9F%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%84%E6%88%90.png" alt="分段系统逻辑地址组成"></p><p>段号的位数决定了每个进程最多可以分几个段</p><p>段内地址位数决定了每个段的最大长度是多少</p><p>在上述例子中，若系统是按字节寻址的，则</p><p>段号占16位，因此在该系统中，每个进程最多有2<sup>16</sup> &#x3D; 64K个段</p><p>段内地址占16位，因此每个段的最大长度是2<sup>16</sup> &#x3D; 64KB。</p><h4 id="什么是段表"><a href="#什么是段表" class="headerlink" title="什么是段表"></a>什么是段表</h4><p>程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”。</p><p><img src="/../img/operationSystem/%E6%AE%B5%E8%A1%A8.png" alt="段表"></p><ol><li>每个段对应一个段表项，其中记录了该段在内存中的起始位置（又称“基址”）和段的长度。</li><li>各个段表项的长度是相同的。例如：某系统按字节寻址，采用分段存储管理，逻辑地址结构为（段号16位，段内地址16位），因此用16位即可表示最大段长。物理内存大小为4GB（可用32位表示整个物理内存地址空间）。因此，可以让每个段表项占16+32&#x3D;48位，即6B。由于段表项长度相同，因此段号可以是隐含的，不占存储空间。若段表存放的起始地址位M，则K号段对应的段表项存放的地址为M+K*6</li></ol><h4 id="如何实现地址变换"><a href="#如何实现地址变换" class="headerlink" title="如何实现地址变换"></a>如何实现地址变换</h4><p><img src="/../img/operationSystem/%E6%AE%B5%E8%A1%A8%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="段表存储管理方式地址变换"></p><h4 id="分段、分页管理的对比"><a href="#分段、分页管理的对比" class="headerlink" title="分段、分页管理的对比"></a>分段、分页管理的对比</h4><p>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</p><p>段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显示地给出段名。</p><p>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</p><p>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。</p><p>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</p><p>分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）</p><p>访问一个逻辑地址需要几次访存？</p><p>分页（单级页表）：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共两次访存</p><p>分段：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共两次访存于分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表放到快表中，这样可以少访问，加快地址变化速度。</p><h3 id="3-1-11-段页式管理方式"><a href="#3-1-11-段页式管理方式" class="headerlink" title="3.1.11 段页式管理方式"></a>3.1.11 段页式管理方式</h3><h4 id="分页、分段管理方式中最大的优缺点"><a href="#分页、分段管理方式中最大的优缺点" class="headerlink" title="分页、分段管理方式中最大的优缺点"></a>分页、分段管理方式中最大的优缺点</h4><table><thead><tr><th align="center"></th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">分页管理</td><td align="center">内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</td><td align="center">不方便按照逻辑模块实现信息的共享和保护</td></tr><tr><td align="center">分段管理</td><td align="center">很方便按照逻辑模块实现信息的共享和保护</td><td align="center">如果段长过大，为其分配很大的连续空间会很不方便，另外段式管理会产生外部碎片</td></tr></tbody></table><h4 id="分段-分页的结合——段页式管理方式"><a href="#分段-分页的结合——段页式管理方式" class="headerlink" title="分段+分页的结合——段页式管理方式"></a>分段+分页的结合——段页式管理方式</h4><p><img src="/../img/operationSystem/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86.png" alt="段页式管理"></p><p>将进程按逻辑模块分段，再将各段分页（如每个页面4KB）再将内存空间分为大小相同的内存块&#x2F;页框&#x2F;页帧&#x2F;物理块进程前将各页面分别装入内存块中。</p><p>分段系统的逻辑地址结构由段号和段内地址（段内偏移量）组成，如：</p><p><img src="/../img/operationSystem/%E5%88%86%E5%BA%A6%E7%B3%BB%E7%BB%9F%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png" alt="分度系统逻辑地址结构"></p><p>段页式系统的逻辑地址结构由段号、页号、页内地址（页内偏移量）组成，如：</p><p><img src="/../img/operationSystem/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png" alt="段页式系统地址结构"></p><blockquote><p>“分段”是对用户可见的，程序员编程时需要显示地给出段号、段内地址。而将各段“分页”对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此<strong>段页式管理地址结构是二维的</strong>。</p></blockquote><p>段号的位数决定了每个进程最多可以分为几个段</p><p>页号位数决定了每个段最大有多少页</p><p>页内偏移量决定了页面大小、内存块大小是多少</p><p>在上述例子中，若系统是按字节寻址的，则</p><p>段号占16位，因此在该系统中，每个进程最多有2<sup>16</sup> &#x3D; 64K个段</p><p>页号占4位，因此每个段最多有2<sup>4</sup> &#x3D; 16页</p><p>页内偏移量占12位，因此每个页面\每个内存块大小为2<sup>12</sup> &#x3D; 4096 &#x3D;4KB</p><h4 id="段表、页表"><a href="#段表、页表" class="headerlink" title="段表、页表"></a>段表、页表</h4><p><img src="/../img/operationSystem/%E6%AE%B5%E8%A1%A8%E6%AE%B5%E9%A1%B5.png" alt="段表段页"></p><p>每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成。每个段表项长度相等，段号是隐含的。</p><p>每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。</p><h4 id="如何实现地址变换-1"><a href="#如何实现地址变换-1" class="headerlink" title="如何实现地址变换"></a>如何实现地址变换</h4><p><img src="/../img/operationSystem/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="段页式管理地址变换"></p><h3 id="3-2-1-虚拟内存的基本概念"><a href="#3-2-1-虚拟内存的基本概念" class="headerlink" title="3.2.1 虚拟内存的基本概念"></a>3.2.1 虚拟内存的基本概念</h3><h4 id="传统存储管理方式的特征、缺点"><a href="#传统存储管理方式的特征、缺点" class="headerlink" title="传统存储管理方式的特征、缺点"></a>传统存储管理方式的特征、缺点</h4><p>传统存储管理（很多暂时用不到的数据也会长期占用内存，导致内存利用率不高）</p><ul><li>连续分配<ul><li>单一连续分配</li><li>固定分区分配</li><li>动态分区分配</li></ul></li><li>非连续分配<ul><li>基本分页存储管理</li><li>基本分段存储管理</li><li>基本段页式存储管理</li></ul></li></ul><p>一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：1. 作业很大时，不能全部装入内存，导致大作业无法运行；2. 当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。</p><p>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</p><h4 id="局部性原理-1"><a href="#局部性原理-1" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）</p><p>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</p><p><img src="/../img/operationSystem/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="计算机中存储器的层次结构"></p><p>快表机构就是将近期常访问的页表项副本放到更高速的联想寄存器中</p><p>高速缓冲技术的思想：将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中。</p><h4 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h4><p><img src="/../img/operationSystem/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="计算机中存储器的层次结构"></p><p>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。</p><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。</p><p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p><p>在操作系统的管理下，在用户看来似乎有一个比实际内存大的多的内存，这就是虚拟内存。</p><blockquote><p>操作系统虚拟性的一个体现，实际的物理内存大小没有变，知识在逻辑上进行了扩充。</p></blockquote><p>虚拟内存有以下三个主要特征：</p><p>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</p><p>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入换出。</p><p>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</p><h4 id="如何实现虚拟内存技术"><a href="#如何实现虚拟内存技术" class="headerlink" title="如何实现虚拟内存技术"></a>如何实现虚拟内存技术</h4><p>虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在离散分配的内存管理方式基础上。</p><p>虚拟内存的实现：</p><ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ul><p>传统的非连续分配存储管理和虚拟内存技术的主要区别：</p><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。（操作系统要提供请求调页或请求调段功能）</p><p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。（操作系统要提供页面置换或段置换的功能）</p><h3 id="3-2-2-请求分页管理方式"><a href="#3-2-2-请求分页管理方式" class="headerlink" title="3.2.2 请求分页管理方式"></a>3.2.2 请求分页管理方式</h3><h4 id="请求分页存储管理与基本分页存储管理的主要区别："><a href="#请求分页存储管理与基本分页存储管理的主要区别：" class="headerlink" title="请求分页存储管理与基本分页存储管理的主要区别："></a>请求分页存储管理与基本分页存储管理的主要区别：</h4><h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h4><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需要知道该页面在外存中存放的位置。</p><p>当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面：有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。</p><p><img src="/../img/operationSystem/%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6.png" alt="页表机制"></p><h4 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h4><p>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。</p><p>此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。</p><p>如何内存有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。</p><p>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</p><p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。</p><p>一条指令在执行期间，可能产生多次缺页中断。</p><h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p>请求分页存储管理与基本分页存储管理的主要区别：</p><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。</p><p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p><p><img src="/../img/operationSystem/%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png" alt="地址变换机构"></p><h3 id="3-2-3-页面置换算法"><a href="#3-2-3-页面置换算法" class="headerlink" title="3.2.3 页面置换算法"></a>3.2.3 页面置换算法</h3><h4 id="最佳置换算法OPT"><a href="#最佳置换算法OPT" class="headerlink" title="最佳置换算法OPT"></a>最佳置换算法OPT</h4><p>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。</p><p>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。</p><h4 id="先进先出置换算法FIFO"><a href="#先进先出置换算法FIFO" class="headerlink" title="先进先出置换算法FIFO"></a>先进先出置换算法FIFO</h4><p>每次选择淘汰的页面是最早进入内存的页面</p><p>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择对头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。</p><p>Belady异常——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p><p>只有IFO算法会产生Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差</p><h4 id="最近最久未使用置换算法LRU"><a href="#最近最久未使用置换算法LRU" class="headerlink" title="最近最久未使用置换算法LRU"></a>最近最久未使用置换算法LRU</h4><p>每次淘汰的页面是最近最久未使用的页面</p><p>实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p><p><img src="/../img/operationSystem/LRU.png" alt="LRU"></p><h4 id="时钟置换算法CLOCK"><a href="#时钟置换算法CLOCK" class="headerlink" title="时钟置换算法CLOCK"></a>时钟置换算法CLOCK</h4><p>最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法。</p><p>简单的CLOCK算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过连接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位置依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）</p><p><img src="/../img/operationSystem/CLOCK.png" alt="CLOCK"></p><h4 id="改进型的时钟置换算法"><a href="#改进型的时钟置换算法" class="headerlink" title="改进型的时钟置换算法"></a>改进型的时钟置换算法</h4><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I&#x2F;O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</p><p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I&#x2F;O操作。这就是改进型的时钟置换算法的思想。</p><p>修改位&#x3D;0，表示页面没有被修改过；修改位&#x3D;1，表示页面被修改过。</p><p>为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1，1）表示一个页面近期被访问过，且被修改过。</p><p>算法规则：将所有可能被置换的页面排成一个循环队列</p><p>第一轮：从当前位置开始扫描到第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位。</p><p>第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的帧访问位设为0.</p><p>第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位。</p><p>第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。</p><p>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描。</p><p><strong>四种页面置换算法比较</strong></p><p><img src="/../img/operationSystem/%E5%9B%9B%E7%A7%8D%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.png" alt="四种页面置换算法比较"></p><h3 id="3-2-4-页面分配策略"><a href="#3-2-4-页面分配策略" class="headerlink" title="3.2.4 页面分配策略"></a>3.2.4 页面分配策略</h3><h4 id="页面分配、置换策略"><a href="#页面分配、置换策略" class="headerlink" title="页面分配、置换策略"></a>页面分配、置换策略</h4><p><strong>驻留集：</strong>指请求分页存储管理中给进程分配的物理块的集合。</p><p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。</p><p>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于即成推进的时间很少；驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。</p><p><strong>固定分配：</strong>操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变。</p><p><strong>可变分配：</strong>先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变。</p><p><strong>局部置换：</strong>发生缺页时只能选进程自己的物理块进行置换。</p><p><strong>全局置换：</strong>可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</p><p><strong>固定分配局部置换：</strong>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。（采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）</p><p><strong>可变分配全剧置换：</strong>刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。</p><p><strong>可变分配局部置换：</strong>刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</p><p>可变分配全剧置换：只要缺页就给分配新物理块</p><p>可变分配局部置换：要根据发生缺页的频率来动态地增加或减少进程的物理块</p><h4 id="调入页面的时机"><a href="#调入页面的时机" class="headerlink" title="调入页面的时机"></a>调入页面的时机</h4><ol><li>预调页策略：根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要用于进程的首次调入，由程序员指出应该先调入哪些部分。</li><li>请求调页策略：进程在运行期间发现缺页时才将所缺页调入内存。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I&#x2F;O操作，因此I&#x2F;O开销比较大。</li></ol><h4 id="从何处调页"><a href="#从何处调页" class="headerlink" title="从何处调页"></a>从何处调页</h4><ol><li>系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。</li><li>系统缺少足够的对换区空间：凡事不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需要写回磁盘对换区，下次需要时再从对换区调入。</li><li>UNIX方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</li></ol><h4 id="抖动（颠簸）现象"><a href="#抖动（颠簸）现象" class="headerlink" title="抖动（颠簸）现象"></a>抖动（颠簸）现象</h4><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）。</p><blockquote><p>为进程分配的物理块太少，会使即成发生动都现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率</p></blockquote><h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><p>驻留集：指请求分页存储管理中给进程分配的内存块的集合</p><p>工作集：指在某段时间间隔里，进程实际访问页面的集合</p><p>操作系统会根据“窗口尺寸”来算出工作集。</p><p>工作集太小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若个内存块。如：窗口尺寸为5，经过一段时间的检测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。一般来说，<strong>驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页。</strong></p><blockquote><p>基于局部性原理克制，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。因此，可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法——选择一个不在工作集中的页面进行淘汰。</p></blockquote><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="4-1-1-初识文件管理"><a href="#4-1-1-初识文件管理" class="headerlink" title="4.1.1 初识文件管理"></a>4.1.1 初识文件管理</h3><p><strong>文件的定义</strong>：一组有意义的信息的集合</p><h4 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h4><ul><li><p>文件名</p><p>  由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件。</p></li><li><p>标识符</p><p>  一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</p></li><li><p>类型</p><p>  指明文件的类型</p></li><li><p>位置</p><p>  文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</p></li><li><p>大小</p><p>  指明文件大小</p></li><li><p>创建时间、上次修改时间</p></li><li><p>文件所有者信息</p></li><li><p>保护信息</p><p>  对文件进行保护的访问控制信息</p></li></ul><h4 id="文件内部的数据应该怎样组织起来？"><a href="#文件内部的数据应该怎样组织起来？" class="headerlink" title="文件内部的数据应该怎样组织起来？"></a>文件内部的数据应该怎样组织起来？</h4><p>无结构文件：如文本文件。由一些二进制或字符流组成，又称“流式文件”</p><p>有结构文件：如数据库表。由一组相似的记录组成，又称“记录式文件”。记录是一组相关数据项的集合。</p><blockquote><p>数据项式文件系统中最基本的数据单位</p></blockquote><h4 id="文件内部的数据应该怎样组织起来？-1"><a href="#文件内部的数据应该怎样组织起来？-1" class="headerlink" title="文件内部的数据应该怎样组织起来？"></a>文件内部的数据应该怎样组织起来？</h4><p>文件的逻辑结构</p><p><img src="/../img/operationSystem/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="文件结构"></p><h4 id="文件之间应该怎样组织起来？"><a href="#文件之间应该怎样组织起来？" class="headerlink" title="文件之间应该怎样组织起来？"></a>文件之间应该怎样组织起来？</h4><p>目录结构</p><p><img src="/../img/operationSystem/%E6%96%87%E4%BB%B6%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.png" alt="文件逻辑结构"></p><p>用户可以自己创建一层一层的目录，各层目录中存放相应的文件。系统中的各个文件就通过一层一层的目录合理有序的组织起来。</p><p>目录其实也是一种特殊的有结构文件（由记录组成）。所谓的“目录”其实就是我们熟悉的“文件夹”。</p><h4 id="操作系统应该向上提供哪些功能？"><a href="#操作系统应该向上提供哪些功能？" class="headerlink" title="操作系统应该向上提供哪些功能？"></a>操作系统应该向上提供哪些功能？</h4><p>可以“<strong>创建文件</strong>”，新建后，图形化交互进程在背后调用了“<strong>create系统调用”</strong>。</p><p>可以“<strong>读文件</strong>”，将文件数据读入内存，才能让CPU处理（“记事本”应用程序通过操作系统提供的“读文件”功能，即<strong>read系统调用</strong>，将文件数据从外存读入内存，并显示在屏幕上）</p><p>可以“写文件”，将更改过的文件数据写回外存（“记事本”应用程序中编辑文件内容，点击“保存”后，“记事本”应用程序通过操作系统提供的“<strong>写文件</strong>”功能，即<strong>write系统调用</strong>，将文件数据从内存写回外存）</p><p>可以“<strong>删除文件</strong>”（点了“删除”之后，图形化交互进程通过操作系统提供的“<strong>删除文件</strong>”功能，即<strong>delete系统调用</strong>，将文件数据从外存中删除）</p><p>向上提供的几个最基本的功能：</p><ul><li>创建文件，create系统调用</li><li>删除文件，delete系统调用</li><li>读文件，read系统调用</li><li>写文件，write系统调用</li><li>打开文件，open系统调用。读&#x2F;写文件之前，需要“打开文件”。</li><li>关闭文件，close系统调用。读&#x2F;写文件结束之后，需要“关闭文件”。</li></ul><blockquote><p>可用几个基本操作完成更复杂的操作，比如：“文件复制”：先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中。</p></blockquote><h4 id="文件应该如何存放在外存？"><a href="#文件应该如何存放在外存？" class="headerlink" title="文件应该如何存放在外存？"></a>文件应该如何存放在外存？</h4><p>与内存一样，外存也是由一个个存储单元组成的，每个存储单元可以存储一定量的数据。每个存储单元对应一个物理地址。</p><p>类似于内存分为一个个“内存块”，外存会分为一个个“块&#x2F;磁盘块&#x2F;物理块”。每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址。同样类似的事，文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转换为外存的物理地址（物理块号，块内地址）的形式。块内地址的位数取决于磁盘块的大小。</p><p>操作系统以“块”为单位为文件分配存储空间，因此即使一个文件大小只有10B，但它依然需要占用1KB的磁盘块。外存中的数据读入内存时同样以块为单位。</p><h3 id="4-1-2-文件的逻辑结构"><a href="#4-1-2-文件的逻辑结构" class="headerlink" title="4.1.2 文件的逻辑结构"></a>4.1.2 文件的逻辑结构</h3><blockquote><p>所谓的“逻辑结构”，就是指在用户看来，文件内部的数据应该是如何组织起来的。而“物理结构”指的是在操作系统看来，文件的数据是如何放在外存中的。</p></blockquote><p>按文件是否有结构分类，可以分为无结构文件、有结构文件两种。</p><h4 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h4><p><strong>无结构文件</strong>：文件内部的数据就是一系列二进制流或字符流组成。又称“<strong>流式文件</strong>”。</p><p>如windows操作系统中的.txt文件。文件内部的数据其实就是一系列字符流，没有明显的结构特性。因此也不用探讨无结构文件的“逻辑结构”问题。</p><h4 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h4><p><strong>有结构文件</strong>：由一组相似的记录组成，又称“<strong>记录式文件</strong>”。每条记录由若干个数据项组成。如：数据库表文件。一般来说，每条记录有一个数据项可作为<strong>关键字</strong>。根据各条记录的长度（占用的存储空间）是否相等，又可分为<strong>定长记录</strong>和<strong>可变长记录</strong>两种。</p><p>根据有结构文件中的各条记录在逻辑上如何组织，可以分为三类：</p><ul><li><p>顺序文件</p><p>  文件中的记录一个接一个顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。</p><p>  顺序存储：逻辑上相邻的记录物理上也相邻（类似于顺序表）。可变长记录无法实现随机存取。每次只能从第一个记录开始依次往后查找。定长记录可实现随机存取。记录长度为L，则第i个记录存放的相对位置是i*L；若采用串结构，无法快速找到某关键字对应的记录；若采用顺序结构，可以快速找到关键字对应的记录（如折半查找）</p><p>  链式存储：逻辑上相邻的记录物理上不一定相邻（类似于链表）。无论是定长&#x2F;可变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找</p></li><li><p>索引文件</p><p>  缺点：每个记录对应一个索引表项，因此索引表可能会很大。比如：文件的每个记录平均只占8B，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了。</p></li><li><p>索引顺序文件</p><p>  索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是<strong>一组记录对应一个索引表项</strong>。</p><p>  索引顺序文件的索引项也不需要按关键字顺序排列，这样可以极大地方便新表项的插入。</p><p>  为了进一步提高检索效率，可以为顺序文件建立多极索引表。</p></li></ul><h3 id="4-1-3-文件目录"><a href="#4-1-3-文件目录" class="headerlink" title="4.1.3 文件目录"></a>4.1.3 文件目录</h3><h4 id="文件目录的实现"><a href="#文件目录的实现" class="headerlink" title="文件目录的实现"></a>文件目录的实现</h4><p><strong>文件控制块</strong></p><p>目录文件中的一条记录就是一个“文件控制块（FCB）“</p><p>FCB的有序集合称为”文件目录“，一个FC B就是一个文件目录项。</p><p>FCB中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读&#x2F;可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）</p><p>最重要，最基本还是文件名、文件存放的物理地址。（FCB实现了文件名和文件之间的映射。使用户（用户程序）可以实现“按名存取”）</p><p>需要对目录进行哪些操作？</p><p>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</p><p>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项</p><p>删除文件：当删除一个文件时，需要在目录中删除相应的目录项</p><p>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</p><p>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文件重命名）</p><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p><strong>单级目录结构</strong></p><p>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项。</p><p>单级目录实现了“按名存取“，但是不允许文件重名。在创建文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中。</p><p>显然，单级目录结构不适用于多用户操作系统</p><p><strong>两级目录结构</strong></p><p>早起的多用户操作系统，采用两级目录结构。分为主文件目录（MFD，Master File Directory）和用户文件目录（UFD，User File Directory）。</p><p>主文件目录记录用户名及相应用户文件目录的存放位置。</p><p>用户文件目录由该用户的文件FCB组成。</p><p>两级目录结构允许不同用户的文件重名，也可以在目录上实现访问限制（检查此时登录的用户名是否匹配）。但是两级目录结构依然缺乏灵活性，用户不能对自己的文件进行分类。</p><p><strong>多级目录结构</strong></p><p>又称树形目录结构。</p><p>用户或用户进程要访问某个文件时，要用文件路径名标识文件，文件路径名是个字符串。各级目录之间用“&#x2F;”隔开。从根目录出发的路径称为绝对路径。</p><p>例如：自拍.png的绝对路径是“&#x2F;照片&#x2F;2022-07&#x2F;自拍.png“</p><p>系统根据绝对路径一层一层地找到下一级目录。刚开始从外存读入根目录的目录表；找到”照片”目录的存放位置后，从外存读入对应的目录表；再找到“2022-07”目录的存放位置，再从外存读入对应目录表；最后才找到文件“自拍.png“的存放位置。整个过程需要3次读磁盘I&#x2F;O操作。</p><p>很多时候，用户会连续访问同一目录内的多个问津啊（比如：接连查看”2022-07“目录内的多个照片文件），显然，每次都从根目录开始查找，是很低效的。因此可以设置一个”当前目录“。例如，此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为“当前目录”。当用户想要访问某个文件时，可以使用从当前目录出发的“相对路径”。</p><p>在linux中，“**.**”表示当前目录，因此如果“照片”是当前目录，则“自拍.png”的相对路径为：“.&#x2F;2022-07&#x2F;自拍.png“。从当前路径出发，只需要查询内存中的”照片“目录表，即可知道”2022-07“目录表的存放位置，从外存调入该目录，即可知道”自拍.png“存放的位置了。</p><p>可见，引入”当前目录“和”相对路径“后，磁盘I&#x2F;O的次数减少了。这就提升了访问文件的效率。</p><p>树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构”。</p><p><strong>无环图目录结构</strong></p><p>在树形目录结构的基础上，增加一些指向同一节点的有向边，使整个目录称为一个有向无环图。可以更方便地实现多个用户间的文件共享。</p><p><strong>可以用不同的文件名只想同一个文件</strong>，甚至可以指向同一个目录（共享同一目录下的所有内容）。</p><p>需要为<strong>每个共享结点设置一个共享计数器</strong>，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的PCB、并使<strong>共享计数器减1</strong>，并不会直接删除共享结点。<strong>只有共享计数器减为0时，才删除结点。</strong></p><p>注意：共享文件不同于复制文件。在<strong>共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。</strong></p><h4 id="索引结点"><a href="#索引结点" class="headerlink" title="索引结点"></a>索引结点</h4><p>其实在查找各级目录的过程中，只需要用到“文件名”这个信息，只有文件名匹配时，才需要读出文件的其他信息。因此可以考虑让目录表“瘦身”来提升效率。</p><p>这样做有什么好处？</p><p>假设一个FCB是64B，磁盘块的大小为1KB，则每个磁盘块中只能存放16个FCB。若一个文件目录中共有640个目录项，则共需要占用640&#x2F;16&#x3D;40个盘块。因此按照某文件名检索该目录，平均需要查询320个目录项，平均需要启动磁盘（每次磁盘I&#x2F;O读入一块）。</p><p>若使用索引结点机制，文件名占14B，索引结点指针占2B，则每个盘块可存放64个目录项，那么按文件名检索目录平均只需要读入320&#x2F;64&#x3D;5个磁盘块。显然，这将大大提升文件检索速度。</p><p>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。</p><p>存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”。</p><p>相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件等。</p><h3 id="4-1-4-文件的物理结构"><a href="#4-1-4-文件的物理结构" class="headerlink" title="4.1.4 文件的物理结构"></a>4.1.4 文件的物理结构</h3><h4 id="文件块、磁盘块"><a href="#文件块、磁盘块" class="headerlink" title="文件块、磁盘块"></a>文件块、磁盘块</h4><p>类似于内存分页，磁盘中的存储单元也会被分为一个个“块&#x2F;磁盘块&#x2F;物理块”。很多操作系统中，<strong>磁盘块的大小与内存块、页面的大小相同。</strong></p><p>内存与磁盘之间的数据交换（即读&#x2F;写操作、磁盘I&#x2F;O）都是以“块”为单位进行的。即每次读入一块，或每次写出一块。</p><p>在内存管理中，进程的逻辑地址空间被分为一个一个页面</p><p>同样的，在外存管理中，为了方便对文件数据的姑那里，文件的逻辑地址空间也被分为了一个一个的文件“块”。</p><p>于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式。</p><p>操作系统为文件分配存储空间都是以块为单位的。</p><p>用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射。</p><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>连续分配方式要求每个文件在磁盘上占有一组连续的块。</p><blockquote><p>用户通过逻辑地址来操作自己的文件，操作系统如何实现从逻辑地址到物理地址的映射？</p></blockquote><p>（逻辑块号，块内地址）-&gt;（物理块号，块内地址）。只需转换块号就行，块内地址保持不变</p><p>用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项FCB……</p><p>物理块号 &#x3D; 起始块号 + 逻辑块号</p><p>当然，还需要检查用户提供的逻辑块号是否合法（逻辑块号 ≥ 长度 就不合法）。可以直接算出逻辑块号对应的物理块号，因此连续分配支持顺序访问和直接访问（即随机访问）。</p><p>读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。</p><p>结论：</p><p><strong>连续分配的文件在顺序读&#x2F;写时速度最快</strong></p><p>物理上采用<strong>连续分配的文件不方便拓展</strong></p><p>物理上采用<strong>连续分配，存储空间利用率低，会产生难以利用的磁盘碎片</strong>，可以用紧凑来处理碎片，但是需要耗费很大的时间代价。</p><p>优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快</p><p>缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片</p><h4 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h4><p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显示链接两种。</p><p><strong>隐式链接</strong></p><blockquote><p>如何实现文件的逻辑块号到物理块号的转变？</p></blockquote><p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项FCB……</p><p>从目录项中找到起始块号（即0号块），将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，再找到2号逻辑块的存放位置……以此类推。</p><p>因此，读入i号逻辑块，总共需要i+1次磁盘I&#x2F;O。</p><p>结论：采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查找效率低。另外，指向下一个盘块的指针页需要耗费少量的存储空间。采用隐式链接的链接分配方式，很方便文件拓展。另外，所有的的空闲磁盘块都可以被利用，不会有碎片问题，外存利用率高。</p><p>隐式链接——除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。</p><p>优点：很方便文件拓展，不会有碎片问题，外存利用率高。</p><p>缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</p><p><strong>显式链接</strong></p><p>把用于链接文件各物理块的指针显示地存放在一张表中。即文件分配表（FAT，File Allocation Table）。</p><p>假设某个新创建的文件“aaa“一次存放在磁盘块2 -&gt; 5 -&gt; 0 -&gt; 1，在目录中只需记录文件的起始块号。</p><p>注意：一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存。FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以时隐含的。</p><blockquote><p>如何实现文件的逻辑块号到物理块号的转变？</p></blockquote><p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项FCB……</p><p>从目录项中国呢找到起始块号，若i&gt;0，则查询内存中的文件分配表FAT，往后找到i号逻辑块对应的物理块号。<strong>逻辑块号转换成物理块号的过程不需要读磁盘操作。</strong></p><p>结论：采用<strong>链式分配（显式链接）</strong>方式的文件，支持顺序访问，也<strong>支持随机访问（想访问i号逻辑块时，并不需要依次访问之前的0～i-1号逻辑块）</strong>，由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。</p><p>显然，显式链接也<strong>不会产生外部碎片，也可以很方便地对文件进行拓展。</strong></p><p>显示链接——把用于链接文件各物理块的指针显示地存放在一张表中，即<strong>文件分配表</strong>（FAT，File Allocation Table）。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。</p><p>优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</p><p>缺点：文件分配表的需要占用一定的存储空间。</p><h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><p>索引分配允许文件离散地分配在各个磁盘块中，系统会<strong>为每个文件建立一张索引表</strong>，索引表中记录了文件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系）。索引表存放的磁盘块称为<strong>索引块</strong>。文件数据存放的磁盘块称为<strong>数据块</strong>。</p><p>假设某个新创建的文件“aaa”的数据一次存放在磁盘块2 -&gt; 5 -&gt; 13 -&gt; 9。7号磁盘块作为“aaa”的索引块，索引块中保存了索引表的内容。</p><p>注：在显式链接的链式分配方式中，文件分配表FAT是一个磁盘对应一张。而索引分配方式中，索引表是一个文件对应一张。</p><p>可以用固定的长度表示物理块号（如：假设磁盘总容量为1TB&#x3D;2<sup>40</sup>B，磁盘块大小为1KB，则共有2<sup>30</sup>个磁盘块，则可用4B表示磁盘块号），因此，索引表中的“逻辑块号”可以是隐含的。</p><p>目录中需要记录文件的索引块是极好磁盘块。</p><blockquote><p>如何实现文件的逻辑块号到物理块号的转换？</p></blockquote><p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项FCB……</p><p>从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可指i号逻辑块在外存中的存放位置。</p><p>可见，索引分配方式可以支持随机访问。文件拓展也很容易实现（只需要给文件分配一个空闲块，并增加了一个索引表项即可）但是索引表需要占用一定的存储空间</p><blockquote><p>如果一个文件的大小超过了256块，那么一个磁盘块是装不下文件的整张索引表的，如何解决这个问题？</p></blockquote><ol><li><p>链接方案</p><p> 如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</p></li><li><p>多层索引</p><p> 建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。</p></li><li><p>混合索引</p><p> 多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表）。</p><p> 优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少。</p></li></ol><h3 id="4-1-5-文件存储空间管理"><a href="#4-1-5-文件存储空间管理" class="headerlink" title="4.1.5 文件存储空间管理"></a>4.1.5 文件存储空间管理</h3><h4 id="存储空间的划分与初始化"><a href="#存储空间的划分与初始化" class="headerlink" title="存储空间的划分与初始化"></a>存储空间的划分与初始化</h4><p>存储空间的划分：将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘）。如：安装Windows操作系统的时候，一个必经步骤是——为磁盘分区（C:盘、D:盘、E:盘等）。有的系统支持超大型文件，可支持由多个物理磁盘组成一个文件卷。</p><p>存储空间的初始化：将各个文件卷划分为目录区、文件区。目录区主要存放文件目录信息FCB、用于磁盘存储空间管理的信息。文件区用于存放文件数据。</p><h4 id="几种管理方法"><a href="#几种管理方法" class="headerlink" title="几种管理方法"></a>几种管理方法</h4><p><strong>空闲表法</strong></p><p>如何分配磁盘块：与内存管理中的动态分区分配很类似，为一个文件<strong>分配连续的存储空间</strong>。同样<strong>可采用首次适应、最佳适应、最坏适应等算法</strong>来决定要为文件分配哪个区间。</p><p>如何回收磁盘块：与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况——1.回收区的前后都没有相邻空闲区；2.回收区的前后都是空闲区；3.回收区前面是空闲区；4.回收区后面是空闲区。<strong>总之，回收时需要注意表项的合并问题。</strong></p><p><strong>空闲链表法</strong></p><ul><li><p>空闲盘块链</p><p>  以盘块为单位组成一条空闲链。空闲盘块中存储这下一个空闲盘块的指针。操作系统中保存着链头、链尾指针。</p><p>  如何分配：若某文件申请K个盘块，则从链头开始一次摘下K个盘块分配，并修改空闲链的链头指针。</p><p>  如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</p></li><li><p>空闲盘区链</p><p>  以盘区为单位组成一条空闲链。空闲盘区中的第一个盘块内记录了盘区的长度、下一个盘区的指针。连续的空闲盘块组成一个空闲盘区。</p><p>  如何分配：若某文件申请k个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。</p><p>  如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有喝任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</p></li></ul><p><strong>位示图法</strong></p><p>位示图：每个二进制对应一个盘块。位示图一般用连续的“字”来表示，如一个字的字长是16位，字中的每一位对应一个盘块。因此可以用（字号，位号）对应一个盘块号。当然有的题目中也描述为（行号，列号）</p><p>（字号，位号）&#x3D;（i，j）的二进制位对应的盘块号b &#x3D; ni + j</p><p>b号盘块对应的字号i &#x3D; b &#x2F; n，位号j &#x3D; b % n</p><p>如何分配：若文件需要k个块，1.顺序扫描位示图，找到k个相邻或不相邻的“0”；2.根据字号、位号算出对应的盘块号，将相应盘块分配给文件；3.将相应位设置为“1”。</p><p>如何回收：1.根据回收的盘块号计算出对应的字号、位号；2.将相应二进制位设为“0”</p><p><strong>成组链接法</strong></p><p>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX系统中采用了成组链接法对磁盘空闲块进行管理。</p><p>文件卷的目录区中专门用一个磁盘块作为“超级块“，当系统启动时需要将超级块读入内存。并且要保证内存与外存中的”超级块“数据一致。</p><h3 id="4-1-6-文件的基本操作"><a href="#4-1-6-文件的基本操作" class="headerlink" title="4.1.6 文件的基本操作"></a>4.1.6 文件的基本操作</h3><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><p>进行Create系统调用时，需要提供的几个主要参数：</p><ol><li>所需的外存空间大小</li><li>文件存放路径</li><li>文件名</li></ol><p>操作系统在处理create系统调用时，主要做了两件事：</p><ol><li>在外存中找到文件所需的空间</li><li>根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息。</li></ol><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>进行Delete系统调用时，需要提供的几个主要参数：</p><ol><li>文件存放路径</li><li>文件名</li></ol><p>操作系统在处理Delete系统调用时，主要做了几件事：</p><ol><li>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项。</li><li>根据该目录项纪录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块。</li><li>从目录表中删除文件对应的目录项。</li></ol><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>进程使用read系统调用完成操作。需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明读入多少数据、指明读入的数据要放在内存中的什么位置。</p><p>操作系统在处理read系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</p><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>进程使用write系统调用完成操作，需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要写出多少数据、写回外存的数据放在内存中的什么位置。</p><p>操作系统在处理write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。</p><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>在很多操作系统中，在对文件进行操作之前，要求用户先使用open系统调用“打开文件“，需要提供的几个主要参数：</p><ol><li>文件存放路径</li><li>文件名</li><li>要对文件操作的类型，如：r只读，rw读写等。</li></ol><p>操作系统在处理open系统调用时，主要做了几件事：</p><ol><li>根据文件存放路径找到文件名对应的目录项，并检查该用户是否有指定的操作权限。</li><li>将目录项复制到内存中的”打开文件表“中。并将对应表的编号返回给用户。之后用户使用打开文件表的标号来指明要操作的文件。</li></ol><h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p>进程使用完文件后，要“关闭文件”</p><p>操作系统在处理Close系统调用时，主要做了几件事：</p><ol><li>将进程的打开文件表相应表项删除</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器count减1，若count&#x3D;0，则删除对应表项。</li></ol><h3 id="4-1-7-文件共享"><a href="#4-1-7-文件共享" class="headerlink" title="4.1.7 文件共享"></a>4.1.7 文件共享</h3><blockquote><p>多个用户共享同一个文件，意味着系统中只有“一份“文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。如果是多个用户都“复制”了同一个文件，那么系统中会有”好几份“文件数据。其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响。</p></blockquote><h4 id="基于索引结点的共享方式（硬链接）"><a href="#基于索引结点的共享方式（硬链接）" class="headerlink" title="基于索引结点的共享方式（硬链接）"></a>基于索引结点的共享方式（硬链接）</h4><p>索引结点，是一种文件目录瘦身策略。由于检索文件时只需要用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。</p><p>索引结点中设置了一个链接技术变量count，用于表示链接到本索引结点上的用户目录项数。</p><p>若count&#x3D;2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。</p><p>若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减1.</p><p>若count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。</p><p>当count&#x3D;0时系统负责删除文件。</p><h4 id="基于符号链的共享方式（软链接）"><a href="#基于符号链的共享方式（软链接）" class="headerlink" title="基于符号链的共享方式（软链接）"></a>基于符号链的共享方式（软链接）</h4><p>在一个Link型的文件中记录共享文件的存放路径（windows快捷方式）</p><p>操作系统根据路径一层层查找目录，最终找到共享文件</p><p>即使软链接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查找共享文件会失败（找不到对应目录项）</p><p>由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I&#x2F;O，因此用软链接访问。</p><h3 id="4-1-8-文件保护"><a href="#4-1-8-文件保护" class="headerlink" title="4.1.8 文件保护"></a>4.1.8 文件保护</h3><h4 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h4><p>为文件设置一个“口令”，用户请求访问该文件时必须提供“口令”。</p><p>口令一般存放在文件对应的FCB或索引结点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件。</p><p>优点：保存口令的空间开销不多，验证口令的时间开销也很小。</p><p>缺点：正确的“口令“存放在系统内部，不够安全。</p><h4 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h4><p>使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码“才能对文件进行正确的解密。</p><p>优点：保密性强，不需要在系统中存储”密码“</p><p>缺点：编码&#x2F;译码，或者说加密&#x2F;解密要花费一定时间。</p><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>在每个文件的FCB（或索引结点）中增加一个访问控制列表（Access-Control List, ACL），该表中记录了各个用户可以对该文件执行哪些操作。</p><p>访问类型：</p><ul><li>读：从文件中读数据</li><li>写：向文件中写数据</li><li>执行：将文件装入内存并执行</li><li>添加：将信息添加到文件结尾部分</li><li>删除：删除文件，释放空间</li><li>列表清单：列出文件名和文件属性</li></ul><p>精简的访问列表：以“组”为单位，标记各“组”用户可以对问及那执行哪些操作。如：分为系统管理员、文件主、文件主的伙伴、其他用户几个分组。</p><p>当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。</p><h3 id="4-1-9-文件系统的层次结构"><a href="#4-1-9-文件系统的层次结构" class="headerlink" title="4.1.9 文件系统的层次结构"></a>4.1.9 文件系统的层次结构</h3><p><img src="/../img/operationSystem/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="文件系统的层次结构"></p><p>用一个例子来辅助记忆文件系统的层次结构：</p><p>假设某用户请求删除文件“D:&#x2F;工作目录&#x2F;学生信息.xlsx“的最后100条记录。</p><ol><li>用户需要通过操作系统提供的接口发出上述请求——用户接口</li><li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项——文件目录系统</li><li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限——存取控制模块（存取控制验证层）</li><li>验证了用户的访问权限之后，需要把用户提供的”记录号“转变为对应的逻辑结构——逻辑文件系统与文件信息缓冲区</li><li>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址——物理文件系统</li><li>要删除这条记录，必定要对磁盘设备发出请求——设备管理程序模块</li><li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收——辅助分配模块</li></ol><h3 id="4-2-1-磁盘的结构"><a href="#4-2-1-磁盘的结构" class="headerlink" title="4.2.1 磁盘的结构"></a>4.2.1 磁盘的结构</h3><h4 id="磁盘、磁道、扇区的概念"><a href="#磁盘、磁道、扇区的概念" class="headerlink" title="磁盘、磁道、扇区的概念"></a>磁盘、磁道、扇区的概念</h4><p>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</p><p>磁盘的磁面被划分成一个个磁道。这样的一个“圈”就是一个磁道。</p><p>最内侧磁道上的扇区面积最小，因此数据密度最大</p><p>一个磁道又被分成一个个扇区，每个扇区就是一个“磁盘块”。各个扇区存放的数据量相同。</p><h4 id="如何在磁盘中读-x2F-写数据"><a href="#如何在磁盘中读-x2F-写数据" class="headerlink" title="如何在磁盘中读&#x2F;写数据"></a>如何在磁盘中读&#x2F;写数据</h4><p>需要把“磁头”移动到想要读&#x2F;写的扇区所在的磁道。磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读&#x2F;写操作。</p><h4 id="盘面、柱面的概念"><a href="#盘面、柱面的概念" class="headerlink" title="盘面、柱面的概念"></a>盘面、柱面的概念</h4><p>一个盘片可能会有两个盘面，每个 盘面对应一个磁头，所有的磁头都是连在同一个磁臂上的，因此所有磁头只能“共进退”，所有盘面中相对位置相同的磁道组成柱面。</p><h4 id="磁盘的物理地址"><a href="#磁盘的物理地址" class="headerlink" title="磁盘的物理地址"></a>磁盘的物理地址</h4><p>可用（柱面号，盘面号，扇区号）来定位任意一个“磁盘块“。文件数据存放在外存中的几号块，这个块号就可以转换成（柱面号，盘面号，扇区号）的地址形式。</p><p>可根据该地址读取一个”块”</p><ol><li>根据“柱面号”移动磁臂，让磁头指向柱面</li><li>激活指定盘面对应的磁头</li><li>磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读&#x2F;写。</li></ol><h4 id="磁盘的分类"><a href="#磁盘的分类" class="headerlink" title="磁盘的分类"></a>磁盘的分类</h4><p>磁头可以移动的活动头磁盘。磁臂可以来回伸缩来带动磁头定位磁道。</p><p>磁头不可移动的称为固定磁盘。这种磁盘中每个磁道由一个磁头。</p><p>盘片可以更换的称为可换盘磁盘。盘片不可更换的称为固定盘磁盘。</p><h3 id="4-2-2-磁盘调度算法"><a href="#4-2-2-磁盘调度算法" class="headerlink" title="4.2.2 磁盘调度算法"></a>4.2.2 磁盘调度算法</h3><h4 id="一次磁盘读-x2F-写操作需要的时间"><a href="#一次磁盘读-x2F-写操作需要的时间" class="headerlink" title="一次磁盘读&#x2F;写操作需要的时间"></a>一次磁盘读&#x2F;写操作需要的时间</h4><p><strong>寻找时间(寻道时间)T<sub>s</sub></strong>:</p><p>在读&#x2F;写数据钱，将磁头移动到指定磁道所花的时间。</p><ol><li><p>启动磁头臂是需要时间的。假设耗时为s；</p></li><li><p>移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。则：</p><p> 寻道时间T<sub>s</sub> &#x3D; s + m * n</p></li></ol><p><strong>延迟时间T<sub>R</sub></strong></p><p>通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r(单位：转&#x2F;秒，或转&#x2F;分)，则平均所需的延迟时间T<sub>R</sub> &#x3D; (1&#x2F;2) * (1&#x2F;r) &#x3D; 1&#x2F;2r。</p><p>1&#x2F;r就是转一圈需要的时间。找到目标扇区平均需要转半圈，因此再乘以1&#x2F;2。</p><p><strong>传输时间T<sub>t</sub></strong></p><p>从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读&#x2F;写的字节数为b，每个磁道上的字节数为N。则：传输时间T<sub>t</sub> &#x3D; (1&#x2F;r) * (b&#x2F;N) &#x3D; b&#x2F;(rN)。</p><p>总的平均存取时间T<sub>a</sub> &#x3D; T<sub>s</sub> + 1&#x2F;2r + b&#x2F;(rN)</p><blockquote><p>每个磁道要可存N字节的数据，因此b字节的数据需要b&#x2F;N个磁道才能存储。而读&#x2F;写一个磁道所需要的时间刚好又是转一圈所需要的时间1&#x2F;r。延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间。</p></blockquote><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><p><strong>先来先服务FCFS</strong></p><p>根据进程请求访问磁盘的先后顺序进行调度。</p><p>假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道。按照FCFS的规则，按照请求到达的顺序，磁头需要一次移动到55、58、39、18、90、160、150、38、184号磁道。磁头总共移动了45+3+19+21+72+70+10+112+146&#x3D;498个磁道</p><p>响应一个请求平均需要移动498&#x2F;9&#x3D;55.3个磁道（平均寻找长度）</p><p>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过得去。</p><p>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。</p><p><strong>最短寻找时间优先SSTF</strong></p><p>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优）</p><p>假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道。</p><p>磁头总共移动了（100-18）+（184-18）&#x3D;248个磁道</p><p>响应一个请求平均需要移动248&#x2F;9 &#x3D; 27.5个磁道（平均寻找长度）</p><p>优点：性能较好，平均寻道时间短</p><p>缺点：可能产生“饥饿”现象</p><p>eg：本例中，如果在处理18号磁道的访问请求时又来了一个38号磁道的访问请求，处理38号磁道的访问请求又来了一个18号磁道的访问请求。如果有源源不断的18号、38号磁道的访问请求到来的话，150、160、184号磁道的访问请求就永远得不到满足，从而产生“饥饿”现象。</p><blockquote><p>产生饥饿的原因在于：磁头在一个小区域内来回来去地移动。</p></blockquote><p><strong>扫描算法SCAN</strong></p><p>SSTF算法产生饥饿的原因在于：磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。这就是扫描算法的思想。由于磁头移动的方式很像电梯，因此也叫电梯算法。</p><p>假设某磁盘的磁道为0～200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、16 0、150、38、184号磁道</p><p>磁头总共移动了（200-100）+（200 -18）&#x3D; 32个磁道</p><p>响应一个请求平均需要移动282&#x2F;9&#x3D;31.3个磁道（平均寻找长度）</p><p>优点：</p><ol><li>只有到达最边上的磁道时，才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后，就不需要再往右移动磁头了。</li><li>SCAN算法对于各个位置磁道的响应频率不平均（如：假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离；而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了）</li></ol><p><strong>Look调度算法</strong></p><p>扫描算法中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。Look调度算法就是为了解决这个问题，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。（边移动边观察，因此叫Look）</p><p>假设某磁盘的磁道为0～200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道</p><p>磁头总共移动了（184 - 100）+（184 - 18）&#x3D; 250个磁道</p><p>响应一个请求平均需要移动250 &#x2F; 9 &#x3D; 27.5 个磁道（平均寻找长度）</p><p>优点：比起SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短。</p><p><strong>循环扫描算法C-SCAN</strong></p><p>SCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</p><p>假设某磁盘的磁道为0～200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道</p><p>磁头总共移动了（200 -100）+（200-0）+（90-0）&#x3D; 390 个磁道</p><p>响应一个请求平均需要移动390 &#x2F; 9 &#x3D; 43.3 个磁道（平均寻找长度）</p><p>优点：比起SCAN来，对于各个位置磁道的响应频率很平均。</p><p>缺点：只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了；并且，磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。另外，比起SCAN算法来，平均寻道时间更长。</p><p><strong>C-LOOK调度算法</strong></p><p>C-SCAN算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p><p>假设某磁盘的磁道为0～200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道</p><p>磁头总共移动了（184 - 100）+（184 - 18） +（90 - 18）&#x3D; 322 个磁道</p><p>响应一个请求平均需要移动322 &#x2F; 9 &#x3D; 35.8个磁道（平均寻找长度）</p><p>优点：比起C-SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短。</p><h3 id="4-2-3-减少磁盘延迟时间的方法"><a href="#4-2-3-减少磁盘延迟时间的方法" class="headerlink" title="4.2.3 减少磁盘延迟时间的方法"></a>4.2.3 减少磁盘延迟时间的方法</h3><h4 id="交替编号"><a href="#交替编号" class="headerlink" title="交替编号"></a>交替编号</h4><p>具体做法：让编号相邻的扇区在物理上不相邻</p><p>原理：读取完一个扇区后需要一段时间处理才可以继续读入下一个扇区</p><h4 id="错位命名"><a href="#错位命名" class="headerlink" title="错位命名"></a>错位命名</h4><p>具体做法：让相邻盘面的扇区编号“错位”</p><p>原理：与“交替编号”的原理相同。”错位命名法“可降低延迟时间</p><h4 id="磁盘地址结构的设计"><a href="#磁盘地址结构的设计" class="headerlink" title="磁盘地址结构的设计"></a>磁盘地址结构的设计</h4><blockquote><p>为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）</p></blockquote><p>假设某磁盘有8个柱面&#x2F;磁道（假设最内侧柱面&#x2F;磁道号为0），4个盘面，8个扇区。则可用3个二进制位表示柱面，2个二进制位表示盘面，3个二进制位表示扇区。</p><p>若物理地址结构式（盘面号，柱面号，扇区号），且需要连续读取物理地址（00，000，000）～（00，001，111）的扇区：</p><p>（00，000，000）～（00，000，111）转两圈可读完</p><p>之后再读取物理地址相邻的区域，即（00，001，000）～（00，001，111），需要启动磁头臂，将磁头移动到下一个磁道。</p><p>若物理地址结构式（柱面号，盘面号，扇区号），且需要连续读取物理地址（000，00，000）～（000，01，111）的扇区：</p><p>（000，00，000）～（000，00，111）由盘面0的磁头读入数据之后再读取物理地址相邻的区域，即（000，01， 000）～（000，01，111），由于柱面号&#x2F;磁道号相同，只是盘面号不同，因此不需要移动磁头臂。只需要激活相邻盘面的磁头即可。</p><p>原因：在读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间。</p><h3 id="4-2-4-磁盘的管理"><a href="#4-2-4-磁盘的管理" class="headerlink" title="4.2.4 磁盘的管理"></a>4.2.4 磁盘的管理</h3><h4 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h4><ol><li>进行低级格式化（物理格式化），将磁盘的各个磁道划分为扇区。一个扇区通常可分为头、数据区域（如512B大小）、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶检验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误）</li><li>将磁盘分区，每个分区由若干柱面组成（即分为我们熟悉的C盘、D盘、E盘）</li><li>进行逻辑格式化，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表）</li></ol><h4 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h4><p>计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行初始化程序（自举程序）完成的。初始化程序可以放在ROM（只读存储器）中。</p><p>ROM中的数据在出厂时就写入了，并且以后不能再修改。</p><p>ROM一般是出厂时就集成在主板上的。</p><p>ROM中只存放很小的“自举装入程序”。</p><p>完成的自举程序放在磁盘的启动块（即引导块&#x2F;启动分区）上，启动块位于磁盘的固定位置。</p><p>开机时计算机先运行“自举装入程序”，通过执行该程序就可找到引导块，并将完整的“自举程序”读入内存，完成初始化。拥有启动分区的磁盘称为启动磁盘或系统磁盘（C:盘）</p><h4 id="坏块的管理"><a href="#坏块的管理" class="headerlink" title="坏块的管理"></a>坏块的管理</h4><p>坏了、无法正常使用的是扇区就是“坏块”。这属于硬件故障，操作系统是无法修复的。应该将坏块标记出来，以免错误地使用到它。</p><p>对于简单的磁盘，可以在逻辑格式化时（建立文件系统时）对整个磁盘进行坏块检查，表明哪些扇区是坏扇区，比如：在FAT表上表明。（在这种方式中，坏块对操作系统不透明）</p><p>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。</p><p>在磁盘出厂前进行低级格式化（物理格式化）时就讲坏块链进行初始化。</p><p>会保留一些”备用扇区“，用于替换坏块。这种方案称为扇区备用。且这种处理方式中，坏块对操作系统透明。</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="5-1-1-I-x2F-O设备的概念和分类"><a href="#5-1-1-I-x2F-O设备的概念和分类" class="headerlink" title="5.1.1 I&#x2F;O设备的概念和分类"></a>5.1.1 I&#x2F;O设备的概念和分类</h3><h4 id="什么是I-x2F-O设备"><a href="#什么是I-x2F-O设备" class="headerlink" title="什么是I&#x2F;O设备"></a>什么是I&#x2F;O设备</h4><p>“I&#x2F;O”就是“输入&#x2F;输出”（Input&#x2F;Output）</p><p>I&#x2F;O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</p><p>UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。</p><p>Write操作：向外部设备写出数据</p><p>Read操作：从外部设备读入数据</p><h4 id="按使用特性分类"><a href="#按使用特性分类" class="headerlink" title="按使用特性分类"></a>按使用特性分类</h4><ul><li><p>人机交互类外部设备</p><p>  数据传输速度慢。包括鼠标、键盘、打印机等，用于人机交互</p></li><li><p>存储设备</p><p>  数据传输速度快。包括移动硬盘、光盘等，用于数据存储</p></li><li><p>网络通信设备</p><p>  数据传输速度介于上述两种之间。包括调制解调器等，用于网络通信</p></li></ul><h4 id="按传输速率分类"><a href="#按传输速率分类" class="headerlink" title="按传输速率分类"></a>按传输速率分类</h4><ul><li>低速设备：鼠标、键盘，每秒几个到几百字节</li><li>中速设备：激光打印机，每秒数千至上万个字节</li><li>高速设备：磁盘，每秒数千字节至前兆字节</li></ul><h4 id="按信息交换的单位分类"><a href="#按信息交换的单位分类" class="headerlink" title="按信息交换的单位分类"></a>按信息交换的单位分类</h4><ul><li><p>块设备：传输速率较高，可寻址，即对它随机地读&#x2F;写任一块。如磁盘等，数据传输的基本单位是“块”。</p></li><li><p>字符设备：传输速率较慢，不可寻址，在输入&#x2F;输出时常采用中断驱动方式。如鼠标、键盘等，数据传输的基本单位是字符。</p></li></ul><h3 id="5-1-2-I-x2F-O控制器"><a href="#5-1-2-I-x2F-O控制器" class="headerlink" title="5.1.2 I&#x2F;O控制器"></a>5.1.2 I&#x2F;O控制器</h3><p>CPU无法直接控制I&#x2F;O设备的机械部件，因此I&#x2F;O设备还要有一个电子部件作为CPU和I&#x2F;O设备机械部件之间的“中介”，用于实现CPU对设备的控制。</p><p>这个电子部件就是I&#x2F;O控制器，又称设备控制器。CPU可控制I&#x2F;O控制器，又由I&#x2F;O控制器来控制设备的机械部件。</p><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ul><li><p>接受和识别CPU发出的命令</p><p>  如CPU发来的read&#x2F;write命令，I&#x2F;O控制器中会有相应的控制寄存器来存放命令和参数</p></li><li><p>向CPU报告设备的状态</p><p>  I&#x2F;O控制器中会有相应的状态寄存器，用于记录I&#x2F;O设备的当前状态。如1表示空闲，0表示忙碌</p></li><li><p>数据交换</p><p>  I&#x2F;O控制器中会设置相应的数据寄存器。输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备。输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据。</p></li><li><p>地址识别</p><p>  类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的”地址“。I&#x2F;O控制器通过CPU提供的“地址”来判断CPU要读&#x2F;写的是哪个寄存器。</p></li></ul><h4 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h4><ul><li><p>CPU与控制器的接口</p><p>  用于实现CPU与控制器之间的通信。CPU通过控制线发出命令；通过地址线指明要操作的设备；通过数据线来取出（输入）数据，或放入（输出）数据</p></li><li><p>I&#x2F;O逻辑</p><p>  负责接收和识别CPU的各种命令（如地址译码），并负责对设备发出命令</p></li><li><p>控制器与设备的接口</p><p>  用于实现控制器与设备之间的通信</p></li></ul><p>ps：</p><ol><li>一个I&#x2F;O控制器可能会对应多个设备；</li><li>数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制&#x2F;状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像I&#x2F;O；另一些计算机则采用I&#x2F;O专用地址，即寄存器独立编址。</li></ol><h4 id="两种寄存器编址方式"><a href="#两种寄存器编址方式" class="headerlink" title="两种寄存器编址方式"></a>两种寄存器编址方式</h4><ul><li><p>内存映射I&#x2F;O</p><p>  控制器中的寄存器与内存地址统一编址</p><p>  优点：简化了指令。可以采用对内存进行操作的指令来对控制器进行操作。</p></li><li><p>寄存器独立编址</p><p>  控制器中的寄存器使用单独的地址。</p><p>  缺点：需要设置专门的指令来实现对控制器的操作，不仅要指明寄存器的地址，还要指明控制器的编号。</p></li></ul><h3 id="5-1-3-I-x2F-O控制方式"><a href="#5-1-3-I-x2F-O控制方式" class="headerlink" title="5.1.3 I&#x2F;O控制方式"></a>5.1.3 I&#x2F;O控制方式</h3><h4 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h4><p><strong>Key word：轮询</strong></p><ol><li><p>完成一次读&#x2F;写操作的流程（以读操作为例）</p><p> ①CPU向控制器发出读指令。于是设备启动，并且状态寄存器设为1（未就绪）</p><p> ②轮询检查控制器的状态（其实就是在不断地执行程序的循环，若状态位一直是1，说明设备还没准备好要输入的数据，于是CPU会不断地轮询）</p><p> ③摄入设备准备好数据后将数据传给控制器，并报告自身状态</p><p> ④控制器将输入的数据放到数据寄存器中，并将状态改为0（已就绪）</p><p> ⑤CPU发现设备已就绪，即可将数据寄存器中的内容读入CPU的寄存器中，再把CPU寄存器中的内容放入内存</p><p> ⑥若还要继续读入数据，则CPU继续发出读指令</p><p> <img src="/../img/operationSystem/%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png" alt="程序直接控制方式"></p></li><li><p>CPU干预的频率</p><p> 很频繁，I&#x2F;O操作开始之前、完成之后需要CPU介入，并且在等待I&#x2F;O完成的过程中CPU需要不断地轮询检查。</p></li><li><p>数据传送的单位</p><p> 每次读&#x2F;写一个字</p></li><li><p>数据的流向</p><p> 读操作（数据输入）：I&#x2F;O设备 -&gt; CPU -&gt; 内存</p><p> 写操作（数据输出）：内存 -&gt; CPU -&gt; I&#x2F;O设备</p><p> 每个字的读&#x2F;写都需要CPU的帮助</p></li><li><p>主要缺点和主要优点</p><p> 优点：实现简单。在读&#x2F;写指令之后，加上实现循环检查的一系列指令即可（因此才称为“程序直接控制方式”）</p><p> 缺点：CPU和I&#x2F;O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等“状态，CPU利用率低。</p></li></ol><h4 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h4><ol><li><p>完成一次读&#x2F;写操作的过程</p><p> <img src="/../img/operationSystem/%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F.png" alt="中断驱动方式"></p></li><li><p>CPU干预的频率</p><p> 每次I&#x2F;O操作开始之前、完成之后需要CPU介入。等待I&#x2F;O完成的过程中CPU可以切换到别的进程执行。</p></li><li><p>数据传送的单位</p><p> 每次读&#x2F;写一个字</p></li><li><p>数据的流向</p><p> 读操作（数据输入）：I&#x2F;O设备 -&gt; CPU -&gt; 内存</p><p> 写操作（数据输出）：内存 -&gt; CPU -&gt; I&#x2F;O设备</p></li><li><p>主要缺点和主要优点</p><p> 优点：与“程序直接控制方式”相比，在“中断驱动方式”中，I&#x2F;O控制器会通过中断信号主动报告I&#x2F;O已完成，CPU不再需要不停地轮询。CPU和I&#x2F;O设备可并行工作，CPU利用率得到明显提升。</p><p> 缺点：每个字在I&#x2F;O设备与内存之间的传输，都需要经过CPU。而频繁的中断处理会消耗较多的CPU时间。</p></li></ol><p>引入中断机制。由于I&#x2F;O设备速度很慢，因此在CPU发出读&#x2F;写命令后，可将等待I&#x2F;O的进程阻塞，先切换到别的进程执行。当I&#x2F;O完成后，控制器会向CPU发出一个中断信号，CPU监测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，CPU从I&#x2F;O控制器读一个字的数据传送到CPU寄存器，在写入主存。接着，CPU恢复等待I&#x2F;O的进程（或其他进程）的运行环境，然后继续执行。</p><p>ps：</p><ol><li>CPU会在每个指令周期的末尾检查中断；</li><li>中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。如果中断发生的频率太高，也会降低系统性能。</li></ol><h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><p>与“中断驱动方式”相比，DMA方式（Direct Memory Access，直接存储器存取。主要用于块设备的I&#x2F;O控制）有这样几个改进：</p><p>①数据的传送单位是“块”。不再是一个字、一个字的传送</p><p>②数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为“快递小哥”</p><p>③仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</p><p><img src="/../img/operationSystem/DMA%E6%8E%A7%E5%88%B6%E5%99%A8.png" alt="DMA控制器"></p><p>DR（Data Register，数据寄存器）：暂存从设备到内存，或从内存到设备的数据。</p><p>MAR（Memory Address Register，内存地址寄存器）：在输入时，MAR表示数据应放到内存中的什么位置；输出时MAR表示要输出的数据放在内存中的什么位置。</p><p>DC（Data Counter，数据计数器）：表示剩余要读&#x2F;写的字节数。</p><p>CR（Command Register，命令&#x2F;状态寄存器）：用于存放CPU发来的I&#x2F;O命令，或设备的状态信息。</p><ol><li><p>完成一次读&#x2F;写操作的流程</p><p> <img src="/../img/operationSystem/DMA%E6%96%B9%E5%BC%8F.png" alt="DMA方式"></p></li><li><p>CPU干预的频率</p><p> 仅在传送一个或多个数据块的开始和结束时，才需要CPU干预</p></li><li><p>数据传送的单位</p><p> 每次读&#x2F;写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）</p></li><li><p>数据的流向（不再需要经过CPU）</p><p> 读操作（数据输入）：I&#x2F;O设备 -&gt; 内存</p><p> 写操作（数据输出）：内存 -&gt; I&#x2F;O设备</p></li><li><p>主要缺点和主要优点</p><p> 优点：数据传输以“块”为单位，CPU介入频率进一步降低。数据的传输不再需要先经过CPU在写入内存，数据传输效率进一步增加。CPU和I&#x2F;O设备的并行性得到提升。</p><p> 缺点：CPU每发出一条I&#x2F;O指令，只能读&#x2F;写一个或多个连续的数据块。如果要读&#x2F;写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I&#x2F;O指令，进行多次中断处理才能完成。</p></li></ol><h4 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h4><p>通道：一种硬件，可以理解为是“弱鸡版的CPU”。通道可以识别并执行一系列通道指令。与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存</p><p>①CPU向通道发出I&#x2F;O指令。指明通道程序在内存中的位置，并指明要操作的是哪个I&#x2F;O设备。之后CPU就切换到其他进程执行了</p><p>②通道执行内存中的通道程序（其中指明了要读入&#x2F;写出多少数据，读&#x2F;写的数据应放在内存的什么位置等信息）</p><p>③通道执行完规定的任务后，向CPU发出中断信号，之后C PU对中断进行处理</p><ol><li><p>完成一次读&#x2F;写操作的流程</p><p> <img src="/../img/operationSystem/%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png" alt="通道控制方式"></p></li><li><p>CPU干预的频率</p><p> 极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读&#x2F;写后才需要发出中断信号，请求CPU干预。</p></li><li><p>数据传送的单位</p><p> 每次读&#x2F;写一组数据块</p></li><li><p>数据的流向（在通道的控制下进行）</p><p> 读操作（数据输入）：I&#x2F;O设备 -&gt; 内存</p><p> 写操作（数据输出）：内存 -&gt; I&#x2F;O设备</p></li><li><p>主要缺点和主要优点</p><p> 缺点：实现复杂，需要专门的通道硬件支持</p><p> 优点：CPU、通道、I&#x2F;O设备可并行工作，资源利用率很高</p></li></ol><h3 id="5-1-4-I-x2F-O软件层次结构"><a href="#5-1-4-I-x2F-O软件层次结构" class="headerlink" title="5.1.4 I&#x2F;O软件层次结构"></a>5.1.4 I&#x2F;O软件层次结构</h3><p><img src="/../img/operationSystem/IO%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="IO软件层次结构"></p><h4 id="用户层软件"><a href="#用户层软件" class="headerlink" title="用户层软件"></a>用户层软件</h4><p>实现了与用户交互的接口，用户可直接使用该层提供的、与I&#x2F;O操作相关的库函数对设备进行操作</p><p>用户层软件将用户请求翻译成格式化的I&#x2F;O请求，并通过“系统调用”请求操作系统内核的服务</p><p>Windows操作系统向外提供的一系列系统调用，但是由于系统调用的格式严格，使用麻烦，因此在用户层上封装了一系列更方便的库函数共用户使用</p><h4 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h4><p>又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。</p><p>主要功能：</p><ol><li><p>向上一层提供统一的调用接口（如read&#x2F;write系统调用）</p></li><li><p>设备的保护</p><p> 原理类似与文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样。</p></li><li><p>差错处理</p><p> 设备独立性软件需要对一些设备的错误进行处理</p></li><li><p>设备的分配与回收</p></li><li><p>数据缓冲区管理</p><p> 可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</p></li><li><p>建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序</p><p> 用户或用户层软件发出I&#x2F;O操作相关系统调用时，需要指明此次要操作的I&#x2F;O设备的逻辑设备名</p><p> 设备独立性软件需要通过“逻辑设备表”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序</p></li></ol><p>操作系统可以采用两种方式管理逻辑设备表LUT：</p><ul><li>整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种只适用于丹用户操作系统。</li><li>为每个用户设置一张LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</li></ul><blockquote><p>为何不同的设备需要不同的设备驱动程序？</p></blockquote><p>不同设备的内部硬件特性不同，这些特性只有厂家才知道，因此厂家必须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作。</p><h4 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h4><p>主要负责对硬件设备的具体控制，将上层发出的一系列命令（如read&#x2F;write）转化成特定设备“能听得懂”的一些列操作。包括设置设备寄存器；检查设备状态等。</p><p>ps：驱动程序一般会以一个独立进程的方式存在。</p><h4 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h4><p>当I&#x2F;O任务完成时，I&#x2F;O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序的处理流程如下：</p><p>从控制器读出设备状态，若I&#x2F;O正常结束，从设备中读入一个字的数据并经由CPU放到内存缓冲区中。若I&#x2F;O异常结束，根据异常原因做响应处理。</p><h3 id="5-1-5-I-x2F-O核心子系统"><a href="#5-1-5-I-x2F-O核心子系统" class="headerlink" title="5.1.5 I&#x2F;O核心子系统"></a>5.1.5 I&#x2F;O核心子系统</h3><p><img src="/../img/operationSystem/IO%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F.png" alt="IO核心子系统"></p><h4 id="各功能要在那个层次实现"><a href="#各功能要在那个层次实现" class="headerlink" title="各功能要在那个层次实现"></a>各功能要在那个层次实现</h4><p>用户层软件：假脱机技术SPOOLing技术</p><p>设备独立性软件：I&#x2F;O调度、设备保护、设备分配与回收、缓冲区管理（即缓冲与高速缓存）</p><p>ps：假脱机技术SPOOLing技术需要请求“磁盘设备”的设备独立性软件的服务，因此一般来说假脱机技术是在用户层软件实现的。</p><p>I&#x2F;O调用：用某种算法确定一个好的顺序来处理各个I&#x2F;O请求。</p><h3 id="5-1-6-假脱机技术"><a href="#5-1-6-假脱机技术" class="headerlink" title="5.1.6 假脱机技术"></a>5.1.6 假脱机技术</h3><h4 id="什么是脱机技术，脱机技术可以解决什么问题"><a href="#什么是脱机技术，脱机技术可以解决什么问题" class="headerlink" title="什么是脱机技术，脱机技术可以解决什么问题"></a>什么是脱机技术，脱机技术可以解决什么问题</h4><p>手工操作阶段：主机直接从I&#x2F;O设备获得数据，由于设备速度慢，主机速度很快 。人机速度矛盾明显，主机要浪费很多时间来等待设备。</p><p>批处理阶段引入了脱机输入&#x2F;输出技术：在外围控制机的控制下，慢速输入设备的数据先辈输入到更快速的磁带上。之后主机可以从快速的磁带上读入数据，从而缓解了速度矛盾。引入脱机技术后，缓解了CPU与慢速I&#x2F;O设备的速度矛盾。另一方面，即使CPU在忙碌，也可以提前将数据输入到磁带；即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁道。</p><blockquote><p>脱机——脱离主机的控制进行的输入&#x2F;输出操作。</p></blockquote><h4 id="假脱机技术的实现原理"><a href="#假脱机技术的实现原理" class="headerlink" title="假脱机技术的实现原理"></a>假脱机技术的实现原理</h4><p>“假脱机技术”又称“SPOOLing技术”，是用软件的方式模拟脱机技术。SPOOLing系统的组成如下：</p><p><img src="/../img/operationSystem/spooling%E7%BB%84%E6%88%90.png" alt="spooling组成"></p><p><strong>输入井和输出井</strong></p><p>“输入井”模拟脱机输入时的磁带，用于收容I&#x2F;O设备输入的数据。</p><p>“输出井”模拟脱机输出时的磁带，用于收容用户进程输出的数据。</p><p><strong>输入进程和输出进程</strong></p><p>“输入进程”模拟脱机输入时的外围控制机</p><p>“输出进程”模拟脱机输出时的外围控制机</p><p><strong>输入缓冲区和输出缓冲区</strong></p><p>在输入进程的控制下，“输入缓冲区”用于暂存从输入设备输入的数据，之后在转存到输入井中</p><p>在输出进程的控制下，”输出缓冲区“用于暂存从输出井送来的数据，之后再传送到输出设备上</p><h4 id="共享打印机原理"><a href="#共享打印机原理" class="headerlink" title="共享打印机原理"></a>共享打印机原理</h4><p>独占式设备——只允许各个进程串行使用的设备。一段时间只能满足一个进程的请求。</p><p>共享设备——允许多个进程“同时”使用的设备（宏观上同时使用，微观上可能是交替使用）。可以同时满足多个进程的使用请求。</p><p>打印机是种“独占式设备”，但是可以用SPOOLing技术改造成“共享设备”</p><p>独占式设备的例子：若进程1正在使用打印机，则进程2请求使用打印机时必然阻塞等待</p><p>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给它们，而是由假脱机管理进程为每个进程做两件事：</p><ol><li>在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中；</li><li>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上。</li></ol><p>当打印机空闲时，输出进程会从文件队列的对头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务。</p><p>虽然系统中只有一台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。</p><p>SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备。</p><h3 id="5-1-7-设备的分配与回收"><a href="#5-1-7-设备的分配与回收" class="headerlink" title="5.1.7 设备的分配与回收"></a>5.1.7 设备的分配与回收</h3><h4 id="设备分配时应考虑的因素"><a href="#设备分配时应考虑的因素" class="headerlink" title="设备分配时应考虑的因素"></a>设备分配时应考虑的因素</h4><ul><li><p>设备的固有属性</p><ul><li>独占设备：一个时段只能分配给一个进程，如打印机</li><li>共享设备：可同时分配给多个进程使用，如磁盘。各进程往往使宏观上同时共享使用设备，而微观上交替使用。</li><li>虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用，如采用SPOOLing技术实现的共享打印机</li></ul></li><li><p>设备分配算法</p><p>  先来先服务、优先级高者优先、短任务优先等</p></li><li><p>设备分配中的安全性</p><ul><li><p>安全分配方式：为进程分配一个设备后就讲进程阻塞，本次I&#x2F;O完成后才将进程唤醒。</p><p>  一个时段内每个进程只能使用一个设备。</p><p>  优点：破坏了“请求和保持”条件，不会死锁</p><p>  缺点：对于一个进程来说，CPU和I&#x2F;O设备只能串行工作</p></li><li><p>不安全分配方式：进程发出I&#x2F;O请求后，系统为其分配I&#x2F;O设备，进程可继续执行，之后还可以发出新的I&#x2F;O请求。只有某个I&#x2F;O请求得不到满足时才将进程阻塞。</p><p>  一个进程可以同时使用多个设备</p><p>  优点：进程的计算任务和I&#x2F;O任务可以并行处理，使进程迅速推进</p><p>  缺点：有可能发生死锁（死锁避免、死锁的检测和解除）</p></li></ul></li></ul><h4 id="静态分配与动态分配"><a href="#静态分配与动态分配" class="headerlink" title="静态分配与动态分配"></a>静态分配与动态分配</h4><p>静态分配：进程运行前为其分配全部所需资源，运行结束后归坏资源。破坏了“请求和保持”条件，不会发生死锁</p><p>动态分配：进程运行过程中动态申请设备资源</p><h4 id="设备分配管理中的数据结构"><a href="#设备分配管理中的数据结构" class="headerlink" title="设备分配管理中的数据结构"></a>设备分配管理中的数据结构</h4><p>“设备、控制器、通道”之间的关系：</p><p><img src="/../img/operationSystem/%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8%E9%80%9A%E9%81%93%E5%85%B3%E7%B3%BB.png"></p><p>一个通道可控制多个设备控制器，每个设备控制器可控制多个设备。</p><p>设备控制表（DCT）：系统为每个设备配置一张DCT，用于记录设备情况</p><p><img src="/../img/operationSystem/%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E8%A1%A8.png" alt="设备控制表"></p><p>控制器控制表（COCT）：每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。</p><p><img src="/../img/operationSystem/%E6%8E%A7%E5%88%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E8%A1%A8.png" alt="控制器控制表"></p><p>通道控制表（CHCT）：每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理。</p><p><img src="/../img/operationSystem/%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E8%A1%A8.png" alt="通道控制表"></p><p>系统设备表（SDT）：记录了系统中全部设备的情况，每个设备对应一个表目</p><p><img src="/../img/operationSystem/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%A4%87%E8%A1%A8.png" alt="系统设备表"></p><h4 id="设备分配的步骤"><a href="#设备分配的步骤" class="headerlink" title="设备分配的步骤"></a>设备分配的步骤</h4><ol><li>根据进程请求的物理设备名查找SDT（注：物理设备名时进程请求分配设备时提供的参数）</li><li>根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li><li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li></ol><blockquote><p>只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I&#x2F;O设备进行数据传送</p></blockquote><p>缺点：</p><ol><li>用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程</li><li>若换了一个物理设备，则程序无法运行</li><li>若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</li></ol><p>改进：建立逻辑设备名与物理设备名的映射机制，用户编程时只需要提供逻辑设备名</p><h4 id="设备分配步骤的改进方法"><a href="#设备分配步骤的改进方法" class="headerlink" title="设备分配步骤的改进方法"></a>设备分配步骤的改进方法</h4><ol><li>根据进程请求的逻辑设备名查找SDT（用户编程时提供的逻辑设备名其实就是“设备类型”）</li><li>查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表LUT中新增一个表项。</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li><li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li></ol><p>逻辑设备表LUT建立了逻辑设备名与物理设备名之间的映射关系。</p><p>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项。</p><p>如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址。</p><p>逻辑设备表的设置问题：</p><p>整个系统只有一张LUT：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统</p><p>每个用户一张LUT：不同用户的逻辑设备名可重复，适用于多用户操作系统</p><h3 id="5-1-8-缓冲区管理"><a href="#5-1-8-缓冲区管理" class="headerlink" title="5.1.8 缓冲区管理"></a>5.1.8 缓冲区管理</h3><h4 id="缓冲区的概念"><a href="#缓冲区的概念" class="headerlink" title="缓冲区的概念"></a>缓冲区的概念</h4><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</p><p>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</p><p>一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要阻止管理好这些缓冲区</p><p>缓冲区的作用：</p><ul><li>缓和CPU与I&#x2F;O设备之间速度不匹配的矛盾</li><li>减少对CPU的中断频率，放宽对CPU中断相应时间的限制</li><li>解决数据力度不匹配的问题</li><li>提高CPU与I&#x2F;O设备之间的并行性</li></ul><h4 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h4><p>假设某用户进程请求某块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区。当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满后，才能冲缓冲区把数据传出。</p><p>处理一块数据平均耗时Max(C, T) + M</p><h4 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h4><p>假设某用户进程请求某种块设备读入若干块的数据。若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区。</p><p>处理一个数据块的平均耗时为Max(T, C + M)</p><h4 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h4><p>将多个大小相等的缓冲区连接成一个循环队列。</p><h4 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h4><p>缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。</p><p>另外，根据一个缓冲区在世纪运算中扮演的功能不同，又设置了四种工作缓冲区：</p><ul><li>用于收容输入数据的工作缓冲区（hin）</li><li>用于提取输入数据的工作缓冲区（sin）</li><li>用于收容输出数据的工作缓冲区（hout）</li><li>用于提取输出数据的工作缓冲区（sout）</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2022/07/13/computer/"/>
      <url>/2022/07/13/computer/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><h3 id="概念、组成、功能和分类"><a href="#概念、组成、功能和分类" class="headerlink" title="概念、组成、功能和分类"></a>概念、组成、功能和分类</h3><p>计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。</p><p>计算机网络是互联、自治的计算机集合。</p><ul><li>互联：互通互联——通信链路</li><li>自治：无主从关系</li></ul><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>数据通信</li><li>资源共享（硬件、软件、数据）</li><li>分布式处理  多台计算机各自承担同一工作任务的不同部分</li><li>提高靠靠性</li><li>负载均衡</li></ul><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li>组成部分分为软件、硬件和协议</li><li>工作方式包括边缘部分和核心部分。边缘部分从用户使用角度又可分为C&#x2F;S方式和P2P方式。核心部分为边缘部分提供服务。</li><li>功能组成包括通信子网和资源子网。通信子网实现数据通信，包括物理层、数据链路层和网络层。资源子网实现资源共享、数据处理等，包含会话层、表示层和应用层。</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>按分布范围可分为：广域网WAN、城域网MAN、局域网WAN和个人区域网PAN。</li><li>按使用者可分为：公用网和专用网。</li><li>按交换技术可分为：电路交换、报文交换和分组交换。</li><li>按拓扑结构可分为：总线型、星型、环形和网状型。</li><li>按传输技术可分为：广播式网络(共享公共通信信道)和点对点网络(使用分组存储转发和路由选择机制)。</li></ul><h3 id="标准化工组及相关组织"><a href="#标准化工组及相关组织" class="headerlink" title="标准化工组及相关组织"></a>标准化工组及相关组织</h3><blockquote><p>要实现不同厂商的硬、软件之间相互连通，必须遵从统一的标准。</p></blockquote><h4 id="标准的分类"><a href="#标准的分类" class="headerlink" title="标准的分类"></a>标准的分类</h4><ul><li>法定标准：由权威机构制定的正式的、合法的标准。eg: OSI</li><li>事实标准：某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准。eg:TCP&#x2F;IP</li></ul><h4 id="RFC（Request-For-Comments）因特网标准的形式"><a href="#RFC（Request-For-Comments）因特网标准的形式" class="headerlink" title="RFC（Request For Comments）因特网标准的形式"></a>RFC（Request For Comments）因特网标准的形式</h4><p>RFC要上升为因特网正式标准的四个阶段：</p><ol><li>因特网草案（Internet Draft）这个阶段还不是RFC文档。</li><li>建议标准（Proposed Standard）从这个阶段开始成为RFC文档。</li><li>草案标准（Draft Standard）IEFT、IAB</li><li>因特网标准（Internet Standard)</li></ol><h4 id="相关组织"><a href="#相关组织" class="headerlink" title="相关组织"></a>相关组织</h4><ul><li>国际标准化组织ISO：OSI参考模型、HDLC协议</li><li>国际电信联盟ITU：置顶通信规则</li><li>国际电气电子工程师协会IEEE：学术机构、IEEE802系列标准、5G</li><li>Internet工程师任务组IETF：负责因特网相关标准的制定</li></ul><h3 id="速率相关的性能指标"><a href="#速率相关的性能指标" class="headerlink" title="速率相关的性能指标"></a>速率相关的性能指标</h3><blockquote><p>速率即数据率或称数据传输率或比特率。也可以表示连接在计算机网络上的主机在数字信道上传送数据位数的速率。</p></blockquote><h4 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h4><p>单位是b&#x2F;s, kb&#x2F;s, Mb&#x2F;s, Gb&#x2F;s, Tb&#x2F;s</p><table><thead><tr><th>单位</th><th align="center">速率</th><th align="center">存储容量</th></tr></thead><tbody><tr><td>千</td><td align="center">1 kb&#x2F;s&#x3D;10^3 b&#x2F;s</td><td align="center">1 KB&#x3D;2^10 B&#x3D;1024 * 8 b</td></tr><tr><td>兆</td><td align="center">1 Mb&#x2F;s&#x3D;10^3 kb&#x2F;s&#x3D;10^6 b&#x2F;s</td><td align="center">1 MB&#x3D;2^10 KB&#x3D;1024 KB</td></tr><tr><td>吉</td><td align="center">1 Gb&#x2F;s&#x3D;10^3 Mb&#x2F;s&#x3D;10^6 Kb&#x2F;s&#x3D;10^ 9 b&#x2F;s</td><td align="center">1 GB&#x3D;2^10 MB&#x3D;1024 MB</td></tr><tr><td>太</td><td align="center">1 Tb&#x2F;s&#x3D;10^ Gb&#x2F;s&#x3D;10^6 Mb&#x2F;s&#x3D;10^9 Kb&#x2F;s&#x3D;10^12 b&#x2F;s</td><td align="center">1 TB&#x3D;2^10 GB&#x3D;1024 GB</td></tr></tbody></table><blockquote><p>ps: 1 Byte(字节)&#x3D;8bit(比特)</p></blockquote><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><p>原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹 Hz。</p><p>在计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间从网络中的某一点到令一点所能通过的最高数据率。单位是比特每秒，b&#x2F;s，kb&#x2F;s，Mb&#x2F;s，Tb&#x2F;s。即网络设备所支持的最高速率。</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>表示在单位时间内通过某个网络(或信道、接口)的数据量，单位b&#x2F;s，kb&#x2F;s，Mb&#x2F;s。</p><p>吞吐量受网络的带宽或网络的额定速率的限制。</p><h3 id="时延、时延带宽积、RTT和利用率"><a href="#时延、时延带宽积、RTT和利用率" class="headerlink" title="时延、时延带宽积、RTT和利用率"></a>时延、时延带宽积、RTT和利用率</h3><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><p>指数据（包围&#x2F;分组&#x2F;比特流）从网络（或链路）的一段传送到另一端所需的时间。也叫延迟或迟延。单位是s。</p><p><strong>发送时延</strong></p><ul><li>从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间。</li><li>发送时延&#x3D;数据长度&#x2F;信道带宽(发送速度)</li></ul><p><strong>传播时延</strong></p><ul><li>取决于电磁波传播速度和链路长度</li><li>传播时延&#x3D;信道长度&#x2F;电磁波在信道上的传播速率</li></ul><p><strong>排队时延</strong></p><ul><li>等待输出&#x2F;入链路可用</li></ul><p><strong>处理时延</strong></p><ul><li>检错找出口</li></ul><h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><p>时延带宽积又称为以比特为单位的链路长度，即某段链路现在有多少比特。<br>时延带宽积(bit)&#x3D;传播时延(s)*带宽(b&#x2F;s)</p><h4 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h4><p>从发送发发送数据开始，到发送发接收到接收方的确认，总共经历的时延。</p><p>RTT越大，在收到确认之前，可以发送的数据越多。</p><p>RTT包括往返传播时延(传播时延*2)和末端处理时间。</p><h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><p>利用率包括信道利用率和网络利用率。信道利用率&#x3D;有数据通过时间&#x2F;(有+无)数据通过时间。网络利用率等于信道利用率的加权平均值。</p><h3 id="分层结构、协议、接口和服务"><a href="#分层结构、协议、接口和服务" class="headerlink" title="分层结构、协议、接口和服务"></a>分层结构、协议、接口和服务</h3><h4 id="分层的基本原则"><a href="#分层的基本原则" class="headerlink" title="分层的基本原则"></a>分层的基本原则</h4><ul><li>各层之间相互独立，每层只实现一种相对独立的功能。</li><li>各层之间的界面自然清晰，易于理解，相互交流尽可能少。</li><li>结构上可分割开。每层都采用最合适的技术来实现。</li><li>保持下层对上层的独立性，上层单项使用下层提供的服务。</li><li>整个分层结构应该能促进标准化工作。</li></ul><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p>第n层中的活动元素称为n层实体。同一层的实体叫做对等实体。</p><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>为进行网络中的对等实体数据交换而建立的规则、标准或约定称为网络协议【水平方向】</p><p>语法：规定传输数据的格式</p><p>语义：规定所要完成的功能</p><p>同步：规定各种操作的顺序</p><h4 id="接口-访问服务点ASP"><a href="#接口-访问服务点ASP" class="headerlink" title="接口(访问服务点ASP)"></a>接口(访问服务点ASP)</h4><p>上层使用下层服务的入口</p><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>下层为相邻上层提供的功能调用。【垂直方向】</p><p><img src="/../img/computer/p1.png"></p><p>SDU服务数据单元：未完成用户所要求的共功能而应传送的数据。</p><p>PCI协议控制信息：控制协议操作的信息。</p><p>PDU协议数据单元：对等层质传送的数据单元。</p><h3 id="OSI七层参考模型"><a href="#OSI七层参考模型" class="headerlink" title="OSI七层参考模型"></a>OSI七层参考模型</h3><p><img src="/../img/computer/osi.png" alt="OSI 七层参考模型"></p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>所有能和用户交互产生网络流量的程序。</p><h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>用于处理在两个通信系统中交换信息的表示方式。</p><p>功能：</p><ul><li>数据格式变换——翻译官</li><li>数据加密解密——密码加密</li><li>数据压缩和恢复——图片压缩</li></ul><h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>向表示实体&#x2F;用户进程提供建立连接并在连接上有序地传送数据——建立同同步会话。</p><p>功能：</p><ul><li>建立、管理和终止会话。</li><li>使用校验点可使会话在通信失效时从校验点或同步点继续回复通信，实现数据同步。</li></ul><p>主要协议：ADS、SAP</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>负责主机中两个进程的通信。即端到端的通信。单位：报文段或用户数据报。</p><p>功能：</p><ul><li>可靠传输、不可靠传输</li><li>差错控制</li><li>流量控制</li><li>复用分用</li></ul><p>主要协议：TCP&#x2F;IP</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>把分组从源端缠讼到目的端，为分组交换网上的不同主机提供通信服务。单位：数据报。</p><p>功能：</p><ul><li>路由选择，最佳路径</li><li>流量控制</li><li>差错控制</li><li>拥塞控制</li></ul><p>主要协议：IP、IPX、ICMP、IGMP、ARP</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>把网络层传下来的数据报组装成帧。单位：帧</p><p>功能：</p><ul><li>成帧（定义帧的开始和结束）</li><li>差错控制：帧错或位错</li><li>流量控制</li><li>访问控制，控制对信道的访问</li></ul><p>主要协议：SDLC、HDLC、PPP、STP</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>在屋里媒体上实现比特流的透明传输——不管所传输数据是什么样的比特组合，都应当能狗在链路上传输。</p><p>功能：</p><ul><li>定义接口特性</li><li>定义传输模式。单工、半双工、双工</li><li>比特同步</li><li>比特编码</li></ul><p>主要协议：Rj45、802.5</p><h3 id="TCP-x2F-IP参考模型和5层参考模型"><a href="#TCP-x2F-IP参考模型和5层参考模型" class="headerlink" title="TCP&#x2F;IP参考模型和5层参考模型"></a>TCP&#x2F;IP参考模型和5层参考模型</h3><p>OSI参考 模型与TCP&#x2F;IP参考模型</p><p><img src="/../img/computer/tcp.png" alt="TCP/IP 四层参考模型"></p><p>相同点：</p><ol><li>都分层</li><li>基于独立的协议栈的概念</li><li>可以实现异构网络互联</li></ol><p>不同点：</p><ol><li>OSI定义三点：服务、协议、接口</li><li>OSI先出现，参考模型限于协议发明，不偏向特定协议</li><li>TCP&#x2F;IP设计之初就考虑到异构网互联问题，将IP作为重要层次</li><li><table><thead><tr><th></th><th align="center">ISO&#x2F;OSI参考模型</th><th align="center">TCP&#x2F;IP模型</th></tr></thead><tbody><tr><td>网络层</td><td align="center">无连接+面向连接</td><td align="center">无连接</td></tr><tr><td>传输层</td><td align="center">面向连接</td><td align="center">无连接+面向连接</td></tr></tbody></table></li></ol><p>ps：面向连接：分为三个阶段，第一是建立连接，在此阶段，发出一个建立连接的请求。只有在连接成功建立之后，才能开始数据传输，这是第二阶段。接着，当数据传输完毕，必须释放连接。而面向无连接没有这么多阶段，它直接进行数据传输。</p><p>五层参考模型</p><p><img src="/../img/computer/5floor.png" alt="五层参考模型"></p><p>五层参考模型的数据封装与解封装</p><p><img src="/../img/computer/p2.png" alt="五层参考模型的数据封装与解封装"></p><h2 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h2><h3 id="物理层基础"><a href="#物理层基础" class="headerlink" title="物理层基础"></a>物理层基础</h3><h4 id="数据通信基础知识"><a href="#数据通信基础知识" class="headerlink" title="数据通信基础知识"></a>数据通信基础知识</h4><blockquote><p>物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 </p></blockquote><p><strong>物理层主要任务</strong>：确定与传输媒体接口有关的一些特性——定义标准。</p><ol><li>机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况。</li><li>电气特性：规定传输二进制位时，线路上信号的电眼范围、阻抗匹配、传输速率和距离限制等。</li><li>功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。</li><li>规程特性：定义各条物理线路的工作规程和时序关系。</li></ol><p><img src="/../img/computer/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.png" alt="典型数据通信模型"></p><p><strong>数据通信相关术语</strong></p><p>通信的目的是传递消息。</p><p><strong>数据</strong>：传送信息的实体，通常是有意义的符号序列。</p><p><strong>信号</strong>：数据的电器&#x2F;电磁的表现，是数据在传输过程中的存在形式。数字信号：代表消息的参数取值是离散的。模拟信号：代表消息的参数取值是连续的。</p><p><strong>信源</strong>：产生和发送数据的源头。</p><p><strong>信宿</strong>：接收数据的终点。</p><p><strong>信道</strong>：信号的传输媒介，一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。<br>信道按传输信号可分为传送模拟信号的模拟信道和传送数字信号的数字信道。按传输介质可分为无线信道和有线信道。</p><p><strong>三种通信方式</strong></p><p>从通信双发信息的交互方式看，可以有三种基本方式：</p><ol><li>单工通信：只有一个方向的通信而没有反方向的交互，仅需要一条信道。</li><li>半双工通信：通信的双方都可以发送或接受信息，但任何一方都不能同时发送和接收，需要两条信道。</li><li>全双工通信：通信双方可以同时发送和接收信息，也需要两条信道。</li></ol><p><strong>两种数据传输方式</strong></p><p>串行传输：速度慢，费用低，适合远距离</p><p>并行传输：速度快，费用高，适合近距离（常用语计算机内部数据传输）</p><h4 id="码元、波特、速率、带宽"><a href="#码元、波特、速率、带宽" class="headerlink" title="码元、波特、速率、带宽"></a>码元、波特、速率、带宽</h4><p><strong>码元</strong>是指一个固定时长的信号波形(数字脉冲)，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为K进制码元，而该时长称为码元宽度。当码元的离散状态有M个时(M大于2)，此时码元为M进制码元。<br><strong>1码元可以携带多个比特的信息量</strong>。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。</p><p><strong>速率</strong>也叫数据率，是指数据的传输速率，表示单位时间内传输的数据量。可以用<strong>码元传输速率</strong>和<strong>信息传输速率</strong>表示。</p><ol><li>码元传输速率：别名码元速率、波形速率、调制速率、符号速率等，他表示单位时间内数字通信系统所传输的码元个数（也可称为脉冲个数或信号变化的次数），<br>单位是<strong>波特（Baud）</strong>。1波特表述数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。（1s传输多少个码元）</li><li>信息传输速率：别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数（即比特数），单位是比特&#x2F;秒（b&#x2F;s）。(1s传输 多少个比特)</li></ol><p>关系：若一个码元携带n bit的信息量，则M Baud的码元传输速率多对应的信息传输速率为M*n bit&#x2F;s。</p><p><strong>带宽</strong>表示在单位时间内从网络中的某一点到另一点所能通过的<strong>最高数据率</strong>，通常用来表示网络的通信线路所能传输数据的能力。单位是b&#x2F;s。</p><p><strong>习题：</strong></p><p>某一数字通信系统传输的是四进制码元，4s传输了8000个码元，求系统的码元传输速率是多少？信息传输速率是多少？若另一个通信系统传输的是十六进制码元，6s传输了7200个码元，<br>求它的码元传输速率是多少？信息传输速率是多少？并指出那个系统传输速率快？</p><p><strong>解：</strong></p><p>四进制码元系统：</p><p>码元传输速率：8000&#x2F;4&#x3D;2000 Baud，信息传输速率：2000*log(2)4&#x3D;4000 b&#x2F;s</p><p>十六进制码元系统：</p><p>码元传输速率：7200&#x2F;6&#x3D;1200 Baud，信息传输速率：1200*log(2)16&#x3D;4800 b&#x2F;s</p><p>因为系统传输的是比特流，通常比较信息传输速率，所以十六进制系统下传输速率更快。同时，如果用该系统去传输四进制码元，会有更高的码元传输速率。</p><h4 id="奈氏准则和香农定理"><a href="#奈氏准则和香农定理" class="headerlink" title="奈氏准则和香农定理"></a>奈氏准则和香农定理</h4><p>奈氏准则：在理想低通（无噪声，带宽受限）天渐狭，为了避免马健串扰，极限码元传输速率2W Baud，W是信道带宽，单位是Hz。</p><p>理想低通信道下的极限数据传输率&#x3D;2Wlog(2)V b&#x2F;s</p><blockquote><p>W 为带宽（Hz），V 为集中码元&#x2F;码元的离散电平数目</p></blockquote><ol><li>在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。</li><li>信道的频率越宽（即能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输。</li><li>奈氏准则给出了码元传输速率的限制，但没有对信息传输速率给出限制。</li><li>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特信息量，这就需要采用多元制的调制方法。</li></ol><p>香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</p><p>信道的极限数据传输速率&#x3D;Wlog(2)(1+S&#x2F;N) b&#x2F;s</p><blockquote><p>W 带宽Hz，S&#x2F;N 信噪比，S是信道所传信号的平均功率，N是信道内的高斯噪声功率。</p></blockquote><h3 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h3><h4 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h4><p>对信号进行再生和还原，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的功能。</p><p>中继器的两端：</p><p>两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互联，且两个网段速率要相同。</p><p>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适合于网段的数据。</p><p>两端可连相同媒体，也可连不同媒体。</p><p>中继器两端的网段一定要是同一个协议。</p><h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><p>对信号进行再生放大转发，对衰减的信号进行放大，接着转发到其它所有(除输入端口外)处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。不具备信号的定向传送能力，是一个共享式设备。</p><h2 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="数据链路层功能概述"><a href="#数据链路层功能概述" class="headerlink" title="数据链路层功能概述"></a>数据链路层功能概述</h3><p><strong>结点</strong>：主机、路由器</p><p><strong>链路</strong>：网路中两个结点之间的物理通道 ，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无限链路。</p><p><strong>数据链路</strong>：网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路。</p><p><strong>帧</strong>：链路层的协议数据单元，封装网络层数据报。</p><blockquote><p>数据链路层在物理层提供服务的基础上想网络层提供服务，其最基本的服务是将源自网络层来的数据可靠的传输到相邻结点的目标机网络层。<br>其主要作用是<strong>加强物理层传输原始化比特流的功能</strong>，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p></blockquote><p>功能:</p><ol><li>为网络层提供服务。(无确认无连接服务，有确认无连接服务，有确认面向连接服务。)</li><li>链路管理，即连接的建立、维持、释放。（用于面向连接的服务）</li><li>组帧</li><li>流量控制。限制发送发</li><li>差错控制（帧错&#x2F;位错）。</li></ol><h3 id="封装成帧和透明传输"><a href="#封装成帧和透明传输" class="headerlink" title="封装成帧和透明传输"></a>封装成帧和透明传输</h3><p><strong>封装成帧</strong>就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，<br>从收到的比特流中识别帧的开始和结束。</p><p>首部和尾部包含许多的控制信息，他们的一个重要作用：<strong>帧定界</strong>（确定帧的界限）</p><p>帧同步：接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。</p><p>组帧的四种方法： 1.字符计数法; 2.字符(节)填充法；3.零比特填充法；4.违规编码法。</p><p><img src="/../img/computer/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.png" alt="组装成帧"></p><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><blockquote><p>指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就”看不见”有什么妨碍<br>数据传输的东西。当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，<br>使接收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的。</p></blockquote><p><strong>字符计数法</strong></p><p>帧首部使用一个计数字段（第一个字节，八位）来标明帧内字符数。</p><p><img src="/../img/computer/%E5%AD%97%E7%AC%A6%E8%AE%A1%E6%95%B0%E6%B3%95.png" alt="字符计数法"></p><p>缺点：如果第一个字节出错，将导致后续所有帧全部出错，发送和接收方的数据就会混乱。</p><p><strong>字符填充法</strong></p><p><img src="/../img/computer/%E5%AD%97%E7%AC%A6%E5%A1%AB%E5%85%85%E6%B3%95.png" alt="字符填充法"></p><p>如果在传输的每帧里面的原始数据里面存在和帧头或者帧尾相同的比特流时，接收法就会错误的处理数据。<br>所以在原始数据中出现帧头或帧尾的地方前面填充字符（遇到和填充字符相同的地方也需要在前面填充字节），<br>告诉接收方，接收时不需要管后面的内容，直到遇到真正的帧尾为止。</p><p><strong>零比特填充法</strong></p><p><img src="/../img/computer/%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85%E6%B3%95.png" alt="零比特填充法"></p><p>操作：</p><p><img src="/../img/computer/%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85%E6%B3%951.png"></p><ol><li>在发送端，扫描整个信息字段，只要连续5个1，就立即填入1个0。</li><li>再接收端收到一个帧时，先找到标志字段确定边界，在用硬件对比特流进行扫描。发现5个连续1时，删除后面的0。</li></ol><p><strong>优点：保证了透明传输，在传送的比特流中可以传送任意比特组合，而不会引起对帧边界的判断错误。</strong></p><p><strong>违规编码法</strong></p><p><img src="/../img/computer/%E8%BF%9D%E8%A7%84%E7%BC%96%E7%A0%81%E6%B3%95.png" alt="违规编码法"></p><p>曼彻斯特编码中可以用高-低电平表示1，用低-高电平表示0，所以在传输数据时，源数据不会出现高-高或低-低电平。<br>可以用”高-高”，”低-低”来定界帧的起始和终止。</p><blockquote><p>由于字节计数法中Count字段的脆弱性（其值若有差错将导致灾难性的后果）及字符填充法实现上的复杂性和不兼容性，<br>目前较普遍使用的帧同步法是<strong>零比特填充</strong>和<strong>违规编码法</strong>。</p></blockquote><h3 id="差错控制（检错编码、纠错编码）"><a href="#差错控制（检错编码、纠错编码）" class="headerlink" title="差错控制（检错编码、纠错编码）"></a>差错控制（检错编码、纠错编码）</h3><h4 id="检错编码——奇偶检验码"><a href="#检错编码——奇偶检验码" class="headerlink" title="检错编码——奇偶检验码"></a>检错编码——奇偶检验码</h4><blockquote><p>奇偶校验码包含n-1为信息元和1位校验元。如果是奇校验：信息元+校验元中1的个数为奇数个，<br>如果是偶校验：信息元+校验元中1的个数是偶数个。</p></blockquote><p>奇偶校验码特点：</p><p>只能检查出奇数个比特错误，交错能力为50%。</p><p>当数据中有偶数个位发生0-1的置换，就不能检查出来。</p><h4 id="检错编码——CRC循环冗余码"><a href="#检错编码——CRC循环冗余码" class="headerlink" title="检错编码——CRC循环冗余码"></a>检错编码——CRC循环冗余码</h4><p>采用CRC循环冗余码时，最终发送的数据为源数据+帧校验序列FCS(冗余码)</p><p>冗余码的计算：</p><ol><li>加0。假设生成多项式G(x)的阶为r，则加r个0。</li><li>模2除法。数据加0后除以多项式，余数为冗余码FCS——CRC检验码的比特序列。</li></ol><p>Tips：多项式为N位，阶位N-1。</p><p><img src="/../img/computer/%E8%AE%A1%E7%AE%97FCS.png"></p><p>接收端检错过程：</p><p>把收到的每一帧都除以相同的除数，然后检查得到的余数R。</p><ol><li>余数为0，判定这个帧没有差错，则接收</li><li>余数不为0，判定这个帧有差错（无法确定到位），丢弃。</li></ol><p>FCS的生成以及接收端CRC检验都是由硬件实现，处理很迅速，因此不会延误数据的传输。</p><p>在数据链路层仅仅使用循环冗余检验CRC差错检测技术，只能做到对帧的无差错接收，<br>即”凡事接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生<br>差错”。接收端丢弃的帧虽然曾收到了，但是最终还是因为有差错被丢弃。**”凡是接收端数据链路层接收的帧均可以以非常<br>接近1的概率认为无差错”。**</p><h4 id="纠错编码——海明码（汉明码）"><a href="#纠错编码——海明码（汉明码）" class="headerlink" title="纠错编码——海明码（汉明码）"></a>纠错编码——海明码（汉明码）</h4><blockquote><p>海明码: 发现双比特错，纠正单比特错。</p></blockquote><p>海明码的工作流程：</p><ol><li>确定校验码位数r</li></ol><p>海明不等式：2^r &gt;&#x3D; k+r+1   r为冗余信息位，k为信息位。</p><p>eg：要发送的数据：D&#x3D;101101</p><p>数据的位数k&#x3D;6，满足不等式的最小r为4，也就是D&#x3D;101101的海明码应该有6+4&#x3D;10位，其中源数据6位，校验码4位。</p><ol start="2"><li>确定校验码和数据的位置</li></ol><p><img src="/../img/computer/%E7%A1%AE%E5%AE%9A%E6%A0%A1%E9%AA%8C%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%8D%E7%BD%AE.png" alt="确定校验码和数据的位置"></p><ol start="3"><li>求出校验码的值</li></ol><p><img src="/../img/computer/%E6%B5%B7%E6%98%8E%E7%A0%811.png" alt="求出校验码的值"></p><ol start="4"><li>检错并纠错</li></ol><p><img src="/../img/computer/%E6%B5%B7%E6%98%8E%E7%A0%812.png" alt="检错并纠错"></p><h3 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h3><blockquote><p>较高的发送速度和较低的接收能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。 </p></blockquote><p>数据链路层的流量控制是点对点的，而传输层的流量控制是端对端的。</p><p>数据链路层流量控制手段：接收方收不下就不回复确认。</p><p>传输层流量控制手段：接收端给发送端一个窗口公告。</p><h4 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h4><p><img src="/../img/computer/%E5%81%9C%E6%AD%A2-%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE.png" alt="停止-等待协议"></p><p>每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧。</p><ol><li>为什么要有停止-等待协议？</li></ol><p>除了比特出差错，底层信道还会出现丢包问题。为了实现流量控制。</p><ol start="2"><li>研究停等协议的前提？</li></ol><p>因为是在讨论可靠传输的原理，所以并不考虑数据是在哪一个层次上传送的。<br>“停止-等待”就是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。</p><blockquote><p>丢包：物理线路故障、设备故障、病毒攻击、路由信息错误等原因，会导致数据包的丢失。</p></blockquote><p><strong>停等协议——无差错情况</strong></p><p><img src="/../img/computer/%E6%97%A0%E5%B7%AE%E9%94%99%E6%83%85%E5%86%B5.png" alt="无差错情况"></p><p><strong>停等协议——有差错情况</strong></p><p>数据帧丢失或检测到帧出错</p><p><img src="/../img/computer/%E6%95%B0%E6%8D%AE%E5%B8%A7%E4%B8%A2%E5%A4%B1.png" alt="数据帧丢失"></p><p>ack丢失</p><p><img src="/../img/computer/ack%E4%B8%A2%E5%A4%B1.png" alt="ack丢失"></p><p>ack迟到</p><p><img src="/../img/computer/ack%E8%BF%9F%E5%88%B0.png" alt="ack迟到"></p><p><strong>信道利用率</strong></p><p>发送发在一个发送周期内，有效的发送数据所需要的时间占整个发送周期的比率。</p><p>信道利用率&#x3D;(L&#x2F;C)&#x2F;T</p><blockquote><p>L：T内发送L比特数据。C：发送方数据传输率。T：发送周期，从开始发送数据，到接收到第一个确认帧为止。</p></blockquote><p><strong>信道吞吐率&#x3D;信道利用率*发送发的发送速率</strong></p><h4 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h4><h5 id="后退N帧协议（GBN）"><a href="#后退N帧协议（GBN）" class="headerlink" title="后退N帧协议（GBN）"></a>后退N帧协议（GBN）</h5><p>GBN发送发必须响应的三件事：</p><ol><li>上层的调用</li></ol><p>上层要发送数据时，发送方先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送；如果窗口已满<br>，发送方只需将数据返回给上层，暗示上层窗口已满。上层等一会再发送。（实际实现中，发送发可以缓存这些<br>数据，窗口不满时再发送帧）。</p><ol start="2"><li>收到了一个ACK</li></ol><p>GBN协议中，对n号帧的确认采用累计确认的方式，标明接收方已经收到n号帧和它之前的全部帧。</p><ol start="3"><li>超时事件</li></ol><p>协议的名字为后退N帧&#x2F;回退N帧，来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样，<br>定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已发送但未被确认的帧。</p><p>GBN接收方要做的事：</p><p>如果正确收到n号帧，并且按序，那么接收方为n帧发送一个ack，并将该帧中的数据部分交付给上层。</p><p>其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK。接收方无需缓存任何失序帧，只需要维护一个信息：<br>expectedseqnum(下一个按序接收的帧序号)。</p><p>运行中的GBN:</p><p><img src="/../img/computer/%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84GBN.png" alt="运行中的GBN"></p><p>优点：因连续发送数据帧而提高了信道利用率</p><p>缺点：在重传时必须把原来已经正确传送的数据帧重传，使传送效率降低。</p><h5 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a>选择重传协议（SR）</h5><p><strong>SR中的滑动窗口机制</strong></p><p><img src="/../img/computer/SR%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6.png" alt="SR滑动窗口机制"></p><p><strong>发送方必须响应的三件事</strong></p><ul><li>上层调用</li></ul><p>从上层收到数据后，SR发送发检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧；<br>否则就像GNB一样，要么将数据缓存，要么返回给上层之后在传输。</p><ul><li>收到一个ACK</li></ul><p>如果收到ACK，加入该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接受。如果该帧序号是窗口<br>的下界(最左边第一个窗口对应的序号)，则窗口想前移动到具有最小序号的未确认帧处。如果窗口移动了<br>并且有序号在窗口内的未发送帧，则发送这些帧。</p><ul><li>超时事件</li></ul><p>每个帧都有自己的定时器，一个超时事件发生后只重传一个帧。</p><p><strong>接收方要做的事</strong></p><p>SR接收方将确认一个正确接受的帧而不管其是否按序。失序的帧将被缓存，并返回给发送方一个该帧<br>的确认帧【收谁确认谁】，直到所有帧(即序号更小的帧)皆被收到为止，这是才可以将一批帧按序交付给<br>上层，然后向前移动滑动窗口。</p><p><strong>运行中的SR</strong></p><p><img src="/../img/computer/%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84SR.png" alt="运行中的SR"></p><p><strong>窗口大小的上限</strong></p><p>发送窗口最好等于接收窗口</p><p>WTMax&#x3D;WRMax&#x3D;2^(n-1)</p><blockquote><p>WTMax 发送窗口，WRMax 接收窗口，n 表示用多少个比特标帧序号。eg：n&#x3D;2，序号就有 0 1 2 3</p></blockquote><h3 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h3><p>点对点链路：两个相邻结点通过一个链路相连，没有第三者。应用：PPP协议，常用语<strong>广域网</strong>。</p><p>广播式链路：所有主机共享通信介质。应用：早起的总线以太网、无线局域网、常用于<strong>局域网</strong>。<br>典型拓扑结构：总线型，星型（逻辑总线型）</p><h4 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h4><blockquote><p>介质访问控制的内容是采取一定的措施，使得两对结点之间的通信不会发生互相干扰的情况。</p></blockquote><p>静态划分信道——信道划分介质访问控制</p><blockquote><p>信道划分介质访问控制：将使用介质的每个设备与来自同一信道上的其它设备的通信隔离开，把时域和频域<br>资源合理地分配给网络上的设备。</p></blockquote><p><strong>频分多路复用 FDM</strong></p><p>用户分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽<br>（频率带宽）资源。</p><p>充分利用传输介质带宽，系统效率提高；由于技术比较成熟，实现也比较容易。</p><p><strong>时分多路复用 TDM</strong></p><p>将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，所有<br>用户轮流占用信道。</p><p><strong>波分多路复用 WDM</strong></p><p>波分多路复用就是光的频分多路复用，在一根光纤中传输多种不同波长（频率）的光信号，由于波长（频率）不同，<br>所以各路光信号互不干扰，最后在用波长分解复用器将各路波长分解出来。</p><p><strong>码分多路复用 CDM</strong></p><p>码分多址（CDMA）是码分复用的一种方式。</p><p>1比特分为多个码片&#x2F;芯片（chip），每一站点被指定一个唯一的m位的芯片序列。发送1时站点发送芯片序列，<br>发送0时发送芯片序列反码（通常把0写成-1）。</p><p>如何不打架：多个站点同时发送数据的时候，要求各个站点芯片序列相互正交。</p><p>如何合并：各路数据在信道中被线性相加。</p><p>如何分离：合并的数据和源站规格化内积。</p><p><strong>动态分配信道——随机访问介质访问控制</strong></p><p>ALOHA协议</p><p>纯ALOHA协议思想：不监听信道，不按时间槽发送，随机重发。如果发生冲突，接收方在就会检测出差错，<br>然后不予确认，发送发在一定时间内收不到就会判断发生冲突。超时后等一随机时间再重传。</p><p>时隙ALOHA协议</p><p>时隙ALOHA协议的思想：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，<br>若发生冲突，则必须等到下一个时间片开始时刻再发送。</p><p>CSMA协议（载波监听多路访问协议）</p><blockquote><p>CS：载波监听，每一个站在发送数据之前都要检测一下总线上是否有其他计算机再发送数据。（当几个站同时在<br>总线上发送数据时，总线上的信号电压摆动值将会增大。当一个站监测到的信号电压摆动值超过一定门限值时，就认为总线上<br>至少有两个站同时再发送数据，标明产生了碰撞，即发生了冲突。）</p></blockquote><blockquote><p>MA：多点接入，表示许多计算机一多点接入的方式连接在一根总线上。</p></blockquote><p><strong>1-坚持CSMA</strong></p><p>坚持指的是对于监听信道忙之后的坚持。</p><p>1-坚持CSMA思想：如果一个主机要发送消息，那么他先监听信道。空闲则直接传输，不必等待。忙则一直监听，知道空闲马上传输。<br>如果有冲突（一段时间内未收到肯定回复），则等待一个随机长的时间再监听，重复上述过程。</p><p>优点：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。</p><p>缺点：假如有两个或两个以上的站点有数据要发送，冲突就不可避免。</p><p><strong>非坚持CSMA</strong></p><p>非坚持指的是对于监听信道忙之后就不继续监听。</p><p>非坚持CSMA思想：如果一个主机要发送消息，那么他先监听信道。空闲则直接传输，不必等待。忙则等待一个随机的时间之后再进行监听。</p><p>优点：采用随机的重发延迟时间可以肩上冲突发生的可能性。</p><p>缺点：可能存在大家都在延迟等待过程，使得媒体仍可能处于空闲状态，媒体使用率降低。</p><p><strong>p-坚持CAMS</strong></p><p>p-坚持指的是对于监听信道空闲的处理。</p><p>p-坚持CSMA思想：如果一个主机要发送消息，那么他先监听信道。空闲则以p概率直接传输，不必等待；概率1-p等待到下一个时间槽再传输。<br>忙则等待一个随机的时间之后在进行监听。</p><p>优点：既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间的这种方案。</p><p>缺点：发生冲突后还是要坚持把数据帧发送完，造成了浪费。</p><p>三种CSMA对比</p><table><thead><tr><th align="center"></th><th align="center">1-坚持CSMA</th><th align="center">非坚持CSMA</th><th align="center">p-坚持CSMA</th></tr></thead><tbody><tr><td align="center">信道空闲</td><td align="center">马上发</td><td align="center">马上发</td><td align="center">p概率马上发，1-p概率等到下一个时隙再发送</td></tr><tr><td align="center">信道忙</td><td align="center">继续坚持监听</td><td align="center">放弃监听，等待一个随机时间再监听</td><td align="center">放弃监听，等待一个随机时间再监听</td></tr></tbody></table><p><strong>动态分配信道——论序访问介质访问控制</strong></p><p>令牌传递协议</p><p>令牌：一个特俗格式的MAC控制帧，不含任何信息。控制信道的使用，确保同一时刻只有一个结点独占信道。每个结点都可以在一定的时间<br>内（令牌持有时间）获得发送数据的权利，比不是无限之地持有令牌。</p><p>缺点：</p><p>存在令牌开销、等待延迟、单点故障</p><blockquote><p>应用于令牌环网（物理星型拓扑，逻辑环形拓扑）<br>采用令牌传送方式的网络常用于负载较重、通信量较大的网络中。</p></blockquote><p><strong>CSMA&#x2F;CA协议</strong>（载波监听多点接入&#x2F;碰撞避免）</p><p>发送数据前，先检测信道是否空闲。</p><p>空闲则发出RTS（request to send），RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息；信道忙则等待。</p><p>接收端收到RTS后，将响应CTS（clear to send）。</p><p>发送端收到CTS后，开始发送数据帧（同时预约信道：发送发告知其他站点自己要传多久数据）。</p><p>接收端收到数据帧后，江永CRC来检验数据是否正确，正确则响应ACK帧。</p><p>发送方收到ACK就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止（采用二进制指数退避算法来确定随机的推迟时间）。</p><h3 id="局域网基本概念和体系结构"><a href="#局域网基本概念和体系结构" class="headerlink" title="局域网基本概念和体系结构"></a>局域网基本概念和体系结构</h3><p>局域网（Local Area Network）：简称LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道。</p><p>特点1：覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</p><p>特点2：使用专门铺设的传输介质（双绞线、同轴电缆）进行联网，数据传输速率高（10Mb&#x2F;s～10Gb&#x2F;s）。</p><p>特点3：通信延迟时间短，误码率低，可靠性较高。</p><p>特点4：各站为平等关系，共享传输信道。</p><p>特点5：多采用分布式控制和广播式通信，能进行广播和组播。</p><p>决定局域网的主要要素为：<strong>网络拓扑</strong>，<strong>传输介质</strong>与<strong>介质访问控制方法</strong>。</p><h4 id="局域网拓扑结构"><a href="#局域网拓扑结构" class="headerlink" title="局域网拓扑结构"></a>局域网拓扑结构</h4><p><strong>星型拓扑</strong></p><p><img src="/../img/computer/%E6%98%9F%E5%9E%8B%E6%8B%93%E6%89%91.png" alt="星型拓扑"></p><p>中心节点是控制中心，任意两个节点间的通信最多只需两步，传输速度快，并且网络构型简单、建网容易、便于控制和管理。但这种网络<br>系统，网络可靠性低，网络共享能力差，有单点故障问题。</p><p><strong>总线型</strong></p><p><img src="/../img/computer/%E6%80%BB%E7%BA%BF%E5%9E%8B%E6%8B%93%E6%89%91.png" alt="总线型拓扑"></p><p>网络可靠性高、网络节点间响应速度快、共享资源能力强、设备投入量少、成本低、安装使用方便，当某个工作站节点出现故障时，对整个<br>网络系统影响小。</p><p><strong>环型拓扑</strong></p><p><img src="/../img/computer/%E7%8E%AF%E5%9E%8B%E6%8B%93%E6%89%91.png" alt="环形拓扑"></p><p>系统中通信设备和线路比较节省。有单点故障问题；由于环路是封闭的，所以不便于扩充，系统响应延时长，且信息传输效率相对较低。</p><p><strong>树型拓扑</strong></p><p><img src="/../img/computer/%E6%A0%91%E5%9E%8B%E6%8B%93%E6%89%91.png" alt="树型拓扑"></p><p>易于拓展，易于隔离故障，也容易有单点故障。</p><h4 id="局域网的分类"><a href="#局域网的分类" class="headerlink" title="局域网的分类"></a>局域网的分类</h4><ol><li>以太网：以太网是应用最为广泛的局域网，包括标准以太网（10Mbps）、快速以太网（100Mbps）、千兆以太网（1000Mbps）和10G以太网，<br>他们都符合IEEE 802.3系列标准规范。逻辑拓扑总线型，物理拓扑是星型或拓展星型。使用CSMA&#x2F;CD。</li><li>令牌环网：物理上采用了星型拓扑结构，逻辑上是环形拓扑结构。已是”明日黄花”。</li><li>FDDI（Fiber Distributed Data Interface）：物理上采用了双环形拓扑结构，逻辑上是环形拓扑结构。</li><li>ATM（Asynchronous Transfer Mode）：较新型的单元交换技术，使用53字节固定长度的单元进行交换。</li><li>无线局域网（Wireless Local Area Network；WLAN）：采用IEEE 802.11标准。</li></ol><blockquote><p>IEEE 802系列标准是IEEE 802 LAN&#x2F;MAN标准委员会制定的局域网、城域网技术标准（1980年2月成立）。其中最广泛使用的有以太网、令牌环、<br>无线局域网等。这一系列标准中的每一个子标准都由委员会中的一个专门工作组负责。</p></blockquote><h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><p>由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带总线局域网规范，是当今现有局域网采用的最通用的通信协议标准。<br>以太网使用CSMA&#x2F;CD（载波监听多路访问及冲突检测）技术。</p><p>以太网在局域网各种技术中占统治性地位：</p><ol><li>造价低廉</li><li>是应用最广泛的局域网技术；</li><li>比令牌环网、ATM网便宜，简单；</li><li>满足网络速率要求：10Mb&#x2F;s～10Gb&#x2F;s。</li></ol><p>计算机与外界有局域网的连接是通过通信适配器的。</p><p><img src="/../img/computer/%E9%80%9A%E4%BF%A1%E9%80%82%E9%85%8D%E5%99%A8.png" alt="通信适配器"></p><p>在局域网中，硬件地址又称为物理地址，或MAC地址。【实际上是标识符】</p><blockquote><p>MAC地址：每个适配器又一个全球唯一的48位2进制地址，前24位代表厂家（由IEEE规定），后24位厂家自己制定。常用6个16进制数表述，<br>如02-60-8c-e4-b1-21。</p></blockquote><p><img src="/../img/computer/MAC%E5%B8%A7.png" alt="MAC帧"></p><h4 id="CSMA-x2F-CD协议（载波监听多点接入-x2F-碰撞检测）"><a href="#CSMA-x2F-CD协议（载波监听多点接入-x2F-碰撞检测）" class="headerlink" title="CSMA&#x2F;CD协议（载波监听多点接入&#x2F;碰撞检测）"></a>CSMA&#x2F;CD协议（载波监听多点接入&#x2F;碰撞检测）</h4><blockquote><p>CS：载波监听，每一个站在发送数据之前以及发送数据时都要检测一下总线上是否有其他计算机在发送数据。</p></blockquote><blockquote><p>MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。（总线型网络）</p></blockquote><blockquote><p>CD：碰撞检测（冲突检测），”边发送边监听”，适配器发送数据边检测信道上信号的变化情况，以便判断自己在发送数据时其它站是否也在发送数据。</p></blockquote><p>确定碰撞后的重传时机（截断二进制指数归避算法）：</p><ol><li>确定基本退避（推迟）时间为争用期2𝞃。</li><li>定义参数k，它等于重传次数，但k不超过10，即k&#x3D;min[重传次数，10]。当重传次数不超过10时，k等于重传次数；当重传次数大于10时，<br>k就不再增大而一直等于10。</li><li>从离散的整数集合[0,1,2^k-1]中随机取出一个数r，重传所需要退避的时间就是r倍的基本退避时间，即2r𝞃。</li><li>当重传达16次仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错。<br>第一次重传，k&#x3D;1，r从{0,1}选；重传推迟时间为0或2𝞃，在这两个时间中随机选一个；若再次碰撞，则在第二次重传时，<br>k&#x3D;2，r从{0，1，2，3}选；重传推迟时间为0或2𝞃或4𝞃或6𝞃，在这四个时间中随机选一个；若再次碰撞，则第三次重传时，k&#x3D;3，r从{0,1,2,3,4,5,6,7}选……</li></ol><p>最小帧长</p><p>真的传输时延至少要两倍于信号在总线中的传播时延。</p><p>帧长（bit）&#x2F;数据传输速率≥2𝞃</p><p>最小帧长&#x3D;总线传播时延×数据传输速率×2，也就是2𝞃 × 数据传输速率</p><h3 id="PPP协议和HDLC协议"><a href="#PPP协议和HDLC协议" class="headerlink" title="PPP协议和HDLC协议"></a>PPP协议和HDLC协议</h3><p><strong>PPP（point to point）</strong></p><p>点对点协议是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都是用ppp协议。只支持全双工链路。</p><p>ppp协议帧格式</p><p><img src="/../img/computer/ppp%E5%8D%8F%E8%AE%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="ppp协议帧格式"></p><p><strong>HDLC协议（高级数据链路控制High——Level Data Link Control）</strong></p><p>高级数据链路控制是一个在同步网上传输数据、面向比特的数据链路高层协议，它是由国际标准化组织ISO根据IBM<br>公司的SDLC（SynchronousData Link Control）协议扩展开发而成的。数据报文可透明传输，用于实现透明传输的”0比特插入法”易于硬件实现。</p><p>HDLC帧格式</p><p><img src="/../img/computer/HDLC%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="HDLC帧格式"></p><ol><li>信息帧（I）第1为为0，用来传输数据信息，或使用捎带技术对数据逆行确认；</li><li>监督帧（S）10，用于流量控制和差错控制，执行对信息帧的确认、请求重发和请求暂停发送等功能</li><li>无编号帧（U）11，用于提供对链路的建立、拆除等多种控制功能。</li></ol><p><strong>ppp和HDLC比较</strong>：</p><ul><li>都支持全双工链路</li><li>都可以实现透明传输</li><li>都可以实现差错检测，但不纠正差错</li></ul><table><thead><tr><th align="center">PPP协议</th><th align="center">面向字节</th><th align="center">2B协议字段</th><th align="center">无序号和确认机制</th><th align="center">不可靠</th></tr></thead><tbody><tr><td align="center">HDLC协议</td><td align="center">面向比特</td><td align="center">没有</td><td align="center">有编号和确认</td><td align="center">可靠</td></tr></tbody></table><h2 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h2><blockquote><p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报。</p></blockquote><p>功能：</p><ol><li>路由选择与分组转发</li><li>异构网络互联</li><li>拥塞控制</li></ol><h3 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h3><p><strong>电路交换</strong></p><p>建立连接（呼叫&#x2F;电路建立）-&gt; 通信 -&gt; 释放连接（拆除电路）</p><p>优点：</p><ul><li>通信时延小</li><li>有序传输</li><li>没有冲突（独占资源）</li><li>实时性强</li></ul><p>缺点：</p><ul><li>建立连接时间长</li><li>线路独占、使用效率低</li><li>灵活性差</li><li>无差错控制能力</li></ul><p><strong>报文交换</strong></p><blockquote><p>报文：源应用发送的信息整体。</p></blockquote><p>优点：</p><ul><li>无需建立连接</li><li>存储转发，动态分配线路</li><li>线路可靠性较高</li><li>线路利用率较高</li><li>多目标服务</li></ul><p>缺点：</p><ul><li>有存储转发时延</li><li>报文大小不定，需要网络节点有较大缓存空间</li></ul><p><strong>分组交换</strong></p><blockquote><p>分组：把大的数据块分割成小的数据块</p></blockquote><p>优点：</p><ul><li>无需建立连接</li><li>存储转发，动态分配线路</li><li>线路可靠性较高</li><li>线路利用率较高</li><li>相对于报文交换，存储管理更容易</li></ul><p>缺点：</p><ul><li>有存储转发时延</li><li>需要传输额外的信息量</li><li>乱序到目的主机时，要对分组排序重组</li></ul><p><img src="/../img/computer/%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F.png" alt="三种交换方式"></p><ol><li>报文交换和分组交换采用存储转发。</li><li>传送数据量大，且传送时间远大于呼叫时，选择电路交换。电路交换传输时延最小。</li><li>从信道利用率看，报文交换和分组交换由于电路交换，其中分组交换时延更小。</li></ol><p><strong>数据报方式</strong></p><p>为网络层提供无连接服务。</p><blockquote><p>不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</p></blockquote><p><strong>虚电路方式</strong></p><p>为网络层提供连接服务。</p><blockquote><p>首先为分组的传输确定传输路径（建立连接），然后沿该路径（连接）传输系列分组，系列分组传输路径相同，传输结束后拆除连接。</p></blockquote><p><img src="/../img/computer/%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%92%8C%E8%99%9A%E7%94%B5%E8%B7%AF.png" alt="数据报和虚电路"></p><h3 id="路由算法与路由协议概述"><a href="#路由算法与路由协议概述" class="headerlink" title="路由算法与路由协议概述"></a>路由算法与路由协议概述</h3><ul><li>静态路由算法（非自适应路由算法）</li></ul><p>管理员手工配置路由信息，简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和较小的商业网络。<br>缺点是路由更新慢，不适用于大型网络。</p><ul><li>动态路由算法（自适应路由算法）</li></ul><p>路由器间彼此交换信息，按照路由算法优化出路由表项。路由更新快，适用于大型网络，即使响应链路费用或网络拓扑变化。缺点：<br>算法复杂，增加网络负担。</p><p><strong>分层次的路由选择协议</strong></p><p>自治系统AS：在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量已确定分组在该AS内的路由，<br>同时还是用一种AS之间的路由协议已确定在AS之间的路由。一个AS内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器<br>在本自治系统内都必须连通。</p><h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><p><img src="/../img/computer/ip%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="IP数据报格式"></p><ul><li>版本：IPv4&#x2F;IPv6</li><li>首部长度：单位是4B，最小为5。</li><li>区分服务：指示期望获得哪种类型的服务。</li><li>总长度：首部+数据，单位是1B。</li><li>标志：只有2为有意义 x _ _<ul><li>中间位DF(Dont Fragment)：DF&#x3D;1，禁止分片；DF&#x3D;0，允许分片</li><li>最低位MF(More Fragment)：MF&#x3D;1，后面”还有分片”；MF&#x3D;0，代表最后一片&#x2F;没分片。</li></ul></li><li>生存时间（TTL）：IP分组的保质期。经过一个路由器-1，变成0则丢弃。</li><li>协议：数据部分的协议。</li><li>首部检验和：只检验首部。</li><li>可选字段：0～40B，用来支持排错、测量以及安全措施。</li><li>填充：全0，把首部补成4B的整数倍。</li></ul><h3 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h3><p> IP地址:全世界唯一的32位&#x2F;4字符标识符,表示路由器主机的接口。</p><p>IP地址::&#x3D;{&lt;网络号&gt;&lt;主机号&gt;}</p><p>eg：11011111 00000001 00000001 00000001 &#x3D; 223.1.1.1</p><p>分类的IP地址：</p><p><img src="/../img/computer/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png" alt="IP地址分类"></p><table><thead><tr><th align="center">网络类别</th><th align="center">最大可用网络数</th><th align="center">第一个可用的网络号</th><th align="center">最后一个可用的网络号</th><th align="center">每个网络中的最大主机数</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">2<sup>7</sup>-2</td><td align="center">1</td><td align="center">126</td><td align="center">2<sup>24</sup>-2</td></tr><tr><td align="center">B</td><td align="center">2<sup>14</sup>-1</td><td align="center">128.1</td><td align="center">191.255</td><td align="center">2<sup>16</sup>-2</td></tr><tr><td align="center">C</td><td align="center">2<sup>21</sup>-1</td><td align="center">192.0.1</td><td align="center">223.255.255</td><td align="center">2<sup>8</sup>-2</td></tr></tbody></table><p>特殊IP地址：</p><table><thead><tr><th align="center">NetID 网络号</th><th align="center">HostID 主机号</th><th align="center">作为IP分组源地址</th><th align="center">作为IP分组目的地址</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">全0</td><td align="center">全0</td><td align="center">可以</td><td align="center">不可以</td><td align="center">本网范围内表示主机，路由表中用于表示默认路由(表示整个Internet网络)</td></tr><tr><td align="center">全0</td><td align="center">特定值</td><td align="center">不可以</td><td align="center">可以</td><td align="center">表示本网内某个特定主机</td></tr><tr><td align="center">全1</td><td align="center">全1</td><td align="center">不可以</td><td align="center">可以</td><td align="center">本网广播地址(路由器不转发)</td></tr><tr><td align="center">特定值</td><td align="center">全0</td><td align="center">不可以</td><td align="center">不可以</td><td align="center">网络地址，表示一个网络</td></tr><tr><td align="center">特定值</td><td align="center">全1</td><td align="center">不可以</td><td align="center">可以</td><td align="center">直接广播地址，对特定网络上的所有主机进行广播</td></tr><tr><td align="center">127</td><td align="center">任何数(非全0&#x2F;1)</td><td align="center">可以</td><td align="center">可以</td><td align="center">用于本地软件环回测试，称为环回地址</td></tr></tbody></table><p>私有IP地址：</p><table><thead><tr><th align="center">地址类别</th><th align="center">地址范围</th><th align="center">网段个数</th></tr></thead><tbody><tr><td align="center">A类</td><td align="center">10.0.0.0~10.255.255.255</td><td align="center">1</td></tr><tr><td align="center">B类</td><td align="center">172.16.0.0~172.31.255.255</td><td align="center">16</td></tr><tr><td align="center">C类</td><td align="center">192.168.0.0~192.168.255.255</td><td align="center">256</td></tr></tbody></table><p>ps：路由器对目的地址是私有IP地址的数据报一律不进行转发。</p><h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3><p> 网络地址转换NAT(Network Address Translation): 在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址。</p><p><img src="/../img/computer/nat.png" alt="NAT"></p><p>假如主机A要发送消息给主机B，A在封装数据报时，源地址和端口就是主机A的，目的地址是主机B的地址，当数据报到达NAT路由器时，会将数据报里的源地址和端口号修改为NAT路由器自己的地址和端口号，这个数据报此时就能够在因特网中进行传输了。</p><p>当主机B给主机C发送消息，主机B封装数据报时，目的地址和端口就是NAT路由器的地址和端口号，当数据报到达路由器时，会按照NAT转换表将目的地址和端口号替换为主机C的。</p><h3 id="子网划分和子网掩码"><a href="#子网划分和子网掩码" class="headerlink" title="子网划分和子网掩码"></a>子网划分和子网掩码</h3><p><img src="/../img/computer/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86.png" alt="子网划分"></p><p>子网掩码：网络号（子网号）全1，主机号全零</p><h3 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h3><ul><li>消除了传统的A类、B类和C类地址以及划分子网的概念。</li></ul><p><img src="/../img/computer/CIDR.png" alt="CIDR"></p><p>CIDR记法：IP地址后加上“&#x2F;”，然后写上网络前缀（可以任意长度）的位数。eg：128.14.32.0&#x2F;20</p><ul><li>融合子网掩码，方便子网划分。</li></ul><p>CIDR把网络前缀都相同的连续的IP地址组成一个”CIDR地址块“。</p><p>128.14.35.7&#x2F;20是某CIDR地址块中的一个地址</p><p>​    二进制：10000000 00001110 00100011 00000111</p><p>最小地址：10000000 00001110 00100000 00000000</p><p>最大地址：10000000 00001110 00101111 11111111</p><p>​    地址块：128.14.32.0&#x2F;20          ”&#x2F;20地址块“ </p><p>子网掩码：11111111 11111111 11110000 00000000</p><h4 id="构成超网"><a href="#构成超网" class="headerlink" title="构成超网"></a><strong>构成超网</strong></h4><p>将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合。</p><p>方法：将网络前缀缩短。</p><p>eg：网络1：206.1.0.0&#x2F;17；网络2：206.1.128.0&#x2F;17。将两个网络聚合成一个网络。</p><p>网络1:</p><p>二进制：11001101 00000001 00000000 00000000</p><p>掩    码：11111111 11111110 00000000 00000000</p><p>网络2:</p><p>二进制：11001101 00000001 10000000 00000000</p><p>掩    码：11111111 11111110 00000000 00000000</p><p>聚合之后的网络：206.1.0.0&#x2F;16。</p><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>由于在实际网络的链路上传送数据帧时，最终必须使用mac地址。</p><p>ARP协议：完成主机或路由器IP地址到MAC地址的映射。</p><p>ARP协议使用过程：</p><p>检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求，同一局域网中所有主机都能收到该请求。目的主机收到请求后就会像源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存（10-20min更新一次）。</p><p>ARP协议4种典型情况：</p><ol><li>主机A发给本网络上的主机B：用ARP找到主机B的硬件地址；</li><li>主机A发给另一网络上的主机B：用ARP找到本网络上一个路由器（网关）的硬件地址；</li><li>路由器发给本网络的主机A：用ARP找到主机A的硬件地址；</li><li>路由器发给另一网络的主机B：用ARP找到本网络上的一个路由器的 硬件地址。</li></ol><p><strong>ARP协议自动进行</strong></p><h3 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3><p>动态主机配置协议DHCP是应用层协议，使用客户&#x2F;服务器方式，客户端和服务端通过广播方式进行交互，基于UDP。DHCP提供即插即用联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址，允许地址重用，支持移动用户加入网络，支持在用地址续租。</p><ol><li>主机广播DHCP发现报文（试图找到网络中的服务器，服务器获得一个IP地址）</li><li>DHCP服务器广播DHCP提供报文（服务器拟分配给主机一个IP地址及相关配置，先到先得）</li><li>主机广播DHCP请求报文（主机想服务器请求提供IP地址）</li><li>DHCP服务器广播DHCP确认报文（正式将IP地址分配给主机）</li></ol><h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p><img src="/../img/computer/%E7%BD%91%E7%BB%9C%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AEICMP.png" alt="网络控制报文协议ICMP"></p><p><strong>ICMP差错报告报文</strong>：</p><ol><li>终点不可达：当路由器或主机不能交付数据报时就像源点发送终点不可达报文。</li><li>源点抑制：当路由器或主机由于拥塞而迭起数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。</li><li>时间超过：当路由器收到生存时间TTL&#x3D;0的数据报时，除丢弃该数据外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li><li>参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。</li><li>改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</li></ol><p><strong>ICMP差错报告报文数据字段</strong></p><p><img src="/../img/computer/ICMP%E5%B7%AE%E9%94%99%E6%8A%A5%E5%91%8A%E6%8A%A5%E6%96%87%E6%95%B0%E6%8D%AE%E5%AD%97%E6%AE%B5.png" alt="ICMP差错报告报文数据字段"></p><p><strong>不应发送ICMP差错报文的情况</strong>：</p><ol><li>对ICMP差错报告报文不在发送ICMP差错报告报文。</li><li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。</li><li>对具有组播地址的数据报都不发送ICMP差错报告报文。</li><li>对具有特俗地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文。</li></ol><p><strong>ICMP询问报文</strong>：</p><ol><li>回送请求和回答报文：主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。测试目的站是否可达以及了解其相关状态。</li><li>时间戳请求和回答报文：请某个主机或路由器回答当前的日期和时间。用来进行时钟同步和测量时间。</li><li><del>掩码地址请求和回答报文</del></li><li><del>路由器询问和通告报文</del></li></ol><p><strong>ICMP的应用</strong></p><p>PING：测试两个主机之间的连通性，使用了ICMP回送请求和回答报文。</p><p>Traceroute：跟踪一个分组从源点到终点的路径，使用了ICMP时间超过差错报告报文。</p><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><blockquote><p>IPv6从根本上决解地址耗尽问题。方法：改进首部格式；快速处理&#x2F;转发数据报；支持QoS。</p></blockquote><p><strong>IPv6出局报格式</strong></p><p><img src="/../img/computer/ipv6%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="IPv6数据报格式"></p><ul><li>版本致命了协议版本，总是6</li><li>优先级：区分数据报的类别和优先级</li><li>“流”是互联网上从特定源点到特定终点的一系列数据报。所有属于同一个流的数据报都具有同样的一个流的数据报都具有同样的流标签。</li><li>下一个首部：表示下一个扩展首部或上层协议首部。</li><li>条数限制：相当于IPv4的TTL</li></ul><p><strong>IPv6和IPv4</strong></p><ol><li>IPv6将地址从32位（4B）扩大到128位（16B），更大的地址空间。</li><li>IPv6将IPv4的<strong>校验和字段彻底移除</strong>，以减少每跳的处理时间。</li><li>IPv6将IPv4的可选字段移除首部，变成了扩展首部，称为灵活的首部格式，路由器通常不对扩展首部进行检查，大大提高了路由器的处理效率。</li><li>IPv6支持<strong>即插即用</strong>（即自动配置），不需要DHCP协议。</li><li>IPv6首部长度必须是<strong>8B的整数倍</strong>，IPv4首部是4B的整数倍。</li><li>IPv6<strong>只能在主机处分片</strong>，IPv4可以在路由器和主机处分片。</li><li>ICMPv6:附加报文类型“分组过大”。</li><li>IPv6支持资源的预分配，支持实时视像等要求，保证一定的带宽和时延的应用。</li><li>IPv6取消了协议字段，改成下一个首部字段。</li><li>IPv6取消了总长度字段，该用有效载荷长度字段。</li><li>IPv6取消了服务类型字段。</li></ol><p><strong>IPv6地址表示形式</strong></p><p>一般形式</p><p>冒号十六进制记法：4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170</p><p>压缩形式</p><p>4BF5:0000:0000:0000:BA5F:039A:000A:2176</p><p>4BF5:0:0:0:BA5F:39A:A:2176</p><p>零压缩：一连串连续的0可以被一对冒号取代。</p><p>FF05:0:0:0:0:0:0:B3</p><p>FF05::B3</p><blockquote><p><strong>双冒号表示法在一个地址种仅可以出现一次。</strong></p></blockquote><p><strong>IPv6基本地址类型</strong></p><p>单播：一对一通信，可做源地址+目的地址</p><p>多播：一对多通信，可做目的地址</p><p>任播：一对多中的一个通信，可做目的地址</p><p><strong>IPv6向IPv4过渡的策略</strong></p><ul><li>双栈协议</li></ul><p>双协议栈技术就是指在一台设备上同时启用IPv4协议栈和IPv6协议栈。这样的话，这台设备既能和IPv4网络通信，又能和IPv6网络通信。如果这台设备是一个路由器，那么这台路由器的不同接口上，分别配置了IPv4地址和IPv6地址，并很可能分别连接了IPv4网络和IPv6网络。如果这台设备是一个计算机，那么它将同时拥有IPv4地址和IPv6地址，并具备同时处理这两个协议地址的功能。</p><ul><li>隧道技术</li></ul><p>通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据（或负载）可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包重新封装然后通过隧道发送。</p><h3 id="RIP协议与距离向量算法"><a href="#RIP协议与距离向量算法" class="headerlink" title="RIP协议与距离向量算法"></a>RIP协议与距离向量算法</h3><p>RIP是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大优点是简单。</p><p>RIP协议要求网络中每一个路由器都维护从它自己到其它每一个目的网络的唯一最佳距离记录（即一组距离）。距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达。<strong>RIP协议只适用于小互联网</strong>。</p><p>RIP协议和谁交换？多久交换一次？交换什么？</p><ol><li>仅和相邻路由器交换信息。</li><li>路由器交换的信息是自己的路由表。</li><li>每30秒交换一次路由信息，只知道自己连接的网络的距离（距离为1），接着每一个路由器也只和数据非常有限的相邻路由器交换并更新路由信息。</li><li>经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短路径和下一跳路由器的地址，即“收敛”。</li></ol><p><strong>距离向量算法</strong></p><ol><li>修改相邻路由器发来的RIP报文中所由表项</li></ol><p>对地址为X的相邻路由器发来的RIP报文，修改此报文中的所有项目：把“下一跳”字段中的地址改为X，并把所有的”距离“字段+1</p><ol start="2"><li><p>对修改后的RIP报文中的每一个项目，进行一下步骤：</p><ol><li><p>R1路由表中若没有Net3，这把该项目填入R1</p></li><li><p>R1路由表中若没有Net3，则查看下一跳路由器地址：</p><p> 若下一跳是X，则用收到的项目替换源路由表中的项目；</p><p> 若下一跳不是X，原来距离比从X走的距离远则更新，否则不做处理。</p></li></ol></li><li><p>若180s还没收到相邻路由器X的更新路由表，则把X记为不可达的路由器，即把距离设置为16。</p></li><li><p>返回</p></li></ol><p><strong>RIP协议的报文格式</strong></p><p><img src="/../img/computer/RIP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="RIP协议的报文格式"></p><p>RIP的特点：当网络出现故障时，要经过比较长的时间（例如数分钟）才能将此信息传送到所有的路由器，“慢收敛”。</p><h3 id="OSPF协议与链路状态算法"><a href="#OSPF协议与链路状态算法" class="headerlink" title="OSPF协议与链路状态算法"></a>OSPF协议与链路状态算法</h3><p>开放最短路径优先OSPF协议：“开放”标明OSPF协议不是受某一家厂商控制，而是公开发表的；“最短路径优先”是因为使用了Dijkatra提出的最短路径算法SPF。</p><p>OSPF最主要的特征就是使用分布式的<strong>链路状态协议</strong>。</p><p>OSPF的特点：</p><ol><li><p>使用洪泛法向自治系统内所有路由器发送消息，即路由器通过输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器。<strong>广播</strong></p><p> 最终整个区域内所有路由器都得到了这个信息的一个副本。</p></li><li><p>发送的信息就是与本路由器相邻的所有路由器的链路状态（本路由器和哪些路由器相邻，以及该链路的度量&#x2F;代价——费用、距离、时延、带宽等）。</p></li><li><p>只有当链路状态发生变化时，路由器才向所有路由器洪泛发送此信息。</p><p> 最后，所有路由器都能建立一个链路状态数据库，即全网拓扑图。</p></li></ol><p><strong>链路状态路由算法</strong></p><ol><li>每个路由器发现它的邻居节点【HELLO问候分组】，并了解邻居节点的网络地址。</li><li>设置到它的每个邻居的成本度量metric。</li><li>构造【DD数据库描述分组】，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</li><li>如果DD分组中的摘要自己都有，则邻站不做处理；如果有没有的或者是更新的，则发送【LSR链路状态请求分组】请求自己没有的和比自己更新的信息。</li><li>收到邻站的LSR分组后，发送【LSU链路状态更新分组】进行更新。</li><li>更新完毕后，邻站返回一个【LSAck链路状态确认分组】进行确认。</li></ol><p>只要一个路由器的链路状态发生变化：</p><ol start="5"><li>泛洪发送【LSU链路状态更新分组】进行更新。</li><li>更新完毕后，其它站返回一个【LSAck链路状态确认分组】进行确认。</li><li>使用Dijkstra根据自己的链路状态数据库构造到其他节点间的最短路径。</li></ol><p><strong>OSPF的区域</strong></p><p>为了使OSPF能够用于规模很大的网络，OSPF将一个自治系统再划分为若干个更小的范围，叫做区域。每一个区域都有一个32位的区域标识符（用点分十进制表示）。区域也不能太大，在一个区域内的路由器最好不超过200个。</p><p><img src="/../img/computer/OSPF%E7%9A%84%E5%8C%BA%E5%9F%9F.png" alt="OSPF的区域"></p><p><strong>OSPF其他特点</strong></p><ol><li>每个30min，要刷新一次数据库中的链路状态。</li><li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF协议要比距离向量协议RIP好得多。</li><li>OSPF不存在坏消息传得慢的问题，它的收敛速度很快。</li></ol><h3 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h3><p>与其他AS的邻站BGP发言人交换信息。</p><p>交换的网络可达性的信息，即要到达某个网络所要经过的一系列AS。</p><p>发生变化时更新有变化的部分。</p><p>BGP所交换的网络可达性的信息就是要到达某个网络所要经过的一系列AS。当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据数据所采用的呃策略从收到的路由信息中找出到达各AS的较好路由。</p><p><strong>BGP协议报文格式</strong></p><p>一个BGP发言人与其它自治系统中的BGP发言人要交换路由信息，就要先建立TCP连接，即通过TCP传送，然后再此连接上交换BGP报文以建立BGP会话（session），利用BGP会话交换路由信息。</p><p><img src="/../img/computer/BGP%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="BGP协议报文格式"></p><p>BGP是应用层协议，借助TCP传送。</p><p><strong>BGP协议特点</strong></p><p>BGP支持CIDR，因此BGP的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。</p><p>在BGP刚刚运行时，BGP的邻站是交换整个的BGP路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销都有好处。</p><p><strong>BGP-4的四种报文</strong></p><ol><li>OPEN（打开）报文：用来与相邻的另一个BGP发言人建立关系，并认证发送方。</li><li>UPDATE（更新）报文：通告新路径或撤销原路径。</li><li>KEEPALIVE（保活）报文：在无UPDATE时，周期性证实邻站的连通性；也作为OPEN的确认。</li><li>NOTIFICATION（通知）报文：报告先前报文的差错；也被用于关闭连接。</li></ol><p><strong>三种路由协议比较</strong></p><p>RIP是一种分布式的基于距离向量的内部网关路由选择协议，用过广播UDP报文来交换路由信息。</p><p>OSPF是一个内部网关协议，要交换的信息量较大，应使报文的长度尽量短，所以不使用传输层协议（如UDP或TCP），而是直接采用IP。</p><p>BGP是一个外部网关协议，在不同的自治系统之间交换路由信息，由于网络环境复杂，需要保证可靠传输，所以采用TCP。</p><table><thead><tr><th align="center">协议</th><th align="center">RIP</th><th align="center">OSPF</th><th align="center">BGP</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">内部</td><td align="center">内部</td><td align="center">外部</td></tr><tr><td align="center">路由算法</td><td align="center">距离-向量</td><td align="center">链路状态</td><td align="center">路径-向量</td></tr><tr><td align="center">传递协议</td><td align="center">UDP</td><td align="center">IP</td><td align="center">TCP</td></tr><tr><td align="center">路径选择</td><td align="center">跳数最少</td><td align="center">代价最低</td><td align="center">较好，非最佳</td></tr><tr><td align="center">交换节点</td><td align="center">和本节点相连的路由器</td><td align="center">网络中的所有路由器</td><td align="center">和本节点相邻的路由器</td></tr><tr><td align="center">交换内容</td><td align="center">当前本路由器知道的全部信息，即自己的路由表</td><td align="center">与本路由器相邻的所有路由器的链路状态</td><td align="center">首次   整个路由表<br />非首次  有变化的部分</td></tr></tbody></table><h3 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h3><p> <strong>IP数据报的三种传输方式</strong>：</p><p>单播：单播用于发送数据报到单个目的地，且每发送一份单播报文都是用一个单播IP地址作为目的地址。是一种点对点传输方式。</p><p>广播：广播是指发送数据报到同一广播域或子网内的所有设备的一种数据传输方式，是一种点对多点传输方式。</p><p>组播：当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据报建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点传输方式。</p><p><strong>IP组播地址</strong></p><p>IP组播地址让源设备能够将分组发送给一组设备。属于多播组的设备将被分配一个组播组IP地址（一群共同需求主机的相同标识）。</p><p>组播地址范围为224.0.0.0～239.255.255.255（D类地址），一个D类地址表示一个组播组。只能用作分组的目标地址。源地址总是为单播地址。</p><ol><li>组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于UDP。</li><li>对组播数据报不产生ICMP差错报文</li><li>并非所有D类地址都可以作为组播地址</li></ol><p><strong>组播的两个情况</strong></p><ul><li>硬件组播</li></ul><p>同单播地址一样，组播IP地址也需要相应的组播MAC地址在本地网络中实际传送帧。组播MAC地址以十六进制值01-00-5E打头，余下的6个十六进制位是根据IP组播地址的最后23为转换得到的。</p><p><img src="/../img/computer/%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%92%AD.png" alt="硬件组播"></p><p>收到多播数据报的主机，还要在IP层利用软件进行过滤，把不是本主机要接收的数据报丢弃。</p><ul><li>在因特网的范围内进行组播</li></ul><p><strong>IGMP协议</strong></p><p>IGMP协议让路哟起知道本局域网上是否有主机（的进程）参加或退出了某个组播组。</p><p>IGMP工作的两个阶段</p><ol><li>某主机要加入组播组时，该主机向组播组的组播地址发送一个IGMP报文，声明自己要称为该组的成员。本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。</li><li>本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。</li></ol><p>只要有一个主机对某个组相应，那么组播路由器就认为这个组是活跃的；如果经过几次探询后没有一个主机相应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</p><p><strong>组播路由器知道的成员关系只是所连接的局域网中无组播组的成员。</strong></p><p><strong>组播路由选择协议</strong></p><p>组播路由选择协议目的是找出以源主机为根节点的组播转发树。</p><p>构造树可以避免在路由器之间兜圈子。</p><p>对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树。</p><p>组播路由选择协议常使用的三种算法：</p><ul><li>基于链路状态的路由选择</li><li>基于距离-向量的路由选择</li><li>协议无关的组播（稀疏&#x2F;密集）</li></ul><h3 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h3><p> <strong>移动IP相关术语</strong></p><p>移动IP技术是移动节点（计算机&#x2F;服务器等）以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证了基于网络IP的网络权限在漫游过程中不发生任何改变。</p><p><strong>移动节点</strong>：具有永久IP地址的移动设备</p><p><strong>归属代理（本地代理）</strong>：一个移动节点拥有的就“居所”称为归属网络，在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理。</p><p><strong>外部代理（外地代理）</strong>：在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理。</p><p><strong>永久地址（归属地址&#x2F;主地址）</strong>：移动站点在归属网络中的原始地址。</p><p><strong>转交地址（辅地址）</strong>：移动站点在外部网络使用的临时地址。</p><p><strong>移动IP通信过程</strong></p><p>A刚进入外部网络：</p><ol><li>在外部代理登记获得一个转交地址，离开时注销；</li><li>外地代理向本地代理登记转交地址。</li></ol><p>B给A发送数据报：</p><ol><li>本地代理接获数据报。</li><li>本地代理在封装数据报，新的数据报目的地址是转交地址，发给外部代理（隧道）。</li><li>外部代理拆封数据报并发给A。</li></ol><p>A给B发送数据报：</p><ol><li>A用自己的主地址作为数据报源地址，用B的IP地址作为数据报的目的地址。</li></ol><p>A移动到了下一个网络：</p><ol><li>在新外部代理登记注册一个转交地址</li><li>新外部代理给本地代理发送新的转交地址（覆盖旧的）</li><li>通信</li></ol><p>A回到了归属网络：</p><ol><li>A向本地代理注销转交地址</li><li>按原始方式通信</li></ol><h2 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h2><h3 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h3><p>传输层使用网络层的服务为应用层提供通信服务。传输层的功能：</p><ol><li><p>传输层提供进程和进程之间的逻辑通信</p></li><li><p>复用和分用</p></li><li><p>传输层对收到的报文进行差错检测</p></li><li><p>传输层的两种协议（TCP、UDP）</p><ol><li><p>TCP</p><p> 面向连接的传输控制协议。传送数据之前必须建立连接，数据传送结束后要释放连接。不提供传送结束后要释放连接。不提供广播或多播服务。由于TCP要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销：确认、流量控制、计时器及连接管理。<strong>可靠，面向连接，时延大，适用于大文件。</strong></p></li><li><p>UDP</p><p> 无连接的用户数据报协议UDP。传送数据之前不需要建立连接，收到UDP报文后也不需要给出任何确认。<strong>不可靠，无连接，时延小，适用于小文件。</strong></p></li></ol></li></ol><p><strong>传输层的寻址与端口</strong></p><p>复用：应用层所有的应用进程都可以通过传输层再传输到网络层。</p><p>分用：传输层从网络层收到数据后交付指明的应用进程。</p><p>逻辑端口&#x2F;软件端口：端口是传输层的SAP，标识主机中的应用进程。端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的。端口号长度为16bit，能表示65536个不同的端口号。</p><p>端口号：</p><ul><li><p>服务端使用的端口号</p><ul><li><p>熟知端口号<strong>0～1023</strong></p><p>  给TCP&#x2F;IP最重要的一些应用程序，让所有用户都知道。</p></li><li><p>登记端口号1024～49151</p><p>  为没有熟知端口号的应用程序使用的。</p></li></ul></li><li><p>客户端使用的端口号<strong>49152～65535</strong></p><p>  仅在客户端进程运行时才动态选择</p></li></ul><table><thead><tr><th align="center">应用程序</th><th align="center">FTP</th><th align="center">TELNET</th><th align="center">SMTP</th><th align="center">DNS</th><th align="center">TFTP</th><th align="center">HTTP</th><th align="center">SNMP</th></tr></thead><tbody><tr><td align="center">熟知端口号</td><td align="center">21</td><td align="center">23</td><td align="center">25</td><td align="center">53</td><td align="center">69</td><td align="center">80</td><td align="center">161</td></tr></tbody></table><h3 id="UDP协议（用户数据报协议）"><a href="#UDP协议（用户数据报协议）" class="headerlink" title="UDP协议（用户数据报协议）"></a>UDP协议（用户数据报协议）</h3><p>UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能。</p><p>UDP的主要特点：</p><ol><li>UDP是无连接的，减少开销和发送数据之前的时延。</li><li>UDP使用最大努力交付，即不保证可靠交付。</li><li>UDP是面向报文的，适合一次性传输少量数据的网络应用。</li><li>UDP无拥塞控制，适合很多实时应用。</li><li>UDP首部开销小，8B，TCP 20B。</li></ol><p><strong>UDP首部格式</strong></p><p><img src="/../img/computer/UDP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png" alt="UDP首部格式"></p><p>分用时，找不到对应的目的端口号，就丢弃报文，并给发送方发送ICMP“端口不可达”差错报告报文。 </p><p><strong>UDP校验</strong></p><p><img src="/../img/computer/UDP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="UDP数据报格式"></p><p>伪首部只有在计算检验和时才出现，不向下传送也不向上递交。</p><p>17：封装UDP报文的IP数据报首部协议字段是17。</p><p>UDP长度：UDP首部8B+数据部分长度（不包括伪首部）。</p><p><img src="/../img/computer/UDP%E6%A0%A1%E9%AA%8C.png" alt="UDP校验"></p><p>在发送端：</p><ol><li>填上伪首部</li><li>全0填充检验和字段</li><li>全0填充数据部分（UDP数据报要看成许多4B的字串接起来）</li><li>伪首部+首部+数据部分采用二进制反码求和</li><li>把和求反码填入校验和字段</li><li>去掉伪首部，发送</li></ol><p>在接收端：</p><ol><li>填上伪首部</li><li>伪首部+首部+数据部分采用二进制反码求和</li><li>结果全为1则无差错，否则丢弃数据报&#x2F;交给应用层附上出差错的警告</li></ol><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>特点：</p><ol><li><p>TCP是面向连接（虚连接）的传输层协议。</p></li><li><p>每一条TCP连接只能有两个端点，每一个TCP连接只能是点对点的。</p></li><li><p>TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达。</p></li><li><p>TCP提供全双工通信。</p><p> 发送缓存：准备发送的数据&amp;已发送但尚未接收到确认的数据</p><p> 接收缓存：按序到达但尚未被接收应用程序读取的数据&amp;不按序到达的数据</p></li><li><p>TCP面向字节流</p><p> TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。</p></li></ol><p><strong>TCP报文首部格式</strong></p><p><img src="/../img/computer/TCP%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png" alt="TCP报文首部格式"></p><p> <strong>序号</strong>：在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，本字段表表示报文段所发送数据的第一个字节的序号。</p><p><strong>确认号</strong>：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则证明到序号N-1为止的所有数据都已正确收到。</p><p>**数据偏移(首部长度)**：TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B为单位，即1个数值是4B。</p><p><strong>6个控制位</strong></p><ul><li><strong>紧急位URG</strong>：URG&#x3D;1时，标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。</li><li><strong>确认位ACK</strong>：ACK&#x3D;1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1。</li><li><strong>推送位PSH</strong>：PSH&#x3D;1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。</li><li><strong>复位RST</strong>：RST&#x3D;1时，标明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。</li><li><strong>同步位SYN</strong>：SYN&#x3D;1时，表明是一个链接请求&#x2F;连接接受报文。</li><li><strong>终止位FIN</strong>：FIN&#x3D;1时，表明此报文段发送方数据已发完，要求释放连接。</li></ul><p><strong>窗口</strong>：指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量。</p><p><strong>检验和</strong>：检验首部+数据，检验时要加上12B伪首部，第四个字段为6。</p><p><strong>紧急指针</strong>：URG&#x3D;1时才有意义，指出本报文段中紧急数据的字节数。</p><p><strong>选项</strong>：最大报文段长度MSS、窗口扩大、时间戳、选择确认……</p><p>TCP连接的三个阶段：</p><p>连接建立 -&gt; 数据传输 -&gt; 连接释放</p><p><strong>TCP建立连接</strong></p><p><img src="/../img/computer/TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png" alt="TCP建立连接"></p><ol><li><p>客户端发送数据连接请求报文段，无应用层数据。</p><p> SYN&#x3D;1，seq&#x3D;x(随机)</p></li><li><p>服务器端为该TCP连接分配缓存和随机变量，并向客户端返回确认报文段，允许连接，无应用层数据。</p><p> SYN&#x3D;1，ACK&#x3D;1，seq&#x3D;y(随机)，ack&#x3D;x+1</p></li><li><p>客户端为该TCP连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据。</p><p> SYN&#x3D;0，ACK&#x3D;1，seq&#x3D;x+1，ack&#x3D;y+1</p></li></ol><p><strong>SYN洪泛攻击</strong></p><p>SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p><p>解决方法：<strong>SYN cookie</strong></p><p><strong>TCO释放连接</strong></p><p><img src="/../img/computer/TCP%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5.png" alt="TCP释放连接"></p><ol><li><p>客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接。</p><p> FIN&#x3D;1，seq&#x3D;u</p></li><li><p>服务器端回送一个确认报文段，客户到服务器这个方向的连接就释放了——半关闭状态。</p><p> ACK&#x3D;1，seq&#x3D;v，ack&#x3D;u+1</p></li><li><p>服务器端发完数据，就发出连接释放报文段，主动关闭TCP连接。</p><p> FIN&#x3D;1，ACK&#x3D;1，seq&#x3D;w，ack&#x3D;u+1</p></li><li><p>客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL(最长报文段寿命)后，连接彻底关闭。</p><p> ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1</p></li></ol><p> <strong>TCP可靠传输</strong></p><p>保证接收方进程从缓存区读出的字节流与发送发发出的字节流是完全一样的。</p><p>TCP实现可靠传输的机制：</p><ol><li>校验：与UDP校验一样，增加伪首部。</li><li>序号：一个字节占一个序号，序号字段指的是一个报文段第一个字节的序号。</li><li>确认：TCP接收方对已经正确接收到的报文段进行确认。</li><li>重传：TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段。TCP采用自适应算法，动态改变重传时间RTTs(加权平均往返时间)。</li></ol><p><strong>TCP流量控制</strong></p><p>流量控制：让发送方慢点，要让接收方来得及接收。</p><p>TCP利用滑动窗口机制实现流量控制。</p><p>在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给发送方），发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。</p><p><strong>发送窗口大小可以动态变化。</strong></p><p>A向B发送数据，连接建立时，B告诉A：“我的rwnd&#x3D;400(字节)“，设每一个报文段100B，报文段序号初始值为1。</p><p><img src="/../img/computer/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png" alt="TCP流量控制"></p><p>TCP为每一个连接设有一个持续计时器，只要TCP连接的一方受到对方的零窗口通知，就启动持续计时器。</p><p>若持续计时器设置的时间到期，就发送一个零窗口探测报文段。接收方收到探测报文段时给出现在的窗口值。</p><p>若窗口仍然是0，那么发送方就重新设置持续计时器。</p><p><strong>TCP拥塞控制</strong></p><p>出现拥塞的条件：对资源需求的总和&gt;可用资源</p><p>网络中有许多资源同时呈现供应不足 -&gt; 网络性能变坏 -&gt; 网络吞吐量将随输入负荷增大而下降</p><p>拥塞控制：防止过多的数据注入到网络中。 </p><p><strong>拥塞控制四种算法</strong></p><p>假定：</p><ol><li><p>数据单方向传送，而另一个方向只传送确认</p></li><li><p>接收方总是有足够大的缓存空间，因而发送窗口大小取决于拥塞程度</p><p> 发送串口&#x3D;Min{接收窗口rwnd，拥塞窗口cwnd}</p><p> 接收窗口：接收方根据接受缓存设置的值，并告知给发送方，反映接收方容量。</p><p> 拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量。</p></li></ol><p>慢开始和拥塞避免</p><p><img src="/../img/computer/%E6%85%A2%E5%BC%80%E5%A7%8B%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.png" alt="慢开始和拥塞避免"></p><p>开始时cwnd&#x3D;1的一个报文段</p><p>一个传输轮次：</p><p>发送了一批报文段并收到它们的确认的时间。一个往返时延RTT。开始发送一批拥塞窗口内的报文段到开始发送下一批拥塞窗口内的报文段的时间。</p><p>快重传和快恢复</p><p><img src="/../img/computer/%E5%BF%AB%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E6%81%A2%E5%A4%8D.png" alt="快重传和快恢复"></p><h2 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h2><p><strong>应用层概述</strong></p><p>应用层对应用程序的通信提供服务。</p><p><strong>应用层协议定义</strong>：</p><p>应用进程交换的报文类型，请求还是响应？</p><p>各种报文类型的语法，如报文中的各个字段及其详细描述</p><p>字段的语义，即包含在字段中的信息的含义</p><p>进程何时、如何发送报文，以及对报文进行响应的规则</p><p><strong>应用层的功能</strong>：</p><p>文件传输、访问和管理</p><p>电子邮件</p><p>虚拟终端</p><p>查询服务和远程作业登录</p><p><strong>应用层的重要协议</strong>：</p><p>FTP、SMTP、POP3、HTTP、DNS</p><h3 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h3><p><strong>客户&#x2F;服务器(c&#x2F;s)模型</strong></p><p>服务器：提供计算服务的设备</p><ol><li>永久的提供服务</li><li>永久性访问地址&#x2F;域名</li></ol><p>客户机：请求计算服务的主机</p><ol><li>与服务器通信，使用服务器提供的服务</li><li>间歇性接入网络</li><li>可能使用动态IP地址</li><li>不与其他客户机直接通信</li></ol><p>应用：Web、文件传输FTP、远程登录、电子邮件</p><p><strong>P2P模型</strong></p><p>不存在永远在线的服务器</p><p>每个主机既可以提供服务，也可以请求服务</p><p>任意端系统&#x2F;节点之间可以直接通讯</p><p>节点间接性接入网络</p><p>节点可能改变IP地址</p><p>可扩展性好</p><p>网络健壮性强</p><h3 id="DNS系统"><a href="#DNS系统" class="headerlink" title="DNS系统"></a>DNS系统</h3><p><strong>域名</strong></p><p><a href="http://www.baidu.com/">www.baidu.com</a></p><p>com：顶级域名</p><p>baidu：二级域名</p><p>www：三级域名</p><ul><li>根：‘.’</li><li>顶级域名<ul><li>国家顶级域名：cn, us, uk</li><li>通用顶级域名：com, net, org, gov, int, aero, museum, travel</li><li>基础结构域名&#x2F;反向域名：arpa</li></ul></li><li>二级域名<ul><li>类别域名：ac, com, edu, gov, mil, net, org</li><li>行政区域名 用于我国各省、自治区、直辖市 bj, js</li></ul></li><li>三级域名</li><li>四级域名</li></ul><p><img src="/../img/computer/%E5%9F%9F%E5%90%8D.png" alt="域名"></p><p><strong>域名解析过程</strong></p><p><img src="/../img/computer/%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2.png" alt="递归查询"></p><p><img src="/../img/computer/%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2.png" alt="迭代查询"></p><h3 id="文件传输协议FTP"><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a>文件传输协议FTP</h3><p><strong>文件传送协议FTP（File Transfer Protocol）</strong></p><p>提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力</p><p>FTP是基于客户&#x2F;服务器（c&#x2F;s）的协议</p><p>用户通过一个客户机程序连接至在远程计算机上运行的服务器程序。依照FTP协议提供服务，进行文件传送的计算机就是FTP服务器。连接FTP服务器，遵循FTP协议的服务器传送文件的电脑就是FT P客户端。</p><p><img src="/../img/computer/FTP.png" alt="FTP工作原理"></p><p>控制连接始终保持</p><p>数据连接保持一会</p><p>是否使用TCP 20端口建立数据连接与传输模式有关</p><p>主动方式使用TCP 20端口</p><p>被动方式由服务器和客户端自行协商决定（端口&gt;1024）</p><p>FTP传输模式：</p><ul><li>文本模式：ASCII模式，以文本序列传输数据；</li><li>二进制模式：Binary模式，以二进制序列传输数据。</li></ul><p>简单文件传送协议TFTP（Trivial File Transfer Protocol）</p><h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><p>电子邮件的信息格式：</p><ul><li><p>信封：<a href="mailto:&#97;&#x62;&#x63;&#x2e;&#x40;&#x31;&#x36;&#51;&#46;&#x63;&#111;&#109;">&#97;&#x62;&#x63;&#x2e;&#x40;&#x31;&#x36;&#51;&#46;&#x63;&#111;&#109;</a></p></li><li><p>内容：</p><ul><li><p>首部</p><p>  To:<a href="mailto:&#97;&#98;&#99;&#46;&#64;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#109;">&#97;&#98;&#99;&#46;&#64;&#49;&#x36;&#x33;&#46;&#x63;&#x6f;&#109;</a></p><p>  Subject:hello!</p></li><li><p>主题</p></li></ul></li></ul><p>组成结构</p><ul><li>用户代理：电子邮件客户端软件——撰写、显示、处理、通信</li><li>邮件服务器<ul><li>发送和接受邮件</li><li>向发件人报告邮件传送结果</li></ul></li><li>协议<ul><li>SMTP协议（发）</li><li>POP3、IMAP（收）</li></ul></li></ul><p><img src="/../img/computer/%E9%82%AE%E4%BB%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="邮件工作原理"></p><p><strong>简单邮件传送协议SMTP</strong></p><p>SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息。</p><p>负责发送邮件的SMTP进程就是SMTP客户，负责接收邮件的进程就是SMTP服务器</p><p>SMTP规定了14条命令（几个字母）和21种应答信息（三位数字代码+简单文字说明）</p><p>采用TCP连接，端口号25，C&#x2F;S</p><p>过程：</p><p>连接建立 -&gt; 邮件发送 -&gt; 连接释放</p><p>缺点：</p><ol><li>SMTP不能传送可执行文件或者其他二进制对象。</li><li>SMTP仅限于传送7位ASCII码，不能传送其他非英语国家的文字。</li><li>SMTP服务器会拒绝超过一定长度的邮件。</li></ol><p><strong>邮局协议POP3</strong></p><p>采用C&#x2F;S模式的TCP连接，端口号110</p><p>POP3工作方式：下载并保留，下载并删除</p><p><strong>网际报文存取协议IMAP</strong></p><p>IMAP协议比POP协议复杂。当用户PC上的IMAP客户程序打开IMAP服务器的邮箱时，用户可以看到邮箱的首部，若用户需要打开某个邮件，该邮件才能上传到用户的计算机上。IMAP可以让用户在不同的地方使用不同的计算机随时上网阅读处理邮件，还允许只读邮件中的某一个部分（先看正文，由WIFI的时候再下载附件）。</p><h3 id="万维网和HTTP协议"><a href="#万维网和HTTP协议" class="headerlink" title="万维网和HTTP协议"></a>万维网和HTTP协议</h3><p>万维网www(World Wide Web) 是一个大规模的、联机式的信息储藏所&#x2F;资料空间，是无数个网络站点和网页的集合。 </p><p>同一资源定位符URL—————-&gt;资源(文字、视频、音频……)</p><p>URL一般形式：</p><p>​&lt;协议&gt;:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;<a href="http://www.pku.edu.cn/">http://www.pku.edu.cn</a></p><p>​http域名</p><p>​ftp IP地址</p><p>用户通过点击超链接获取资源，这些资源通过超文本传输协议(HTTP)传送给使用者。</p><p>万维网以客户&#x2F;服务器方式工作，用户使用的浏览器就是万维网客户程序，万维网文档所驻留的主机运行服务器程序。</p><p>万维网使用超文本标记语言HTML，使得万维网页面设计者可以很方便地从一个界面的链接转到另一个界面，并能够在自己的屏幕上显示出来。</p><p><strong>超文本传输协议HTTP</strong></p><p>HTTP协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。</p><p><img src="/../img/computer/HTTP1.png" alt="HTTP1"></p><p>用户浏览页面方法：</p><ol><li>输入URL</li><li>点击超链接</li></ol><p>具体过程：</p><ol><li>浏览器分析URL</li><li>浏览器向DNS请求解析IP地址</li><li>DNS解析出IP地址</li><li>浏览器与服务器建立TCP连接</li><li>浏览器发出取文件命令</li><li>服务器响应</li><li>释放TCP连接</li><li>浏览器显示</li></ol><p><strong>HTTP协议的特点</strong></p><p>HTTP协议是无状态的。</p><p>但是在实际工作中，一些万维网站点常常希望能够识别用户。</p><p>COOkie时存储在用户主机中的文本文件，记录一段时间内某用户（使用识别码，如“123456”）的访问记录。</p><p>HTTP采用TCP作为运输层协议，但HTTP协议本身是无连接的（通信双方在交换HTTP报文之前不需要建立HTTP连接）。</p><p>HTTP的连接方式：</p><ul><li>持久连接keep-alive<ul><li>非流水</li><li>流水</li></ul></li><li>非持久连接close</li></ul><p>HTTP非持久连接</p><p><img src="/../img/computer/http%E9%9D%9E%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5.png" alt="http非持久连接"></p><p>HTTP持久连接</p><p><img src="/../img/computer/http%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5.png" alt="http持久连接"></p><p><strong>报文结构</strong></p><p>HTTP报文是面向文本的，因此在报文中的每一个字段都是一些ASCII码串。</p><p><img src="/../img/computer/http%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png" alt="报文结构"></p><p>状态码：</p><ul><li><p>1xx表示通知信息的，如请求收到了或正在处理</p></li><li><p>2xx表示成功，如接受或知道了</p></li><li><p>3xx表示重定向，如要完成请求还必须采取进一步的行动</p></li><li><p>4xx表示客户的差错，如请求中有错误的语法或不能完成</p></li><li><p>5xx表示服务器的差错，如服务器失效无法完成请求</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
