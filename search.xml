<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java 环境安装</title>
      <link href="/2022/12/18/0_%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2022/12/18/0_%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-环境安装"><a href="#Java-环境安装" class="headerlink" title="Java 环境安装"></a>Java 环境安装</h2><h3 id="JDK-下载地址：Oracle-官网"><a href="#JDK-下载地址：Oracle-官网" class="headerlink" title="JDK 下载地址：Oracle 官网"></a>JDK 下载地址：<a href="https://www.oracle.com/java/technologies/downloads/">Oracle 官网</a></h3><p><img src="http://1.117.162.142:9000/blog/image-20221218150049618.png" alt="image-20221218150049618"></p><blockquote><p>如果是 MacOS 系统，选择 macOS 下载。安装过程中无脑选择下一步即可。</p></blockquote><p>默认安装路径为：<code>C:\Program Files\Java\jdk1.8.0_351</code></p><p><img src="http://1.117.162.142:9000/blog/image-20221218151753512.png" alt="image-20221218151753512"></p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ul><li><p>Windows 操作系统</p><p>  右键 <code>我的电脑</code> 选择 <code>属性</code> -&gt; <code>高级系统设置</code> -&gt; <code>环境变量</code> -&gt; <code>系统环境变量</code> -&gt; <code>新建</code></p><p>  <img src="http://1.117.162.142:9000/blog/image-20221218151918407.png" alt="image-20221218151918407"></p></li></ul><p>​选择 <code>Path</code> -&gt; <code>编辑</code> -&gt; <code>新建</code> -&gt; <code>确定</code></p><p><img src="http://1.117.162.142:9000/blog/image-20221218152717603.png" alt="image-20221218152717603"></p><p>​<code>win + R</code> -&gt; 输入 <code>cmd</code> -&gt; <code>java -version</code></p><p><img src="http://1.117.162.142:9000/blog/image-20221218153109679.png" alt="image-20221218153109679"></p><ul><li><p>macOS 系统</p><p>  配置环境变量</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看 jdk 安装路径</span></span><br><span class="line">/usr/libexec/java_home -V</span><br></pre></td></tr></table></figure><p>  <img src="http://1.117.162.142:9000/blog/image-20221218154441249.png" alt="image-20221218154441249"></p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑 .bash_profile</span></span><br><span class="line">vim .bash_profile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置以下类容</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Java</span></span><br><span class="line">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_321.jdk/Contents/Home</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH:.</span><br><span class="line">CLASSPATH=$JAVA_HOME/lib/tools.jar:%JAVA_HOME/lib/dt.jar:.</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br></pre></td></tr></table></figure>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除 .bash_profile 文件</span></span><br><span class="line">rm -rf ~/.bash_profile</span><br></pre></td></tr></table></figure></li></ul><h2 id="Maven-仓库安装"><a href="#Maven-仓库安装" class="headerlink" title="Maven 仓库安装"></a>Maven 仓库安装</h2><h3 id="maven-下载地址：Apache-官网"><a href="#maven-下载地址：Apache-官网" class="headerlink" title="maven 下载地址：Apache 官网"></a>maven 下载地址：<a href="https://maven.apache.org/download.cgi">Apache 官网</a></h3><p><img src="http://1.117.162.142:9000/blog/image-20221218155540200.png" alt="image-20221218155540200"></p><p>解压即可</p><h3 id="配置环境变量-1"><a href="#配置环境变量-1" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ul><li><p>windows</p><p>  右键 <code>我的电脑</code> 选择 <code>属性</code> -&gt; <code>高级系统设置</code> -&gt; <code>环境变量</code> -&gt; <code>系统环境变量</code> -&gt; <code>新建</code></p><p>  <img src="http://1.117.162.142:9000/blog/image-20221218160621062.png" alt="image-20221218160621062"></p><p>  选择 <code>Path</code> -&gt; <code>编辑</code> -&gt; <code>新建</code> -&gt; <code>确定</code></p><p>  <img src="http://1.117.162.142:9000/blog/image-20221218160716558.png" alt="image-20221218160716558"></p><p>  <code>win + R</code> -&gt; 输入 <code>cmd</code> -&gt; <code>mvn -v</code></p><p>  <img src="http://1.117.162.142:9000/blog/image-20221218160747410.png" alt="image-20221218160747410"></p></li><li><p>macOS</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑 .bash_profile</span></span><br><span class="line">vim .bash_profile</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置以下类容</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Maven</span></span><br><span class="line">export MAVEN_HOME=/Users/zhangjian/develop/apache-maven-3.8.4 # 路径为自己的解压路径</span><br><span class="line">export PATH=$&#123;MAVEN_HOME&#125;/bin:$PATH:.</span><br></pre></td></tr></table></figure></li></ul><h2 id="MySQL-数据库安装"><a href="#MySQL-数据库安装" class="headerlink" title="MySQL 数据库安装"></a>MySQL 数据库安装</h2><h3 id="下载地址-MySQL-官网"><a href="#下载地址-MySQL-官网" class="headerlink" title="下载地址 MySQL 官网"></a>下载地址 <a href="https://dev.mysql.com/downloads/mysql/">MySQL 官网</a></h3><img src="http://1.117.162.142:9000/blog/image-20221218162355221.png" alt="image-20221218162355221" style="zoom:50%;" /><img src="http://1.117.162.142:9000/blog/image-20221218162122545.png" alt="image-20221218162122545" style="zoom:50%;" /><img src="http://1.117.162.142:9000/blog/image-20221218162139014.png" alt="image-20221218162139014" style="zoom:50%;" /><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>打开安装程序</p><img src="http://1.117.162.142:9000/blog/image-20221218162812173.png" alt="image-20221218162812173" style="zoom:50%;" /><img src="http://1.117.162.142:9000/blog/image-20221218163128679.png" alt="image-20221218163128679" style="zoom:50%;" /><img src="http://1.117.162.142:9000/blog/image-20221218163618079.png" alt="image-20221218163618079" style="zoom:50%;" /><img src="http://1.117.162.142:9000/blog/image-20221218163652068.png" alt="image-20221218163652068" style="zoom:50%;" /><img src="http://1.117.162.142:9000/blog/image-20221218163727555.png" alt="image-20221218163727555" style="zoom:50%;" /><img src="http://1.117.162.142:9000/blog/image-20221218163809979.png" alt="image-20221218163809979" style="zoom:50%;" /><img src="http://1.117.162.142:9000/blog/image-20221218163934418.png" alt="image-20221218163934418" style="zoom:50%;" /><img src="http://1.117.162.142:9000/blog/image-20221218164017993.png" alt="image-20221218164017993" style="zoom:50%;" /><img src="http://1.117.162.142:9000/blog/image-20221218164132575.png" alt="image-20221218164132575" style="zoom:50%;" /><img src="http://1.117.162.142:9000/blog/image-20221218164219001.png" alt="image-20221218164219001" style="zoom:50%;" /><img src="http://1.117.162.142:9000/blog/image-20221218164302577.png" alt="image-20221218164302577" style="zoom:50%;" /><img src="http://1.117.162.142:9000/blog/image-20221218164321320.png" alt="image-20221218164321320" style="zoom:50%;" /><img src="http://1.117.162.142:9000/blog/image-20221218164351873.png" alt="image-20221218164351873" style="zoom:50%;" /><img src="http://1.117.162.142:9000/blog/image-20221218164419439.png" alt="image-20221218164419439" style="zoom:50%;" /><img src="http://1.117.162.142:9000/blog/image-20221218164437139.png" alt="image-20221218164437139" style="zoom:50%;" /><h3 id="配置环境变量-2"><a href="#配置环境变量-2" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>默认安装路径为<code>C:\Program Files\MySQL\MySQL Server 8.0</code></p><p><img src="http://1.117.162.142:9000/blog/image-20221218164652460.png" alt="image-20221218164652460"></p><p>右键 <code>我的电脑</code> 选择 <code>属性</code> -&gt; <code>高级系统设置</code> -&gt; <code>环境变量</code> -&gt; <code>系统环境变量</code> -&gt; 选择 Path -&gt; 新建</p><p><img src="http://1.117.162.142:9000/blog/image-20221218164903850.png" alt="image-20221218164903850"></p><p><code>win + R</code> 输入 cmd 打开终端，输入<code>mysql -uroot -p</code> ，然后回车，输入密码</p><p><img src="http://1.117.162.142:9000/blog/image-20221218165058024.png" alt="image-20221218165058024"></p><h2 id="开发工具安装"><a href="#开发工具安装" class="headerlink" title="开发工具安装"></a>开发工具安装</h2><h3 id="下载地址-IntelliJ-IDEA"><a href="#下载地址-IntelliJ-IDEA" class="headerlink" title="下载地址 IntelliJ IDEA"></a>下载地址 <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a></h3><blockquote><p>注册自己学校的邮箱，可以激活使用一年</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DXC 实习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>24 大设计模式 和 7 个原则</title>
      <link href="/2022/12/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/12/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="7个原则"><a href="#7个原则" class="headerlink" title="7个原则"></a>7个原则</h2><p>单一职责原则【SINGLE RESPONSIBILITY PRINCIPLE】：一个类负责一项职责。</p><p>里氏替换原则【LISKOV SUBSTITUTION PRINCIPLE】: 继承与派生的规则。</p><p>依赖倒置原则【DEPENDENCE INVERSION PRINCIPLE】: 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。</p><p>接口隔离原则【INTERFACE SEGREGATION PRINCIPLE】: 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。</p><p>迪米特法则【LOW OF DEMETER】: 低耦合，高内聚。</p><p>开闭原则【OPEN CLOSE PRINCIPLE】: 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p><p>组合&#x2F;聚合复用原则【Composition&#x2F;Aggregation Reuse Principle(CARP) 】: 尽量使用组合和聚合少使用继承的关系来达到复用的原则。</p><h2 id="24大设计模式"><a href="#24大设计模式" class="headerlink" title="24大设计模式"></a>24大设计模式</h2><h3 id="1-创建型-单例模式-Singleton-Pattern"><a href="#1-创建型-单例模式-Singleton-Pattern" class="headerlink" title="1. 创建型 - 单例模式(Singleton Pattern)"></a>1. 创建型 - 单例模式(Singleton Pattern)</h3><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</p><p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p><p><img src="http://1.117.162.142:9000/blog/562f2844-d77c-40e0-887a-28a7128abd42.png" alt="562f2844-d77c-40e0-887a-28a7128abd42"></p><h4 id="6种实现方式"><a href="#6种实现方式" class="headerlink" title="6种实现方式"></a>6种实现方式</h4><p><img src="http://1.117.162.142:9000/blog/2_singleton_1.png" alt="2_singleton_1"></p><h4 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式 - 线程不安全"></a>懒汉式 - 线程不安全</h4><p>以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化，从而节约资源。</p><p>这个实现再多线程环境下是不安全的，如果多个线程能够同时进入<code>if(uniqueInstance == null)</code>, 并且此时 uniqueInstance 为 null，那么会有多个线程执行<code>uniqueInstance = new Singleton();</code>语句，这将导致多次实例化 uniqueInstance。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern001</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonPattern001 uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonPattern001</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonPattern001 <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> <span class="title class_">SingletonPattern001</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="饿汉式-线程安全"><a href="#饿汉式-线程安全" class="headerlink" title="饿汉式 - 线程安全"></a>饿汉式 - 线程安全</h4><p>线程不安全的问题主要是由于 uniqueInstance 被多次实例化，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全的问题。</p><p>但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern002</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonPattern002</span> <span class="variable">uniqueInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonPattern002</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonPattern002 <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="懒汉式-线程安全"><a href="#懒汉式-线程安全" class="headerlink" title="懒汉式 - 线程安全"></a>懒汉式 - 线程安全</h4><p>只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了多次实例化 uniqueInstance 的问题。</p><p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，因此性能上有一定的损耗。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern003</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonPattern003 uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonPattern003</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonPattern003 <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> <span class="title class_">SingletonPattern003</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双重校验锁-线程安全"><a href="#双重校验锁-线程安全" class="headerlink" title="双重校验锁 - 线程安全"></a>双重校验锁 - 线程安全</h4><p>uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern004</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonPattern004 uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonPattern004</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonPattern004 <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonPattern004.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">SingletonPattern004</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance &#x3D;&#x3D; null 的情况下，如果两个线程同时执行 if 语句，那么两个线程就会同时进入 if 语句块内。虽然在 if 语句内有加锁操作，但是两个线程都会执行<code>uniqueInstance = new Singleton();</code>这条语句，只是先后的问题，那么就会进行两次实例化，从而产生了两个实例。因此必须使用双重校验锁，也就是需要使用两个 if 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SingletonPattern004.class) &#123;</span><br><span class="line">          uniqueInstance = <span class="keyword">new</span> <span class="title class_">SingletonPattern004</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的。<code>uniqueInstance = new SingletonPattern004();</code>这段代码其实是分为三步执行。</p><ol><li>分配内存空间</li><li>初始化对象</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，有可能执行顺序变为了 1&gt;3&gt;2，这在单线程情况下自然是没有问题。但如果是多线程下，有可能获得是一个还没有被初始化的实例，以至于程序出错。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>当 SingletonPattern005 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用<code>getUniqueInstance()</code>方法从而触发<code>SingletonHolder.INSTANCE</code>时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例。</p><p>这种方式不仅具有延迟初始化的好处，而且由虚拟机提供了对线程安全的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern005</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonPattern005</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingletonPattern005</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonPattern005</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingletonPattern005 <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h4><p>这是单例模式的最佳实践，他实现简单，并且在面对复杂的序列化或者反射攻击的时候，能够防止实例化多次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SingletonPattern006</span> &#123;</span><br><span class="line">    uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑一下单例模式的实现，该 Singleton 在每次序列化的时候都会创建一个新的实例，为了保证只创建一个实例，必须声明所有字段都是transient，并且提供一个 readResolve() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用枚举来实现单例模式，会出现反射攻击，因为通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象。如果要防止这种攻击，需要在构造函数中添加防止实例化对二个对象的代码。从上面的讨论可以看出，解决序列化和反射攻击很麻烦，而枚举实现不会出现这两种问题，所以说枚举实现单例模式是最佳实践。</p><h3 id="2-创建型-简单工厂-Simple-Factory"><a href="#2-创建型-简单工厂-Simple-Factory" class="headerlink" title="2. 创建型 - 简单工厂(Simple Factory)"></a>2. 创建型 - 简单工厂(Simple Factory)</h3><h4 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h4><p>再创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p><h4 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h4><p>简单工厂不是设计模式，更像一种编程习惯。它把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</p><p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。因为客户类往往有多个，如果不使用简单工厂，所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p><p><img src="http://1.117.162.142:9000/blog/c79da808-0f28-4a36-bc04-33ccc5b83c13.png" alt="c79da808-0f28-4a36-bc04-33ccc5b83c13"></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下的 Client 类中包含了实例化的代码，这是一种错误的实现，如果在客户类中存在实例化代码，就需要将代码放到简单工厂中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        Product product;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            product = <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleFactory</span> <span class="variable">simpleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleFactory</span>();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> simpleFactory.createProduct(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-创建型-工厂方法-Factory-Method"><a href="#3-创建型-工厂方法-Factory-Method" class="headerlink" title="3. 创建型 - 工厂方法(Factory Method)"></a>3. 创建型 - 工厂方法(Factory Method)</h3><h4 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h4><p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p><h4 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h4><p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</p><p>下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。</p><p><img src="http://1.117.162.142:9000/blog/1818e141-8700-4026-99f7-900a545875f5.png" alt="1818e141-8700-4026-99f7-900a545875f5"></p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> factoryMethod();</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-创建型-抽象工厂-Abstract-Factory"><a href="#4-创建型-抽象工厂-Abstract-Factory" class="headerlink" title="4. 创建型 - 抽象工厂(Abstract Factory)"></a>4. 创建型 - 抽象工厂(Abstract Factory)</h3><h4 id="意图-2"><a href="#意图-2" class="headerlink" title="意图"></a>意图</h4><p>提供一个接口，用于创建 相关的对象家族。</p><h4 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h4><p>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</p><p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p><p>至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</p><p>从高层次来看，抽象工厂使用了组合，即 Client 组合了 AbstractFactory，而工厂方法模式使用了继承。</p><p><img src="http://1.117.162.142:9000/blog/8668a3e1-c9c7-4fcb-98b2-a96a5d841579.png" alt="8668a3e1-c9c7-4fcb-98b2-a96a5d841579"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductA1</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductA2</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductB1</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductB2</span> <span class="keyword">extends</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">abstractFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory1</span>();</span><br><span class="line">        <span class="type">AbstractProductA</span> <span class="variable">productA</span> <span class="operator">=</span> abstractFactory.createProductA();</span><br><span class="line">        <span class="type">AbstractProductB</span> <span class="variable">productB</span> <span class="operator">=</span> abstractFactory.createProductB();</span><br><span class="line">        <span class="comment">// do something with productA and productB</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-创建型-生成器-Builder"><a href="#5-创建型-生成器-Builder" class="headerlink" title="5. 创建型 - 生成器(Builder)"></a>5. 创建型 - 生成器(Builder)</h3><h4 id="意图-3"><a href="#意图-3" class="headerlink" title="意图"></a>意图</h4><p>封装一个对象的构造过程，并允许按步骤构造。</p><h4 id="类图-4"><a href="#类图-4" class="headerlink" title="类图"></a>类图</h4><p><img src="http://1.117.162.142:9000/blog/13b0940e-d1d7-4b17-af4f-b70cb0a75e08.png" alt="13b0940e-d1d7-4b17-af4f-b70cb0a75e08"></p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>以下是一个简易的 StringBuilder 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractStringBuilder</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(count + <span class="number">1</span>);</span><br><span class="line">        value[count++] = c;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>)</span><br><span class="line">            expandCapacity(minimumCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">expandCapacity</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> value.length * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minimumCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">            newCapacity = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilder</span> <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Create a copy, don&#x27;t share the array</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            sb.append((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcdefghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure><h3 id="6-创建型-原型模式-Prototype"><a href="#6-创建型-原型模式-Prototype" class="headerlink" title="6. 创建型 - 原型模式(Prototype)"></a>6. 创建型 - 原型模式(Prototype)</h3><h4 id="意图-4"><a href="#意图-4" class="headerlink" title="意图"></a>意图</h4><p>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。</p><h4 id="类图-5"><a href="#类图-5" class="headerlink" title="类图"></a>类图</h4><p><img src="http://1.117.162.142:9000/blog/a40661e4-1a71-46d2-a158-ff36f7fc3331.png"></p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> Prototype <span class="title function_">myClone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcretePrototype</span><span class="params">(String filed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filed = filed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Prototype <span class="title function_">myClone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(filed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> filed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">clone</span> <span class="operator">=</span> prototype.myClone();</span><br><span class="line">        System.out.println(clone.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br></pre></td></tr></table></figure><h3 id="7-结构型-外观-Facade"><a href="#7-结构型-外观-Facade" class="headerlink" title="7. 结构型 - 外观(Facade)"></a>7. 结构型 - 外观(Facade)</h3><h4 id="意图-5"><a href="#意图-5" class="headerlink" title="意图"></a>意图</h4><p>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</p><h4 id="类图-6"><a href="#类图-6" class="headerlink" title="类图"></a>类图</h4><p><img src="http://1.117.162.142:9000/blog/f9978fa6-9f49-4a0f-8540-02d269ac448f.png"></p><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>观看电影需要操作很多电器，使用外观模式实现一键看电影功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubSystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnOnTV</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;turnOnTV()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCD</span><span class="params">(String cd)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;setCD( &quot;</span> + cd + <span class="string">&quot; )&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">starWatching</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;starWatching()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SubSystem</span> <span class="variable">subSystem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubSystem</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchMovie</span><span class="params">()</span> &#123;</span><br><span class="line">        subSystem.turnOnTV();</span><br><span class="line">        subSystem.setCD(<span class="string">&quot;a movie&quot;</span>);</span><br><span class="line">        subSystem.starWatching();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Facade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Facade</span>();</span><br><span class="line">        facade.watchMovie();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p>最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。</p><h3 id="8-结构性-适配器-Adapter"><a href="#8-结构性-适配器-Adapter" class="headerlink" title="8. 结构性 - 适配器(Adapter)"></a>8. 结构性 - 适配器(Adapter)</h3><h4 id="意图-6"><a href="#意图-6" class="headerlink" title="意图"></a>意图</h4><p>把一个类接口转换成另一个用户需要的接口。</p><p><img src="http://1.117.162.142:9000/blog/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png"></p><h4 id="类图-7"><a href="#类图-7" class="headerlink" title="类图"></a>类图</h4><p><img src="http://1.117.162.142:9000/blog/0f754c1d-b5cb-48cd-90e0-4a86034290a1.png"></p><h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Turkey</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WildTurkey</span> <span class="keyword">implements</span> <span class="title class_">Turkey</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;gobble!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    Turkey turkey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        turkey.gobble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Turkey</span> <span class="variable">turkey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WildTurkey</span>();</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TurkeyAdapter</span>(turkey);</span><br><span class="line">        duck.quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-结构型-桥接-Bridge"><a href="#9-结构型-桥接-Bridge" class="headerlink" title="9. 结构型 - 桥接(Bridge)"></a>9. 结构型 - 桥接(Bridge)</h3><h4 id="意图-7"><a href="#意图-7" class="headerlink" title="意图"></a>意图</h4><p>将抽象与实现分离开来，使他们可以独立变化。</p><h4 id="类图-8"><a href="#类图-8" class="headerlink" title="类图"></a>类图</h4><ul><li>Abstracttion：定义抽象类的接口</li><li>Implementor：定义实现类接口</li></ul><p><img src="http://1.117.162.142:9000/blog/c2cbf5d2-82af-4c78-bd43-495da5adf55f.png"></p><h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><p>RemoteControl 表示遥控器，指代 Abstraction。</p><p>TV 表示电视，指代 Implementor。</p><p>桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">tuneChannel</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sony</span> <span class="keyword">extends</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sony.on()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sony.off()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tuneChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sony.tuneChannel()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RCA</span> <span class="keyword">extends</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RCA.on()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RCA.off()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tuneChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RCA.tuneChannel()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteControl</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">tuneChannel</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteRemoteControl1</span> <span class="keyword">extends</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteRemoteControl1</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(tv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteRemoteControl1.on()&quot;</span>);</span><br><span class="line">        tv.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteRemoteControl1.off()&quot;</span>);</span><br><span class="line">        tv.off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tuneChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteRemoteControl1.tuneChannel()&quot;</span>);</span><br><span class="line">        tv.tuneChannel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteRemoteControl2</span> <span class="keyword">extends</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteRemoteControl2</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(tv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteRemoteControl2.on()&quot;</span>);</span><br><span class="line">        tv.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteRemoteControl2.off()&quot;</span>);</span><br><span class="line">        tv.off();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tuneChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteRemoteControl2.tuneChannel()&quot;</span>);</span><br><span class="line">        tv.tuneChannel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RemoteControl</span> <span class="variable">remoteControl1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteRemoteControl1</span>(<span class="keyword">new</span> <span class="title class_">RCA</span>());</span><br><span class="line">        remoteControl1.on();</span><br><span class="line">        remoteControl1.off();</span><br><span class="line">        remoteControl1.tuneChannel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-结构型-组合-Composite"><a href="#10-结构型-组合-Composite" class="headerlink" title="10. 结构型 - 组合(Composite)"></a>10. 结构型 - 组合(Composite)</h3><h4 id="意图-8"><a href="#意图-8" class="headerlink" title="意图"></a>意图</h4><p>将对象组合成树形结构来表示”整体&#x2F;部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。</p><h4 id="类图-9"><a href="#类图-9" class="headerlink" title="类图"></a>类图</h4><p>组件(Component)类是组合类(Composite)和叶子类(Leaf)的父类，可以把组合类堪称是树的中间节点。</p><p>组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。</p><p><img src="http://1.117.162.142:9000/blog/3fb5b255-b791-45b6-8754-325c8741855a.png"></p><h4 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Component</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        print(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> level)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Composite</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        child = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Composite:&quot;</span> + name);</span><br><span class="line">        <span class="keyword">for</span> (Component component : child) &#123;</span><br><span class="line">            component.print(level + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        child.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        child.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;left:&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(); <span class="comment">// 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Composite</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        root.add(node1);</span><br><span class="line">        root.add(node2);</span><br><span class="line">        root.add(node3);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">node21</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;21&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">node22</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&quot;22&quot;</span>);</span><br><span class="line">        node2.add(node21);</span><br><span class="line">        node2.add(node22);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">node221</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;221&quot;</span>);</span><br><span class="line">        node22.add(node221);</span><br><span class="line">        root.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Composite:root</span><br><span class="line">--left:1</span><br><span class="line">--Composite:2</span><br><span class="line">----left:21</span><br><span class="line">----Composite:22</span><br><span class="line">------left:221</span><br><span class="line">--left:3</span><br></pre></td></tr></table></figure><h3 id="11-结构型-装饰-Decorator"><a href="#11-结构型-装饰-Decorator" class="headerlink" title="11. 结构型 - 装饰(Decorator)"></a>11. 结构型 - 装饰(Decorator)</h3><h4 id="意图-9"><a href="#意图-9" class="headerlink" title="意图"></a>意图</h4><p>为对象动态添加功能。</p><h4 id="类图-10"><a href="#类图-10" class="headerlink" title="类图"></a>类图</h4><p>装饰者(Decorator)和具体组件(ConcreteComponent)都继承自组件(Component)，具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其他装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于他的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。</p><p><img src="http://1.117.162.142:9000/blog/137c593d-0a9e-47b8-a9e6-b71f540b82dd.png"></p><h4 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h4><p>设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。</p><p>下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。</p><p><img src="http://1.117.162.142:9000/blog/c9cfd600-bc91-4f3a-9f99-b42f88a5bb24.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DarkRoast</span> <span class="keyword">implements</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseBlend</span> <span class="keyword">implements</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CondimentDecorator</span> <span class="keyword">implements</span> <span class="title class_">Beverage</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Beverage beverage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Milk</span> <span class="keyword">extends</span> <span class="title class_">CondimentDecorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Milk</span><span class="params">(Beverage beverage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mocha</span> <span class="keyword">extends</span> <span class="title class_">CondimentDecorator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mocha</span><span class="params">(Beverage beverage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Beverage</span> <span class="variable">beverage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseBlend</span>();</span><br><span class="line">        beverage = <span class="keyword">new</span> <span class="title class_">Mocha</span>(beverage);</span><br><span class="line">        beverage = <span class="keyword">new</span> <span class="title class_">Milk</span>(beverage);</span><br><span class="line">        System.out.println(beverage.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.0</span><br></pre></td></tr></table></figure><h4 id="设计原则-1"><a href="#设计原则-1" class="headerlink" title="设计原则"></a>设计原则</h4><p>类应该对扩展开放，对修改关闭: 也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。</p><p>不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。</p><h3 id="12-结构型-享元-Flyweight"><a href="#12-结构型-享元-Flyweight" class="headerlink" title="12. 结构型 - 享元(Flyweight)"></a>12. 结构型 - 享元(Flyweight)</h3><h4 id="意图-10"><a href="#意图-10" class="headerlink" title="意图"></a>意图</h4><p>利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。</p><h4 id="类图-11"><a href="#类图-11" class="headerlink" title="类图"></a>类图</h4><ul><li>Flyweight: 享元对象</li><li>IntrinsicState: 内部状态，享元对象共享内部状态</li><li>ExtrinsicState：外部状态，每个享元对象的外部状态不同</li></ul><p><img src="http://1.117.162.142:9000/blog/d52270b4-9097-4667-9f18-f405fc661c99.png"></p><h4 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyweight</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doOperation</span><span class="params">(String extrinsicState)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title class_">Flyweight</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String intrinsicState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteFlyweight</span><span class="params">(String intrinsicState)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.intrinsicState = intrinsicState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOperation</span><span class="params">(String extrinsicState)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Object address: &quot;</span> + System.identityHashCode(<span class="built_in">this</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;IntrinsicState: &quot;</span> + intrinsicState);</span><br><span class="line">        System.out.println(<span class="string">&quot;ExtrinsicState: &quot;</span> + extrinsicState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyweightFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Flyweight&gt; flyweights = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Flyweight <span class="title function_">getFlyweight</span><span class="params">(String intrinsicState)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flyweights.containsKey(intrinsicState)) &#123;</span><br><span class="line">            <span class="type">Flyweight</span> <span class="variable">flyweight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFlyweight</span>(intrinsicState);</span><br><span class="line">            flyweights.put(intrinsicState, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweights.get(intrinsicState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FlyweightFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlyweightFactory</span>();</span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweight1</span> <span class="operator">=</span> factory.getFlyweight(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweight2</span> <span class="operator">=</span> factory.getFlyweight(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        flyweight1.doOperation(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">        flyweight2.doOperation(<span class="string">&quot;y&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object address: 356573597</span><br><span class="line">IntrinsicState: aa</span><br><span class="line">ExtrinsicState: x</span><br><span class="line">Object address: 356573597</span><br><span class="line">IntrinsicState: aa</span><br><span class="line">ExtrinsicState: y</span><br></pre></td></tr></table></figure><h3 id="13-结构型-代理-Proxy"><a href="#13-结构型-代理-Proxy" class="headerlink" title="13. 结构型 - 代理(Proxy)"></a>13. 结构型 - 代理(Proxy)</h3><h4 id="意图-11"><a href="#意图-11" class="headerlink" title="意图"></a>意图</h4><p>控制对其他对象的访问。</p><h4 id="类图-12"><a href="#类图-12" class="headerlink" title="类图"></a>类图</h4><p>代理有以下四类：</p><ul><li>远程代理(Remote Proxy)：控制对远程对象(不同地址空间)的访问，他负责将请求及其参数进行编码，并向不通过地址空间中的对象发送已经编码的请求。</li><li>虚拟代理(Virtual Proxy)：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。</li><li>保护代理(Protection Proxy)：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。</li><li>智能代理(Smart Reference)：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个持久化对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。</li></ul><p><img src="http://1.117.162.142:9000/blog/a6c20f60-5eba-427d-9413-352ada4b40fe.png"></p><h4 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h4><p>以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighResolutionImage</span> <span class="keyword">implements</span> <span class="title class_">Image</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> URL imageURL;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> startTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HighResolutionImage</span><span class="params">(URL imageURL)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.imageURL = imageURL;</span><br><span class="line">        <span class="built_in">this</span>.startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="built_in">this</span>.width = <span class="number">600</span>;</span><br><span class="line">        <span class="built_in">this</span>.height = <span class="number">600</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLoad</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟图片加载，延迟 3s 加载完成</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> endTime - startTime &gt; <span class="number">3000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Real Image: &quot;</span> + imageURL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProxy</span> <span class="keyword">implements</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HighResolutionImage highResolutionImage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageProxy</span><span class="params">(HighResolutionImage highResolutionImage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.highResolutionImage = highResolutionImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!highResolutionImage.isLoad()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Temp Image: &quot;</span> + highResolutionImage.getWidth() + <span class="string">&quot; &quot;</span> + highResolutionImage.getHeight());</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        highResolutionImage.showImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageViewer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">image</span> <span class="operator">=</span> <span class="string">&quot;http://image.jpg&quot;</span>;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(image);</span><br><span class="line">        <span class="type">HighResolutionImage</span> <span class="variable">highResolutionImage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HighResolutionImage</span>(url);</span><br><span class="line">        <span class="type">ImageProxy</span> <span class="variable">imageProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageProxy</span>(highResolutionImage);</span><br><span class="line">        imageProxy.showImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-行为型-责任链-Chain-Of-Responsibility"><a href="#14-行为型-责任链-Chain-Of-Responsibility" class="headerlink" title="14. 行为型 - 责任链(Chain Of Responsibility)"></a>14. 行为型 - 责任链(Chain Of Responsibility)</h3><h4 id="意图-12"><a href="#意图-12" class="headerlink" title="意图"></a>意图</h4><p>十多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，知道有一个对象处理它为止。</p><h4 id="类图-13"><a href="#类图-13" class="headerlink" title="类图"></a>类图</h4><p>Handler：定义处理请求的接口，并且实现后续链(successor)</p><p><img src="http://1.117.162.142:9000/blog/691f11eb-31a7-46be-9de1-61f433c4b3c7.png"></p><h4 id="实现-11"><a href="#实现-11" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler successor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteHandler1</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(successor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getType() == RequestType.type1) &#123;</span><br><span class="line">            System.out.println(request.getName() + <span class="string">&quot; is handle by ConcreteHandler1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (successor != <span class="literal">null</span>) &#123;</span><br><span class="line">            successor.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler2</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteHandler2</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(successor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getType() == RequestType.type2) &#123;</span><br><span class="line">            System.out.println(request.getName() + <span class="string">&quot; is handle by ConcreteHandler2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (successor != <span class="literal">null</span>) &#123;</span><br><span class="line">            successor.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RequestType type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Request</span><span class="params">(RequestType type, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RequestType <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestType</span> &#123;</span><br><span class="line">    type1, type2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">handler1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler1</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">handler2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler2</span>(handler1);</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(RequestType.type1, <span class="string">&quot;request1&quot;</span>);</span><br><span class="line">        handler2.handleRequest(request1);</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(RequestType.type2, <span class="string">&quot;request2&quot;</span>);</span><br><span class="line">        handler2.handleRequest(request2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request1 is handle by ConcreteHandler1</span><br><span class="line">request2 is handle by ConcreteHandler2</span><br></pre></td></tr></table></figure><h3 id="15-行为型-策略-Strategy"><a href="#15-行为型-策略-Strategy" class="headerlink" title="15. 行为型 - 策略(Strategy)"></a>15. 行为型 - 策略(Strategy)</h3><h4 id="意图-13"><a href="#意图-13" class="headerlink" title="意图"></a>意图</h4><p>定义一系列算法，封装每个算法，并使他们可以互换。</p><p>策略模式可以让算法独立于使用他的客户端。</p><h4 id="类图-14"><a href="#类图-14" class="headerlink" title="类图"></a>类图</h4><ul><li>Strategy 接口定义一个算法族，它们都具有 behavior() 方法。</li><li>Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(in Strategy) 方法可以动态地改变 strategy() 对象，也就是说能动态地改变 Context 所使用的算法。</li></ul><p><img src="http://1.117.162.142:9000/blog/strategy%E7%B1%BB%E5%9B%BE.png"></p><h4 id="与状态模式的笔记哦啊"><a href="#与状态模式的笔记哦啊" class="headerlink" title="与状态模式的笔记哦啊"></a>与状态模式的笔记哦啊</h4><p>状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 锁组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。</p><p>状态模式主要是用来解决状态转的的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。</p><h4 id="实现-12"><a href="#实现-12" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">QuackBehavior</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Quack</span> <span class="keyword">implements</span> <span class="title class_">QuackBehavior</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;quack!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Squeak</span> <span class="keyword">implements</span> <span class="title class_">QuackBehavior</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;squeak!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> QuackBehavior quackBehavior;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performQuack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (quackBehavior != <span class="literal">null</span>) &#123;</span><br><span class="line">            quackBehavior.quack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setQuackBehavior</span><span class="params">(QuackBehavior quackBehavior)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.quackBehavior = quackBehavior;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Duck</span> <span class="variable">duck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Duck</span>();</span><br><span class="line">        duck.setQuackBehavior(<span class="keyword">new</span> <span class="title class_">Squeak</span>());</span><br><span class="line">        duck.performQuack();</span><br><span class="line">        duck.setQuackBehavior(<span class="keyword">new</span> <span class="title class_">Quack</span>());</span><br><span class="line">        duck.performQuack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">squeak!</span><br><span class="line">quack!</span><br></pre></td></tr></table></figure><h3 id="16-行为型-模版方法-Template-Method"><a href="#16-行为型-模版方法-Template-Method" class="headerlink" title="16. 行为型 - 模版方法(Template Method)"></a>16. 行为型 - 模版方法(Template Method)</h3><h4 id="意图-14"><a href="#意图-14" class="headerlink" title="意图"></a>意图</h4><p>定义算法框架，并将一些步骤的实现延迟到子类。</p><p>通过模版方法，子类可以重新定义的某些步骤，而不用改变算法的结构。</p><h4 id="类图-15"><a href="#类图-15" class="headerlink" title="类图"></a>类图</h4><p><img src="http://1.117.162.142:9000/blog/templateMethod%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-13"><a href="#实现-13" class="headerlink" title="实现"></a>实现</h4><p>冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。</p><p><img src="http://1.117.162.142:9000/blog/11236498-1417-46ce-a1b0-e10054256955.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CaffeineBeverage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">prepareRecipe</span><span class="params">()</span> &#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">boilWater</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;boilWater&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pourInCup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;pourInCup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> <span class="keyword">extends</span> <span class="title class_">CaffeineBeverage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Coffee.brew&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Coffee.addCondiments&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tea</span> <span class="keyword">extends</span> <span class="title class_">CaffeineBeverage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">brew</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tea.brew&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tea.addCondiments&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CaffeineBeverage</span> <span class="variable">caffeineBeverage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Coffee</span>();</span><br><span class="line">        caffeineBeverage.prepareRecipe();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        caffeineBeverage = <span class="keyword">new</span> <span class="title class_">Tea</span>();</span><br><span class="line">        caffeineBeverage.prepareRecipe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">boilWater</span><br><span class="line">Coffee.brew</span><br><span class="line">pourInCup</span><br><span class="line">Coffee.addCondiments</span><br><span class="line">-----------</span><br><span class="line">boilWater</span><br><span class="line">Tea.brew</span><br><span class="line">pourInCup</span><br><span class="line">Tea.addCondiments</span><br></pre></td></tr></table></figure><h3 id="17-行为型-命令模式-command"><a href="#17-行为型-命令模式-command" class="headerlink" title="17. 行为型 - 命令模式(command)"></a>17. 行为型 - 命令模式(command)</h3><h4 id="意图-15"><a href="#意图-15" class="headerlink" title="意图"></a>意图</h4><p>将命令封装在对象中，以便使用命令来参数化其它对象，或者将命令对象放入队列中进行排队，或者将命对象的操作记录到日志中，以及支持可撤销的操作。</p><h4 id="类图-16"><a href="#类图-16" class="headerlink" title="类图"></a>类图</h4><ul><li>Command：命令</li><li>Receiver：命令接受者，也就是命令真正的执行者</li><li>Invoker：通过它来调用命令</li><li>Client：可以设置命令与命令的接受者</li></ul><p><img src="http://1.117.162.142:9000/blog/Command%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-14"><a href="#实现-14" class="headerlink" title="实现"></a>实现</h4><p>设计一个遥控器，可以控制电灯开关。</p><p><img src="http://1.117.162.142:9000/blog/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-01.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOnCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    Light light;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightOnCommand</span><span class="params">(Light light)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOffCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    Light light;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightOffCommand</span><span class="params">(Light light)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        light.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Light is on!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Light is off!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command[] onCommands;</span><br><span class="line">    <span class="keyword">private</span> Command[] offCommands;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">slotNum</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onCommands = <span class="keyword">new</span> <span class="title class_">Command</span>[slotNum];</span><br><span class="line">        <span class="built_in">this</span>.offCommands = <span class="keyword">new</span> <span class="title class_">Command</span>[slotNum];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnCommand</span><span class="params">(Command command, <span class="type">int</span> slot)</span> &#123;</span><br><span class="line">        onCommands[slot] = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOffCommand</span><span class="params">(Command command, <span class="type">int</span> slot)</span> &#123;</span><br><span class="line">        offCommands[slot] = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onButtonWasPushed</span><span class="params">(<span class="type">int</span> slot)</span> &#123;</span><br><span class="line">        onCommands[slot].execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offButtonWasPushed</span><span class="params">(<span class="type">int</span> slot)</span> &#123;</span><br><span class="line">        offCommands[slot].execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invoker</span>();</span><br><span class="line">        <span class="type">Light</span> <span class="variable">light</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">        <span class="type">Command</span> <span class="variable">lightOnCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightOnCommand</span>(light);</span><br><span class="line">        <span class="type">Command</span> <span class="variable">lightOffCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightOffCommand</span>(light);</span><br><span class="line">        invoker.setOnCommand(lightOnCommand, <span class="number">0</span>);</span><br><span class="line">        invoker.setOffCommand(lightOffCommand, <span class="number">0</span>);</span><br><span class="line">        invoker.onButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">        invoker.offButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-行为型-观察者-Observer"><a href="#18-行为型-观察者-Observer" class="headerlink" title="18. 行为型 - 观察者(Observer)"></a>18. 行为型 - 观察者(Observer)</h3><h4 id="意图-16"><a href="#意图-16" class="headerlink" title="意图"></a>意图</h4><p>主题(Subject)是被观察的对象，而其所有依赖者(Observer)称为观察者。</p><p><img src="http://1.117.162.142:9000/blog/%E8%A7%82%E5%AF%9F%E8%80%85-01.jpeg"></p><h4 id="类图-17"><a href="#类图-17" class="headerlink" title="类图"></a>类图</h4><p>主题(Subject)具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p><p>观察者(Observer)的注册功能需要调用主题的 registerObserver()方法。</p><p><img src="http://1.117.162.142:9000/blog/Observer%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-15"><a href="#实现-15" class="headerlink" title="实现"></a>实现</h4><p>天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。</p><p><img src="http://1.117.162.142:9000/blog/%E8%A7%82%E5%AF%9F%E8%80%85-02.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">resisterObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherData</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherData</span><span class="params">()</span> &#123;</span><br><span class="line">        observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMeasurements</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resisterObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer o : observers) &#123;</span><br><span class="line">            o.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatisticsDisplay</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StatisticsDisplay</span><span class="params">(Subject weatherData)</span> &#123;</span><br><span class="line">        weatherData.resisterObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;StatisticsDisplay.update: &quot;</span> + temp + <span class="string">&quot; &quot;</span> + humidity + <span class="string">&quot; &quot;</span> + pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CurrentConditionsDisplay</span><span class="params">(Subject weatherData)</span> &#123;</span><br><span class="line">        weatherData.resisterObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CurrentConditionsDisplay.update: &quot;</span> + temp + <span class="string">&quot; &quot;</span> + humidity + <span class="string">&quot; &quot;</span> + pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherStation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WeatherData</span> <span class="variable">weatherData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherData</span>();</span><br><span class="line">        <span class="type">CurrentConditionsDisplay</span> <span class="variable">currentConditionsDisplay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CurrentConditionsDisplay</span>(weatherData);</span><br><span class="line">        <span class="type">StatisticsDisplay</span> <span class="variable">statisticsDisplay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StatisticsDisplay</span>(weatherData);</span><br><span class="line"></span><br><span class="line">        weatherData.setMeasurements(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CurrentConditionsDisplay.update: 0.0 0.0 0.0</span><br><span class="line">StatisticsDisplay.update: 0.0 0.0 0.0</span><br><span class="line">CurrentConditionsDisplay.update: 1.0 1.0 1.0</span><br><span class="line">StatisticsDisplay.update: 1.0 1.0 1.0</span><br></pre></td></tr></table></figure><h3 id="19-行为型-访问者-Visitor"><a href="#19-行为型-访问者-Visitor" class="headerlink" title="19. 行为型 - 访问者(Visitor)"></a>19. 行为型 - 访问者(Visitor)</h3><h4 id="意图-17"><a href="#意图-17" class="headerlink" title="意图"></a>意图</h4><p>为一个对象结构(比如组合结构)增加新能力</p><h4 id="类图-18"><a href="#类图-18" class="headerlink" title="类图"></a>类图</h4><ul><li>Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作</li><li>ConcreteVisitor：具体访问者，存储遍历过程中的累积结果</li><li>ObjectStructure：对象结构，可以是组合结构，或者是一个集合</li></ul><p><img src="http://1.117.162.142:9000/blog/Visitor%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-16"><a href="#实现-16" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomerGroup</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Customer&gt; customers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Customer customer : customers) &#123;</span><br><span class="line">            customer.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addCustomer</span><span class="params">(Customer customer)</span> &#123;</span><br><span class="line">        customers.add(customer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> <span class="keyword">implements</span> <span class="title class_">Element</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Customer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        orders.add(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">for</span> (Order order : orders) &#123;</span><br><span class="line">            order.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> <span class="keyword">implements</span> <span class="title class_">Element</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Item&gt; items = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">    Order(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Order(String name, String itemName) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.addItem(<span class="keyword">new</span> <span class="title class_">Item</span>(itemName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        items.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">            item.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> <span class="keyword">implements</span> <span class="title class_">Element</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Item(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Visitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Customer customer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Order order)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Item item)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralReport</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> customersNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> ordersNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> itemsNo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Customer customer)</span> &#123;</span><br><span class="line">        System.out.println(customer.getName());</span><br><span class="line">        customersNo++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        System.out.println(order.getName());</span><br><span class="line">        ordersNo++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        System.out.println(item.getName());</span><br><span class="line">        itemsNo++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayResults</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Number of customers: &quot;</span> + customersNo);</span><br><span class="line">        System.out.println(<span class="string">&quot;Number of orders:    &quot;</span> + ordersNo);</span><br><span class="line">        System.out.println(<span class="string">&quot;Number of items:     &quot;</span> + itemsNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;customer1&quot;</span>);</span><br><span class="line">        customer1.addOrder(<span class="keyword">new</span> <span class="title class_">Order</span>(<span class="string">&quot;order1&quot;</span>, <span class="string">&quot;item1&quot;</span>));</span><br><span class="line">        customer1.addOrder(<span class="keyword">new</span> <span class="title class_">Order</span>(<span class="string">&quot;order2&quot;</span>, <span class="string">&quot;item1&quot;</span>));</span><br><span class="line">        customer1.addOrder(<span class="keyword">new</span> <span class="title class_">Order</span>(<span class="string">&quot;order3&quot;</span>, <span class="string">&quot;item1&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="string">&quot;order_a&quot;</span>);</span><br><span class="line">        order.addItem(<span class="keyword">new</span> <span class="title class_">Item</span>(<span class="string">&quot;item_a1&quot;</span>));</span><br><span class="line">        order.addItem(<span class="keyword">new</span> <span class="title class_">Item</span>(<span class="string">&quot;item_a2&quot;</span>));</span><br><span class="line">        order.addItem(<span class="keyword">new</span> <span class="title class_">Item</span>(<span class="string">&quot;item_a3&quot;</span>));</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;customer2&quot;</span>);</span><br><span class="line">        customer2.addOrder(order);</span><br><span class="line"></span><br><span class="line">        <span class="type">CustomerGroup</span> <span class="variable">customers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomerGroup</span>();</span><br><span class="line">        customers.addCustomer(customer1);</span><br><span class="line">        customers.addCustomer(customer2);</span><br><span class="line"></span><br><span class="line">        <span class="type">GeneralReport</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralReport</span>();</span><br><span class="line">        customers.accept(visitor);</span><br><span class="line">        visitor.displayResults();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">customer1</span><br><span class="line">order1</span><br><span class="line">item1</span><br><span class="line">order2</span><br><span class="line">item1</span><br><span class="line">order3</span><br><span class="line">item1</span><br><span class="line">customer2</span><br><span class="line">order_a</span><br><span class="line">item_a1</span><br><span class="line">item_a2</span><br><span class="line">item_a3</span><br><span class="line">Number of customers: <span class="number">2</span></span><br><span class="line">Number of orders:    <span class="number">4</span></span><br><span class="line">Number of items:     <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="20-行为型-状态-State"><a href="#20-行为型-状态-State" class="headerlink" title="20. 行为型 - 状态(State)"></a>20. 行为型 - 状态(State)</h3><h4 id="意图-18"><a href="#意图-18" class="headerlink" title="意图"></a>意图</h4><p>允许对象在内部状态改变时，改变它的行为，对象看起来好像修改了它所属的类。</p><h4 id="类图-19"><a href="#类图-19" class="headerlink" title="类图"></a>类图</h4><p><img src="http://1.117.162.142:9000/blog/State%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-17"><a href="#实现-17" class="headerlink" title="实现"></a>实现</h4><p>糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。</p><p><img src="http://1.117.162.142:9000/blog/%E7%8A%B6%E6%80%81-01.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 投入 25 分钱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 退回 25 分钱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转动曲柄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发放糖果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HasQuarterState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HasQuarterState</span><span class="params">(GumballMachine gumballMachine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You can&#x27;t insert another quarter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Quarter returned&quot;</span>);</span><br><span class="line">        gumballMachine.setState(gumballMachine.getNoQuarterState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You turned...&quot;</span>);</span><br><span class="line">        gumballMachine.setState(gumballMachine.getSoldState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;No gumball dispensed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoQuarterState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    GumballMachine gumballMachine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NoQuarterState</span><span class="params">(GumballMachine gumballMachine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You insert a quarter&quot;</span>);</span><br><span class="line">        gumballMachine.setState(gumballMachine.getHasQuarterState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You haven&#x27;t insert a quarter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You turned, but there&#x27;s no quarter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You need to pay first&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoldOutState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    GumballMachine gumballMachine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SoldOutState</span><span class="params">(GumballMachine gumballMachine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You can&#x27;t insert a quarter, the machine is sold out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You can&#x27;t eject, you haven&#x27;t inserted a quarter yet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;You turned, but there are no gumballs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;No gumball dispensed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoldState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line"></span><br><span class="line">    GumballMachine gumballMachine;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SoldState</span><span class="params">(GumballMachine gumballMachine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Please wait, we&#x27;re already giving you a gumball&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sorry, you already turned the crank&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Turning twice doesn&#x27;t get you another gumball!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span> &#123;</span><br><span class="line">        gumballMachine.releaseBall();</span><br><span class="line">        <span class="keyword">if</span> (gumballMachine.getCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            gumballMachine.setState(gumballMachine.getNoQuarterState());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Oops, out of gumballs&quot;</span>);</span><br><span class="line">            gumballMachine.setState(gumballMachine.getSoldOutState());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GumballMachine</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> State soldOutState;</span><br><span class="line">    <span class="keyword">private</span> State noQuarterState;</span><br><span class="line">    <span class="keyword">private</span> State hasQuarterState;</span><br><span class="line">    <span class="keyword">private</span> State soldState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GumballMachine</span><span class="params">(<span class="type">int</span> numberGumballs)</span> &#123;</span><br><span class="line">        count = numberGumballs;</span><br><span class="line">        soldOutState = <span class="keyword">new</span> <span class="title class_">SoldOutState</span>(<span class="built_in">this</span>);</span><br><span class="line">        noQuarterState = <span class="keyword">new</span> <span class="title class_">NoQuarterState</span>(<span class="built_in">this</span>);</span><br><span class="line">        hasQuarterState = <span class="keyword">new</span> <span class="title class_">HasQuarterState</span>(<span class="built_in">this</span>);</span><br><span class="line">        soldState = <span class="keyword">new</span> <span class="title class_">SoldState</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numberGumballs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            state = noQuarterState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            state = soldOutState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        state.insertQuarter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">        state.ejectQuarter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span> &#123;</span><br><span class="line">        state.turnCrank();</span><br><span class="line">        state.dispense();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseBall</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A gumball comes rolling out the slot...&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            count -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getSoldOutState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> soldOutState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getNoQuarterState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> noQuarterState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getHasQuarterState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hasQuarterState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getSoldState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> soldState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GumballMachine</span> <span class="variable">gumballMachine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GumballMachine</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        gumballMachine.insertQuarter();</span><br><span class="line">        gumballMachine.turnCrank();</span><br><span class="line"></span><br><span class="line">        gumballMachine.insertQuarter();</span><br><span class="line">        gumballMachine.ejectQuarter();</span><br><span class="line">        gumballMachine.turnCrank();</span><br><span class="line"></span><br><span class="line">        gumballMachine.insertQuarter();</span><br><span class="line">        gumballMachine.turnCrank();</span><br><span class="line">        gumballMachine.insertQuarter();</span><br><span class="line">        gumballMachine.turnCrank();</span><br><span class="line">        gumballMachine.ejectQuarter();</span><br><span class="line"></span><br><span class="line">        gumballMachine.insertQuarter();</span><br><span class="line">        gumballMachine.insertQuarter();</span><br><span class="line">        gumballMachine.turnCrank();</span><br><span class="line">        gumballMachine.insertQuarter();</span><br><span class="line">        gumballMachine.turnCrank();</span><br><span class="line">        gumballMachine.insertQuarter();</span><br><span class="line">        gumballMachine.turnCrank();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">You insert a quarter</span><br><span class="line">You turned...</span><br><span class="line">A gumball comes rolling out the slot...</span><br><span class="line">You insert a quarter</span><br><span class="line">Quarter returned</span><br><span class="line">You turned, but there<span class="string">&#x27;s no quarter</span></span><br><span class="line"><span class="string">You need to pay first</span></span><br><span class="line"><span class="string">You insert a quarter</span></span><br><span class="line"><span class="string">You turned...</span></span><br><span class="line"><span class="string">A gumball comes rolling out the slot...</span></span><br><span class="line"><span class="string">You insert a quarter</span></span><br><span class="line"><span class="string">You turned...</span></span><br><span class="line"><span class="string">A gumball comes rolling out the slot...</span></span><br><span class="line"><span class="string">You haven&#x27;</span>t insert a quarter</span><br><span class="line">You insert a quarter</span><br><span class="line">You can<span class="string">&#x27;t insert another quarter</span></span><br><span class="line"><span class="string">You turned...</span></span><br><span class="line"><span class="string">A gumball comes rolling out the slot...</span></span><br><span class="line"><span class="string">You insert a quarter</span></span><br><span class="line"><span class="string">You turned...</span></span><br><span class="line"><span class="string">A gumball comes rolling out the slot...</span></span><br><span class="line"><span class="string">Oops, out of gumballs</span></span><br><span class="line"><span class="string">You can&#x27;</span>t insert a quarter, the machine is sold out</span><br><span class="line">You turned, but there are no gumballs</span><br><span class="line">No gumball dispensed</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="21-行为型-解释器-Interpreter"><a href="#21-行为型-解释器-Interpreter" class="headerlink" title="21. 行为型 - 解释器(Interpreter)"></a>21. 行为型 - 解释器(Interpreter)</h3><h4 id="意图-19"><a href="#意图-19" class="headerlink" title="意图"></a>意图</h4><p>为语言创建解释器，通常由语言的语法和语法分析来定义。</p><h4 id="类图-20"><a href="#类图-20" class="headerlink" title="类图"></a>类图</h4><ul><li>TerminalExpression：终结符表达式，每个终结符都需要一个 TerminalExpression</li><li>Context：上下文，包含解释器之外的一些全局信息</li></ul><p><img src="http://1.117.162.142:9000/blog/Interpreter%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-18"><a href="#实现-18" class="headerlink" title="实现"></a>实现</h4><p>以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。</p><p>例如一颗解析树为 D And (A or (B C))，文本 “D A”满足该解析树定义的规则。</p><p>这里的 Context 指的是 String。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TerminalExpression</span> <span class="keyword">extends</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">literal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TerminalExpression</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        literal = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">StringTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(str);</span><br><span class="line">        <span class="keyword">while</span> (st.hasMoreTokens()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> st.nextToken();</span><br><span class="line">            <span class="keyword">if</span> (test.equals(literal)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AndExpression</span> <span class="keyword">extends</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Expression</span> <span class="variable">expression1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Expression</span> <span class="variable">expression2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AndExpression</span><span class="params">(Expression expression1, Expression expression2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.expression1 = expression1;</span><br><span class="line">        <span class="built_in">this</span>.expression2 = expression2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> expression1.interpret(str) &amp;&amp; expression2.interpret(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrExpression</span> <span class="keyword">extends</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Expression</span> <span class="variable">expression1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Expression</span> <span class="variable">expression2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrExpression</span><span class="params">(Expression expression1, Expression expression2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.expression1 = expression1;</span><br><span class="line">        <span class="built_in">this</span>.expression2 = expression2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">interpret</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> expression1.interpret(str) || expression2.interpret(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建解析树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title function_">buildInterpreterTree</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Literal</span></span><br><span class="line">        <span class="type">Expression</span> <span class="variable">terminal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TerminalExpression</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="type">Expression</span> <span class="variable">terminal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TerminalExpression</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="type">Expression</span> <span class="variable">terminal3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TerminalExpression</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        <span class="type">Expression</span> <span class="variable">terminal4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TerminalExpression</span>(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">        <span class="comment">// B C</span></span><br><span class="line">        <span class="type">Expression</span> <span class="variable">alternation1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrExpression</span>(terminal2, terminal3);</span><br><span class="line">        <span class="comment">// A Or (B C)</span></span><br><span class="line">        <span class="type">Expression</span> <span class="variable">alternation2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrExpression</span>(terminal1, alternation1);</span><br><span class="line">        <span class="comment">// D And (A Or (B C))</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AndExpression</span>(terminal4, alternation2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Expression</span> <span class="variable">define</span> <span class="operator">=</span> buildInterpreterTree();</span><br><span class="line">        <span class="type">String</span> <span class="variable">context1</span> <span class="operator">=</span> <span class="string">&quot;D A&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">context2</span> <span class="operator">=</span> <span class="string">&quot;A B&quot;</span>;</span><br><span class="line">        System.out.println(define.interpret(context1));</span><br><span class="line">        System.out.println(define.interpret(context2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h3 id="22-行为型-迭代器-Iterator"><a href="#22-行为型-迭代器-Iterator" class="headerlink" title="22. 行为型 - 迭代器(Iterator)"></a>22. 行为型 - 迭代器(Iterator)</h3><h4 id="意图-20"><a href="#意图-20" class="headerlink" title="意图"></a>意图</h4><p>提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。</p><h4 id="类图-21"><a href="#类图-21" class="headerlink" title="类图"></a>类图</h4><ul><li>Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator；</li><li>Iterator 主要定义了 ha sNext() 和 next() 方法。</li><li>Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。</li></ul><p><img src="http://1.117.162.142:9000/blog/Iterator%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-19"><a href="#实现-19" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line">    Iterator <span class="title function_">createIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title class_">Aggregate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer[] items;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteAggregate</span><span class="params">()</span> &#123;</span><br><span class="line">        items = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            items[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>&lt;Integer&gt;(items);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;Item&gt; &#123;</span><br><span class="line">    Item <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span>&lt;Item&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Item[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">(Item[] items)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.items = items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[position++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; items.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Aggregate</span> <span class="variable">aggregate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteAggregate</span>();</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = aggregate.createIterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-行为型-中介者-Mediator"><a href="#23-行为型-中介者-Mediator" class="headerlink" title="23. 行为型 - 中介者(Mediator)"></a>23. 行为型 - 中介者(Mediator)</h3><h4 id="意图-21"><a href="#意图-21" class="headerlink" title="意图"></a>意图</h4><p>集中相关对象之间复杂的沟通和控制方式。</p><h4 id="类图-22"><a href="#类图-22" class="headerlink" title="类图"></a>类图</h4><ul><li>Mediator：中介者，定义一个接口用于与各同时(Colleague)对象通信。</li><li>Colleague：同事，相关对象</li></ul><p><img src="http://1.117.162.142:9000/blog/Mediator%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-20"><a href="#实现-20" class="headerlink" title="实现"></a>实现</h4><p>Alarm(闹钟)、CoffeePot(咖啡壶)、Calendar(日历)、Sprinkler(喷头)是一组相关的对象，在某个对象的时间产生时需要去操作其它对象，形成了下面这种依赖结构：</p><p><img src="http://1.117.162.142:9000/blog/%E4%B8%AD%E4%BB%8B%E8%80%85-01.jpeg"></p><p><img src="http://1.117.162.142:9000/blog/%E4%B8%AD%E4%BB%8B%E8%80%85-02.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Mediator mediator)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alarm</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        mediator.doEvent(<span class="string">&quot;alarm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAlarm</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doAlarm()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeePot</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        mediator.doEvent(<span class="string">&quot;coffeePot&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCoffeePot</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doCoffeePot()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calender</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        mediator.doEvent(<span class="string">&quot;calender&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCalender</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doCalender()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sprinkler</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        mediator.doEvent(<span class="string">&quot;sprinkler&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSprinkler</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSprinkler()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doEvent</span><span class="params">(String eventType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Alarm alarm;</span><br><span class="line">    <span class="keyword">private</span> CoffeePot coffeePot;</span><br><span class="line">    <span class="keyword">private</span> Calender calender;</span><br><span class="line">    <span class="keyword">private</span> Sprinkler sprinkler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteMediator</span><span class="params">(Alarm alarm, CoffeePot coffeePot, Calender calender, Sprinkler sprinkler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.alarm = alarm;</span><br><span class="line">        <span class="built_in">this</span>.coffeePot = coffeePot;</span><br><span class="line">        <span class="built_in">this</span>.calender = calender;</span><br><span class="line">        <span class="built_in">this</span>.sprinkler = sprinkler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doEvent</span><span class="params">(String eventType)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;alarm&quot;</span>:</span><br><span class="line">                doAlarmEvent();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;coffeePot&quot;</span>:</span><br><span class="line">                doCoffeePotEvent();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;calender&quot;</span>:</span><br><span class="line">                doCalenderEvent();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                doSprinklerEvent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAlarmEvent</span><span class="params">()</span> &#123;</span><br><span class="line">        alarm.doAlarm();</span><br><span class="line">        coffeePot.doCoffeePot();</span><br><span class="line">        calender.doCalender();</span><br><span class="line">        sprinkler.doSprinkler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCoffeePotEvent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCalenderEvent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSprinklerEvent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Alarm</span> <span class="variable">alarm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Alarm</span>();</span><br><span class="line">        <span class="type">CoffeePot</span> <span class="variable">coffeePot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CoffeePot</span>();</span><br><span class="line">        <span class="type">Calender</span> <span class="variable">calender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calender</span>();</span><br><span class="line">        <span class="type">Sprinkler</span> <span class="variable">sprinkler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sprinkler</span>();</span><br><span class="line">        <span class="type">Mediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteMediator</span>(alarm, coffeePot, calender, sprinkler);</span><br><span class="line">        <span class="comment">// 闹钟事件到达，调用中介者就可以操作相关对象</span></span><br><span class="line">        alarm.onEvent(mediator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doAlarm()</span><br><span class="line">doCoffeePot()</span><br><span class="line">doCalender()</span><br><span class="line">doSprinkler()</span><br></pre></td></tr></table></figure><h3 id="24-行为型-备忘录-Memento"><a href="#24-行为型-备忘录-Memento" class="headerlink" title="24. 行为型 - 备忘录(Memento)"></a>24. 行为型 - 备忘录(Memento)</h3><h4 id="意图-22"><a href="#意图-22" class="headerlink" title="意图"></a>意图</h4><p>在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。</p><h4 id="类图-23"><a href="#类图-23" class="headerlink" title="类图"></a>类图</h4><ul><li>Originator：原始对象</li><li>Caretaker：负责保存好备忘录</li><li>Memento：备忘录，存储原始对象的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况下只允许 Originator 访问本备忘录的内部状态。</li></ul><p><img src="http://1.117.162.142:9000/blog/Memento%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-21"><a href="#实现-21" class="headerlink" title="实现"></a>实现</h4><p>以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create Memento</span></span><br><span class="line">    PreviousCalculationToCareTaker <span class="title function_">backupLastCalculation</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setMemento</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">restorePreviousCalculation</span><span class="params">(PreviousCalculationToCareTaker memento)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getCalculationResult</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setFirstNumber</span><span class="params">(<span class="type">int</span> firstNumber)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setSecondNumber</span><span class="params">(<span class="type">int</span> secondNumber)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorImp</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> firstNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> secondNumber;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PreviousCalculationToCareTaker <span class="title function_">backupLastCalculation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// create a memento object used for restoring two numbers</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PreviousCalculationImp</span>(firstNumber, secondNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restorePreviousCalculation</span><span class="params">(PreviousCalculationToCareTaker memento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstNumber = ((PreviousCalculationToOriginator) memento).getFirstNumber();</span><br><span class="line">        <span class="built_in">this</span>.secondNumber = ((PreviousCalculationToOriginator) memento).getSecondNumber();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCalculationResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// result is adding two numbers</span></span><br><span class="line">        <span class="keyword">return</span> firstNumber + secondNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirstNumber</span><span class="params">(<span class="type">int</span> firstNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstNumber = firstNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecondNumber</span><span class="params">(<span class="type">int</span> secondNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.secondNumber = secondNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PreviousCalculationToOriginator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getFirstNumber</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getSecondNumber</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PreviousCalculationToCareTaker</span> &#123;</span><br><span class="line">    <span class="comment">// no operations permitted for the caretaker</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreviousCalculationImp</span> <span class="keyword">implements</span> <span class="title class_">PreviousCalculationToCareTaker</span>,</span><br><span class="line">        PreviousCalculationToOriginator &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> firstNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> secondNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PreviousCalculationImp</span><span class="params">(<span class="type">int</span> firstNumber, <span class="type">int</span> secondNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstNumber = firstNumber;</span><br><span class="line">        <span class="built_in">this</span>.secondNumber = secondNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirstNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSecondNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> secondNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// program starts</span></span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalculatorImp</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// assume user enters two numbers</span></span><br><span class="line">        calculator.setFirstNumber(<span class="number">10</span>);</span><br><span class="line">        calculator.setSecondNumber(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find result</span></span><br><span class="line">        System.out.println(calculator.getCalculationResult());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Store result of this calculation in case of error</span></span><br><span class="line">        <span class="type">PreviousCalculationToCareTaker</span> <span class="variable">memento</span> <span class="operator">=</span> calculator.backupLastCalculation();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// user enters a number</span></span><br><span class="line">        calculator.setFirstNumber(<span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// user enters a wrong second number and calculates result</span></span><br><span class="line">        calculator.setSecondNumber(-<span class="number">290</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// calculate result</span></span><br><span class="line">        System.out.println(calculator.getCalculationResult());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// user hits CTRL + Z to undo last operation and see last result</span></span><br><span class="line">        calculator.restorePreviousCalculation(memento);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// result restored</span></span><br><span class="line">        System.out.println(calculator.getCalculationResult());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">110</span><br><span class="line">-273</span><br><span class="line">110</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴JAVA开发手册</title>
      <link href="/2022/12/12/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4JAVA%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/"/>
      <url>/2022/12/12/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4JAVA%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h3><h4 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h4><ul><li><p>类名使用大驼峰(UpperCamelCase)风格，但是如果类名包含<code>DO/BO/DTO/VO/AO/PO/UID</code>等，以下必须大写。例如：UserDO&#x2F;UserDTO</p></li><li><p>方法名、参数名、成员变量、局部变量统一使用小驼峰(lowerCamelCase)风格，必须遵从驼峰形式。</p></li><li><p>常量命名全部大写，单词间用下划线隔开，要求语义表达完整，即使名字长也没关系。</p></li><li><p>抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类 命名以它要测试的类的名称开始，以 Test 结尾。</p></li><li><p>包名统一使用小写，单数形式，类名如果有复数含义，类名可以使用复数形式。例如：应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils</p></li><li><p>杜绝完全不规范的缩写，避免望文不知义。</p></li><li><p>接口类中的方法和属性不要加任何修饰符号。</p></li><li><p>各层命名规约： </p><ul><li>A) Service&#x2F;DAO 层方法命名规约 <ul><li>1） 获取单个对象的方法用 get 做前缀。</li><li>2） 获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。 </li><li>3） 获取统计值的方法用 count 做前缀。 </li><li>4） 插入的方法用 save&#x2F;insert 做前缀。 </li><li>5） 删除的方法用 remove&#x2F;delete 做前缀。 </li><li>6） 修改的方法用 update 做前缀。</li></ul></li><li>B) 领域模型命名规约 <ul><li>1） 数据对象：xxxDO，xxx 即为数据表名。 </li><li>2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。 </li><li>3） 展示对象：xxxVO，xxx 一般为网页名称。 </li><li>4） POJO 是 DO&#x2F;DTO&#x2F;BO&#x2F;VO 的统称，禁止命名成 xxxPOJO。</li></ul></li></ul></li></ul><h4 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h4><ul><li>在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数 字 1 混淆，造成误解。</li></ul><h4 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h4><ul><li><p>如果是大括号内为空，则简洁地写成{}即可，大括号中间无需换行和空格</p></li><li><p>左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格；而左 大括号前需要空格。</p></li><li><p>if&#x2F;for&#x2F;while&#x2F;switch&#x2F;do 等保留字与括号之间都必须加空格。</p></li><li><p>任何二目、三目运算符的左右两边都需要加一个空格。(“+”  “-“  “*”  “&#x2F;“  “&#x3D;”  “&amp;&amp;”  “||”)</p></li><li><p>注释的双斜线与注释内容之间有且仅有一个空格。</p></li><li><p>在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开。<code>long first = 1000000000000L; int second = (int)first + 2; </code></p></li><li><p>方法参数在定义和传入时，多个参数逗号后边必须加空格。</p></li></ul><h4 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h4><ul><li><p>避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析 成本，直接用类名来访问即可。</p></li><li><p>所有的覆写方法，必须加@Override 注解。</p></li><li><p>相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）</p></li><li><p>外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产 生影响。接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。</p></li><li><p>不能使用过时的类或方法。</p></li><li><p>Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</p></li><li><p>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</p></li><li><p>定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。数据库字段的 bigint 必须与类属性的 Long 类型相对应。</p></li><li><p>所有的 POJO 类属性必须使用包装数据类型。RPC 方法的返回值和参数必须使用包装数据类型。所有的局部变量使用基本数据类型。</p></li><li><p>定义 DO&#x2F;DTO&#x2F;VO 等 POJO 类时，不要设定任何属性默认值。</p></li><li><p>序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果 完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。</p></li><li><p>构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。</p></li><li><p>POJO 类必须写 toString 方法。</p></li><li><p>类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter &#x2F; setter 方法。</p></li></ul><h4 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h4><h4 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h4><ul><li><p>获取单例对象需要保证线程安全，其中的方法也要保证线程安全</p></li><li><p>创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</p></li><li><p>线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p></li><li><p>高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁； 能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</p></li><li><p>对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会 造成死锁。</p></li><li><p>在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代 码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。</p></li></ul><h4 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h4><ul><li>在一个 switch 块内，每个 case 要么通过 continue&#x2F;break&#x2F;return 等来终止，要么 注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。注意 break 是退出 switch 语句块，而 return 是退出方法体。</li><li>在 if&#x2F;else&#x2F;for&#x2F;while&#x2F;do 语句中必须使用大括号。</li><li>在高并发场景中，避免使用”等于”判断作为中断或退出的条件。</li></ul><h4 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h4><ul><li>类、类属性、类方法的注释必须使用 Javadoc 规范，使用&#x2F;*<em>内容</em>&#x2F;格式，不得使用 &#x2F;&#x2F; xxx 方式。</li><li>所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。</li><li>所有的类都必须添加创建者和创建日期。</li><li>方法内部单行注释，在被注释语句上方另起一行，使用&#x2F;&#x2F;注释。方法内部多行注释 使用&#x2F;* *&#x2F;注释，注意与代码对齐。</li><li>所有的枚举类型字段必须要有注释，说明每个数据项的用途。</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。</li><li>注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够 取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后 取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。</li><li>获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();</li><li>日期格式化时，传入 pattern 中表示年份统一使用小写的 y。表示月份是大写的 M；表示分钟则是小写的 m；24 小时制的是大写的 H；12 小时制的则是小写的 h。new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);</li></ul><h3 id="异常日志"><a href="#异常日志" class="headerlink" title="异常日志"></a>异常日志</h3><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul><li>Java 类库中定义的可以通过预检查方式规避的 RuntimeException 异常不应该通 过 catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等 等。</li><li>异常不要用来做流程控制，条件控制。</li><li>catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。 对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。</li><li>捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它， 请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理 解的内容。</li><li>有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回 滚事务。</li><li>finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。</li><li>不要在 finally 块中使用 return。</li><li>捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类</li><li>在调用 RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用 Throwable 类来进行拦截。</li></ul><h4 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h4><ul><li>应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</li><li>所有日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。网络 运行状态、安全相关信息、系统监测、管理后台操作、用户敏感操作需要留存相关的网络日 志不少于 6 个月。</li><li>应用中的扩展日志（如打点、临时监控、访问日志等）命名方式： appName_logType_logName.log。logType:日志类型，如 stats&#x2F;monitor&#x2F;access 等；logName:日志 描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归 类查找。</li><li>在日志输出时，字符串变量之间的拼接使用占位符的方式。</li><li>对于 trace&#x2F;debug&#x2F;info 级别的日志输出，必须进行日志级别的开关判断。</li><li>避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity&#x3D;false。</li><li>异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通 过关键字 throws 往上抛出。</li></ul><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul><li>好的单元测试必须遵守 AIR 原则。</li><li>单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的， 执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。 单元测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。</li><li>保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之 间决不能互相调用，也不能依赖执行的先后次序。</li><li>单元测试是可以重复执行的，不能受到外界环境的影响。</li><li>对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类 级别，一般是方法级别。</li><li>核心业务、核心应用、核心模块的增量代码确保单元测试通过。</li><li>单元测试代码必须写在如下工程目录：src&#x2F;test&#x2F;java，不允许写在业务代码目录下。</li></ul><h3 id="安全规约"><a href="#安全规约" class="headerlink" title="安全规约"></a>安全规约</h3><ul><li>隶属于用户个人的页面或者功能必须进行权限控制校验。</li><li>用户敏感数据禁止直接展示，必须对展示数据进行脱敏。中国大陆个人手机号码显示为:137****0969，隐藏中间 4 位，防止隐私泄露。</li><li>用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注 入，禁止字符串拼接 SQL 访问数据库。</li><li>用户请求传入的任何参数必须做有效性验证。</li><li>禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。</li><li>表单、AJAX 提交必须执行 CSRF 安全验证。</li><li>在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的 机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。</li></ul><h3 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h3><h4 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h4><ul><li>表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在设置从 is_xxx 到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取 值含义与取值范围。</li><li>表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间 只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重 考虑。</li><li>表名不使用复数名词。</li><li>禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</li><li>主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。</li><li>小数类型为 decimal，禁止使用 float 和 double。</li><li>如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</li><li>varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长 度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。</li><li>表必备三字段：id, create_time, update_time。</li></ul><h4 id="索引规约"><a href="#索引规约" class="headerlink" title="索引规约"></a>索引规约</h4><ul><li>业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。</li><li>超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询 时，保证被关联的字段需要有索引。</li><li>在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度即可。</li><li>页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</li></ul><h4 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h4><ul><li>不要使用 count(列名)或 count(常量)来替代 count(<em>)，count(</em>)是 SQL92 定义的 标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。</li><li>count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</li><li>当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果 为 NULL，因此使用 sum()时需注意 NPE 问题。</li><li>使用 ISNULL()来判断是否为 NULL 值。</li><li>代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</li><li>不得使用外键与级联，一切外键概念必须在应用层解决。</li><li>禁止使用存储过程，存储过程难以调试和扩展，更没有移植性</li><li>数据订正（特别是删除、修改记录操作）时，要先 select，避免出现误删除，确认无 误才能执行更新语句。</li></ul><h4 id="ORM映射"><a href="#ORM映射" class="headerlink" title="ORM映射"></a>ORM映射</h4><ul><li>在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。</li><li>POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行 字段与属性之间的映射。</li><li>不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要 定义；反过来，每一个表也必然有一个 POJO 类与之对应。</li><li>sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。</li><li>iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。</li><li>不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。</li><li>更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。</li></ul><h3 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h3><h4 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h4><ul><li>图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于 Web 层，也可以直接依赖于 Service 层，依此类推：</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 开放接口层：可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；进行网关安全控制、流量控制等。</span><br><span class="line"><span class="bullet">-</span> 终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。</span><br><span class="line"><span class="bullet">-</span> Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</span><br><span class="line"><span class="bullet">-</span> Service 层：相对具体的业务逻辑服务层。</span><br><span class="line"><span class="bullet">-</span> Manager 层：通用业务处理层，它有如下特征：</span><br><span class="line"><span class="bullet">-</span> 对第三方平台封装的层，预处理返回结果及转化异常信息。</span><br><span class="line"><span class="bullet">-</span> 对 Service 层通用能力的下沉，如缓存方案、中间件通用处理。</span><br><span class="line"><span class="bullet">-</span> 与 DAO 层交互，对多个 DAO 的组合复用。 </span><br><span class="line"><span class="bullet">-</span> DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase 等进行数据交互。</span><br><span class="line"><span class="bullet">-</span> 外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。</span><br></pre></td></tr></table></figure><ul><li>分层领域模型规约：<ul><li>DO（Data Object）：此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</li><li>DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。</li><li>BO（Business Object）：业务对象，由 Service 层输出的封装业务逻辑的对象。</li><li>AO（Application Object）：应用对象，在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</li><li>VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li><li>Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类 来传输。</li></ul></li></ul><h4 id="二方库依赖"><a href="#二方库依赖" class="headerlink" title="二方库依赖"></a>二方库依赖</h4><ul><li><p>定义 GAV 遵从以下规则： </p><ul><li>GroupID 格式：com.{公司&#x2F;BU }.业务线 [.子业务线]，最多 4 级。 </li><li>ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。  </li><li>Version：详细规定参考下方。</li></ul></li><li><p>二方库版本号命名方式：主版本号.次版本号.修订号</p><ul><li>主版本号：产品方向改变，或者大规模 API 不兼容，或者架构不兼容升级。</li><li>次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的 API 不兼容修改。</li><li>修订号：保持完全兼容性，修复 BUG、新增次要功能特性等。</li></ul></li><li><p>线上应用不要依赖 SNAPSHOT 版本（安全包除外）。</p></li><li><p>二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变， 必须明确评估和验证。</p></li><li><p>二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用 枚举类型或者包含枚举类型的 POJO 对象。</p></li><li><p>依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。</p></li><li><p>禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的 Version。</p></li></ul><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><ul><li>高并发服务器建议调小 TCP 协议的 time_wait 超时时间。</li><li>调大服务器所支持的最大文件句柄数（File Descriptor，简写为 fd）。</li><li>给 JVM 环境参数设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出 dump 信息。</li><li>在线上生产环境，JVM 的 Xms 和 Xmx 设置一样大小的内存容量，避免在 GC 后调整 堆大小带来的压力。</li></ul><h3 id="设计规约"><a href="#设计规约" class="headerlink" title="设计规约"></a>设计规约</h3><ul><li><p>存储方案和底层数据结构的设计获得评审一致通过，并沉淀成为文档。 说明：有缺陷的底层数据结构容易导致系统风险上升，可扩展性下降，重构成本也会因历史数据迁移和系 统平滑过渡而陡然增加，所以，存储方案和数据结构需要认真地进行设计和评审，生产环境提交执行后， 需要进行 double check。</p></li><li><p>在需求分析阶段，如果与系统交互的 User 超过一类并且相关的 User Case 超过 5 个，使用用例图来表达更加清晰的结构化需求。</p></li><li><p>如果某个业务对象的状态超过 3 个，使用状态图来表达并且明确状态变化的各个触 发条件。</p></li><li><p>如果系统中某个功能的调用链路上的涉及对象超过 3 个，使用时序图来表达并且明 确各调用环节的输入与输出。</p></li><li><p>如果系统中模型类超过 5 个，并且存在复杂的依赖关系，使用类图来表达并且明确 类之间的关系。</p></li><li><p>如果系统中超过 2 个对象之间存在协作关系，并且需要表示复杂的处理流程，使用 活动图来表示。</p></li></ul><h4 id="附1-专有名词解释"><a href="#附1-专有名词解释" class="headerlink" title="附1 : 专有名词解释"></a>附1 : 专有名词解释</h4><ul><li>POJO（Plain Ordinary Java Object）: 在本手册中，POJO 专指只有 setter &#x2F; getter &#x2F; toString 的简单类，包括 DO&#x2F;DTO&#x2F;BO&#x2F;VO 等。</li><li>GAV（GroupId、ArtifactctId、Version）: Maven 坐标，是用来唯一标识 jar 包。</li><li>OOP（Object Oriented Programming）: 本手册泛指类、对象的编程处理方式。</li><li>ORM（Object Relation Mapping）: 对象关系映射，对象领域模型与底层数据之间的转换， 本文泛指 iBATIS, mybatis 等框架。</li><li>NPE（java.lang.NullPointerException）: 空指针异常。</li><li>SOA（Service-Oriented Architecture）: 面向服务架构，它可以根据需求通过网络对松散耦合 的粗粒度应用组件进行分布式部署、组合和使用，有利于提升组件可重用性，可维护性。</li><li>IDE（Integrated Development Environment）: 用于提供程序开发环境的应用程序，一般包括 代码编辑器、编译器、调试器和图形用户界面等工具，本《手册》泛指 IntelliJ IDEA 和 eclipse。</li><li>OOM（Out Of Memory）: 源于 java.lang.OutOfMemoryError，当 JVM 没有足够的内存来 为对象分配空间并且垃圾回收器也无法回收空间时，系统出现的严重状况。</li><li>一方库：本工程内部子项目模块依赖的库（jar 包）。</li><li>二方库：公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar 包）。</li><li>三方库：公司之外的开源库（jar 包）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规约 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity</title>
      <link href="/2022/11/29/SpringSecurity/"/>
      <url>/2022/11/29/SpringSecurity/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><p><img src="http://1.117.162.142:9000/blog/image-20211219121555979.png" alt="image-20211219121555979"></p><h2 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h2><p>​<strong>Spring Security</strong> 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架<strong>Shiro</strong>，它提供了更丰富的功能，社区资源也比Shiro丰富。</p><p>​一般来说中大型的项目都是使用<strong>SpringSecurity</strong> 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。</p><p>​ 一般Web应用的需要进行<strong>认证</strong>和<strong>授权</strong>。</p><p>​<strong>认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</strong></p><p>​<strong>授权：经过认证后判断当前用户是否有权限进行某个操作</strong></p><p>​而认证和授权也是SpringSecurity作为安全框架的核心功能。</p><h2 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1. 快速入门"></a>1. 快速入门</h2><h3 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1 准备工作"></a>1.1 准备工作</h3><p>​我们先要搭建一个简单的SpringBoot工程</p><p>① 设置父工程 添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>② 创建启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SecurityApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>③ 创建Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-2-引入SpringSecurity"><a href="#1-2-引入SpringSecurity" class="headerlink" title="1.2 引入SpringSecurity"></a>1.2 引入SpringSecurity</h3><p>​在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。</p><p>​必须登陆之后才能对接口进行访问。</p><h2 id="2-认证"><a href="#2-认证" class="headerlink" title="2. 认证"></a>2. 认证</h2><h3 id="2-1-登陆校验流程"><a href="#2-1-登陆校验流程" class="headerlink" title="2.1 登陆校验流程"></a>2.1 登陆校验流程</h3><p><img src="http://1.117.162.142:9000/blog/image-20211215094003288.png" alt="image-20211215094003288"></p><h3 id="2-2-原理初探"><a href="#2-2-原理初探" class="headerlink" title="2.2 原理初探"></a>2.2 原理初探</h3><p>​想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。</p><h4 id="2-2-1-SpringSecurity完整流程"><a href="#2-2-1-SpringSecurity完整流程" class="headerlink" title="2.2.1 SpringSecurity完整流程"></a>2.2.1 SpringSecurity完整流程</h4><p>​SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。</p><p><img src="http://1.117.162.142:9000/blog/image-20211214144425527.png"></p><p>​图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。</p><p><strong>UsernamePasswordAuthenticationFilter</strong>:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。</p><p><strong>ExceptionTranslationFilter：</strong>处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。</p><p><strong>FilterSecurityInterceptor：</strong>负责权限校验的过滤器。</p><p>​</p><p>​我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。</p><p><img src="http://1.117.162.142:9000/blog/image-20211214145824903.png" alt="image-20211214145824903"></p><h4 id="2-2-2-认证流程详解"><a href="#2-2-2-认证流程详解" class="headerlink" title="2.2.2 认证流程详解"></a>2.2.2 认证流程详解</h4><p><img src="http://1.117.162.142:9000/blog/image-20211214151515385.png" alt="image-20211214151515385"></p><p>概念速查:</p><p>Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。</p><p>AuthenticationManager接口：定义了认证Authentication的方法 </p><p>UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。</p><p>UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。</p><h3 id="2-3-解决问题"><a href="#2-3-解决问题" class="headerlink" title="2.3 解决问题"></a>2.3 解决问题</h3><h4 id="2-3-1-思路分析"><a href="#2-3-1-思路分析" class="headerlink" title="2.3.1 思路分析"></a>2.3.1 思路分析</h4><p>登录</p><p>​①自定义登录接口  </p><p>​调用ProviderManager的方法进行认证 如果认证通过生成jwt</p><p>​把用户信息存入redis中</p><p>​②自定义UserDetailsService </p><p>​在这个实现类中去查询数据库</p><p>校验：</p><p>​①定义Jwt认证过滤器</p><p>​获取token</p><p>​解析token获取其中的userid</p><p>​从redis中获取用户信息</p><p>​存入SecurityContextHolder</p><h4 id="2-3-2-准备工作"><a href="#2-3-2-准备工作" class="headerlink" title="2.3.2 准备工作"></a>2.3.2 准备工作</h4><p>①添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--fastjson依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jwt依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>② 添加Redis相关配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JavaType;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.type.TypeFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.SerializationException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis使用FastJson序列化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastJsonRedisSerializer</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">RedisSerializer</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Charset</span> <span class="variable">DEFAULT_CHARSET</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; clazz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastJsonRedisSerializer</span><span class="params">(Class&lt;T&gt; clazz)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(T t) <span class="keyword">throws</span> SerializationException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> SerializationException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span> || bytes.length &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, DEFAULT_CHARSET);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(str, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> JavaType <span class="title function_">getJavaType</span><span class="params">(Class&lt;?&gt; clazz)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TypeFactory.defaultInstance().constructType(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="type">FastJsonRedisSerializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastJsonRedisSerializer</span>(Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hash的key也采用StringRedisSerializer的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setHashValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ 响应类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseResult</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提示信息，如果有错误时，前端可以获取该字段进行提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询到的结果数据，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResponseResult</span><span class="params">(Integer code, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResponseResult</span><span class="params">(Integer code, T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResponseResult</span><span class="params">(Integer code, String msg, T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.JwtBuilder;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JWT工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有效期为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">JWT_TTL</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">60</span> *<span class="number">1000L</span>;<span class="comment">// 60 * 60 *1000  一个小时</span></span><br><span class="line">    <span class="comment">//设置秘钥明文</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JWT_KEY</span> <span class="operator">=</span> <span class="string">&quot;sangeng&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getUUID</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成jtw</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject token中要存放的数据（json格式）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String subject)</span> &#123;</span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getJwtBuilder(subject, <span class="literal">null</span>, getUUID());<span class="comment">// 设置过期时间</span></span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成jtw</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject token中要存放的数据（json格式）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ttlMillis token超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String subject, Long ttlMillis)</span> &#123;</span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getJwtBuilder(subject, ttlMillis, getUUID());<span class="comment">// 设置过期时间</span></span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JwtBuilder <span class="title function_">getJwtBuilder</span><span class="params">(String subject, Long ttlMillis, String uuid)</span> &#123;</span><br><span class="line">        <span class="type">SignatureAlgorithm</span> <span class="variable">signatureAlgorithm</span> <span class="operator">=</span> SignatureAlgorithm.HS256;</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> generalKey();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(nowMillis);</span><br><span class="line">        <span class="keyword">if</span>(ttlMillis==<span class="literal">null</span>)&#123;</span><br><span class="line">            ttlMillis=JwtUtil.JWT_TTL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">expMillis</span> <span class="operator">=</span> nowMillis + ttlMillis;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(expMillis);</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setId(uuid)              <span class="comment">//唯一的ID</span></span><br><span class="line">                .setSubject(subject)   <span class="comment">// 主题  可以是JSON数据</span></span><br><span class="line">                .setIssuer(<span class="string">&quot;sg&quot;</span>)     <span class="comment">// 签发者</span></span><br><span class="line">                .setIssuedAt(now)      <span class="comment">// 签发时间</span></span><br><span class="line">                .signWith(signatureAlgorithm, secretKey) <span class="comment">//使用HS256对称加密算法签名, 第二个参数为秘钥</span></span><br><span class="line">                .setExpiration(expDate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ttlMillis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String id, String subject, Long ttlMillis)</span> &#123;</span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getJwtBuilder(subject, ttlMillis, id);<span class="comment">// 设置过期时间</span></span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg&quot;</span>;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> parseJWT(token);</span><br><span class="line">        System.out.println(claims);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成加密后的秘钥 secretKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SecretKey <span class="title function_">generalKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(encodedKey, <span class="number">0</span>, encodedKey.length, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String jwt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> generalKey();</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(secretKey)</span><br><span class="line">                .parseClaimsJws(jwt)</span><br><span class="line">                .getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCache</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存基本的对象，Integer、String、实体类等</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 缓存的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">setCacheObject</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> T value)</span></span><br><span class="line">    &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存基本的对象，Integer、String、实体类等</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 缓存的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeUnit 时间颗粒度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">setCacheObject</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> T value, <span class="keyword">final</span> Integer timeout, <span class="keyword">final</span> TimeUnit timeUnit)</span></span><br><span class="line">    &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置有效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true=设置成功；false=设置失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="type">long</span> timeout)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置有效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true=设置成功；false=设置失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="type">long</span> timeout, <span class="keyword">final</span> TimeUnit unit)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.expire(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的基本对象。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存键值对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getCacheObject</span><span class="params">(<span class="keyword">final</span> String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();</span><br><span class="line">        <span class="keyword">return</span> operation.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除单个对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteObject</span><span class="params">(<span class="keyword">final</span> String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除集合对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> collection 多个对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">deleteObject</span><span class="params">(<span class="keyword">final</span> Collection collection)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(collection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存List数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataList 待缓存的List数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">long</span> <span class="title function_">setCacheList</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> List&lt;T&gt; dataList)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForList().rightPushAll(key, dataList);</span><br><span class="line">        <span class="keyword">return</span> count == <span class="literal">null</span> ? <span class="number">0</span> : count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的list对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存键值对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">getCacheList</span><span class="params">(<span class="keyword">final</span> String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().range(key, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存Set</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSet 缓存的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存数据的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; BoundSetOperations&lt;String, T&gt; <span class="title function_">setCacheSet</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> Set&lt;T&gt; dataSet)</span></span><br><span class="line">    &#123;</span><br><span class="line">        BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key);</span><br><span class="line">        Iterator&lt;T&gt; it = dataSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            setOperation.add(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setOperation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的set</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">getCacheSet</span><span class="params">(<span class="keyword">final</span> String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存Map</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">setCacheMap</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> Map&lt;String, T&gt; dataMap)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dataMap != <span class="literal">null</span>) &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, dataMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的Map</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Map&lt;String, T&gt; <span class="title function_">getCacheMap</span><span class="params">(<span class="keyword">final</span> String key)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往Hash中存入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hKey Hash键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">setCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String hKey, <span class="keyword">final</span> T value)</span></span><br><span class="line">    &#123;</span><br><span class="line">        redisTemplate.opsForHash().put(key, hKey, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Hash中的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hKey Hash键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Hash中的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String hKey)</span></span><br><span class="line">    &#123;</span><br><span class="line">        HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash();</span><br><span class="line">        <span class="keyword">return</span> opsForHash.get(key, hKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除Hash中的数据</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hkey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String hkey)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">HashOperations</span> <span class="variable">hashOperations</span> <span class="operator">=</span> redisTemplate.opsForHash();</span><br><span class="line">        hashOperations.delete(key, hkey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取多个Hash中的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hKeys Hash键集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Hash对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">getMultiCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> Collection&lt;Object&gt; hKeys)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().multiGet(key, hKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的基本对象列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern 字符串前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对象列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;String&gt; <span class="title function_">keys</span><span class="params">(<span class="keyword">final</span> String pattern)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.keys(pattern);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebUtils</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符串渲染到客户端</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 渲染对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string 待渲染的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">renderString</span><span class="params">(HttpServletResponse response, String string)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            response.setStatus(<span class="number">200</span>);</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            response.getWriter().print(string);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⑤实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户表(User)实体类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 三更</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">40356785423868312L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 主键</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用户名</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 昵称</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 密码</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 账号状态（0正常 1停用）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 邮箱</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 手机号</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String phonenumber;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用户性别（0男，1女，2未知）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 头像</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String avatar;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用户类型（0管理员，1普通用户）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String userType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建人的用户id</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Long createBy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建时间</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 更新人</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Long updateBy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 更新时间</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除标志（0代表未删除，1代表已删除）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Integer delFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3-实现"><a href="#2-3-3-实现" class="headerlink" title="2.3.3 实现"></a>2.3.3 实现</h4><h5 id="2-3-3-1-数据库校验用户"><a href="#2-3-3-1-数据库校验用户" class="headerlink" title="2.3.3.1 数据库校验用户"></a>2.3.3.1 数据库校验用户</h5><p>​从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。</p><h6 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h6><p>​我们先创建一个用户表， 建表语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `sys_user` (</span><br><span class="line">  `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">  `user_name` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;用户名&#x27;,</span><br><span class="line">  `nick_name` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;昵称&#x27;,</span><br><span class="line">  `password` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;密码&#x27;,</span><br><span class="line">  `status` CHAR(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;账号状态（0正常 1停用）&#x27;,</span><br><span class="line">  `email` VARCHAR(64) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,</span><br><span class="line">  `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT &#x27;手机号&#x27;,</span><br><span class="line">  `sex` CHAR(1) DEFAULT NULL COMMENT &#x27;用户性别（0男，1女，2未知）&#x27;,</span><br><span class="line">  `avatar` VARCHAR(128) DEFAULT NULL COMMENT &#x27;头像&#x27;,</span><br><span class="line">  `user_type` CHAR(1) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;用户类型（0管理员，1普通用户）&#x27;,</span><br><span class="line">  `create_by` BIGINT(20) DEFAULT NULL COMMENT &#x27;创建人的用户id&#x27;,</span><br><span class="line">  `create_time` DATETIME DEFAULT NULL COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `update_by` BIGINT(20) DEFAULT NULL COMMENT &#x27;更新人&#x27;,</span><br><span class="line">  `update_time` DATETIME DEFAULT NULL COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">  `del_flag` INT(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志（0代表未删除，1代表已删除）&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;</span><br></pre></td></tr></table></figure><p>​引入MybatisPuls和mysql驱动的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​配置数据库信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>​定义Mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​修改User实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名上加<span class="meta">@TableName(value = &quot;sys_user&quot;)</span> ,id字段上加 <span class="meta">@TableId</span></span><br></pre></td></tr></table></figure><p>​配置Mapper扫描</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.sangeng.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleSecurityApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(SimpleSecurityApplication.class);</span><br><span class="line">        System.out.println(run);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​添加junit依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>​   测试MP是否能正常使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUserMapper</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="核心代码实现"><a href="#核心代码实现" class="headerlink" title="核心代码实现"></a>核心代码实现</h6><p>创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">//根据用户名查询用户信息</span></span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(User::getUserName,username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line">        <span class="comment">//如果查询不到数据就通过抛出异常来给出提示</span></span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//TODO 根据用户查询权限信息 添加到LoginUser中</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//封装成UserDetails对象返回 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginUser</span>(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。例如</p><p><img src="http://1.117.162.142:9000/blog/image-20211216123945882.png" alt="image-20211216123945882"></p><p>这样登陆的时候就可以用sg作为用户名，1234作为密码来登陆了。</p><h5 id="2-3-3-2-密码加密存储"><a href="#2-3-3-2-密码加密存储" class="headerlink" title="2.3.3.2 密码加密存储"></a>2.3.3.2 密码加密存储</h5><p>​实际项目中我们不会把密码明文存储在数据库中。</p><p>​默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。</p><p>​我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。</p><p>​我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。</p><p>​我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-3-3-登陆接口"><a href="#2-3-3-3-登陆接口" class="headerlink" title="2.3.3.3 登陆接口"></a>2.3.3.3 登陆接口</h5><p>​接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。</p><p>​在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。</p><p>​认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginServcie loginServcie;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseResult <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loginServcie.login(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                <span class="comment">//关闭csrf</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 对于登录接口 允许匿名访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">                <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LoginServcie</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResponseResult <span class="title function_">login</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user.getUserName(),user.getPassword());</span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authenticate</span> <span class="operator">=</span> authenticationManager.authenticate(authenticationToken);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(authenticate))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用userid生成token</span></span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authenticate.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> loginUser.getUser().getId().toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> JwtUtil.createJWT(userId);</span><br><span class="line">        <span class="comment">//authenticate存入redis</span></span><br><span class="line">        redisCache.setCacheObject(<span class="string">&quot;login:&quot;</span>+userId,loginUser);</span><br><span class="line">        <span class="comment">//把token响应给前端</span></span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;token&quot;</span>,jwt);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(<span class="number">200</span>,<span class="string">&quot;登陆成功&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-3-3-4-认证过滤器"><a href="#2-3-3-4-认证过滤器" class="headerlink" title="2.3.3.4 认证过滤器"></a>2.3.3.4 认证过滤器</h5><p>​我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。</p><p>​使用userid去redis中获取对应的LoginUser对象。</p><p>​然后封装Authentication对象存入SecurityContextHolder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(token)) &#123;</span><br><span class="line">            <span class="comment">//放行</span></span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析token</span></span><br><span class="line">        String userid;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(token);</span><br><span class="line">            userid = claims.getSubject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;token非法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从redis中获取用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> <span class="string">&quot;login:&quot;</span> + userid;</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> redisCache.getCacheObject(redisKey);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(loginUser))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存入SecurityContextHolder</span></span><br><span class="line">        <span class="comment">//TODO 获取权限信息封装到Authentication中</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                <span class="comment">//关闭csrf</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 对于登录接口 允许匿名访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">                <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把token校验过滤器添加到过滤器链中</span></span><br><span class="line">        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-3-3-5-退出登陆"><a href="#2-3-3-5-退出登陆" class="headerlink" title="2.3.3.5 退出登陆"></a>2.3.3.5 退出登陆</h5><p>​我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LoginServcie</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResponseResult <span class="title function_">login</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user.getUserName(),user.getPassword());</span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authenticate</span> <span class="operator">=</span> authenticationManager.authenticate(authenticationToken);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(authenticate))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用userid生成token</span></span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authenticate.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> loginUser.getUser().getId().toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> JwtUtil.createJWT(userId);</span><br><span class="line">        <span class="comment">//authenticate存入redis</span></span><br><span class="line">        redisCache.setCacheObject(<span class="string">&quot;login:&quot;</span>+userId,loginUser);</span><br><span class="line">        <span class="comment">//把token响应给前端</span></span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;token&quot;</span>,jwt);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(<span class="number">200</span>,<span class="string">&quot;登陆成功&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResponseResult <span class="title function_">logout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authentication.getPrincipal();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userid</span> <span class="operator">=</span> loginUser.getUser().getId();</span><br><span class="line">        redisCache.deleteObject(<span class="string">&quot;login:&quot;</span>+userid);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(<span class="number">200</span>,<span class="string">&quot;退出成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-授权"><a href="#3-授权" class="headerlink" title="3. 授权"></a>3. 授权</h2><h3 id="3-0-权限系统的作用"><a href="#3-0-权限系统的作用" class="headerlink" title="3.0 权限系统的作用"></a>3.0 权限系统的作用</h3><p>​例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。</p><p>​总结起来就是<strong>不同的用户可以使用不同的功能</strong>。这就是权限系统要去实现的效果。</p><p>​我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。</p><p>​所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。</p><p>​</p><h3 id="3-1-授权基本流程"><a href="#3-1-授权基本流程" class="headerlink" title="3.1 授权基本流程"></a>3.1 授权基本流程</h3><p>​在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。</p><p>​所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。</p><p>​然后设置我们的资源所需要的权限即可。</p><h3 id="3-2-授权实现"><a href="#3-2-授权实现" class="headerlink" title="3.2 授权实现"></a>3.2 授权实现</h3><h4 id="3-2-1-限制访问资源所需权限"><a href="#3-2-1-限制访问资源所需权限" class="headerlink" title="3.2.1 限制访问资源所需权限"></a>3.2.1 限制访问资源所需权限</h4><p>​SpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。</p><p>​但是要使用它我们需要先开启相关配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br></pre></td></tr></table></figure><p>​然后就可以使用对应的注解。@PreAuthorize</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;test&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-封装权限信息"><a href="#3-2-2-封装权限信息" class="headerlink" title="3.2.2 封装权限信息"></a>3.2.2 封装权限信息</h4><p>​我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。</p><p>​我们先直接把权限信息写死封装到UserDetails中进行测试。</p><p>​我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sangeng.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.annotation.JSONField;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//存储权限信息</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; permissions;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginUser</span><span class="params">(User user,List&lt;String&gt; permissions)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">        <span class="built_in">this</span>.permissions = permissions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储SpringSecurity所需要的权限信息的集合</span></span><br><span class="line">    <span class="meta">@JSONField(serialize = false)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;GrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span>  Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">if</span>(authorities!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> authorities;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中</span></span><br><span class="line">        authorities = permissions.stream().</span><br><span class="line">                map(SimpleGrantedAuthority::<span class="keyword">new</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​LoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sangeng.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;</span><br><span class="line"><span class="keyword">import</span> com.sangeng.domain.LoginUser;</span><br><span class="line"><span class="keyword">import</span> com.sangeng.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.sangeng.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(User::getUserName,username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//TODO 根据用户查询权限信息 添加到LoginUser中</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginUser</span>(user,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-2-3-从数据库查询权限信息"><a href="#3-2-3-从数据库查询权限信息" class="headerlink" title="3.2.3 从数据库查询权限信息"></a>3.2.3 从数据库查询权限信息</h4><h5 id="3-2-3-1-RBAC权限模型"><a href="#3-2-3-1-RBAC权限模型" class="headerlink" title="3.2.3.1 RBAC权限模型"></a>3.2.3.1 RBAC权限模型</h5><p>​RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。</p><p>​<img src="http://1.117.162.142:9000/blog/image-20211222110249727.png" alt="image-20211222110249727"></p><h5 id="3-2-3-2-准备工作"><a href="#3-2-3-2-准备工作" class="headerlink" title="3.2.3.2 准备工作"></a>3.2.3.2 准备工作</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="comment">/*!32312 IF NOT EXISTS*/</span>`sg_security` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 */</span>;</span><br><span class="line"></span><br><span class="line">USE `sg_security`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_menu` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_menu`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_menu` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `menu_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;菜单名&#x27;</span>,</span><br><span class="line">  `path` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;路由地址&#x27;</span>,</span><br><span class="line">  `component` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;组件路径&#x27;</span>,</span><br><span class="line">  `visible` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;菜单状态（0显示 1隐藏）&#x27;</span>,</span><br><span class="line">  `status` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;菜单状态（0正常 1停用）&#x27;</span>,</span><br><span class="line">  `perms` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;权限标识&#x27;</span>,</span><br><span class="line">  `icon` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;#&#x27;</span> COMMENT <span class="string">&#x27;菜单图标&#x27;</span>,</span><br><span class="line">  `create_by` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_by` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `del_flag` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;是否删除（0未删除 1已删除）&#x27;</span>,</span><br><span class="line">  `remark` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;菜单表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_role` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_role`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_role` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role_key` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色权限字符串&#x27;</span>,</span><br><span class="line">  `status` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;角色状态（0正常 1停用）&#x27;</span>,</span><br><span class="line">  `del_flag` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;del_flag&#x27;</span>,</span><br><span class="line">  `create_by` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_by` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `remark` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;角色表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_role_menu` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_role_menu`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_role_menu` (</span><br><span class="line">  `role_id` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">  `menu_id` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;菜单id&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`role_id`,`menu_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_user` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_user`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_user` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `user_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  `nick_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `status` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;账号状态（0正常 1停用）&#x27;</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  `phonenumber` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">  `sex` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户性别（0男，1女，2未知）&#x27;</span>,</span><br><span class="line">  `avatar` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;头像&#x27;</span>,</span><br><span class="line">  `user_type` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;用户类型（0管理员，1普通用户）&#x27;</span>,</span><br><span class="line">  `create_by` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人的用户id&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_by` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新人&#x27;</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  `del_flag` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;删除标志（0代表未删除，1代表已删除）&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_user_role` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_user_role`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_user_role` (</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `role_id` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;角色id&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`user_id`,`role_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">DISTINCT m.`perms`</span><br><span class="line">FROM</span><br><span class="line">sys_user_role ur</span><br><span class="line">LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`</span><br><span class="line">LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`</span><br><span class="line">LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`</span><br><span class="line">WHERE</span><br><span class="line">user_id = 2</span><br><span class="line">AND r.`status` = 0</span><br><span class="line">AND m.`status` = 0</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sangeng.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 菜单表(Menu)实体类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> makejava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-11-24 15:30:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TableName(value=&quot;sys_menu&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">54979041104113736L</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 菜单名</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String menuName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 路由地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 组件路径</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String component;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 菜单状态（0显示 1隐藏）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String visible;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 菜单状态（0正常 1停用）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 权限标识</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String perms;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 菜单图标</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String icon;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Long createBy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Long updateBy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否删除（0未删除 1已删除）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> Integer delFlag;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 备注</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> String remark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-3-3-代码实现"><a href="#3-2-3-3-代码实现" class="headerlink" title="3.2.3.3 代码实现"></a>3.2.3.3 代码实现</h5><p>​我们只需要根据用户id去查询到其所对应的权限信息即可。</p><p>​所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.sangeng.domain.Menu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MenuMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Menu&gt; &#123;</span><br><span class="line">    List&lt;String&gt; <span class="title function_">selectPermsByUserId</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sangeng.mapper.MenuMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPermsByUserId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">            DISTINCT m.`perms`</span><br><span class="line">        FROM</span><br><span class="line">            sys_user_role ur</span><br><span class="line">            LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`</span><br><span class="line">            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`</span><br><span class="line">            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`</span><br><span class="line">        WHERE</span><br><span class="line">            user_id = #&#123;userid&#125;</span><br><span class="line">            AND r.`status` = 0</span><br><span class="line">            AND m.`status` = 0</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​在application.yml中配置mapperXML文件的位置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:/mapper/**/*.xml</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MenuMapper menuMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(User::getUserName,username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; permissionKeyList =  menuMapper.selectPermsByUserId(user.getId());</span><br><span class="line"><span class="comment">//        //测试写法</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;test&quot;));</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginUser</span>(user,permissionKeyList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-自定义失败处理"><a href="#4-自定义失败处理" class="headerlink" title="4. 自定义失败处理"></a>4. 自定义失败处理</h2><p>​我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。</p><p>​在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。</p><p>​如果是认证过程中出现的异常会被封装成AuthenticationException然后调用<strong>AuthenticationEntryPoint</strong>对象的方法去进行异常处理。</p><p>​如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用<strong>AccessDeniedHandler</strong>对象的方法去进行异常处理。</p><p>​所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。</p><p>①自定义实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessDeniedHandlerImpl</span> <span class="keyword">implements</span> <span class="title class_">AccessDeniedHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">ResponseResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(HttpStatus.FORBIDDEN.value(), <span class="string">&quot;权限不足&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(result);</span><br><span class="line">        WebUtils.renderString(response,json);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> 三更  B站： https://space.bilibili.com/663528522</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationEntryPointImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">ResponseResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(HttpStatus.UNAUTHORIZED.value(), <span class="string">&quot;认证失败请重新登录&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(result);</span><br><span class="line">        WebUtils.renderString(response,json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>②配置给SpringSecurity</p><p>​</p><p>​先注入对应的处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AccessDeniedHandler accessDeniedHandler;</span><br></pre></td></tr></table></figure><p>​然后我们可以使用HttpSecurity对象的方法去配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint).</span><br><span class="line">        accessDeniedHandler(accessDeniedHandler);</span><br></pre></td></tr></table></figure><h2 id="5-跨域"><a href="#5-跨域" class="headerlink" title="5. 跨域"></a>5. 跨域</h2><p>​浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 </p><p>​前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。</p><p>​所以我们就要处理一下，让前端能进行跨域请求。</p><p>①先对SpringBoot配置，运行跨域请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">      <span class="comment">// 设置允许跨域的路径</span></span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置允许跨域请求的域名</span></span><br><span class="line">                .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">// 是否允许cookie</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 设置允许的请求方式</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;PUT&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置允许的header属性</span></span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">// 跨域允许时间</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②开启SpringSecurity的跨域访问</p><p>由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">            <span class="comment">//关闭csrf</span></span><br><span class="line">            .csrf().disable()</span><br><span class="line">            <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">            .and()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            <span class="comment">// 对于登录接口 允许匿名访问</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">            <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">            .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加过滤器</span></span><br><span class="line">    http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置异常处理器</span></span><br><span class="line">    http.exceptionHandling()</span><br><span class="line">            <span class="comment">//配置认证失败处理器</span></span><br><span class="line">            .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">            .accessDeniedHandler(accessDeniedHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许跨域</span></span><br><span class="line">    http.cors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-遗留小问题"><a href="#6-遗留小问题" class="headerlink" title="6. 遗留小问题"></a>6. 遗留小问题</h2><h3 id="其它权限校验方法"><a href="#其它权限校验方法" class="headerlink" title="其它权限校验方法"></a>其它权限校验方法</h3><p>​我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。</p><p>​    </p><p>​这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。</p><p>​hasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。</p><p>​它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。</p><p>​hasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasAnyAuthority(&#x27;admin&#x27;,&#x27;test&#x27;,&#x27;system:dept:list&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​hasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所以这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;system:dept:list&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​hasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所以这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasAnyRole(&#x27;admin&#x27;,&#x27;system:dept:list&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义权限校验方法"><a href="#自定义权限校验方法" class="headerlink" title="自定义权限校验方法"></a>自定义权限校验方法</h3><p>​我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;ex&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SGExpressionRoot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasAuthority</span><span class="params">(String authority)</span>&#123;</span><br><span class="line">        <span class="comment">//获取当前用户的权限</span></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authentication.getPrincipal();</span><br><span class="line">        List&lt;String&gt; permissions = loginUser.getPermissions();</span><br><span class="line">        <span class="comment">//判断用户权限集合中是否存在authority</span></span><br><span class="line">        <span class="keyword">return</span> permissions.contains(authority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@ex.hasAuthority(&#x27;system:dept:list&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于配置的权限控制"><a href="#基于配置的权限控制" class="headerlink" title="基于配置的权限控制"></a>基于配置的权限控制</h3><p>​我们也可以在配置类中使用使用配置的方式对资源进行权限控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">            <span class="comment">//关闭csrf</span></span><br><span class="line">            .csrf().disable()</span><br><span class="line">            <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">            .and()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            <span class="comment">// 对于登录接口 允许匿名访问</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/testCors&quot;</span>).hasAuthority(<span class="string">&quot;system:dept:list222&quot;</span>)</span><br><span class="line">            <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">            .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加过滤器</span></span><br><span class="line">    http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置异常处理器</span></span><br><span class="line">    http.exceptionHandling()</span><br><span class="line">            <span class="comment">//配置认证失败处理器</span></span><br><span class="line">            .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">            .accessDeniedHandler(accessDeniedHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许跨域</span></span><br><span class="line">    http.cors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>​CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。</p><p>​<a href="https://blog.csdn.net/freeking101/article/details/86537087">https://blog.csdn.net/freeking101/article/details/86537087</a></p><p>​SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。</p><p>​我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。</p><h3 id="认证成功处理器"><a href="#认证成功处理器" class="headerlink" title="认证成功处理器"></a>认证成功处理器</h3><p>​实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。</p><p>​我们也可以自己去自定义成功处理器进行成功后的相应处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SGSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;认证成功了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationSuccessHandler successHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.formLogin().successHandler(successHandler);</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="认证失败处理器"><a href="#认证失败处理器" class="headerlink" title="认证失败处理器"></a>认证失败处理器</h3><p>​实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。</p><p>​我们也可以自己去自定义失败处理器进行失败后的相应处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SGFailureHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationFailureHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;认证失败了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationSuccessHandler successHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationFailureHandler failureHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.formLogin()</span><br><span class="line"><span class="comment">//                配置认证成功处理器</span></span><br><span class="line">                .successHandler(successHandler)</span><br><span class="line"><span class="comment">//                配置认证失败处理器</span></span><br><span class="line">                .failureHandler(failureHandler);</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="登出成功处理器"><a href="#登出成功处理器" class="headerlink" title="登出成功处理器"></a>登出成功处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SGLogoutSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">LogoutSuccessHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;注销成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationSuccessHandler successHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationFailureHandler failureHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogoutSuccessHandler logoutSuccessHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.formLogin()</span><br><span class="line"><span class="comment">//                配置认证成功处理器</span></span><br><span class="line">                .successHandler(successHandler)</span><br><span class="line"><span class="comment">//                配置认证失败处理器</span></span><br><span class="line">                .failureHandler(failureHandler);</span><br><span class="line"></span><br><span class="line">        http.logout()</span><br><span class="line">                <span class="comment">//配置注销成功处理器</span></span><br><span class="line">                .logoutSuccessHandler(logoutSuccessHandler);</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他认证方案畅想"><a href="#其他认证方案畅想" class="headerlink" title="其他认证方案畅想"></a>其他认证方案畅想</h3>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka</title>
      <link href="/2022/11/28/kafka/"/>
      <url>/2022/11/28/kafka/</url>
      
        <content type="html"><![CDATA[<h2 id="消息队列的流派"><a href="#消息队列的流派" class="headerlink" title="消息队列的流派"></a>消息队列的流派</h2><h3 id="什么是-MQ"><a href="#什么是-MQ" class="headerlink" title="什么是 MQ"></a>什么是 MQ</h3><p>Message Queue (MQ)，消息队列中间件。很多人都说：MQ 通过将消息的发送和接收分离来实现应用程序的异步和解偶，这个给人的直觉是——MQ 是异步的，用来解偶的，但是这个只是 MQ 的效果而不是目的。MQ 真正的目的是为了通讯，屏蔽底层复杂的通讯协议，定义了一套应用层的、更加简单的通讯协议。一个分布式系统中两个模块之间的通讯要么是 HTTP，要么是自己开发的 (rpc) TCP，但是这两种协议其实都是原始的协议。HTTP 协议很难实现两端通讯——模块 A 可以调用 B，B 也可以主动调用 A，如果要做到这个两端都要背上 WebServer，而且还不支持长连接 (HTTP 2.0 的库根本找不到)。TCP 就更加原始了，粘包、心跳、私有的协议，想一想头皮就发麻。MQ 所要做的就是在这些协议之上构建一个简单的“协议”——生产者&#x2F;消费者模型。MQ 带给我们的“协议”不是具体的通讯协议，而是更高层次通讯模型。它定义了两个对象——发送数据的叫生产者；接收数据的叫消费者，提供一个 SDK 让我们可以定义自己的生产者和消费者实现消息通讯而无视底层通讯协议。<strong>消息队列具体解决的是什么问题——通信问题</strong>。</p><h3 id="有-Broker-的-MQ"><a href="#有-Broker-的-MQ" class="headerlink" title="有 Broker 的 MQ"></a>有 Broker 的 MQ</h3><p>这个流派通常有一台服务器作为 Broker，所有的消息都通过它中转。生产者吧消息发送给它就结束自己的任务了，Broker 则把消息主动推送给消费者 (或者消费者主动轮询)。</p><h4 id="重-Topic"><a href="#重-Topic" class="headerlink" title="重 Topic"></a>重 Topic</h4><p>Kafka、JMS (ActiveMQ) 就属于这个流派，生产者会发送 key 和数据到 Broker，由 Broker 比较 key 之后决定给哪个消费者。这种模式是我们最常见的模式，是我们对 MQ 最多的印象。在这种模式下一个 topic 往往是一个比较大的概念，甚至一个系统就可能只有一个 topic，topic 某种意义上就是 queue，生产者发送 key 相当于说：“hi，把数据放到 key 的队列中”。</p><p>比如一个 Broker 定义了三个队列：key1、key2、key3，生产者发送数据 {key:key data:data}，Broker 在推送数据的时候则推送 data 给匹配的 key。</p><p>虽然架构一样但是 kafka 的性能要比 jms 的性能不知道高到多少倍，所以基本这种类型的 MQ 只有 kafka 一种备选方案。如果你需要一条暴力的数据流 (在乎性能而非灵活性) 那么 kafka 是最好的选择。</p><h4 id="轻-Topic"><a href="#轻-Topic" class="headerlink" title="轻 Topic"></a>轻 Topic</h4><p>这种的代表是 RabbitMQ (或者说是 AMQP)。生产者发送 key 和数据，消费者定义订阅的队列，Broker 收到数据之后会通过一定的逻辑计算出 key 对应的队列，然后把数据交给队列。</p><p>这种模式下解偶了 key 和 queue，在这种架构中 queue 是非常轻量级的 (在 RabbitMQ 中它的上限取决于你的内存)，消费者关心的只是自己的 queue；生产者不必关心数据最终给谁只要指定 key 就行了，中间的那层映射在 AMQP 中叫 exchange (交换机)。</p><p>AMQP 中有四种 exchange</p><ul><li>Direct exchange：key 就等于 queue</li><li>Fanout exchange：无视 key，给所有的 queue 都来一份</li><li>Topic exchange：key 可以用“宽字符”模糊匹配 queue</li><li>Headers exchange：无视 key，通过查看消息的头部元数据来决定发给哪个 queue (AMQP 头部元数据非常丰富而且可以自定义)</li></ul><p>这种结构的架构给通讯带来了很大的灵活性，我们能想到的通讯方式都可以用这四种 exchange 表达出来。如果你需要一个企业数据总线 (在乎灵活性) 那么 RabbitMQ 绝对的值得一用。</p><h3 id="无-Broker-的-MQ"><a href="#无-Broker-的-MQ" class="headerlink" title="无 Broker 的 MQ"></a>无 Broker 的 MQ</h3><p>无 Broker 的 MQ 的代表是 ZeroMQ。该作者非常睿智，他非常敏锐的意识到——MQ 是更高级的 Socket，它是解决通讯问题的。所以 ZeroMQ 被设计成了一个“库”而不是一个中间件，这种实现也可以达到——没有 Broker 的目的。</p><p>节点之间通讯的消息都是发送到彼此的队列中，每隔节点都既是生产者又是消费者。ZeroMQ 做的事情就是封装出一套类似于 Socket 的API 可以完成发送数据，读取数据。</p><p>ZeroMQ 其实就是一个跨语言的、重量级的 Actor 模型邮箱库。你可以把自己的程序想象成一个 Actor，ZeroMQ 就是提供邮箱功能的库；ZeroMQ 可以实现同一台机器的 RPC 通讯，也可以实现不同机器的 TCP、UDP 通讯，如果你需要一个强大的、灵活、野蛮的通讯能力，别犹豫 ZeroMQ。</p><h2 id="Kafka-介绍"><a href="#Kafka-介绍" class="headerlink" title="Kafka 介绍"></a>Kafka 介绍</h2><p>Kafka 是最初由 Linkedin 公司开发，是一个分布式、支持分区的 (partition)、多副本的 (replica)，基于 zookeeper 协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据已满足各种需求场景：比如基于 hadoop 的批处理系统、低延迟的实时系统、Storm&#x2F;Spark 流式处理引擎，web&#x2F;nginx 日志、访问日志，消息服务等等，用 scala 语言编写，Linkedin 于 2010 年贡献给了 Apache 基金会并成为顶级开源项目。</p><h3 id="Kafka-的使用场景"><a href="#Kafka-的使用场景" class="headerlink" title="Kafka 的使用场景"></a>Kafka 的使用场景</h3><ul><li>日志收集：一个公司可以用 Kafka 收集各种服务的 log，通过 Kafka 以统一接口服务的方式开放给各种 consumer，例如 hadoop、Hbase、Solr 等。</li><li>消息系统：解耦和生产者和消费者、缓存消息等。</li><li>用户活动跟踪：Kafka 经常被用来记录 web 用户或者 app 用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到 Kafka 的 topic 中，然后订阅者通过订阅这些 topic 来做实时的监控分析，或者装载到 hadoop、数据仓库中做离线分析和挖掘。</li><li>运营指标：Kafka 也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li></ul><h3 id="Kafka-安装"><a href="#Kafka-安装" class="headerlink" title="Kafka 安装"></a>Kafka 安装</h3><ul><li><p>安装 JDK</p></li><li><p>下载 Kafka 安装包：<a href="http://kafka.apache.org/downloads">http://kafka.apache.org/downloads</a></p></li><li><p>上传到 Kafka 服务器上：<code>/opt/kafka</code></p></li><li><p>解压缩</p></li><li><p>进入到 config 目录，修改 server.properties</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># broker.id 属性在 kafka 集群中必须是唯一</span><br><span class="line">broker.id<span class="operator">=</span><span class="number">0</span></span><br><span class="line"># kafka 部署的机器 ip 和提供服务的端口号</span><br><span class="line">listeners<span class="operator">=</span>PLAINTEXT:<span class="operator">/</span><span class="operator">/</span>服务器ip:<span class="number">9092</span></span><br><span class="line"># kafka 的消息存储文件</span><br><span class="line">log.dir<span class="operator">=</span><span class="operator">/</span>opt<span class="operator">/</span>kafka<span class="operator">/</span>log</span><br><span class="line"># kafka 连接 zookeeper 的地址</span><br><span class="line">zookeeper.connect<span class="operator">=</span>zookeeper服务器ip:<span class="number">2181</span></span><br></pre></td></tr></table></figure><p>  <strong>server.properties 核心配置详解</strong>：</p><table><thead><tr><th>Property</th><th>Default</th><th>Descrition</th></tr></thead><tbody><tr><td>brocker.id</td><td>0</td><td>每个 broker 都可以用一个唯一的非负整数 id 进行标识；这个 id 可以作为 broker 的名字，你可以选择任意你喜欢的数字作为 id，只要 id 是唯一的即可。</td></tr><tr><td>log.dirs</td><td>&#x2F;tmp&#x2F;kafka-logs</td><td>kafka 存放数据的路径。这个路径并不是唯一的，可以是多个，路径之间只需要使用逗号分隔即可；每当创建 partition 时，都会选择在包含最少 partitions 的路径下进行。</td></tr><tr><td>listeners</td><td>PLAINTEXT:&#x2F;&#x2F;localhost:9092</td><td>server 接收客户端连接的端口，ip 配置 kafka 本机 ip 即可</td></tr><tr><td>zookeeper.connect</td><td>localhost:2181</td><td>zookeeper 连接字符串的格式为：hostname:port，此处 hostname 和 port 分别是 zookeeper 集群中某个节点的 host 和 port；zookeeper 如果是集群，连接方式为 hostname1:port1,hostname2:port2,hostname3:port3</td></tr><tr><td>log.retention.hours</td><td>168</td><td>每个日志文件删除之前保存的时间。默认数据保存时间对所有 topic 都一样</td></tr><tr><td>default.replication.factor</td><td>1</td><td>自动创建 topic 的默认副本数量，建议设置为大于等于 2</td></tr><tr><td>min.insync.replicas</td><td>1</td><td>当 producer 设置 ack 为 -1 时，min.insync.replicas 指定 replicas 的最小数目 (必须确认每一个 replica 的写数据都是成功的)，如果这个数目没有达到，producer 发送消息会产生异常</td></tr><tr><td>delete.topic.enable</td><td>false</td><td>是否允许删除主题</td></tr><tr><td>num.partitions</td><td>1</td><td>创建 topic 的默认分区数</td></tr></tbody></table></li><li><p>进入到 bin 目录内，执行一下命令来启动 kafka 服务器 </p><p>  <code>./kafka-server-start.sh -daemon ../config/server.properties</code></p></li><li><p>校验 kafka 是否启动成功：</p><p>  进入到 zk 内查看是否有 kafka 的节点：<code>ls /brokers/ids/</code></p></li></ul><h3 id="Kafka-基本概念"><a href="#Kafka-基本概念" class="headerlink" title="Kafka 基本概念"></a>Kafka 基本概念</h3><p>Kafka 是一个分布式的，分区的消息 (官方称之为 commit log) 服务。它提供了一个消息系统应该具备的功能，但是却用独特的设计。可以这样来说，Kafka 借鉴了 JMS 规范的思想，但是却并没有完全遵循 JMS 规范。</p><p>基础的消息 (Message) 相关术语：</p><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>Broker</td><td>消息中间件处理节点，一个 kafka 节点就是一个 broker，一个或者多个 Broker 可以组成一个 kafka 集群</td></tr><tr><td>Topic</td><td>Kafka 根据 topic 对消息进行归类，发布到 Kafka 集群的每条消息都需要指定一个 topic</td></tr><tr><td>Producer</td><td>消息生产者，向 Broker 发送消息的客户端</td></tr><tr><td>Consumer</td><td>消息消费者，从 Broker 读取消息的客户端</td></tr><tr><td>ConsumerGroup</td><td>每个 Consumer 属于一个特定的 Consumer Group，一条消息可以被多个不同的 Consumer Group 消费，但是一个 Consumer Group 中只能有一个 Consumer 能够消费该消息。</td></tr><tr><td>Partition</td><td>物理上的概念，一个 topic 可以分为多个 partition，每个 partition 内部消息是有序的</td></tr></tbody></table><p><img src="http://1.117.162.142:9000/blog/kafka%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png" alt="kafka基本概念"></p><h2 id="Kafka-基本使用"><a href="#Kafka-基本使用" class="headerlink" title="Kafka 基本使用"></a>Kafka 基本使用</h2><h3 id="创建主题-topic"><a href="#创建主题-topic" class="headerlink" title="创建主题 topic"></a>创建主题 topic</h3><p>topic 是什么概念？topic 可以实现消息的分类，不同消费者订阅不同的 topic。</p><p>执行以下命令创建 topic，这个 topic 只有一个 partition，并且备份因子也设置为1:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --create --zookeeper zk服务器ip:2181 --replication-factor 1 --partitions 1 --topic topic名</span><br></pre></td></tr></table></figure><p>查看当前 kafka 内有哪些 topic</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topic.sh --list --zookeeper zk服务器ip:2181</span><br></pre></td></tr></table></figure><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>kafka 自带了一个 producer 命令客户端，可以从本地文件中读取内容，或者我们也可以以命令的行中直接输入内容，并将这些内容以消息的形式发送到 kafka 集群中。在默认情况下，每一个行会被当做成一个独立的消息。使用 kafka 的发送消息的客户端，指定发送到的 kafka 服务器地址和 topic。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-producer.sh --broker-list kafka服务器ip:9092 --topic topic名</span><br></pre></td></tr></table></figure><h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><p>对于 consumer，kafka 同样也携带了一个命令行客户端，会将获取到内容在命令中进行输出，默认是消费最新的消息。使用 kafka 的消费者消息的客户端，从制定 kafka 服务器的指定 topic 中消费消息。</p><ul><li><p>方式一：从最后一条消息的偏移量 +1 开始消费</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-consumer.sh --bootstrap-server kafka服务器ip:9092 --topic topic名</span><br></pre></td></tr></table></figure></li><li><p>方式二：从头开始消费</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-consumer.sh --bootstrap-server kafka服务器ip:9092 --from-beginning --topic test</span><br></pre></td></tr></table></figure></li></ul><p>几个注意点：</p><ul><li>消息会被存储</li><li>消息是顺序存储</li><li>消息是有偏移量的</li><li>消费时可以指明偏移量进行消费</li></ul><h2 id="关于消息的细节"><a href="#关于消息的细节" class="headerlink" title="关于消息的细节"></a>关于消息的细节</h2><h3 id="消息的顺序存储"><a href="#消息的顺序存储" class="headerlink" title="消息的顺序存储"></a>消息的顺序存储</h3><ul><li><p>生产者将消息发送给 broker，broker 会将消息保存在本地的日志文件中</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/kafka/log/kafka-logs/分区-主题/00000000.log</span><br></pre></td></tr></table></figure></li><li><p>消息的保存是有序的，通过 offset 偏移量来描述消息的有序性</p></li><li><p>消费者消费消息时也是通过 offset 来描述当前要消费的那条消息的位置</p></li></ul><h3 id="单播消息的实现"><a href="#单播消息的实现" class="headerlink" title="单播消息的实现"></a>单播消息的实现</h3><p>单播消息：一个消费组里只会有一个消费者能消费到某一个 topic 中的消息。于是可以创建多个消费者，这些消费者在同一个消费组中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-consumer.sh --bootstrap-server kafka服务器ip:9092 --consumer-property group.id=消费组名 --topic topic名</span><br></pre></td></tr></table></figure><p><img src="http://1.117.162.142:9000/blog/kafka%E5%8D%95%E6%92%AD%E6%B6%88%E6%81%AF.png" alt="kafka单播消息"></p><h3 id="多播消息的实现"><a href="#多播消息的实现" class="headerlink" title="多播消息的实现"></a>多播消息的实现</h3><p>在一些业务场景中需要让一条消息被多个消费者消费，那么就可以使用多播模式。</p><p>kafka 实现多播，只需要让不同的消费者处于不同的消费组就可以。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-consumer.sh --bootstrap-server kafka服务器ip:9092 --consumer-property group.id=消费组名1 --topic topic名</span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server kafka服务器ip:9092 --consumer-property group.id=消费组名2 --topic topic名</span><br></pre></td></tr></table></figure><p><img src="http://1.117.162.142:9000/blog/kafka%E5%A4%9A%E6%92%AD%E6%B6%88%E6%81%AF.png" alt="kafka多播消息"></p><h3 id="查看消费组及信息"><a href="#查看消费组及信息" class="headerlink" title="查看消费组及信息"></a>查看消费组及信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前主题下有哪些消费组</span></span><br><span class="line">./kafka-consumer-groups.sh --bootstrap-server kafka服务器ip:9092 --list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看消费组中的具体信息：比如当前偏移量、最后一条消息的偏移量、堆积的消息数量</span></span><br><span class="line">./kafka-consumer-groups.sh --bootstrap-server kafka服务器ip:9092 --describe --group 消费组名</span><br></pre></td></tr></table></figure><ul><li>Current-offset：当前消费组的已消费偏移量</li><li>Log-end-offset：主题对应分区消息的结束偏移量 (HW)</li><li>Lag：当前消费组未消费的消息数</li></ul><h2 id="主题、分区的概念"><a href="#主题、分区的概念" class="headerlink" title="主题、分区的概念"></a>主题、分区的概念</h2><h3 id="主题-Topic"><a href="#主题-Topic" class="headerlink" title="主题 Topic"></a>主题 Topic</h3><p>主题 Topic 可以理解成是一个类别的名称。</p><h3 id="分区-Partition"><a href="#分区-Partition" class="headerlink" title="分区 Partition"></a>分区 Partition</h3><p><img src="http://1.117.162.142:9000/blog/partition.png" alt="分区"></p><p>一个主题中的消息量是非常大的，因此可以通过分区的设置，来分布式存储这些消息。比如一个 topic 创建了三个分区。那么 topic 中的消息就会分别存放在这三个分区中。</p><p>为一个主题创建多个分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --create --zookeeper zk服务器ip:2181 --partition 分区数 --topic topic名</span><br></pre></td></tr></table></figure><p>可以通过这样的命令查看 topic 的分区信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --describe --bootstrap-server kafka服务器ip:9092 --topic topic名</span><br></pre></td></tr></table></figure><p>分区的作用：</p><ul><li>可以分布式存储</li><li>可以并行写</li></ul><p>实际上是存在&#x2F;log&#x2F;kafka-logs&#x2F;topic-分区&#x2F;000000000.log 文件中</p><p>消费者吧定期将自己消费分区的 offset 提交给 kafka 内部的 topic：_consumer_offsets，提交过去的时候，key 是 consumerGroupId + Topic + 分区号，value 就是当前 offset 的值，kafka 会定期清理 topic 里的消息，最后就保留最新的那条数据。</p><p>因为 _consumer_offsets 可能会接收高并发的请求，kafka 默认给其分配 50 个分区 (可以通过 offsets.topic.num.partitions 设置)，这样可以通过加机器的方式抗大并发。</p><p>通过如下公式可以选出 consumer 消费的 offset 要提交到 _consumer_offsets 哪个分区</p><p>公式：<code>hash(consumerGroupId) % _consumer_offsets</code> 主题的分区数</p><h2 id="Kafka-集群操作"><a href="#Kafka-集群操作" class="headerlink" title="Kafka 集群操作"></a>Kafka 集群操作</h2><h3 id="在一台服务器上搭建-kafka-集群"><a href="#在一台服务器上搭建-kafka-集群" class="headerlink" title="在一台服务器上搭建 kafka 集群"></a>在一台服务器上搭建 kafka 集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">0 1 2</span></span><br><span class="line">broker.id=2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">9092 9093 9094</span></span><br><span class="line">listeners=PLAINTEXT://ip地址:9092</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">log-0 log-1 log-2</span></span><br><span class="line">log.dir=/opt/kafka/log-1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">./kafka-server-start.sh -daemon ../config/server.properties</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看是否启动成功，进入zookeeper服务器</span></span><br><span class="line">ls /brokers/ids</span><br></pre></td></tr></table></figure><h3 id="副本的概念"><a href="#副本的概念" class="headerlink" title="副本的概念"></a>副本的概念</h3><p>副本是对分区的备份。在集群中，不同的副本会被部署在不同的 broker 上。创建一个主题，两个分区，三个副本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topic.sh --create --zookeeper zk服务器ip：2181 --replication-factor 3 --partitions 2 --topic topic名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 topic 情况</span></span><br><span class="line">./kafka-topics.sh --describe --zookeeper zk服务器ip:2181 --topic topic名</span><br></pre></td></tr></table></figure><p>通过查看主题信息，其中的关键数据：</p><ul><li>replicas：当前副本存在的 broker 节点</li><li>leader：副本里的概念。每个 partition 都有一个 broker 作为 leader。消息发送方要把消息发给哪个 broker？就看副本的 leader 是在哪个 broker 上面。副本里的 leader 专门用来接收消息。接收到消息，其他 follower 通过 poll 的方式来同步数据。</li><li>follower：leader 处理所有针对这个 partition 的读写请求，而 follower 被动复制 leader，不提供读写 (主要是为了保证多副本数据与消费的一致性)，如果 leader 所在的 broker 挂掉，那么就会进行新 leader 选举。通过 kill 掉 leader 后再查看主体情况</li><li>isr：可以同步的 broker 节点和已同步的 broker 节点，存放在 isr 集合中。</li></ul><p><img src="http://1.117.162.142:9000/blog/%E4%B8%BB%E9%A2%98%E3%80%81%E5%88%86%E5%8C%BA%E5%92%8C%E5%89%AF%E6%9C%AC%E7%9A%84%E6%A6%82%E5%BF%B5.png" alt="主题、分区和副本的概念"></p><h3 id="kafka-集群消息的发送"><a href="#kafka-集群消息的发送" class="headerlink" title="kafka 集群消息的发送"></a>kafka 集群消息的发送</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-producer.sh --broker-list kafka服务器0ip:9092,kafka服务器1ip:9092,kafka服务器2ip:9092 --topic topic名</span><br></pre></td></tr></table></figure><h3 id="kafka-集群消息的消费"><a href="#kafka-集群消息的消费" class="headerlink" title="kafka 集群消息的消费"></a>kafka 集群消息的消费</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kafka-console-consumer.sh --boostrap-server kafka服务器0ip:9092,kafka服务器1ip:9092,kafka服务器2ip:9092 --from-beginning --consumer-property group.id=group名 --topic topic名</span><br></pre></td></tr></table></figure><h3 id="关于分区消费组消费者的细节"><a href="#关于分区消费组消费者的细节" class="headerlink" title="关于分区消费组消费者的细节"></a>关于分区消费组消费者的细节</h3><p><img src="http://1.117.162.142:9000/blog/%E5%88%86%E5%8C%BA%E6%B6%88%E8%B4%B9%E7%BB%84%E6%B6%88%E8%B4%B9%E8%80%85.png" alt="分区消费组消费者"></p><p>图中 Kafka 集群有两个 broker，每个 broker 中有多个 partition。一个 partition 只能被一个消费组里的某一个消费组消费，从而保证消费顺序。kafka 只在 partition 的范围内保证消息消费的局部顺序性，不能在同一个 topic 中的多个 partition 中保证总的消费顺序性。一个消费者可以消费多个partition。消费组中消费者的数量不能比一个 topic 中的 partition 数量多，否则多出来的消费者消费不到消息。</p><h2 id="Java-客户端实现生产者"><a href="#Java-客户端实现生产者" class="headerlink" title="Java 客户端实现生产者"></a>Java 客户端实现生产者</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">TOPIC_NAME</span> <span class="operator">=</span> <span class="string">&quot;donkey-topic&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;121.4.107.132:9092&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把发送的key从字符串序列化为字节数组</span></span><br><span class="line">        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        <span class="comment">// 把发送的消息value从字符串序列化为字节数组</span></span><br><span class="line">        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息的客户端</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">        ProducerRecord&lt;String, String&gt; producerRecord = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(TOPIC_NAME, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="type">RecordMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> producer.send(producerRecord).get();</span><br><span class="line">      System.out.println(<span class="string">&quot;同步方式发送消息结果：&quot;</span> + <span class="string">&quot;topic-&quot;</span> + metadata.topic() + <span class="string">&quot;|partition-&quot;</span> + metadata.partition() + <span class="string">&quot;|offset-&quot;</span> + metadata.offset());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送消息到指定分区上"><a href="#发送消息到指定分区上" class="headerlink" title="发送消息到指定分区上"></a>发送消息到指定分区上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; producerRecord = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(TOPIC_NAME, <span class="number">0</span>, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="未指定分区"><a href="#未指定分区" class="headerlink" title="未指定分区"></a>未指定分区</h3><p>会通过业务 key 的 hash 运算，算出消息往哪个分区上发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; producerRecord = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(TOPIC_NAME, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h3><p>生产者同步发送消息，在收到 kafka 的 ack 告知发送成功之前一直处于阻塞状态，阻塞到 3s 的时间，如果还没有收到消息，会进行重试，重试的次数为 3 次。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RecordMetadata metadata <span class="operator">=</span> producer.send(producerRecord).<span class="keyword">get</span>();</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span>阻塞<span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line">System.out.println(&quot;同步方式发送消息结果：&quot; <span class="operator">+</span> &quot;topic-&quot; <span class="operator">+</span> metadata.topic() <span class="operator">+</span> &quot;|partition-&quot; <span class="operator">+</span> metadata.partition() <span class="operator">+</span> &quot;|offset-&quot; <span class="operator">+</span> metadata.offset());</span><br></pre></td></tr></table></figure><h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">producer.send(producerRecord, <span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompletion</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;发送消息失败：&quot;</span> + e.getStackTrace());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (recordMetadata != <span class="literal">null</span>) &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;异步方式发送消息结果：&quot;</span> + <span class="string">&quot;topic-&quot;</span> + recordMetadata.topic() + <span class="string">&quot;｜partition-&quot;</span> + recordMetadata.partition() + <span class="string">&quot;|offset-&quot;</span> + recordMetadata.offset());</span><br><span class="line">          &#125;</span><br><span class="line">          countDownLatch.countDown();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure><h3 id="生产者中的-ack-配置"><a href="#生产者中的-ack-配置" class="headerlink" title="生产者中的 ack 配置"></a>生产者中的 ack 配置</h3><p>在同步发送的前提下，生产者在获得集群返回的 ack 之前会一直阻塞。ack 的三个值：</p><ul><li>acks&#x3D;0：表示producer不需要等待任何broker确认收到消息的回复，就可以继续发送下一条消息。性能最高，但是最容易丢消息。</li><li>acks&#x3D;1 (默认值)：至少要等待leader已经成功将数据写入本地log，但是不需要等待所有follower是否成功写入。就可以继续发送吓一跳消息。这种情况下，如果follower没有成功备份数据，而此时leader又挂掉，则消息会丢失。</li><li>acks&#x3D;-1&#x2F;all：需要等待 min.insync.replicas(默认为1，推荐配置大于等于2)这个参数配置的副本个数都成功写入日志，这种策略会保证只要有一个备份存活就不会丢失数据。这是最强的数据保证。一般除非是金融级别，或跟钱打交道的场景才会使用这种配置。</li></ul><p>下面是关于 ack 和重试 (如果没有收到 ack，就开始重试) 的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props.put(ProducerConfig.ACKS_CONFIG, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="comment">//发送失败会重试，默认重试间隔100ms，重试能保证消息发送的可靠性，</span></span><br><span class="line"><span class="comment">//但是也可能造成消息重复发送，比如网络抖动，所以需要在接收者那边做好消息接收的幂等性处理</span></span><br><span class="line">props.put(ProducerConfig.RETRIES_CONFIG, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 重试间隔设置</span></span><br><span class="line">props.put(ProducerConfig.RETRY_BACKOFF_MS_CONFIG, <span class="number">300</span>);</span><br></pre></td></tr></table></figure><h3 id="生产者中缓冲区的配置"><a href="#生产者中缓冲区的配置" class="headerlink" title="生产者中缓冲区的配置"></a>生产者中缓冲区的配置</h3><p><img src="http://1.117.162.142:9000/blog/kafka%E5%8F%91%E9%80%81%E7%AB%AF%E7%BC%93%E5%86%B2%E5%8C%BA.png" alt="kafka发送端缓冲区"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置发送消息的本地缓冲区，</span></span><br><span class="line"><span class="comment">//设置了该缓冲区，消息会先发送发哦本地缓冲区，可以提高消息发送性能，默认值是33554432(也就是32MB)</span></span><br><span class="line">props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, <span class="number">33554432</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//kafka本地线程会从缓冲区去数据，批量发送到broker，</span></span><br><span class="line"><span class="comment">//设置批量发送消息的大小，默认值是16384，即16kb，就是说一个batch满了16kb就发送出去</span></span><br><span class="line">props.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class="number">16384</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认值是0，意思就是消息必须立即被发送出去，但是这样会影响性能，</span></span><br><span class="line"><span class="comment">//一般设置10ms左右，就是说这个消息发送完后会进入本地的一个batch，</span></span><br><span class="line"><span class="comment">//如果10ms内，这个batch满了16kb就会随batch一起被发送出去，</span></span><br><span class="line"><span class="comment">//如果10ms内，batch没满，那么也必须把消息发送出去，不能让消息的发送延迟时间太长</span></span><br><span class="line">props.put(ProducerConfig.LINGER_MS_CONFIG, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="Java客户端实现消费者"><a href="#Java客户端实现消费者" class="headerlink" title="Java客户端实现消费者"></a>Java客户端实现消费者</h2><h3 id="基本实现-1"><a href="#基本实现-1" class="headerlink" title="基本实现"></a>基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">TOPIC_NAME</span> <span class="operator">=</span> <span class="string">&quot;donkey-topic&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">CONSUMER_GROUP_NAME</span> <span class="operator">=</span> <span class="string">&quot;donkeyGroup&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;121.4.107.132:9092&quot;</span>);</span><br><span class="line">        <span class="comment">// 消费分组名</span></span><br><span class="line">        props.put(ConsumerConfig.GROUP_ID_CONFIG, CONSUMER_GROUP_NAME);</span><br><span class="line">        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(props);</span><br><span class="line">        <span class="comment">// 消费者订阅主题列表</span></span><br><span class="line">        consumer.subscribe(Arrays.asList(TOPIC_NAME));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;收到消息：partition = %d, offset = %d, key = %s, value = %s%n&quot;</span>, record.partition(), record.offset(), record.key(), record.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动提交-offset"><a href="#自动提交-offset" class="headerlink" title="自动提交 offset"></a>自动提交 offset</h3><p><strong>提交的内容：</strong>消费者无论是自动提交还是手动提交，都需要把<strong>所属的消费组+消费的某个主题+消费的某个分区及消费的偏移量</strong>，这样的信息提交到集群的 _consumer_offsets 主题里面。</p><p>设置自动提交参数 - 默认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否自动提交offset，默认就是 true</span></span><br><span class="line">props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="comment">// 自动提交offset的间隔时间</span></span><br><span class="line">props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, <span class="string">&quot;1000&quot;</span>);</span><br></pre></td></tr></table></figure><p>消费者 poll 到消息后默认情况下，会自动向 broker 的 _consumer_offset 主题提交当前主题-分区消费的偏移量。</p><p>自动提交会丢消息：因为如果消费者还没消费完 poll 下来的消息就自动提交了偏移量，那么此时消费者挂了，于是下一个消费者会从已提交的 offset 的下一个位置开始消费消息。之前未被消费的消息就丢失掉了。</p><h3 id="手动提交-offset"><a href="#手动提交-offset" class="headerlink" title="手动提交 offset"></a>手动提交 offset</h3><ul><li><p>设置手动提交参数</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="string">&quot;false&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>在消费完消息后手动提交</p><ul><li><p>手动同步提交</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (records.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 手动同步提交 offset，当前线程会阻塞直到 offset 提交成功</span></span><br><span class="line">  <span class="comment">// 一般使用同步提交，因为提交之后一般也没有什么逻辑代码了</span></span><br><span class="line">  consumer.commitSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>手动异步提交</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (records.count() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 手动异步提交 offset，当前线程提交 offset 不会阻塞，可以继续处理后面的程序逻辑</span></span><br><span class="line">  consumer.commitAsync(<span class="keyword">new</span> <span class="title class_">OffsetCommitCallback</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception e)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Commit failed for &quot;</span> + offsets);</span><br><span class="line">        System.err.println(<span class="string">&quot;Commit failed exception: &quot;</span> + e.getStackTrace());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="消费者-poll-消息的过程"><a href="#消费者-poll-消息的过程" class="headerlink" title="消费者 poll 消息的过程"></a>消费者 poll 消息的过程</h3><ul><li><p>消费者建立了与 broker 之间的长连接，开始 poll 消息。</p></li><li><p>默认一次 poll 500 条消息。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>  可以根据消费速度的快慢来设置，因为如果两次 poll 的时间如果超出了 30s 的时间间隔，kafka 会认为其消费能力过弱，将其踢出消费组。将分区分配给其他消费者。可以通过这个值进行设置：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, <span class="number">30</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果每隔 1s 内没有 poll 到任何消息，则继续去 poll 消息，循环往复，直到 poll 到消息。如果超出了 1s，则此次长轮询结果。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br></pre></td></tr></table></figure></li><li><p>消费者发送心跳的时间间隔</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li><li><p>kafka 如果超过 10s 没有收到消费者的心跳，则会把消费者提出消费组，进行 rebalance，把分区分配给其他消费者。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, <span class="number">10</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="指定分区消费"><a href="#指定分区消费" class="headerlink" title="指定分区消费"></a>指定分区消费</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.assign(Arrays.asList(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(TOPIC_NAME, <span class="number">0</span>)));</span><br></pre></td></tr></table></figure><h3 id="消息回溯消费"><a href="#消息回溯消费" class="headerlink" title="消息回溯消费"></a>消息回溯消费</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">consumer.assign(Arrays.asList(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(TOPIC_NAME, <span class="number">0</span>)));</span><br><span class="line">consumer.seekToBeginning(Arrays.asList(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(TOPIC_NAME, <span class="number">0</span>)));</span><br></pre></td></tr></table></figure><h3 id="指定-offset-消费"><a href="#指定-offset-消费" class="headerlink" title="指定 offset 消费"></a>指定 offset 消费</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">consumer.assign(Arrays.asList(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(TOPIC_NAME, <span class="number">0</span>)));</span><br><span class="line">consumer.seek(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(TOPIC_NAME, <span class="number">0</span>), <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="从指定时间点消费"><a href="#从指定时间点消费" class="headerlink" title="从指定时间点消费"></a>从指定时间点消费</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; topicPartitions = consumer.partitionsFor(TOPIC_NAME);</span><br><span class="line"><span class="comment">// 从一小时前开始消费</span></span><br><span class="line"><span class="type">long</span> <span class="variable">fetchDataTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime() - <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line">Map&lt;TopicPartition, Long&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (PartitionInfo par : topicPartitions) &#123;</span><br><span class="line">  map.put(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(TOPIC_NAME, par.partition()), fetchDataTime);</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;TopicPartition, OffsetAndTimestamp&gt; parMap = consumer.offsetsForTimes(map);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;TopicPartition, OffsetAndTimestamp&gt; entry : parMap.entrySet()) &#123;</span><br><span class="line">  <span class="type">TopicPartition</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">  <span class="type">OffsetAndTimestamp</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">  <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="type">Long</span> <span class="variable">offset</span> <span class="operator">=</span> value.offset();</span><br><span class="line">  System.out.println(<span class="string">&quot;partition-&quot;</span> + key.partition() + <span class="string">&quot;|offset-&quot;</span> + offset);</span><br><span class="line">  System.out.println();</span><br><span class="line">  <span class="comment">// 根据消费里的 timestamp 确定 offset</span></span><br><span class="line">  <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">    consumer.assign(Arrays.asList(key));</span><br><span class="line">    consumer.seek(key, offset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新消费组的消费偏移量"><a href="#新消费组的消费偏移量" class="headerlink" title="新消费组的消费偏移量"></a>新消费组的消费偏移量</h3><p>当消费主题的是一个新的消费组，或者指定 offset 的消费方式，offset 不存在，那么应该如何消费？</p><ul><li><p>latest (默认)：只消费自己启动之后发送到主题的消息</p></li><li><p>earliest：第一次从头开始消费，以后按照消费 offset 记录继续消费，这个需要区别于 consumer.seekToBeginning(每次都从头开始消费)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="string">&quot;earliest&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="SpringBoot-中使用-Kafka"><a href="#SpringBoot-中使用-Kafka" class="headerlink" title="SpringBoot 中使用 Kafka"></a>SpringBoot 中使用 Kafka</h2><h3 id="导入-Maven-依赖"><a href="#导入-Maven-依赖" class="headerlink" title="导入 Maven 依赖"></a>导入 Maven 依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="comment"># kafka服务器地址</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="number">121.4</span><span class="number">.107</span><span class="number">.132</span><span class="string">:9092</span></span><br><span class="line">    <span class="comment"># 生产者</span></span><br><span class="line">    <span class="attr">producer:</span></span><br><span class="line">      <span class="comment"># 设置大于0的值，则客户端会将发送失败的记录重新发送</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">batch-size:</span> <span class="number">16384</span></span><br><span class="line">      <span class="attr">buffer-memory:</span> <span class="number">33554432</span></span><br><span class="line">      <span class="attr">acks:</span> <span class="number">1</span></span><br><span class="line">      <span class="comment"># 指定消息key和消息体的编解码方式</span></span><br><span class="line">      <span class="attr">key-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">      <span class="attr">value-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">    <span class="comment"># 消费者</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="attr">group-id:</span> <span class="string">donkey-group</span></span><br><span class="line">      <span class="attr">enable-auto-commit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">auto-offset-reset:</span> <span class="string">earliest</span></span><br><span class="line">      <span class="attr">key-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">      <span class="attr">value-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">      <span class="attr">max-poll-records:</span> <span class="number">500</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">ack-mode:</span> <span class="string">manual_immediate</span></span><br><span class="line">      <span class="comment"># 每当一条记录被消费者监听器(ListenerConsumer)处理之后提交</span></span><br><span class="line">      <span class="comment"># RECORD</span></span><br><span class="line">      <span class="comment"># 每当一批poll()的数据被消费者监听器(ListenerConsumer)处理之后提交</span></span><br><span class="line">      <span class="comment"># BATCH</span></span><br><span class="line">      <span class="comment"># 当每一批poll()的数据被消费者监听器(ListenerConsumer)处理之后，距离上次提交时间大于TIME时提交</span></span><br><span class="line">      <span class="comment"># TIME</span></span><br><span class="line">      <span class="comment"># 当每一批poll()的数据被消费者监听器(ListenerConsumer)处理之后，被处理record数量大于等于COUNT时提交</span></span><br><span class="line">      <span class="comment"># COUNT</span></span><br><span class="line">      <span class="comment"># TIME ｜ COUNT 有一条件满足时提交</span></span><br><span class="line">      <span class="comment"># COUNT_TIME</span></span><br><span class="line">      <span class="comment"># 当每一批poll()的数据被消费者监听器(ListenerConsumer)处理之后，手动调用Acknowledgment.acknowledge()后提交</span></span><br><span class="line">      <span class="comment"># MANUAL</span></span><br><span class="line">      <span class="comment"># 手动调用Acknowledgment.acknowledge()后立即提交，一般使用这种情况</span></span><br><span class="line">      <span class="comment"># MANUAL_IMMEDIATE</span></span><br></pre></td></tr></table></figure><h3 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/msg&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaController</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">TOPIC_NAME</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Autowire</span></span><br><span class="line">  <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/send&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    kafkaTemplate.send(TOPIC_NAME, <span class="number">0</span>, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;this is a message!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;send success!&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@KafkaListener(topics = &#123;&quot;&quot;&#125;, groupId = &quot;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumerMessage2</span><span class="params">(ConsumerRecords&lt;String, String&gt; records, Acknowledgment ack)</span> &#123;</span><br><span class="line">        <span class="comment">// 批量处理</span></span><br><span class="line">      ack.acknowledge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@KafkaListener(groupId = &quot;&quot;, topicPartitions = &#123;</span></span><br><span class="line"><span class="meta">          @TopicPartition(topic = &quot;&quot;, partitions = &quot;&#123;&quot;&quot;, &quot;&quot;&#125;&quot;),</span></span><br><span class="line"><span class="meta">          @TopicPartition(topic = &quot;&quot;, partitions = &quot;&quot;, partitionOffsets = @PartitionOffset(partition = &quot;&quot;, initialOffset = &quot;&quot;))</span></span><br><span class="line"><span class="meta">  &#125;, concurrency = &quot;&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumerMessage3</span><span class="params">(ConsumerRecord&lt;String, String&gt; record, Acknowledgment ack)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> record.value();</span><br><span class="line">      logger.info(value);</span><br><span class="line">      logger.info(String.valueOf(record));</span><br><span class="line">      ack.acknowledge();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Kafka-集群-Controller、Rebalance-和-HW"><a href="#Kafka-集群-Controller、Rebalance-和-HW" class="headerlink" title="Kafka 集群 Controller、Rebalance 和 HW"></a>Kafka 集群 Controller、Rebalance 和 HW</h2><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>Kafka 集群中的 broker 在 zk 中创建临时序号节点，序号最小的节点 (最先创建的节点) 将作为集群的 controller，负责管理整个集群中的所有分区和副本的状态：</p><ul><li>当某个分区的 leader 副本出现故障时，由控制器负责为该分区选举新的 leader 副本。</li><li>当检测到某个分区的 ISR 集合发生变化时，由控制器负责通知所有 broker 更新其元数据信息。</li><li>当使用 kafka-topics.sh 脚本为某个 topic 增加分区数量时，同样还是由控制器负责让新分区被其他节点感知到。</li></ul><h3 id="Rebalance"><a href="#Rebalance" class="headerlink" title="Rebalance"></a>Rebalance</h3><p>前提是：消费者没有指明分区消费。当消费组里消费者和分区的关系发生变化，那么就会触发 rebalance 机制。</p><p>这个机制会重新调整消费者消费哪个分区。</p><p>在触发 rebalance 机制之前，消费者消费哪个分区有三种策略：</p><ul><li>range：通过公示来计算某个消费者消费哪个分区，<code>分区数量 / 消费者数量 + 1</code></li><li>轮询：大家轮着消费</li><li>sticky：在触发了 rebalance 后，在消费者消费的原分区不变的基础上进行调整。</li></ul><h3 id="HW-和-LEO"><a href="#HW-和-LEO" class="headerlink" title="HW 和 LEO"></a>HW 和 LEO</h3><p>HW 俗称高水位，HighWatermark 的缩写，取一个 partition 对应的 ISR 中最小的 LEO (log-end-offset) 作为 HW，consumer 最多只能消费到 HW 所在的位置。另外每个 replica 都有 HW，leader 和 follower 各自负责更新自己的 HW 的状态。对于 leader 新写入的消息，consumer 不能立刻消费，leader 会等待该消息被所有 ISR 中的 replicas 同步更新 HW，此时消息才能被 consumer 消费。这样就保证了如果 leader 所在的 broker 失效，该消息仍然可以从新选举的 leader 中获取。</p><p><img src="http://1.117.162.142:9000/blog/hw%E5%92%8Cleo.png" alt="hw和leo"></p><h2 id="Kafka-线上问题优化"><a href="#Kafka-线上问题优化" class="headerlink" title="Kafka 线上问题优化"></a>Kafka 线上问题优化</h2><h3 id="如何防止消息丢失"><a href="#如何防止消息丢失" class="headerlink" title="如何防止消息丢失"></a>如何防止消息丢失</h3><ul><li>发送方：ack 是 1 或者 -1&#x2F;all 可以防止消息丢失，如果要做到 99.999%，ack 设成 all，把 min.insync.replicas 配置成分区备份数</li><li>消费方：把自动提交改为手动提交。</li></ul><h3 id="如何防止消息的重复消费"><a href="#如何防止消息的重复消费" class="headerlink" title="如何防止消息的重复消费"></a>如何防止消息的重复消费</h3><p>一条消息被消费者消费多次。如果为了消息的不重复消费，而把生产端的重试机制关闭、消费端的手动提交改成自动提交，这样反而会出现消息丢失，那么可以直接在防止消息丢失的手段上再加上消费消息时的幂等性保证，就能解决消息的重复消费问题 。</p><p>幂等性如何保证：</p><ul><li>mysql 插入业务 id 作为主键，主键是唯一的，所以一次只能插入一条</li><li>使用 redis 或 zk 的分布式锁 (主流的方案)</li></ul><h3 id="如何做到顺序消费"><a href="#如何做到顺序消费" class="headerlink" title="如何做到顺序消费"></a>如何做到顺序消费</h3><ul><li><p>发送方：在发送时将 ack 不能设置 0，关闭重试，使用同步发送，等到发送成功在发送下一条。确保消息是顺序发送的。</p></li><li><p>接收方：消息是发送到一个分区中，只能有一个消费组的消费者来接收消息。</p><p>  因此，kafka 的顺序消费会牺牲掉性能。</p></li></ul><h3 id="解决消息积压问题"><a href="#解决消息积压问题" class="headerlink" title="解决消息积压问题"></a>解决消息积压问题</h3><p>消息积压会导致很多问题，比如磁盘被打满、生产端发消息导致 kafka 性能过慢，就容易出现服务雪崩，就需要有相应的手段：</p><ul><li>方案一：在一个消费者中启动多个线程，让多个线程同时消费。提升一个消费者的消费能力。</li><li>方案二：如果方案一还不够的话，这个时候可以启动多个消费者，多个消费者部署在不同的服务器上。其实多个消费者部署在同一服务器上也可以提高消费能力——充分利用服务器的 CPU 资源。</li><li>方案三：让一个消费者去把收到的消息往另一个 topic 上发，另一个 topic 设置多个分区和多个消费者，进行具体的业务消费。</li></ul><h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p>延迟队列的应用场景：在订单创建成功后如果超过 30 分钟没有付款，则需要取消订单，此时可用延时队列来实现</p><ul><li>创建多个 topic，每个 topic 表示延时的间隔<ul><li>topic_5s：延时 5s 执行的队列</li><li>topic_1m：延时 1 分钟执行的队列</li><li>topic_30m：延时 30 分钟执行的队列</li></ul></li><li>消息发送者发送消息到相应的 topic，并带上消息的发送时间</li><li>消费者订阅相应的 topic，消费时轮询消费整个 topic 中的消息<ul><li>如果消息的发送时间，和消费者的当前时间超过预设的值，比如 30 分钟</li><li>如果消息的发送时间，和消费的当前时间没有超过预设的值，则不消费当前的 offset 及之后的 offset 的所有消息都消费</li><li>下次继续消费该 offset 处的消息，判断时间是否已满足预设值。</li></ul></li></ul><h2 id="Kafka-eagle"><a href="#Kafka-eagle" class="headerlink" title="Kafka eagle"></a>Kafka eagle</h2><p>官网：<a href="https://www.kafka-eagle.org/">https://www.kafka-eagle.org/</a></p><ul><li>下载安装包、解压</li><li>安装 JDK 环境</li><li>配置 kafka-eagle 环境变量</li><li>修改配置文件：zk 服务器地址和 mysql 服务器地址</li><li>启动</li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 进阶</title>
      <link href="/2022/10/31/mysql-advanced/"/>
      <url>/2022/10/31/mysql-advanced/</url>
      
        <content type="html"><![CDATA[<h2 id="一、用户与权限管理"><a href="#一、用户与权限管理" class="headerlink" title="一、用户与权限管理"></a>一、用户与权限管理</h2><h3 id="1-用户管理"><a href="#1-用户管理" class="headerlink" title="1. 用户管理"></a>1. 用户管理</h3><p>MySQL 用户可以分为普通 用户和 root 用户。root 用户是超级管理员，拥有所有权限，包括创建用户、删除用户和修改用户的密码等管理权限；普通用户只拥有被授予的各种权限。</p><p>MySQL 提供了许多语句用来管理用户账号，这些语句可以用来管理包括登录和退出 MySQL 服务器、创建用户、删除用户、密码管理和权限管理等内容。</p><h4 id="1-1-登录-MySQL-服务器"><a href="#1-1-登录-MySQL-服务器" class="headerlink" title="1.1 登录 MySQL 服务器"></a>1.1 登录 MySQL 服务器</h4><p>启动 MySQL 服务器后，可以通过 mysql 命令来登录服务器。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h hostname<span class="operator">|</span>hostIP <span class="operator">-</span>P port <span class="operator">-</span>u username <span class="operator">-</span>p DatabaseName <span class="operator">-</span>e &quot;SQL语句&quot;</span><br></pre></td></tr></table></figure><ul><li><code>-h 参数</code> 后面接主机名或主机 IP，hostname 为主机，hostIP 为主机 IP。</li><li><code>-P 参数</code> 后面接 MySQL服务器的端口，通过该参数连接到指定的端口。MySQL 服务的默认端口是 3306，不使用该参数时自动连接到 3306 端口，port 为连接的端口号。</li><li><code>-u 参数</code> 后面接用户名，username 为用户名。</li><li><code>-p 参数</code> 会提示输入密码。</li><li><code>DatabaseName 参数</code> 知名登录到哪一个数据库中。如果没有该参数，就会直接登录到 MySQL 数据库中，然后可以使用 USE 命令来选择数据库。</li><li><code>-e 参数</code> 后面可以直接加 SQL 语句。登录 MySQL 服务器以后即可执行这个 SQL 语句，然后退出 MySQL 服务器。</li></ul><h4 id="1-2-创建用户"><a href="#1-2-创建用户" class="headerlink" title="1.2 创建用户"></a>1.2 创建用户</h4><p>在 MySQL 数据库中，官方推荐使用 <code>CREATE USER</code> 语句来创建新用户。MySQL 8 版本移除了 PASSWORD 加密方法，因此不再推荐使用 INSERT 语句直接操作 MySQL 中的 user 表来增加用户。</p><p>使用 <code>CREATE USER</code> 语句来创建新用户时，必须拥有 CREATE USER 权限。每添加一个用户，CREATE USER 语句会在 MySQL.user 表中添加一条新记录，但是新创建的账户没有任何权限。如果添加的账户已经存在，CREATE USER 语句就会返回一个错误。</p><p>CREATE USER 语句的基本语法形式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> 用户名 [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>][, 用户名 [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>]];</span><br></pre></td></tr></table></figure><ul><li>用户名参数表示新建用户的账户，由用户 (User) 和 主机名 (Host) 构成；</li><li>“[]”表示可选，也就是说，可以指定用户登录时需要密码验证，也可以不指定密码验证，这样用户可以直接登录。不过，不指定密码的方式不安全，不推荐使用。如果指定密码值，这里需要使用 IDENTIFIED BY 指定明文密码值。</li><li>CREATE USER 语句可以同时创建多个用户。</li></ul><h4 id="1-3-修改用户"><a href="#1-3-修改用户" class="headerlink" title="1.3 修改用户"></a>1.3 修改用户</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 修改用户名</span><br><span class="line"><span class="keyword">UPDATE</span> mysql.user <span class="keyword">SET</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">USER</span> <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><h4 id="1-4-删除用户"><a href="#1-4-删除用户" class="headerlink" title="1.4 删除用户"></a>1.4 删除用户</h4><p>在 MySQL 数据库中，可以使用 <code>DROP USER</code> 语句来删除普通用户，也可以直接在 mysql.user 表中删除用户。</p><p><strong>方式一：使用 DROP 方式删除 (推荐)</strong></p><p>使用 DROP USER 语句来删除用户时，必须拥有 DROP USER 权限。DROP USER 语句的基本语法形式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="keyword">user</span>[, <span class="keyword">user</span>] ...; # 默认删除的是<span class="keyword">user</span>@<span class="operator">%</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="keyword">user</span>@<span class="string">&#x27;host&#x27;</span></span><br></pre></td></tr></table></figure><p>其中，user 参数是需要删除的用户，由用户的用户名 (User) 和主机名 (Host) 组成。DROP USER 语句可以同事删除多个用户，各用户之间用逗号隔开。</p><p><strong>方式二：使用 DELETE 方式删除</strong></p><p>可以使用 DELETE 语句直接将用户的信息从 mysql.user 表中删除，但必须拥有对 mysql.user 表的 DELETE 权限。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mysql.user <span class="keyword">WHERE</span> Host<span class="operator">=</span><span class="string">&#x27;hostname&#x27;</span> <span class="keyword">AND</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;username&#x27;</span>;</span><br></pre></td></tr></table></figure><p>Host 字段和 User 字段是 user 表的联合主键，因此两个字段的值才能唯一确定一条记录。</p><p>执行完 DELETE 命令后要使用 FLUSH 命令来使用户生效，命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>:::tip</p><p>不推荐通过 <code>DELETE FROM USER u WHERE USER=&#39;&#39;;</code> 进行删除，系统会有残留信息保留。而 <code>DROP user</code> 命令会删除用户以及对应的权限，执行命令 mysql.user 表和 mysql.db 表的相应记录都消失了。</p><p>:::</p><h4 id="1-5-设置当前用户密码"><a href="#1-5-设置当前用户密码" class="headerlink" title="1.5 设置当前用户密码"></a>1.5 设置当前用户密码</h4><p>适用于 root 用户修改自己的密码，以及普通用户登录后修改自己的密码。</p><p>root 用户拥有很高的权限，因此必须保证 root 用户的密码安全。root 用户可以通过多种方式来修改密码，使用 ALTER USER 修改用户密码是 MySQL 官方推荐的方式。此外，也可以通过 SET 语句修改密码。由于 MySQL 8 中已移除了 PASSWORD() 函数，因此不再使用 UPDATE 语句直接操作用户表修改密码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 旧的写法 (MySQL <span class="number">5.7</span> 测试有效)</span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="operator">=</span> PASSWORD(<span class="string">&#x27;密码&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 使用 <span class="keyword">ALTER</span> <span class="keyword">USER</span> 命令来修改当前用户密码 (推荐使用)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">USER</span>() IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;NEW_PASSWORD&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 使用 <span class="keyword">SET</span> 语句来修改当前用户密码，该语句会自动将密码加密后再赋给当前用户</span><br><span class="line"><span class="keyword">SET</span> PASSWORD<span class="operator">=</span><span class="string">&#x27;new_password&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="1-6-修改其它用户密码"><a href="#1-6-修改其它用户密码" class="headerlink" title="1.6 修改其它用户密码"></a>1.6 修改其它用户密码</h4><p>root 用户不仅可以修改自己的密码，还可以修改其它普通用户的密码。root 用户登录 MySQL 服务器后，可以通过 ALTER 语句和 SET 语句来修改普通用户的密码。由于 PASSWORD() 函数已移除，因此使用 UPDATE 直接操作用户表的方式已不再使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 使用 <span class="keyword">ALTER</span> 语句来修改普通用户的密码</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">user</span> [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>][, <span class="keyword">user</span> [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>]];</span><br><span class="line"></span><br><span class="line"># 使用 <span class="keyword">SET</span> 命令来修改普通用户的密码</span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span><span class="operator">=</span><span class="string">&#x27;new_password&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 使用 <span class="keyword">UPDATE</span> 语句修改普通用户密码 (不推荐)</span><br><span class="line"><span class="keyword">UPDATE</span> MySQL.user <span class="keyword">SET</span> authentication_string<span class="operator">=</span>PASSWORD(<span class="string">&#x27;new_password&#x27;</span>) </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;username&#x27;</span> <span class="keyword">AND</span> Host<span class="operator">=</span><span class="string">&#x27;hostname&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="1-7-MySQL-8-密码管理"><a href="#1-7-MySQL-8-密码管理" class="headerlink" title="1.7 MySQL 8 密码管理"></a>1.7 MySQL 8 密码管理</h4><p>MySQL 中记录使用过的历史密码，目前包含如下密码管理功能：</p><ul><li>密码过期：要求定期修改密码。</li><li>密码重用限制：不允许使用旧密码。</li><li>密码强度评估：要求使用高强度密码。</li></ul><blockquote><p>提示</p><p>MySQL 密码管理功能只针对使用基于 MySQL 授权插件的账号，这些插件有 mysql_native_password、sha256_password 和 caching_sha2_password。</p></blockquote><p><strong>密码过期策略</strong></p><ul><li>在 MySQL 中，数据库管理员可以手动设置账号密码过期，也可以建一个自动密码过期策略。</li><li>过期策略可以是全局的，也可以为每个账号设置单独的过期策略。</li></ul><p><strong>手动设置立马过期</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">user</span> PASSWORD EXPIRE;</span><br></pre></td></tr></table></figure><p>该语句将密码设置为过期后，用户仍然可以登录数据库，但是无法进行查询，只有在重置了密码后，才可进行查询。</p><p><strong>手动设置指定时间过期：全局</strong></p><p>如果密码使用的时间大于允许的时间，服务器会自动设置为过期，不需要手动设置。</p><p>MySQL 使用 <code>default_password_lifetime</code> 系统变量建立全局密码过期策略。</p><ul><li>它的默认值是 0，表示禁用自动密码过期。</li><li>它允许的值是正整数 N，表示允许的密码生存期。密码必须每隔 N 天进行修改。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用 <span class="keyword">SQL</span> 语句更改该变量的值并持久化</span><br><span class="line"><span class="keyword">SET</span> PERSIST default_password_lifetime <span class="operator">=</span> <span class="number">180</span>; # 建立全局策略，设置密码每隔 <span class="number">180</span> 天过期</span><br><span class="line"></span><br><span class="line"># 配置文件my.cnf(或my.ini)中进行维护</span><br><span class="line">[mysqld]</span><br><span class="line">default_password_lifetime<span class="number">-180</span> # 建立全局策略，设置密码每隔 <span class="number">180</span> 天过期</span><br></pre></td></tr></table></figure><p><strong>手动设置指定时间过期：单独设置</strong></p><p>每隔账号既可延用全局密码过期策略，也可单独设置策略。在 CREATE USER 和 ALTER USER 语句上加入 PASSWORD EXPIRE 选项可实现单独设置策略。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 设置 rose 账号密码每<span class="number">90</span>天过期；</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE <span class="type">INTERVAL</span> <span class="number">90</span> <span class="keyword">DAY</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE <span class="type">INTERVAL</span> <span class="number">90</span> <span class="keyword">DAY</span>;</span><br><span class="line"></span><br><span class="line"># 设置密码永不过期；</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE NAVER;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE NAVER;</span><br><span class="line"></span><br><span class="line"># 延用全局密码过期策略</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE <span class="keyword">DEFAULT</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE <span class="keyword">DEFAULT</span>;</span><br></pre></td></tr></table></figure><p><strong>密码重用策略</strong></p><p>MySQL 限制使用已用过的密码。重用限制策略基于密码更改的数量和使用的时间。重用策略可以是全局的，也可以为每个账号设置单独的策略。</p><ul><li><p>账号的历史密码包含过去该账号所使用的密码。MySQL 基于以下规则来限制密码重用：</p><ul><li>如果账号的密码限制<strong>基于密码更改的数量</strong>，那么新密码不能从最近限制的密码数量中选择。例如，如果密码更改的最小值为 3，那么新密码不能与最近 3 个密码中任何一个相同。</li><li>如果账号密码限制<strong>基于时间</strong>，那么新密码不能从规定时间内选择。例如，如果密码重用周期为 60 天，那么新密码不能从最近 60 天内使用的密码中选择。</li></ul></li><li><p>MySQL 使用 password_history 和 password_reuser_interval 系统变量设置密码重用策略。</p><ul><li><code>password_history</code>：规定密码重用的数量</li><li><code>password_reuser_interval</code>: 规定密码重用的周期</li></ul></li><li><p>这两个值可在服务器的配置文件中进行维护，也可在运行期间使用 SQL 语句更改该变量的值并持久化。</p></li><li><p>手动设置密码重用方式一：全局</p><ul><li><p>使用 SQL</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 设置不能选择最近使用过的 <span class="number">6</span> 个密码</span><br><span class="line"><span class="keyword">SET</span> PERSIST password_history <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">#设置不能选择最近一年内的密码</span><br><span class="line"><span class="keyword">SET</span> PERSIST password_reuse_interval <span class="operator">=</span> <span class="number">365</span>;</span><br></pre></td></tr></table></figure></li><li><p>my.cnf (或 my.ini) 配置文件</p>  <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">password_history</span>=<span class="string">6</span></span><br><span class="line"><span class="attr">password_reuser_interval</span>=<span class="string">365</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>手动设置密码重用方式二：单独设置</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 不能使用最近 <span class="number">5</span> 个密码</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD HISTORY <span class="number">5</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD HISTORY <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"># 不能使用最近 <span class="number">365</span> 天内的密码</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD REUSE <span class="type">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD REUSE <span class="type">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br><span class="line"></span><br><span class="line"># 既不能使用最近 <span class="number">5</span> 个密码，也不能使用 <span class="number">365</span> 天内的密码</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> </span><br><span class="line">PASSWORD HISTORY <span class="number">5</span></span><br><span class="line">PASSWORD REUSE <span class="type">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> </span><br><span class="line">PASSWORD HISTORY <span class="number">5</span></span><br><span class="line">PASSWORD REUSE <span class="type">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br><span class="line"></span><br><span class="line"># 延用全局策略</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> </span><br><span class="line">PASSWORD HISTORY <span class="keyword">DEFAULT</span></span><br><span class="line">PASSWORD REUSE <span class="type">INTERVAL</span> <span class="keyword">DEFAULT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;rose&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> </span><br><span class="line">PASSWORD HISTORY <span class="keyword">DEFAULT</span></span><br><span class="line">PASSWORD REUSE <span class="type">INTERVAL</span> <span class="keyword">DEFAULT</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2. 权限管理"></a>2. 权限管理</h3><p>关于 MySQL 的权限简单的理解就是 MySQL 允许你做你权力以内的事情，不可以越界。比如只允许你执行 SELECT 操作，那么你就不能执行 UPDATE 操作。只允许你从某台机器上连接 MySQL，那么就不能从除那台机器外的其它机器连接 MySQL。</p><h4 id="2-1-权限列表"><a href="#2-1-权限列表" class="headerlink" title="2.1 权限列表"></a>2.1 权限列表</h4><p>使用 <code>show privileges;</code> 查看权限列表</p><ul><li><code>CREATE 和 DROP 权限</code>，可以创建新的数据库和表，或删除 (移掉) 已有的数据库和表。如果将 MySQL 数据库中的 DROP 权限授予某用户，用户就可以删除 MySQL 访问权限保存的数据库。</li><li><code>SELECT、INSERT、UPDATE 和 DELETE 权限 </code>允许在一个数据库现有的表上实施操作。</li><li><code>SELECT 权限 </code>只有在它们真正从一个表中检索行时才被用到。</li><li><code>INDEX 权限</code> 允许创建或删除索引，INDEX 适用于已有的表。如果具有某个表的 CREATE 权限，就可以在 CREATE TABLE 语句中包括索引定义。</li><li><code>ALTER 权限</code> 可以使用 ALTER TABLE 来更改表的结构和重新命名表。</li><li><code>CREATE ROUTINE 权限</code> 用来创建保存的程序 (函数和程序)，ALTER ROUTINE 权限用来更改和删除保存的程序，<code>EXECUTE 权限</code> 用来执行保存的程序。</li><li><code>GRANT 权限</code> 允许授权给其它用户，可用于数据库、表和保存的程序。</li><li><code>FILE 权限</code> 是用户可以使用 <code>LOAD DATA INFILE</code> 和 <code>SELECT ... INTO OUTFILE</code> 语句读或写服务器上的文件，任何被授予 FILE 权限的用户都能读或写 MySQL 服务器上的任何文件 (说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件)。</li></ul><p>MySQL 的权限如何分布：</p><table><thead><tr><th>权限分布</th><th>可能的设置的权限</th></tr></thead><tbody><tr><td>表权限</td><td><code>Select</code>, <code>Insert</code>, <code>Update</code>, <code>Delete</code>, <code>Create</code>, <code>Drop</code>, <code>Grant</code>, <code>References</code>, <code>Index</code>, <code>Alter</code></td></tr><tr><td>列权限</td><td><code>Select</code>, <code>Insert</code>, <code>Update</code>, <code>References</code></td></tr><tr><td>过程权限</td><td><code>Execute</code>, <code>Alter Routine</code>, <code>Grant</code></td></tr></tbody></table><h4 id="2-2-授予权限的原则"><a href="#2-2-授予权限的原则" class="headerlink" title="2.2 授予权限的原则"></a>2.2 授予权限的原则</h4><p>权限控制主要是出于安全因素，因此需要遵循以下几个经验原则：</p><ol><li>只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给 select 权限就可以了，不要给用户赋予 update、insert 或者 delete 权限。</li><li>创建用户的时候限制用户的登录主机，一般是限制成指定 IP 或者内网 IP 段。</li><li>为每个用户设置满足密码复杂度的密码。</li><li>定期清理不需要的用户，回收权限或者删除用户。</li></ol><h4 id="2-3-授予权限"><a href="#2-3-授予权限" class="headerlink" title="2.3 授予权限"></a>2.3 授予权限</h4><p>给用户授权的方式有两种，分别是通过把角色赋予用户给用户授权和直接给用户授权。用户是数据库的使用者，我们可以通过给用户授予访问数据库中资源的权限，来控制使用者对数据库的访问，消除安全隐患。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限<span class="number">1</span>, 权限<span class="number">2</span>, ..., 权限n <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> 用户名@用户地址 [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码口令&#x27;</span>];</span><br></pre></td></tr></table></figure><ul><li>该权限如果发现没有该用户，则会直接新建一个用户。 </li><li>如果要给所有权限，可以使用 ALL PRIVILEGES，但不包括 GRANT 权限。</li><li>如果要赋予包括 GRANT 的权限，添加参数 <code>WITH GRANT OPTION</code> 这个选项即可，表示该用户可以将自己拥有的权限授权给别人。经常有人在创建操作用户的时候不指定 <code>WITH GRANT OPTION</code> 选项导致后来该用户不能使用 GRANT 命令创建用户或者给其它用户授权。</li><li>可以使用 GRANT 重复给用户添加权限，权限叠加，比如你先给用户添加一个 SELECT 权限，然后又给用户添加一个 INSERT 权限，那么该用户就同时拥有了 SELECT 和 INSERT 权限。</li></ul><blockquote><p>在开发应用的时候，经常会遇到一种需求，就是要根据用户的不同，对数据进行横向和纵向的分组。</p><ul><li>所谓横向的分组，就是指用户可以接触到的数据范围，比如可以看到那些表的数据；</li><li>所谓纵向的分组，就是指用户对接触到的数据能访问到什么程度，比如能看、能改，甚至是删除。</li></ul></blockquote><h4 id="2-4-查看权限"><a href="#2-4-查看权限" class="headerlink" title="2.4 查看权限"></a>2.4 查看权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前用户权限</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANT</span>;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="built_in">CURRENT_USER</span>;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="built_in">CURRENT_USER</span>();</span><br><span class="line"></span><br><span class="line"># 查看某用户的全局权限</span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;主机地址&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="2-5-收回权限"><a href="#2-5-收回权限" class="headerlink" title="2.5 收回权限"></a>2.5 收回权限</h4><p>收回全新啊就是取消已经赋予用户的某些权限。收回用户不必要的权限可以在一定程度上保证系统的安全性。MySQL 中使用 <code>REVOKE 语句</code> 取消用户的某些权限。使用 REVOKE 收回权限之后，用户账户的记录将从 db、host、tables_priv 和 column_priv 表中删除，但是用户账户记录仍然在 user 表中保存 (删除 user 表中的账户记录使用 DROP USER 语句)。</p><p><strong>注意：再将用户账户从 user 表删除之前，应该收回相应用户的所有权限</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限<span class="number">1</span>, 权限<span class="number">2</span>, ..., 权限n <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">FROM</span> 用户名@用户地址;</span><br></pre></td></tr></table></figure><p><strong>注意：须用户重新登录后才能生效</strong>。</p><blockquote><p>总结</p><p>有一些程序员喜欢使用 Root 超级用户来访问数据库，完全把权限控制放在应用层面实现。这样当然也是可以的。但建议大家，尽量使用数据库自己的角色和用户机制来控制访问权限，不要轻易用 Root 账号。因为 Root 账号密码放在代码里面不安全，一旦泄露，数据库就会完全失去保护。</p><p>而且，MySQL 的权限控制功能十分完善，应该尽量利用，可以提高效率，而且安全可靠。</p></blockquote><h3 id="3-权限表"><a href="#3-权限表" class="headerlink" title="3. 权限表"></a>3. 权限表</h3><p>MySQL 服务器通过权限表来控制用户对数据库的访问，权限表存放在 mysql 数据库中。MySQL 数据库系统会根据这些权限表的内容为每个用户赋予相应的权限。这些权限表中最重要的是 <code>user表</code>、<code>db表</code>。除此之外，还有 <code>tables_priv 表</code> 、<code>columns_priv 表</code> 和 <code>procs_priv 表</code> 等。在 MySQL 启动时，服务器将这些数据库表中权限信息的内容读入内存。</p><table><thead><tr><th>表名</th><th>描述</th></tr></thead><tbody><tr><td>user</td><td>用户账号及权限信息</td></tr><tr><td>global_grants</td><td>动态全局授权</td></tr><tr><td>db</td><td>数据库层级的权限</td></tr><tr><td>tables_priv</td><td>表层级的权限</td></tr><tr><td>columns_priv</td><td>列层级的权限</td></tr><tr><td>procs_priv</td><td>存储的过程和函数权限</td></tr><tr><td>proxies_priv</td><td>代理用户的权限</td></tr><tr><td>default_roles</td><td>账号连接并认证后默认授予的角色</td></tr><tr><td>role_edges</td><td>角色子图的边界</td></tr><tr><td>password_history</td><td>密码更改信息</td></tr></tbody></table><h3 id="4-访问控制"><a href="#4-访问控制" class="headerlink" title="4. 访问控制"></a>4. 访问控制</h3><p>连接请求来时，会匹配 mysql 数据库中 user 表里的 user、host 和 password，全部匹配成功才连接成功，这是连接核实阶段。接下来访问数据库、表、字段时，会去 db、tables_priv、columns_priv 表里匹配当前用户的权限。这是请求核实阶段。</p><h3 id="5-角色管理"><a href="#5-角色管理" class="headerlink" title="5. 角色管理"></a>5. 角色管理</h3><p>角色是在 MySQL 8.0 中引入的新功能。在 MySQL 中，角色是权限的集合，可以为角色添加或移除权限。用户可以被赋予角色，同时也被授予角色包含的权限。对角色进行操作需要较高的权限。并且向用户账户一样，角色可以游泳授予和撤销的权限。</p><p>引入角色的目的是方便管理拥有相同权限的用户。恰当的权限设定，可以确保数据的安全性，这是至关重要的。</p><h4 id="5-1-创建角色"><a href="#5-1-创建角色" class="headerlink" title="5.1 创建角色"></a>5.1 创建角色</h4><p>在实际应用中，为了安全性，需要给用户授予权限。当用户数量较多时，为了避免单独给每一个用户授予多个权限，可以先讲权限集合放入角色中，再赋予用户相应的角色。</p><p>创建角色使用 <code>CREATE ROLE</code> 语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>][, <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>]]...</span><br></pre></td></tr></table></figure><p>角色名称的命名规则和用户名类似。如果 host_name 省略，默认为 %，role_name 不可省略，不可为空。</p><h4 id="5-2-给角色赋予权限"><a href="#5-2-给角色赋予权限" class="headerlink" title="5.2 给角色赋予权限"></a>5.2 给角色赋予权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privileges <span class="keyword">ON</span> table_name <span class="keyword">TO</span> <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>];</span><br></pre></td></tr></table></figure><ul><li>Privileges 代表权限的命你在，多个权限用逗号隔开。</li></ul><h4 id="5-3-查看角色的权限"><a href="#5-3-查看角色的权限" class="headerlink" title="5.3 查看角色的权限"></a>5.3 查看角色的权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;role_name&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>只要创建了一个角色，系统就会自动给一个 USAGE 权限，意思是连接登录数据库的权限。</li></ul><h4 id="5-4-回收角色的权限"><a href="#5-4-回收角色的权限" class="headerlink" title="5.4 回收角色的权限"></a>5.4 回收角色的权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> privileges <span class="keyword">ON</span> table_name <span class="keyword">FROM</span> <span class="string">&#x27;role_name&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="5-5-删除角色"><a href="#5-5-删除角色" class="headerlink" title="5.5 删除角色"></a>5.5 删除角色</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> ROLE role [, role2]...</span><br></pre></td></tr></table></figure><h4 id="5-6-给用户赋予角色"><a href="#5-6-给用户赋予角色" class="headerlink" title="5.6 给用户赋予角色"></a>5.6 给用户赋予角色</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> role [, role2, ...] <span class="keyword">TO</span> <span class="keyword">user</span> [, user2, ...];</span><br></pre></td></tr></table></figure><h4 id="5-7-激活角色"><a href="#5-7-激活角色" class="headerlink" title="5.7 激活角色"></a>5.7 激活角色</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 方式一：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">DEFAULT</span> ROLE <span class="keyword">ALL</span> <span class="keyword">TO</span> <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;host_name&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 方式二：将 active_all_roles_on_login 设置为 <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> activate_all_roles_on_login<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line"># 上面这条<span class="keyword">SQL</span>的意思是对所有角色永久激活。</span><br><span class="line"></span><br><span class="line"># 查看当前已激活的角色</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_ROLE</span>();</span><br></pre></td></tr></table></figure><h4 id="5-8-撤销用户的角色"><a href="#5-8-撤销用户的角色" class="headerlink" title="5.8 撤销用户的角色"></a>5.8 撤销用户的角色</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> role <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><h4 id="5-9-设置强制角色-mandatory-role"><a href="#5-9-设置强制角色-mandatory-role" class="headerlink" title="5.9 设置强制角色 (mandatory role)"></a>5.9 设置强制角色 (mandatory role)</h4><p>强制角色是给每个创建账户的默认角色，不需要手动设置，强制角色无法被 REVOKE 或者 DROP。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 方式一：服务启动前设置</span><br><span class="line">[mysqld]</span><br><span class="line">mandatory_roles<span class="operator">=</span><span class="string">&#x27;role1,role2@localhost,...&#x27;</span></span><br><span class="line"></span><br><span class="line"># 方式二：运行时设置</span><br><span class="line"><span class="keyword">SET</span> PERSIST mandatory_roles <span class="operator">=</span> <span class="string">&#x27;role1,role2@localhost,...&#x27;</span>;# 系统重启后仍然有效</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> mandatory_roles <span class="operator">=</span> <span class="string">&#x27;role1,role2@localhost,...&#x27;</span>;# 系统重启后失效</span><br></pre></td></tr></table></figure><h4 id="5-10-小结"><a href="#5-10-小结" class="headerlink" title="5.10 小结"></a>5.10 小结</h4><p>MySQL 主要管理角色的语句如下：</p><table><thead><tr><th align="center">语句</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">CREATE ROLE and DROP ROLE</td><td align="center">创建和删除角色</td></tr><tr><td align="center">GRANT and REVOKE</td><td align="center">给角色或者用户分配&#x2F;撤销权限</td></tr><tr><td align="center">SHOW GRANTS</td><td align="center">显示用户&#x2F;角色所拥有的权限或者角色</td></tr><tr><td align="center">SET DEFAULT ROLE</td><td align="center">设置账户默认使用什么角色</td></tr><tr><td align="center">SET ROLE</td><td align="center">改变当前会话的角色</td></tr><tr><td align="center">CURRENT_ROLE()</td><td align="center">显示当前会话的角色</td></tr><tr><td align="center">Mandatory_roles 和 activate_all_roles_on_login 系统变量</td><td align="center">允许定义用户登录时强制的或者激活授权的角色</td></tr></tbody></table><h2 id="二、逻辑架构"><a href="#二、逻辑架构" class="headerlink" title="二、逻辑架构"></a>二、逻辑架构</h2><h3 id="1-逻辑架构剖析"><a href="#1-逻辑架构剖析" class="headerlink" title="1. 逻辑架构剖析"></a>1. 逻辑架构剖析</h3><h4 id="1-1-服务器处理客户端请求"><a href="#1-1-服务器处理客户端请求" class="headerlink" title="1.1 服务器处理客户端请求"></a>1.1 服务器处理客户端请求</h4><p>首先 MySQL 是典型的 C&#x2F;S 架构，即 Client &#x2F; Server 架构，服务器端程序使用的 mysqld。不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：**客户端进程向服务器进程发送一段文本 (SQL 语句)，服务器进程处理后再向客户端进程发送一段文本 (处理结果)**。</p><p>下图为服务器处理客户端进程发送的查询请求的示例图：</p><p><img src="http://1.117.162.142:9000/blog/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82.png" alt="服务器处理客户端请求"></p><p>具体结构：</p><p><img src="http://1.117.162.142:9000/blog/mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.png" alt="mysql逻辑架构"></p><h4 id="1-2-Connectors"><a href="#1-2-Connectors" class="headerlink" title="1.2 Connectors"></a>1.2 Connectors</h4><p>Connectors，指的是不同语言中与 SQL 的交互。MySQL 首先是一个网络程序，在 TCP 之上定义了自己的应用层协议。所以要使用 MySQL，我们可以编写代码，跟 MySQL Server 建立 TCP 连接，之后按照其定义好的协议进行交互。或者比较方便的办法是调用 SDK，比如 Native C API、JDBC、PHP等各语言 MySQL Connector，或者通过 ODBC。但<strong>通过 SDK 来访问 MySQL，本质上还是在 TCP 连接上通过 MySQL 协议跟 MySQL 进行交互</strong>。</p><p>MySQL Server 结构可以分为三层：</p><h4 id="1-3-第一层：连接层"><a href="#1-3-第一层：连接层" class="headerlink" title="1.3 第一层：连接层"></a>1.3 第一层：连接层</h4><p>系统 (客户端) 访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。</p><p>经过三次握手建立连接成功后，MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。</p><ul><li>用户名或密码不对，会收到一个 Access denied for user 错误，客户端程序结束执行。</li><li>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖此时读到的权限。</li></ul><blockquote><p>一个系统只会和 MySQL 服务器建立一个连接吗？只能有一个系统和 MySQL 服务器建立连接吗？</p></blockquote><p>当然不是，多个系统都可以和 MySQL 服务器建立连接，每个系统建立的连接肯定不止一个。所以，为了解决 TCP 无限创建与 TCP频繁创建销毁带来的资源耗尽、性能下降问题。MySQL 服务器里有专门的 <strong>TCP 连接池</strong>限制连接数，采用<strong>长连接模式</strong>复用 TCP 连接，来解决上述问题。</p><p><img src="http://1.117.162.142:9000/blog/mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0.png" alt="mysql连接池"></p><p>TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><p>所以连接管理的职责是负责认证、管理连接、获取权限信息。</p><h4 id="1-4-第二层：服务层"><a href="#1-4-第二层：服务层" class="headerlink" title="1.4 第二层：服务层"></a>1.4 第二层：服务层</h4><p>第二层架构主要完成大多数的核心服务功能，如 SQL 接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p><p>在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化：如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。</p><p>如果是 SELECT 语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><ul><li><p><strong>SQL Interface：SQL 接口</strong></p><ul><li>接收用户的 SQL 命令，并且返回用户需要查询的结果。比如 SELECT … FROM 就是调用 SQL Interface</li><li>MySQL 支持 DML (数据操作语言)、DDL (数据定义语言)、存储过程、视图、触发器、自定义函数等多种 SQL 语言接口</li></ul></li><li><p><strong>Parser：解析器</strong></p><ul><li>在解析器中对 SQL 语句进行语法分析、语义分析。将 SQL 语句分解成数据结构，并将这个结构传递到后续步骤，以后 SQL 语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个 SQL 语句是不合理的。</li><li>在 SQL 命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL 还会对 SQL 查询进行语法上的优化，进行查询重写。</li></ul></li><li><p><strong>Optimizer：优化器</strong></p><ul><li><p>SQL 语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划。</p></li><li><p>这个执行计划表明应该使用哪些索引进行查询 (全表检索还是使用索引检索)，表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</p></li><li><p>它使用 <code>选取-投影-连接</code> 策略进行查询。例如</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure><p>  这个 SELECT 查询先根据 WHERE 语句进行选取，而不是将表全部查询出来以后再进行 gender 过滤。</p><p>  这个 SELECT 查询先根据 id 和 name 进行属性投影，而不是将属性全部取出来以后再进行过滤，将这两个查询条件连接起来生成最终查询结果。</p></li></ul></li><li><p><strong>Caches &amp; Buffers：查询缓存组件</strong></p><ul><li>MySQL 内部维持着一些 Cache 和 Buffer，比如 Query Cache 用来缓存一条 SELECT 语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存，权限缓存等。</li><li>这个查询缓存可以在不同客户端之间共享。</li><li>从 MySQL 5.7.20 开始，不推荐使用查询缓存，并在 MySQL 8.0 中删除。</li></ul></li></ul><h4 id="1-5-第三层：引擎层"><a href="#1-5-第三层：引擎层" class="headerlink" title="1.5 第三层：引擎层"></a>1.5 第三层：引擎层</h4><p>和其它数据库相比，MySQL 有点与众不同，它的架构可以在多种场景中应用并发挥良好作用，主要体现在存储引擎的架构上，插件式的存储引擎结构将查询处理和其它的系统任务以及数据的存储提取相分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。同时开源的 MySQL 还允许开发人员设置自己的存储引擎。</p><p>这种高效的模块化结构为那些希望专门针对特定应用程序需求 (例如数据仓库、事务处理或高可用性情况) 的人提供了巨大的好处，同时享受使用一组独立于任何借口和服务的优势存储引擎。</p><p>插件式存储引擎层 (Storage Engines)，<strong>真正的负责了 MySQL 中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</strong>，服务器通过 API 于存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p><p>MySQL 8.0.27 默认支持的存储引擎如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> engines;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> Engine             <span class="operator">|</span> Support <span class="operator">|</span> Comment                                                        <span class="operator">|</span> Transactions <span class="operator">|</span> XA   <span class="operator">|</span> Savepoints <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> ARCHIVE            <span class="operator">|</span> YES     <span class="operator">|</span> Archive storage engine                                         <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLACKHOLE          <span class="operator">|</span> YES     <span class="operator">|</span> <span class="operator">/</span>dev<span class="operator">/</span><span class="keyword">null</span> storage engine (anything you write <span class="keyword">to</span> it disappears) <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MRG_MYISAM         <span class="operator">|</span> YES     <span class="operator">|</span> Collection <span class="keyword">of</span> identical MyISAM tables                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FEDERATED          <span class="operator">|</span> <span class="keyword">NO</span>      <span class="operator">|</span> Federated MySQL storage engine                                 <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MyISAM             <span class="operator">|</span> YES     <span class="operator">|</span> MyISAM storage engine                                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> PERFORMANCE_SCHEMA <span class="operator">|</span> YES     <span class="operator">|</span> Performance Schema                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> InnoDB             <span class="operator">|</span> <span class="keyword">DEFAULT</span> <span class="operator">|</span> Supports transactions, <span class="type">row</span><span class="operator">-</span>level locking, <span class="keyword">and</span> <span class="keyword">foreign</span> keys     <span class="operator">|</span> YES          <span class="operator">|</span> YES  <span class="operator">|</span> YES        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MEMORY             <span class="operator">|</span> YES     <span class="operator">|</span> Hash based, stored <span class="keyword">in</span> memory, useful <span class="keyword">for</span> temporary tables      <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CSV                <span class="operator">|</span> YES     <span class="operator">|</span> CSV storage engine                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br></pre></td></tr></table></figure><h4 id="1-6-存储层"><a href="#1-6-存储层" class="headerlink" title="1.6 存储层"></a>1.6 存储层</h4><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存在的，并完成于存储引擎的交互。当然有些存储引擎比如 InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的使用是的这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用 DAS、NAS、SAN 等各种存储系统。</p><h4 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7 小结"></a>1.7 小结</h4><p>简化 SQL 执行流程：</p><p><img src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="简化sql执行流程"></p><p>简化为三层结构：</p><ol><li>连接层：客户端和服务端建立连接，客户端发送 SQL 至服务器端；</li><li>SQL 层 (服务层)：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</li><li>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</li></ol><h3 id="2-SQL-执行流程"><a href="#2-SQL-执行流程" class="headerlink" title="2. SQL 执行流程"></a>2. SQL 执行流程</h3><h4 id="2-1-MySQL-中的-SQL-执行流程"><a href="#2-1-MySQL-中的-SQL-执行流程" class="headerlink" title="2.1 MySQL 中的 SQL 执行流程"></a>2.1 MySQL 中的 SQL 执行流程</h4><p><img src="http://1.117.162.142:9000/blog/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="sql执行流程"></p><p>MySQL 的查询流程：</p><ol><li><p><strong>查询缓存</strong>：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL 8.0 之后就抛弃了这个功能。</p><p> MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被肢解缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被肢解返回给客户端。如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。所以，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><blockquote><p>大多数情况查询缓存就是个鸡肋，为什么呢？</p></blockquote><p> 查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的鲁棒性大大降低，只有相同的查询操作才会命中查询缓存。两个查询请求在任何字符上的不同 (如空格、注释、大小写)，都会导致缓存不会命中。因此 MySQL 的查询缓存命中率不高。</p><p> 同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql、information_schema、performance_schema 数据库中的表，那这个查询就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数 NOW，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的。</p><p> 此外，既然时缓存，那就有它缓存失效的时候。MySQL 的缓存系统会监测涉及到的每张表，只要该表的结果或者数据被修改，如对该表使用了 INSERT、UPDATE、DELETE、TRUNCATE TABLE、ALTER TABLE、DROP TABLE 或 DROP DATABASE 语句，那使用该表的所有高速缓存存储都将变为无效并从高速缓存中删除。对于更新压力大的数据库来说，查询缓存的命中率会非常低。</p><p> <strong>总之，因为查询缓存往往弊大于利，查询缓存的失效非常频繁</strong>。</p><p> 一般建议大家在静态表里使用查询缓存，什么叫静态表呢？就是一般我们极少更新的表。比如，一个系统配置表、字典表、这种表上的查询才适合使用查询缓存。好在 MySQL 也提供了这种“按需使用”的方式。你可以将 my.cnf 参数 query_cache_type 设置成 DEMAND，代表当 SQL 语句中有 SQL_CACHE 关键词时才缓存。</p></li><li><p><strong>解析器</strong>：在解析器中对 SQL 语句进行语法分析、语义分析。</p><p> 如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。SQL 语句的分析分为词法分析与语法分析。</p><p> 分析器先做词法分析。你输入的是由多少个字符串和空格组成的一条 SQL 语句，MySLQ 需要识别出里面的字符串分别是什么，代表什么。</p><p> MySLQ 从你输入的 “select” 这个关键字识别出来，这是一个查询语句。它也要把字符串 “T” 识别成”表名 T“，把字符串 “ID” 识别成 “列ID”。</p><p> 接着，要做语法分析。根据词法分析的结果，语法分析器 (比如：Bison) 会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><p> 如果你的 语句不对，就会收到 “You have an error in you SQL syntax” 的错误提醒。 </p><p> sql词法分析过程：</p><p> <img src="http://1.117.162.142:9000/blog/sql%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B.png" alt="sql词法分析过程"></p></li><li><p><strong>优化器</strong>：在优化器中会确定 SQL 语句的执行路径，比如时根据全表检索，还是根据索引检索等。</p><p> 经过了解析器，MySQL 就知道要做什么了。在开始执行之前，还要先经过优化器的处理。<strong>一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划</strong>。</p><p> 比如：优化器是在表里面有多个索引的时候，决定使用那个索引；或者在一个语句有多表关联 (join) 的时候，决定各个表的连接顺序，还有表达式简化、子查询转为连接、外连接转为内连接等。</p><p> 在查询优化器中，可以分为逻辑查询优化阶段和物理查询优化阶段。</p><p> 逻辑查询优化就是通过改变 SQL 语句的内容来时的 SQL 查询更高效，同时为物理查询优化提供更多的候选执行计划。通常采用的方式是对 SQL 语句进行等价变换，对查询进行重写，而查询重写的数学基础就是关系代数。对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等。</p><p> 物理查询优化是基于关系代数进行的查询重写，而关系代数的每一步都对应着无力计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。在这个阶段里，对于单表和多表连接的操作，需要高效地使用索引，提升查询效率。</p></li><li><p><strong>执行器</strong>：</p><p> 截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了执行器阶段。在执行之前需要判断该用户是否具备权限。如果没有，就会返回权限错误。如果具备权限，就执行 SQL 查询并返回结果。在 MySQL 8.0 以下的版本，如果设置了查询缓存，这是会讲查询结果进行缓存。</p><p> 如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，调用存储引擎 API 对表进行读写。存储引擎 API 只是抽象接口，下面还有个存储引擎层，具体实现还是要看表选择的存储引擎。</p></li></ol><p>SQL 语句在 MySQL 中的执行流程是：<code>SQL 语句 → 查询缓存 → 解析器 → 优化器 → 执行器</code>。</p><p><img src="http://1.117.162.142:9000/blog/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B2.png" alt="sql执行流程2"></p><h4 id="2-2-MySQL-8-中-SQL-执行原理"><a href="#2-2-MySQL-8-中-SQL-执行原理" class="headerlink" title="2.2 MySQL 8 中 SQL 执行原理"></a>2.2 MySQL 8 中 SQL 执行原理</h4><p>前面的结构图很复杂，我们需要抓取最核心的部分：SQL 的执行原理。不同 DBMS 的 SQL 的执行原理是相通的，只是在不同的软件中，各有各的实现路径。</p><p>既然一条 SQL 语句会经历不同的模块，那接下来看下在不同的模块中，SQL 执行所使用的资源 (时间) 是怎样的。如何在 MySQL 中对一条 SQL 语句的执行时间进行分析。</p><ol><li><p>确认 profiling 是否开启</p><p> 了解查询语句底层执行的过程：<code>select @@profiling;</code> 或者 <code>show variables like &#39;%profiling&amp;&#39;;</code> 查看是否开启计划。开启它可以让 MySQL 收集在 SQL 执行时所使用的资源情况。</p><p> profiling&#x3D;0 代表关闭，将其改为 1，<code>set profiling=1;</code>。Profiling 功能由 MySQL 会话变量：profiling 控制。默认是 OFF。</p></li><li><p>多次执行相同 SQL 查询</p></li><li><p>查看 profiles</p><p> <code>SHOW profiles;</code> 和 <code>SHOW profile;</code> 语句可以展示当前会话 (退出 session 后，profiling 重置为 0) 中执行语句的资源使用情况。</p></li></ol><h3 id="3-数据库缓冲池-buffer-pool"><a href="#3-数据库缓冲池-buffer-pool" class="headerlink" title="3. 数据库缓冲池 (buffer pool)"></a>3. 数据库缓冲池 (buffer pool)</h3><p>InnoDB 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面 (包括读页面、写页面、创建新页面等操作)。而磁盘 I&#x2F;O需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请占用内存来作为数据缓冲池，在真正访问页面之前，需要把磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访问。</p><p>这样做的好处是可以让磁盘活动最小化，从而减少与磁盘直接进行 I&#x2F;O 的时间。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里面，那么访问的成本就会降低很多。</p><h4 id="3-1-缓冲池-vs-查询缓存"><a href="#3-1-缓冲池-vs-查询缓存" class="headerlink" title="3.1 缓冲池 vs 查询缓存"></a>3.1 缓冲池 vs 查询缓存</h4><ul><li><p>缓冲池</p><p>  在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，如下图：</p><p>  <img src="http://1.117.162.142:9000/blog/%E7%BC%93%E5%86%B2%E6%B1%A0.png" alt="缓冲池"></p><p>  从图中，可以看到 InnoDB 缓冲池包括了数据页、索引页、插入缓存、锁信息、自适应 Hash 和数据字典信息等。</p><p>  <strong>缓冲池的重要性</strong>：</p><p>  对于使用 InnoDB 作为存储引擎的表来说，不管是用于存储用户数据的索引 (包括聚簇索引和二级索引)，还是各种系统数据，都是以页的形式存放在表空间中的，而所谓的表空间只不过是 InnoDB 对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。但是各位也都知道，磁盘的速度慢得跟乌龟一样，怎么能配得上 CPU 呢。这里，缓冲池可以帮助我们消除 CPU 和磁盘之间的鸿沟。所以 InnoDB 存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，也就是说即使我们只需要访问一夜的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘 I&#x2F;O 的开销了。</p><p>  <strong>缓存原则</strong>：</p><p>  <code>为止 * 频次</code> 这个原则，可以帮我们对 I&#x2F;O 访问效率进行优化。</p><p>  首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。</p><p>  其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会优先对使用频次高的热数据进行加载。</p><p>  <strong>缓冲池的预读特性</strong>：</p><p>  了解了缓冲池的作用之后，我们还需要了解缓冲池的另一个特性：<strong>预读</strong>。</p><p>  缓冲池的作用就是提升 I&#x2F;O 效率，而我们进行读取数据的时候存在一个局部性原理，也就是说我们使用了一些数据，大概率还会使用它周围的一些数据，因此采用预读的机制提前加载，可以减少未来可能的磁盘 I&#x2F;O 操作。</p></li><li><p>查询缓存</p><p>  那么什么是查询缓存呢？</p><p>  查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</p><p>  缓冲池服务于数据库整体的 I&#x2F;O 操作，它们的共同点都是通过缓存的机制来提升效率。</p></li></ul><h4 id="3-2-缓冲池如何读取数据"><a href="#3-2-缓冲池如何读取数据" class="headerlink" title="3.2 缓冲池如何读取数据"></a>3.2 缓冲池如何读取数据</h4><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p><p>缓存在数据库中的结构和作用：</p><p><img src="http://1.117.162.142:9000/blog/%E7%BC%93%E5%AD%98%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E4%BD%9C%E7%94%A8.png" alt="缓存在数据库中的结构和作用"></p><p>如果我们执行 SQL 语句的时候更新了缓冲池中的数据，那么这些数据会马上同步到磁盘上吗？</p><p>实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会以一定的频率刷新到磁盘上。注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做 <code>checkpoint</code> 的机制将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。</p><p>比如，当缓冲池不够用时，需要释放掉一些不常用的页，此时就可以强行采用 checkpoint 的方式，将不常用的脏页回写到磁盘上，然后再从缓冲池中将这些页释放掉。这里脏页指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。</p><h4 id="3-3-查看-x2F-设置缓冲池的大小"><a href="#3-3-查看-x2F-设置缓冲池的大小" class="headerlink" title="3.3 查看&#x2F;设置缓冲池的大小"></a>3.3 查看&#x2F;设置缓冲池的大小</h4><p>如果你使用的是 MySQL MyISAM 存储引擎，它只缓存索引，不缓存数据，对应的键缓存参数为 <code>key_buffer-size</code>，你可以用它进行查看。</p><p>如果你使用的是 InnoDB 存储引擎，可以通过查看 <code>innodb_buffer_pool_size</code> 变量来查看缓冲池的大小。命令如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看缓冲池大小</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_size&#x27;</span>; # 单位是 B</span><br><span class="line"></span><br><span class="line"># 修改缓冲池大小</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_buffer_pool_size <span class="operator">=</span> xxxxx;</span><br><span class="line">或</span><br><span class="line">[mysqld]</span><br><span class="line">innodb_buffer_pool_size <span class="operator">=</span> xxxxxx</span><br></pre></td></tr></table></figure><h4 id="3-4-多个-Buffer-Pool-实例"><a href="#3-4-多个-Buffer-Pool-实例" class="headerlink" title="3.4 多个 Buffer Pool 实例"></a>3.4 多个 Buffer Pool 实例</h4><p>Buffer Pool 本质是 InnoDB 向操作系统申请的一块连续的内存空间，再多线程环境下，访问 Buffer Pool 中的数据都需要加锁处理。在 Buffer Pool 特别大而且多线程并发访问特别高的情况下，单一的 Buffer Pool 可能会影响请求的处理速度。所以在 Buffer Pool 特别大的时候，我们可以把它们拆分成若干个小的 Buffer Pool，每个 Buffer Pool 都称为一个实例，它们都是独立的，独立的去申请内存空间，独立的管理各种链表。所以在多线程并发访问时并不会相互影响，从而提高并发处理能力。</p><p>我们可以在服务器启动的时候通过设置 <code>innodb_buffer_pool_instances</code> 的值来修改 Buffer Pool 实例的个数。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[server]</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_instances</span> = <span class="string">2</span></span><br></pre></td></tr></table></figure><p>这样就表明我们要创建两个 Buffer Pool 实例。</p><p>查看缓冲池的个数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_instances&#x27;</span>;</span><br></pre></td></tr></table></figure><p>每个 Buffer Pool实例实际占多少内存空间公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size / innodb_buffer_pool_instances</span><br></pre></td></tr></table></figure><p>也就是总共的大小除以实例的个数，结果就是每个 Buffer Pool 实例占用的大小。</p><p>不过也不是说 Buffer Pool 实例创建的越多越好，分别管理各个 Buffer Pool 也是需要性能开销的，InnoDB 规定：当 innodb_buffer_pool_size 的值小于 1G 的时候设置多个实例是无效的，InnoDB 会默认把 innodb_buffer_pool_instances 的值改为 1。而我们鼓励在 Buffer Pool 大于或等于 1G 的时候设置多个 Buffer Pool 实例。</p><h4 id="3-5-引申问题"><a href="#3-5-引申问题" class="headerlink" title="3.5 引申问题"></a>3.5 引申问题</h4><p>Buffer Pool 是MySQL 内存结构中十分核心的一个组成，可以把它想象成一个黑盒子。</p><p><strong>黑盒下的更新数据流程</strong></p><p>当我们查询数据的时候，会先去把 Buffer Pool 中查询。如果 Buffer Pool 中不存在，存储引擎会先将数据从磁盘加载到 Buffer Pool 中，然后将数据返回给客户端；同理，当我们更新某个数据的时候，如果这个数据不存在于 Buffer Pool，同样会先将数据加载进来，然后修改内存的数据。被修改过的数据会在之后统一刷入磁盘。</p><p><img src="http://1.117.162.142:9000/blog/%E9%BB%91%E7%9B%92%E4%B8%8B%E7%9A%84%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B.png" alt="黑盒下的更新数据流程"></p><p>这个过程看似没啥问题，实则是有问题的。假设我们修改 Buffer Pool 中的数据成功，但是还没来得及讲数据刷入磁盘 MySQL 就挂了怎么办？按照上图的逻辑，此时更新之后的数据只存在于 Buffer Pool 中，如果此时 MySQL 服务宕机了，这部分数据将会永久地消失。</p><p>再者，我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回滚都做不到还谈什么崩溃恢复？</p><p>利用 <code>Redo Log &amp; Undo Log</code>。</p><h2 id="三、存储引擎"><a href="#三、存储引擎" class="headerlink" title="三、存储引擎"></a>三、存储引擎</h2><p>为了管理方便，人们把连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存储的功能划分为MySQL Server 的功能，把真实存取数据的功能划分为存储引擎的功能。所以在MySQL Server 完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</p><p>MySQL 中提到了存储引擎的概念。简而言之，存储引擎就是指表的类型。其实存储引擎以前叫做表处理器，后来改名为存储引擎，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。</p><h3 id="1-查看存储引擎"><a href="#1-查看存储引擎" class="headerlink" title="1. 查看存储引擎"></a>1. 查看存储引擎</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> engines;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> Engine             <span class="operator">|</span> Support <span class="operator">|</span> Comment                                                        <span class="operator">|</span> Transactions <span class="operator">|</span> XA   <span class="operator">|</span> Savepoints <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> ARCHIVE            <span class="operator">|</span> YES     <span class="operator">|</span> Archive storage engine                                         <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLACKHOLE          <span class="operator">|</span> YES     <span class="operator">|</span> <span class="operator">/</span>dev<span class="operator">/</span><span class="keyword">null</span> storage engine (anything you write <span class="keyword">to</span> it disappears) <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MRG_MYISAM         <span class="operator">|</span> YES     <span class="operator">|</span> Collection <span class="keyword">of</span> identical MyISAM tables                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FEDERATED          <span class="operator">|</span> <span class="keyword">NO</span>      <span class="operator">|</span> Federated MySQL storage engine                                 <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MyISAM             <span class="operator">|</span> YES     <span class="operator">|</span> MyISAM storage engine                                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> PERFORMANCE_SCHEMA <span class="operator">|</span> YES     <span class="operator">|</span> Performance Schema                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> InnoDB             <span class="operator">|</span> <span class="keyword">DEFAULT</span> <span class="operator">|</span> Supports transactions, <span class="type">row</span><span class="operator">-</span>level locking, <span class="keyword">and</span> <span class="keyword">foreign</span> keys     <span class="operator">|</span> YES          <span class="operator">|</span> YES  <span class="operator">|</span> YES        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MEMORY             <span class="operator">|</span> YES     <span class="operator">|</span> Hash based, stored <span class="keyword">in</span> memory, useful <span class="keyword">for</span> temporary tables      <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CSV                <span class="operator">|</span> YES     <span class="operator">|</span> CSV storage engine                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br></pre></td></tr></table></figure><ul><li><code>Engine 参数</code> 表示存储引擎名称。</li><li><code>Support 参数</code> 表示 MySQL 数据库管理系统是否支持该存储引擎：YES 表示支持，NO 表示不支持。</li><li><code>DEFAULT</code> 表示系统默认支持的存储引擎。</li><li><code>Comment 参数</code> 表示对存储引擎的评论。</li><li><code>Transactions 参数</code> 表示存储引擎是否支持事务：YES 表示支持，NO 表示不支持。</li><li><code>XA 参数</code> 表示存储引擎所支持的分布式是否符合 XA 规范：YES 表示支持，NO 表示不支持。代表着该存储引擎是否支持分布式事务。</li><li><code>Saverpoints 参数</code> 表示存储引擎是否支持事务处理的保存点：YES 表示支持，NO 表示不支持。也就是说，该存储引擎是否支持部分事务回滚。</li></ul><h3 id="2-设置系统默认的存储引擎"><a href="#2-设置系统默认的存储引擎" class="headerlink" title="2. 设置系统默认的存储引擎"></a>2. 设置系统默认的存储引擎</h3><ul><li><p>查看默认的存储引擎</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span>;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@default</span>_storage_engine;</span><br></pre></td></tr></table></figure></li><li><p>修改默认的存储引擎</p><p>  如果在创建表的语句中没有显示指定表的存储引擎的话，那就会默认使用 InnoDB 作为表的存储引擎。如果我们想改变表的默认存储引擎的话，可以这样可启动服务器的命令行：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> DEFAULT_STORAGE_ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure><p>  或者修改 my.cnf (Windows 系统叫 my.ini) 文件：</p>  <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">default_storage_engine</span>=<span class="string">MyISAM</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">restart mysqld.service</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-设置表的存储引擎"><a href="#3-设置表的存储引擎" class="headerlink" title="3. 设置表的存储引擎"></a>3. 设置表的存储引擎</h3><p>存储引擎室负责对表中的数据进行提取和写入工作的，我们可以为不同的表设置不同的存储引擎，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。</p><h4 id="3-1-创建表时指定存储引擎"><a href="#3-1-创建表时指定存储引擎" class="headerlink" title="3.1 创建表时指定存储引擎"></a>3.1 创建表时指定存储引擎</h4><p>我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎 InnoDB。如果我们想显式的指定一下表的存储引擎，那可以这么写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">建表语句;</span><br><span class="line">) ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure><h4 id="3-2-修改表的存储引擎"><a href="#3-2-修改表的存储引擎" class="headerlink" title="3.2 修改表的存储引擎"></a>3.2 修改表的存储引擎</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure><h3 id="4-引擎介绍"><a href="#4-引擎介绍" class="headerlink" title="4. 引擎介绍"></a>4. 引擎介绍</h3><h4 id="4-1-InnoDB-引擎：具备外键支持功能的事务存储引擎"><a href="#4-1-InnoDB-引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="4.1 InnoDB 引擎：具备外键支持功能的事务存储引擎"></a>4.1 InnoDB 引擎：具备外键支持功能的事务存储引擎</h4><ul><li>MySQL 从 3.23.34a 开始就包含 InnoDB 存储引擎。大于等于 5.5 之后，默认采用 InnoDB 引擎。</li><li>InnoDB 是 MySQL 的默认事务型引擎，它被设计用来处理大量的短期 (short-lived) 事务。可以确保事务的完整提交 (Commit) 和 回滚 (Rollback)。</li><li>除了增加和查询外，还需要更新、删除操作，那么，应优先选择 InnoDB 存储引擎。</li><li>除非有非常特别的原因需要使用其它的存储引擎，否则应该优先考虑 InnoDB 引擎。</li><li>数据文件结构：<ul><li>表名.frm 存储表结构 (MySQL 8.0 时，合并在表名.ibd 中)</li><li>表名.ibd 存储数据和索引</li></ul></li><li>InnoDB 是为处理巨大数据量的最大性能设计。<ul><li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如 <code>.frm</code>，<code>.par</code>， <code>.trn</code>，<code>.isl</code>，<code>.db</code>，<code>.opt</code> 等都在MySQL 8.0 中不存在了。</li></ul></li><li>对比 MyISAM 的存储引擎，InnoDB 写的处理效率差一些，并且会占用更多的磁盘空间以保存数据和索引。</li><li>MyISAM 只缓存索引，不缓存真实数据；InnoDB 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响。</li></ul><h4 id="4-2-MyISAM-引擎：主要的非事务处理存储引擎"><a href="#4-2-MyISAM-引擎：主要的非事务处理存储引擎" class="headerlink" title="4.2 MyISAM 引擎：主要的非事务处理存储引擎"></a>4.2 MyISAM 引擎：主要的非事务处理存储引擎</h4><ul><li>MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数 (GIS) 等，但 MyISAM 不支持事务、行级锁、外键，有一个毫无疑问的缺陷就是崩溃后无法安全回复。</li><li>5.5 之前默认的存储引擎。</li><li>优势是访问的速度快，对事物完整性没有要求或者以 SELECT、INSERT 为主的应用。</li><li>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高。</li><li>数据文件结构：<ul><li>表名.frm 存储表结构</li><li>表名.MYD 存储数据 (MYData)</li><li>表名.MYI 存储索引 (MYIndex)</li></ul></li><li>应用场景：只读应用或者以读为主的业务。</li></ul><h4 id="4-3-Archive-引擎：用于数据存档"><a href="#4-3-Archive-引擎：用于数据存档" class="headerlink" title="4.3 Archive 引擎：用于数据存档"></a>4.3 Archive 引擎：用于数据存档</h4><ul><li><p><code>archive</code> 是归档的意思，仅仅支持插入和查询两种功能 (行被插入后不能再修改)。</p></li><li><p>在 MySQL 5.5 以后支持索引的功能。</p></li><li><p>拥有很好的压缩机制，使用 zlib 压缩裤，在记录请求的时候实时的进行压缩，经常被用来作为仓库使用。</p></li><li><p>创建 ARCHIVE 表时，存储引擎会创建名称以表名开头的文件。数据文件的扩展名为 <code>.ARZ</code>。</p></li><li><p>根据英文的测试结论来看，同样数据量下，Archive 表比 MyISAM 表要小大约 75%，比支持事务处理的 InnoDB 表小大约 83%。</p></li><li><p>ARCHIVE 存储引擎采用了行级锁。该 ARCHIVE 引擎支持 AUTO_INCREMENT 列属性。AUTO_INCREMENT 列可以具有唯一索引或非唯一索引。尝试在任何其它列上创建索引会导致错误。</p></li><li><p>ARCHIVE 表适合日志和数据采集 (归档) 类应用；适合存储大量的独立 的作为历史记录的数据。拥有很高的插入速度，但是对查询的支持较差。</p></li><li><p>ARCHIVE 存储引擎功能</p><table><thead><tr><th>特征</th><th>支持</th></tr></thead><tbody><tr><td>B 树索引</td><td>不支持</td></tr><tr><td>备份&#x2F;时间点恢复 (在服务器中实现，而不是在存储引擎中)</td><td>支持</td></tr><tr><td>集群数据库支持</td><td>不支持</td></tr><tr><td>聚集索引</td><td>不支持</td></tr><tr><td>压缩数据</td><td>支持</td></tr><tr><td>数据缓存</td><td>不支持</td></tr><tr><td>加密数据 (加密功能在服务器中实现)</td><td>支持</td></tr><tr><td>外键支持</td><td>不支持</td></tr><tr><td>全文检索索引</td><td>不支持</td></tr><tr><td>地理空间数据类型支持</td><td>支持</td></tr><tr><td>地理空间索引支持</td><td>不支持</td></tr><tr><td>哈希索引</td><td>不支持</td></tr><tr><td>索引缓存</td><td>不支持</td></tr><tr><td>锁粒度</td><td>行锁</td></tr><tr><td>MVCC</td><td>不支持</td></tr><tr><td>存储限制</td><td>没有任何限制</td></tr><tr><td>交易</td><td>不支持</td></tr><tr><td>更新数据字典的统计信息</td><td>支持</td></tr></tbody></table></li></ul><h4 id="4-4-Blackhole-引擎：丢弃写操作，读操作会返回空内容"><a href="#4-4-Blackhole-引擎：丢弃写操作，读操作会返回空内容" class="headerlink" title="4.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容"></a>4.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容</h4><ul><li>Blackhole 引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。</li><li>但服务器会记录 Blackhole 表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。</li></ul><h4 id="4-5-CSV-引擎：存储数据时，以逗号分隔各个数据项"><a href="#4-5-CSV-引擎：存储数据时，以逗号分隔各个数据项" class="headerlink" title="4.5 CSV 引擎：存储数据时，以逗号分隔各个数据项"></a>4.5 CSV 引擎：存储数据时，以逗号分隔各个数据项</h4><ul><li>CSV 引擎可以将普通的 CSV 文件作为 MySQL 的表来处理，但不支持索引。</li><li>CSV 引擎可以作为一种数据交换的机制，非常有用。</li><li>CSV 存储的数据直接可以在操作系统里，用文本编辑器，或者 excel 读取。</li><li>对于数据的快速导入、导出是有明显优势的。</li></ul><p>创建 CSV 表时，服务器会创建一个纯文本数据文件，其名称以表名开头并带有 .CSV 扩展名。当你将数据存储到表中时，存储引擎将其以逗号分隔值格式保存到数据文件中。</p><h4 id="4-6-Memory-引擎：置于内存的表"><a href="#4-6-Memory-引擎：置于内存的表" class="headerlink" title="4.6 Memory 引擎：置于内存的表"></a>4.6 Memory 引擎：置于内存的表</h4><p>概述：</p><p>Memory 采用的逻辑介质是内存，响应速度很快，但是当 mysqld 守护进程崩溃的时候数据会丢失。另外，要求存储的数据是数据长度不变的格式，比如，Blob 和 Text 类型的数据不可用 (长度不固定的)。</p><p>主要特征：</p><ul><li>Memory 同时支持哈希索引和 B+ 树索引。<ul><li>哈希索引相等的比较快，但是对于范围的比较慢很多。</li><li>默认使用哈希索引，其速度要比使用 B 型树索引快。</li><li>如果希望使用 B 树索引，可以在创建索引时选择使用。</li></ul></li><li>Memory 表至少比 MyISAM 表要快一个数量级。</li><li>Memory 表的大小是受限制的。表的大小主要取决于两个参数，分别是 max_rows 和 max_heap_table_size。其中，max_rows 可以在创建表时指定；max_heap_table_size 的大小默认为 16MB，可以按需要进行扩大。</li><li>数据文件与索引文件分开存储。<ul><li>每个基于 Memory 存储引擎的表实际对应一个磁盘文件，该文件的文件名与表名相同，类型为 frm 类型，该文件中只存储表的结构，而其数据文件都是存储在内存中的。</li><li>这样有利于数据的快速处理，提供整个表的处理效率。</li></ul></li><li>缺点：其数据易丢失，生命周期短。基于这个缺陷，选择 Memory 存储引擎时需要特别小心。</li></ul><p>使用 Memory 存储引擎的场景：</p><ol><li>目标数据比较小，而且非常频繁的进行访问，在内存中存放数据，如果太大的数据会造成内存溢出。可以通过参数 max_heap_table_size 控制 Memory 表的大小，限制 Memory 表的最大的大小。</li><li>如果数据是临时的，而且必须立即可用得到，那么就可以放在内存中。</li><li>存储在 Memory 表中的数据如果突然间丢失的话也没有太大的关系。</li></ol><h4 id="4-7-Federated-引擎：访问远程表"><a href="#4-7-Federated-引擎：访问远程表" class="headerlink" title="4.7 Federated 引擎：访问远程表"></a>4.7 Federated 引擎：访问远程表</h4><ul><li>Federated 引擎是访问其他 MySQL 服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</li></ul><h4 id="4-8-Merge-引擎：管理多个-MyISAM-表构成的表集合"><a href="#4-8-Merge-引擎：管理多个-MyISAM-表构成的表集合" class="headerlink" title="4.8 Merge 引擎：管理多个 MyISAM 表构成的表集合"></a>4.8 Merge 引擎：管理多个 MyISAM 表构成的表集合</h4><h4 id="4-9-NDB-引擎：MySQL-集群专用存储引擎"><a href="#4-9-NDB-引擎：MySQL-集群专用存储引擎" class="headerlink" title="4.9 NDB 引擎：MySQL 集群专用存储引擎"></a>4.9 NDB 引擎：MySQL 集群专用存储引擎</h4><p>也叫作 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。</p><h3 id="5-MyISAM-和-InnoDB"><a href="#5-MyISAM-和-InnoDB" class="headerlink" title="5. MyISAM 和 InnoDB"></a>5. MyISAM 和 InnoDB</h3><blockquote><p>很多人对 InnoDB 和 MyISAM 的取舍存在疑问，到底选择哪个比较好呢？</p></blockquote><p>MySQL 5.5 之前的默认存储引擎是 MyISAM，5.5 之后改为了 InnoDB。</p><p>首先对于 InnoDB 存储引擎，提供了良好的事务管理、崩溃修改能力和并发控制。因为 InnoDB 存储引擎支持事务，所以对于要求事务完整性的场合需要选择 InnoDB，比如数据操作出了插入和查询意外还包含很多更新和删除操作，像财务系统等对数据准确性要求较高的系统。缺点是其读写效率稍差，占用的数据空间相对比较大。</p><p>其次对于 MyISAM 存储引擎，如果是小型应用，系统以读操作和插入操作为主，只有很少的更新、删除操作，并且对事务的要求没有那么高，则可以选择这个存储引擎。MyISAM 存储引擎的优势在于占用空间小，处理速度快；缺点是不支持事务的完整性和并发性。</p><p>这两种存储引擎各有特点，当然也可以在 MySQL 中，针对不同的数据表，可以选择不同的存储引擎。</p><table><thead><tr><th>对比项</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td>行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响。</td></tr><tr><td>自带系统表使用</td><td>Y</td><td>N</td></tr><tr><td>关注点</td><td>性能：节省资源、消耗少、简单业务</td><td>事务：并发写、事务、更大资源</td></tr><tr><td>默认安装</td><td>Y</td><td>Y</td></tr><tr><td>默认使用</td><td>N</td><td>Y</td></tr></tbody></table><h3 id="6-阿里巴巴、淘宝用哪个"><a href="#6-阿里巴巴、淘宝用哪个" class="headerlink" title="6. 阿里巴巴、淘宝用哪个"></a>6. 阿里巴巴、淘宝用哪个</h3><table><thead><tr><th>产品</th><th>价格</th><th>目标</th><th>主要功能</th><th>是否可投入生产？</th></tr></thead><tbody><tr><td>Percona Server</td><td>免费</td><td>提供 XtraDB 存储引擎的包装器和其它分析工具</td><td>XtraDB</td><td>是</td></tr><tr><td>MariaDB</td><td>免费</td><td>扩展 MySQL 以包含 XtraDB 和其他性能改进</td><td>XtraDB</td><td>是</td></tr><tr><td>Drizzle</td><td>免费</td><td>提供比 MySQL 更强大的可扩展性和性能改进</td><td>高可用性</td><td>是</td></tr></tbody></table><ul><li>Percona 为 MySQL 数据库服务器进行了改进，在功能和性能上较 MySQL 有很显著的提升。</li><li>该版本提升了在高负载情况下的 InnoDB 的性能、为 DBA 提供一些非常有用的性能诊断工具；另外有更多的参数和命令来控制服务器行为。</li><li>该公司新建了一款存储引擎较 XtraDB 完全可以替代 InnoDB，并且在性能和并发上做的更好。</li><li>阿里巴巴大部分 MySQL 数据库其实使用的 percona 的原型加以修改。</li></ul><h3 id="7-补充"><a href="#7-补充" class="headerlink" title="7. 补充"></a>7. 补充</h3><h4 id="7-1-InnoDB-表的优势"><a href="#7-1-InnoDB-表的优势" class="headerlink" title="7.1 InnoDB 表的优势"></a>7.1 InnoDB 表的优势</h4><p>InnoDB 存储引擎在实际应用中拥有诸多优势，比如操作便利、提高了数据库的性能、维护成本低等。如果由于硬件或软件的原因导致服务器崩溃，那么在重启服务器之后不需要进行额外的操作。InnoDB 崩溃恢复功能自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。</p><p>InnoDB 存储引擎在主内存中维护缓冲池，高频率使用的数据将在内存中直接被处理。这种缓存方式应用于多种信息，加速了处理进程。</p><p>在专用服务器上，物理內存中高达 80% 的部分被应用于缓冲池。如果需要将数据插入不同的表中，可以设置外键加强数据的完整性。更新或者删除数据，关联数据将会被自动更新或删除。如果试图将数据插入从表，但在主表中没有对应的数据，插入的数据将被自动移除。如果磁盘或內存中的数据出现崩溃，在使用脏数据之前，校验和机制会发出警告。当每个表的主键都设置合理时，与这些列有关的操作会被自动优化。插入、更新和删除操作通过做改变缓冲自动机制进行优。InnoDB 不仅支持当前读写，也会缓冲改变的数据到数据流磁盘。</p><p>InnoDe的性能优势不只存在于长时运行查询的大型表。在同一列多次被查询时，自适应哈希索引会提高查询的速度，使用 InnoDB 可以压缩表和相关的索引，可以在不影响性能和可用性的情况下创建或删除索引，对干大型文本和 BLOB 数据，使用动态行形式，这种存储布局更高效。通过查询 INFORMATION_SCHEMA 库中的表可以监控存储引擎的内部工作。在同一个语句中，InnoDB 表可以与其他存储引擎表混用。即使有些操作系统限制文件大小为 2GB，InnoDB 仍然可以处理。当处理大数据量时，InnoDB 兼顾 CPU，以达到最大性能。</p><h4 id="7-2-InnoDB-和-ACID-模型"><a href="#7-2-InnoDB-和-ACID-模型" class="headerlink" title="7.2 InnoDB 和 ACID 模型"></a>7.2 InnoDB 和 ACID 模型</h4><p>ACID 模型是一系列数据库设计规则，这些规则着重强调可靠性，而可靠性对于商业数据和任务关键型应用非常重要。MySQL 包含类似 InnoDB 存储引擎的组件，与 ACID 模型紧密相连，这样出现意外时，数据不会崩溃，结果不会失真。如果依赖 ACID 模型，可以不使用一致性检查和崩溃恢复机制。如果拥有额外的软件保护，极可靠的硬件或者应用可以容忍一小部分的数据丢失和不一致，可以将 MySQL 设置调整为只依赖部分 ACID 特性，以达到更高的性能。</p><p>InnoDB 存储引擎与 ACID 模型相同作用的四个方面。</p><ol><li><p>原子方面</p><p> ACID 的原子方面主要涉及 InnoDB 事务，与 MySQL 相关的特性主要包括：</p><ul><li>自动提交设置</li><li>COMMIT 语句</li><li>ROLLBACK 语句</li><li>操作 INFORMATION_SCHEMA 库中的表数据。</li></ul></li><li><p>一致性方面</p><p> ACID 模型的一致性主要涉及保护数据不崩溃的内部 InnoDB 处理过程，与 MySQL 相关的特性主要包括：</p><ul><li>InnoDB 双写缓存</li><li>InnoDB 崩溃恢复</li></ul></li><li><p>隔离方面</p><p> 隔离是应用于事务的级别，与 MySQL 相关的特性主要包括：</p><ul><li>自动提交设置</li><li><code>SET ISOLATION LEVEL</code> 语句</li><li>InnoDB 锁的低级别信息</li></ul></li><li><p>耐久性方面</p><p> ACID 模型的耐久性主要涉及与硬件配置相互影响的 MySQL 软件特性。由于硬件复杂多样化，耐久性方面没有具体的规则可循，与 MySQL 相关的特性有：</p><ul><li>InnoDB 双写缓存，通过 innodb_doublewrite 配置项配置</li><li>配置项 innodb_flush_log_at_trx_commit </li><li>配置项 sync_binlog</li><li>配置项 innodb_file_per_table</li><li>存储设备的写入缓存</li><li>存储设备的备用电池缓存</li><li>运行 MySQL 的操作系统</li><li>持续的电力供应</li><li>备份策略</li><li>对分布式或托管的应用，最主要的在于硬件设备的地点以及网络情况</li></ul></li></ol><h4 id="7-3-InnoDB-架构"><a href="#7-3-InnoDB-架构" class="headerlink" title="7.3 InnoDB 架构"></a>7.3 InnoDB 架构</h4><ul><li><p>缓冲池</p><p>  缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的数据能够直接在内存中获得，从而提高速度。</p></li><li><p>更改缓存</p><p>  更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索引页的更改。索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁盘。更新缓存合并期间，可能会大大降低查询的性能。在内存中，更新缓存占用一部分 InnoDB 缓冲池。在磁盘中，更新缓存是系统表空间的一部分。更新缓存的数据类型由 innodb_change_buffering 配置项管理。</p></li><li><p>自适应哈希索引</p><p>  自适应哈希索引将负载和足够的内存结合起来，使得 InnoDB 像内存数据库一样运行，不需要降低事务上的性能或可靠性。这个特性通过 innodb_adaptive_hash_index 选项配置，或者通过 –skip-innodb_adaptive_hash_index 命令行在服务启动时关闭。</p></li><li><p>重做日志缓存</p><p>  重做日志缓存存放要放入重做日志的数据。重做日志缓存大小通过 innodb_log_buffer_size 配置项配置。重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存是的大型事务能够正常运行而不需要写入磁盘。</p></li><li><p>系统表空间</p><p>  系统表空间包括 InnoDB 数据字典、双写缓存、更新缓存和撤销日志，同时也包括表和索引数据。多表共享，系统表空间被视为共享表空间。</p></li><li><p>双写缓存</p><p>  双写缓存位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存后，InnoDB 才会将数据页写入合适的位置。</p></li><li><p>撤销日志</p><p>  撤销日志是一系列与事务相关的插销记录的集合，包含如何撤销事务最近的更改。如果其它事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。插销日志存在于撤销日志片段中，这些片段包含于回滚片段中。</p></li><li><p>每个表一个文件的表空间</p><p>  每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中，而不是系统表空间中。这个功能通过 innodb_file_per_table 配置项开启。每个表空间由一个单独的 .ibd 数据文件代表，该文件默认被创建在数据库目录中。</p></li><li><p>通用表空间</p><p>  使用 CREATE TABLESPACE 语法创建共享的 InnoDB 表空间。通过表空间可以创建在 MySQL 数据目录之外能够管理多个表并支持所有行格式的表。</p></li><li><p>撤销表空间</p><p>  撤销表空间由一个或多个包含撤销日志的文件组成。撤销表空间的数量由 innodb_undo_tablespaces 配置项配置。</p></li><li><p>临时表空间</p><p>  用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。innodb_temp_data_file_path 配置项定义了相关的路径、名称、大小和属性。如果该值为空，默认会在 innodb_data_home_dir 变量指定的目录下创建一个自动扩展的数据文件。</p></li><li><p>重做日志</p><p>  重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据。正常操作期间，重做日志会将请求数据进行编码，这些请求会改变 InnoDB 表数据。遇到意外崩溃后，未完成的更改会自动在初始化期间重新进行。</p></li></ul><h2 id="四、索引的数据结构"><a href="#四、索引的数据结构" class="headerlink" title="四、索引的数据结构"></a>四、索引的数据结构</h2><h3 id="1-为什么使用索引"><a href="#1-为什么使用索引" class="headerlink" title="1. 为什么使用索引"></a>1. 为什么使用索引</h3><p>索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL 中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。</p><p><img src="http://1.117.162.142:9000/blog/%E7%B4%A2%E5%BC%95-1.png" alt="索引-1"></p><p>如上图所示，数据库没有索引的情况下，数据分布在硬盘的不同的位置上面，读取数据时，摆臂需要前后摆动查找数据，这样操作非常消耗时间。如果数据顺序摆放，那么也需要从 1 到 6 行按顺序读取，这样就相当于进行了 6 次 IO 操作，依旧非常耗时。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找 Col2 &#x3D; 89 这条记录，就要逐行去查找、去比较。从 Col2 &#x3D; 34 开始，进行比较，发现不是，继续下一行。我们当前的表只有不到 10 行数据，但如果表很大的话，有上千万条数据，就意味着要做很多很多次磁盘 I&#x2F;O 才能找到。现在要查找 Col2 &#x3D; 89 这条记录。CPU 必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最消耗时间的就是磁盘 I&#x2F;O (涉及到磁盘的旋转时间 (速度较快)、磁头的寻道时间 (速度慢、耗时))。</p><p>假如给数据使用二叉树这样的数据结构进行存储，如下图所示。</p><p><img src="http://1.117.162.142:9000/blog/%E7%B4%A2%E5%BC%95-2.png" alt="索引-2"></p><p>对字段 Col2 添加了索引，就相当于在硬盘上为 Col2 维护了一个索引的数据结构，即这个二叉搜索树。二叉搜索树的每个结点存储的是 (K, V) 结构，key 是 Col2，value 是该 key 所在行的文件指针 (地址) 。比如：该二叉搜索树的根结点就是：(34，0x07)。现在对 Col2 添加了索引，这时再去查找 Col2 &#x3D; 89 这条记录的时候会先去查找该二叉搜索树 (二叉树的遍历查找)。读 34 到内存，89 &gt; 34；继续右侧数据，读 89 到内存，89 &#x3D;&#x3D; 89；找到数据返回。找到之后就根据当前结点的 value 快速定位到要查找的记录对应的地址。我们可以发现，只需要查找两次就可以定位到记录的地址，查询速度就提高了。</p><p>这就是我们为什么要建索引，目的就是为了<strong>减少磁盘 I&#x2F;O 的次数</strong>，加快查询速率。</p><h3 id="2-索引及其优缺点"><a href="#2-索引及其优缺点" class="headerlink" title="2. 索引及其优缺点"></a>2. 索引及其优缺点</h3><h4 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h4><p>MySQL 官方对索引的定义为：<strong>索引 (index) 是帮助 MySQL 高效获取数据的数据结构</strong>。</p><p>索引的本质：索引是数据结构。可以简单理解为排好序的快速查找数据结构，满足特定查找算法。这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法。</p><p>索引是在存储引擎中实现的，因此没中存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的最大索引数和最大索引长度。所有存储引擎支持每个表至少 16 个索引，总索引长度至少为 256 字节。有些存储引擎支持更多的索引数和更大的索引长度。</p><h4 id="2-2-优点"><a href="#2-2-优点" class="headerlink" title="2.2 优点"></a>2.2 优点</h4><ol><li>类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的 IO 成本，这也是创建索引最主要的原因。</li><li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。</li><li>在实现数据的参考完整性方面，可以加速表和表之间的连接。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。</li><li>在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间，降低了 CPU 的消耗。</li></ol><h4 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h4><p>增加索引也有许多不利的方面，主要表现在如下几个方面：</p><ol><li>创建索引和维护索引要消耗时间，并且随着数据量的增加，所耗费的时间也会增加。</li><li>索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</li></ol><p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p><blockquote><p>提示：</p><p>索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p></blockquote><h3 id="3-InnoDB-中索引的推演"><a href="#3-InnoDB-中索引的推演" class="headerlink" title="3. InnoDB 中索引的推演"></a>3. InnoDB 中索引的推演</h3><h4 id="3-1-索引之前的查找"><a href="#3-1-索引之前的查找" class="headerlink" title="3.1 索引之前的查找"></a>3.1 索引之前的查找</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [列名列表] <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="operator">=</span> xxx;</span><br></pre></td></tr></table></figure><ul><li><p>在一个页中查找</p><p>  假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p><ul><li>以主键为搜索条件。可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li><li>以其他列作为搜索条件。因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从最小记录开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然这种查找的效率是非常低的。</li></ul></li><li><p>在很多页中查找</p><p>  大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：</p><ul><li>定位到记录所在的页。</li><li>从所在的页内中查找相应的记录。</li></ul><p>  在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是超级耗时的。如果一个表有一亿条记录呢？此时索引应运而生。</p></li></ul><h4 id="3-2-设计索引"><a href="#3-2-设计索引" class="headerlink" title="3.2 设计索引"></a>3.2 设计索引</h4><p>建一个表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line">c1 <span class="type">INT</span>,</span><br><span class="line">  c2 <span class="type">INT</span>,</span><br><span class="line">  c3 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(c1)</span><br><span class="line">) ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure><p>这个新建的 index_demo 表中有两个 INT 类型的列，一个 CHAR(1) 类型的列，而且规定了 c1 列为主键，这个表使用 Compact 行格式来实际存储记录的。这里简化了index_demo 表的行格式示意图：</p><p><img src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-1.png" alt="简化行格式示意图"></p><p>只在示意图里展示记录的这几个部分：</p><ul><li>record_type：记录头信息的一项属性，表示记录的类型，0 表示普通记录，2 表示最小记录，3 表示最大记录，1 后文再描述。</li><li>next_record：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，用箭头来表明下一条记录是谁。</li><li>各个列的值：这里指记录在 index_demo 表中的三个列，分别是 c1、c2、c3。</li><li>其他信息：除了上述三种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：</p><p><img src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-2.png" alt="简化行格式示意图"></p><p>把一些记录放到页里的示意图就是：</p><p><img src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-3.png" alt="简化行格式示意图"></p><p><strong>一个简单的索引设计方案：</strong></p><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？ 我们可以为快速定位记录所在的数据页而建立一个目录，建这个目录必须完成下边这些事：</p><ul><li><p>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</p><p>  假设：每个数据页最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。有了这个假设之后我们向 index_demo 表插入 3 条记录：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> index_demo <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="string">&#x27;u&#x27;</span>), (<span class="number">3</span>, <span class="number">9</span>, <span class="string">&#x27;d&#x27;</span>), (<span class="number">5</span>, <span class="number">3</span>, <span class="string">&#x27;y&#x27;</span>);</span><br></pre></td></tr></table></figure><p>  那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：</p><p>  <img src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-4.png" alt="简化行格式示意图"></p><p>  从图中可以看出来，index_demo 表中的 3 条记录都被插入到了编号为 10 的数据页中。此时我们再来插一条记录：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> index_demo <span class="keyword">VALUES</span>(<span class="number">4</span>, <span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>  因为页 10 最多只能放 3 条记录，所以我们不得不再分配一个新页：</p><p>  <img src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-5.png" alt="简化行格式示意图"></p><p>  注意，新分配的数据页编号可能并不是连续的。它们只是通过维护着上个页和下一个页的编号而建立了链表关系。另外，页 10 中用户记录最大的主键值是 5，而页 28 中有一条记录的主键值是 4，因为 5 ＞ 4，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为 4 的记录的时候需要伴随着一次记录移动，也就是把主键值为 5 的记录移动到页 28 中，然后再把主键值为 4 的记录插入到页 10 中，这个过程的示意图如下：</p><p>  <img src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-6.png" alt="简化行格式示意图"></p><p>  <img src="/../.vuepress/public/mysql/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-7.png" alt="简化行格式示意图"></p><p>  这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：下一个数据页的用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程称为<strong>页分裂</strong>。</p></li><li><p>给所有的页建立一个目录项。</p><p>  由于数据页的编号可能是不连续的，所以在向 index_demo 表中插入许多条记录后，可能是这样的效果：</p><p>  <img src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-8.png" alt="简化行格式示意图"></p><p>  因为这些 16KB 的页在物理存储上是不连续的，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给他们做个目录，每个页对应一个目录项，每个目录项包括下边两部分：</p><ul><li>页的用户记录中最小的主键值，用 key 表示。</li><li>页号，用 page_no 表示。</li></ul><p>  <img src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-9.png" alt="简化行格式示意图"></p><p>  以页 28 为例，它对应目录项 2，这个目录项中国呢包含着该页的页号 28 以及该页中用户记录的最小主键值 5。只需要把几个目录项在物理存储器上连续存储 (比如：数组)，就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：</p><ul><li>先从目录项中根据二分法快速确定出主键值为 20 的记录在目录项 3 中 (因为 12 &lt; 20 &lt; 209)，它对应的页是页 9。</li><li>再根据在页中查找记录的方式去页 9 中定位具体的记录。</li></ul></li></ul><p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为索引。</p><p><strong>InnoDB 中的索引方案</strong></p><ul><li><p>迭代 1 次：目录项记录的页</p><p>  上边称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用二分法快速定位具体的目录项而假设所有目录项都可以在物理存储器上连续存储，但是这样做有几个问题：</p><ul><li>InnoDB 是使用页来作为管理存储空间的基本单位，最多能保证 16KB 的连续存储空间，而随着表中记录数量的增多，需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</li><li>我们时常会对记录进行增删，假设我们把页 28 中的记录都删除了，那意味着目录项 2 也就没有存在的必要了，这就需要吧目录项 2 后的目录项都向前移动一下，这样牵一发而动全身的操作效率很差。</li></ul><p>  所以，我们需要一种可以灵活管理所有目录项的方式。我们发现目录项其实长得跟我们的用户记录差不多，只不过目录项中的两个列是主键和页号而已，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录。那 InnoDB 怎么区分一条记录是普通的用户记录还是目录项记录呢？使用记录头信息里的 record_type 属性，它的各个取值代表的意思如下：</p><ul><li>0：普通的用户记录</li><li>1：目录项记录</li><li>2：最小记录</li><li>3：最大记录</li></ul><p>  我们把前边使用到的目录项放到数据页中的样子就是这样：</p><p>  <img src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-10.png" alt="简化行格式示意图"></p><p>  从图中可以看出来，我们新分配了一个编号为 30 的页来专门存储目录项记录。这里再次强调目录项记录和普通用户记录的不同点：</p><ul><li>目录项记录的 record_type 值是 1，而普通用户记录的 record_type 值是 0。</li><li>目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有 InnoDB 自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫 min_rec_mask 的属性，只有在存储目录项记录的页中的主键值最小的目录项记录的 min_rec_mask 值为 1，其它别的记录的 min_rec_mask 值都是 0。</li></ul><p>  <strong>相同点</strong>：两者用的是一样的数据页，都会为主键值生成 Page Directory (页目录)，从而在按照主键值进行查找时可以使用二分法来加快查询速度。</p><p>  现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p><ul><li>先到存储目录项记录的页，也就是页 30 中通过二分法快速定位到对应目录项，因为 12 &lt; 20 &lt; 209，所以定位到对应的记录所在的页就是页 9。</li><li>再到存储用户记录的页 9 中根据二分法快速定位到主键值为 20 的用户记录。</li></ul></li><li><p>迭代 2 次：多个目录项记录的页</p><p>  虽然说目录项记录中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有 16KB 大小，能存放的目录项记录也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的目录项记录，如何处理呢？</p><p>  这里假设一个存储目录项记录的页最多只能存放 4 条目录项记录，所以如果此时再向上图中插入一条主键值为 320 的用户记录的话，那就需要分配一个新的存储目录项记录的页：</p><p>  <img src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-11.png" alt="简化行格式示意图"></p><p>  从图中可以看出，插入了一条主键值为 320 的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了页 31。</li><li>因为原先存储目录项记录的页 30 的容量已满 (假设只能存储 4 条目录项记录)，所以不得不需要一个新的页 32 来存放页 31 对应的目录项。</li></ul><p>  现在因为存储目录项记录的页不止一个，所以如果想根据主键值查找一条用户记录大致需要 3 个步骤，以查找主键值为 20 的记录为例：</p><ul><li>确定目录项记录页。现在的存储目录项记录的页有两个，即页 30 和 页 32，又因为页 30 表示的目录项的主键值的范围是 [1, 320)，页 32 表示的目录项的主键值不小于 320，所以主键值为 20 的记录对应的目录项记录在页 30 中。</li><li>通过目录项记录页确定用户记录真实所在的页。在一个存储目录项记录的页中通过主键值定位一条目录项记录的方式说过了。</li><li>在真实存储用户记录的页中定位到具体的记录。</li></ul></li><li><p>迭代 3 次：目录项记录页的目录页</p><p>  问题来了，在这个查询步骤的第一步中我们需要定位存储目录项记录的页，但是这些页是不连续的，如果我们表中的数据非常多则会产生很多存储目录项记录的页，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p><p>  <img src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-12.png" alt="简化行格式示意图"></p><p>  如图，我们生成了一个存储更高级目录项的页 33，这个页中的两条记录分别代表页 30 和页 32，如果用户记录的主键值在 [1, 320) 之间，则到页 30 中查找更详细的目录项记录，如果主键值不小于 320 的话，就到页 32 中查找更详细的目录项记录。</p><p>  随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用瞎编的这个图来描述它：</p><p>  <img src="http://1.117.162.142:9000/blog/B+%E6%A0%91-1.png" alt="B+树-1"></p><p>  这个数据结构，它的名称是 B+ 树。</p></li><li><p>B+ Tree</p><p>  不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到 B+ 树这个数据结构中了，所以我们也称这些数据页为节点。从图中可以看出，我们的实际用户记录其实都存放在 B+ 树的最底层的节点上，这些节点也被称为叶子结点，其余用来存放目录项的节点称为非叶子节点或者内节点，其中 B+ 树最上边的那个节点也称为根结点。</p><p>  一个 B+ 树的结点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层，之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页最多存放 3 条记录，存放目录项记录的页最多存放 4 条记录。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录的叶子节点代表的数据页可以存放 100 条用户记录，所有存放目录项记录的内节点代表的数据页可以存放 1000 条目录项记录，那么：</p><ul><li>如果 B+ 树只有一层，也就是只有一个用于存放用户记录的节点，最多能存放 100 条记录。</li><li>如果 B+ 树有两层，最多能存放 1000 * 100 &#x3D; 100 000 条记录。</li><li>如果 B+ 树有三层，最多能存放 1000 * 1000 * 100 &#x3D; 100 000 000 条记录。</li><li>如果 B+ 树有四层，最多能存放 1000 * 1000 * 1000 * 100 &#x3D; 100 000 000 000 条记录。</li></ul><p>  你的表里能存放 100000000000 条记录吗？所以<strong>一般情况下，我们用到的 B+ 树都不会超过 4 层</strong>，那我们通过主键值去查找某条记录最多只需要做 4 个页面内的查找 (查找 3 个目录项页和一个用户记录页)，又因为在每个页面内有所谓的 Page Directory (页目录)，所以在页面内也可以通过二分法实现快速定位记录。</p></li></ul><h4 id="3-3-常见索引概念"><a href="#3-3-常见索引概念" class="headerlink" title="3.3 常见索引概念"></a>3.3 常见索引概念</h4><p>索引按照物理实现方式，索引可以分为 2 种：聚簇索引和非聚簇索引。我们也把非聚簇索引称为二级索引或者辅助索引。</p><ul><li><p><strong>聚簇索引</strong></p><p>  聚簇索引并不是一种单独的索引类型，而是一种数据存储方式 (所有的用户记录都存储在了叶子节点)，也就是所谓的<strong>索引即数据，数据即索引</strong>。</p><blockquote><p>术语“聚簇”表示数据行和相邻的键值聚簇的存储在一起。</p></blockquote><p>  特点：</p><ul><li>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：<ul><li>页内的记录是按照主键的大小顺序排成一个单向链表。</li><li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li></ul></li><li>B+ 树的叶子节点存储的是完整的用户记录。所谓完整的用户记录，就是指这个记录中存储了所有列的值 (包括隐藏列)。</li></ul><p>  我们把具有这两种特性的 B+ 树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子结点处。这种聚簇索引并不需要我们在 MySQL 语句中显式的使用 INDEX 语句去创建，InnoDB 存储引擎会自动的为我们创建聚簇索引。</p><p>  优点：</p><ul><li>数据访问更快，因为聚簇索引将索引和数据保存在同一个 B+ 树中，因此从聚簇索引中获取数据比非聚簇索引更快。</li><li>聚簇索引对于主键的排序查找和范围查找速度非常快。</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的 I&#x2F;O 操作。</li></ul><p>  缺点：</p><ul><li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主键。</li><li>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义主键为不可更新。</li><li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</li></ul><p>  限制：</p><ul><li>对于 MySQL 数据库目前只有 InnoDB 数据引擎支持聚簇索引，而 MyISAM 并不支持聚簇索引。</li><li>由于数据物理存储排序方式只能有一种，所以每个 MySQL 的表只能有一个聚簇索引。一般情况下就是该表的主键。</li><li>如果没有定义主键，InnoDB 会选择非空的唯一索引代替。如果没有这样的索引，InnoDB 会隐式的定义一个主键来作为聚簇索引。</li><li>为了充分利用聚簇索引的聚簇的特性，所以 InnoDB 表的主键列尽量选用有序的顺序 ID，而不建议用无需的id，比如 UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。</li></ul></li><li><p><strong>二级索引 (辅助索引、非聚簇索引)</strong></p><p>  上边介绍的聚簇索引只能在搜索条件是主键值时才能发挥作用，因为 B+ 树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办呢？肯定不能是从头到位沿着链表依次遍历记录一遍。</p><p>  答案：我们可以多建几棵 B+ 树，不同的 B+ 树中的数据采用不同的排序规则。比方说我们用 c2 列的大小作为数据页、页中巨鹿的排序规则，再建一棵 B+ 树，效果如下图所示：</p><p>  <img src="http://1.117.162.142:9000/blog/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.png" alt="二级索引"></p><p>  这个 B+ 树与上边介绍的聚簇索引有几处不同：</p><ul><li>使用记录 c2 列的大小进行记录和页的排序，这包括三方面的含义：<ul><li>页内的记录是按照 c2 列的大小顺序排成一个单向链表。</li><li>各个存放用户记录的页也是根据页中记录的 c2 列大小顺序排成一个双向链表。</li><li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的 c2 列大小顺序排成一个双向链表。</li></ul></li><li>B+ 树的叶子节点存储的并不是完整的用户记录，而只是 c2 列 + 主键这两个列的值。</li><li>目录项记录中不再是主键 + 页号的搭配，而变成了 c2 列 + 页号的搭配。</li></ul><p>  所以如果我们想再想通过 c2 列的值查找某些记录的话就可以使用我们刚刚建好的这个 B+ 树了。以查找 c2 列的值为 4 的记录为例，查找过程如下：</p><ul><li>确定目录项记录页。根据跟页面，也就是页 44，可以快速定位到目录项记录所在的页为页 42 (因为 2 &lt; 4 &lt; 9)。</li><li>通过目录项记录页确定用户记录真实所在的页。在页 42 中可以快速定位到实际存储用户记录的页，但是由于 c2 列并没有唯一性约束，所以 c2 列值为 4 的记录可能分布在多个数据页中，又因为 2 &lt; 4 ≤ 4，所以确定实际存储用户记录的页在页 34 和页 35 中。</li><li>在真实存储用户记录的页中定位到具体的记录。到页 34 和页 35 中定位到具体的记录。</li><li>但是这个 B+树的叶子节点中的记录只存储了 c2 和 c1 (也就是主键) 两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</li></ul><p>  <strong>概念：回表</strong></p><p>  我们根据这个以 c2 列大小排序的 B+ 树只能确定我们要查找记录的主键值，所以如果我们想根据 c2 列的值查找到完整的用户记录的话，仍然需要到聚簇索引中再查找一遍，这个过程称为回表。也就是根据 c2 列的值查询一条完整的用户记录需要使用到两棵 B+ 树。</p><p>  <strong>问题</strong>：为什么我们还需要一次回表操作呢？直接把完整的用户记录放到叶子节点不行吗？</p><p>  <strong>回答</strong>：如果把完整的用户记录放到叶子节点是不用回表。但是 太占地方了，相当于每建立一棵 B+ 树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。</p><p>  因为这种按照非主键列建立的 B+ 树需要一次回表操作才可以定位到完整的用户记录，所以这种 B+ 树也被称为二级索引 (英文名 secondary index)，或者辅助索引。由于我们使用的是 c2 列的大小作为 B+ 树的排序规则，所以我们也称这个 B+ 树是为 c2 列建立的索引。</p><p>  非聚簇索引的存在不影响数据在聚簇索引中的组织，索引一张表可以有多个非聚簇索引。</p><p>  <img src="http://1.117.162.142:9000/blog/%E5%A4%9A%E4%B8%AA%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt="多个非聚簇索引"></p><p>  <strong>小结</strong>：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：</p><ul><li>聚簇索引的叶子节点存储的就是我们的数据记录，非聚簇索引的叶子节点存储的是数据位置。非聚簇索引不会影响数据表的物理存储顺序。</li><li>一个表只能有一个聚簇索引，因为只能有一种排序存储的方式，但可以有多个非聚簇索引，也就是多个索引目录提供数据检索。</li><li>使用聚簇索引的时候，数据的查询效率高，但如果对数据进行插入、删除、更新等操作，效率会比非聚簇索引低。</li></ul></li><li><p><strong>联合索引</strong></p><p>  我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让 B+ 树按照 c2 和 c3 列的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照 c2 列进行排序。</li><li>在记录的 c2 列相同的情况下，采用 c3 列进行排序。</li></ul><p>  为 c2 和 c3 列建立的索引的示意图如下：</p><p>  <img src="http://1.117.162.142:9000/blog/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.png" alt="联合索引"></p><p>  如图所示，我们需要注意以下几点：</p><ul><li>每条目录项记录都由 c2、c3、页号这三个部分组成，各条记录先按照 c2 列的值进行排序，如果记录的 c2 列相同，则按照 c3 列的值进行排序。</li><li>B+ 树叶子节点处的用户记录由 c2、c3 和主键 c1 列组成。</li></ul><p>  注意一点，以 c2 和 c3 列的大小为排序规则建立的 B+ 树称为联合索引，本质上也是一个二级索引。它的意思与分别为 c2 和 c3 列分别建立索引的表述是不同的，不同点如下：</p><ul><li>建立联合索引只会建立如上图一样的一棵 B+ 树。</li><li>为 c2 和 c3 列分别建立索引会分别以 c2 和 c3 列的大小为排序规则建立两棵 B+ 树。</li></ul></li></ul><h4 id="3-4-InnoDB-的-B-树索引的注意事项"><a href="#3-4-InnoDB-的-B-树索引的注意事项" class="headerlink" title="3.4 InnoDB 的 B+ 树索引的注意事项"></a>3.4 InnoDB 的 B+ 树索引的注意事项</h4><p><strong>根页面位置万年不动</strong></p><p>前面介绍 B+ 树索引的时候，为了理解方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上 B+ 树的形成过程是这样的：</p><ul><li>每当为某个表创建一个 B+ 树索引 (聚簇索引不是人为创建的，默认就有) 的时候，都会为这个索引创建一个根结点页面。最开始表中没有数据的时候，每个 B+ 树索引对应的根结点中既没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个根结点中。</li><li>当根结点中的可用空间用完时继续插入记录，此时会将根结点中的所有记录复制到一个新分配的页，比如页 a 中，然后对这个新页进行页分裂的从左，得到另一个新页，比如页 b。这时新插入的记录根据键值 (也就是聚簇索引中的主键值，二级索引中对应的索引列的值) 的大小就会被分配到页 a 或者页 b 中，而根结点便升级为存储目录项记录的页。</li></ul><p>这个过程特别注意的是：一个 B+ 树索引的根结点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根结点的页号便会被记录到某个地方，然后凡是 InnoDB 存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根结点的页号，从而来访问这个索引。</p><p><strong>内节点中目录项记录的唯一性</strong></p><p>我们知道 B+ 树索引的内节点中目录项记录的内容是索引列 + 页号的搭配，但是这个搭配对于耳机索引来说有点不严谨。以 index_demo 为例，假设这个表中的数据是这样的：</p><table><thead><tr><th>c1</th><th>c2</th><th>c3</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>‘u’</td></tr><tr><td>3</td><td>1</td><td>‘d’</td></tr><tr><td>5</td><td>1</td><td>‘y’</td></tr><tr><td>7</td><td>1</td><td>‘a’</td></tr></tbody></table><p>如果二级索引中目录项记录的内容只是索引列 + 页号的搭配的话，那么为 c2 列建立索引后的 B+ 树应该长这样：</p><p><img src="http://1.117.162.142:9000/blog/index_demoB+%E6%A0%91.png" alt="index_demoB+树"></p><p>如果我们相信插入一行记录，其中 c1、c2、c3 的值分别是：9、1、’c’，那么在修改这个 c2 列建立的二级索引对应的 B+ 树时碰到了个大问题：由于页 3 中存储的目录项记录是由 c2 列 + 页号的值构建成的，页 3 中的两条目录项记录对应的 c2 列的值都是 1，而我们新插入的这条记录的 c2 列的值也是 1，那我们这条新插入的记录到底应该放到页 4 中，还是应该放到页 5 中啊？</p><p>为了让新插入记录能找到自己在哪个页里，我们需要保证在 B+ 树的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于耳机索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>也就是把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证 B+ 树每一层中各条目录项记录除页号这个字段外是唯一的，所以我们为 c2 列建立二级索引后的示意图实际上应该是这样子的：</p><p><img src="http://1.117.162.142:9000/blog/index_demoB+%E6%A0%912.png" alt="index_demoB+树"></p><p>这样我们再插入记录 (9, 1, ‘c’) 时，由于页 3 中存储的目录项记录是由 c2 列 + 主键 + 页号的值构成的，可以先把新纪录的 c2 列的值和页 3中各目录项记录的 c2 列的值做比较，如果 c2 列的值相同的话，可以接着比较主键值，因为 B+ 树同一层中不同目录项记录的 c2 列 + 主键值 的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新纪录应该被插入到页 5 中。</p><p><strong>一个页面最少存储两条记录</strong></p><p>一个 B+ 树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为 B+ 树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉很多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是啥效果呢？那就是目录层级非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半条劲只能存放一条真实的用户记录？所以 InnoDB 的一个数据页至少可以存放两条记录。</p><h3 id="4-MyISAM-中的索引方案"><a href="#4-MyISAM-中的索引方案" class="headerlink" title="4. MyISAM 中的索引方案"></a>4. MyISAM 中的索引方案</h3><p>B 树索引适用存储引擎如表所示：</p><table><thead><tr><th>索引 &#x2F; 存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>B-Tree 索引</td><td>支持</td><td>支持</td><td>支持</td></tr></tbody></table><p>即使多个存储引擎支持同一种类型的索引，但是她们的实现原理也是不同的。InnoDB 和 MyISAM 默认的索引是 BTree 索引；而 Memory 默认的索引是 Hash 索引。</p><p>MyISAM 引擎使用 B+ 树作为索引结构，叶子节点的 data 域存放的是数据记录的地址。</p><h4 id="4-1-MyISAM-索引的原理"><a href="#4-1-MyISAM-索引的原理" class="headerlink" title="4.1 MyISAM 索引的原理"></a>4.1 MyISAM 索引的原理</h4><p>InnoDB 中索引即数据，也就是聚簇索引的那棵 B+ 树的叶子节点中已经把所有完整的用户记录都包含了，而 MyISAM 的索引方案虽然也适用树形结构，但是却将索引和数据分开存储：</p><ul><li>将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为数据文件。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。</li><li>使用 MyISAM 存储引擎的表会把索引信息另外存储到一个称为索引文件的另一个文件中。MyISAM 会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是主键值 + 数据记录地址的组合。</li></ul><p><img src="http://1.117.162.142:9000/blog/MyISAM%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84-1.png" alt="MyISAM索引结构-1"></p><p>这里设表一共有三列，假设我们以 col1 为主键，上图是一个 MyISAM 表的主索引 (Primary key) 示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。在 MyISAM 中，主键索引和二级索引 (Secondary key) 在结构上没有任何区别，只是主键索引要求 key 是唯一的，而二级索引的 key 可以重复。如果我们在 col2 上建立一个二级索引，则此索引的结构如下图所示：</p><p><img src="http://1.117.162.142:9000/blog/MyISAM%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84-2.png" alt="MyISAM索引结构-2"></p><p>同样也是一棵 B+ 树，data 域保存数据记录的地址。因为，MyISAM 中索引检索的算法为：首先按照 B+ 树搜索算法搜索索引，如果指定的 key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。</p><h4 id="4-2-MyISAM-与-InnoDB-对比"><a href="#4-2-MyISAM-与-InnoDB-对比" class="headerlink" title="4.2 MyISAM 与 InnoDB 对比"></a>4.2 MyISAM 与 InnoDB 对比</h4><p>MyISAM 的索引方式都是非聚簇的，与 InnoDB 包含 1 个聚簇索引是不同的。小结两种引擎索引的区别：</p><ul><li>在 InnoDB 存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次回表操作，意味着 MyISAM 中建立的索引相当于全部都是二级索引。</li><li>InnoDB 的数据文件本身就是索引文件，而 MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</li><li>InnoDB 的非聚簇索引 data 域存储相应记录主键的值，而 MyISAM 索引记录的是地址。换句话说，InnoDB 的所有非聚簇索引都引用主键作为 data 域。</li><li>MyISAM 的回表操作是十分快速的，因为是拿地址偏移量直接到文件中取数据的，反观 InnoDB 是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</li><li>InnoDB 要求表必须有主键 (MyISAM 可以没有)。如果没有显示指定，则 MySQL 系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整型。</li></ul><p><strong>小结</strong>：</p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助。比如：</p><ul><li>知道了 InnoDB 的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。</li><li>用非单调的字段作为主键在 InnoDB 中不是好主意，因为 InnoDB 数据文件本身是一棵 B+ 树，非单调的主键会造成在插入新纪录时，数据文件为了维持 B+ 树的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</li></ul><h3 id="5-索引的代价"><a href="#5-索引的代价" class="headerlink" title="5. 索引的代价"></a>5. 索引的代价</h3><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p><ul><li><p>空间上的代价</p><p>  每建立一个索引都要为它建立一棵 B+ 树，每一棵 B+ 树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的 B+ 树由许多数据页组成，那就是很大的一片存储空间。</p></li><li><p>时间上的代价</p><p>  每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+ 树索引。而且 B+ 树每层节点都是按照索引列的值从小到大的顺序排列而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录 (也就是不论是用户记录还是目录项记录) 都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收等操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的 B+ 树都要进行相关的维护操作，会给性能拖后腿。</p></li></ul><blockquote><p>一个表上索引建得越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们得学学这些索引在哪些条件下起作用的。</p></blockquote><h3 id="6-MySQL-数据结构选择的合理性"><a href="#6-MySQL-数据结构选择的合理性" class="headerlink" title="6. MySQL 数据结构选择的合理性"></a>6. MySQL 数据结构选择的合理性</h3><p>从 MySQL 的角度讲，不得不考虑一个现实问题就是磁盘 IO。如果我们能让索引的数据结构尽量减少硬盘的 I&#x2F;O 操作，所消耗的时间也越小。可以说，磁盘的 I&#x2F;O 操作次数对索引的使用效率至关重要。</p><p>查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个 G 甚至更多，为了减少索引在内存的占用，数据库索引是存储在外部磁盘上的。当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载，那么 MySQL 衡量查询效率的标准就是磁盘 IO 次数。</p><h4 id="6-1-全表遍历"><a href="#6-1-全表遍历" class="headerlink" title="6.1 全表遍历"></a>6.1 全表遍历</h4><p>略</p><h4 id="6-2-Hash-结构"><a href="#6-2-Hash-结构" class="headerlink" title="6.2 Hash 结构"></a>6.2 Hash 结构</h4><p>Hash 本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。</p><p>Hash 算法是通过某种确定性的算法 (比如 MD5、SHA1、SHA2、SHA3) 将输入转变为输出。相同的输入永远可以得到相同的输出，假设输入内容有微小偏差，在输出中通常会有不同的结果。</p><p>举例：如果你想要验证两个文件是否相同，那么你不需要把两份文件直接拿来比对，只需要让对方把 Hash 函数计算得到的结果告诉你即可，然后在本地同样对文件进行 Hash 函数的运算，最后通过比较这两个 Hash 函数的结果是否相同，就可以知道这两个文件是否相同。</p><p><strong>加速查找速度的数据结构，常见的有两类</strong>：</p><ul><li>树，例如平衡二叉搜索树，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是 O(log<sub>2</sub>N)。</li><li>哈希，例如 HashMap，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是 O(1)。</li></ul><p><img src="http://1.117.162.142:9000/blog/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%951.png" alt="哈希算法"></p><p>采用 Hash 进行检索效率非常高，基本上一次检索就可以找到数据，而 B+ 树需要自顶向下依次查找，多次访问节点才能找到数据，中间需要多次 I&#x2F;O 操作，从效率来说 Hash 比 B+ 树更快。</p><p>在哈希的方式下，一个元素 k 处于 h(k) 中，即利用哈希函数 h，根据关键字 k 计算出槽的位置。函数 h 将关键字域映射到哈希表 T[0 ··· m - 1] 的槽位上。</p><p><img src="http://1.117.162.142:9000/blog/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%952.png" alt="哈希算法2"></p><p>上图中哈希函数 h 有可能将两个不同的关键字映射到相同的位置，这叫做碰撞，在数据库中一般采用链接法来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：</p><p><img src="http://1.117.162.142:9000/blog/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%953.png" alt="哈希算法3"></p><p>实验：体会数组和 hash 表的查找方面的效率区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法复杂度为 O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">in</span>[<span class="number">100000</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100000</span>; j++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(temp == arr[i]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  System.out.println(<span class="string">&quot;time: &quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法复杂度为 O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">  HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">100000</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    set.add(i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> j;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> set.contains(temp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  System.out.println(<span class="string">&quot;time: &quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Hash 结构效率高，那为什么索引结构要设计成树型呢</strong>？</p><ul><li>Hash 索引仅能满足 &#x3D; 、&lt;&gt; 和 IN 查询。如果进行范围查询，哈希型的索引，时间复杂度会退化为 O(n)；而树型的有序特性，依然能够保持 O(log<sub>2</sub>N) 的高效率。</li><li>Hash 索引还有一个缺陷，数据的存储是没有顺序的，在 ORDER BY 的情况下，使用 Hash 索引还需要对数据重新排序。</li><li>对于联合索引的情况，Hash 值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。</li><li>对于等值查询来说，通常 Hash 索引的效率更高，不过也存在一种情况，就是索引列的重复值如果很多，效率就会降低。这是因为遇到 Hash 冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以，Hash 索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。</li></ul><p><strong>Hash 索引适用存储引擎如表所示</strong>：</p><table><thead><tr><th>索引 &#x2F; 存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>Hash 索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr></tbody></table><p><strong>Hash 索引的适用性</strong>：</p><p>Hash 索引存在着很多限制，相比之下在数据库中 B+ 树索引的使用面会更广，不过也有一些场景采用 Hash 索引效率更高，比如在键值型 (Key-Value) 数据库中，Redis 存储的核心就是 Hash 表。</p><p>MySQL 中的 Memory 存储引擎支持 Hash 存储，如果我们需要用到查询的临时表时，就可以选择 Memory 存储引擎，把某个字段设置为 Hash 索引，比如字符串类型的字段，进行 Hash 计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要等值查询的时候，采用 Hash 索引是个不错的选择。</p><p>另外，InnoDB 本身不支持 Hash 索引，但是提供自适应 Hash 索引 (Adaptive Hash Index)。什么情况下才会使用自适应 Hash 索引呢？如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到 Hash 表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让 B+ 树也具备了 Hash 索引的优点。</p><p><img src="http://1.117.162.142:9000/blog/%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95.png" alt="自适应哈希索引"></p><p> 采用自适应 Hash 索引的目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。</p><p>可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%adaptive_hash_index&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="6-3-二叉搜索树"><a href="#6-3-二叉搜索树" class="headerlink" title="6.3 二叉搜索树"></a>6.3 二叉搜索树</h4><p>如果我们利用二叉树作为索引结构，那么磁盘的 IO 次数和索引树的高度是相关的。</p><p><strong>二叉搜索树的特点</strong></p><ul><li>一个节点只能有两个子节点，也就是一个节点度不能超过 2</li><li>左子节点 &lt; 本节点；右子节点 &gt; 本节点，比我大的向右，比我小的向左</li></ul><p><strong>查找规则</strong></p><p>最基础的二叉搜索树 (Binary Search Tree)，搜索某个节点和插入节点的规则一样，假设搜索插入的数值为 key：</p><ul><li>如果 key 大于根结点，则在右子树中进行查找；</li><li>如果 key 小雨根结点，则在左子树中进行查找；</li><li>如果 key 等于根结点，也就是找到了这个节点，返回根结点即可。</li></ul><p>举个例子，对数列 (34, 22, 89, 5, 23, 77, 91) 创造出来的二分查找树如下图所示：</p><p><img src="http://1.117.162.142:9000/blog/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-1.png" alt="二叉搜索树"></p><p>但是存在特俗的情况，就是有时候二叉树的深度非常大。比如我们给出的数据顺序是 (5, 22, 23, 34, 77, 89, 91)，创造出来的二分搜索树如下图所示：</p><p><img src="http://1.117.162.142:9000/blog/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-2.png" alt="二叉搜索树"></p><p>上面第二棵树也属于二分查找树，但是性能上已经退化成了一条链表，查找数据的时间复杂度变成了 O(n)。能看出来第一个树的深度是 3，也就是说最多只需 3 次比较，就可以找到结点，而第二个树的深度是 7，最多需要 7 次比较才能找到结点。</p><p>为了提高查询效率，就需要减少磁盘 IO 数。为了减少磁盘 IO 的次数，就需要尽量降低树的高度，需要把原来高瘦的树结构变得矮胖，树的每层的分叉越多越好。</p><h4 id="6-4-AVL-树"><a href="#6-4-AVL-树" class="headerlink" title="6.4 AVL 树"></a>6.4 AVL 树</h4><p>为了解决上面二叉搜索树退化成链表的问题，人们提出了平衡二叉搜索树 (Balanced Binary Tree)，又称为 AVL 树，它在二叉搜索树的基础上增加了约束，具有以下性质：</p><p><strong>它是一棵空树或他的左右两个紫薯的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树</strong>。</p><p>这里说一下，常见的平衡二叉树有很多种，包括了平衡二叉搜索树、红黑树、数堆、伸展树。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到了平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就属于平衡二叉搜索树，搜索时间复杂度就是 O(log<sub>2</sub>n)。</p><p>数据查询的时间主要依赖于磁盘 I&#x2F;O 的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改进，树的深度也是 O(log<sub>2</sub>n)，当 n 比较大时，深度也是比较高的，比如下图的情况：</p><p><img src="http://1.117.162.142:9000/blog/avl%E6%A0%91.png" alt="avl树"></p><p>每访问一次节点就需要进行一次磁盘 I&#x2F;O 操作，对于上面的树来说，我们需要进行 5 次 I&#x2F;O 操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘 I&#x2F;O 操作次数多，会影响整体数据查询的效率。</p><p>针对同样的数据，如果我们把二叉树改成 M 叉树 (M &gt; 2) 呢？当 M &#x3D; 3 时，同样的 31 个节点可以由下面的三叉树来进行存储：</p><p><img src="http://1.117.162.142:9000/blog/%E5%B9%B3%E8%A1%A1%E4%B8%89%E5%8F%89%E6%A0%91.png" alt="平衡三叉树"></p><p>能看到此时树的高低降低了，当数据量 N 大的时候，以及树的分叉数 M 大的时候，M 叉树的高度会远小于二叉树的高度 (M &gt; 2)。所以，我们需要把树丛高瘦变矮胖。</p><h4 id="6-5-BTree"><a href="#6-5-BTree" class="headerlink" title="6.5 BTree"></a>6.5 BTree</h4><p>B 树的英文是 Balance Tree，也就是多路平衡查找树。简写为 B-Tree。它的高度远小于平衡二叉树的高度。</p><p>B 树的结构如下图所示：</p><p><img src="http://1.117.162.142:9000/blog/B%E6%A0%91.png" alt="B树"></p><p>B 树作为多路平衡查找树，它的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶。每个磁盘块包括了关键字和子节点的指针。如果一个磁盘块中包括了 x 个关键字，那么指针数就是 x+1。对于一个 100 阶的 B 树来说，如果有 3 层的话最多可以存储约 100 万的索引数据。对于大量的索引数据来说，采用 B 树的结构是非常适合的，因为树的高度要远小于二叉树的高度。</p><p>一个 M 阶的 B 树 (M &gt; 2) 有以下的特性：</p><ul><li>根结点的儿子树的范围是 [2, M]。</li><li>每个中间节点包含 k - 1 个关键字和 k 个孩子，孩子的数量 &#x3D; 关键字的数量 +1，k 的取值范围为 [ceil(M &#x2F; 2), M]。</li><li>叶子节点包括 k - 1 个关键字 (叶子节点没有孩子)，k 的取值范围为 [ceil(M &#x2F; 2), M]。</li><li>假设中间节点的关键字为：Key[1], Key[2], …, Key[k - 1]，且关键字按照升序排序，即 Key[i] &lt; Key[i + 1]。此时 k - 1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i - 1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k - 1] 的子树。</li><li>所有叶子节点位于同一层。</li></ul><p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。可以看下磁盘块 2，里面的关键字为 (8, 12)，它有 3 个孩子 (3, 5)，(9, 10)， (13, 15)，能看到 (3, 5) 小于 8，(9, 10) 在 8 和 12 之间，而 (13, 15) 大于 12，刚好符合刚才给出的特征。</p><p>然后看下如何用 B 树进行查找。假设想要查找的关键字是 9，那么步骤可以分为以下几步：</p><ul><li>与根结点的关键字 (17, 35) 进行比较，9 小于 17 纳米得到指针 P1；</li><li>按照指针 P1 找到磁盘块 2，关键字为 (8, 12)，因为 9 在 8 和 12 之间，所以得到指针 P2；</li><li>按照指针 P2 找到磁盘块 6，关键字为 (9, 10)，然后找到了关键字 9。</li></ul><p>能看出来在 B 树的搜索过程中，比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I&#x2F;O 操作，消耗的时间比在内存中进行比较所需的时间要多，是数据查找用时的重要因素。<strong>B 树相比于平衡二叉树来说磁盘 I&#x2F;O 操作要少</strong>，在数据查询中比平衡二叉树效率要高。所以<strong>只要树的高度足够低，IO 次数足够少，就可以提高查询性能</strong>。</p><p><strong>小结</strong>：</p><ul><li>B 树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</li><li>关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束。</li><li>其搜索性能等价于在关键字全集内做一次二分查找。</li></ul><p>例子：</p><p><img src="http://1.117.162.142:9000/blog/B%E6%A0%91%E4%BE%8B%E5%AD%90.png" alt="B树例子"></p><h4 id="6-6-B-Tree"><a href="#6-6-B-Tree" class="headerlink" title="6.6 B + Tree"></a>6.6 B + Tree</h4><p>B+ 树也是一种多路搜索树，基于 B 树做出了改进，主流的 DBMS 都支持 B+ 树的索引方式，比如 MySQL。相比于 B-Tree，B+Tree 适合文件索引系统。</p><p><strong>B+ 树和 B 树的差异在于以下几点</strong>：</p><ul><li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字树 + 1。</li><li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大或最小。</li><li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中，非叶子节点及保存索引，也保存数据记录。</li><li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</li></ul><p>下图就是一棵 B+ 树，阶数为 3，根节点中的关键字 1、18、35 分别是子节点 (1, 8, 14)，(18, 24,31) 和 (35, 41, 53) 中的最小值。每一层父节点的关键字都会出现在下一层的子节点的关键字中，因此在叶子节点中包括了所有的关键字信息，并且每一个叶子节点都有一个只想下一个节点的指针，这样就形成了一个链表。</p><p><img src="http://1.117.162.142:9000/blog/B+%E6%A0%91.png" alt="B+树"></p><p>如果，想要查找关键字 16，B+ 树会自顶向下逐层进行查找：</p><ul><li>与根结点的关键字 (1, 18, 35) 进行比较，16 在 1 和 18 之间，得到指针 P1 (指向磁盘块 2)</li><li>找到磁盘块 2，关键字为 (1, 8, 14)，因为 16 大于 14，所以得到指针 P3 (指向磁盘块 7)</li><li>找到磁盘块 7，关键字为 (14, 16, 17)，然后找到了关键字 16，所以可以找到关键字 16 所对应的数据。</li></ul><p>整个过程一共进行了 3 次 IO 操作，看起来 B+ 树和 B 树的查询过程差不多，但是 B+ 树和 B 树有根根本的差异在于，<strong>B+ 树的中间节点并不直接存储数据</strong>。这样的好处都有什么？</p><p>首先，<strong>B+ 树查询效率更稳定</strong>。因为 B+ 树每次只有访问到叶子节点才能找到对应的数据，而在 B 树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。</p><p>其次，<strong>B+ 树的查询效率更高</strong>。这是因为通常 B+ 树比 B 树更矮胖 (阶数更大，深度更低)，查询所需要的磁盘 I&#x2F;O 也会更少。同样的磁盘页大小，B+ 树可以存储更多的节点关键字。</p><p>不仅是对单个关键字的查询上，<strong>在查询范围上，B+ 树的效率也比 B 树高</strong>。这里因为所有关键字都出现在 B+ 树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在 B 树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</p><blockquote><p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。</p><p>但 B 树和 B+ 树各有自己的应用场景，不能说 B+ 树完全比 B 树好，反之亦然。</p></blockquote><p><strong>思考题：为了减少 IO，索引树会一次性加载吗</strong>？</p><blockquote><p>1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个 G。</p><p>2、当我们利用索引查询的时候，是不可能将全部几个 G 的索引都加载进内存的，能做的只能是：逐一加载每一个磁盘页，因为磁盘页对应着索引树的节点。</p></blockquote><p><strong>思考题：B+ 树的存储能力如何？为何说一般查找行记录，最多只需要 1～3 次磁盘 IO</strong>？</p><blockquote><p>InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT (占用 4 个字节) 或BIGINT (占用 8 个字节)，指针类型也一般为 4 或 8 个字节，也就是说一个页 (B+ 树中的一个节点) 中大概存储 16KB &#x2F; (8B + 8B) &#x3D; 1K 个键值 (因为是估值，为方便计算，这里的 K 取值为 10<sup>3</sup>。也就是说一个深度为 3 的 B+ 树索引可以维护 10<sup>3</sup> * 10<sup>3</sup> * 10<sup>3</sup> &#x3D; 10 亿条记录。这里假定一个数据页也存储 10<sup>3</sup> 条行记录数据了)。</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+ 树的高度一般都在 2～4 层。MySQL 的 InnoDB 存储引擎在设计时是将根结点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1～3 次磁盘 I&#x2F;O 操作。</p></blockquote><p><strong>思考：为什么说 B+ 树比 B 树更适合实际应用中操作系统的文件索引和数据库索引</strong>？</p><blockquote><p>1、B+ 树的磁盘读写代价更低</p><p>B+ 树的内部节点并没有指向关键字具体信息的指针。因此其内部节点相对 B 树更小。如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了。</p><p>2、B+ 树的查询效率更加稳定</p><p>由于非终结点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p></blockquote><p><strong>思考题：Hash 索引与 B+ 树索引的区别</strong></p><blockquote><p>1、Hash 索引不能进行范围查询，而 B+ 树可以。这是因为 Hash 索引指向的数据是无序的，而 B+ 树的叶子节点是个有序的链表。</p><p>2、Hash 索引不支持联合索引的最左侧原理 (即联合索引的部分索引无法使用)，而 B+ 树可以。对于联合索引来说，Hash 索引在计算 Hash 值的时候是将索引键合并后再一起计算 Hash 值，所以不会针对每个索引单独计算 Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</p><p>3、Hash 索引不支持 ORDER BY 排序，因为 Hash 索引指向的数据是无序的，因此无法起到排序优化的作用，而 B+ 树索引数据是有序的，可以起到对该字段 ORDER BY 排序优化的作用。同理，也无法用 Hash 索引进行模糊查询，而 B+ 树使用 LIKE 进行模糊查询的时候，LIKE 后面模糊查询 (比如 % 结尾) 的话就可以起到优化作用。</p><p>4、I浓浓DB 不支持 哈希索引。</p></blockquote><p><strong>思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗</strong>？</p><blockquote><p>如果使用的是 MySQL 的话，我们需要了解 MySQL 的存储引擎都支持哪些索引结构，如下表</p><table><thead><tr><th>Storage Engine</th><th>Permissible Index Types</th></tr></thead><tbody><tr><td>InnoDB</td><td>BTREE</td></tr><tr><td>MyISAM</td><td>BREEE</td></tr><tr><td>MEMORY&#x2F;HEAP</td><td>HASH，BTREE</td></tr><tr><td>NDB</td><td>HASH，BTREE</td></tr></tbody></table><p>能看到，针对 InnoDB 和 MyISAM 存储引擎，都会默认采用 B+ 树索引，无法使用 Hash 索引。InnoDB 提供的自适应 Hash 是不需要手动指定的。如果是 Memory&#x2F;Heap 和 NDB 引擎，是可以进行选择 Hash 索引的。</p></blockquote><h4 id="6-7-R-树"><a href="#6-7-R-树" class="headerlink" title="6.7 R 树"></a>6.7 R 树</h4><p>R- Tree 在 MySQL 很少使用，仅支持 geometry 数据类型，支持该类型的存储引擎只有 MyISAM、BDB、InnoDB、NDB、Archive 集中。举个 R 树在现实领域中能够解决的例子：查找 20 英里以内所有的餐厅。如果没有 R 树你会怎么解决？一般情况下我们会把餐厅的坐标 (x, y) 分为两个字段存放在数据库中，一个字段记录精度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满足要求。如果一个地区有 100 家餐厅的话，我们就需要进行 100 次位置计算了，如果应用到谷歌、百度地图这种超级大数据库中，这种方法便必定不可行了。R 树就很好的解决了这种高维空间搜索问题。它把 B 树的思想很好的扩展到了多维空间，采用了 B 树分割空间的思想，并在添加、删除操作时采用合并、分解节点的方法，保证树的平衡性。因此，R 树就是一棵用来存储高维数据的平衡树。相对于 B-Tree，R-Tree 的优势在于范围查找。</p><table><thead><tr><th>索引 &#x2F; 存储引擎</th><th>MyISAM</th><th>InnoDB</th><th>Memory</th></tr></thead><tbody><tr><td>R-Tree 索引</td><td>支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h4 id="6-8-小结"><a href="#6-8-小结" class="headerlink" title="6.8 小结"></a>6.8 小结</h4><p>使用索引可以帮助我们从海量的数据中快速定位想要查找的数据，不过索引也存在一些不足，比如占用存储空间、降低数据库写操作的性能等，如果有多个索引还会增加索引选择的时间。当我们使用索引时，需要平衡索引的利 (提升查询效率) 和弊(维护索引所需的代价)。</p><p>在实际工作中，我们还需要基于需求和数据本身的分布情况来确定是否使用索引，尽管索引不是万能的，但数据量大的时候不使用索引是不可想象的，毕竟索引的本质，是帮助我们提升数据检索的效率。</p><h2 id="五、InnoDB-数据存储结构"><a href="#五、InnoDB-数据存储结构" class="headerlink" title="五、InnoDB 数据存储结构"></a>五、InnoDB 数据存储结构</h2><h3 id="1-数据库的存储结构：页"><a href="#1-数据库的存储结构：页" class="headerlink" title="1. 数据库的存储结构：页"></a>1. 数据库的存储结构：页</h3><p>索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都是保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL 服务器上的存储引擎负责对表中数据的读取和写入工作。不同存储引擎中存放的格式一般是不同的，甚至有的存储引擎比如 Memory 都不用磁盘来存储数据。</p><p>由于 InnoDB 是 MySQL 的默认存储引擎，所以本章剖析 InnoDB 存储引擎的数据存储结构。</p><h4 id="1-1-磁盘与内存交互基本单位：页"><a href="#1-1-磁盘与内存交互基本单位：页" class="headerlink" title="1.1 磁盘与内存交互基本单位：页"></a>1.1 磁盘与内存交互基本单位：页</h4><p>InnoDB 将数据划分为若干个页，InnoDB 中页的大小默认为 16KB。</p><p>以页作为磁盘和内存之间交互的基本单位，也就是一次最少丛磁盘中读取 16KB 的内容到内存中，一次最少把内存中的 16KB 内容刷新到磁盘中。也就是说，<strong>在数据库中，不论读一行，还是读多行，都是将这些所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页 (Page)，数据库 I&#x2F;O 操作的最小单位是页</strong>。一个页中可以存储多个行记录。</p><blockquote><p>记录是按照行来存储的，但是数据库的读取并不是以行为单位，否则一次读取 (也就是一次 I&#x2F;O 操作) 只能处理一行数据，效率会非常低。</p></blockquote><p><img src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E9%A1%B5.png" alt="数据页"></p><h4 id="1-2-页结构概述"><a href="#1-2-页结构概述" class="headerlink" title="1.2 页结构概述"></a>1.2 页结构概述</h4><p>页 a、页 b、页 c … 页 n 这些页可以不再物理结构上相连，只要通过双向链表相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页都会为存储在它里边的记录生成一个页目录，再通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，啊啊然后再便利该槽对应分组中的记录即可快速找到指定的记录。</p><h4 id="1-3-页的大小"><a href="#1-3-页的大小" class="headerlink" title="1.3 页的大小"></a>1.3 页的大小</h4><p>不同的数据库管理系统的页大小不同。比如在 MySQL 的 InnoDB 存储引擎中，默认页的大小是 16KB，我们可以通过下面的命令来进行查看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_page_size%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>SQL Server 中页的大小为 8KB，而在 Oracle 中我们用术语“块” (Block) 来代表“页”，Oracle 支持的块的大小为 2KB、4KB、8KB、16KB、32KB 和 64KB。</p><h4 id="1-4-页的上层结构"><a href="#1-4-页的上层结构" class="headerlink" title="1.4 页的上层结构"></a>1.4 页的上层结构</h4><p>另外在数据库中，还存在着区 (Extent)、段 (Segment) 和表空间 (Tablespace) 的概念。行、页、区、段、表空间的关系如下图所示：</p><p><img src="http://1.117.162.142:9000/blog/%E8%A1%8C%E9%A1%B5%E5%8C%BA%E6%AE%B5%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="行页区段表空间的关系"></p><p>区 (Extent) 是比页大一级的存储结构，在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64 * 16KB &#x3D; 1MB。</p><p>段 (Segment) 由一个或多个区组成，区在文件系统中是一个连续分配的空间 (在 InnoDB 中是连续的 64 个页)，不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p><p>表空间 (Tablespace) 是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。</p><h3 id="2-页的内部结构"><a href="#2-页的内部结构" class="headerlink" title="2. 页的内部结构"></a>2. 页的内部结构</h3><p>页如果按类型划分的话，常见的有数据页 (保存 B+ 树节点)、系统页、Undo 页 和 事物数据页等。数据页是我们最常使用的页。</p><p>数据页的 16KB 大小的存储空间被划分为七个部分，分别是文件头 (File Header)、页头 (Page Header)、最大最小记录 (Infimum + supremum)、用户记录 (User Records)、空闲空间 (Free Space)、页目录 (Page Directory) 和文件尾 (File Tailer)。</p><p>页结构的示意图如下所示：</p><p><img src="http://1.117.162.142:9000/blog/%E9%A1%B5%E7%BB%93%E6%9E%84%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="页结构的示意图"></p><p>这 7 个部分作用分别如下：</p><table><thead><tr><th>名称</th><th>占用大小</th><th>说明</th></tr></thead><tbody><tr><td>File Header</td><td>38 字节</td><td>文件头，描述页的信息</td></tr><tr><td>Page Header</td><td>56 字节</td><td>页头，页的状态信息</td></tr><tr><td>Infimum + Supremum</td><td>26 字节</td><td>最大和最小记录，这时两个虚拟的行记录</td></tr><tr><td>User Records</td><td>不确定</td><td>用户记录，存储行记录内容</td></tr><tr><td>Free Space</td><td>不确定</td><td>空闲记录，页中还没有被使用的空间</td></tr><tr><td>Page Directory</td><td>不确定</td><td>页目录，存储用户记录的相对位置</td></tr><tr><td>File Trailer</td><td>8 字节</td><td>文件尾，校验页是否完整</td></tr></tbody></table><p>我们可以把这 7 个结构分成 3 个部分。</p><h4 id="2-1-File-Header-文件头部-和-File-Trailer-文件尾部"><a href="#2-1-File-Header-文件头部-和-File-Trailer-文件尾部" class="headerlink" title="2.1 File Header (文件头部) 和 File Trailer (文件尾部)"></a>2.1 File Header (文件头部) 和 File Trailer (文件尾部)</h4><p>首先是文件通用部分，也就是文件头和文件尾。</p><p><strong>文件头部信息</strong></p><p>不同类型的页都会以 File Header 作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁等，所有的数据页会组成一个双链表。这个部分占用固定的 38 个字节，是由下边这些内容组成的：</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4 字节</td><td>页的校验和 (checksum 值)</td></tr><tr><td>FIL_PAGE_OFFSET</td><td>4 字节</td><td>页号</td></tr><tr><td>FIL_PAGE_PREV</td><td>4 字节</td><td>上一个页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4 字节</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td>8 字节</td><td>页面被最后修改时对应的日志序列位置 (英文名是：Log Sequence Number)</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2 字节</td><td>该页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td>8 字节</td><td>尽在系统表空间的一个页中定义，代表文件至少被刷新到了对应的 LSN 值</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4 字节</td><td>页属于哪个表空间</td></tr></tbody></table><p>其中：</p><ul><li><p>FIL_PAGE_OFFSET</p><p>  每一个页都有一个单独的页号，InnoDB通过页号可以唯一定位一个页。</p></li><li><p>FIL_PAGE_TYPE</p><p>  这个代表当前页的类型。InnoDB 为了不同的目的而把页分为不同的类型，上面介绍的都是存储记录的数据页，还有很多其它的类型的页：</p><table><thead><tr><th>类型名称</th><th>十六进制</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>最新分配，还没使用</td></tr><tr><td>FIL_PAGE_UNDO_LOG</td><td>0x0002</td><td>Undo 日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>段信息节点</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Insert Buffer 空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Insert Buffer 位图</td></tr><tr><td>FIL_PAGE_TYPE_SYS</td><td>0x0006</td><td>系统页</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>扩展描述页</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>溢出页</td></tr><tr><td>FIL_PAGE_INDEX</td><td>0x45BF</td><td>索引页，也就是数据页</td></tr></tbody></table><p>  我们存放记录的数据页的类型其实是 FIL_PAGE_INDEX，也就是所谓的索引页。</p></li></ul><p><strong>数据页的链接实现</strong></p><p>在文件头部内容中有两个属性：FIL_PAGE_PREV 和 FIL_PAGE_NEXT</p><p>InnoDB 都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV 和 FIL_PAGE_NEXT 就跟别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间不需要是物理上的连续，而是逻辑上的连续。</p><p>数据页之间组成的双向链表：</p><p><img src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%BB%84%E6%88%90%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="数据页之间组成的双向链表"></p><p><img src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%BB%84%E6%88%90%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A82.png" alt="数据页之间组成的双向链表"> </p><p><strong>检验页的完整性</strong></p><p>文件头部和文件尾部都有属性：FIL_PAGE_SPACE_OR_CHKSUM</p><p>代表当前页面的检验和 (checksum)。</p><blockquote><p>什么是校验和？</p><p>就是对于一个很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为检验和。</p><p>在比较两个很长的字节串之前，先比较这两个长字节串的校验和，如果校验和都不一样，则两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。</p></blockquote><p>InnoDB 存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候断电了，造成了该页传输的不完整性。</p><p>为了检测一个页是否完整 (也就是在同步的时候有没有发生只同步一半的尴尬情况)，这时可以通过文件尾的检验和 (checksum 值) 与文件头的检验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。</p><p><strong>文件尾部</strong></p><p>文件尾部总共占用 8 个字节</p><ul><li>前 4 个字节代表页的校验和：这个部分适合 File Header 中的校验和相对应的。</li><li>后 4 个字节代表页面被最后修改时对应的日志序列位置 (LSN)。</li></ul><p>这个部分也是为了校验页的完整性的，如果首部和尾部的 LSN 值校验不成功的话，就说明同步过程出现了问题。</p><h4 id="2-2-User-Records-用户记录-、最大最小记录、Free-Space-空闲空间"><a href="#2-2-User-Records-用户记录-、最大最小记录、Free-Space-空闲空间" class="headerlink" title="2.2 User Records (用户记录)、最大最小记录、Free Space (空闲空间)"></a>2.2 User Records (用户记录)、最大最小记录、Free Space (空闲空间)</h4><p>第二部分是记录部分，页的主要作用是存储记录，所以”最大和最小记录“和“用户记录”部分占了页结构的主要空间。</p><p><img src="http://1.117.162.142:9000/blog/%E9%A1%B5%E7%BB%93%E6%9E%84%E7%A9%BA%E9%97%B4%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="页结构空间示意图"></p><p><strong>空闲空间 (Free Space)</strong></p><p>我们自己存储的记录会按照指定的行格式存储到 User Records 部分。但是在一开始生成页的时候，其实并没有 User Records 这个部分，每当我们插入一条记录，都会从 Free Space 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到 User Records 部分，当 Free Space 部分的空间全部被 User Records 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。</p><p><strong>用户记录 (User Records)</strong></p><p>User Records 中的这些记录按照指定的行格式一条一条摆在 User Records 部分，相互之间形成单链表。用户记录里的</p><p><strong>最小最大记录 (Infimum + Supremum)</strong></p><p>记录可以比较大小吗？</p><p>记录可以比大小，对于一条完整的记录来说，比较就的大小就是比较主键的大小。比方说我们插入的 4 行记录的主键值分别是：1、2、3、4，这就意味着这 4 条记录是从小到大依次递增。</p><p>InnoDB 规定的最小记录与最大记录这两条记录的构造十分简单，都是由 5 个字节大小的记录头信息和 8 字节大小的一个固定的部分组成的，如图：</p><p><img src="http://1.117.162.142:9000/blog/%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E8%AE%B0%E5%BD%95.png" alt="最小最大记录"></p><p>这两条记录不是我们自己定义的记录，所以她们并不存放在页的 User Records 部分，她们被单独放在一个称为 Infimum + Supremum 的部分，如图：</p><p> <img src="http://1.117.162.142:9000/blog/%E6%9C%80%E5%B0%8F%E6%9C%80%E5%A4%A7%E8%AE%B0%E5%BD%952.png" alt="最小最大记录"></p><h4 id="2-3-Page-Directory-页目录-、Page-Header-页面头部"><a href="#2-3-Page-Directory-页目录-、Page-Header-页面头部" class="headerlink" title="2.3 Page Directory (页目录)、Page Header (页面头部)"></a>2.3 Page Directory (页目录)、Page Header (页面头部)</h4><p><strong>页目录</strong></p><p>在页中，记录是以单向链表的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了目录页这个模块，专门给记录做一个目录，通过二分查找法的方式进行检索提升效率。</p><p><strong>页目录是如何构成的</strong></p><p>需求：根据主键值查找页中的某条记录，如何实现快速查找呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> page_demo <span class="operator">=</span> <span class="keyword">WHERE</span> c1 <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>最笨的办法：顺序查找</p><p>从 Infimum 记录 (最小记录) 开始，沿着链表一直往后找，总有一天会找到或者找不到，在找的时候还能投机取巧，因为链表中哥哥记录的值是按照从小到大的顺序排列的，所以当链表的某个节点代表的记录的主键值大于你想要查找的主键值是，你就可以停止查找了，因为该节点后边的节点的主键值依次递增。</p><p>如果一个页中存储了非常多的记录，这么查找性能很差。</p><p>好办法：使用目录，二分查找法</p><ul><li>将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。</li><li>第一组，也就是最小记录所在的分组只有一个记录；最后一组，就是最大记录所在的分组，会有 1～8 条记录；其余的组记录数量在 4～8 条之间。这样做的好处是，除了第一组以外，其余组的记录树会尽量平分。</li><li>在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。</li><li>页目录用来存储魅族最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，魅族的地址偏移量也被称之为槽 (slot)，每个槽相当于指针指向了不同组的最后一个记录。</li></ul><p>页目录分组的个数如何确定？</p><p>为什么最小记录的 n_owned 值为 1，而最大记录的 n_owned 值为 5 呢？</p><p>InnoDB 规定：对于最小记录所在的分组只能有一条记录，最大记录所在的分组拥有的记录条数只能在 1～8 之间，剩下的分组中记录的条数范围只能在 4～8 之间。</p><p>分组是按照下面的步骤进行的：</p><ul><li>初始情况下一个数据页里只有最小记录和最大记录两条记录，她们分属于两个分组。</li><li>之后没插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的 n_owned 值加 1，表示本组内又添加了一条记录，知道该组中的记录数等于 8 个。</li><li>在一个组中的记录数等于 8 个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中 4 条记录，另一个 5 条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li></ul><p><strong>页面头部</strong></p><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫 Page Header 的部分，这个部分占用固定的 56 个字节，专门存储各种状态信息。</p><table><thead><tr><th>名称</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2 字节</td><td>在页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2 字节</td><td>还未使用的空间最小地址，也就是说从该地址之后就是 Free Space</td></tr><tr><td>PAGE_N_HEAP</td><td>2 字节</td><td>本页中的记录的数量 (包括最小和最大记录以及标记为删除的记录)</td></tr><tr><td>PAGE_FREE</td><td>2 字节</td><td>第一个已经标记为删除的记录地址 (各个已删除的记录通过 next_record 也会组成一个单链表，这个单链表中的记录可以被重新利用)</td></tr><tr><td>PAGE_GARBAGE</td><td>2 字节</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2 字节</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2 字节</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2 字节</td><td>一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2 字节</td><td>该页中记录的数量 (不包括最小和最大记录以及被标记为删除的记录)</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8 字节</td><td>修改当前页的最大事务 ID，该值尽在二级索引中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2 字节</td><td>当前页在 B+ 树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8 字节</td><td>索引 ID，表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10 字节</td><td>B+ 树叶子段的头部信息，仅在 B+ 树的 Root 页定义</td></tr></tbody></table><h4 id="2-4-从数据页的角度看-B-树如何查询"><a href="#2-4-从数据页的角度看-B-树如何查询" class="headerlink" title="2.4 从数据页的角度看 B+ 树如何查询"></a>2.4 从数据页的角度看 B+ 树如何查询</h4><p>一棵 B+ 树按照节点类型可以分成两部分：</p><ul><li>叶子节点，B+ 树最底层的节点，节点的高度为 0，存储行记录。</li><li>非叶子节点，节点的高度大于 0，存储索引键和页面指针，并不存储记录本身。</li></ul><p><img src="http://1.117.162.142:9000/blog/B+%E6%A0%91%E6%9F%A5%E8%AF%A2.png" alt="B+树查询"></p><p>当我们从页结构来理解 B+ 树的时候，可以帮我们理解一些通过索引进行检索的原理：</p><p><strong>B+ 树是如何进行记录检索的</strong>？</p><p>如果通过 B+ 树的索引查询行记录，首先是从 B+ 树的根开始，逐层检索，知道找到叶子节点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽 (slot) 采用二分查找的方式先找到一个粗略的记录分组，然后再在分组中通过链表遍历的方式查找记录。</p><p><strong>普通索引和唯一索引在存储效率上有什么不同</strong>？</p><p>我们创建索引的时候可以是普通索引，也可以是唯一索引，那么这两个索引在查询效率上有什么不同呢？</p><p>唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索。而普通索引，可能会存储在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是单独将这条记录从磁盘中读出去，而是将这个记录所在的页加载到内存中进行读取。InnoDB 存储引擎的页大小为 16KB，在一个页中可能存储着上千个记录，因此在普通索引的字段上进行查找也就是在内存中多几次判断下一条记录的操作，对于 CPU 来说，这些操作所消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本没有差别。</p><h3 id="3-InnoDB-行格式-或记录格式"><a href="#3-InnoDB-行格式-或记录格式" class="headerlink" title="3. InnoDB 行格式 (或记录格式)"></a>3. InnoDB 行格式 (或记录格式)</h3><p>平时的数据以行为单位来向表中插入数据，这些记录在磁盘上的存放方式也被称为行格式或记录格式。InnoDB 存储引擎设计了 4 种不同类型的行格式，分别是 Compact、Redundant、Dynamic 和 Compressed 行格式。</p><p>查看 MySQL8 的默认行格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@innodb</span>_default_row_format;</span><br></pre></td></tr></table></figure><p>也可以使用如下语法查看具体表使用的行格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">like</span> 表名\G</span><br></pre></td></tr></table></figure><h4 id="3-1-指定行格式的语法"><a href="#3-1-指定行格式的语法" class="headerlink" title="3.1 指定行格式的语法"></a>3.1 指定行格式的语法</h4><p>在创建或修改表的语句中指定行格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (列信息) ROW_FORMAT<span class="operator">=</span>行格式名称;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ROW_FORMAT<span class="operator">=</span>行格式名称;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> record_test_table(</span><br><span class="line">col1 <span class="type">VARCHAR</span>(<span class="number">8</span>),</span><br><span class="line">  col2 <span class="type">VARCHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  col3 <span class="type">char</span>(<span class="number">8</span>),</span><br><span class="line">  col4 <span class="type">VARCHAR</span>(<span class="number">8</span>)</span><br><span class="line">) CHARSET<span class="operator">=</span>ascii ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> record_test_table(col1, col2, col3, col4)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="string">&#x27;wangwu&#x27;</span>,<span class="string">&#x27;laji&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;xiaoming&#x27;</span>,<span class="string">&#x27;xiaohong&#x27;</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><h4 id="3-2-COMPACT-行格式"><a href="#3-2-COMPACT-行格式" class="headerlink" title="3.2 COMPACT 行格式"></a>3.2 COMPACT 行格式</h4><p>在 MySQL 5.1 版本中，默认设置为 Compact 行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p><p><img src="http://1.117.162.142:9000/blog/compact%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="compact行格式示意图"></p><p><strong>变长字段长度列表</strong></p><p>MySQL 支持一些变长的数据类型，比如 VARCHAR(M)、VARBINARY(M)、TEXT 类型，BLOB 类型，这些数据类型修饰列称为变长字段，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。在 Compact 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。</p><blockquote><p>注意：这里面存储的变长长度和字段顺序是反过来的。比如两个 varchar 字段在表结构的顺序是 a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是 15，10，是反过来的。</p></blockquote><p>以 record_test_table 表中的第一条记录举例：因为 record_test_table 表的 col1、col2、col4 都是 VARCHAR(8) 类型的，所以这三个列的值的长度都需要保存在记录开头处，注意 record_test_table 表中的各个列都使用的是 ascii 字符集 (每个字符只需要 1 字节来进行编码)。</p><table><thead><tr><th>列名</th><th>存储内容</th><th>内容长度 (十进制表示)</th><th>内容长度 (十六进制表示)</th></tr></thead><tbody><tr><td>col1</td><td>‘zhangsan’</td><td>8</td><td>0x88</td></tr><tr><td>col2</td><td>‘lisi’</td><td>4</td><td>0x04</td></tr><tr><td>col4</td><td>‘laji’</td><td>6</td><td>0x06</td></tr></tbody></table><p>又因为这些长度值需要按照列的逆序存放，所以最后变长字段长度列表的字节串用十六进制表示的效果就是 (各个字节之间实际上没有空格，用空格隔开只是方便理解)：06 04 08</p><p>把这个字节串组成的变长字段长度列表填入上边的示意图中的效果就是：</p><p><img src="http://1.117.162.142:9000/blog/compact%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE-1.png" alt="compact行格式示意图"></p><p><strong>NULL 值列表</strong></p><p>Compact 行格式会把可以为 NULL 的列统一管理起来，存在一个标记为 NULL 值列表中。如果表中没有允许存储 NULL 的列，则 NULL 值列表也不存在了。</p><p>为什么定义 NULL 值列表？</p><p>之所以要存储 NULL 是因为数据都是需要对齐的，如果没有标注出来 NULL 值的位置，就有可能在查询数据的时候出现混乱。如果使用一个特定的符号放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据的头部开辟出一块空间专门用来记录改行数据哪些是非空数据，哪些是空数据，格式如下：</p><ul><li>二进制位的值为 1 时，代表该列的值为 NULL。</li><li>二进制位的值为 0 时，代表该列的值不为 NULL。</li></ul><p>例如：字段 a、b、c，其中 a 是主键，在某一行中存储的数依次是 a &#x3D; 1、b &#x3D; null、c &#x3D; 2。那么 Compact 行格式中的 NULL 值列表中存储：01。第一个 0 表示 c 不为 null，第二个 1 表示 b 是 null。这里之所以没有 a 是因为数据库会自动跳过主键，因为主键肯定是非 NULL 且唯一的，在 NULL 值列表的数据中就会自动跳过主键。</p><p>record_test_table 的两条记录的 NULL 值列表就如下：</p><p>第一条记录：</p><p><img src="http://1.117.162.142:9000/blog/%E7%AC%AC%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95.png" alt="第一条记录"></p><p>第二条记录：</p><p><img src="http://1.117.162.142:9000/blog/%E7%AC%AC%E4%BA%8C%E6%9D%A1%E8%AE%B0%E5%BD%95.png" alt="第二条记录"></p><p><strong>记录头信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> page_demp(</span><br><span class="line">c1 <span class="type">INT</span>,</span><br><span class="line">  c2 <span class="type">INT</span>,</span><br><span class="line">  c3 <span class="type">VARCHAR</span>(<span class="number">10000</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> kEY(c1)</span><br><span class="line">)CHARSET<span class="operator">=</span>ascii ROW_FORMAT<span class="operator">=</span>Compact;</span><br></pre></td></tr></table></figure><p>这个表中的记录的行格式示意图：</p><p><img src="http://1.117.162.142:9000/blog/%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="行格式示意图"></p><p>这些记录头信息中各个属性如下：</p><table><thead><tr><th>名称</th><th>大小 (单位：bit)</th><th>描述</th></tr></thead><tbody><tr><td>预留位 1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位 2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_mask</td><td>1</td><td>标记该记录是否被删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+ 树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>表示当前记录拥有的记录数</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在记录堆的位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型，0 表示普通记录，1 表示 B+ 树非叶子节点记录，2 表示最小记录，3 表示最大记录</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><p>简化后的行格式示意图：</p><p><img src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8C%96%E5%90%8E%E7%9A%84%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="简化后的行格式示意图"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demp</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">100</span>, <span class="string">&#x27;song&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;tong&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="number">300</span>, <span class="string">&#x27;zhan&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="number">400</span>, <span class="string">&#x27;lisi&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://1.117.162.142:9000/blog/page_demo%E6%95%B0%E6%8D%AE.png" alt="page_demo数据"></p><ul><li><p>delete_mask</p><p>  这个属性标记着当前记录是否被删除，占用 1 个二进制位。</p><ul><li>值为 0：代表记录并没有被删除</li><li>值为 1:代表记录被删除</li></ul><p>  被删除的记录为什么还在页中存储呢？</p><p>  你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其它的记录在磁盘上需要重新排列，导致性能消耗。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为可重用空间，之后如果有新纪录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</p></li><li><p>min_rec_mask</p><p>  B+ 树的每层非叶子节点中最小记录都会添加该标记，min_rec_mask 值为 1。我们自己插入的四条记录 min_rec_mask 值都是 0，意味着他们都不是 B+ 树的非叶子节点中的最小记录。</p></li><li><p>record_type</p><p>  这个属性表示当前记录的类型，一共有 4 种类型的记录：</p><p>  0：表示普通记录</p><p>  1：表示 B+ 树非叶子节点记录</p><p>  2：表示最小记录</p><p>  3：表示最大记录</p><p>  从图中我们可以看出来，我们自己插入的记录就是普通记录，它们的 record_type 值都是 0，而最小记录和最大记录的 record_type 值分别为 2 和 3。</p></li><li><p>heap_no</p><p>  这个属性表示当前记录在本页中的位置。</p><p>  从图中可以看出来，我们插入的 4 条记录在本页中的位置分别是：2、3、4、5。</p><p>  怎么不见 heap_no 值为 0 和 1 的记录呢？</p><p>  MySQL 会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录。最小记录和最大记录的 heap_no 值分别是 0 和 1，也就是说它们的位置最靠前。</p></li><li><p>n_owned</p><p>  页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。</p></li><li><p>next_record</p><p>  记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。</p><p>  比如：第一条记录的 next_record 值为 32，意味着从第一条记录的真实数据的地址处向后找 32 个字节便是下一条记录的真实数据。</p><p>  注意，下一条记录指的并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 Infimum 记录 (也就是最小记录) 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum 记录 (也就是最大记录)。下图用箭头代替偏移量表示 next_record。</p><p>  <img src="http://1.117.162.142:9000/blog/next_record%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="next_record示意图"></p><ul><li><p>删除操作</p><p>  从表中删除掉一条记录，这个链表也是会跟着变化：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> page_demo <span class="keyword">WHERE</span> c1 <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>  删掉第二条记录后的示意图就是：</p><p>  <img src="http://1.117.162.142:9000/blog/%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="删除操作示意图"></p><p>  从图中可以看出来，删除第二条记录前后主要发生了这些变化：</p><ul><li>第二条记录并没有从存储空间中移除，而是把该记录的 delete_mask 值设置为 1。</li><li>第二条记录的 next_record 值变为了 0，意味着该记录没有下一条记录了。</li><li>第一条记录的 next_record 指向了第三条记录。</li><li>最大记录的 n_owned 值从 5 变成了 4。</li></ul><p>  所以，不论我们怎么对页中的记录做增删改操作，InnoDB 始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。</p></li><li><p>添加操作</p><p>  主键值为 2 的记录被我们删掉了，但是存储空间却没有回收，如果再次把这条记录插入到表中，会发生什么事呢？</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;tong&#x27;</span>);</span><br></pre></td></tr></table></figure><p>  看一下记录的存储情况：</p><p>  <img src="http://1.117.162.142:9000/blog/%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="添加操作示意图"></p><p>  直接服用了原来被删除记录的存储空间。</p><p>  说明：</p><p>  当数据页中存在多条被删掉的记录时，这些记录的 next_record 属性将会把这些被删除的记录组成一个垃圾链表，以备之后重用这部分存储空间。</p></li></ul></li></ul><p><strong>记录的真实数据</strong></p><p>记录的真实数据除了我们自己定义的列的数据以外，还会有三个隐藏列：</p><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6 字节</td><td>行 ID，唯一标识一条记录</td></tr><tr><td>transaction_id</td><td>是</td><td>6 字节</td><td>事务 ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7 字节</td><td>回滚指针</td></tr></tbody></table><p>实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR。</p><ul><li>一个表没有手动定义主键，则会选取一个 Unique 键作为主键，如果连 Unique 键都没有定义的话，则会为表默认添加一个名为 row_id 的隐藏列作为主键。所以 row_id 是在没有自定义主键以及 Unique 键的情况下才会存在的。</li><li>事务 ID 和回滚指针在后面描述</li></ul><h4 id="3-3-Dynamic-和-Compressed-行格式"><a href="#3-3-Dynamic-和-Compressed-行格式" class="headerlink" title="3.3 Dynamic 和 Compressed 行格式"></a>3.3 Dynamic 和 Compressed 行格式</h4><p><strong>行溢出</strong></p><p>InnoDB 存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。</p><p>很多 DBA 喜欢 MySQL 数据库提供的 VARCHAR(M) 类型，认为可以存放 65535 字节。这是真的吗？如果我们使用 ascii 字符集的话，一个字符就代表一个字节，我们看看 VARCHAR(65535) 是否可用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> varchar_size_demo(c <span class="type">VARCHAR</span>(<span class="number">65535</span>)) CHARSET <span class="operator">=</span> ascii ROW_FORMAT <span class="operator">=</span> Compact;</span><br><span class="line"># 结果如下：</span><br><span class="line">ERROR <span class="number">1118</span> (<span class="number">42000</span>): <span class="type">Row</span> size too large.</span><br></pre></td></tr></table></figure><p>报错的信息表达的意思是：MySQL 对一条记录占用的最大存储空间是有限制的，除 BLOB 或 TEXT 类型的列之外，其他所有的列 (不包含隐藏列和记录头信息) 占用的字节长度加起来不能超过 65535 个字节。</p><p>这个 65535 个字节除了列本身的数据之外，还包括一些其它的数据，以 Compact 行格式为例，比如我们为了存储一个 VARCHAR(M) 类型的列，除了真实数据占有空间以外，还需要记录的额外信息。</p><p>如果该 VARCHAR 类型的列没有 NOT NULL 属性，那最多只能存储 65532 个字节的数据， 因为变长字段的长度占用 2 个字节，NULL 值标识需要占用 1 个字节。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> varchar_size_demo(c <span class="type">VARCHAR</span>(<span class="number">65532</span>)) CHARSET <span class="operator">=</span> ascii ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure><p>如果有 NOT NULL 属性，那么就不需要 NULL 值标识，也就可以多存储一个字节，即 65533 个字节。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> varchar_size_demo(c <span class="type">VARCHAR</span>(<span class="number">65533</span>) <span class="keyword">not</span> <span class="keyword">null</span>) CHARSET <span class="operator">=</span> ascii ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure><p>通过上面的案例，我们可以知道一个页的大小一般是 16KB，也就是 16384 字节，而一个 VARCHAR(M) 类型的列就最多可以存储 65533 个字节，这样就可能出现一个页存放不了一条记录，这种现象称为行溢出。</p><p>在 Compact 和 Redundant 行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行分也存储，然后记录的真实数据处用 20 个字节存储指向这些页的地址 (当然这 20 个字节中国呢还包括这些分散在其他页面中的数据的占用的字节数)，从而可以找到剩余数据所在的页。这称为页的扩展，举例如下：</p><p><img src="http://1.117.162.142:9000/blog/%E9%A1%B5%E7%9A%84%E6%89%A9%E5%B1%95.png" alt="页的扩展"></p><p>在 MySQL 8.0 中，默认行格式就是 Dynamic，Dynamic、Compressed 行格式和 Compact 行格式挺像，只不过在处理行溢出数据时有分歧：</p><ul><li>Compressed 和 Dynamic 两种记录格式对于存放在 BLOB 中的数据采用了完全的行溢出的方式。如图，在数据页中只存放 20 个字节的指针 (溢出页的地址)，实际的数据都存放在 Off Page (溢出页) 中。</li><li>Compact 和 Redundant 两种格式会在记录的真实数据处存储一部分数据 (存放 768 个前缀字节)。</li></ul><p>Compressed 行记录格式的另一个功能就是，存储在其中的行数据会以 zlib 的算法进行压缩，因此对于 BLOB、TEXT、VARCHAR 这类大长度类型的数据能够进行非常有效的存储。</p><p><img src="http://1.117.162.142:9000/blog/Compressed%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F.png" alt="Compressed行记录格式"></p><h4 id="3-4-Redundant-行格式"><a href="#3-4-Redundant-行格式" class="headerlink" title="3.4 Redundant 行格式"></a>3.4 Redundant 行格式</h4><p>Redundant 是 MySQL 5.0 版本之前 InnoDB 的行记录存储方式，MySQL 5.0 支持 Redundant 是为了兼容之前版本的页格式。</p><p>现在我们把表 record_test_table 的行格式修改为 Redundant：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> recoord_test_table ROW_FORMAT <span class="operator">=</span> Redundant;</span><br></pre></td></tr></table></figure><p><img src="http://1.117.162.142:9000/blog/Redundant%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Redundant行格式示意图"></p><p>从上图可以看到，不同于 Compact 行记录格式，Redundant 行格式的首部是一个字段长度偏移列表，同样是按照列的顺序逆序放置的。</p><h3 id="4-区、段与碎片区"><a href="#4-区、段与碎片区" class="headerlink" title="4. 区、段与碎片区"></a>4. 区、段与碎片区</h3><h4 id="4-1-为什么要有区？"><a href="#4-1-为什么要有区？" class="headerlink" title="4.1 为什么要有区？"></a>4.1 为什么要有区？</h4><p>B+ 树的每一层中的页都会形成一个双向链表，如果是以页为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。我们介绍 B+ 树索引的使用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的随机 I&#x2F;O。再一次强调，磁盘的速度和内存的速度差了好几个数量级，随机 I&#x2F;O 是非常慢的，所以我们应该尽量让链表中相邻的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的顺序 I&#x2F;O。</p><p>引入区的概念，一个区就是在物理位置上连续的 64 个页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB&#x3D;1MB。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费 (数据不足以填充满整个区)，但是从性能角度看，可以消除很多的随机 I&#x2F;O，功大于过。</p><h4 id="4-2-为什么要有段？"><a href="#4-2-为什么要有段？" class="headerlink" title="4.2 为什么要有段？"></a>4.2 为什么要有段？</h4><p>对于范围查询，其实是对 B+ 树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以 InnoDB 对 B+ 树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点由自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段 (segment)，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成两个段，一个叶子节点段，一个非叶子节点段。</p><p>除了索引的叶子节点段和非叶子节点段之外，InnoDB 中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段友数据段、索引段、回滚段。数据段即为 B+ 树的叶子节点，索引段即为 B+ 树的非叶子节点。</p><p>在 InnoDB 存储引擎中，对段的管理都是由引擎自身所完成的，DBA 不能也没有必要对其进行控制。这从一定程度上简化了 DBA 对于段的管理。</p><p>段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p><h4 id="4-3-为什么要有碎片区？"><a href="#4-3-为什么要有碎片区？" class="headerlink" title="4.3 为什么要有碎片区？"></a>4.3 为什么要有碎片区？</h4><p>默认情况下，一个使用 InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成两个段，而段是以区为单位申请存储空间的，一个区默认占用 1M (64 * 16KB&#x3D; 1024KB) 存储空间，所以默认情况下一个只存了几条记录的小表也需要 2M 的存储空间么？以后每次添加一个索引都要多申请 2M 的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常纯粹的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。</p><p>为了考虑以完整的区为单位分配给某个段对于数据量小的表太浪费存储空间的情况，InnoDB 提出了一个碎片 (fragment) 区的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段 A，有些页用于段 B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。</p><p>所以此后为某个段分配存储空间的策略是这样的：</p><ul><li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li><li>当某个段已经占用了 32 个碎片区页面之后，就会申请以完整的区为单位来分配存储空间。</li></ul><p>所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。</p><h4 id="4-4-区的分类"><a href="#4-4-区的分类" class="headerlink" title="4.4 区的分类"></a>4.4 区的分类</h4><p>区大体上可以分为四种类型：</p><ul><li>空闲的区 (FREE)：现在还没有用到这个区中的任何页面。</li><li>有剩余空间的碎片区 (FREE_FRAG)：表示碎片区中还有可用的页面。</li><li>没有剩余空间的碎片区 (FULL_FRAG)：表示碎片区中的所有页面都被使用，没有空闲页面。</li><li>附属于某个段的区 (FSEG)：每一个索引都可以分为叶子节点段和非叶子节点段。</li></ul><p>处于 FREE、FREE_FRAG 以及 FULL_FRAG 这三种状态的区都是独立的，直属于表空间。而处于 FSEG 状态的区市附属于某个段的。</p><blockquote><p>如果把表空间比作是一个集团军，段就相当于师，区就相当于团。一般的团都是隶属于某个师的，就像是处于 FSEG 的区全都隶属于某个段，而处于 FREE、FREE_FRAG 和 FULL_FRAG 这三种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样。</p></blockquote><h3 id="5-表空间"><a href="#5-表空间" class="headerlink" title="5. 表空间"></a>5. 表空间</h3><p>表空间可以看做是 InnoDB 存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。</p><p>表空间是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。表空间数据库有一个或多个表空间组成，表空间从管理上可以划分为系统表空间 (System tablespace)、独立表空间 (File-per-table tablespace)、撤销表空间 (Undo Tablespace) 和临时表空间 (Temporary Tablespace) 等。</p><h4 id="5-1-独立表空间"><a href="#5-1-独立表空间" class="headerlink" title="5.1 独立表空间"></a>5.1 独立表空间</h4><p>独立表空间，即每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间 (即：单表) 可以在不同的数据库之间进行迁移。</p><p>空间可以回收 (DROP TABLE 操作可以自动回收表空间；其他情况，表空间不能自己回收)。如果对于统计分析或事日志表，删除大量数据后可以通过：<code>alter table TableName engine=innodb</code>；回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。</p><p><strong>独立表空间结构</strong></p><p>独立表空间由段、区、页组成。</p><p><strong>真实表空间对应的文件大小</strong></p><p>我们到数据目录里看，会发现一个新建的表对应的 <code>.ibd</code> 文件只占用了 96k，才 6 个页面大小 (MySQL 5.7中)，这是因为一开始表空间占用的空间很小，因为表里边都没有数据。不过别忘了这些 .ibd 文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。</p><p><strong>查看 InnoDB 的表空间类型：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_file_per_table&#x27;</span>;</span><br></pre></td></tr></table></figure><p>你能看到 innodb_file_per_table&#x3D;ON，这就意味着每张表都会单独保存为一个 .ibd 文件。</p><h4 id="5-2-系统表空间"><a href="#5-2-系统表空间" class="headerlink" title="5.2 系统表空间"></a>5.2 系统表空间</h4><p>系统表空间的结构和独立表空间基本类似，只不过由于整个 MySQL 进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。</p><p><strong>InnoDB 数据字典</strong></p><p>每当我们向一个表中插入一条记录的时候，MySQL 检验过程如下：</p><p>先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的 B+ 树中。所以说，MySQL 除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说：</p><ul><li>某个表属于哪个表空间，表里边有多少列</li><li>表对应的每一个列的类型是什么</li><li>该表有多少索引，每个索引对应哪几个字段，该索引对应的跟页面在哪个表空间的哪个页面</li><li>该表有哪些外键，外键对应哪个表的哪些列</li><li>某个表空间对应文件系统上文件路径是什么</li><li>……</li></ul><p>上述这些数据并不是我们使用 INSERT 语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为元数据。InnoDB存储引擎特意定义了一些列的内部系统表 (internal system table) 来记录这些元数据：</p><table><thead><tr><th>表名</th><th>描述</th></tr></thead><tbody><tr><td>SYS_TABLES</td><td>整个 InnoDB 存储引擎中所有的表的信息</td></tr><tr><td>SYS_COLUMNS</td><td>整个 InnoDB 存储引擎中所有的列的信息</td></tr><tr><td>SYS_INDEXES</td><td>整个 InnoDB 存储引擎中所有的索引的信息</td></tr><tr><td>SYS_FIELDS</td><td>整个 InnoDB 存储引擎中所有的索引对应的列的信息</td></tr><tr><td>SYS_FOREIGN</td><td>整个 InnoDB 存储引擎中所有的外键的信息</td></tr><tr><td>SYS_FOREIGN_COLS</td><td>整个 InnoDb 存储引擎中所有的外键对应的信息</td></tr><tr><td>SYS_TABLESPACES</td><td>整个 InnoDB 存储引擎中所有的表空间信息</td></tr><tr><td>SYS_DATAFILES</td><td>整个 InnoDB 存储引擎中所有的表空间对应文件系统的文件路径信息</td></tr><tr><td>SYS_VIPTUAL</td><td>整个 InnoDB 存储引擎中所有的虚拟生成列的信息</td></tr></tbody></table><p>这些系统表也被称为数据字典，它们都是以 B+ 树的形式保存在系统表空间的某些页面中，其中SYS_TABLES、SYS_COLUMNS、SYS_INDEXES、SYS_FIELDS 这四个表尤其重要，称之为基本系统表 (basic system tables)，我们先看看这四个表的结构：</p><p><strong>SYS_TABLES 表结构</strong></p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>NAME</td><td>表的名称。主键</td></tr><tr><td>ID</td><td>InnoDB 存储引擎中每个表都有一个唯一的ID。(二级索引)</td></tr><tr><td>N_COLS</td><td>该表拥有列的个数</td></tr><tr><td>TYPE</td><td>表的类型，记录了一些文件格式、行格式、压缩等信息</td></tr><tr><td>MIX_ID</td><td>已过时，忽略</td></tr><tr><td>MIX_LEN</td><td>表的一些额外的属性</td></tr><tr><td>CLUSTER_ID</td><td>未使用，忽略</td></tr><tr><td>SPACE</td><td>该表所属表空间的ID</td></tr></tbody></table><p><strong>SYSCOLUMNS 表结构</strong></p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>TABLE_ID</td><td>该列所属表对应的 ID。</td></tr><tr><td>POS</td><td>该列在表中是第几列</td></tr><tr><td>NAME</td><td>该列的名称</td></tr><tr><td>MTYPE</td><td>main data type，主数据类型，就是那堆 INT、CHAR、VARCHAR、FLOAT、DOUBLE 之类的东东</td></tr><tr><td>PRTYPE</td><td>precise type，精确数据类型，就是修饰主数据类型的那堆东东，比如是否允许 NULL 值，是否允许负数啥的</td></tr><tr><td>LEN</td><td>该列最多占用存储空间的字节数</td></tr><tr><td>PREC</td><td>该列的精度，不过这列貌似都没有使用，默认值都是 0</td></tr></tbody></table><p><strong>SYS_INDEXES 表结构</strong></p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>TABLE_ID</td><td>该索引所属表对应的ID</td></tr><tr><td>ID</td><td>InnoDB 存储引擎中每个索引都有一个唯一的 ID</td></tr><tr><td>NAME</td><td>该索引的名称</td></tr><tr><td>M_FIELDS</td><td>该索引包含列的个数</td></tr><tr><td>TYPE</td><td>该索引的类型，比如聚簇索引、唯一索引、更改缓冲区的索引、全文索引、普通的二级索引等等各种类型</td></tr><tr><td>SPACE</td><td>该索引根页面所在的表空间</td></tr><tr><td>PAGE_NO</td><td>该索引根页面所在的页面号</td></tr><tr><td>MERGE_THRESHOLD</td><td>如果页面中的记录被删除到某个比列，就把该页面和相邻页面合并，这个值就是这个比例</td></tr></tbody></table><p><strong>SYS_FIELDS 表结构</strong></p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>INDEX_ID</td><td>该索引列所属的索引的ID</td></tr><tr><td>POS</td><td>该索引列在某个索引中是第几列</td></tr><tr><td>COL_NAME</td><td>该索引列的名称</td></tr></tbody></table><p>注意：用户是不能直接访问 InnoDB 的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。不过考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库 information_schema 中提供了一些以 innodb_sys 开头的表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use information_schema;</span><br><span class="line"><span class="keyword">show</span> tables <span class="keyword">like</span> <span class="string">&#x27;innodb_sys%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在 information_schema 数据库中的这些以 INNODB_SYS 开头的表并不是真正的内部系统表 (内部系统表就是我们上边以 SYS 开头的那些表)，而是在存储引擎启动时读取这些以 SYS 开头的系统表，然后填充到这些以 INNODB_SYS 开头的表中。以 INNODB_SYS 开头的表和以 SYS 开头的表中的字段并不完全一样，但供参考已经足矣。</p><h3 id="附录：数据页加载的三种方式"><a href="#附录：数据页加载的三种方式" class="headerlink" title="附录：数据页加载的三种方式"></a>附录：数据页加载的三种方式</h3><p>InnoDB 从磁盘中读取数据的最小单位是数据页。而你想得到的 id &#x3D; xxx 的数据，就是这个数据页众多行中的一行。对于 MySQL 存放的数据，逻辑概念上我们称之为表，在磁盘等物理层面而言是按数据页形式进行存放的，当其加载到 MySQL 中我们称之为缓存页。</p><p>如果缓冲池中没有该页数据，那么缓冲池有以下三种读取数据的方式，每种方式的读取效率都是不同的：</p><h4 id="内存读取"><a href="#内存读取" class="headerlink" title="内存读取"></a>内存读取</h4><p>如果该数据存在于内存中，基本上执行时间在 1ms 左右，效率还是很高的。</p><p><img src="http://1.117.162.142:9000/blog/%E5%86%85%E5%AD%98%E8%AF%BB%E5%8F%96.png" alt="内存读取"></p><h4 id="随机读取"><a href="#随机读取" class="headerlink" title="随机读取"></a>随机读取</h4><p>如果数据没有在内存中，就需要在磁盘上对该页进行查找，整体时间预估在 10ms 左右，这 10ms 中有 6ms 是磁盘的实际繁忙时间 (包括了寻到和半圈旋转时间)，有 3ms 是对可能发生的排队时间的估计值，另外还有 1ms 的传输时间，将页从磁盘服务缓冲区传输到数据缓冲区中。这 10ms 看起来很快，但实际上对于数据库来说消耗的时间已经非常长了，因为这还只是一个页的读取时间。</p><p><img src="http://1.117.162.142:9000/blog/%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%8F%96.png" alt="随机读取"></p><h4 id="顺序读取"><a href="#顺序读取" class="headerlink" title="顺序读取"></a>顺序读取</h4><p>顺序读取其实是一种批量读取的方式，因为我们请求的数据在磁盘上往往都是相邻存储的，顺序读取可以帮我们批量读取页面，这样的话，一次性加载到缓冲池中就不需要再对其他页面单独进行磁盘 I&#x2F;O 操作了。如果一个磁盘的吞吐量是 40MB&#x2F;S，那么对于一个 16KB 大小的页来说，一次可以顺序读取 2560 (40MB&#x2F;16KB) 个页，相当于一个页的读取时间为 0.4ms。采用批量读取的方式，即使是从磁盘上进行读取，效率也比从内存中只单独读取一个页的效率要高。</p><h2 id="六、索引的创建与设计原则"><a href="#六、索引的创建与设计原则" class="headerlink" title="六、索引的创建与设计原则"></a>六、索引的创建与设计原则</h2><h3 id="1-索引的生命与使用"><a href="#1-索引的生命与使用" class="headerlink" title="1. 索引的生命与使用"></a>1. 索引的生命与使用</h3><h4 id="1-1-索引的分类"><a href="#1-1-索引的分类" class="headerlink" title="1.1 索引的分类"></a>1.1 索引的分类</h4><p>MySQL 的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p><ul><li>从功能逻辑上说，索引主要有四种，分别是普通索引、唯一索引、主键索引、全文索引。</li><li>按照物理实现方式，索引可以分为两种：聚簇索引和非聚簇索引。</li><li>按照作用字段个数进行划分，分成单列索引和联合索引。</li></ul><p><strong>普通索引</strong>：</p><p>在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在任何数据类型中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索引以后，可以通过索引进行查询。例如，在表 student 的字段 name 上建立一个普通索引，查询记录时就可以根据该索引进行查询。</p><p><strong>唯一性索引</strong>：</p><p>使用 UNIQUE 可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里可以有多个唯一索引。</p><p>例如，在表 student 的字段 email 中创建唯一性索引，那么字段 email 的值就必须是唯一的。通过唯一性索引，可以更快速地确定某条记录。</p><p><strong>主键索引</strong></p><p>主键索引就是一种特殊的 唯一性索引，在唯一索引的基础上增加了不为空的约束，也就是 NOT NULL + UNIQUE，一张表里最多只有一个主键索引。这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</p><p><strong>单列索引</strong></p><p>在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。</p><p><strong>多列 (组合、联合) 索引</strong></p><p>多列索引是在表的多个字段组合上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段 id、name 和 gender 上建立一个多列索引 idx_id_name_gender，只有在查询条件中使用了字段 id 时该索引才会被使用。使用组合索引时遵循最左前缀集合。</p><p><strong>全文索引</strong></p><p>全文索引 (也称全文检索) 是目前搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</p><p>使用参数 FULL TEXT 可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引只能创建在 CHAR、VARCHAR 或 TEXT 类型及其系列类型的字段上，<strong>查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度</strong>。例如，表 student 的字段 information 是 TEXT 类型，该字段包含了很多文字信息。在字段 information 上建立全文索引后，可以提高查询字段 information 的速度。</p><p>全文索引典型的两种类型：自然语言的全文索引和布尔全文索引。</p><ul><li>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。<strong>在整个索引中出现次数越少的词语，匹配时的相关度就越高</strong>。相反，非常常见的单词将不会被搜索，如果一个词语的在超过 50% 的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。</li></ul><p>MySQL 数据库从 3.23.23 版本开始支持全文索引，但 MySQL 5.6.4 以前只有 MyISAM 支持，5.6.4 版本以后 InnoDB 才支持，但是官方版本不支持中文分词，需要第三方分词插件。在 5.7.6 版本，MySQL 内置了 ngram 全文解析器，用来支持亚洲语种的分词。测试或使用全文索引时，要先看一下自己的 MySQL 版本、存储引擎和数据类型是否支持全文索引。</p><p>随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被 solr、ElasticSearch 等专门的搜索引擎所替代。</p><p><strong>空间索引</strong></p><p>使用参数 SPATIAL 可以设置索引为空间索引。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL 中的空间数据类型包括 GEOMETRY、POINT、LINESTRING 和 POLYGON 等。目前只有 MyISAM 存储引擎支持空间检索，而且索引的字段不能为空值。对于初学者来说，这类索引很少会用到。</p><p><strong>小结</strong>：</p><ul><li>InnoDB：支持 B-Tree、Full-text 等索引，不支持 Hash 索引；</li><li>MyISAM：支持 B-Tree、Full-text 等索引，不支持 Hash 索引；</li><li>Memory：支持 B-Tree、Hash 等索引，不支持 Full-text 索引；</li><li>NDB：支持 Hash 索引，不支持 B-Tree、Full-text 等索引；</li><li>Archive：不支持 B-Tree、Hash、Full-text 等索引。</li></ul><h4 id="1-2-创建索引"><a href="#1-2-创建索引" class="headerlink" title="1.2 创建索引"></a>1.2 创建索引</h4><p>MySQL 支持多种 方法在单个或多个列上创建索引：在创建表的定义语句 CREATE TABLE 中指定索引列，使用 ALTER TABLE 语句在存在的表上创建索引，或者使用 CREATE INDEX 语句在已存在的表上添加索引。</p><p><strong>创建表的时候创建索引</strong></p><p>使用 CREATE TABLE 创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外键约束或者唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">dept_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">emp_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  emp_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">  dept_id <span class="type">INT</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> emp_dept_id_fk <span class="keyword">FOREIGN</span> KEY(dept_id) <span class="keyword">REFERENCES</span> dept(dept_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>但是，如果现实创建表时创建索引的话，基本语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name [col_name data_type]</span><br><span class="line">[<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY] [index_name] (col_name [length]) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><ul><li>UNIQUE、FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引；</li><li>INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引；</li><li>index_name 指定索引的名称，为可选参数，如果不指定，那么 MySQL 默认 col_name 为索引名；</li><li>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</li><li>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</li><li>ASC 或 DESC 指定生序或者降序的索引值存储。</li></ul><p><strong>创建普通索引</strong></p><p>在 book 表中的 year_publication 字段上建立普通索引，SQL 语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book(</span><br><span class="line">book_id <span class="type">INT</span>,</span><br><span class="line">  book_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  authors <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  info <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  comment <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  year_publication <span class="keyword">YEAR</span>,</span><br><span class="line">  INDEX(year_publication)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>通过命令查看索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>使用 EXPLAIN 语句查看索引是否正在使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> year_publication <span class="operator">=</span> <span class="string">&#x27;1997&#x27;</span>;</span><br></pre></td></tr></table></figure><p>EXPLAIN 语句输出结果：</p><ul><li>possible_keys 行给出了 MySQL 在搜索数据记录时可选用的各个索引</li><li>key 行是 MySQL 实际选用的索引。</li></ul><p>可以看到，possible_keys 和 key 的值都为 year_publication，查询时使用了索引。</p><p><strong>创建唯一索引</strong></p><p>创建唯一索引的目的也是减少查询索引列操作的执行时间，尤其是对比较庞大的数据表。它与前面的普通索引类似，不同的是，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX idx_id(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>该语句执行完毕之后，使用 <code>SHOW CREATE TABLE</code> 查看表结构。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure><p>其中各个主要参数的含义为：</p><ul><li>Table 表示创建索引的表</li><li>Non_unique 表示索引非唯一，1 代表非唯一索引，0 代表唯一索引。</li><li>Key_name 表示索引的名字。</li><li>Seq_in_index 表示该字段在索引中的位置，单列索引该值为 1，组合索引为每个字段在索引定义中的顺序。</li><li>Column_name 表示定义索引的列字段。</li><li>Sub_part 表示索引的长度。</li><li>Null 表示该字段是否能为空值。</li><li>Index_type 表示索引类型</li></ul><p>由结果可以看到，id 字段上已经成功建立了一个名为 idx_id 的唯一索引。</p><p><strong>主键索引</strong></p><p>设定为主键后数据库会自动建立索引，innodb 为聚簇索引，语法：</p><ul><li><p>随表一起建索引：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED AUTO_INCREMENT,</span><br><span class="line">  student_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  student_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>删除主键索引</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure></li><li><p>修改主键索引：必须先删除掉 (drop) 原索引，再新建 (add) 索引</p></li></ul><p><strong>创建单列索引</strong></p><p>单列索引是在数据表中的某一个字段上创建的索引，一个表中可以创建多个单列索引，前面例子中创建的索引都为单列索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  INDEX aingle_idx_name(name(<span class="number">20</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>该语句执行完毕之后，使用 <code>SHOW CREATE TABLE</code> 查看表结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure><p>由结果可以看到，id 字段上已经成功建立了一个名为 single_idx_name 的单列索引。索引长度为 20。</p><p><strong>创建组合索引</strong></p><p>组合索引是在多个字段上创建一个索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(</span><br><span class="line">id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  INDEX mul_idx(id, name, age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>该语句执行完毕之后，使用 SHOW INDEX 查看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure><p>由结果可以看到，id、name 和 age 字段上已经成功建立了一个名为 mul_idx 的组合索引。</p><p>组合索引可起几个索引的作用，但是使用时并不是随便查询哪个字段都可以使用索引，而是遵从“最左前缀”。例如，索引可以搜索的字段组合为：(id, name, age)、(id, name) 或者 id。而 age 或者 (name, age) 组合不能使用索引查询。</p><p>在 test 表中，查询 id 和 name 字段，使用 EXPLAIN 语句查看索引的使用情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> name <span class="operator">=</span> <span class="string">&#x27;zhangsan&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以看到，查询 id 和 name 字段时，使用了名称为 mul_idx 的索引，如果查询 (name, age) 组合或者单独查询 name 和 age 字段，会发现结果中 possible_keys 和 key 值为 NULL，并没有使用在 test 表中创建的索引进行查询。</p><p><strong>创建全文索引</strong></p><p>FULLTEXT 全文索引可以用于全文搜索，并且只为 CHAR、VARCHAR 和 TEXT 列创建索引。索引总是对整个列进行，不支持局部 (前缀) 索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  age <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  FULLTEXT INDEX futxt_idx_info(info)</span><br><span class="line">)ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure><blockquote><p>在 MySQL 5.7 及之后版本中可以不指定最后的 ENGINE 了，因为在此版本中 InnoDB 支持全文索引。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure><p>由结果可以看到，info 字段上已经成功建立了一个名为 futxt_idx_info 的 FULLTEXT 索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles(</span><br><span class="line">id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  title <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  body TEXT,</span><br><span class="line">  FULLTEXT index(title, body)</span><br><span class="line">)ENGINE <span class="operator">=</span> INNODB;</span><br></pre></td></tr></table></figure><p>创建了一个给 title 和 body 字段添加全文索引的表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> papers(</span><br><span class="line">id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  title <span class="type">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  content text,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  FULLTEXT KEY title (title, content)</span><br><span class="line">)ENGINE<span class="operator">=</span>MyISAM <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>不同于 like 方式的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> content <span class="keyword">LIKE</span> <span class="string">&#x27;%查询字符串%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>全文索引用 match + against 方式查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, content) AGAINST (<span class="string">&#x27;查询字符串&#x27;</span>);</span><br></pre></td></tr></table></figure><p>明显的提高查询效率。</p><blockquote><p>注意点</p><ul><li>使用全文索引前，搞清楚版本支持情况；</li><li>全文索引比 like + % 快 N 倍，但是可能存在精度问题；</li><li>如果需要全文索引的是大量数据，建议先添加数据，再创建索引。</li></ul></blockquote><p><strong>创建空间索引</strong></p><p>空间索引创建中，要求空间类型的字段必须为非空。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(</span><br><span class="line">geo GEOMETRY <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  SPATIAL INDEX spa_idx_geo(geo)</span><br><span class="line">)ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure><p>该语句执行完毕之后，使用 SHOW CREATE TABLE 查看表结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure><p>可以看到，test 表的 geo 字段上创建了名为 spa_idx_geo 的空间索引。注意创建时指定空间类型字段值的非空约束，并且表的存储引擎为MyISAM。</p><p><strong>使用 ALTER TABLE 语句创建索引</strong></p><p>ALTER TABLE 语句创建索引的基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY]</span><br><span class="line">[index_name] (col_name[length], ...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><p>与创建表时创建索引的语法不同的是，在这里使用了 ALTER TABLE 和 ADD 关键字，ADD 表示向表中添加索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">ADD</span> INDEX idx_bkname(book_name(<span class="number">30</span>));</span><br></pre></td></tr></table></figure><p><strong>使用 CREATE INDEX 创建索引</strong></p><p>CREATE INDEX 语句可以在意境存在的表上添加索引，在 MySQL 中，CREATE INDEX 被映射到一个 ALTER TABLE 语句上，基本语法结构为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span>SPATIAL] INDEX index_name </span><br><span class="line"><span class="keyword">ON</span> table_name (col_name[length], ...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_cmt <span class="keyword">ON</span> book(COMMENT);</span><br></pre></td></tr></table></figure><h4 id="1-3-删除索引"><a href="#1-3-删除索引" class="headerlink" title="1.3 删除索引"></a>1.3 删除索引</h4><p>MySQL 中删除索引使用 ALTER TABLE 或者 DROP INDEX 语句，两者可实现相同的功能，DROP INDEX 语句在内部被映射到一个 ALTER TABLE 语句中。</p><p><strong>使用 ALTER TABLE 删除索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure><blockquote><p>提示</p><p>添加 AUTO_INCREMENT 约束字段的唯一索引不能被删除。</p></blockquote><p><strong>使用 DROP INDEX 语句删除索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure><blockquote><p>提示</p><p>删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。</p></blockquote><h3 id="2-MySQL-8-0-索引新特性"><a href="#2-MySQL-8-0-索引新特性" class="headerlink" title="2. MySQL 8.0 索引新特性"></a>2. MySQL 8.0 索引新特性</h3><h4 id="2-1-支持降序索引"><a href="#2-1-支持降序索引" class="headerlink" title="2.1 支持降序索引"></a>2.1 支持降序索引</h4><p>降序索引以降序存储键值。虽然在语法上，从 MySQL 4 版本开始就已经支持降序索引的语法了，但实际上 DESC 定义是被忽略的，直到MySQL 8.x 版本才开始真正支持降序索引 (仅限于 InnoDB 存储引擎)。</p><p>MySQL 在 8.0 版本之前创建的仍然是生序索引，使用时进行反向扫描，这大大降低了数据库的效率。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。</p><p>分别在 MySQL 5.7 版本和 MySQL 8.0 版本中创建数据表 ts1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ts1(a <span class="type">int</span>, b <span class="type">int</span>, index idx_a_b(a, b <span class="keyword">desc</span>));</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> ts1;</span><br></pre></td></tr></table></figure><p>从结果中可以看出，MySQL 5.7 版本中，索引仍然是默认的生序。而 MySQL 8.0 版本中，索引可以降序。分别插入 800 条随机数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ts_insert()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">WHILE i <span class="operator">&lt;</span> <span class="number">800</span></span><br><span class="line">DO</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ts1 <span class="keyword">select</span> rand() <span class="operator">*</span> <span class="number">80000</span>, rand() <span class="operator">*</span> <span class="number">80000</span>;</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line"><span class="keyword">CALL</span> ts_insert();</span><br></pre></td></tr></table></figure><p>在 MySQL 5.7 版本中查看数据表 ts1 的执行计划，结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ts1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a, b <span class="keyword">DESC</span> LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>从结果可以看出，执行计划中扫描数为 799，而且使用了 Using filesort。</p><blockquote><p>提示</p><p>Using filesort 是 MySQL 中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员可以通过优化索引尽量避免出现 Using filesort，从而提高数据库执行速度。</p></blockquote><p>在 MySQL 8.0 版本中查看数据表 ts1 的执行计划。从结果可以看出，执行计划中扫描数为 5，而且没有使用 Using filesort。</p><blockquote><p>注意</p><p>降序索引支队查询中特定的排序顺序有效，如果使用不当，反而查询效率更低。例如，上述查询排序条件改为order by a desc, b desc，MySQL 5.7 的执行计划要明显好于 MySQL 8.0。</p></blockquote><p>将排序条件修改为 order by a desc, b desc 后，下面来对比不同版本中执行计划的效果。</p><p>在 MySQL 5.7 版本中查看数据表 ts1 的执行计划，结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ts1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a DEDC, b <span class="keyword">DESC</span> LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>在 MySQL 8.0 版本中查看数据表 ts1 的执行计划。</p><p>从结果可以看出，修改后 MySQL 5.7 的执行计划要明显好于 MySQL 8.0。</p><h4 id="2-2-隐藏索引"><a href="#2-2-隐藏索引" class="headerlink" title="2.2 隐藏索引"></a>2.2 隐藏索引</h4><p>在 MySQL 5.7 版本之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，有智能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。</p><p>从 MySQL 8.x 开始支持隐藏索引 (invisible indexes)，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引 (即使使用 force index (强制使用索引)，优化器也不会使用该索引)，确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。这种通过现将索引设置为隐藏索引，再删除索引的方式就是软删除。</p><p>同时，如果你想验证某个索引删除之后的查询性能影响，就可以暂时先隐藏该索引。</p><blockquote><p>注意：</p><p>主键不能被设置为隐藏索引。当表中没有显示主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引。</p></blockquote><p>索引默认是可见的，在使用 CREATE TABLE，CREATE INDEX 或 ALTER TABLE 等语句时可以通过 VISIBLE 或者 INVISIBLE 关键词设置索引的可见性。</p><p><strong>创建表时直接创建</strong></p><p>在 MySQL 中创建隐藏索引通过 SQL 语句 INVISIBLE 来实现，其语法形式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename(</span><br><span class="line">propname1 type1[CONSTRAINT1],</span><br><span class="line">propname2 type2[CONSTRAINT2],</span><br><span class="line">......</span><br><span class="line">propname typen,</span><br><span class="line">  INDEX [indexname](propname1 [(length)] INVISIBLE)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上述语句比普通索引多了一个关键字 INVISIBLE，用来标记索引为不可见索引。</p><p><strong>在已经存在的表上创建</strong></p><p>可以为已经存在的表设置隐藏索引，其语法形式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX indexname</span><br><span class="line"><span class="keyword">ON</span> tablename(propname[(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure><p><strong>通过 ALTER TABLE 语句创建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename</span><br><span class="line"><span class="keyword">ADD</span> INDEX indexname (propname [(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure><p><strong>切换索引可见状态</strong></p><p>已存在的索引可通过如下语句切换可见状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> INDEX index_name INVISIBLE; # 切换成隐藏索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> INDEX index_name VISIBLE; # 切换成非隐藏索引</span><br></pre></td></tr></table></figure><p>如果将 index_cname 索引切换成可见状态，通过 explain 查看执行计划，发现优化器选择了 index_cname 索引。</p><blockquote><p>注意</p><p>当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p></blockquote><p>通过设置隐藏索引的可见性可以查看索引对调优的帮助。</p><p><strong>使隐藏索引对查询优化器可见</strong></p><p>在 MySQL 8.x 版本中，为索引提供了一种新的方式，可以通过查询优化器的一个开关 (use_invisible_indexes) 来打开某个设置，使隐藏索引对查询优化器可见。如果 use_invisible_indexes 设置为 off (默认)，优化器会忽略隐藏索引。如果设置为 on，即使隐藏索引不可见，优化器在生成执行计划时仍然会考虑使用隐藏索引。</p><ul><li><p>在 MySQL 命令执行如下命令查看查询优化器的开关设置</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@optimizer</span>_switch \G</span><br></pre></td></tr></table></figure><p>  在输出的结果信息中找到如下属性配置。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_invisible_indexes<span class="operator">=</span>off</span><br></pre></td></tr></table></figure><p>  此属性配置值为 off，说明隐藏索引默认为对查询优化器不可见。</p></li><li><p>使隐藏索引对查询优化器可见，需要在 MySQL 命令执行如下命令：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION optimizer_switch<span class="operator">=</span>&quot;use_invisible_indexes=on&quot;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-索引的设计原则"><a href="#3-索引的设计原则" class="headerlink" title="3. 索引的设计原则"></a>3. 索引的设计原则</h3><p>为了使索引的使用效率更高，再创建索引时，必须考虑在那些字段上创建索引和创建什么类型的索引。<strong>索引设计不合理或缺少索引都会对数据库和应用程序的性能造成障碍</strong>。高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑相应准则。</p><h4 id="3-1-数据准备"><a href="#3-1-数据准备" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE indextest;</span><br><span class="line">USE indextest;</span><br><span class="line">#创建学生表和课程表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_info(</span><br><span class="line">id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  student_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  course_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  class_id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  create_time DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> course(</span><br><span class="line">id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  course_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  course_name <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 函数<span class="number">1</span>:创建随机产生字符串函数</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>)# 该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span></span><br><span class="line"><span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line"><span class="keyword">SET</span> return_str <span class="operator">=</span> CONCAT(return_str, <span class="built_in">SUBSTRING</span>(chars_str, <span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> RAND() <span class="operator">*</span> <span class="number">52</span>), <span class="number">1</span>));</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建随机数函数</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num(from_num <span class="type">INT</span>, to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span> RAND() <span class="operator">*</span> (to_num <span class="operator">-</span> from_num <span class="operator">+</span> <span class="number">1</span>));</span><br><span class="line"><span class="keyword">RETURN</span> i;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p> 创建函数，假如报错：</p><p><code>This function has none of DETERMINISTIC......</code></p><p>由于开启过慢查询日志 bin-log，我们就必须为我们的 function 指定一个参数。<br>主从复制，主机会将写操作记录在 bin-log 日志中。从机读取 bin-log 日志，执行语句来同步数据。如果使用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，mysql 不开启创建函数设置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看 mysql 是否允许创建函数</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_bin_trust_function_creators&#x27;</span>;</span><br><span class="line"># 命令开启：允许创建函数设置：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>;# 不加 <span class="keyword">global</span> 只是当前窗口有效</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 创建插入模拟数据的存储过程</span><br><span class="line"># 存储过程<span class="number">1</span>: 创建插入课程表存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="keyword">insert</span> course(max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>; # 设置手动提交事务</span><br><span class="line">REPEAT# 循环</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;# 赋值</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> course (course_id, course_name) <span class="keyword">VALUES</span> (rand_num(<span class="number">10000</span>, <span class="number">10100</span>), rand_string(<span class="number">6</span>));</span><br><span class="line">UNTIL i <span class="operator">=</span> max_num</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br><span class="line"><span class="keyword">COMMIT</span>;# 提交事物</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 存储过程<span class="number">2</span>:创建插入学生信息表存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_stu(max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">REPEAT</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student_info (course_id, class_id, student_id, NAME) <span class="keyword">VALUES</span></span><br><span class="line">(rand_num(<span class="number">10000</span>, <span class="number">10100</span>), rand_num(<span class="number">10000</span>,<span class="number">10200</span>), rand_num(<span class="number">1</span>, <span class="number">200000</span>), rand_string(<span class="number">6</span>));</span><br><span class="line">UNTIL i <span class="operator">=</span> max_num</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 调用存储过程</span><br><span class="line"><span class="keyword">CALL</span> insert_course(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">CALL</span> insert_stu(<span class="number">1000000</span>);</span><br></pre></td></tr></table></figure><h4 id="3-2-哪些情况适合创建索引"><a href="#3-2-哪些情况适合创建索引" class="headerlink" title="3.2 哪些情况适合创建索引"></a>3.2 哪些情况适合创建索引</h4><ul><li><p>字段的数值有唯一性的限制</p><p>  索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中，如果某个字段是唯一性的，就可以直接创建唯一性索引，或者主键索引。这样可以更快速地通过该索引来确定某条记录。</p><p>  例如，学生表中学好是具有唯一性的字段，为该字段建立唯一性索引可以很快确定某个学生的信息，如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p><blockquote><p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。</p><p>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p></blockquote></li><li><p>频繁作为 WHERE 查询条件的字段</p><p>  某个字段在 SELECT 语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p><p>  比如 student_info 数据表 (含 100 万条数据)，假设我们想要查询 student_id&#x3D;123110 的用户信息。</p><p>  如果我们没有对 student_id 字段创建索引，进行如下查询：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> course_id, class_id, name, create_time, student_id</span><br><span class="line"><span class="keyword">FROM</span> student_info</span><br><span class="line"><span class="keyword">WHERE</span> student_id <span class="operator">=</span> <span class="number">123110</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 耗时：<span class="number">251</span>ms</span><br></pre></td></tr></table></figure><p>  为 student_id 添加索引</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_sid(student_id);</span><br><span class="line"># 耗时<span class="number">1</span>ms。</span><br></pre></td></tr></table></figure></li><li><p>经常 GROUP BY 和 ORDER BY 的列</p><p>  索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要对分组或者排序的字段进行索引。如果待排序的列有多个，那么可以在这些列上建立组合索引。</p><p>  比如，按照 student_id 对学生选修的课程进行分组，现是不同的 student_id 和课程数量，显式 100 个即可。如果我们不对 student_id 创建索引，执行下面的 SQL 语句：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num <span class="keyword">FROM</span> student_info <span class="keyword">GROUP</span> <span class="keyword">BY</span> student_id LIMIT <span class="number">100</span>;</span><br><span class="line">耗时<span class="number">1</span>ms。</span><br></pre></td></tr></table></figure><p>  删除索引 (<code>DROP INDEX idx_sid ON student_info;</code>) 后运行时间: 1273ms。</p><p>  同样，如果是 ORDER BY，也需要对字段创建索引。</p><p>  如果同时有 GROUP BY 和 ORDER BY 的情况：比如我们按照 student_id 进行分组，同时按照创建时间降序的方式进行排序，这时我们就需要同时进行 GROUP BY 和 ORDER BY，那么是不是需要单独创建 student_id 的索引和 create_time 的索引呢？</p><p>  当我们对 student_id 和 create_time 分别创建索引，执行下面的 SQL 查询：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num <span class="keyword">FROM</span> student_info</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> student_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>  当对 student_id 和 create_time 分别创建索引时，sql 执行顺序是先执行 GROUP BY，所以只会使用 student_id 的索引。要想提高效率需要创建联合索引 <code>ALTER TABLE student_info ADD INDEX idx_sid_create_time(student_id, create_time DESC);</code>。但是如果创建索引时，student_id 和 create_time 顺序交换，执行上面的 sql，也不会用到该索引。</p></li><li><p>UPDATE、DELTET 的 WHERE 条件列</p><p>  当我们对某条数据进行 UPDATE 或者 DELETE 操作的时候，是否也需要对 WHERE 的条件列创建索引呢？</p><p>  想要把 name 为 IWIDRA 对应的 student_id 修改为 10002，当我们没有对 name 进行索引的时候，执行 SQL 语句：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> student_info <span class="keyword">SET</span> student_id <span class="operator">=</span> <span class="number">10002</span></span><br><span class="line"><span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;IWIDRA&#x27;</span>;</span><br><span class="line"># 耗时 <span class="number">356</span>ms</span><br></pre></td></tr></table></figure><p>  看一看到效率不高，但如果对 name 字段创建了索引，在执行类似 SQL </p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_name(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> student_info <span class="keyword">SET</span> student_id <span class="operator">=</span> <span class="number">10003</span></span><br><span class="line"><span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;qStmgT&#x27;</span>;</span><br><span class="line"># 耗时 <span class="number">3</span>ms</span><br></pre></td></tr></table></figure><p>  同样的，对 DELETE 语句 WHERE 条件后的字段创建索引，也会大幅提升效率。</p><p>  对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<strong>如果进行更新的时候，更新的字段时非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护</strong>。</p></li><li><p>DISTINCT 字段需要创建索引</p><p>  有时我门需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。比如，想要查询课程表中不同的 student_id 都有哪些，如果没有对 student_id 创建索引，执行 SQL 语句：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(student_id) <span class="keyword">FROM</span> student_info;</span><br><span class="line"># 耗时：<span class="number">553</span>ms</span><br></pre></td></tr></table></figure><p>  如果对 student_id 创建索引，在执行 SQL：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_sid(student_id);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(student_id) <span class="keyword">FROM</span> student_info;</span><br><span class="line"># 耗时：<span class="number">12</span>ms</span><br></pre></td></tr></table></figure><p>  能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照递增的顺序进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。</p></li><li><p>多表 JOIN 连接操作时，创建索引注意事项</p><p>  首先，连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套循环，数量级增长会非常快，严重影响查询的效率。</p><p>  其次，对 WHERE 条件创建索引，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</p><p>  最后，对用于连接的字段创建索引，并且该字段再多张表中的类型必须一致。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。</p><p>  执行下面的 SQL，如果只对 student_id 创建索引</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> course.course_id, name, student_info.student_id, course_name</span><br><span class="line"><span class="keyword">FROM</span> student_info <span class="keyword">JOIN</span> course</span><br><span class="line"><span class="keyword">ON</span> student_info.course_id<span class="operator">=</span>course.course_id</span><br><span class="line"><span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;qStmgT&#x27;</span>;</span><br><span class="line"># 耗时：<span class="number">186</span>ms</span><br></pre></td></tr></table></figure><p>  对 name 创建索引，再次执行耗时：3ms</p></li><li><p>使用列的类型小的创建索引</p><p>  我们这里说的类型大小指的就是该类型表示的数据范围的大小。</p><p>  我们在定义表结构的时候要显式的指定列的类型，以整数类型为列，有 TINYINT、MEDIUMINT、INT、BIGINT 等，它们占用的存储空间一次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引使用较小的类型，比如我们能使用 INT 就不要使用 BIGINT，能使用 MEDIUMINT 就不要使用 INT。这是因为：</p><ul><li>数据类型越小，在查询时进行的比较操作越快</li><li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I&#x2F;O 到来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ul><p>  这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I&#x2F;O。</p></li><li><p>使用字符串前缀创建索引</p></li><li><p>假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的 B+ 树中有那么两个问题：</p><ul><li>B+ 树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在索引中占用的存储空间越大。</li><li>如果 B+ 树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。</li></ul><p>  我们可以通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既节约空间，又减少了字符串的比较时间，还大体能解决排序的问题。</p><p>  例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间，如果只检索字段前面的若干字符，这样可以提高检索速度。</p><p>  创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> shop(address <span class="type">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> shop <span class="keyword">ADD</span> INDEX(address(<span class="number">12</span>));</span><br></pre></td></tr></table></figure><p>  问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的，截取得少了，重复内容太多，字段的散列度会降低。怎么计算不同的长度的选择性呢？</p><p>  先看一下字段在全部数据中的选择度：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">distinct</span> address) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> shop;</span><br></pre></td></tr></table></figure><p>  通过不同长度去计算，与全表的选择性对比：</p><p>  公式：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(列名, 索引长度)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br></pre></td></tr></table></figure><p>  例如：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address, <span class="number">10</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub10, <span class="comment">-- 截取前 10 个字符的选择度</span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address, <span class="number">15</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub11, <span class="comment">-- 截取前 15 个字符的选择度</span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address, <span class="number">20</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub12, <span class="comment">-- 截取前 20 个字符的选择度</span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address, <span class="number">25</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub13, <span class="comment">-- 截取前 25 个字符的选择度</span></span><br></pre></td></tr></table></figure><p>  <strong>引申另一个问题：索引列前缀对排序的影响</strong></p><p>  如果使用了索引列前缀，比方说前边只把 address 列的前 12 个字符放到了二级索引中，下边这个查询可能就有点尴尬了：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> shop</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> address</span><br><span class="line">LIMIT <span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>  因为二级索引中不包含完整的 address 列信息，所以无法对前 12 个字符相同，后边不同的记录进行排序，也就是使用索引列前缀的方式无法支持使用索引排序，只能使用文件排序。</p><p>  <strong>拓展：Alibaba《Java 开发手册》</strong></p><p>  【强制】在 varchar 字段上建立索引时，必须制定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</p><p>  说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上，可以使用  <code>count(distinct left(列名, 索引长度)) / count(*)</code> 的区分度来确定。</p></li><li><p>区分度高 (散列性高) 的列适合作为索引</p><p>  列的基数指的是某一列中不重复数据的个数，比方说某个列包含值 2，5，8，2，5，8，2，5，8，虽然有 9 条记录，但该列的基数却是 3.也就是说，在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</p><p>  可以使用公式 <code>SELECT COUNT(distinct a) / count(*) FROM t1</code> 计算区分度，越接近 1 越好，一般超过 33% 就算是比较高效的索引了。</p><p>  拓展：联合索引把区分度高 (散列性高) 的列放在前面。</p></li><li><p>使用最频繁的列放到联合索引的左侧</p><p>  这样也可以较少的建立一些索引。同时，由于“最左前缀原则”，可以增加联合索引的使用率。</p></li><li><p>在多个字段都要创建索引的情况下，联合索引由于单值索引</p></li></ul><h4 id="3-3-限制索引的数目"><a href="#3-3-限制索引的数目" class="headerlink" title="3.3 限制索引的数目"></a>3.3 限制索引的数目</h4><p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量不超过 6 个。原因：</p><ul><li>每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。</li><li>索引会影响 INSERT、DELETE、UPDATE 等语句的性能，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</li><li>优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加 MySQL 优化器生成执行计划时间，降低查询性能。</li></ul><h4 id="3-4-哪些情况不适合创建索引"><a href="#3-4-哪些情况不适合创建索引" class="headerlink" title="3.4 哪些情况不适合创建索引"></a>3.4 哪些情况不适合创建索引</h4><ol><li><p>在 WHERE 中使用不到的字段，不要设置索引</p><p> WHERE 条件 (包括 GROUP BY、ORDER BY) 里用不到的字段不需要创建索引，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的。</p></li><li><p>数据量小的表最好不要使用索引</p><p> <strong>如果表记录太少，比如少于 1000 个，那么是不需要创建索引的</strong>。表记录太少，是否创建索引对查询效率的影响并不大。甚至说，查询话费的时间可能比遍历索引的时间还短，索引可能不会产生优化效果。</p></li><li><p>有大量重复数据的列上不需要建立索引</p><p> 在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。比如在学生表的“性别”字段上只有“男”与“女”两个不同值，因此无需建立索引。如果建立索引，不但不会提高查询效率，反而会严重降低数据更新速度。</p><blockquote><p>结论：当数据重复度大，比如高于 10% 的时候，也不需要对这个字段使用索引。</p></blockquote></li><li><p>避免对经常更新的表创建过多的索引</p><p> 第一层含义：频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。</p><p> 第二层含义：避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却会降低更新表的速度。</p></li><li><p>不建议用无序的值作为索引</p><p> 例如身份证、UUID (在索引比较时需要专为 ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p></li><li><p>删除不再使用或者很少使用的索引</p><p> 表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将他们删除，从而减少索引对更新操作的影响。</p></li><li><p>不要定义冗余或重复的索引</p><p> <strong>冗余索引</strong></p><p> 有时候有意或无意的就对同一个列创建了多个索引，比如：index(a, b, c) 相当于 index(a)、index(a, b)、index(a, b, c)。index(a, b, c) 索引就可以对 a 进行快速搜索，如果在对 a 列进行创建索引，就是一个冗余索引。</p><p> <strong>重复索引</strong></p><p> 在一个表中，col1 是主键，此时给他定义一个唯一索引，还定义了一个普通索引，但是主键本身就会生成聚簇索引，索引定义的唯一索引和普通索引是重复的，这种情况要避免。</p></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>索引是一把双刃剑，可提高查询效率，但也会降低插入和更新的速度并占用磁盘空间。</p><p>选择索引的最终目的是为了使查询的速度变快，上面给出的原则是最基本的准则，但不能拘泥于上面的准则，大家要在以后的学习和工作中进行不断的实践，根据应用的实际情况进行分析和判断，选择最合适的索引方式。</p><h2 id="七、性能分析工具的使用"><a href="#七、性能分析工具的使用" class="headerlink" title="七、性能分析工具的使用"></a>七、性能分析工具的使用</h2><p>在数据库调优中，我们的目标就是响应时间更快，吞吐量更大。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。</p><h3 id="1-数据库服务器的优化步骤"><a href="#1-数据库服务器的优化步骤" class="headerlink" title="1. 数据库服务器的优化步骤"></a>1. 数据库服务器的优化步骤</h3><p>当我们遇到数据库调优问题的时候，该如何思考呢？思考的的整个流程图分成了观察 Show status 和行动 Action 两个部分。字母 S 的部分代表观察 (会使用相应的分析工具)，字母 A 代表的部分是行动 (对应分析可以采取的行动)。</p><p><img src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="数据库服务器的优化流程图"></p><p>我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的 SQL 都有哪些，查看具体的 SQL 执行计划，甚至是 SQL 执行中的每一步的成本代价，这样才能定位问题所在，找到了问题，再采取相应的行动。</p><p><strong>详细解释一下上图</strong>：</p><p>首先在 S1 部分，我们需要观察服务器的状态是否存在周期性的波动。如果存在周期性波动，有可能是周期性节点的原因，比如双十一、</p><p>促销活动等。这样的话，我们可以通过 A1 这一步骤解决，也就是加缓存，或者更改缓存失效策略。</p><p>如果缓存策略没有解决，或者不是周期性波动的原因，我们就需要进一步分析查询延迟和卡顿的原因。接下来进入 S2 这一步，我们需要开启慢查询。慢查询可以帮我们定位执行慢的 SQL 语句。我们可以通过设置 long_query_time 参数定义慢的阈值，如果 SQL 执行实际那超过了 long_query_time，则会认为是慢查询。当收集上来这些慢查询之后，我们就可以通过分析工具对慢查询日志进行分析。</p><p>在 S3 这一步骤中，我们就知道了执行慢的 SQL，这样就可以针对性地使用 EXPLAIN 查看对应 SQL 语句的执行计划，或者使用 show profile 查看 SQL 中每一个步骤的时间成本。这样我们就可以了解 SQL 查询慢是因为执行时间长，还是等待时间长。</p><p>如果是 SQL 等待时间长，我们进入 A2 步骤。在这一步骤中，我们可以调优服务器的参数，比如适当增加数据库缓冲池。如果是 SQL 执行时间长，就进入 A3 步骤，这一步中我们需要考虑是索引设计的问题？还是查询关联的数据表过多？还是因为数据表的字段设计问题导致了这一现象。然后在这些维度上进行对应的调整。</p><p>如果 A2 和 A3 都不能解决问题，我们需要考虑数据库自身的 SQL 查询性能是否已经达到了瓶颈，如果确认没有到达性能瓶颈，就需要重新检查，重复以上的步骤。如果已经到达了性能瓶颈，进入 A4 阶段，需要考虑增加服务器，采用读写分离的架构，或者考虑对数据库进行分库分表，比如垂直分库、垂直分表和水平分表等。</p><p>以上就是数据库调优的流程思路。如果我们发现执行 SQL 时存在不规则延迟或卡顿的时候，就可以采用分析工具帮我们定位有问题的 SQL，这三种分析工具你可以理解是 SQL 调优的三个步骤：慢查询、EXPLAIN 和 SHOW PROFILING。</p><p><strong>小结</strong>：</p><p> <img src="http://1.117.162.142:9000/blog/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.png" alt="性能分析"></p><h3 id="2-查看系统性能参数"><a href="#2-查看系统性能参数" class="headerlink" title="2. 查看系统性能参数"></a>2. 查看系统性能参数</h3><p>在 MySQL 中，可以使用 SHOW STATUS 语句查询一些 MySQL 数据库服务器的性能参数、执行效率。</p><p>SHOW STATUS 语句语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;参数&#x27;</span>;</span><br></pre></td></tr></table></figure><p>一些常用的性能参数如下：</p><ul><li>Connections：连接 MySQL 服务器的次数。</li><li>Uptime：MySQL 服务器上线时间。</li><li>Slow_queries：慢查询的次数。</li><li>Innodb_rows_read：Select 查询返回的行数。</li><li>Innodb_rows_inserted：执行 INSERT 操作插入的行数。</li><li>Innodb_rows_updated：执行 UPDATE 操作更新的行数。</li><li>Innodb_rows_deleted：执行 DELETED 擦欧总删除的行数。</li><li>Com_select：查询操作的次数。</li><li>Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。</li><li>Com_update：更新操作的次数。</li><li>Com_delete：删除操作的次数。</li></ul><h3 id="3-统计-SQL-的查询成本：last-query-cost"><a href="#3-统计-SQL-的查询成本：last-query-cost" class="headerlink" title="3. 统计 SQL 的查询成本：last_query_cost"></a>3. 统计 SQL 的查询成本：last_query_cost</h3><p>一条 SQL 查询语句在执行前需要确定查询执行计划，如果存在多种执行计划的话，MySQL 会计算每个执行计划所需要的成本，从中选择成本最小的一个座位最终执行的执行计划。</p><p>如果我们想要查看某条 SQL 语句的查询成本，可以在执行完这条 SQL 语句之后，通过查看当前会话中的last_query_cost 变量值来得到当前查询的成本。它通常也是我们评价一个查询的执行效率的一个常用指标。这个查询成本对应的是 SQL 语句所需要读取的页的数量。</p><p>例如：想要在 student 表中查询 id&#x3D;900001 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time <span class="keyword">FROM</span> student_info</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">900001</span>;</span><br></pre></td></tr></table></figure><p>运行结果 (1 条记录，运行时间为 0.015s)</p><p>然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#结果</span><br><span class="line">last_query_cost <span class="operator">=</span> <span class="number">1.000000</span></span><br></pre></td></tr></table></figure><p>如果想要查询 id 在 900001 到 900100 之间的学生记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time <span class="keyword">FROM</span> student_info</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">900001</span> <span class="keyword">AND</span> <span class="number">900100</span>;</span><br></pre></td></tr></table></figure><p>运行结果 (100 条记录，运行时间为 0.004s)</p><p>查看优化器成本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#结果</span><br><span class="line">last_query_cost <span class="operator">=</span> <span class="number">20.290432</span></span><br></pre></td></tr></table></figure><p>能看到页的数量是刚才的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SQL 查询的时间基本上一样，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然页数量增加了不少，但是通过缓冲池的机制，并没有增加多少查询时间。</p><p>使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p><p>SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到一下两点结论：</p><ul><li><strong>位置决定效率</strong>。如果页就在数据库缓冲池中，那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。</li><li><strong>批量决定效率</strong>。如果我们从磁盘中对单一页进行随机读，那么效率是很低的 (差不多 10ms)，而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</li></ul><p>所以说，遇到 I&#x2F;O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到缓冲池中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p><h3 id="4-定位执行慢的-SQL：慢查询日志"><a href="#4-定位执行慢的-SQL：慢查询日志" class="headerlink" title="4. 定位执行慢的 SQL：慢查询日志"></a>4. 定位执行慢的 SQL：慢查询日志</h3><p>MySQL 的慢查询日志，用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 long_query_time 值的 SQL，则会被记录到慢查询日志中。long_query_time 的默认值为 10，意思是运行 10 秒以上 (不包含 10 秒) 的语句，认为是超出了我们的最大忍耐时间值。</p><p>它的主要作用是，帮助我们发现那些执行时间特别长的 SQL 查询，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，对解决问题很有帮助。比如一条 SQL 执行超过 15s，我们就算慢 SQL，希望能收集超过 5s 的 SQL，结合 EXPLAIN 进行全面分析。</p><p>默认情况下，MySQL 数据库没有开启慢查询日志，需要我们手动来设置这个参数。如果不是条有需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持 将日志记录写入文件。</p><h4 id="4-1-开启慢查询日志参数"><a href="#4-1-开启慢查询日志参数" class="headerlink" title="4.1 开启慢查询日志参数"></a>4.1 开启慢查询日志参数</h4><p><strong>开启 slow_query_log</strong></p><p>在使用前，需要先看下慢查询是否已经开启 <code>show variables like &#39;%slow_query_log&#39;;</code> ，如果是 off 状态，使用 <code>set global slow_query_log=&#39;ON&#39;;</code> 开启。使用 <code>show variables like &#39;%slow_query_log%&#39;;</code> 查看慢查询日志文件的位置。</p><h4 id="4-2-修改-long-query-time-阈值"><a href="#4-2-修改-long-query-time-阈值" class="headerlink" title="4.2 修改 long_query_time 阈值"></a>4.2 修改 long_query_time 阈值</h4><p>使用 <code>show variables like &#39;%long_query_time%&#39;;</code> 查看慢查询的时间阈值设置，使用 <code>set global long_query_time = 1;</code> 修改慢查询的时间阈值。使用 <code>show global status like &#39;%slow_queries%&#39;;</code> 查看当前系统中有多少条慢查询记录。</p><h4 id="4-3-案例演示"><a href="#4-3-案例演示" class="headerlink" title="4.3 案例演示"></a>4.3 案例演示</h4><p><strong>分析</strong></p><p>除了上述变量，控制慢查询日志的还有一个系统变量：min_examined_row_limit。这个变量的意思是，查询扫描过的最少记录数。这个变量和查询执行时间，共同组成了判别一个查询是否是慢查询的条件。如果查询扫描过的记录数大于等于这个变量的值，并且查询执行时间超过 long_query_time 的值，那么，这个查询就被记录到慢查询日志中；反之，则不被记录到慢查询日志中。</p><p><code>show variables like &#39;min%&#39;;</code> 这个值默认是 0。与 long_query_time&#x3D;10 合在一起，表示只要查询的执行时间超过 10 秒钟，哪怕一个记录也没有扫描，都要被记录到慢查询日志中。你也可以根据需要，通过修改 my.ini 文件，来修改查询时长，或者通过 SET 命令，用 SQL 语句修改 min_examined_row_limit 的值。</p><h4 id="4-4-慢查询日志分析工具：mysqldumpslow"><a href="#4-4-慢查询日志分析工具：mysqldumpslow" class="headerlink" title="4.4 慢查询日志分析工具：mysqldumpslow"></a>4.4 慢查询日志分析工具：mysqldumpslow</h4><p>在生产环境中，如果要收工分析日志，查找、分析 SQL，显然是个体力活，MySQL 提供了日志分析工具 mysqldumpslow。</p><p>查看 mysqldumpslow 的帮助信息 <code>mysqldumpslow --help</code> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">~</span><span class="operator">/</span> mysqldumpslow <span class="comment">--help</span></span><br><span class="line">Usage: mysqldumpslow [ OPTS... ] [ LOGS... ]</span><br><span class="line"></span><br><span class="line">Parse <span class="keyword">and</span> summarize the MySQL slow query log. Options <span class="keyword">are</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">--verbose    verbose</span></span><br><span class="line">  <span class="comment">--debug      debug</span></span><br><span class="line">  <span class="comment">--help       write this text to standard output</span></span><br><span class="line"></span><br><span class="line">  <span class="operator">-</span>v           verbose</span><br><span class="line">  <span class="operator">-</span>d           debug</span><br><span class="line">  <span class="operator">-</span>s <span class="keyword">ORDER</span>     what <span class="keyword">to</span> sort <span class="keyword">by</span> (al, <span class="keyword">at</span>, ar, c, l, r, t), <span class="string">&#x27;at&#x27;</span> <span class="keyword">is</span> <span class="keyword">default</span></span><br><span class="line">                al: average lock <span class="type">time</span></span><br><span class="line">                ar: average <span class="keyword">rows</span> sent</span><br><span class="line">                <span class="keyword">at</span>: average query <span class="type">time</span></span><br><span class="line">                 c: count</span><br><span class="line">                 l: lock <span class="type">time</span></span><br><span class="line">                 r: <span class="keyword">rows</span> sent</span><br><span class="line">                 t: query <span class="type">time</span>  </span><br><span class="line">  <span class="operator">-</span>r           reverse the sort <span class="keyword">order</span> (largest <span class="keyword">last</span> instead <span class="keyword">of</span> <span class="keyword">first</span>)</span><br><span class="line">  <span class="operator">-</span>t NUM       just <span class="keyword">show</span> the top n queries</span><br><span class="line">  <span class="operator">-</span>a           don<span class="string">&#x27;t abstract all numbers to N and strings to &#x27;</span>S<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  -n NUM       abstract numbers with at least n digits within names</span></span><br><span class="line"><span class="string">  -g PATTERN   grep: only consider stmts that include this string</span></span><br><span class="line"><span class="string">  -h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),</span></span><br><span class="line"><span class="string">               default is &#x27;</span><span class="operator">*</span><span class="string">&#x27;, i.e. match all</span></span><br><span class="line"><span class="string">  -i NAME      name of server instance (if using mysql.server startup script)</span></span><br><span class="line"><span class="string">  -l           don&#x27;</span>t subtract lock <span class="type">time</span> <span class="keyword">from</span> total <span class="type">time</span></span><br></pre></td></tr></table></figure><p>使用 <code>mysqldumpslow -a -s t -t 5 /opt/homebrew/var/mysql/zhangjiandeMacBook-Pro-slow.log</code> 定位慢查询 SQL。</p><h4 id="4-5-关闭慢查询日志"><a href="#4-5-关闭慢查询日志" class="headerlink" title="4.5 关闭慢查询日志"></a>4.5 关闭慢查询日志</h4><ul><li><p>永久性方式</p><p>  修改 my.cnf 或 my.ini 文件，把 [mysqld] 组下的 slow_query_log 值设为 OFF，修改保存后，在重启 MySQL 服务，即可生效。</p></li><li><p>临时性方式</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log<span class="operator">=</span>OFF;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-6-删除慢查询日志"><a href="#4-6-删除慢查询日志" class="headerlink" title="4.6 删除慢查询日志"></a>4.6 删除慢查询日志</h4><p>使用 SHOW 语句显示慢查询日志信息，具体 SQL 语句如下：</p><p><code>SHOW VARIABLES LIKE &#39;slow_query_log%&#39;;</code></p><p>从执行结果可以看出慢查询日志的的目录，在该目录下手动删除慢查询日志文件即可。使用命令 <code>mysqladmin flush-logs</code> 来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p flush<span class="operator">-</span>logs slow</span><br></pre></td></tr></table></figure><blockquote><p>提示</p><p>慢查询日志都是使用 mysqladmin flush-logs 命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。</p></blockquote><h3 id="5-查看-SQL-执行成本：SHOW-PROFILE"><a href="#5-查看-SQL-执行成本：SHOW-PROFILE" class="headerlink" title="5. 查看 SQL 执行成本：SHOW PROFILE"></a>5. 查看 SQL 执行成本：SHOW PROFILE</h3><p>show profile 是 MySQL 提供的可以用来分析当前会话中 SQL 都做了什么、执行的资源消耗情况的工具，可用于 SQL 调优的测量。默认情况下处于关闭状态，并保存最近 15 次的运行结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看状态</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span>;</span><br><span class="line"># 开启</span><br><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"># 查看当前会话有哪些 profile</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"># 查看指定 query id</span><br><span class="line"><span class="keyword">show</span> profile cpu, block io <span class="keyword">for</span> query <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>show profile 的常用查询参数</strong>：</p><ul><li>ALL：显示所有的开销信息。</li><li>BLOCK IO：显示块 IO 开销。</li><li>CONTEXT SWITCHES：上下文切换开销。</li><li>CPU：显示 CPU 开销信息。</li><li>IPC：显示发送和接受开销信息。</li><li>MEMORY：显示内存开销信息。</li><li>PAGE FAULTS：显示页面错误开销信息。</li><li>SOURCE：显示和 Source_function，Source_file，Source_line 相关的开销信息。</li><li>SWAPS：显示交换次数开销信息。</li></ul><p><strong>日常开发需要注意的结论</strong>：</p><ul><li><code>concerting HEAP to MyISAM</code>：查询结果太大，内存不够，数据往磁盘上搬了。</li><li><code>Creating tmp table</code>：创建临时表，先拷贝数据到临时表，用完后再删除临时表。</li><li><code>Copying to tmp table on disk</code>：把内存中临时表复制到磁盘上，警惕！</li><li><code>locked</code>。</li></ul><p>如果在 show profile 诊断结果中出现了以上 4 条结果中的任何一条，则 SQL 语句需要优化。</p><blockquote><p>注意：</p><p>不过 show profile 命令将被弃用，可以从 information_schema 中 profiling 数据表进行查看。</p></blockquote><h3 id="6-分析查询语句：EXPLAIN"><a href="#6-分析查询语句：EXPLAIN" class="headerlink" title="6. 分析查询语句：EXPLAIN"></a>6. 分析查询语句：EXPLAIN</h3><h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h4><p><strong>定位了慢查询的 SQL 之后，我们就可以使用 EXPLAIN 或 DESCRIBE 工具做针对性的分析查询语句</strong>。DESCRIBE 语句的使用方法与 EXPLAIN 语句是一样的，并且分析结果也是一样的。</p><p>MySQL 中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的 Query 提供它认为最优的执行计划 (他认为最优的数据检索方式，但不见得是 DBA 认为是最优的，这部分最耗费时间)。</p><p>这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL 为我们提供了 EXPLAIN 语句来帮助我们查看某个查询语句的具体执行计划。</p><p><strong>能做什么</strong>？</p><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li><strong>哪些索引被实际使用</strong></li><li>表之间的引用</li><li><strong>每张表有多少行被优化器查询</strong></li></ul><p><strong><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">官网介绍</a></strong></p><p><strong>版本情况</strong></p><ul><li>MySQL 5.6.3 以前只能 EXPLAIN SELECT；MySQL 5.6.3 以后就可以 EXPLAIN SELECT、UPDATE、DELETE</li><li>在 5.7 以前的版本中，想要显示 partitions 需要使用 explain partitions 命令；想要显示 filtered 需要使用 explain extended 命令。在 5.7 版本后，默认 explain 直接显示 partitions 和 filtered 中的信息。</li></ul><h4 id="6-2-基本语法"><a href="#6-2-基本语法" class="headerlink" title="6.2 基本语法"></a>6.2 基本语法</h4><p>EXPLAIN 或 DESCRIBE 语句的语法形式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> select_options</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">SELECT</span> select_options</span><br></pre></td></tr></table></figure><p>如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 EXPLAIN，就像这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">No</span> tables used <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br></pre></td></tr></table></figure><p>输出的上述信息就是所谓的执行计划。在这个执行计划的辅助下，我们需要知道应该怎么样改进自己的查询语句以使查询执行起来更高效。其实除了以 SELECT 开头的查询语句，其余的 DELETE、INSERT、REPLACE 以及 UPDATE 语句等都可以加上 EXPLAIN，用来查看这些语句的执行计划，只是平时我们对 SELECT 语句更感兴趣。</p><blockquote><p>注意：</p><p>执行 EXPLAIN 时并没有真正的执行该后面的语句，因此可以安全的查看执行计划。</p></blockquote><p>EXPLAIN 语句输出的各个列的作用如下：</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id</td></tr><tr><td>select_type</td><td>SELECT 关键字对应的那个查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上使用的索引</td></tr><tr><td>key_len</td><td>实际使用到的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>filtered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table><h4 id="6-3-数据准备"><a href="#6-3-数据准备" class="headerlink" title="6.3 数据准备"></a>6.3 数据准备</h4><p><strong>建表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s1 (</span><br><span class="line">id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">  key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key2 <span class="type">INT</span>,</span><br><span class="line">  key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  INDEX idx_key1 (key1),</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX idx_key2 (key2),</span><br><span class="line">  INDEX idx_key3 (key3),</span><br><span class="line">  INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s2 (</span><br><span class="line">id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">  key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key2 <span class="type">INT</span>,</span><br><span class="line">  key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  INDEX idx_key1 (key1),</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX idx_key2 (key2),</span><br><span class="line">  INDEX idx_key3 (key3),</span><br><span class="line">  INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p><strong>设置参数 log_bin_trust_function_creators</strong></p><p>创建函数，假如报错，需开启如下命令：允许创建函数设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>;# 不加 <span class="keyword">global</span> 只是当前窗口有效。</span><br></pre></td></tr></table></figure><p><strong>创建函数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string1(n <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>)#该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line"><span class="keyword">SET</span> return_str <span class="operator">=</span> CONCAT(return_str, <span class="built_in">SUBSTRING</span>(chars_str, <span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> RAND() <span class="operator">*</span> <span class="number">52</span>), <span class="number">1</span>));</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p><strong>创建存储过程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_s1 (<span class="keyword">IN</span> min_num <span class="type">INT</span> (<span class="number">10</span>), <span class="keyword">IN</span> max_num <span class="type">INT</span> (<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">REPEAT</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> s1 <span class="keyword">VALUES</span>(</span><br><span class="line">  (min_num <span class="operator">+</span> i),</span><br><span class="line">  rand_string1(<span class="number">6</span>),</span><br><span class="line">  (min_num <span class="operator">+</span> <span class="number">30</span> <span class="operator">*</span> i <span class="operator">+</span> <span class="number">5</span>),</span><br><span class="line">  rand_string1(<span class="number">6</span>),</span><br><span class="line">  rand_string1(<span class="number">10</span>),</span><br><span class="line">  rand_string1(<span class="number">5</span>),</span><br><span class="line">  rand_string1(<span class="number">10</span>),</span><br><span class="line">  rand_string1(<span class="number">10</span>));</span><br><span class="line">  UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">  <span class="keyword">END</span> REPEAT;</span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_s2 (<span class="keyword">IN</span> min_num <span class="type">INT</span> (<span class="number">10</span>), <span class="keyword">IN</span> max_num <span class="type">INT</span> (<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">REPEAT</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> s2 <span class="keyword">VALUES</span>(</span><br><span class="line">  (min_num <span class="operator">+</span> i),</span><br><span class="line">  rand_string1(<span class="number">6</span>),</span><br><span class="line">  (min_num <span class="operator">+</span> <span class="number">30</span> <span class="operator">*</span> i <span class="operator">+</span> <span class="number">5</span>),</span><br><span class="line">  rand_string1(<span class="number">6</span>),</span><br><span class="line">  rand_string1(<span class="number">10</span>),</span><br><span class="line">  rand_string1(<span class="number">5</span>),</span><br><span class="line">  rand_string1(<span class="number">10</span>),</span><br><span class="line">  rand_string1(<span class="number">10</span>));</span><br><span class="line">  UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">  <span class="keyword">END</span> REPEAT;</span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p><strong>调用存储过程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> insert_s1(<span class="number">10001</span>, <span class="number">10000</span>);</span><br><span class="line"><span class="keyword">CALL</span> insert_s2(<span class="number">10001</span>, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure><h4 id="6-4-EXPLAIN-各列作用"><a href="#6-4-EXPLAIN-各列作用" class="headerlink" title="6.4 EXPLAIN 各列作用"></a>6.4 EXPLAIN 各列作用</h4><ul><li>table：表名</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 查询的每一行记录都对应着一个单表</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line"># s1:驱动表  s2:被驱动表</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">join</span> buffer (hash <span class="keyword">join</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+</span></span><br><span class="line"># 执行计划中，记录在前的为驱动表，在后的为被驱动表，这里s2为驱动表，s1为被驱动表</span><br></pre></td></tr></table></figure><ul><li>id：在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2</span><br><span class="line"><span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key2</span><br><span class="line"><span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> idx_key1      <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> idx_key2      <span class="operator">|</span> idx_key2 <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> mysql_test.s1.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+-----------------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key3 <span class="keyword">FROM</span> s2);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>       <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys       <span class="operator">|</span> key                 <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE       <span class="operator">|</span> s1          <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> idx_key1            <span class="operator">|</span> <span class="keyword">NULL</span>                <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE       <span class="operator">|</span> <span class="operator">&lt;</span>subquery2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="operator">&lt;</span>auto_distinct_key<span class="operator">&gt;</span> <span class="operator">|</span> <span class="operator">&lt;</span>auto_distinct_key<span class="operator">&gt;</span> <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> mysql_test.s1.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> MATERIALIZED <span class="operator">|</span> s2          <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index  <span class="operator">|</span> idx_key3            <span class="operator">|</span> idx_key3            <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> s2         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span> <span class="operator">|</span> <span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br></pre></td></tr></table></figure><p><strong>查询优化器可能对涉及子查询的查询语句进行重写，转变为多表查询的操作</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key2 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> idx_key1      <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> idx_key2      <span class="operator">|</span> idx_key2 <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> mysql_test.s1.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span>; <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+----------+---------+--------------------+------+----------+------------------------------------+</span></span><br></pre></td></tr></table></figure><p><strong>Union 去重</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> s2         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span> <span class="operator">|</span> <span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>       <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p>id 如果相同，可以认为是一组，从上往下顺序执行</p></li><li><p>在所有组中，id 值越大，优先级越高，越先执行</p></li><li><p>关注点：id 号每个号码，表示一趟独立的查询，一个 SQL 的查询趟越少越好数</p></li></ul></blockquote><ul><li>select_type</li></ul><p>一条大的查询语句里边可以包含若干个 SELECT 关键字，每个 SELECT 关键字代表着一个小的查询语句，而每个 SELECT 关键字的 FROM 字句中都可以包含若干张表 (这些表用来做连接查询)，每一张表都对应着执行计划输出中的一条记录，对于在同一个 SELECT 关键字中的表来说，它们的 id 值是相同的。</p><p>MySQL 为每个 SELECT 关键字代表的小查询都定义了一个称之为 select_type 的属性，意思是我们只要知道了某个小查询的 select_type 属性，就知道了这个小查询在整个大查询中扮演的一个什么角色，select_type 能取的值：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>SIMPLE</td><td>Simple SELECT (not using UNION or subqueries)</td></tr><tr><td>PRIMARY</td><td>Outermost SELECT</td></tr><tr><td>UNION</td><td>Second or later SELECT statement in a UNION</td></tr><tr><td>UNION RESULT</td><td>Result of a UNION</td></tr><tr><td>SUBQUERY</td><td>FIRST SELECT in subquery</td></tr><tr><td>DEPENDENT SUBQUERY</td><td>First SELECT in subquery,dependent on outer query</td></tr><tr><td>DEPENDENT UNION</td><td>Second or later SELECT statement in a UNION, dependent on outer query</td></tr><tr><td>DERIVED</td><td>Derived table</td></tr><tr><td>MATERIALIZED</td><td>Materialized subquery</td></tr><tr><td>UNCACHEABLE SUBQUERY</td><td>A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td>UNCACHEABLE UNION</td><td>The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table><p>select_type：SELECT 关键字对应的那个查询的类型，确定小查询在整个大查询中扮演了一个什么角色</p><p>具体分析：</p><ol><li><p>SIMPLE</p><p> 查询语句中不包含 UNION 或者子查询的查询都算是 SIMPLE 类型</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line"># 连接查询也算是 SIMPLE 类型</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">join</span> buffer (hash <span class="keyword">join</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------------+</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>UNION RESULT</p><p> 对于包含 UNION 或者 UNION ALL 或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的 select_type 值就是 PRIMARY。</p><p> 对于包含 UNION 或者 UNION ALL 的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的 select_type 值就是 UNION。</p><p> MySQL 选择使用临时表来完成 UNION 查询的去重工作，针对该临时表的查询的 select_type 就是 UNION RESULT。</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> s2         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span> <span class="operator">|</span> <span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>       <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>SUBQUERY</p><p> 如果包含子查询的查询语句不能够专为对应的 semi-join 的形式，并且该子查询是不相关子查询。该子查询的第一个 SELECT 关键字代表的那个查询的 select_type 就是 SUBQUERY</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p>​如果包含子查询的查询语句不能够专为对应的 semi-join 的形式，并且该子查询是相关子查询，则该子查询的第一个 SELECT 关键字代表的那个查询的 select_type 就是 DEPENDENT SUBQUERY</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1</span><br><span class="line"><span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> s1.key2 <span class="operator">=</span> s2.key2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+--------+-------------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type        <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys     <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+--------+-------------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>            <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> idx_key3          <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DEPENDENT SUBQUERY <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> idx_key2,idx_key1 <span class="operator">|</span> idx_key2 <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> mysql_test.s1.key2 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+--------+-------------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"># 注意的是，select_type 为 DEPENDENT SUBQUERY 的查询可能会被执行多次</span><br></pre></td></tr></table></figure><p>​在包含 UNION 或者 UNION ALL 的大查询中，如果各个小查询都依赖于外层查询的话，拿出了最左边的那个小查询之外，其余的小查询的 select_type 的值就是 DEPENDENT UNION。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1</span><br><span class="line"><span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type        <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>            <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DEPENDENT SUBQUERY <span class="operator">|</span> s2         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> DEPENDENT <span class="keyword">UNION</span>    <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span>       <span class="operator">|</span> <span class="operator">&lt;</span>union2,<span class="number">3</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span></span><br></pre></td></tr></table></figure><p>​对于派生表的查询，该派生表对应的子查询的 select_type 就是 DERIVED。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> key1, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> c <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> key1) <span class="keyword">AS</span> derived_s1 <span class="keyword">WHERE</span> c <span class="operator">&gt;</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> <span class="operator">&lt;</span>derived2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>​当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的 select_type 属性就是 MATERALIZED。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2);#子查询被转化为物化表</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>       <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys       <span class="operator">|</span> key                 <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE       <span class="operator">|</span> s1          <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> idx_key1            <span class="operator">|</span> <span class="keyword">NULL</span>                <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE       <span class="operator">|</span> <span class="operator">&lt;</span>subquery2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="operator">&lt;</span>auto_distinct_key<span class="operator">&gt;</span> <span class="operator">|</span> <span class="operator">&lt;</span>auto_distinct_key<span class="operator">&gt;</span> <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> mysql_test.s1.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> MATERIALIZED <span class="operator">|</span> s2          <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index  <span class="operator">|</span> idx_key1            <span class="operator">|</span> idx_key1            <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><ul><li><p>partitions：匹配的分区信息</p><p>  代表分区表中的命中情况，非分区表，该项为 NULL。一般情况下我们的查询语句的执行计划的 partitions 列的值都是 NULL。</p></li><li><p><strong>type</strong>：针对单表的访问方法</p><p>  执行计划的一条记录就代表着 MySQL 对某个表的执行查询时的访问方法，又称访问类型，其中的 type 列就表明了这个访问方法是啥，是较为重要的一个指标。比如，看到 type 列的值是 ref，表明 MySQL 即将使用 ref 访问方法来执行对 s1 表的查询。</p><p>  完整的访问方法如下：system, const, eq_ref, ref, fulltext, ref_or_null, index_merge, unique_subquery, index_subquery, range, index, ALL。</p><ul><li><p>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如 MyISAM、MEMORY，那么对该表的访问方法就是 system。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t(i <span class="type">INT</span>) ENGINE<span class="operator">=</span>MyISAM;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t     <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">system</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span></span><br></pre></td></tr></table></figure></li><li><p>当根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是 const</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10005</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> const <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key2 <span class="operator">=</span> <span class="number">10066</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> const <span class="operator">|</span> idx_key2      <span class="operator">|</span> idx_key2 <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure></li><li><p>在连接查询时，如果被驱动表时通过主键或者唯一二级索引列等值匹配的方式进行访问的 (如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较)，则对该被驱动表的访问方法就是 eq_ref。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>              <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> mysql_test.s2.id <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+</span></span><br></pre></td></tr></table></figure></li><li><p>当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是 ref</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure></li><li><p>当对普通二级索引进行等值匹配查询，该索引列的值也可以是 NULL 值时，那么对该表的访问方法就可能是 ref_or_null</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key1 <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type        <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> ref_or_null <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure></li><li><p>单表访问方法时在某些场景下可以使用 Intersection、Union、Sort-Union 这三种索引合并的方式来执行查询</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type        <span class="operator">|</span> possible_keys     <span class="operator">|</span> key               <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index_merge <span class="operator">|</span> idx_key1,idx_key3 <span class="operator">|</span> idx_key1,idx_key3 <span class="operator">|</span> <span class="number">303</span>,<span class="number">303</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">union</span>(idx_key1,idx_key3); <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span></span><br></pre></td></tr></table></figure></li><li><p>unique_subquery 是针对在一些包含 IN 子查询的查询语句中，如果查询优化器决定将 IN 子查询转换为 EXISTS 子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的 type 列的值就是 unique_subquery。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1</span><br><span class="line"><span class="keyword">WHERE</span> key2 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> s1.key1 <span class="operator">=</span> s2.key1) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type        <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type            <span class="operator">|</span> possible_keys    <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>            <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>             <span class="operator">|</span> idx_key3         <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DEPENDENT SUBQUERY <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> unique_subquery <span class="operator">|</span> <span class="keyword">PRIMARY</span>,idx_key1 <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> func <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p>如果使用索引获取某些范围区间的记录，那么就可能使用到 range 访问方法</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure></li><li><p>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是 index</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> key_part2 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> idx_key_part  <span class="operator">|</span> idx_key_part <span class="operator">|</span> <span class="number">909</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span></span><br></pre></td></tr></table></figure></li><li><p>全表扫描</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>小结</p><p>  结果值从最好到最坏依次是：</p><p>  <strong>system</strong> &gt; <strong>const</strong> &gt; <strong>eq_ref</strong> &gt; <strong>ref</strong> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <strong>range</strong> &gt; <strong>index</strong> &gt; <strong>ALL</strong></p><p>  其中比较重要的几个提取出来 (加粗的)。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts 级别。</p></li></ul></li><li><p>possible_keys 和 key (可能用到的索引和实际上使用的索引)</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys     <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1,idx_key3 <span class="operator">|</span> idx_key3 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>     <span class="number">5.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p>key_len：实际使用到的索引长度 (即：字节数)</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10005</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> const <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure></li><li><p>ref：当使用索引列等值查询时，与索引列进行等值匹配的对象信息。</p><p>  比如知识一个常数或者是某个列。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>              <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> mysql_test.s2.id <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+------------------+------+----------+-------+</span></span><br></pre></td></tr></table></figure></li><li><p>rows：预估的需要读取的记录条数，值越小越好</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">366</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure></li><li><p>filtered：某个表经过搜索条件过滤后剩余记录条数的百分比。</p><p>  如果使用的是索引执行的单表扫描，那么计算时需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">366</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span>; <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+------------------------------------+</span></span><br></pre></td></tr></table></figure><p>   对于单表查询来说，这个 filtered 列的值没什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的 filtered 值，它决定了被驱动表要执行的次数 (即：rows * filtered)</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> mysql_test.s1.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p>Extra：一些额外的信息，更准确的理解 MySQL 到底将如何执行给定的查询语句。</p><p>  当查询语句没有 FROM 字句时将会提示该额外信息</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">No</span> tables used <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br></pre></td></tr></table></figure><p>  查询语句的 WHERE 字句永远为 FALSE 时将会提示该额外信息</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">!=</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> Impossible <span class="keyword">WHERE</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span></span><br></pre></td></tr></table></figure><p>  当我们使用全表扫描来执行对某个表的查询，并且该语句的 WHERE 字句中有针对该表的搜索条件时，在 Extra 列中会提示上述额外信息</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>  当查询列表处有 MIN 或者 MAX 聚合函数，但是并没有符合 WHERE 字句中国呢的搜索条件的记录时，将会提示该额外信息</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(key1) <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;abcdefg&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">No</span> matching min<span class="operator">/</span>max <span class="type">row</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+</span></span><br></pre></td></tr></table></figure><p>  当查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用覆盖索引的情况下，在 Extra 列将会提示该额外信息。比方说下边这个查询中只需要用到 idx_key1 而不需要回表操作：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>  有些搜索条件中虽然出现了索引列，但却不能使用到索引</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key1 <span class="keyword">LIKE</span> <span class="string">&#x27;%a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">366</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure><p>  在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL 一般会为其分配一块名叫 join buffer 的内存块来加快查询速度，也就是我们所说的基于块的嵌套循环算法</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.common_field <span class="operator">=</span> s2.common_field;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">join</span> buffer (hash <span class="keyword">join</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>  当我们使用左连接时，如果 WHERE 子句中包含要求被驱动表的某个列等于 NULL 值的搜索条件，而且那个列又是不允许存储 NULL 值的，那么在该表的执行计划的 Extra 列就会提示 Not exists 额外信息</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> mysql_test.s1.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Not</span> <span class="keyword">exists</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------------------+</span></span><br></pre></td></tr></table></figure><p>  如果执行计划的 Extra 列出现了 Using intersect(…) 提示，说明准备使用 Intersect 索引合并的方式执行查询，括号中的 … 表示需要进行索引合并的索引名称。如果出现了 Using union(…) 提示，说明准备使用 Union 索引合并的方式执行查询。出现了 Using sort union(…) 提示，说明准备使用 Sort-Union 索引合并的方式执行查询。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type        <span class="operator">|</span> possible_keys     <span class="operator">|</span> key               <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index_merge <span class="operator">|</span> idx_key1,idx_key3 <span class="operator">|</span> idx_key1,idx_key3 <span class="operator">|</span> <span class="number">303</span>,<span class="number">303</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">union</span>(idx_key1,idx_key3); <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>  当我们的 LIMIT 子句的参数为 0 时，表示压根不打算从表中读出任何记录，将会提示该额外信息</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 LIMIT <span class="number">0</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> Zero limit <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------+</span></span><br></pre></td></tr></table></figure><p>  有一些情况对结果集中的记录进行排序是可以使用到索引的。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> key1 LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+</span></span><br></pre></td></tr></table></figure><p>  很多情况下排序操作无法使用到索引，只能在内存中 (记录较少的时候) 或者磁盘中 (记录较多的时候) 进行排序，MySQL 把这种在内存或者磁盘上进行排序的方式统称为文件排序 (英文名：filesort)</p><p>  如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的 Extra 列中显示 Using filesort 提示</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> common_field LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br></pre></td></tr></table></figure><p>  在许多查询的执行过程中，MySQL 可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含 DISTINCT、GROUP BY、UNION 等子句的查询过程中，如果不能有效利用索引来完成查询，MySQL 很有可能寻求通过建立内部临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的 Extra 列将会显示 Using temporary 提示。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> common_field <span class="keyword">FROM</span> s1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br></pre></td></tr></table></figure><p>  执行计划中出现 Using temporary 并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以我们最好能使用索引来替代掉使用临时表。比如：扫描指定的索引 idx_key1 即可。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> key1, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> amount <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> key1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">9895</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p>小结</p><ul><li>EXPLAIN 不考虑各种 cache</li><li>EXPLAIN 不能显示 MySQL 在执行查询时所作的优化工作</li><li>EXPLAIN 不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li><li>部分统计信息是估算的，并非精确值</li></ul></li></ul><h3 id="7-EXPLAIN-的进一步使用"><a href="#7-EXPLAIN-的进一步使用" class="headerlink" title="7. EXPLAIN 的进一步使用"></a>7. EXPLAIN 的进一步使用</h3><h4 id="7-1-EXPLAIN-四种输出格式"><a href="#7-1-EXPLAIN-四种输出格式" class="headerlink" title="7.1 EXPLAIN 四种输出格式"></a>7.1 EXPLAIN 四种输出格式</h4><ul><li><p>传统格式</p><p>  传统格式简单明了，输出是一个表格形式，概要说明查询计划。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> s1.key1, s2.key1 <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.common_field <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>    <span class="number">90.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> mysql_test.s2.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p>JSON 格式</p><p>  第一种格式中介绍的 EXPLAIN 语句输出中缺少了一个衡量执行计划好坏的重要属性——成本。而 JSON 格式是四种格式里面输出信息最详尽的格式，里面包含了执行的成本信息。</p><ul><li><p>JSON 格式：在 EXPLAIN 单词和真正的查询语句中间加上 FORMAT&#x3D;JSON。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT<span class="operator">=</span>JSON <span class="keyword">SELECT</span> ......</span><br></pre></td></tr></table></figure></li><li><p>EXPLAIN 的 Column 与 JSON 的对应关系</p><table><thead><tr><th>Column</th><th>JSON Name</th><th>Meaning</th></tr></thead><tbody><tr><td>id</td><td>select_id</td><td>The SELECT identifier</td></tr><tr><td>select_type</td><td>None</td><td>The SELECT type</td></tr><tr><td>table</td><td>table_name</td><td>The table for the output row</td></tr><tr><td>partitions</td><td>partitions</td><td>The matching partitions</td></tr><tr><td>type</td><td>access_type</td><td>The join type</td></tr><tr><td>possible_keys</td><td>possible_keys</td><td>The possible indexes to choose</td></tr><tr><td>key</td><td>key</td><td>The index actually chosen</td></tr><tr><td>ken_len</td><td>key_length</td><td>The length of the chosen key</td></tr><tr><td>ref</td><td>ref</td><td>The columns compared to the index</td></tr><tr><td>rows</td><td>rows</td><td>Estimate of rows to be examined</td></tr><tr><td>filtered</td><td>filtered</td><td>Percentage of rows filtered by table condition</td></tr><tr><td>Extra</td><td>None</td><td>Additional information</td></tr></tbody></table>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT<span class="operator">=</span>JSON <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key2 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">EXPLAIN: &#123;</span><br><span class="line">  &quot;query_block&quot;: &#123;</span><br><span class="line">    &quot;select_id&quot;: <span class="number">1</span>,</span><br><span class="line">    &quot;cost_info&quot;: &#123;</span><br><span class="line">      &quot;query_cost&quot;: &quot;1360.07&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;nested_loop&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;table&quot;: &#123;</span><br><span class="line">          &quot;table_name&quot;: &quot;s1&quot;,</span><br><span class="line">          &quot;access_type&quot;: &quot;ALL&quot;,</span><br><span class="line">          &quot;possible_keys&quot;: [</span><br><span class="line">            &quot;idx_key1&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;rows_examined_per_scan&quot;: <span class="number">9895</span>,</span><br><span class="line">          &quot;rows_produced_per_join&quot;: <span class="number">989</span>,</span><br><span class="line">          &quot;filtered&quot;: &quot;10.00&quot;,</span><br><span class="line">          &quot;cost_info&quot;: &#123;</span><br><span class="line">            &quot;read_cost&quot;: &quot;914.80&quot;,</span><br><span class="line">            &quot;eval_cost&quot;: &quot;98.95&quot;,</span><br><span class="line">            &quot;prefix_cost&quot;: &quot;1013.75&quot;,</span><br><span class="line">            &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;used_columns&quot;: [</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;key1&quot;,</span><br><span class="line">            &quot;key2&quot;,</span><br><span class="line">            &quot;key3&quot;,</span><br><span class="line">            &quot;key_part1&quot;,</span><br><span class="line">            &quot;key_part2&quot;,</span><br><span class="line">            &quot;key_part3&quot;,</span><br><span class="line">            &quot;common_field&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;attached_condition&quot;: &quot;((`mysql_test`.`s1`.`common_field` = &#x27;a&#x27;) and (`mysql_test`.`s1`.`key1` is not null))&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;table&quot;: &#123;</span><br><span class="line">          &quot;table_name&quot;: &quot;s2&quot;,</span><br><span class="line">          &quot;access_type&quot;: &quot;eq_ref&quot;,</span><br><span class="line">          &quot;possible_keys&quot;: [</span><br><span class="line">            &quot;idx_key2&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;key&quot;: &quot;idx_key2&quot;,</span><br><span class="line">          &quot;used_key_parts&quot;: [</span><br><span class="line">            &quot;key2&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;key_length&quot;: &quot;5&quot;,</span><br><span class="line">          &quot;ref&quot;: [</span><br><span class="line">            &quot;mysql_test.s1.key1&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;rows_examined_per_scan&quot;: <span class="number">1</span>,</span><br><span class="line">          &quot;rows_produced_per_join&quot;: <span class="number">989</span>,</span><br><span class="line">          &quot;filtered&quot;: &quot;100.00&quot;,</span><br><span class="line">          &quot;index_condition&quot;: &quot;(cast(`mysql_test`.`s1`.`key1` as double) = cast(`mysql_test`.`s2`.`key2` as double))&quot;,</span><br><span class="line">          &quot;cost_info&quot;: &#123;</span><br><span class="line">            &quot;read_cost&quot;: &quot;247.38&quot;,</span><br><span class="line">            &quot;eval_cost&quot;: &quot;98.95&quot;,</span><br><span class="line">            &quot;prefix_cost&quot;: &quot;1360.08&quot;,</span><br><span class="line">            &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;used_columns&quot;: [</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;key1&quot;,</span><br><span class="line">            &quot;key2&quot;,</span><br><span class="line">            &quot;key3&quot;,</span><br><span class="line">            &quot;key_part1&quot;,</span><br><span class="line">            &quot;key_part2&quot;,</span><br><span class="line">            &quot;key_part3&quot;,</span><br><span class="line">            &quot;common_field&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  s1 表的的成本计算：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">  &quot;read_cost&quot;: &quot;914.80&quot;,</span><br><span class="line">  &quot;eval_cost&quot;: &quot;98.95&quot;,</span><br><span class="line">  &quot;prefix_cost&quot;: &quot;1013.75&quot;,</span><br><span class="line">  &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>read_cost 是由下边这两部分组成的：</p><ul><li>IO 成本</li><li>检测 <code>rows * (1 - filter)</code> 条记录的 CPU 成本</li></ul><blockquote><p>rows 和 filter 都是前边介绍执行计划的输出列，在 JSON 格式的执行计划中，rows 相当于 rows_wxamined_per_scan，filtered 名称不变。</p></blockquote></li><li><p>eval_cost 是这样计算的：</p><p>  检测 <code>rows * filter</code> 条记录的成本</p></li><li><p>prefix_cost 就是单独查询 s1 表的成本，也就是：</p><p>  <code>read_cost + eval_cost</code></p></li><li><p>data_read_per_join 表示在此次查询中需要读取的数据量。</p></li></ul><p>  对于 s2 表的 cost_info 部分是这样的：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">  &quot;read_cost&quot;: &quot;247.38&quot;,</span><br><span class="line">  &quot;eval_cost&quot;: &quot;98.95&quot;,</span><br><span class="line">  &quot;prefix_cost&quot;: &quot;1360.08&quot;,</span><br><span class="line">  &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  由于 s2 表是被驱动表，所以可能被读取多次，这里的 read_cost 和 eval_cost 是访问多次 s2 表后累加起来的值，主要关注里边的 prefix_cost 的值代表的是整个连接查询预计的成本，也就是单词查询 s1 表和多次查询 s2 表后的成本的和，也就是：</p><p>  <code>247.38 + 98.95 + 1013.75 = 1360.08</code></p></li></ul></li><li><p>TREE 格式</p><p>  TREE 格式是 8.0.16 版本之后引入的新格式，主要根据查询的各个部分之间的关系和各部分的执行顺序来描述如何查询。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT<span class="operator">=</span>TREE <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key2 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>\G</span><br><span class="line">EXPLAIN: <span class="operator">-</span><span class="operator">&gt;</span> Nested loop <span class="keyword">inner</span> <span class="keyword">join</span>  (cost<span class="operator">=</span><span class="number">1360.08</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">990</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Filter</span>: ((s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>) <span class="keyword">and</span> (s1.key1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>))  (cost<span class="operator">=</span><span class="number">1013.75</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">990</span>)</span><br><span class="line">        <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Table</span> scan <span class="keyword">on</span> s1  (cost<span class="operator">=</span><span class="number">1013.75</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">9895</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> Single<span class="operator">-</span><span class="type">row</span> index lookup <span class="keyword">on</span> s2 <span class="keyword">using</span> idx_key2 (key2<span class="operator">=</span>s1.key1), <span class="keyword">with</span> index <span class="keyword">condition</span>: (<span class="built_in">cast</span>(s1.key1 <span class="keyword">as</span> <span class="keyword">double</span>) <span class="operator">=</span> <span class="built_in">cast</span>(s2.key2 <span class="keyword">as</span> <span class="keyword">double</span>))  (cost<span class="operator">=</span><span class="number">0.25</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>可视化输出</p><p>  可视化输出，可以通过 MySQL Workbench 可视化查看 MySQL 的执行计划。通过点击 workbench 的放大镜图标，即可生成可视化的查询计划。</p></li></ul><h4 id="7-2-SHOW-WARNINGS-的使用"><a href="#7-2-SHOW-WARNINGS-的使用" class="headerlink" title="7.2 SHOW WARNINGS 的使用"></a>7.2 SHOW WARNINGS 的使用</h4><p>在使用 EXPLAIN 语句查看了某个查询的执行计划之后，紧接着还可以使用 SHOW WARNINGS 语句查看与这个查询的执行计划有关的一下扩展信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> s1.key1, s2.key1 <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.common_field <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">9595</span> <span class="operator">|</span>    <span class="number">90.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_key1      <span class="operator">|</span> idx_key1 <span class="operator">|</span> <span class="number">303</span>     <span class="operator">|</span> mysql_test.s2.key1 <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+--------------------+------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> WARNINGS \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">  Level: Note</span><br><span class="line">   Code: <span class="number">1003</span></span><br><span class="line">Message: <span class="comment">/* select#1 */</span> <span class="keyword">select</span> `mysql_test`.`s1`.`key1` <span class="keyword">AS</span> `key1`,`mysql_test`.`s2`.`key1` <span class="keyword">AS</span> `key1` <span class="keyword">from</span> `mysql_test`.`s1` <span class="keyword">join</span> `mysql_test`.`s2` <span class="keyword">where</span> ((`mysql_test`.`s1`.`key1` <span class="operator">=</span> `mysql_test`.`s2`.`key1`) <span class="keyword">and</span> (`mysql_test`.`s2`.`common_field` <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>))</span><br></pre></td></tr></table></figure><p>可以看到 SHOW WARNINGS 展示出来的信息有三个字段：Level、Code、Message。最常见的就是 Code 为 1003 的信息，当 Code 为 1003 时，Message 字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。比如上边的查询本来是一个左外连接查询，但是有一个 s2.common_field IS NOT NULL 的条件，就会导致查询优化器把左外连接查询优化为内连接查询，从 SHOW WARNINGS 的 Message 字段也可以看出来，原本的 LEFT JOIN 已经变成了 JOIN。</p><h3 id="8-分析优化器执行计划：trace"><a href="#8-分析优化器执行计划：trace" class="headerlink" title="8. 分析优化器执行计划：trace"></a>8. 分析优化器执行计划：trace</h3><p>OPTIMIZER_TRACE 是 MySQL 5.6 引入的一项跟踪功能，它可以跟踪优化器做出的各种决策 (比如访问表的方法、各种开销计算、各种转换等)，并将跟踪结果记录到 INFORMATION_SCHEMA.OPTIMIZER_TRACE 表中。</p><p>此功能默认关闭。开启 trace，并设置格式为 JSON，同时设置 trace 最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enable=on&#x27;</span>,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">SET</span> optimizer_trace_max_mem_size<span class="operator">=</span><span class="number">1000000</span>;</span><br></pre></td></tr></table></figure><p>开启后，可分析如下语句：</p><ul><li>SELECT</li><li>INSERT</li><li>REPLACE</li><li>UPDATE</li><li>DELETE</li><li>EXPLAIN</li><li>SET</li><li>DECLARE</li><li>CASE</li><li>IF</li><li>RETURN</li><li>CALL</li></ul><p>执行 SQL 后执行 <code>SELECT * FROM information_schema.optimizer_trace \G</code></p><p>结果包括四部分：</p><ul><li>查询语句</li><li>QUERY 字段对应语句的跟踪信息</li><li>跟踪信息过长时，被截断的跟踪信息的字节数</li><li>执行跟踪语句的用户是否有查看对象的权限，当不具有权限时，该列信息为 1 且 TRACE 字段为空，一般在调用带有 SQL SECURITY DEFINER 的视图或者是存储过程的情况下，会出现此问题。</li></ul><h3 id="9-MySQL-监控分析视图-sys-schema"><a href="#9-MySQL-监控分析视图-sys-schema" class="headerlink" title="9. MySQL 监控分析视图 - sys schema"></a>9. MySQL 监控分析视图 - sys schema</h3><p>关于 MySQL 的性能监控和问题诊断，我们一般都从 performance_schema 中去获取想要的数据，在 MySQL 5.7.7 版本中新增 sys schema，它将 performance_schema 和 information_schema 中的数据以更容易理解的方式总结归纳为视图，其目的就是为了降低查询 performance_schema 的复杂度，让 DBA 能够快速的定位问题。</p><h4 id="9-1-Sys-schema-视图摘要"><a href="#9-1-Sys-schema-视图摘要" class="headerlink" title="9.1 Sys schema 视图摘要"></a>9.1 Sys schema 视图摘要</h4><ul><li>主机相关：以 host_summary开头，主要汇总了 IO 延迟的信息。</li><li>Innodb 相关：以 innodb 开头，汇总了 innodb buffer 信息和事务等待 innodb 锁的信息。</li><li>I&#x2F;O 相关：以 io 开头，汇总了等待 I&#x2F;O、I&#x2F;O 使用量情况。</li><li>内存使用情况：以 memory 开头，从主机、县城、事件等角度展示内存的使用情况。</li><li>连接与会话信息：processlist 和 session 相关视图，总结了会话相关信息。</li><li>表相关：以 schema_table 开头的视图，展示了表的统计信息。</li><li>索引信息：统计了索引的使用情况，包含冗余索引和未使用的索引情况。</li><li>语句相关：以 statement 开头，包含了执行全表扫描、使用临时表、排序等的语句信息。</li><li>用户相关：以 user 开头的视图，统计了用户使用的文件 I&#x2F;O、执行语句统计信息。</li><li>等待事件相关信息：以 wait 开头，展示等待事件的延迟情况。</li></ul><h4 id="9-2-Sys-schema-视图使用场景"><a href="#9-2-Sys-schema-视图使用场景" class="headerlink" title="9.2 Sys schema 视图使用场景"></a>9.2 Sys schema 视图使用场景</h4><p><strong>索引情况</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查询冗余索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_redundant_indexes;</span><br><span class="line"></span><br><span class="line"># 查询未使用过的索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_unused_indexes;</span><br><span class="line"></span><br><span class="line"># 查询索引的使用情况</span><br><span class="line"><span class="keyword">select</span> index_name, rows_selected, rows_inserted, rows_updated, rows_deleted <span class="keyword">from</span> sys.schema_index_statistics <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>表相关</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查询表的访问量</span><br><span class="line"><span class="keyword">select</span> table_schema, table_name, <span class="built_in">sum</span>(io_read_requests<span class="operator">+</span>io_write_requests) <span class="keyword">as</span> io <span class="keyword">from</span> sys.schema_table_statistics <span class="keyword">group</span> <span class="keyword">by</span> table_schema, table_name <span class="keyword">order</span> <span class="keyword">by</span> io <span class="keyword">desc</span>;</span><br><span class="line"># 查询占用 bufferpool 较多的表</span><br><span class="line"><span class="keyword">select</span> object_schema, object_name, allocated, data <span class="keyword">from</span> sys.innodb_buffer_stats_by_table <span class="keyword">order</span> <span class="keyword">by</span> allocated limit <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># 查看表的全表扫描情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.statements_with_full_table_scans <span class="keyword">where</span> db<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>语句相关</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 监控 <span class="keyword">SQL</span> 执行的频率</span><br><span class="line"><span class="keyword">select</span> db, exec_count, query <span class="keyword">from</span> sys.statement_analysis <span class="keyword">order</span> <span class="keyword">by</span> exec_count <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"># 监控使用了排序的 <span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db, exec_count, first_seen, last_seen, query <span class="keyword">from</span> sys.statements_with_sorting limit <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># 监控使用了临时表或磁盘临时表的 <span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db, exec_count, tmp_tables, tmp_disk_tables, query <span class="keyword">from</span> sys.statement_analysis <span class="keyword">where</span> tmp_tables <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">or</span> tmp_disk_tables <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">order</span> <span class="keyword">by</span> (tmp_tables <span class="operator">+</span> tmp_disk_tables) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><strong>IO 相关</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看消耗磁盘 IO 的文件</span><br><span class="line"><span class="keyword">select</span> file, avg_read, avg_write, avg_read <span class="operator">+</span> avg_write <span class="keyword">as</span> avg_io <span class="keyword">from</span> sys.io_global_by_file_by_bytes <span class="keyword">order</span> <span class="keyword">by</span> avg_read limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>Innodb 相关</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 行锁阻塞情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure><blockquote><p>风险提示：</p><p>通过 sys 库去查询时，MySQL 会消耗大量资源去收集相关信息，严重的可能会导致业务请求被阻塞，从而引起故障。建议生产上不要频繁的去查询 sys 或者 performance_schema、information_schema 来完成监控、巡检等工作。</p></blockquote><h2 id="八、索引优化与查询优化"><a href="#八、索引优化与查询优化" class="headerlink" title="八、索引优化与查询优化"></a>八、索引优化与查询优化</h2><p>都有哪些维度可以进行数据库调优？简言之：</p><ul><li>索引失效、没有充分利用到索引——索引建立</li><li>关联查询太多 JOIN (设计缺陷或不得已的需求) ——SQL 优化</li><li>服务器调优及各个参数设置 (缓冲、线程数等)——调整 my.cnf</li><li>数据过多——分库分表</li></ul><p>SQL 查询优化的技术大致可以分成物理查询优化和逻辑查询优化两大块。</p><ul><li>物理查询优化是通过索引和表连接方式等技术来进行优化，这里重点需要掌握索引的使用。</li><li>逻辑查询优化就是通过 SQL 等价变换提升查询效率，直白一点就是说，换一种查询写法执行效率可能更高。</li></ul><h3 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1. 数据准备"></a>1. 数据准备</h3><h4 id="1-1-建表"><a href="#1-1-建表" class="headerlink" title="1.1 建表"></a>1.1 建表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> class(</span><br><span class="line">id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  className <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  address <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  monitor <span class="type">INT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  stuno <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  age <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  classId <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">  # <span class="keyword">CONSTRAINT</span> fk_class_id <span class="keyword">FOREIGN</span> KEY (classId) <span class="keyword">REFERENCES</span> t_class (id)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><h4 id="1-2-设置参数"><a href="#1-2-设置参数" class="headerlink" title="1.2 设置参数"></a>1.2 设置参数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 开启允许创建函数设置：</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="1-3-创建函数"><a href="#1-3-创建函数" class="headerlink" title="1.3 创建函数"></a>1.3 创建函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 生成随机字符串</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>)#该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line"><span class="keyword">SET</span> return_str <span class="operator">=</span> CONCAT(return_str, <span class="built_in">SUBSTRING</span>(chars_str, <span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> RAND() <span class="operator">*</span> <span class="number">52</span>), <span class="number">1</span>));</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 生成随机班级编号</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num(from_num <span class="type">INT</span>, to_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span> RAND() <span class="operator">*</span> (to_num <span class="operator">-</span> from_num <span class="operator">+</span> <span class="number">1</span>));</span><br><span class="line"><span class="keyword">RETURN</span> i;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 删除函数</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> 函数名;</span><br></pre></td></tr></table></figure><h4 id="1-4-创建存储过程"><a href="#1-4-创建存储过程" class="headerlink" title="1.4 创建存储过程"></a>1.4 创建存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 创建往 stu 表中插入数据的存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_stu(<span class="keyword">START</span> <span class="type">INT</span>, max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;    # 设置手动提交事物</span><br><span class="line">REPEAT      # 循环</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;    # 赋值</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (stuno, name, age, classId) <span class="keyword">VALUES</span></span><br><span class="line">((<span class="keyword">START</span> <span class="operator">+</span> i), rand_string(<span class="number">6</span>), rand_num(<span class="number">1</span>, <span class="number">50</span>), rand_num(<span class="number">1</span>, <span class="number">1000</span>));</span><br><span class="line">UNTIL i <span class="operator">=</span> max_num</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br><span class="line"><span class="keyword">COMMIT</span>;# 提交事物</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 往 class 表中插入数据的存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_class(max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;    # 设置手动提交事物</span><br><span class="line">REPEAT      # 循环</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;    # 赋值</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class (classname, address, monitor) <span class="keyword">VALUES</span></span><br><span class="line">(rand_string(<span class="number">8</span>), rand_string(<span class="number">10</span>), rand_num(<span class="number">1</span>, <span class="number">100000</span>));</span><br><span class="line">UNTIL i <span class="operator">=</span> max_num</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br><span class="line"><span class="keyword">COMMIT</span>;# 提交事物</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 删除存储过程</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> 存储过程名;</span><br></pre></td></tr></table></figure><h4 id="1-5-调用存储过程"><a href="#1-5-调用存储过程" class="headerlink" title="1.5 调用存储过程"></a>1.5 调用存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 向 class 表中添加一万条数据</span><br><span class="line"><span class="keyword">CALL</span> insert_class(<span class="number">10000</span>);</span><br><span class="line"># 向 stu 表中添加 <span class="number">50</span> 万条数据</span><br><span class="line"><span class="keyword">CALL</span> insert_stu(<span class="number">100000</span>, <span class="number">500000</span>);</span><br></pre></td></tr></table></figure><h4 id="1-6-删除某表上的索引"><a href="#1-6-删除某表上的索引" class="headerlink" title="1.6 删除某表上的索引"></a>1.6 删除某表上的索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc_drop_index(dbname <span class="type">VARCHAR</span>(<span class="number">200</span>), tablename <span class="type">VARCHAR</span>(<span class="number">200</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> ct <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> _index <span class="type">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> _cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> index_name <span class="keyword">FROM</span> information_schema.STATISTICS <span class="keyword">WHERE</span> table_schema<span class="operator">=</span>dbname <span class="keyword">AND</span> table_name<span class="operator">=</span>tablename <span class="keyword">AND</span> seq_in_index<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> index_name <span class="operator">&lt;&gt;</span> <span class="string">&#x27;PRIMARY&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">set</span> done <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">OPEN</span> _cur;</span><br><span class="line">    <span class="keyword">FETCH</span> _cur <span class="keyword">INTO</span> _index;</span><br><span class="line">    WHILE _index<span class="operator">&lt;&gt;</span><span class="string">&#x27;&#x27;</span> DO</span><br><span class="line">      <span class="keyword">SET</span> <span class="variable">@str</span> <span class="operator">=</span> CONCAT(&quot;drop index &quot;, _index, &quot; on &quot;, tablename);</span><br><span class="line">      <span class="keyword">PREPARE</span> sql_str <span class="keyword">FROM</span> <span class="variable">@str</span>;</span><br><span class="line">      <span class="keyword">EXECUTE</span> sql_str;</span><br><span class="line">      <span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> sql_str;</span><br><span class="line">      <span class="keyword">SET</span> _index<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="keyword">FETCH</span> _cur <span class="keyword">INTO</span> _index;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">CLOSE</span> _cur;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line"><span class="keyword">CALL</span> proc_drop_index(&quot;dbname&quot;, &quot;tablename&quot;);</span><br></pre></td></tr></table></figure><h3 id="2-索引失效案例"><a href="#2-索引失效案例" class="headerlink" title="2. 索引失效案例"></a>2. 索引失效案例</h3><p>MySQL 中提高性能的一个最有效的方式是对数据表设计合理的索引。索引提供了高效访问数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。</p><ul><li>使用索引可以快速地定位表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。</li><li>如果查询时没有使用索引，查询语句就会扫描表中的所有记录。在数据量大的情况下，这样查询的速度会很慢。</li></ul><p>大多数情况下都 (默认) 采用 B+ 树来构建索引。只是空间列类型的索引使用 R-树，并且 MEMORY 表还支持 hash 索引。</p><p>其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？给予 cost 开销 (CostBaseOptimizer)，它不是基于规则 (Rule-BasedOptimizer)，也不是基于语义。怎么样开销小就怎么来。另外，SQL 语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</p><h4 id="2-1-全值匹配"><a href="#2-1-全值匹配" class="headerlink" title="2.1 全值匹配"></a>2.1 全值匹配</h4><p>系统中经常出现的 SQL 语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> classId <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> classId <span class="operator">=</span> <span class="number">4</span> <span class="keyword">AND</span> `NAME` <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure><p>建立索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age <span class="keyword">ON</span> student(age);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid <span class="keyword">ON</span> student(age, classId);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student(age, classId, name);</span><br></pre></td></tr></table></figure><p>创建索引前的查询时间是 0.137s，创建索引后的查询时间是 0.001s。</p><h4 id="2-2-最佳左前缀法则"><a href="#2-2-最佳左前缀法则" class="headerlink" title="2.2 最佳左前缀法则"></a>2.2 最佳左前缀法则</h4><p>在 MySQL 建立联合索引时，会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> student.`name` <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.classId <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> student.`name` <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.classId <span class="operator">=</span> <span class="number">4</span> <span class="keyword">AND</span> student.age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> student.`name` <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure><p>MySQL 可以为多个字段创建索引，一个索引可以包括 16 个字段。对于多列索引，<strong>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用</strong>。如果查询条件中没有使用这些字段中第一个字段时，多列或联合索引不会被使用。</p><blockquote><p>拓展：Alibaba《Java 开发手册》</p><p>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p></blockquote><h4 id="2-3-主键插入顺序"><a href="#2-3-主键插入顺序" class="headerlink" title="2.3 主键插入顺序"></a>2.3 主键插入顺序</h4><p>对于一个使用 InnoDB 存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在 1～100 之间，如果此时再插入一条主键值为 9 的记录，那它插入的位置在 8 和 10 之间，但是这个数据页已经满了，再插进来就需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着性能损耗。所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值一次递增，这样就不会发生这样的性能损耗了。所以建议：让主键具有 AUTO_INCREMENT，让存储引擎自己为表生成主键，而不是我们手动插入。</p><p>我们自定义的主键列 id 拥有 AUTO_INCREMENT 属性，再插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。</p><h4 id="2-4-计算、函数、类型转换到值索引失效"><a href="#2-4-计算、函数、类型转换到值索引失效" class="headerlink" title="2.4 计算、函数、类型转换到值索引失效"></a>2.4 计算、函数、类型转换到值索引失效</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.`name` <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(student.`name`, <span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> index idx_name <span class="keyword">ON</span> student(name);</span><br></pre></td></tr></table></figure><p>上面两个 SQL，第一个索引生效，第二个索引失效。</p><h4 id="2-5-类型转换到值索引失效"><a href="#2-5-类型转换到值索引失效" class="headerlink" title="2.5 类型转换到值索引失效"></a>2.5 类型转换到值索引失效</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="number">123</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_name      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_name      <span class="operator">|</span> idx_name <span class="operator">|</span> <span class="number">63</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure><p>student 表中 name 字段是字符串类型，第一个 SQL 在执行时，会隐式将 name 转换成 整形，所以会导致索引失效。</p><blockquote><p>设计实体类属性时，一定要与数据库字段类型相对应。否则，就会出现类习惯转换的情况。</p></blockquote><h4 id="2-6-范围条件右边的列索引失效"><a href="#2-6-范围条件右边的列索引失效" class="headerlink" title="2.6 范围条件右边的列索引失效"></a>2.6 范围条件右边的列索引失效</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student(age, classId, name);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> classId <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">AND</span> `NAME` <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+-------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys        <span class="operator">|</span> key                  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+-------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_age_classid_name <span class="operator">|</span> idx_age_classid_name <span class="operator">|</span> <span class="number">10</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">19008</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+-------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure><p>根据 key_len 可以看出该 SQL 只用到了联合索引的 age 和 classId，name 并没有用到。范围条件：&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 和 between 等。</p><p>在实际开发中，将范围查询条件防止语句最后，建索引时，也将该字段放置在最后。</p><blockquote><p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置 where 语句最后。</p></blockquote><h4 id="2-7-不等于-x3D-或-lt-gt-索引失效"><a href="#2-7-不等于-x3D-或-lt-gt-索引失效" class="headerlink" title="2.7 不等于 (!&#x3D; 或 &lt;&gt;) 索引失效"></a>2.7 不等于 (!&#x3D; 或 &lt;&gt;) 索引失效</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> `NAME` <span class="operator">&lt;&gt;</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_name      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">50.15</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure><h4 id="2-8-IS-NULL-可以使用索引，IS-NOT-NULL-无法使用索引"><a href="#2-8-IS-NULL-可以使用索引，IS-NOT-NULL-无法使用索引" class="headerlink" title="2.8 IS NULL 可以使用索引，IS NOT NULL 无法使用索引"></a>2.8 IS NULL 可以使用索引，IS NOT NULL 无法使用索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys        <span class="operator">|</span> key                  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_age_classid_name <span class="operator">|</span> idx_age_classid_name <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys        <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_age_classid_name <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">50.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure><blockquote><p>结论：最好在设计数据表的时候就将字段设置为 NOT NULL 约束，比如你可以将 INT 类型的字段，默认值设置为 0。将字符类型的默认值设置为空字符串 (‘’)。</p><p>拓展：同理，在查询中使用 NOT LIKE 也无法使用索引，到值全表扫描。</p></blockquote><h4 id="2-9-like-以通配符-开头索引失效"><a href="#2-9-like-以通配符-开头索引失效" class="headerlink" title="2.9 like 以通配符 % 开头索引失效"></a>2.9 like 以通配符 % 开头索引失效</h4><p>在使用 LIKE 关键字进行查询的查询语句中，如果匹配字符串的第一个字符为 %，索引就不会起作用。只有 % 不在第一个位置，索引才会起作用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.`name` <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_name      <span class="operator">|</span> idx_name <span class="operator">|</span> <span class="number">63</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.`name` <span class="keyword">LIKE</span> <span class="string">&#x27;%abc&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">11.11</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure><blockquote><p>拓展：Alibaba《Java 开发手册》</p><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p></blockquote><h4 id="2-10-OR-前后存在非索引的列，索引失效"><a href="#2-10-OR-前后存在非索引的列，索引失效" class="headerlink" title="2.10 OR 前后存在非索引的列，索引失效"></a>2.10 OR 前后存在非索引的列，索引失效</h4><p>在 WHERE 字句中，如果在 OR 前的条件列进行了索引，而在 OR 后的条件列没有进行索引，那么索引会失效。也就是说，OR 前后的两个条件中的列都是索引时，查询中才使用索引。</p><p>因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列进行了索引是没有意义的，只要有条件列没有进行索引，就会进行全表扫描，因此索引的条件列也会失效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age <span class="keyword">ON</span> student(age);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">OR</span> classId <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_age       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">11.88</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> index idx_cid <span class="keyword">ON</span> student(classId);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------------+-----------------+-----------------+---------+------+-------+----------+-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type        <span class="operator">|</span> possible_keys   <span class="operator">|</span> key             <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------------+-----------------+-----------------+---------+------+-------+----------+-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index_merge <span class="operator">|</span> idx_age,idx_cid <span class="operator">|</span> idx_age,idx_cid <span class="operator">|</span> <span class="number">5</span>,<span class="number">5</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10232</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">union</span>(idx_age,idx_cid); <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------------+-----------------+-----------------+---------+------+-------+----------+-------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>当只在 age 字段上建立索引时，会导致索引失效。如果再给 classId 字段建立索引，此时就可以使用索引。</p><h4 id="2-11-数据库和表的字符集统一使用-utf8mb4"><a href="#2-11-数据库和表的字符集统一使用-utf8mb4" class="headerlink" title="2.11 数据库和表的字符集统一使用 utf8mb4"></a>2.11 数据库和表的字符集统一使用 utf8mb4</h4><p>统一使用 utf8mb4兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换会造成索引失效。</p><h4 id="2-12-建议"><a href="#2-12-建议" class="headerlink" title="2.12 建议"></a>2.12 建议</h4><ul><li>对于单列索引，尽量选择针对当前 query 过滤性更好的索引。</li><li>在选择组合索引的时候，当前 query 中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>在选择组合索引的时候，尽量选择能够包含当前 query 中的 where 子句中更多字段的索引。</li><li>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。</li></ul><p>总之，书写 SQL 语句时，尽量避免造成索引失效的情况。 </p><h3 id="3-关联查询优化"><a href="#3-关联查询优化" class="headerlink" title="3. 关联查询优化"></a>3. 关联查询优化</h3><h4 id="3-1-数据准备-1"><a href="#3-1-数据准备-1" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 分类表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `type`(</span><br><span class="line">id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  card <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"># 图书表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> book(</span><br><span class="line">bookId <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  card <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (bookId)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 向分类表中插入 <span class="number">20</span> 条记录</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TYPE(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"></span><br><span class="line"># 向图书表中插入 <span class="number">20</span> 条记录</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br></pre></td></tr></table></figure><h4 id="3-2-采用左外连接"><a href="#3-2-采用左外连接" class="headerlink" title="3.2 采用左外连接"></a>3.2 采用左外连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> `type` <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card <span class="operator">=</span> book.card; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> type  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> book  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">join</span> buffer (hash <span class="keyword">join</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX x <span class="keyword">ON</span> book(card);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> type  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> book  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> x             <span class="operator">|</span> x    <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> mysql_test.type.card <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX y <span class="keyword">ON</span> `type`(card);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> type  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> y    <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> book  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> x             <span class="operator">|</span> x    <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> mysql_test.type.card <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><h4 id="3-3-采用内连接"><a href="#3-3-采用内连接" class="headerlink" title="3.3 采用内连接"></a>3.3 采用内连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> `type` <span class="keyword">INNER</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card <span class="operator">=</span> book.card; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> type  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> book  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">join</span> buffer (hash <span class="keyword">join</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX y <span class="keyword">ON</span> `type`(card);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> book  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> type  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> y             <span class="operator">|</span> y    <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> mysql_test.book.card <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX x <span class="keyword">ON</span> book(card);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> book  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> x             <span class="operator">|</span> x    <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                 <span class="operator">|</span>   <span class="number">20</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> type  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> y             <span class="operator">|</span> y    <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> mysql_test.book.card <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+----------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>从上述可以得出一下结论：对于内连接来说，查询优化器可以决定谁来作为驱动表，谁作为被驱动表。如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表。<strong>当表的连接条件中都没有索引 (或都有索引) 时，数据小的表驱动数据大的表</strong>。</p><h4 id="3-4-JOIN-语句原理"><a href="#3-4-JOIN-语句原理" class="headerlink" title="3.4 JOIN 语句原理"></a>3.4 JOIN 语句原理</h4><p>JOIN 方式连接多表，本质就是各个表之间数据的循环匹配。MySQL5.5 版本之前，MySQL 只支持一种表间关联方式，就是嵌套循环。如果关联表的数据量很大，则 JOIN 关联的执行时间会非常长。在 MySQL 5.5 以后的版本中，MySQL 通过引入 BNLJ 算法来优化嵌套执行。</p><p><strong>驱动表和被驱动表</strong></p><p>驱动表就是主表，被驱动表就是从表、非驱动表。</p><ul><li><p>对于内连接来说：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">JOIN</span> B <span class="keyword">ON</span> ...</span><br></pre></td></tr></table></figure><p>  对于内连接来说 A 不一定是驱动表，优化器会根据你查询语句做优化，决定先查哪张表。先查询的那张表就是驱动表，反之就是被驱动表。通过 explain 关键字可以查看。</p></li><li><p>对于外连接来说：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> ...</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> B <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> A <span class="keyword">ON</span> ...</span><br></pre></td></tr></table></figure><p>  通常，会认为 A 就是驱动表，B 就是被驱动表。但也未必。 对于外连接来说，查询优化器可能会将外连接修改为内连接，对于内连接，主从表就会不确定。</p></li></ul><p><strong>简单嵌套循环连接 (Simple Nested-Loop Join)</strong></p><p>算法相当简单，从表 A 中取出一条数据 1，遍历表 B，将匹配到的数据放到 result..以此类推，驱动表 A 中的每一条记录与被驱动表 B 的记录进行判断：</p><p><img src="http://1.117.162.142:9000/blog/%E7%AE%80%E5%8D%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5.png" alt="简单嵌套循环连接"></p><p>可以看到这种方式效率是非常低的，以上述表 A 数据 100 条，表 B 数据 1000 条计算，则 A * B &#x3D; 10 万次。开销统计如下：</p><table><thead><tr><th>开销统计</th><th>SNLJ</th></tr></thead><tbody><tr><td>外表扫描次数</td><td>1</td></tr><tr><td>内表扫描次数</td><td>A</td></tr><tr><td>读取记录数</td><td>A + B * A</td></tr><tr><td>JOIN 比较次数</td><td>A * B</td></tr><tr><td>回表读取记录次数</td><td>0</td></tr></tbody></table><p>当然 MySQL 不会这么粗暴的区进行表的连接，所以就出现了后面的两种对 Nested-Loop Join 优化算法。</p><p><strong>索引嵌套循环连接 (Index Nested-Loop Join)</strong></p><p>Index Nested-Loop Join 其优化的思路主要是为了减少内层表数据的匹配次数，所以要求被驱动表上必须有索引才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去比较，这样极大的减少了对内层表的匹配次数。</p><p><img src="http://1.117.162.142:9000/blog/%E7%B4%A2%E5%BC%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5.png" alt="索引嵌套循环连接"></p><p>驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故 MySQL 优化器都倾向于使用记录数少的表作为驱动表。</p><table><thead><tr><th>开销统计</th><th>SNLJ</th><th>INLJ</th></tr></thead><tbody><tr><td>外表扫描次数</td><td>1</td><td>1</td></tr><tr><td>内表扫描次数</td><td>A</td><td>0</td></tr><tr><td>读取记录数</td><td>A + B * A</td><td>A + B(match)</td></tr><tr><td>JOIN 比较次数</td><td>A * B</td><td>A * Index(Height)</td></tr><tr><td>回表读取记录次数</td><td>0</td><td>B(match)(if possible)</td></tr></tbody></table><p>如果被驱动表家索引，效率是非常高的，但如果索引不是主键索引，所以还的进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高。</p><p><strong>块嵌套循环连接 (Block Nested-Loop Join)</strong></p><p>如果存在索引，那么会使用 index 的方式进行 join，如果 join 的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把驱动表的记录再加载到内存匹配，这样周而复始，大大增加了IO 的次数。为了减少被驱动表的 IO 次数，就出现了 Block Nested-Loop Join 的方式。</p><p>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了 join buffer 缓冲区，将驱动表 join 相关的部分数据列 (大小受 join buffer 的限制) 缓存到 join buffer 中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和 join buffer 中的所有驱动表记录进行匹配 (内存中操作)，将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</p><blockquote><p>注意：</p><p>这里缓存的不只是关联表的列，select 后面的列也会缓存起来。</p><p>在一个有 N 个 join 关联的 SQL 中会分配 N - 1 个 join buffer。所以查询的时候尽量减少不必要的字段，可以让 join buffer 中可以存放更多的列。</p></blockquote><p><img src="http://1.117.162.142:9000/blog/%E5%9D%97%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5.png" alt="块嵌套循环连接"></p><table><thead><tr><th>开销统计</th><th>SNLJ</th><th>INLJ</th><th>BNLJ</th></tr></thead><tbody><tr><td>外表扫描次数</td><td>1</td><td>1</td><td>1</td></tr><tr><td>内表扫描次数</td><td>A</td><td>0</td><td>A * used_column_size &#x2F; join_buffer_size + 1</td></tr><tr><td>读取记录数</td><td>A + B * A</td><td>A + B(match)</td><td>A + B * (A * used_column_size &#x2F; join_buffer_size)</td></tr><tr><td>JOIN 比较次数</td><td>B * A</td><td>A * Index(Height)</td><td>B * A</td></tr><tr><td>回表读取记录次数</td><td>0</td><td>B(match)(if possible)</td><td>0</td></tr></tbody></table><p>参数设置：</p><ul><li><p>block_nested_loop</p><p>  通过 <code>show variables like &#39;%optimizer_switch%&#39;</code> 查看 <code>block_nested_loop</code> 状态。默认是开启的。</p></li><li><p>join_buffer_size</p><p>  驱动表能不能一次加载完，要看 join buffer 能不能存储所有的数据，默认情况下 <code>join_buffer_size=256k</code>。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%join_buffer%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> join_buffer_size <span class="operator">|</span> <span class="number">262144</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+--------+</span></span><br></pre></td></tr></table></figure><p>  Join_buffer_size 的最大值在 32 位系统可以申请 4G，而在 64 位操作系统下可以申请大于 4G 的 Join Buffer 空间 (64 位 Windows 除外，其大值会被截断位 4GB 并发出警告)。</p></li></ul><p><strong>Join 小结</strong></p><ul><li><p>整体效率比较：INLJ &gt; BNLJ &gt; SNLJ </p></li><li><p>永远用小结果集驱动大结果集 (其本质就是减少外层循环的数据数量) (小的度量单位指的是表行数 * 每行大小)</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.b, t2.<span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.b <span class="operator">=</span> t2.b) <span class="keyword">where</span> t2.id <span class="operator">&lt;=</span> <span class="number">100</span>;  # 推荐</span><br><span class="line"><span class="keyword">select</span> t1.b, t2.<span class="operator">*</span> <span class="keyword">from</span> t2 straight_join t1 <span class="keyword">on</span> (t1.b <span class="operator">=</span> t2.b) <span class="keyword">where</span> t2.id <span class="operator">&lt;=</span> <span class="number">100</span>;  # 不推荐</span><br></pre></td></tr></table></figure></li><li><p>为被驱动表匹配的条件增加索引 (减少内层表的循环匹配次数)</p></li><li><p>增大 join buffer size 的大小 (一次缓存的数据越多，那么内层包的扫表次数就越少)</p></li><li><p>减少驱动表不必要的字段查询 (字段越少，join buffer 所缓存的数据就越多)</p></li></ul><p><strong>Hash Join</strong></p><p>从 MySQL 的 8.0.20 版本开始将废弃 BNLJ，因为从 MySQL 8.0.18 版本开始就加入了 hash join 默认都会使用 hash join</p><ul><li><p>Nested Loop：</p><p>  对于被连接的数据子集较小的情况，Nested Loop 是个较好的选择。</p></li><li><p>Hash Join 是做大数据集连接时常用方式，优化器使用两个表中较小 (相对较小) 的表利用 Join Key 在内存中建立散列表，然后扫描较大的表并探测散列表，找出与 Hash 表匹配的行。</p><ul><li>这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。</li><li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高 I&#x2F;O 的性能。</li><li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是 Join 的重型升降机。Hash Join 只能应用于等值连接 (如 WHERE a .col1 &#x3D; b.col2)，这是由 Hash 的特点决定的。</li></ul><table><thead><tr><th>类别</th><th>Nested Loop</th><th>Hash Join</th></tr></thead><tbody><tr><td>使用条件</td><td>任何条件</td><td>等值连接 (&#x3D;)</td></tr><tr><td>相关资源</td><td>CPU、磁盘 I&#x2F;O</td><td>内存、临时空间</td></tr><tr><td>特点</td><td>当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果。</td><td>当缺乏索引或者索引条件模糊时，Hash Join 比 Nested Loop 有效。在数据仓库环境下，如果表的记录数多，效率高</td></tr><tr><td>缺点</td><td>当索引失去或者查询条件限制不够时，效率很低；当表的记录数多时，效率低。</td><td>为建立哈希表，需要大量内存。第一次的结果返回较慢。</td></tr></tbody></table></li></ul><h4 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h4><ul><li>保证被驱动表的 JOIN 字段已经创建了索引</li><li>需要 JOIN 的字段，数据类型保持绝对一致</li><li>LEFT JOIN 时，选择小表作为驱动表，大表作为被驱动表。减少外层循环的次数。</li><li>INNER JOIN 时，MySQL 会自动将小结果集的表选为驱动表。选择相信 MySQL 优化策略。</li><li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</li><li>不建议使用子查询，建议将子查询 SQL 拆开结合程序多次查询或使用 JOIN 来代替子查询。</li><li>衍生表建不了索引</li></ul><h3 id="4-子查询优化"><a href="#4-子查询优化" class="headerlink" title="4. 子查询优化"></a>4. 子查询优化</h3><p>MySQL 从 4.1 版本开始支持子查询，使用子查询可以进行 SELECT 语句的嵌套查询，记一个 SELECT 查询的结果作为另一个 SELECT 语句的条件。子查询可以一次性完成很多逻辑上需要多个步骤才能完成的 SQL 操作。</p><p>子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子查询的执行效率不高。原因：</p><ul><li>执行子查询时，MySQL 需要为内层查询语句的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</li><li>子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引，索引查询性能会受到一定的影响。</li><li>对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</li></ul><p>在 MySQL 中，可以使用连接 (JOIN) 查询来替代子查询。连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引的话，性能就会更好。</p><blockquote><p>尽量不要使用 NOT IN 或者 NOT EXISTS，用 LEFT JOIN xxx ON xx WHERE xx IS NULL 替代。</p></blockquote><h3 id="5-排序优化"><a href="#5-排序优化" class="headerlink" title="5. 排序优化"></a>5. 排序优化</h3><p><strong>问题</strong>：在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？</p><p>在 MySQL 中，支持两种排序方式，分别是 FileSort 和 Index 排序。</p><ul><li>Index 排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高。</li><li>FileSort 排序规则一般在内存中进行排序，占用 CPU 较多。如果待排结果较大，会产生临时文件 I&#x2F;O 到磁盘进行排序的情况，效率较低。</li></ul><p><strong>优化建议</strong>：</p><ul><li>SQL 中。可以在 WHERE 字句和 ORDER BY 字句中使用索引，目的是在 WHERE 字句中避免全表扫描，在 ORDER BY 字句避免使用 FileSort 排序。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</li><li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。</li><li>无法使用 Index 时，需要对 FileSort 方式进行调优。</li></ul><p><strong>测试</strong></p><p>先删除 student 和 class 表创建的索引。<code>CALL proc_drop_index(&#39;mysql_test&#39;, &#39;student&#39;)</code>、<code>CALL proc_drop_index(&#39;mysql_test&#39;, &#39;class&#39;)</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 创建索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classId_name <span class="keyword">ON</span> student (age, classId, name);</span><br><span class="line"># <span class="keyword">ORDER</span> <span class="keyword">BY</span> 时不 LIMIT，索引失效</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age, classId;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age, classId LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">ORDER</span> <span class="keyword">BY</span> 时顺序错误，索引失效</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classId_stuno <span class="keyword">ON</span> student (age, classId, stuno);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> classId LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> classId, `NAME` LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age, classId, stuno LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age, classId LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">ORDER</span> <span class="keyword">BY</span> 时规则不一致，索引失效 (顺序错，不索引；方向反，不索引)</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>, classId <span class="keyword">ASC</span> LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> classId <span class="keyword">DESC</span>, `NAME` <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span>, classId <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>, classId <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"># 无过滤，不索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> classId;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> classId, `NAME`;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> classId <span class="operator">=</span> <span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> classId <span class="operator">=</span> <span class="number">45</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">INDEX a_b_c(a, b, c)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 能使用索引最左前缀</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a, b</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a, b, c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">DESC</span>, B <span class="keyword">DESC</span>, c <span class="keyword">DESC</span></span><br><span class="line"></span><br><span class="line">如果 <span class="keyword">WHERE</span> 使用索引的最左前缀定义为常量，则 <span class="keyword">order</span> <span class="keyword">by</span> 能使用索引</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">AND</span> b<span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">AND</span> b <span class="operator">&gt;</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c</span><br><span class="line"></span><br><span class="line">不能使用索引进行排序</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">ASC</span>, b <span class="keyword">DESC</span>, c <span class="keyword">DESC</span># 排序不一致</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> g <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c# 丢失 a 索引</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> c # 丢失 b 索引</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> a, d# d 不是索引的一部分</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="keyword">IN</span> (...) <span class="keyword">ORDER</span> <span class="keyword">BY</span> b, c# 对于排序来说，多个相等条件也是范围查询</span><br></pre></td></tr></table></figure><p><strong>实战</strong></p><p>清空索引。查询年龄为 30 岁的，且学生编号小雨 101000 的学生，按用户名称排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span> <span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `NAME`; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>     <span class="number">3.33</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-----------------------------+</span></span><br></pre></td></tr></table></figure><p>结果是 type 为 ALL，Extra 还出现了 Using FIleSort，都是最坏的情况。所以必须优化。</p><p><strong>方案一：为了去掉 filesort 可以把所有建成</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_name <span class="keyword">ON</span> student(age, NAME);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span> <span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `NAME`; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+--------------+---------+-------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+--------------+---------+-------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_age_name  <span class="operator">|</span> idx_age_name <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> const <span class="operator">|</span> <span class="number">18544</span> <span class="operator">|</span>    <span class="number">33.33</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+--------------+---------+-------+-------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p><strong>方案二：尽量让 WHERE 的过滤条件和排序使用上索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 建立一个三个字段的组合索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_stuno_name <span class="keyword">ON</span> student (age, stuno, NAME);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span> <span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> `NAME`; </span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------------------------+--------------------+---------+------+------+----------+---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys                   <span class="operator">|</span> key                <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------------------------+--------------------+---------+------+------+----------+---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_age_name,idx_age_stuno_name <span class="operator">|</span> idx_age_stuno_name <span class="operator">|</span> <span class="number">9</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">19</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span>; <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------------------------+--------------------+---------+------+------+----------+---------------------------------------+</span></span><br></pre></td></tr></table></figure><p>现在发现 Using FileSort 依然存在，索引 name 并没有使用到索引，而且 type 还是 range，光看字面其实并不美好。原因是，因为 stuno 是一个范围过滤，所以索引后面的字段不会再使用索引了。</p><p>结果竟然有 filesort 的 SQL 运行速度，超过了已经优化掉 filesort 的 SQL，而且快了很多，几乎一瞬间就出现了结果。</p><p>原因：所有的排序都是在条件过滤之后才执行的。所以，如果条件过滤掉大部分数据的话，剩下几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序，但实际提升性能很有限。相对 stuno &lt; 101000 这个条件，如果没有用到索引的话，要对几万条的数据进行扫描，这时非常消耗性能的，索引放在这个字段上性价比最高，是最优选择。</p><blockquote><p>结论：</p><ul><li>两个索引同时存在，MySQL 自动选择最优方案。 (对于这个例子，MySQL 选择 idx_age_stuno_name)。但是，随着数据量的变化 ，选择的索引也会随之变化的。</li><li>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</li></ul></blockquote><p><strong>FileSort 算法</strong></p><p>排序的字段如果不在索引列上，则 FileSort 会有两种算法：双路排序和单路排序</p><ul><li><p>双路排序 (慢)</p><p>  MySQL 4.1 之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据，读取行指针和 order by 列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出。从磁盘去排序字段，在 buffer 进行排序，再从磁盘去其他字段。取一批数据，要对磁盘进行两次扫描，总所周知，IO 是很耗时的，索引在 MySQL 4.1 之后，出现了第二种改进的算法，就是单路排序。</p></li><li><p>单路排序 (快)</p><p>  从磁盘读取查询需要的所有列，按照order by 列在 buffer 对他们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机 IO 变成了顺序 IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。</p></li></ul><p><strong>结果及引申出的问题</strong></p><ul><li>由于单路是后出，总体而言好过双路</li><li>但是用单路有问题<ul><li>在 sort_buffer 中，单路比多路要多占用很多空间，因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了 sort_buffer 的容量，导致每次只能取 sort_buffer 容量大小的数据，进行排序 (创建 tmp 文件，多路合并)，排完再取 sort_buffer 容量大小，再排……从而多次 I&#x2F;O。</li><li>单路本来想省一次 I&#x2F;O 操作，反而 导致了大量的 I&#x2F;O 操作，反而得不偿失。</li></ul></li></ul><p><strong>优化策略</strong></p><ul><li><p>尝试提高 sort_buffer_size</p><p>  不管用哪种算法，提高这个参数都会提高效率，要根据系统的能力去提高，因为这个参数是针对每个进程 (connection) 的 1M-8M 之间调整。MySQL 5.7，InnoDB 存储引擎默认值是 1048576 字节，1MB。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%sort_buffer_size%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name           <span class="operator">|</span> <span class="keyword">Value</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> innodb_sort_buffer_size <span class="operator">|</span> <span class="number">1048576</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> myisam_sort_buffer_size <span class="operator">|</span> <span class="number">8388608</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sort_buffer_size        <span class="operator">|</span> <span class="number">262144</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+---------+</span></span><br></pre></td></tr></table></figure></li><li><p>尝试提高 max_length_for_sort_data</p><p>  提高这个参数，会增加用改进算法的概率。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%max_length_for_sort_data%&#x27;</span>;# 默认 <span class="number">1024</span> 字节</span><br></pre></td></tr></table></figure><p>  但是如果设的太高，数据总容量超出 sort_buffer_size 的概率就增大，明显症状是高的磁盘 I&#x2F;O 活动和低的处理器使用率。如果需要返回的列的总长度大于 max_length_for_sort_data，使用双路算法，否则使用单路算法。1024-8192 字节之间调整。</p></li><li><p>ORDER BY 时 SELECT * 是一个大忌。最好只 QUERY 需要的字段。</p><p>  当 QUERY 的字段大小总和小于 max_length_for_sort_data，而且排序字段不是 TEXT｜BLOB 类型时，会用改进后的算法——单路排序，否则用老算法——多路排序。</p><p>  两种算法的数据都有可能超出 sort_buffer_size 的容量，超出之后，会创建 tmp 文件进行合并排序，导致多次 I&#x2F;O，但是用单路排序算法的风险风大一些，所以要提高 sort_buffer_size。</p></li></ul><h3 id="6-GROUP-BY-优化"><a href="#6-GROUP-BY-优化" class="headerlink" title="6.GROUP BY 优化"></a>6.GROUP BY 优化</h3><ul><li>group by 使用索引的原则几乎跟 order by 一致，group by 即使没有过滤条件使用到索引，也可以直接使用索引。</li><li>group by 先排序再分组，遵照索引建的最佳左前缀原则</li><li>当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置</li><li>where 效率高于 having，能写在 where 限定的条件就不要写在 having 中了</li><li>减少使用 order by，和业务沟通能不排序就不排序，或将排序当道程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费 CPU，数据库的 CPU 资源是极其宝贵的</li><li>包含了 ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在 1000 行以内，否则 SQL 会很慢</li></ul><h3 id="7-优化分页查询"><a href="#7-优化分页查询" class="headerlink" title="7. 优化分页查询"></a>7. 优化分页查询</h3><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000，10，此时需要 MySQL 排序前 2000010 记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LIMIT <span class="number">2000000</span>, <span class="number">10</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------+</span></span><br></pre></td></tr></table></figure><p><strong>优化思路一</strong></p><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student t, (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">2000000</span>, <span class="number">10</span>) a <span class="keyword">WHERE</span> t.id <span class="operator">=</span> a.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+--------+---------------+---------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+--------+---------------+---------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> <span class="operator">&lt;</span>derived2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> t          <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> a.id <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> student    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+--------+---------------+---------+---------+------+--------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p><strong>优化思路二</strong></p><p>该方案适用于主键自增的表，可以把 LIMIT 查询转换成某个位置的查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">2000000</span> LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><h3 id="8-优先考虑覆盖索引"><a href="#8-优先考虑覆盖索引" class="headerlink" title="8. 优先考虑覆盖索引"></a>8. 优先考虑覆盖索引</h3><h4 id="8-1-什么是覆盖索引"><a href="#8-1-什么是覆盖索引" class="headerlink" title="8.1 什么是覆盖索引"></a>8.1 什么是覆盖索引</h4><ul><li><p>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。<strong>一个索引包含了满足查询结果的数据就叫做覆盖索引</strong>。</p></li><li><p>非聚簇复合索引的一种方式，它包括在查询里的 SELECT、JOIN 和 WHERE 子句用到的所有列 (即建索引的字段正好是覆盖查询条件中所涉及的字段)。简单说就是，<code>索引列 + 主键</code> 包含 <code>SELECT 到 FROM 之间查询的列</code>。</p><p>举例：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 删除原有索引并创建新索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_name <span class="keyword">ON</span> student(age, `NAME`);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&lt;&gt;</span> <span class="number">20</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_age_name  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> age, `NAME` <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&lt;&gt;</span> <span class="number">20</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> idx_age_name  <span class="operator">|</span> idx_age_name <span class="operator">|</span> <span class="number">68</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> `NAME` <span class="keyword">LIKE</span> <span class="string">&#x27;%abc&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">11.11</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+--------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> id, age <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> `NAME` <span class="keyword">LIKE</span> <span class="string">&#x27;%abc&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> student <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_age_name <span class="operator">|</span> <span class="number">68</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">499086</span> <span class="operator">|</span>    <span class="number">11.11</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+</span></span><br></pre></td></tr></table></figure><h4 id="8-2-覆盖索引的利弊"><a href="#8-2-覆盖索引的利弊" class="headerlink" title="8.2 覆盖索引的利弊"></a>8.2 覆盖索引的利弊</h4><p>好处：</p><ul><li><p>避免 InnoDB 表进行索引的二次查询 (回表)</p><p>  InnoDB 是以聚簇索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键值后，还需通过主键进行二次查询才能获取真实所需要的数据。在覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询，减少了 IO 操作，提升了查询效率。</p></li><li><p>可以把随机 IO 变成顺序 IO 加快查询效率</p><p>  由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少得多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</p></li></ul><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段</strong>。</p><p>弊端：</p><ul><li>索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务 DBA，或者成为业务数据架构师的工作。</li></ul><h3 id="9-如何给字符串添加索引"><a href="#9-如何给字符串添加索引" class="headerlink" title="9. 如何给字符串添加索引"></a>9. 如何给字符串添加索引</h3><h3 id="10-索引下推"><a href="#10-索引下推" class="headerlink" title="10. 索引下推"></a>10. 索引下推</h3><h4 id="10-1-使用前后对比"><a href="#10-1-使用前后对比" class="headerlink" title="10.1 使用前后对比"></a>10.1 使用前后对比</h4><p>Index Condition Pushdown (ICP) 是 MySQL 5.6 中新特性，是一种在存储引擎层使用过滤数据的优化方式。</p><ul><li>如果没有 ICP，存储引擎会遍历索引以定位基表中的行，并将它们返回给 MySQL 服务器，由 MySQL 服务器评估 WHERE 后面的条件是否保留行。</li><li>启用 ICP 后，如果部分 WHERE 条件可以仅使用索引中的列进行筛选，则 MySQL 服务器会把这部分 WHERE 条件放到存储引擎筛选。然后，存储引擎通过使用索引条目来筛选数据，并且只有在满足这一条件时才从表中读取行。<ul><li>好处：ICP 可以减少存储引擎必须访问基表的次数和 MySQL 服务器必须访问存储引擎的次数。</li><li>但是，ICP 的加速效果取决于在存储引擎内通过 ICP 筛选掉的数据的比例。</li></ul></li></ul><h4 id="10-2-ICP-的开启-x2F-关闭"><a href="#10-2-ICP-的开启-x2F-关闭" class="headerlink" title="10.2 ICP 的开启&#x2F;关闭"></a>10.2 ICP 的开启&#x2F;关闭</h4><ul><li>默认情况下启用索引条件下推。可以通过设置系统变量 optimizer_switch 控制：<code>index_condition_pushdown</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 打开索引下推</span><br><span class="line"><span class="keyword">SET</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;index_condition_pushdown=on&#x27;</span>;</span><br><span class="line"># 关闭索引下推</span><br><span class="line"><span class="keyword">SET</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;index_condition_pushdown=off&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>当使用索引条件下推时，EXPLAIN 语句输出结果中 Extra 列内容显示为 <code>Using index condition</code>。</li></ul><h4 id="10-3-ICP-使用案例"><a href="#10-3-ICP-使用案例" class="headerlink" title="10.3 ICP 使用案例"></a>10.3 ICP 使用案例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> people (</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">zipcode <span class="type">VARCHAR</span> ( <span class="number">20</span> ) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">firstname <span class="type">VARCHAR</span> ( <span class="number">20</span> ) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">lastname <span class="type">VARCHAR</span> ( <span class="number">20</span> ) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">address <span class="type">VARCHAR</span> ( <span class="number">50</span> ) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY ( id ),</span><br><span class="line">KEY zip_last_first ( zipcode, lastname, firstname ) </span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB AUTO_INCREMENT <span class="operator">=</span> <span class="number">5</span> <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb3 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_bin;</span><br><span class="line"></span><br><span class="line"># 插入数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> people <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;000001&#x27;</span>, <span class="string">&#x27;三&#x27;</span>, <span class="string">&#x27;赵&#x27;</span>, <span class="string">&#x27;北京市&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;000002&#x27;</span>, <span class="string">&#x27;四&#x27;</span>, <span class="string">&#x27;钱&#x27;</span>, <span class="string">&#x27;重庆市&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;000003&#x27;</span>, <span class="string">&#x27;五&#x27;</span>, <span class="string">&#x27;孙&#x27;</span>, <span class="string">&#x27;南京市&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;000004&#x27;</span>, <span class="string">&#x27;六&#x27;</span>, <span class="string">&#x27;李&#x27;</span>, <span class="string">&#x27;天津市&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 知道一个人邮编，但是不确定这个人的姓氏</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> people <span class="keyword">WHERE</span> zipcode <span class="operator">=</span> <span class="string">&#x27;000001&#x27;</span> <span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span> <span class="keyword">AND</span> address <span class="keyword">LIKE</span> <span class="string">&#x27;%北京市%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys  <span class="operator">|</span> key            <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> people <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> zip_last_first <span class="operator">|</span> zip_last_first <span class="operator">|</span> <span class="number">63</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">25.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span>; <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------------+------+----------------+----------------+---------+-------+------+----------+------------------------------------+</span></span><br></pre></td></tr></table></figure><p>执行查看 SQL 的查询计划，Extra 中显示了 Using index condition，这表示使用了索引下推。另外，Using where 表示条件中包含需要过滤的非索引列数据，即 <code>address LIKE &#39;%北京市%&#39;</code> 这个条件并不是索引列，需要在服务端过滤掉。如果不想出现 Using where，把 <code>address LIKE &#39;%北京市%&#39;</code> 去掉即可。</p><h4 id="10-4-开启和关闭-ICP-的性能对比"><a href="#10-4-开启和关闭-ICP-的性能对比" class="headerlink" title="10.4 开启和关闭 ICP 的性能对比"></a>10.4 开启和关闭 ICP 的性能对比</h4><p>创建存储过程，主要目的就是插入很多 000001 的数据，这样查询的时候为了在存储引擎层做过滤，减少 IO，也为了减少缓冲池 (缓存数据页，没有 IO) 的作用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_people(max_num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">REPEAT</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> people (zipcode, firstname, lastname, address) <span class="keyword">VALUES</span> (<span class="string">&#x27;000001&#x27;</span>, <span class="string">&#x27;六&#x27;</span>, <span class="string">&#x27;周&#x27;</span>, <span class="string">&#x27;天津市&#x27;</span>);</span><br><span class="line">UNTIL i <span class="operator">=</span> max_num</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 调用存储过程</span><br><span class="line"><span class="keyword">CALL</span> insert_people(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line"># 打开 profiling</span><br><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># 执行 <span class="keyword">SQL</span> 语句，此时默认打开索引下推</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> people <span class="keyword">WHERE</span> zipcode <span class="operator">=</span> <span class="string">&#x27;000001&#x27;</span> <span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 再次执行 <span class="keyword">SQL</span> 语句，不使用索引下推</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ no_icp (people) */</span> <span class="operator">*</span> <span class="keyword">FROM</span> people <span class="keyword">WHERE</span> zipcode <span class="operator">=</span> <span class="string">&#x27;000001&#x27;</span> <span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 查看当前会话所产生的所有 profiles</span><br><span class="line"><span class="keyword">SHOW</span> profiles;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Query_ID <span class="operator">|</span> Duration   <span class="operator">|</span> Query                                                                                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span> <span class="number">0.17796400</span> <span class="operator">|</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> people <span class="keyword">WHERE</span> zipcode <span class="operator">=</span> <span class="string">&#x27;000001&#x27;</span> <span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span>                         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span> <span class="number">1.06563900</span> <span class="operator">|</span> <span class="keyword">SELECT</span> <span class="comment">/*+ no_icp (people) */</span> <span class="operator">*</span> <span class="keyword">FROM</span> people <span class="keyword">WHERE</span> zipcode <span class="operator">=</span> <span class="string">&#x27;000001&#x27;</span> <span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+------------------------------------------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> profile <span class="keyword">FOR</span> query <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Status                         <span class="operator">|</span> Duration <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> starting                       <span class="operator">|</span> <span class="number">0.000193</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Executing hook <span class="keyword">on</span> transaction  <span class="operator">|</span> <span class="number">0.000006</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> starting                       <span class="operator">|</span> <span class="number">0.000015</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> checking permissions           <span class="operator">|</span> <span class="number">0.000011</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Opening tables                 <span class="operator">|</span> <span class="number">0.000314</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> init                           <span class="operator">|</span> <span class="number">0.000011</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">System</span> lock                    <span class="operator">|</span> <span class="number">0.000019</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> optimizing                     <span class="operator">|</span> <span class="number">0.000024</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> statistics                     <span class="operator">|</span> <span class="number">0.000226</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> preparing                      <span class="operator">|</span> <span class="number">0.000046</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> executing                      <span class="operator">|</span> <span class="number">0.177033</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">end</span>                            <span class="operator">|</span> <span class="number">0.000014</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query <span class="keyword">end</span>                      <span class="operator">|</span> <span class="number">0.000003</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> waiting <span class="keyword">for</span> handler <span class="keyword">commit</span>     <span class="operator">|</span> <span class="number">0.000008</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> closing tables                 <span class="operator">|</span> <span class="number">0.000008</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> freeing items                  <span class="operator">|</span> <span class="number">0.000021</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cleaning up                    <span class="operator">|</span> <span class="number">0.000012</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> profile <span class="keyword">FOR</span> query <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Status                         <span class="operator">|</span> Duration <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> starting                       <span class="operator">|</span> <span class="number">0.001877</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Executing hook <span class="keyword">on</span> transaction  <span class="operator">|</span> <span class="number">0.000012</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> starting                       <span class="operator">|</span> <span class="number">0.000015</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> checking permissions           <span class="operator">|</span> <span class="number">0.000008</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Opening tables                 <span class="operator">|</span> <span class="number">0.000120</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> init                           <span class="operator">|</span> <span class="number">0.000007</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">System</span> lock                    <span class="operator">|</span> <span class="number">0.000015</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> optimizing                     <span class="operator">|</span> <span class="number">0.000030</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> statistics                     <span class="operator">|</span> <span class="number">0.000195</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> preparing                      <span class="operator">|</span> <span class="number">0.000041</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> executing                      <span class="operator">|</span> <span class="number">1.063250</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">end</span>                            <span class="operator">|</span> <span class="number">0.000015</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query <span class="keyword">end</span>                      <span class="operator">|</span> <span class="number">0.000004</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> waiting <span class="keyword">for</span> handler <span class="keyword">commit</span>     <span class="operator">|</span> <span class="number">0.000008</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> closing tables                 <span class="operator">|</span> <span class="number">0.000006</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> freeing items                  <span class="operator">|</span> <span class="number">0.000025</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cleaning up                    <span class="operator">|</span> <span class="number">0.000011</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+----------+</span></span><br></pre></td></tr></table></figure><p>多次测试效率对比来看，使用 ICP 优化的查询效率会好一些。这里建议多存储一些数据效果更明显。</p><h4 id="10-5-ICP-的使用条件"><a href="#10-5-ICP-的使用条件" class="headerlink" title="10.5 ICP 的使用条件"></a>10.5 ICP 的使用条件</h4><ul><li>如果表访问的类型为 range、ref、eq_ref 和 ref_or_null 可以使用 ICP</li><li>ICP 可以用于 InnoDB 和 MyISAM 表，包括分区表 InnoDB 和 MyISAM 表</li><li>对于 InnoDB 表，ICP 仅用于二级索引。ICP 的目标是减少全行读取次数，从而减少 I&#x2F;O 操作。</li><li>当 SQL 使用覆盖索引时，不支持 ICP。因为这种情况下使用 ICP 不会减少 I&#x2F;O。</li><li>相关子查询的条件不能使用 ICP。</li></ul><h3 id="11-其他查询优化策略"><a href="#11-其他查询优化策略" class="headerlink" title="11. 其他查询优化策略"></a>11. 其他查询优化策略</h3><h4 id="11-1-EXISTS-和-IN-的区分"><a href="#11-1-EXISTS-和-IN-的区分" class="headerlink" title="11.1 EXISTS 和 IN 的区分"></a>11.1 EXISTS 和 IN 的区分</h4><p><strong>问题</strong>：</p><p>不太理解那种情况下应该使用 EXISTS，哪种情况下应该用 IN。选择的标准是看能否使用表的索引吗？</p><p><strong>回答</strong>：</p><p>索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为小表驱动大表。在这种方式下效率是最高的。</p><p>比如下面这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> cc <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> B);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> B <span class="keyword">WHERE</span> B.cc <span class="operator">=</span> A.cc);</span><br></pre></td></tr></table></figure><p>当 A 小于 B 时，用 EXISTS。因为 EXISTS 的实现，相当于外表循环，实现的逻辑类似于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> A</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> B</span><br><span class="line">if j.cc <span class="operator">=</span><span class="operator">=</span> i.cc <span class="keyword">then</span> ...</span><br></pre></td></tr></table></figure><p>当 B 小于 A 时用 IN，因为实现的逻辑类似于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> B</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> A</span><br><span class="line">if j.cc <span class="operator">=</span><span class="operator">=</span> i.cc <span class="keyword">then</span> ...</span><br></pre></td></tr></table></figure><p>哪个表小就用哪个表来驱动，A 表小就用 EXISTS，B 表小就用 IN。</p><h4 id="11-2-COUNT-与-COUNT-具体字段-效率"><a href="#11-2-COUNT-与-COUNT-具体字段-效率" class="headerlink" title="11.2 COUNT(*) 与 COUNT(具体字段) 效率"></a>11.2 COUNT(*) 与 COUNT(具体字段) 效率</h4><p><strong>问提</strong>：</p><p>在 MySQL 中统计数据表的行数，可以使用三种方式：<code>SELECT COUNT(*)</code>、<code>SELECT COUNT(1)</code> 和 <code>SELECT COUNT(具体字段)</code>，使用这三者之间的查询效率是怎样的？</p><p><strong>回答</strong>：</p><p>前提：如果要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才可以。</p><ul><li>COUNT(*) 和 COUNT(1) 都是对所有结果进行 COUNT，COUNT(*) 和 COUNT(1) 本质上并没有区别 (二者执行时间可能略有差别，不过还是可以把它两的执行效率看成是相等的)。如果有 WHERE 字句，则是对所有符合筛选条件的数据行进行统计；如果没有 WHERE 字句，则是对数据表的数据行数进行统计。</li><li>如果是 MyISAM 存储引擎，统计数据表的行数只需要 O(1) 的复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息存储了 row_count 值，而一致性则由表级锁来保证。如果是 InnoDB 存储引擎，因为 InnoDB 支持事物，采用行级锁和 MVCC 机制，所以无法像 MyISAM 一样，维护一个 row_count 变量，因此需要采用扫描全表，是 O(n) 的复杂度，进行循环 + 计数的方式来完成统计。</li><li>在 InnoDB 存储引擎中，如果采用 COUNT(具体字段) 来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引 (非聚簇索引)。对于 COUNT(*) 和 COUNT(1) 来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。如果有多个二级索引，会使用 key_len 小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</li></ul><h4 id="11-3-关于-SELECT"><a href="#11-3-关于-SELECT" class="headerlink" title="11.3 关于 SELECT(*)"></a>11.3 关于 SELECT(*)</h4><p>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用 SELECT &lt;字段列表&gt; 查询。原因：</p><ul><li>MySQL 在解析的过程中，会通过查询数据字典将 * 按序转换成所有列名，这会大大的耗费资源和时间。</li><li>无法使用覆盖索引。</li></ul><h4 id="11-4-LIMIT-1-对优化的影响"><a href="#11-4-LIMIT-1-对优化的影响" class="headerlink" title="11.4 LIMIT 1 对优化的影响"></a>11.4 LIMIT 1 对优化的影响</h4><p>针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上 LIMIT 1 的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p><p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上 LIMIT 1 了。</p><h4 id="11-5-多使用-COMMIT"><a href="#11-5-多使用-COMMIT" class="headerlink" title="11.5 多使用 COMMIT"></a>11.5 多使用 COMMIT</h4><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放的资源而减少。</p><p>COMMIT 所释放的资源：</p><ul><li>回滚段上用于恢复数据的信息</li><li>被程序语句获得的锁</li><li>redo &#x2F; undo log buffer 中的空间</li><li>管理上述三种资源中的内部花费</li></ul><h3 id="12-淘宝数据库，主键如何设计的？"><a href="#12-淘宝数据库，主键如何设计的？" class="headerlink" title="12. 淘宝数据库，主键如何设计的？"></a>12. 淘宝数据库，主键如何设计的？</h3><p>数据库的主键如何设计，大多数人的回答都会是用 8 字节的 BIGINT 做主键，而不要用 INT。(错)</p><p>这样的回答，只站在了数据库着一层，而没有从业务的角度思考主键。主键就是自增 ID 吗？用自增做主键，架构设计上可能连及格都拿不到。</p><h4 id="12-1-自增-ID-的问题"><a href="#12-1-自增-ID-的问题" class="headerlink" title="12.1 自增 ID 的问题"></a>12.1 自增 ID 的问题</h4><p>自增 ID 做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增 ID 除了简单其他都是缺点，总体来看存在以下几方面的问题：</p><ul><li><p>可靠性不高</p><p>  存在自增 ID 回溯的问题，这个问题直到最新版本的 MySQL 8.0 才修复</p></li><li><p>安全性不高</p><p>  对外暴露的接口可以非常容易猜测对应的信息。比如：&#x2F;User&#x2F;1&#x2F; 这样的接口，可以非常容易猜测用户 ID 的值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。</p></li><li><p>性能差</p><p>  自增 ID 的性能较差，需要在数据库服务器端生成。</p></li><li><p>交互多</p><p>  业务还需要额外执行一次类似 last_insert_id() 的函数才能知道刚才插入的自增值，这需要多一次的网络交互。在海量并发的系统中，多一条 SQL，就多一次性能上的开销。</p></li><li><p>局部唯一性</p><p>  最重要的一点，自增 ID 是局部唯一，只在当前数据库实例中唯一，而不是全剧唯一，在任意服务期间都是唯一的。对于目前分布式系统来说，这简直就是噩梦。</p></li></ul><h4 id="12-2-业务字段做主键"><a href="#12-2-业务字段做主键" class="headerlink" title="12.2 业务字段做主键"></a>12.2 业务字段做主键</h4><p>为了能够唯一地标识一个会员的信息，需要为会员信息表设置一个主键。考虑业务字段做主键。</p><table><thead><tr><th>cardno</th><th>name</th><th>phone</th><th>pid</th><th>address</th><th>sex</th><th>birthday</th></tr></thead><tbody><tr><td>10000001</td><td>张三</td><td>13300000001</td><td>1101232000000007890</td><td>上海</td><td>女</td><td>2000-01-02</td></tr><tr><td>10000002</td><td>李四</td><td>13300000002</td><td>1101232000000007891</td><td>浙江</td><td>男</td><td>1999-02-03</td></tr></tbody></table><ul><li><p>选择卡号 (cardno)</p><p>  会员卡号看起来比较合适，因为会员卡号不能为空，而且有唯一性，可以用来标识一条会员记录。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo.membermaster(</span><br><span class="line">cardno <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  name TEXT,</span><br><span class="line">  phone TEXT,</span><br><span class="line">  pid TEXT,</span><br><span class="line">  address TEXT,</span><br><span class="line">  sex TEXT,</span><br><span class="line">  birthday DATETIME</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>  不同的会员卡号对应不同的会员，字段 cardno 唯一地标识某一个会员。如果都是这样，会员卡号与会员一一对应，系统是可以正常运行的。</p><p>  但实际情况是，会员卡号可能存在重复使用的情况。比如，张三因为工作变动搬离了原来的地址，不再到商家的门店消费了 (退还了会员卡)，于是张三就不再是这个商家门店的会员了。但是，商家不想让这个会员卡空着，就把卡号 10000001 的会员卡发给了王五。</p><p>  从系统设计的角度看，这个变化只是修改了会员信息表中的卡号是 10000001 这个会员信息，并不会影响到数据一致性。也就是说，修改会员卡号是 10000001 的会员信息，系统的各个模块，都会获取到修改后的会员信息，不会出现有的模块获取到修改之前的会员信息，有些模块获取到修改后的会员信息，而导致系统内部数据不一致的情况。因此，从信息系统层面上看是没问题的。</p><p>  但是从使用系统的业务层面来看，就有很大的问题了，会对商家造成影响。</p><p>  比如，有一个销售流水表 (trans)，记录了所有的销售流水明细。2020-12-01，张三在门店购买了一本书，消费了 89 元。那么，系统中就有了张三买书的流水记录，如下所示：</p><table><thead><tr><th>transactionno</th><th>itemnumber</th><th>quantity</th><th>price</th><th>salesvalue</th><th>cardno</th><th>transdate</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>89</td><td>89</td><td>10000001</td><td>2020-12-01</td></tr></tbody></table><p>  接着，查询一下2020-12-01 的会员消费记录：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.name, c.goodsname, a.quantity, a.salesvalue, a.transdate</span><br><span class="line"><span class="keyword">FROM</span> demo.trans <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">JOIN</span> demo.membermaster <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">JOIN</span> demo.goodsmaster <span class="keyword">AS</span> c</span><br><span class="line"><span class="keyword">ON</span> (a.cardno <span class="operator">=</span> b.cardno <span class="keyword">AND</span> a.itemnumber <span class="operator">=</span> c.itemnumber);</span><br></pre></td></tr></table></figure><p>  如果会员卡 10000001 又发给了王五，我们会更改会员信息表。到值查询时得到的结果是王五在 2020-12-01 买了一本书，消费 89 元。所以不能将会员卡好当做主键。</p></li><li><p>选择会员电话或身份证号</p><p>  会员电话可以做主键吗？不行的。在实际操作中，手机号也存在被运营商收回，重新发给别人用的情况。</p><p>  那身份证号行不行呢？好像可以，因为身份证绝不会重复，身份证号与一个人存在一一对应的关系。可问题是，身份证号属于个人隐私，顾客不一定愿意给你。要是强制要求会员必须登记身份证号，会把很多客人赶跑的。其实，客户电话也有这个问题，这也是我们在设计会员信息表的时候，允许身份证号和电话都为空的原因。</p><p>  <strong>所以，建议尽量不要用跟业务有关的字段做主键。毕竟，作为项目设计的技术人员，我们谁也无法预测在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现</strong>。</p><blockquote><p>经验：</p><p>刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高。</p></blockquote></li></ul><h4 id="12-3-淘宝的主键设计"><a href="#12-3-淘宝的主键设计" class="headerlink" title="12.3 淘宝的主键设计"></a>12.3 淘宝的主键设计</h4><p>打开自己淘宝订单，会发现每个订单号的特征。例如：1713216900604568394、1696231922773568394</p><p>可以发现，订单号不是自增 ID。订单号长度为 19 位，且订单号的最后 6 位都是一样的，都是568394。且订单号的前面 13 位部分是单调递增的。</p><p>大胆猜测，淘宝的订单 ID 设计应该是：<code>订单 ID = 时间 + 去重字段 + 用户ID后6位尾号</code>。这样的设计能做到全剧唯一，且对分布式系统查询及其友好。</p><h4 id="12-4-推荐的主键设计"><a href="#12-4-推荐的主键设计" class="headerlink" title="12.4 推荐的主键设计"></a>12.4 推荐的主键设计</h4><p>非核心业务：对应表的主键自增 ID，如告警、日志、监控等信息。</p><p>核心业务：<strong>主键设计至少应该是全局唯一且是单调递增</strong>。全局唯一保证在各系统之间都是唯一的，单调递增是希望插入时不影响数据库性能。</p><p>这里推荐最简单的一种主键设计：UUID</p><p><strong>UUID 的特点</strong>：</p><p>全局唯一，占用 36 字节，数据无序，插入性能差。</p><p><strong>认识 UUID</strong>：</p><ul><li>为什么 UUID 是全局唯一的？</li><li>为什么 UUID 占用 36 个字节？</li><li>为什么 UUID 是无序的？</li></ul><p>MySQL 数据库的 UUID 组成如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID <span class="operator">=</span> 时间 <span class="operator">+</span> UUID版本(<span class="number">16</span>字节) <span class="operator">-</span> 时钟序列(<span class="number">4</span>字节) <span class="operator">-</span> MAC地址(<span class="number">12</span>字节)</span><br></pre></td></tr></table></figure><p><img src="http://1.117.162.142:9000/blog/mysqluuid.png" alt="mysql-uuid"></p><p><strong>为什么 UUID 是全局唯一的</strong>？</p><p>在 UUID 中的时间部分占用 60 位，存储的类似 TIMESTAMP 的时间戳，但表示的是从 1582-10-15 00:00:00.00 到现在的 100ns 的计数。可以看到 UUID 存储的时间精度比 TIMESTAMP 更高，时间维度发生重复的概率降低到 1&#x2F;100ns。</p><p>时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC 地址用于全局唯一。</p><p><strong>为什么 UUID 占用 36 字节</strong>？</p><p>UUID 根据字符串进行存储，设计时还带有无用的 “-” 字符串，因此总共需要 36 字节。</p><p><strong>为什么 UUID 是随机无序的呢</strong>？</p><p>因为 UUID 的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</p><p><strong>改造 UUID</strong></p><p>若将时间高低位互换，则时间就是单调递增的了，也就变的单调递增了。MySQL 8.0 可以更换时间低位和时间高位的存储方式，这样 UUID 就是有序的 UUID 了。</p><p>MySQL 8.0 还解决了 UUID 存在的空间占用的问题，除去了 UUID 字符串中无意义的 ”-“ 字符串，并且将字符串用二进制类型保存，这样存储空间降低为了 16 字节。</p><p>可以通过 MySQL 8.0 提供的 uuid_to_bin 函数实现上述功能，同样的，MySQL 也提供了 bin_to_uuid 函数进行转化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@uuid</span> <span class="operator">=</span> UUID();</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@uuid</span>, uuid_to_bin(<span class="variable">@uuid</span>), uuid_to_bin(<span class="variable">@uuid</span>, <span class="literal">TRUE</span>);</span><br></pre></td></tr></table></figure><p><strong>通过函数 uuid_to_bin(@uuid, true) 将 UUID 转化为有序 UUID</strong>了。全局唯一 + 单调递增。</p><p><strong>有序 UUID 性能测试</strong></p><p>16 字节的有序 UUID，相比之前 8 字节的自增 ID，性能和存储空间对比究竟如何呢？</p><p>插入 1 亿条数据，每条数据占用 500 字节，含有 3 个二级索引，最终的结果如下所示：</p><p><img src="http://1.117.162.142:9000/blog/%E6%9C%89%E5%BA%8Fuuid%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.png" alt="有序uuid性能测试"></p><p>从上图可以看到插入 1 亿条数据有序 UUID 是最快的，而且在实际业务使用中有序 UUID 在业务端就可以生成。还可以进一步减少 SQL 交互次数。</p><p>另外，虽然有序 UUID 相比自增 ID 多了 8 个字节，但是鸡只增大了 3g 的存储空间，还可以接受。</p><blockquote><p>在当今的互联网环境中，非常不推荐自增 ID 作为主键的数据库设计。更推荐类似有序 UUID 的全局唯一的实现。</p><p>另外，在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。这样的主键设计就更为考验架构师的水平了。</p></blockquote><p><strong>如果不是 MySQL 8.0 怎么办</strong>？</p><p>手动赋值字段做主键！</p><p>比如，设计各个分店的会员表的主键，因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题。</p><p>可以在总部 MySQL 数据库中，有一个管理信息表，在这个表中添加一个字段，专门用来记录当前会员编号的最大值。</p><h2 id="九、数据库的设计规范"><a href="#九、数据库的设计规范" class="headerlink" title="九、数据库的设计规范"></a>九、数据库的设计规范</h2><h3 id="1-为什么需要数据库设计"><a href="#1-为什么需要数据库设计" class="headerlink" title="1. 为什么需要数据库设计"></a>1. 为什么需要数据库设计</h3><p>我们在设计数据表的时候，要考虑很多问题。比如：</p><ul><li>用户都需要什么数据？需要在数据表中保存哪些数据？</li><li>如何保证数据表中数据的正确性，当插入、删除、更新的时候该进行怎样的约束检查？</li><li>如何降低数据表的数据冗余度，保证数据表不会因为用户量的增长而迅速扩张？</li><li>如何让负责数据维护的人员更方便地使用数据库？</li><li>使用数据库的应用场景也各不相同，可以说针对不同的情况，设计出来的数据表可能千差万别。</li></ul><p>现实情况中，面临的场景：</p><p>当数据库运行了一段时间之后，我们才发现数据表设计得有问题。重新调整数据表的结构，就需要做数据迁移，还有可能影响程序的业务逻辑，以及网站的正常访问。</p><p>如果是糟糕的数据库设计可能会造成以下问题：</p><ul><li>数据冗余、信息重复，存储空间浪费</li><li>数据更新、插入、删除的一场</li><li>无法正确表示信息</li><li>丢失有效信息</li><li>程序性能差</li></ul><p>良好的数据库设计则有以下优点：</p><ul><li>节省数据的存储空间</li><li>能够保证数据的完整性</li><li>方便进行数据库应用系统的开发</li></ul><p>总之，开始设置数据库的时候，我们就需要重视数据表的设计。为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。</p><h3 id="2-范式"><a href="#2-范式" class="headerlink" title="2. 范式"></a>2. 范式</h3><h4 id="2-1-范式简介"><a href="#2-1-范式简介" class="headerlink" title="2.1 范式简介"></a>2.1 范式简介</h4><p><strong>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式</strong>。可以理解为，一张数据表的设计结构需要满足的某种设计标准的级别。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p><p>范式的英文名称是 Mormal Form，简称 NF。它是英国人 E.F.Codd 在上个世纪 70 年代提出关系数据库模型后总结出来的。范式是关系数据库理论的基础，也是我们在设计数据库结构过程中所要遵循的规则和指导方法。</p><h4 id="2-2-范式都包括哪些"><a href="#2-2-范式都包括哪些" class="headerlink" title="2.2 范式都包括哪些"></a>2.2 范式都包括哪些</h4><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式 (1NF)、第二范式 (2NF)、第三范式 (3NF)、巴斯-科德范式 (BCNF)、第四范式 (4NF) 和第五范式 (5NF，又称完美范式)。</p><p>数据库的范式设计越高阶，冗余度就越低，同时高阶的范式一定符合低阶范式的要求，满足最低要求的范式是第一范式 (1NF)。在第一范式的基础上进一步满足更多规范要求的成为第二范式 (2NF)，其余范式以此类推。一般来说，在关系型数据库设计中，最高也就遵循到 BCNF，普遍还是 3NF。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是反规范化。</p><p><img src="http://1.117.162.142:9000/blog/%E8%8C%83%E5%BC%8F.png" alt="范式"></p><h4 id="2-3-键和相关属性的概念"><a href="#2-3-键和相关属性的概念" class="headerlink" title="2.3 键和相关属性的概念"></a>2.3 键和相关属性的概念</h4><p>范式的定义会使用到主键和候选键，数据库中的键  (Key) 由一个或者多个属性组成。数据表中常用的几种键和属性的定义：</p><ul><li>超键：能唯一标识元组的属性集叫做超键。</li><li>候选键：如果超键不包括多余的属性，那么这个超键就是候选键。</li><li>主键：用户可以从候选键中选择一个作为主键。</li><li>外键：如果数据表 R1 中的某属性集不是 R1 的主键，而是另一个数据表 R2 的主键，那么这个属性集就是数据表 R1 的外键。</li><li>主属性：包含在任一候选键中的属性称为主属性。</li><li>非主属性：与主属性相对，指的是不包含在任何一个候选键中的属性。</li></ul><p>通常，我们也将候选键称之为码，把主键也称为主码。因为键可能是由多个属性组成的，针对单个属性，我们还可以用主属性和非主属性来进行区分。</p><p>举例：</p><p>这里有两个表：</p><p>球员表 (player)：球员编号｜ 姓名｜身份证号｜年龄｜球队编号</p><p>球队表 (team)：球队编号｜主教练｜球队所在地</p><ul><li>超键：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如 (球员编号) (球员编号，姓名) (身份证号，年龄) 等。</li><li>候选键：就是最小的超键，对于球员表来说，候选键就是 (球员编号) 或者身份证号。</li><li>主键：我们自己选定，也就是从候选键中选择一个，比如 (球员编号)。</li><li>外键：球员表中的球队编号。</li><li>主属性、非主属性：在球员表中，主属性是 (球员编号) (身份证号)，其他的属性 (姓名) (年龄) (球队编号) 都是非主属性。</li></ul><h4 id="2-4-第一范式-1st-NF"><a href="#2-4-第一范式-1st-NF" class="headerlink" title="2.4 第一范式 (1st NF)"></a>2.4 第一范式 (1st NF)</h4><p>第一范式主要是确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值不可再次拆分的最小数据单元。</p><p>我们在设计某个字段的时候，对于字段 X 来说，不能把字段 X 拆分成字段 X-1 和字段 X-2。事实上，任何的 DBMS 都会满足第一范式的要求，不会将字段进行拆分。</p><h4 id="2-5-第二范式-2nd-NF"><a href="#2-5-第二范式-2nd-NF" class="headerlink" title="2.5 第二范式 (2nd NF)"></a>2.5 第二范式 (2nd NF)</h4><p>第二范式要求，在满足第一范式的基础上，还要<strong>满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分</strong>。如果指导主键的所有属性的值，就可以检索到任何元组 (行) 的任何属性的任何值。(要求中的主键，其实可以拓展替换为候选键)。</p><blockquote><p>小结：第二范式 (2NF) 要求实体的属性完全依赖主关键字。如果存在不完全依赖，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与元实体之间是一对多的关系。</p><p>1 NF 告诉我们字段属性需要是原子性的，而 2NF 告诉我们一张表就是一个独立的对象，一张表只表达一个意思。</p></blockquote><h4 id="2-6-第三范式-3rd-NF"><a href="#2-6-第三范式-3rd-NF" class="headerlink" title="2.6 第三范式 (3rd NF)"></a>2.6 第三范式 (3rd NF)</h4><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段和主键字段直接相关，也就是说，<strong>要求数据表中的所有非主键字段不能依赖于其他非主键字段</strong>。(即，不能存在非主属性 A 依赖于非主属性 B，非主属性 B 依赖于主键 C 的情况，即存在 A→B→C 的决定关系) 通俗地讲，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。</p><p>这里的主键可以拓展为候选键。</p><blockquote><p>符合 3NF 后的数据模型通俗地讲，2NF 和 3NF 通常以这句话概括：“每个非主键属性依赖于主键，依赖于整个主键，并且除了主键别无他物”。</p></blockquote><h4 id="2-7-小结"><a href="#2-7-小结" class="headerlink" title="2.7 小结"></a>2.7 小结</h4><p>关于数据表的设计，有三个范式要遵循。</p><ul><li>第一范式，确保每列保持原子性。数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。</li><li>第二范式，确保每列都和主键完全依赖。尤其在复合主键的情况下，非主键部分不应该依赖于部分主键。</li><li>第三范式，确保每列都和主键列直接相关，而不是间接相关。</li></ul><p>范式的优点：数据的标准化有助于消除数据库中的数据冗余，第三范式通常被认为在性能、扩展性和数据完整性方面达到了最好的平衡。</p><p>范式的缺点：范式的使用，可能降低查询的效率。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要关联多张表，这不但代价昂贵，也可能使一些索引策略无效。</p><p>范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式的原则，通过增加少量的冗余或重复的数据来提高数据库的读性能，减少关联查询，join 表的次数，实现空间换取时间的目的。因此在实际的设计过程中要理论结合实际，灵活运用。</p><blockquote><p>范式本身没有优劣之分，只有适用场景不同。没有完美的设计，只有合适的设计，我们在数据表的设计中，还需要根据需求将范式和反范式混合使用。</p></blockquote><h3 id="3-反范式化"><a href="#3-反范式化" class="headerlink" title="3. 反范式化"></a>3. 反范式化</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p>有的时候不能简单按照规范要求设计数据表，因为有的数据看似冗余，其实对业务来说十分重要。这个时候，我们就要遵循业务优先的原则，首先满足业务需求，再尽量尽量减少冗余。</p><p>如果数据库中的数据量比较大，系统的 UV 和 PV 访问频次比较高，则完全按照 MySQL 的三大范式设计数据表，读数据时会产生大量的关联查询，在一定程度上会影响数据库的读性能。如果我们想对查询效率进行优化，反范式优化也是一种优化思路。此时，可以通过在数据表中增加冗余字段来提高数据库的读性能。</p><p><strong>规范化 vs 性能</strong></p><blockquote><ul><li>为满足某种商业目标，数据库性能比规范化数据库更重要</li><li>在数据规范化的同时，要综合考虑数据库的性能</li><li>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</li><li>通过在给定的表中插入计算列，以方便查询</li></ul></blockquote><h4 id="3-2-应用举例"><a href="#3-2-应用举例" class="headerlink" title="3.2 应用举例"></a>3.2 应用举例</h4><p>例如客户表和评论表，如果要查询该条评论的评论人名称，就需要关联客户表去查询客户的名称。如果经常性的去查询评论人，我们就可以在评论表中，添加评论人名称字段，就不用每次进行关联查询了。</p><h4 id="3-3-反范式的新问题"><a href="#3-3-反范式的新问题" class="headerlink" title="3.3 反范式的新问题"></a>3.3 反范式的新问题</h4><p>反范式可以通过空间换时间，提升查询的效率，但是反范式也会带来一些新问题：</p><ul><li>存储空间变大了</li><li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则数据不一致</li><li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常消耗系统资源</li><li>在数据量小的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加复杂</li></ul><h4 id="3-4-反范式的适用场景"><a href="#3-4-反范式的适用场景" class="headerlink" title="3.4 反范式的适用场景"></a>3.4 反范式的适用场景</h4><p>当冗余信息有价值或者能大幅度提高查询效率的时候，我们才会采取反范式化的优化。</p><ul><li><p>增加冗余字段的建议‘</p><p>  增加冗余字段一定要符合如下两个条件。只有满足这两个条件，才可以考虑增加冗余字段。</p><ul><li>这个冗余字段不需要经常进行修改</li><li>这个冗余字段查询的时候不可或缺</li></ul></li><li><p>历史快照、历史数据的需要</p><p>  在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的订单收货信息都属于历史快照，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</p><p>  反范式优化也常用在数据仓库的设计中，因为数据仓库通常存储历史数据，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p><p>  简单总结下数据仓库和数据库在使用上的区别：</p><ul><li>数据库设计的目的在于捕获数据，而数据仓库设计的目的在于分析数据</li><li>数据库对数据的增删改实时性要求强，需要存储在线的用户数据，而数据仓库存储的一般是历史数据</li><li>数据库设计需要尽量避免冗余，单位了提高查询效率也允许一定的冗余度，而数据仓库在设计上更偏向采用反范式设计。</li></ul></li></ul><h3 id="4-BCNF-巴斯范式"><a href="#4-BCNF-巴斯范式" class="headerlink" title="4. BCNF (巴斯范式)"></a>4. BCNF (巴斯范式)</h3><p>人们在 3NF 的基础上进行了改进，提出了巴斯范式 (BCNF)，也叫做巴斯-科德范式 (Boyce-Codd Normal Form)。BCNF 被认为没有新的设计规范加入，只是对第三范式中设计规范要求更强，使得数据库冗余度更小。所以，称为是修正的第三范式，或扩充的第三范式，BCNF 不被称为第四范式。</p><p>若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到 BC 范式。一般来说，一个数据库设计符合 3NF 或 BCNF 就可以了。</p><h3 id="5-第四范式"><a href="#5-第四范式" class="headerlink" title="5. 第四范式"></a>5. 第四范式</h3><p>多值依赖的概念：</p><ul><li>多值依赖即属性之间的一对多关系，记为 K→→A。</li><li>函数依赖事实上是单值依赖，所以不能表达属性值之间的一对多关系。</li><li>平凡的多值依赖：全集 U &#x3D; K + A，一个 K 可以对应于多个 A，即 K→→A。此时整个表就是一组一对多关系。</li><li>非平凡的多值依赖：全集 U &#x3D; K + A + B，一个 K 可以对应于多个 A，也可以对应于多个 B，A 与 B 互相独立，即 K→→A，K→→B。整个表有多组一对多关系，且有：“一”部分是相同的属性集合，“多”部分是互相独立的属性集合。</li></ul><p>第四范式即在满足巴斯-科德范式 (BCNF) 的基础上，消除非平凡且非函数依赖的多值依赖 (即把同一表内的多对多关系删除)。</p><h3 id="6-第五范式"><a href="#6-第五范式" class="headerlink" title="6. 第五范式"></a>6. 第五范式</h3><p>除了第四范式外，还有更高级的第五范式 (又称完美范式) 和域键范式 (DKNF)。</p><p>在满足第四范式 (4NF) 的基础上，消除不是由候选键所蕴含的连接依赖。如果关系模式 R 中的每一个连接依赖均由 R 的候选键所隐含，则称此关系模式符合第五范式。</p><p>函数依赖是多值依赖的一种特殊的情况，而多值依赖实际上依赖的一种特殊情况。但连接依赖不像函数依赖和多值依赖可以由语义直接导出，而是在关系连接运算时才反映出来。存在连接依赖的关系模式仍可能遇到数据冗余及插入、修改、删除异常等问题。</p><p>第五范式处理的是无损连接问题，这个范式基本没有任何实际意义，因为无损连接很少出现，而且难以察觉。而域键范式试图定义一个终极范式，该范式考虑所有的依赖和约束类型，但是实际价值也是最小的，只存在理论研究中。</p><h3 id="7-ER-模型"><a href="#7-ER-模型" class="headerlink" title="7. ER 模型"></a>7. ER 模型</h3><p>数据库设计是牵一发而动全身的。那有没有什么办法提前看到数据库的全貌呢？比如需要哪些数据表、数据表中应该有哪些字段，数据表与数据表之间有什么关系、通过什么字段进行连接，等等。这样我们才能进行整体的梳理和设计。</p><p>其实，ER 模型就是一个这样的工具。ER 模型也叫作实体关系模型，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。<strong>在开发基于数据库的信息系统的设计阶段，通常使用 ER 模型来描述信息需求和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库</strong>。</p><h4 id="7-1-ER-模型包括哪些要素？"><a href="#7-1-ER-模型包括哪些要素？" class="headerlink" title="7.1 ER 模型包括哪些要素？"></a>7.1 ER 模型包括哪些要素？</h4><p><strong>ER 模型中有三个要素，分别是实体、属性和关系</strong>。</p><p><strong>实体</strong>，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用矩形来表示。实体分为两类，分别是强实体和弱实体。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。</p><p><strong>属性</strong>，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用 椭圆形来表示。</p><p><strong>关系</strong>，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模型中用菱形来表示。</p><p>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，<strong>可以独立存在的是实体，不可再分的是属性</strong>。也就是说，属性不能包含其他属性。</p><h4 id="7-2-关系的类型"><a href="#7-2-关系的类型" class="headerlink" title="7.2 关系的类型"></a>7.2 关系的类型</h4><p>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是一对一、一对多、多对多。</p><p>一对一：指实体之间的关系一一对应的，比如个人与身份证信息之间的关系就是一对一的关系。一个人只能有一个身份证信息，一个身份证信息也只属于一个人。</p><p>一对多：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体。比如说，我们新建一个班级表，而每个班级都有多个学生，每个学生则对应一个班级，班级对学生就是一对多的关系。</p><p>多对多：指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购商品。再比如一个选课表，有许多科目，每个科目有很多学生选，而每个学生又可以选择多个科目，这就是多对多的关系。</p><h4 id="7-3-建模分析"><a href="#7-3-建模分析" class="headerlink" title="7.3 建模分析"></a>7.3 建模分析</h4><p>ER 模型看起来比较麻烦，但是对我们把控项目整体非常重要。如果你只是开发一个小应用，或许简单设计几个表够用了，一旦要设计有一定规模的应用，在项目的初始阶段，建立完整的 ER 模型就非常关键了。开发应用项目的实质，其实就是建模。</p><p>我们设计的案例是电商业务，由于电商业务太过庞大且复杂，所以我们做了业务简化，比如针对 SKU (StockKeepingUnit，库存量单位) 和 SPU (Standard Product Unit，标准化产品单元) 的含义上，我们直接使用了 SKU，并没有提及 SPU 的概念。本次电商业务涉及总共有 8 个实体：</p><ul><li>地址实体</li><li>用户实体</li><li>购物车实体</li><li>评论实体</li><li>商品实体</li><li>商品分类实体</li><li>订单实体</li><li>订单详情实体</li></ul><p>其中，用户和商品分类是强实体，因为他们不需要依赖其他任何实体。而其他属于弱实体，因为他们虽然都可以独立存在，但是他们都依赖用户这个实体，因此都是弱实体。知道了这些要素，我们就可以给电商业务创建 ER 模型了，如图：</p><p><img src="http://1.117.162.142:9000/blog/%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1ER%E6%A8%A1%E5%9E%8B-1.png" alt="电商业务ER模型-1"></p><p>在这个图中，地址和用户之间的添加关系，是一对多的关系，而商品和商品详情是一对一的关系，商品和订单是多对多的关系。这个 ER 模型，包括了 8 个实体之间的 8 种关系。</p><ul><li>用户可以在电商平台添加多个地址；</li><li>用户只能拥有一个购物车；</li><li>用户可以生成多个订单；</li><li>用户可以发表多条评论；</li><li>一件商品可以有多条评论；</li><li>每一个商品分类包含多种商品；</li><li>一个订单可以包含多个商品，一个商品可以在多个订单里。</li><li>订单中又包含多个订单详情，因为一个订单中可能包含不同种类的商品。</li></ul><h4 id="7-4-ER-模型的细化"><a href="#7-4-ER-模型的细化" class="headerlink" title="7.4 ER 模型的细化"></a>7.4 ER 模型的细化</h4><p>有了这个 ER 模型，我们就可以从整体上理解电商的业务了。刚刚的 ER 模型展示了电商业务的框架，但是只包括了订单，地址，用户，购物车，评论，商品，商品分类和订单详情这八个实体，以及它们之间的关系，还不能对应到具体的表，以及表于表之间的关联。我们需要把属性加上，用椭圆来表示，这样我们得到的 ER 模型就更加完整了。</p><p>因此，我们需要进一步去设计一下这个 ER 模型的各个局部，也就是细化下电商的业务流程，然后把它们综合到一起，形成一个完整的 ER 模型。这样可以帮助我们理清数据库的设计思路。</p><p>接下来分析一下各个实体都有哪些属性，如下所示。</p><ul><li><strong>地址实体</strong>包括用户编号、省、市、地区、收件人、联系电话、是否是默认地址。</li><li><strong>用户实体</strong>包括用户编号、用户名称、昵称、用户密码、手机号、邮箱、头像、用户级别。</li><li><strong>购物车实体</strong>包括购物车编号、用户编号、商品编号、商品数量、图片文件 URL。</li><li><strong>订单实体</strong>包括订单编号、收货人、收件人电话、总金额、用户编号、付款方式、送货地址、下单时间。</li><li><strong>订单详情实体</strong>包括订单详情编号、订单编号、商品名称、商品编号、商品数量。</li><li><strong>商品实体</strong>包括商品编号、价格、商品名称、分类编号、是否销售、规格、颜色。</li><li><strong>评论实体</strong>包括评论 ID、评论内容、评论时间、用户编号、商品编号。</li><li><strong>商品分类实体</strong>包括类别编号、类别名称、父类别编号。</li></ul><p>这样细分之后，我们就可以重新设计电商业务了，ER 模型如图：</p><p><img src="http://1.117.162.142:9000/blog/%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1ER%E6%A8%A1%E5%9E%8B-2.png" alt="电商业务ER模型-2"></p><h4 id="7-5-ER-模型图转换成数据表"><a href="#7-5-ER-模型图转换成数据表" class="headerlink" title="7.5 ER 模型图转换成数据表"></a>7.5 ER 模型图转换成数据表</h4><p>通过绘制 ER 模型，我们已经理清了业务逻辑，现在，我们就要进行非常重要的一步了：把绘制好的 ER 模型，转换成具体的数据表，下面介绍下转换的原则：</p><ul><li>一个实体通常转换成一个数据表；</li><li>一个多对多的关系，通常也转换成一个数据表；</li><li>一个一对一或者一对多的关系，往往通过表的外键来表达，而不是设计一个新的数据表；</li><li>属性转换成表的字段。</li></ul><p>下面结合前面的 ER 模型，具体讲解一下怎么运用这些转换的原则，把 ER 模型转换成具体的数据表，从而把抽象出来的数据模型，落实到具体的数据库设计当中。</p><p><strong>一个实体转换成一个数据表</strong></p><p><strong>首先是强实体转换成数据表</strong>：用户实体转换成用户表 (user_info) 的代码如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_info` (</span><br><span class="line">`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `user_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名称&#x27;</span>,</span><br><span class="line">  `nick_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户昵称&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户密码&#x27;</span>,</span><br><span class="line">  `phone_num` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  `head_imd` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;头像&#x27;</span>,</span><br><span class="line">  `user_level` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户级别&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>商品分类实体转换成商品分类表 (base_category)，由于商品分类可以有一级分类和二级分类，比如一级分类有家居、手机等等分类，二级分类可以根据手机的一级分类分为手机配件，运营商等，这里我们把商品分类实体规划为两张表，分别是一级分类表和二级分类表，之所以这么规划是因为一级分类和二级分类都是有限的，存储为两张表业务结构更加清晰。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 一级分类表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `base_category1` (</span><br><span class="line">`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>，</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类名称&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;一级分类表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 二级分类表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `base_category2` (</span><br><span class="line">`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;二级分类名称&#x27;</span>,</span><br><span class="line">  `category1_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;一级分类编号&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;二级分类表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>那么如果规划一张表，表结构如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `base_category` (</span><br><span class="line">`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;二级分类名称&#x27;</span>,</span><br><span class="line">  `category1_parent_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;父分类编号&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;分类表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果这样分类的话，那么查询一级分类的时候，就需要判断父分类编号是否为空，但是如果插入二级分类的时候也是空，就容易造成业务数据混乱。而且查询二级分类的时候 <code>IS NOT NULL</code> 条件是无法使用到索引的。同时，这样的设计也不符合第二范式 (因为父分类编号并不依赖分类编号 ID，因为父分类编号可以有很多数据为 NULL)，所以就需要进行表的拆分。因此无论是业务需求还是数据库表的规范来看都应该拆分为两张表。</p><p><strong>再把弱实体转换成数据表</strong>：</p><p>地址实体转换成地址表 (user_address)，如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_address` (</span><br><span class="line">`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `province` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;省&#x27;</span>,</span><br><span class="line">  `city` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;市&#x27;</span>,</span><br><span class="line">  `user_address` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;具体地址&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">  `consignee` <span class="type">varchar</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;收件人&#x27;</span>,</span><br><span class="line">  `phone_num` <span class="type">varchar</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;联系方式&#x27;</span>,</span><br><span class="line">  `is_fefault` <span class="type">varchar</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;是否是默认&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;用户地址表；&#x27;</span></span><br></pre></td></tr></table></figure><p>订单实体转换成订单表 (order_info)，如下所示，实际业务中订单的信息会非常多，这里做了简化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `order_info` (</span><br><span class="line">`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `consignee` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;收货人&#x27;</span>,</span><br><span class="line">  `consignee_tel` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;收件人电话&#x27;</span>,</span><br><span class="line">  `total_amount` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;总金额&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `payment_way` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;付款方式&#x27;</span>,</span><br><span class="line">  `delivery_address` <span class="type">varchar</span>(<span class="number">1000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;送货地址&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;下单时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;订单表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>订单详情实体转换成订单详情表 (order_detail)，如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 订单详情表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `order_detail` (</span><br><span class="line">`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;订单详情编号&#x27;</span>,</span><br><span class="line">  `order_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单编号&#x27;</span>,</span><br><span class="line">  `sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku_id&#x27;</span>,</span><br><span class="line">  `sku_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku 名称&#x27;</span>,</span><br><span class="line">  `sku_num` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;购买个数&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;订单明细表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>购物车实体转换成购物车表 (cart_info)，如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `cart_info` (</span><br><span class="line">`cart_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku_id&#x27;</span>,</span><br><span class="line">  `sku_num` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;数量&#x27;</span>,</span><br><span class="line">  `img_url` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;图片文件&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;购物车表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>评论实体转换成评论表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sku_comments` (</span><br><span class="line">`comment_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;评论编号&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户编号&#x27;</span>,</span><br><span class="line">  `sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku_id&#x27;</span>,</span><br><span class="line">  `comment` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;评论内容&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;评论时间&#x27;</span>,</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">45</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;商品评论表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>商品实体转换成商品表 (members)，如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sku_info` (</span><br><span class="line">`sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;商品编号itemID&#x27;</span>,</span><br><span class="line">  `price` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;价格&#x27;</span>,</span><br><span class="line">  `sku_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku 名称&#x27;</span>,</span><br><span class="line">  `sku_desc` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品规格描述&#x27;</span>,</span><br><span class="line">  `category3_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;三级分类id(冗余)&#x27;</span>,</span><br><span class="line">  `color` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;颜色&#x27;</span>,</span><br><span class="line">  `is_sale` tinyint(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;是否销售(1:是 0:否)&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">45</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;商品表&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>一个多对多的关系转换成一个数据表</strong></p><p>这个 ER 模型中的多对多的关系有 一个，即商品和订单之间的关系，同品类的商品可以出现在不同的订单中，不同的订单也可以包含同一类型的商品，所以它们之间的关系是多对多。针对这种情况需要设计一个独立的表来表示，这种表一般称为中间表。</p><p>我们可以设计一个独立的订单详情表，来代替商品和订单之间的包含关系。这个表关联到两个实体，分别是订单、商品。所以，表中必须要包括这两个实体转换成的表的主键。除此之外，我们还要包括该关系自有的属性：商品数量，商品下单价格以及商品名称。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 订单详情表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `order_detail` (</span><br><span class="line">`id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;订单详情编号&#x27;</span>,</span><br><span class="line">  `order_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单编号&#x27;</span>,</span><br><span class="line">  `sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku_id&#x27;</span>,</span><br><span class="line">  `sku_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku名称&#x27;</span>,</span><br><span class="line">  `sku_num` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;购买个数&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;订单明细表&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>通过外键来表达一对多的关系</strong></p><p>在上面的表的设计中，我们可以用外键来表达一对多的关系。比如在商品评论表 sku_comments 中，分别把 user_id、sku_id 定义成外键，以使用下面的语句设置外键。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONSTRAINT</span> fk_comment_user <span class="keyword">FOREIGN</span> KEY (user_id) <span class="keyword">REFERENCES</span> user_info (id),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_comment_sku <span class="keyword">FOREIGN</span> KEY (sku_id) <span class="keyword">REFERENCES</span> sku_info (sku_id)</span><br></pre></td></tr></table></figure><p>外键约束主要是在数据库层面上保证数据的一致性，但是因为插入和更新数据需要检查外键，理论上性能会有所下降，对性能是负面的影响。</p><p>实际的项目，不建议使用外键，一方面是降低开发的复杂度 (有外键的话主从表类的操作必须是先操作主表)，另外是有外键在处理数据的时候非常麻烦。在电商平台，由于并发业务量比较大，所以一般不设置外键，以免影响数据库性能。</p><p>在应用层面做数据的一致性检查，本来就是一个正常的功能需求。如学生选课的场景，课程肯定不是输入的，而是通过下来或者查找等方式从系统中进行选取，就能保证是合法的课程 ID，因此就不需要靠数据库的外键来检查了。</p><p><strong>把属性转换成表的字段</strong></p><p>在刚刚的设计中，我们也完成了把属性都转换成了表的字段，比如把商品属性转换成了商品信息表中的字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sku_info` (</span><br><span class="line">`sku_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;商品编号itemID&#x27;</span>,</span><br><span class="line">  `price` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;价格&#x27;</span>,</span><br><span class="line">  `sku_name` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;sku 名称&#x27;</span>,</span><br><span class="line">  `sku_desc` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品规格描述&#x27;</span>,</span><br><span class="line">  `category3_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;三级分类id(冗余)&#x27;</span>,</span><br><span class="line">  `color` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;颜色&#x27;</span>,</span><br><span class="line">  `is_sale` tinyint(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;是否销售(1:是 0:否)&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">45</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;商品表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>到这里，我们通过创建电商项目业务流程的 ER 模型，再把 ER 模型转换成具体的数据表的过程，完成了利用 ER 模型设计电商项目数据库的工作。</p><p>其实，任何一个机遇数据库的应用项目，都可以通过这种先建立 ER 模型，再转换成数据表的方式，完成数据库的设计工作。创建 ER 模型不是目的，目的是把业务逻辑梳理清楚，设计出优秀的数据库。建议不是为了建模而建模，要利用创建 ER 模型的过程来整理思路，这样创建 ER 模型才有意义。</p><p><img src="http://1.117.162.142:9000/blog/er%E6%A8%A1%E5%9E%8B.png" alt="er模型"></p><h3 id="8-数据表的设计原则"><a href="#8-数据表的设计原则" class="headerlink" title="8. 数据表的设计原则"></a>8. 数据表的设计原则</h3><p>综合以上内容，总结出数据表设计的一般原则：三少一多</p><ul><li><p>数据表的个数越少越好</p><p>  RDBMS 的核心在于对实体和联系的定义，也就是 E-R 图 (Entity Relationship Diagram)，数据表越少，证明实体和联系设计得越简洁，既方便理解又方便操作。</p></li><li><p>数据表中的字段个数越少越好</p><p>  字段个数越多，数据冗余的可能性越大。设置字段个数的前提是各个字段相互独立，而不是某个字段的取值可以由其他字段计算出来。当然字段个数少是相对的，我们通常会在数据冗余和检索效率中进行平衡。</p></li><li><p>数据表中联合主键的字段个数越少越好</p><p>  设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式 (也就是用多个字段来定义一个主键)。联合主键中的字段越多，占用的索引空间越大，不仅会加大理解难度，还会增加运行时间和索引空间，因此联合主键的字段个数越少越好。</p></li><li><p>使用主键和外键越多越好</p><p>  数据库的设计实际上就是定义各种表，以及各种字段之间的关系。这些关系越多，证明这些实体之间的冗余度越低，利用度越高。这样做的好处在于不仅保证了数据表之间的独立性，还能提升相互之间的关联使用率。</p></li></ul><p>三少一多原则的核心就是简单可复用。简单指的是用更少的表、更少的字段、更少的联合主键字段来完成数据表的设计。可复用则是通过主键、外键的使用来增强数据表之间的复用率。因为一个主键可以理解是一张表的代表。键设计得越多，证明它们之间的利用率越高。</p><blockquote><p>注意：这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。</p></blockquote><h3 id="9-数据库对象编写建议"><a href="#9-数据库对象编写建议" class="headerlink" title="9. 数据库对象编写建议"></a>9. 数据库对象编写建议</h3><h4 id="9-1-关于库"><a href="#9-1-关于库" class="headerlink" title="9.1 关于库"></a>9.1 关于库</h4><ul><li><p>【强制】库的名称必须控制在 32 个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。</p></li><li><p>【强制】库名中英文一律小写，不同单词采用下划线分割。须见名知意。</p></li><li><p>【强制】库的名称格式：业务系统名称_子系统名。</p></li><li><p>【强制】库名禁止使用关键字，如 type，order 等。</p></li><li><p>【强制】创建数据库时必须显示指定字符集，并且字符集只能是 utf8 或者 utf8mb4.</p><p>  创建数据库 SQL 举例：<code>CREATE DATABASE crm_fund DEFAULT CHARACTER SET &#39;utf8&#39;;</code></p></li><li><p>【建议】对于程序连接数据库账号，遵循权限最小原则</p><p>  使用数据库账号只能在一个 DB 下使用，不准跨库。程序使用的账号原则上不准有 DROP 权限。</p></li><li><p>【建议】临时库以 tmp_ 为前缀，并以日期为后缀。备份库以 bak_ 为前缀，并以日期为后缀。</p></li></ul><h4 id="9-2-关于表、列"><a href="#9-2-关于表、列" class="headerlink" title="9.2 关于表、列"></a>9.2 关于表、列</h4><ul><li><p>【强制】表和列的名称必须控制在 32 个字符以内，表明只能使用英文字母、数字和下划线，建议以英文字母开头。</p></li><li><p>【强制】表明、列名一律小写，不同单词采用下划线分割。须见名知意。</p></li><li><p>【强制】表明要求有模块名强相关，同一模块的表明尽量使用统一前缀。比如：crm_fund_item</p></li><li><p>【强制】创建表时必须显式指定字符集为 utf8 或 utf8mb4。</p></li><li><p>【强制】表名、列名禁止使用关键字 (如 type、order 等)</p></li><li><p>【强制】创建表时必须显式指定表存储引擎类型。如无特殊需求，一律为 InnoDB。</p></li><li><p>【强制】建表必须有 comment。</p></li><li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或缩写。如：公司 ID，不要使用 corporation_id，而用 corp_id。</p></li><li><p>【强制】布尔值类型的字段命名为 is_描述。如 member 表上表示是否为 enabled 的会员的字段命名为 is_enabled。</p></li><li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据。</p><p>  通常文件很大，短时间内造成数据量快速增长，数据库进行数据读取时，通常会进行大量的随机 I&#x2F;O 操作，文件很大时，IO 操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</p></li><li><p>【建议】建表时关于主键：表必须有主键</p><ul><li>强制要求主键为 id，类型为 int 或 bigint，且为 AUTO_INCREMENT 建议使用 UNSIGNED 无符号型。</li><li>标识表里每一行主体的字段不要设为主键，建议设为其他字段如 user_id，order_id 等，并建立 unique key 索引。因为如果设为主键且主键值为随机插入，则会导致 innodb 内部页分裂和大量随机 I&#x2F;O，性能下降。</li></ul></li><li><p>【建议】核心表 (如用户表) 必须有行数据的创建时间字段 (create_time) 和最后更新时间字段 (update_time)，便于查问题。</p></li><li><p>【建议】表中所有字段尽量都是 NOT NULL 属性，业务可以根据需要定义 DEFAULT 值。</p><p>  因为使用 NULL 值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</p></li><li><p>【建议】所有存储相同数据的列名和列类型必须一致 (一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，到值查询效率降低)。</p></li><li><p>【建议】中间表 (或临时表) 用于保留中间结果集，名称以 tmp_ 开头。备份表用于备份或抓取原表快照，名称以 bak_ 开头。中间表和备份表定期清理。</p></li><li><p>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语句，方便数据库和数据表结构的导出和导入。</p></li></ul><h4 id="9-3-关于索引"><a href="#9-3-关于索引" class="headerlink" title="9.3 关于索引"></a>9.3 关于索引</h4><ul><li><p>【强制】InnoDB 表必须主键为 id int &#x2F; bigint auto_increment，且主键值禁止被更新。</p></li><li><p>【强制】InnoDB 和 MyISAM 存储引擎表，索引类型必须为 BTREE。</p></li><li><p>【建议】主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_ 开头，一律使用小写格式，以字段的名称或缩写作为后缀。</p></li><li><p>【建议】多单词组成的 columnname，取前几个单词首字母，加末单词组成 column_name。如：sample 表member_id 上的索引：idx_sample_mid。</p></li><li><p>【建议】单个表上的索引个数不能超过 6 个。</p></li><li><p>【建议】在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面。</p></li><li><p>【建议】在多表 JOIN 的 SQL 里，保证被驱动表的连接列上有索引，这样 JOIN 执行效率最高。</p></li><li><p>【建议】建表或加索引时，保证表里互相不存在冗余索引。</p><p>  比如：如果表里已经存在 key(a,b)，则 key(a) 为冗余索引，需要删除。</p></li></ul><h4 id="9-4-SQL-编写"><a href="#9-4-SQL-编写" class="headerlink" title="9.4 SQL 编写"></a>9.4 SQL 编写</h4><ul><li><p>【强制】程序端 SELECT 语句必须指定具体字段名称，禁止写成 *。</p></li><li><p>【建议】程序端 INSERT 语句制定具体字段名称，不要写成 INSERT INTO t1 VALUES(…)。</p></li><li><p>【建议】除静态表或小表 (100 行以内)，DML 语句必须有 WHERE 条件，且使用索引查找。</p></li><li><p>【建议】INSERT INTO … VALUES(xx),(xx),(xx).. 这里 xx 的值不要超过 5000 个。值过多虽然上线很快，但会引起主从同步延迟。</p></li><li><p>【建议】SELECT 语句不要使用 UNION，推荐使用 UNION ALL，并且 UNION 字句个数限制在 5 个以内。</p></li><li><p>【建议】线上环境，多表 JOIN 不要超过 5 个表。</p></li><li><p>【建议】减少使用 ORDER BY，和业务沟通能不排序就不排序，获奖排序放到程序段去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费 CPU，数据库的 CPU 资源是极其宝贵的。</p></li><li><p>【建议】包含了 ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在 1000 行以内，否则 SQL 会很慢。</p></li><li><p>【建议】对单表的多次 ALTER 操作必须合并为一次</p><p>  对于超过 100w 行的大表进行 alter table，必须经过 DBA 审核，并在业务低峰期执行，多个 alter 需整合在一起。因为 alter table 会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</p></li><li><p>【建议】批量操作数据时，需要控制事物处理间隔时间，进行必要的 sleep。</p></li><li><p>【建议】事物里包含 SQL 不超过 5 个。</p><p>  因为过长的事物会导致锁数据较久，MySQL 内部缓存、连接消耗过多等问题。</p></li><li><p>【建议】事物里更新语句尽量基于主键或 UNIQUE KEY，如 UPDATE … WHERE id &#x3D; xxx;</p><p>  否则会产生间隙锁，内部扩大锁定范围，到值系统性能下降，产生死锁。</p></li></ul><h2 id="十、数据库其它调优策略"><a href="#十、数据库其它调优策略" class="headerlink" title="十、数据库其它调优策略"></a>十、数据库其它调优策略</h2><h3 id="1-数据库调优的措施"><a href="#1-数据库调优的措施" class="headerlink" title="1. 数据库调优的措施"></a>1. 数据库调优的措施</h3><h4 id="1-1-调优的目标"><a href="#1-1-调优的目标" class="headerlink" title="1.1 调优的目标"></a>1.1 调优的目标</h4><ul><li>尽可能节省系统资源，以便系统可以提供更大负荷的服务。(吞吐量更大)</li><li>合理的结构设计和参数调整，以提高用户操作响应的速度。(响应速度更快)</li><li>减少系统的瓶颈，提高 MySQL 数据库整体的性能。</li></ul><h4 id="1-2-如何定位调优问题"><a href="#1-2-如何定位调优问题" class="headerlink" title="1.2 如何定位调优问题"></a>1.2 如何定位调优问题</h4><p>不过随着用户量的不断增加，以及应用程序复杂度的提升，我们很难用更快取定义数据库调优的目标，因为用户在不同时间段访问服务器遇到的瓶颈不同，比如双十一促销的时候会带来大规模的并发访问；还有用户在进行不同业务操作的时候，数据库的事物处理和 SQL 查询都会有所不同。因此我们还需要更加精细的定位，取确定调优的目标。一般情况下，有如下几种方式：</p><ul><li><p>用户的反馈 (主要)</p><p>  用户是我们服务对象，因此它们的反馈是最直接的。虽然它们不会直接提出技术建议，但是有些问题往往是用户第一时间发现的。我们要重视用户的反馈，找到和数据相关的问题。</p></li><li><p>日志分析 (主要)</p><p>  可以通过查看数据库日志和操作系统日志等方式找出异常情况，通过它们来定位遇到的问题。</p></li><li><p>服务器资源使用监控</p><p>  通过监控服务器的 CPU、内存、I&#x2F;O 等使用情况，可以实时了解服务器的性能使用，与历史情况进行对比。</p></li><li><p>数据库内部状况监控</p><p>  在数据库的监控中，活动会话 (Active Session) 监控是一个重要的指标。通过它，可以清楚地了解数据库当前是否处于非常繁忙的状态，是否存在 SQL 堆积等。</p></li><li><p>其它</p><p>  除了活动会话监控以外，我们也可以对事物、锁等待等进行监控，这些都可以帮助我们对数据库的运行状态有更全面的认识。</p></li></ul><h4 id="1-3-调优的维度和步骤"><a href="#1-3-调优的维度和步骤" class="headerlink" title="1.3 调优的维度和步骤"></a>1.3 调优的维度和步骤</h4><p>我们需要调优的对象是整个数据库管理系统，它不仅包括 SQL 查询，还包括数据库的部署配置、架构等。从这个角度来说，我们思考的维度就不仅仅局限在 SQL 优化上了。通过如下的步骤我们进行梳理：</p><p><strong>第一步：选择适合的 DBMS</strong></p><p>如果对事务性处理以及安全性要求高的话，可以选择商业的数据库产品。这些数据库在事物处理和查询性能上都比较强，比如采用 SQL Server、Oracle，那么单表存储上亿条数据是没有问题的。如果数据表设计得好，即使不采用分库分表的方式，查询效率也不差。</p><p>出此以外，也可以采用开源的 MySQL 进行存储，他有很多存储引擎可以选择，如果进行事物处理的话可以选择 InnoDB，非事物处理可以选择 MyISAM。</p><p>NoSQL 阵营包括键值型数据库、文档型数据库、搜索引擎、列式存储和图形数据库。这些数据库的优缺点和使用场景各有不同，比如列式存储数据库可以大幅度降低系统的 I&#x2F;O，适合于分布式文件系统，但如果数据需要频繁地增删改，那么列式存储就不太适用了。</p><p>DBMS 的选择关系到了后面的整个设计过程，所以第一步就是要选择合适的 DBMS。如果已经确定了 DBMS，那么这步可以跳过。</p><p><strong>第二步：优化表设计</strong></p><p>选择了 DBMS 之后，我们就需要进行表设计了。而数据表的设计方式也直接影响了后续的 SQL 查询语句。RDBMS 中，每个对象都可以定义为一张表，表于表之间的关系代表了对象之间的关系。如果用的是 MySQL，我们还可以根据不同的使用需求，选择不同的存储引擎。除此以外，还有一些优化的原则可以参考：</p><ul><li>表结构要尽量遵循三范式的原则。这样可以让数据结构更加清晰规范，减少冗余字段，同时也减少了在更新、插入和删除数据时等异常情况的发生。</li><li>如果查询应用比较多，尤其是需要进行多表联查的时候，可以采用反范式进行优化。反范式采用空间换时间的方式，通过增加冗余字段提高查询的效率。</li><li>表字段的数据类型选择，关系到了查询效率的高低以及存储空间的大小。一般来说，如果字段可以采用数值类型就不要采用字符类型；字符长度要尽可能设计得短一些。针对字符类型来说，当确定字符长度固定时，就可以采用 CHAR 类型；当长度不固定时，通常采用 VARCHAR 类型。</li></ul><p>数据表的结构设计很基础，也很关键。好的表结构可以在业务发展和用户量增加的情况下依然发挥作用，不好的表结构设计会让数据表变得非常臃肿，查询效率也会降低。</p><p><strong>第三步：优化逻辑查询</strong></p><p>当我们建立好数据表之后，就可以对数据表进行增删改查的操作了。这时我们首先需要考虑的是逻辑查询优化。SQL 查询优化，可以分为逻辑查询优化和物理查询优化。逻辑查询优化就是通过改变 SQL 语句的内容让 SQL 执行效率更高效，采用的方式是对 SQL 语句进行等价变换，对查询进行重写。</p><p><strong>SQL 的查询重写包括了子查询优化、等价谓词重写、视图重写、条件简化、连接消除和嵌套连接消除等</strong>。</p><p>比如用到 EXISTS 子查询和 IN 子查询的时候，会根据小表驱动大表的原则选择适合的子查询。在 WHERE 字句中会尽量避免对字段进行函数运算，它们会让字段的索引失效。</p><p>举例：查询评论内容开头为 abc 的内容都有哪些，如果在 WHERE 字句中使用了函数，语句就会写成下面这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> comment_id, comment_text, comment_time <span class="keyword">FROM</span> product_comment <span class="keyword">WHERE</span> <span class="built_in">SUBSTRING</span>(comment_text, <span class="number">1</span>, <span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p>采用查询重写的方式进行等价替换：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> comment_id, comment_text, comment_time <span class="keyword">FROM</span> product_comment <span class="keyword">WHERE</span> comment_text <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>第四步：优化物理查询</strong></p><p>物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术 (比如索引等)，通过计算代价模型对各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。<strong>在这个部分中，我们需要掌握的重点是对索引的创建和使用</strong>。</p><p>但索引不是万能的，我们需要根据实际情况来创建索引。SQL 查询时需要对不同的数据表进行查询，因此在屋里查询优化阶段也需要确定这些查询所采用的路径，具体的情况包括：</p><ul><li>单表扫描：对于单表扫描来说，我们可以全表扫描所有的数据，也可以局部扫描。</li><li>两张表的连接：常用的连接方式包括了嵌套循环连接、HASH 连接和合并连接。</li><li>多张表的连接：多张数据表进行连接的时候，顺序很重要，因为不同的连接路径查询的效率不同，搜索空间也会不同。我们在进行多表连接的时候，搜索空间可能会达到很高的数据量级，巨大的搜索空间显然会占用更多的资源，因此我们需要通过调整连接顺序，将搜索空间调整在一个可接受的范围内。</li></ul><p><strong>第五步：使用 Redis 或 memcached 作为缓存</strong></p><p>除了可以对 SQL 本身进行优化以外，我们还可以请外援提升查询的效率。</p><p>因为数据都是存放到数据库中，我们需要从数据库层中取出数据放到内存中进行业务逻辑的操作，当用户量增大的时候，如果频繁地进行数据查询，会消耗数据库的很多资源。如果我们将常用的数据直接放到内存中，就会大幅提升查询的效率。</p><p>常用的键值存储数据库有 Redis 和 Memcached，它们都可以将数据存放到内存中。</p><p>从可靠性来说，Redis 支持持久化，可以让我们的数据保存在硬盘上，不过这样一来性能消耗也会比较大。而 Memcache 仅仅是内存存储，不支持持久化。</p><p>从支持的数据类型来说，Redis 比 Memcached 要多，它不仅支持 key-value 类型的数据，还支持 List、Set、Hash等数据结构。当我们有持久化需求或者是更高级的数据处理需求的时候，就可以使用 Redis。如果是简单的 key-value 存储，则可以使用 Memcached。</p><p><strong>通常我们对于查询响应要求高的场景 (响应时间短，吞吐量大)，可以考虑内存数据库，毕竟术业有专攻</strong>。传统的 RDBMS 都是将数据存储在硬盘上，而内存数据库则存放在内存中，查询起来要快得多。不过使用不同的工具，也增加了开发人员的使用成本。</p><p><strong>第六步：库级优化</strong></p><p>库级优化是站在数据库的维度上进行的优化策略，比如控制一个库中的数据表数量。另外，单一的数据库总会遇到各种限制，不如取长补短，利用外援的方式。通过主从架构优化我们的读写策略，通过对数据库进行垂直或者水平切分，突破单一数据库或数据表的访问限制，提升查询的性能。</p><p><strong>读写分离</strong></p><p>如果读和写的业务量都很大，并且它们都在同一个数据库服务器中进行操作，那么数据库的性能就会出现瓶颈，这时为了提升系统的性能，优化用户体验，我们可以采用读写分离的方式降低主数据库的负载，比如用主数据库 (master) 完成写操作，用从数据库 (slave) 完成读操作。</p><p><img src="http://1.117.162.142:9000/blog/%E4%B8%80%E4%B8%BB%E4%B8%80%E4%BB%8E%E6%A8%A1%E5%BC%8F.png" alt="一主一从模式"></p><p><img src="/myslq/%E5%8F%8C%E4%B8%BB%E5%8F%8C%E4%BB%8E%E6%A8%A1%E5%BC%8F.png" alt="双主双从模式"></p><p><strong>数据分片</strong></p><p>对数据库分库分表。当数据量级达到千万级以上时，有时候我们需要把一个数据库切分成多份，放到不同的数据库服务器上，减少对单一数据库服务器的访问压力。如果你使用的是 MySQL，就可以使用 MySQL 自带的分区表功能，当然你也可以考虑自己做垂直拆分 (分库)、水平拆分 (分表)、垂直+水平拆分 (分库分表)。</p><p><img src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87-1.png" alt="数据分片"></p><p><img src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87-2.png" alt="数据分片"></p><blockquote><p>但需要注意的是，拆分在提升数据库性能的同时，也会增加维护和使用成本。</p></blockquote><h3 id="2-优化-MySQL-服务器"><a href="#2-优化-MySQL-服务器" class="headerlink" title="2. 优化 MySQL 服务器"></a>2. 优化 MySQL 服务器</h3><p>优化 MySQL 服务器主要从两个方面来优化，一方面是对硬件进行优化；另一方面是对 MySQL 服务的参数进行优化。这部分的内容需要较全面的知识，一般只有专业的数据库管理员才能进行这一类的优化。对于可以定制参数的操作系统，也可以针对 MySQL 进行操作系统优化。</p><h4 id="2-1-优化服务器硬件"><a href="#2-1-优化服务器硬件" class="headerlink" title="2.1 优化服务器硬件"></a>2.1 优化服务器硬件</h4><p><strong>服务器的硬件性能直接决定着 MySQL 数据库的性能</strong>。硬件的性能瓶颈直接决定 MySQL 数据库的运行速度和效率。针对性能瓶颈提高硬件配置，可以提高 MySQL 数据库查询、更新的速度。</p><ul><li>配置较大的内存。足够大的内存是提高 MySQL 数据库性能的方法之一。内存的速度比磁盘 I&#x2F;O 快得多，可以通过增加系统的缓冲区容量使数据在内存中停留的时间更长，以减少磁盘 I&#x2F;O。</li><li>配置高速磁盘系统，以减少读盘的等待时间，提高响应速度。磁盘的 I&#x2F;O 能力，也就是它的寻道能力，目前的 SCSI 高速旋转的是 7200 转&#x2F;分钟，这样的速度，一旦访问的用户量上去，磁盘的压力就会过大，如果是每天的网站 pv (page view) 在 150w，这样的一般配置就无法满足这样的需求了。现在 SSD 盛行，在 SSD 上随机访问和顺序访问性能几乎差不多，使用SSD 可以减少随机 I&#x2F;O 带来的性能损耗。</li><li>合理分布磁盘 I&#x2F;O，把磁盘 I&#x2F;O 分散在多个设备上，以减少资源竞争，提高并行操作能力。</li><li>配置多处理器，MySQL 是多线程的数据库，多处理器可同时执行多个线程。</li></ul><h4 id="2-2-优化-MySQL-的参数"><a href="#2-2-优化-MySQL-的参数" class="headerlink" title="2.2 优化 MySQL 的参数"></a>2.2 优化 MySQL 的参数</h4><p>通过优化 MySQL 的参数可以提高资源利用率，从而达到提高 MySQL 服务器性能的目的。</p><p>MySQL 服务的配置参数都在 my.cnf 或者 my.ini 文件的 [mysqld] 组中。配置完参数以后，需要重新启动 MySQL 服务器才会生效。下面对几个对性能影响比较大的参数进行详细介绍。</p><ul><li><p><code>innodb_buffer_pool_size</code>：这个参数是 My SQL 数据库最重要的参数之一，表示 InnoDB 类型的表和索引的最大缓存。它不仅仅缓存索引数据，还会缓存表的数据。这个值越大，查询的速度就会越快。但是这个值太大会影响操作系统的性能。</p></li><li><p><code>key_buffer_size</code>：表示索引缓冲区的大小。索引缓冲区是所有的线程共享。增加索引缓冲区可以得到更好处理的索引 (对所有读和多重写)。当然，这个值不是越大越好，它的大小取决于内存的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在 4GB 左右的服务器该参数可设置为 256M 或 384M。</p></li><li><p><code>table_cache</code>：表示同时打开的表的个数。这个值越大，能够同时打开的表的个数越多。物理内存越大，设置就越大。默认为2402，调到 512-1024 最佳。这个值不是越大越好，因为同时打开的表太多会影响操作系统的性能。</p></li><li><p><code>query_cache_size</code>：表示查询缓冲区的大小。可以通过 MySQL控制台观察，如果 Cache_lowmem_prunes 的值非常大，则表明经常出现缓冲不够的情况，就要增加 Query_cache_size 的值；如果 Qcache_hits 的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区碎片很多。MySQL 8.0 之后失效。该参数需要和 query_cache_type 配合使用。</p></li><li><p><code>query_cache_type</code> 的值是 0 时，所有的查询都不使用查询缓存区。但是 query_cache_type&#x3D;0 并不会导致 MySQL 释放 query_cache_size 所配置的缓存区内存。</p><ul><li>当 query_cache_type&#x3D;1 时，所有的查询都将使用查询缓存区，除非在查询语句中指定 SQL_NO_CACHE，如果 SELECT SQL_NO_CACHE * FROM tel_name。</li><li>当 query_cache_type&#x3D;2 时，只有在查询语句中使用 SQL_CACHE 关键字，查询才会使用查询缓存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的查询操作的情况。</li></ul></li><li><p><code>sort_buffer_size</code>：表示每个需要进行排序的线程分配的缓冲区的大小。增加这个参数的值可以提高 ORDER BY 或 GROUP BY 操作的速度。默认数值是 2097144字节 (约 2MB)。对于内存在 4GB 左右的服务器推荐设置为 6-8M，如果有 100个连接，那么实际分配的总共排序缓冲区大小为 100 * 6 &#x3D; 600MB。</p></li><li><p><code>join_buffer_size=8M</code>：表示联合查询操作所能使用的缓冲区大小，和 sort_buffer_size 一样，该参数对应的分配内存也是每个连接独享。</p></li><li><p><code>read_buffer_size</code>：表示每个线程连续扫描时为扫描的每个表分配的缓冲区的大小 (字节)。当线程从表中连续读取记录时需要用到这个缓冲区。 SET SESSION read_buffer_size&#x3D;n 可以临时设置该参数的值。默认为 64k，可以设置为 4M。</p></li><li><p><code>innodb_flush_log_at_trx_commit</code>：表示何时将缓冲区的数据写入日志文件，并且将日志文件写入磁盘中。该参数对于 InnoDB 引擎非常重要。该参数有 3 个值，分别为 0、1 和 2 该参数的默认值为 1。</p><ul><li>值为 0 时，表示每秒 1 次的频率将数据写入日志文件并将日志文件写入磁盘。每个事物的 COMMIT 并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld 进程的崩溃会导致上一秒钟所有事物数据的丢失。</li><li>值为 1 时，表示每次提交事物时将数据写入日志文件并将日志文件写入磁盘进行同步。该模式是最安全的，但也是最慢的一种方式。因为每次事物提交或事物外的指令都需要把日志写入 (flush) 磁盘。</li><li>值为 2 时，表示每次提交事物时将数据写入日志文件，每隔 1 秒将日志文件写入磁盘。该模式速度较快，也比 0 安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事物数据才可能丢失。</li></ul></li><li><p><code>innodb_log_buffer_size</code>：这是 InnoDB 存储引擎的 事物日志所使用的缓冲区。为了提高性能，也是先将信息写入 InnoDB Log Buffer 中，当满足 in no d b_flush_log_trx_commit 参数所设置的相应条件 (或者日志缓冲区写满) 之后，才会将日志写到文件 (或者同步到磁盘) 中。</p></li><li><p><code>max_connections</code>：表示允许连接到 MySQL 数据库的最大数量，默认值是 151。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这时可以考虑增大 max_connections 的值。在 Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数不是越大越好，因为这些连接会浪费内存的资源。过多的连接可能会导致 MySQL 服务器僵死。</p></li><li><p><code>back_log</code>：用于控制 MySQL 监听 TCP 端口时设置的积压请求栈大小。如果 MySQL 的连接数达到 max_connections 时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即 back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50，之后的版本默认为 50 + (max_connections &#x2F; 5)，对于 Linux 系统推荐设置为小于 512 的整数，但最大不超过 900。如果需要数据库在较短的时间内处理大量连接请求，可以考虑适当增大 back_log 的值。</p></li><li><p><code>thread_cache_size</code>：线程池缓存线程数量的大小，当客户端断开链接后将当前线程缓存起来，当在接到新的连接请求时快速响应无需创建新的线程。这尤其对那些使用短连接的应用程序来说可以极大的提高创建连接的效率。那么为了提高可以增大该参数的值。默认为 60，可以设置为 120。</p><p>  可以通过如下几个 MySQL 状态值来适当调整线程池的大小：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Thread%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>  当 Thread_cached 越来越少，但 Threads_connected 始终不降，且 Threads_created 持续升高，可适当增加 thread_cache_size 的大小。</p></li><li><p><code>wait_timeout</code>：指定一个请求的最大连接时间，对于 4GB 左右内存的服务器可以设置为 5-10。</p></li><li><p><code>interactive_timeout</code>：表示服务器在关闭连接前等待行动的秒数。</p></li></ul><p>这里给出一份 my.cnf 的参考配置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">port<span class="operator">=</span><span class="number">3306</span></span><br><span class="line">serverid<span class="operator">=</span><span class="number">1</span></span><br><span class="line">socket<span class="operator">=</span><span class="operator">/</span>tmp<span class="operator">/</span>mysql.sock</span><br><span class="line"><span class="keyword">skip</span><span class="operator">-</span>locking</span><br><span class="line"># 避免 MySQL 的外部锁定，减少出错几率增强稳定性。</span><br><span class="line"><span class="keyword">skip</span><span class="operator">-</span>name<span class="operator">-</span>resolve</span><br><span class="line"># 禁止 MySQL 对外部连接进行 DNS 解析，使用这一选项可以消除 MySQL 进行 DNS 解析的时间。但需要注意，如果开启该选项，则所有远程主机授权都要使用 IP 地址方式，否则 MySQL 将无法正常处理连接请求！</span><br><span class="line">back_log<span class="operator">=</span><span class="number">384</span></span><br><span class="line">key_buffer_size<span class="operator">=</span><span class="number">256</span>M</span><br><span class="line">max_allowed_packet<span class="operator">=</span><span class="number">4</span>M</span><br><span class="line">thread_stack<span class="operator">=</span><span class="number">256</span>k</span><br><span class="line">table_cache<span class="operator">=</span><span class="number">128</span>k</span><br><span class="line">sort_buffer_size<span class="operator">=</span><span class="number">6</span>M</span><br><span class="line">read_buffer_size<span class="operator">=</span><span class="number">4</span>M</span><br><span class="line">read_rnd_buffer_size<span class="operator">=</span><span class="number">16</span>M</span><br><span class="line">join_buffer_size<span class="operator">=</span><span class="number">8</span>M</span><br><span class="line">myisam_sort_buffer_size<span class="operator">=</span><span class="number">64</span>M</span><br><span class="line">table_cache<span class="operator">=</span><span class="number">512</span></span><br><span class="line">thread_cache_size<span class="operator">=</span><span class="number">64</span></span><br><span class="line">query_cache_size<span class="operator">=</span><span class="number">64</span>M</span><br><span class="line">tmp_table_size<span class="operator">=</span><span class="number">256</span>M</span><br><span class="line">max_connections<span class="operator">=</span><span class="number">768</span></span><br><span class="line">max_connect_errors<span class="operator">=</span><span class="number">10000000</span></span><br><span class="line">wait_timeout<span class="operator">=</span><span class="number">10</span></span><br><span class="line">thread_concurrency<span class="operator">=</span><span class="number">8</span></span><br><span class="line"># 该参数取值为服务器逻辑CPU数量<span class="operator">*</span><span class="number">2</span>，在本例中，服务器有两颗物理CPU，而每颗物理CPU又支持H.T超线程，所以实际取值为<span class="number">4</span><span class="operator">*</span><span class="number">2</span><span class="operator">=</span><span class="number">8</span></span><br><span class="line"><span class="keyword">skip</span><span class="operator">-</span>networking</span><br><span class="line"># 开启该选项可以彻底关闭 MYSQL 的 TCP<span class="operator">/</span>IP 连接方式，如果 WEB 服务器是以远程连接的方式访问 MYSQL 数据库服务器则不要开启该选项！否则将无法正常连接</span><br><span class="line">table_cache<span class="operator">=</span><span class="number">1024</span></span><br><span class="line">innodb_additional_mem_pool_size<span class="operator">=</span><span class="number">4</span>M</span><br><span class="line"># 默认为 <span class="number">2</span>M</span><br><span class="line">innodb_flush_log_at_trx_commit<span class="operator">=</span><span class="number">1</span></span><br><span class="line">innodb_log_buffer_size<span class="operator">=</span><span class="number">2</span>M</span><br><span class="line"># 默认为 <span class="number">1</span>M</span><br><span class="line">innodb_thread_concurrency<span class="operator">=</span><span class="number">8</span></span><br><span class="line"># 你的服务器 CPU 有几个就设置为几。建议用默认一般为 <span class="number">8</span></span><br><span class="line">tmp_table_size<span class="operator">=</span><span class="number">64</span>M</span><br><span class="line"># 默认为 <span class="number">16</span>M，调到 <span class="number">64</span>～<span class="number">256</span> 最佳</span><br><span class="line">thread_cache_size<span class="operator">=</span><span class="number">120</span></span><br><span class="line">query_cache_size<span class="operator">=</span><span class="number">32</span>M</span><br></pre></td></tr></table></figure><p>很多情况还需要具体情况具体分析！</p><p><strong>举例</strong>：</p><p>下面是一个电商平台，类似京东或天猫这样的平台。商家购买服务，入驻平台，开通之后，商家可以在系统中上架各种商品，客户通过手机 App、微信小程序等渠道购买商品，商家接到订单以后安排快递送货。</p><p>刚刚上线的时候，系统运行状态良好。但是，随着入住的商家不断增多，使用系统的用户量越来越多，每天的订单数据达到了 5 万条以上。这个时候，系统开始出现问题，CPU 使用率不断飙升。终于，双十一或者 618 活动高峰的时候，CPU 使用率达到 99%，这实际上就意味着，系统的计算资源已经耗尽，再也无法处理任何新的订单了。换句话说，系统已经崩溃了。</p><p>这个时候，我们想到了对系统参数进行调整，因为参数的值决定了资源配置的方式和投放的程度。</p><p>为了解决这个问题，一共调整了 3 个系统参数，分别是</p><ul><li>InnoDB_flush_log_at_trx_commit</li><li>InnoDB_buffer_pool_size</li><li>InnoDB_buffer_pool_instances</li></ul><p>下面我们就说一说调整这三个参数的原因是什么。</p><p><strong>调整系统参数 InnoDB_flush_log_at_trx_commit</strong></p><p>这个参数适用于 InnoDB 存储引擎，电商平台系统中的表用的存储引擎都是 InnoDB。默认的值是 1，意思是每次提交事物的时候，都把数据写入日志，并把日志写入磁盘。这样做的好处是数据安全性最佳，不足之处在于每次提交事物，都要进行磁盘写入的操作。在大并发的场景下，过于频繁的磁盘读写会导致 CPU 资源浪费，系统效率变低。</p><p>这个参数的值还有 2 个可能的选项，分别是 0 和 2。我们把这个参数的值改成了 2.这样就不用每次提交事物的时候都启动磁盘读写了，在大并发的场景下，可以改善系统效率，降低 CPU 使用率。即便出现故障，损失的数据也比较小。</p><p><strong>调整系统参数 InnoDB_buffer_pool_size</strong></p><p>这个参数的意思是，InnoDB 存储引擎使用缓存来存储索引和数据。这个值越大，可以加载到缓存区的索引和数据量就越多，需要的磁盘读写就越少。</p><p>因为我们的 MySQL 服务器是数据库专属服务器，只用来运行 MySQL 数据库服务，没有其他应用了，而我们的计算机是 64 位机器，内存也有 128G。于是我们把这个参数的值调整为 64G。这样一来，磁盘读写次数可以大幅降低，我们就可以充分利用内存，释放出一些 CPU 的资源。</p><p><strong>调整系统参数 InnoDB_buffer_pool_instances</strong></p><p>这个参数可以讲 InnoDB 的缓存区分成几个部分，这样可以提高系统的并行处理能力，因为可以允许多个进程同时处理不同部分的缓存区。</p><p>我们把 InnoDB_buffer_pool_instances 的值修改为 64，意思就是把 InnoDB 的缓存区分成 64 个分区，这样就可以同时有多个进程进行数据操作，CPU 的效率就高多了。修改好了系统参数的值，要重启 MySQL 数据库服务器。</p><blockquote><p>总结一下就是遇到 CPU 资源不足的问题，可以从下面两个思路去解决。</p><ul><li>疏通拥堵路段，消除瓶颈，让等待的时间更短；</li><li>开拓新的通道，增加并行处理能力。</li></ul></blockquote><h3 id="3-优化数据库结构"><a href="#3-优化数据库结构" class="headerlink" title="3. 优化数据库结构"></a>3. 优化数据库结构</h3><p>一个好的数据库设计方案对于数据库的性能常常会起到事半功倍的效果。合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p><h4 id="3-1-拆分表：冷热数据分离"><a href="#3-1-拆分表：冷热数据分离" class="headerlink" title="3.1 拆分表：冷热数据分离"></a>3.1 拆分表：冷热数据分离</h4><p>拆分表的思路是，把一个包含很多字段的表拆分成 2 个或者多个相对较小的表。这样做的原因是，这些表中某些字段的操作频率很高 (热数据)，经常要进行查询或者更新操作，而另外一些字段的使用频率却很低 (冷数据)，冷热数据分离，可以减小表的宽度。如果放在一个表里面，每次查询都要读取大记录，会消耗较多的资源。</p><p>MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。表越宽，把表装载进内存缓冲池时所占用的内存也就越大，会消耗更多的 IO。冷热数据分离的目的是：减少磁盘 IO，保证热数据的内存缓存命中率；更有效的利用缓存，避免读入无用的冷数据。</p><p>举例：会员 members 存储会员登录认证信息，该表中有很多字段，如 id、姓名、密码、地址、电话、个人描述字段。其中地址、电话、个人描述等字段并不常用，可以将这些不常用的字段分解出另一个表。将这个表取名叫 members_detail，表中有 member_id、address、telephone、description 等字段。这样就把会员表分成了两个表，分别为 members 和 members_detail 表。</p><p>创建这两个表的 SQL 语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> members (</span><br><span class="line">id <span class="type">int</span>() <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  username <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  password <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  last_login_time datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  last_login_ip <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> members_detail (</span><br><span class="line">member_id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  address <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  telephone <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  description text</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果需要查询会员的基本信息或详细信息，那么可以用会员的 id 来查询。如果需要将会员的基本信息和详细信息同时显示，那么可以将 members 表和 members_detail 表进行联合查询，查询语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> members <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> members_detail <span class="keyword">ON</span> members.id <span class="operator">=</span> members_detail.member_id;</span><br></pre></td></tr></table></figure><p>通过这种分解可以提高表的查询效率。对于字段很多且有些字段使用不频繁的表，可以通过这种分解的方式来优化数据库的性能。</p><h4 id="3-2-增加中间表"><a href="#3-2-增加中间表" class="headerlink" title="3.2 增加中间表"></a>3.2 增加中间表</h4><p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，<strong>把需要经常李娜和查询的数据插入中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率</strong>。</p><p>首先，分析经常联合查询表中的字段；然后，使用这些字段建立一个中间表，并将原来联合查询的表的数据插入中间表中；最后，使用中间表来进行查询。</p><p>举例：学生信息表和班级表的 SQL 语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `class` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `className` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `address` <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `monitor` <span class="type">INT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `stuno` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `classId` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>现在有一个模块需要经常查询带有学生名称 (name)、学生所在班级名称 (className)、学生班级班长 (monito) 的学生信息。根据这种情况可以创建一个 temp_student 表。temp_student 表中存储学生名称 (stu_name)、学生所在班级名称 (className) 和学生班级班长 (monitor) 信息。创建表的语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `temp_student` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `stu_name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `className` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `monitor` <span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>接下来，从学生信息表和班级表中查询相关信息存储到临时表中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> temp_student(stu_name, clasName, monitor)</span><br><span class="line"><span class="keyword">SELECT</span> s.name, c.className, c.monitor</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">as</span> s, class <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">WHERE</span> s.classId <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure><p>以后，可以直接从 temp_student 表中查询学生名称、班级名称和班级班长，而不用每次都进行联合查询。这样可以提高数据库的查询速度。</p><blockquote><p>如果用户信息修改了，是不是会导致 temp_vip 中的数据不一致的问题呢？如何同步数据呢？</p><p>方式1: 清空数据 -&gt; 重新添加数据</p><p>方式2: 使用视图</p></blockquote><h4 id="3-3-增加冗余字段"><a href="#3-3-增加冗余字段" class="headerlink" title="3.3 增加冗余字段"></a>3.3 增加冗余字段</h4><p>设计数据库表时应尽量遵循范式理论的规约，尽可能减少冗余字段，让数据库设计看起来精致、优雅。但是，合理地加入冗余字段可以提高查询速度。</p><p>表的规范化程度越高，表于表之间的关系就越多，需要连接查询的情况也就越多。尤其在数据量大，而且需要频繁进行连接的时候，为了提升效率，我们也可以考虑增加冗余字段来减少连接。</p><p>改进表的设计时，可以考虑优化字段的数据类型。这个问题在打架刚从事开发时进本不算是问题。但是，随着你的经验越来越丰富，参与的项目越来越大，数据量也越来越多的时候，你就不能只从系统稳定性的角度来思考问题了，还要考虑懂啊系统整体的稳定性和效率。此时，优先选择符合存储需要的最小的数据类型。</p><p>列的字段越大，建立索引时所需要的空间也就越大。这样一页中所能存储的索引节点的数据量也就越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。</p><p>具体来说：</p><ul><li><p>情况一：对整数类型数据进行优化。</p><p>  遇到整数类型的字段可以用 INT 型。这样做的理由是，INT 型数据有足够大的取值范围，不用担心数据超出取值范围的问题。刚开始做项目的时候，首先要保证系统的稳定性，这样设计字段类型是可以的。但在数据量很大的时候，数据类型的定义，在很大程度上会影响到系统整体的执行效率。</p><p>  对于非负型的数据 (如自增 ID、整型 IP) 来说，要优先使用无符号整型 UNSIGNED 来存储。因为无符号相对于有符号，同样的字节数，存储的数值范围更大。如 tinyint 有符号为 -128～127，无符号为 0～255，多出一倍的存储空间。</p></li><li><p>情况二：既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型。</p><p>  跟文本类型数据相比，大整数往往占用更少的存储空间，因此，在存取和比对的时候，可以占用更少的内存空间。所以，在二者皆可用的情况下，尽量使用整数类型，这样可以提高查询的效率。如：将 IP 地址转换成整型数据。</p></li><li><p>情况三：避免使用 TEXT、BLOB 数据类型</p><p>  MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用 磁盘临时表进行。并且对于这种数据，MySQL 还是要进行二次查询，会使 SQL 性能表的很差，但是不是说一定不能使用这样的数据类型。</p><p>  如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select *，而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p></li><li><p>情况四：避免使用 ENUM 类型</p><p>  修正 ENUM 值需要使用 ALTER 语句。</p><p>  ENUM 类型的 OPDER BY 操作效率低，需要额外操作。使用 TINYINT 来代替 ENUM 类型。</p></li><li><p>情况五：使用 TIMESTAMP 存储时间</p><p>  TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19 03:14:07。TIMESTAMP 使用 4 字节，DATETIME 使用 8 个字节，同时 TIMESTAMP 具有自动赋值以及自动更新的特性。</p></li><li><p>情况六：用 DECIMAL 代替 FLOAT 和 DOUBLE 存储精确浮点数</p><ul><li>非精准浮点：float、double</li><li>精准浮点：decimal</li></ul><p>  Decimal 类型为精准浮点数，在计算时不会丢失精度，尤其是财务相关的金融类数据。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。可以用于存储比 bigint 更大的整型数据。</p></li></ul><p>总之，遇到数据量大的项目时，一定要在充分连接业务需求的前提下，合理优化数据类型，这样才能充分发挥资源的效率，使系统达到最优。</p><h4 id="3-5-优化插入记录的速度"><a href="#3-5-优化插入记录的速度" class="headerlink" title="3.5 优化插入记录的速度"></a>3.5 优化插入记录的速度</h4><p>插入记录时，影响插入速度的主要时索引、唯一性校验、一次插入记录条数等。根据这些情况可以分别进行优化。这里我们分为 MyISAM 引擎和 InnoDB 存储引擎来讲。</p><ul><li><p>MyISAM 引擎的表：</p><ul><li><p>禁用索引</p><p>  对于非空表，插入记录时，MySQL 会根据表的索引对插入的记录建立索引。如果插入大量数据，建立索引就会降低插入记录的速度。为了解决这种问题，可以再插入记录之前禁用索引，数据插入完毕后再开启索引。禁用索引的语句如下：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name DISABLE KEYS;</span><br></pre></td></tr></table></figure><p>  重新开启索引的语句如下：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name ENABLE KEYS;</span><br></pre></td></tr></table></figure><p>  若对于空表批量导入数据，则不需要进行此操作，因为 MyISAM 引擎的表是在导入数据之后才建立索引的。</p></li><li><p>禁用唯一性检查</p><p>  插入数据时，MySQL 会对插入的记录进行唯一性校验。这种唯一性校验会降低插入记录的速度。为了降低这种情况对查询速度的影响，可以在插入记录之前禁用唯一性检查，等到记录插入完毕后再开启。禁用唯一性检查的语句如下：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> UNIQUE_CHECKS<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>  开启唯一性检查的语句如下：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> UNIQUE_CHECKS<span class="operator">=</span><span class="number">1</span>；</span><br></pre></td></tr></table></figure></li><li><p>使用批量插入</p><p>  插入多条记录时，可以使用一条 INSERT 语句插入一条记录，也可以使用一条 INSERT 语句插入多条记录。插入一条记录的 INSERT 语句情形如下：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;wangwu&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">&#x27;zhaoliu&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>  使用一条 INSERT 插入多条记录的情形如下：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;wangwu&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;zhaoliu&#x27;</span>, <span class="number">18</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>  第二种情形的插入速度要比第一种情形快。</p></li><li><p>使用 LOAD DATA INFILE 批量导入</p><p>  当需要批量导入数据时，如果能用 LOAD DATA INFILE 语句，就尽量使用。因为 LOAD DATA INFILE 语句导入数据的速度比 INSERT 语句快。</p></li></ul></li><li><p>InnoDB 引擎的表：</p><ul><li><p>禁用唯一性检查</p><p>  插入数据之前执行 <code>set unique_checks=0</code> 来禁止对唯一索引的检查，数据导入完成之后再运行 <code>set unique_checks=1</code>。这个和 MyISAM 引擎的使用方法一样。</p></li><li><p>禁用外键检查</p><p>  插入数据执勤啊执行禁止对外键的检查，数据插入完成之后再恢复对外键的检查。禁用外键检查的语句如下：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> foreign_key_checks<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>  恢复对外键的检查语句如下：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> foreign_key_checks<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>禁止自动提交</p><p>  插入数据之前禁止事物的自动提交，数据导入完成之后，执行恢复自动提交操作。禁止自动提交的语句如下：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>  恢复自动提交的语句如下：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3-6-使用非空约束"><a href="#3-6-使用非空约束" class="headerlink" title="3.6 使用非空约束"></a>3.6 使用非空约束</h4><p>在设计字段的时候，如果业务允许，建议尽量使用非空约束。这样做的好处是：</p><ul><li>进行比较和计算时，省去要对 NULL 值的字段判断是否为空的开销，提高存储效率。</li><li>非空字段也容易创建索引。因为索引 NULL 列需要额外的空间来保存，所以要占用更多的空间。使用非空约束，就可以节省存储空间 (每个字段 1 个 bit)。</li></ul><h4 id="3-7-分析表、检查表与优化表"><a href="#3-7-分析表、检查表与优化表" class="headerlink" title="3.7 分析表、检查表与优化表"></a>3.7 分析表、检查表与优化表</h4><p>MySQL 提供了分析表、检查表和优化表的语句。分析表主要是分析关键字的分布，检查表主要是检查表是否存在错误，优化表主要是消除删除或者更新造成的空间浪费。</p><ul><li><p>分析表</p><p>  MySQL 中提供了 ANALYZE TABLE 语句分析包，ANALYZE TABLE 语句的基本语法如下：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> tbl_name[, tbl_name]...</span><br></pre></td></tr></table></figure><p>  默认的，MySQL 服务会讲 ANALYZE TABLE 语句写到 BINLOG 中，以便在主从架构中，从服务能够同步数据。可以添加参数 LOCAL 或者 NO_WRITE_TO_BINLOG 取消将语句写到 BINLOG 中。</p><p>  使用 ANALYZE TABLE 分析表的过程中，数据库系统会自动对表加一个只读锁。在分析期间，只能读取表中的记录，不能更新和插入记录。ANALYZE TABLE 语句能够分析 InnoDB 和 MyISAM 类型的表，但是不能作用于视图。</p><p>  ANALYZE TABLE 分析后的统计结果会反应到 cardinality 的值，该值统计了表中某一键所在的列不重复的值的个数。<strong>该值越接近表中的总行数，则在表连接查询或者索引查询时，就越优先被优化器选择使用</strong>。也就是索引列的 cardinality 的值愈表中数据的总条数差距越大，即使查询的时候使用了该索引作为查询条件，存储引擎实际查询的时候使用的概率就越小。下面通过例子来验证下。cardinality 可以通过 SHOW INDEX FROM 表名查看。</p></li><li><p>检查表</p><p>  MySQL 中可以使用 CHECK TABLE 语句来检查表。CHECK TABLE 语句能够检查 InnoDB 和 MyISAM 类型的表是否存在错误。CHECK TABLE 语句在执行过程中也会给表加上只读锁。</p><p>  对于 MyISAM 类型的表，CHECK TABLE 语句还会更新关键字统计数据。而且，CHECK TABLE 也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在。该语句的基本语法如下：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHECK</span> <span class="keyword">TABLE</span> tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option <span class="operator">=</span> &#123;QUICK <span class="operator">|</span> FAST <span class="operator">|</span> MEDIUM <span class="operator">|</span> EXTENDED <span class="operator">|</span> CHANGED&#125;</span><br></pre></td></tr></table></figure><p>  其中，tbl_name 是表名；option 参数有 5 个取值，分别是 QUICK、FAST、MEDIUM、EXTENDED 和 CHANGED。各个选项的意义分别是：</p><ul><li>QUICK：不扫描行，不检查错误的连接。</li><li>FAST：只检查没有被正确关闭的表。</li><li>CHANGED：值检查上次检查后被更改的表和没有被正确关闭的表。</li><li>MEDIUM：扫描行，以验证被删除的连接是有效的。也可以计算各行的关键字校验和，并使用计算出的校验和验证这一点。</li><li>EXTENDED：对每行的所有关键字进行一个全面的关机那字查找。这可以确保表时 100% 一致的，但是画的时间较长。</li></ul><p>  option 只对 MyISAM 类型的表有效，对 InnoDB 类型的表无效。</p></li><li><p>优化表</p><ul><li><p>OPTIMIZE TABLE</p><p>  MySQL 中使用 OPTIMIZE TABLE 语句来优化表。但是 OPTIMIZE TABLE 语句只能优化表中的 VARCHAR、BLOB 或 TEXT 类型的字段。一个表使用了这些字段的数据类型，若已经删除了表的一大部分数据，或者已经对含有可变长度行的表 (含有 VARCHAR、BLOB 或 TEXT 列的表) 进行了很多更新，则应使用 OPTIMIZE TABLE 来重新利用未使用的空间，并整理数据文件的碎片。</p><p>  OPTIMIZE TABLE 语句对 InnoDB 和 MyISAM 类型的表都有效。该语句在执行过程中也会给表加上只读锁。</p><p>  OPTIMIZE TABLE 语句的基本语法如下：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> tbl_name[, tbl_name] ...</span><br></pre></td></tr></table></figure><p>  LOCAL ｜ NO_WRITE_TO_BINLOG 关键字的意义和分析表相同，都是指定不写入二进制日志。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> optimize <span class="keyword">table</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+----------+----------+-------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>              <span class="operator">|</span> Op       <span class="operator">|</span> Msg_type <span class="operator">|</span> Msg_text                                                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+----------+----------+-------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> mysql_test.student <span class="operator">|</span> optimize <span class="operator">|</span> note     <span class="operator">|</span> <span class="keyword">Table</span> does <span class="keyword">not</span> support optimize, doing recreate <span class="operator">+</span> analyze instead <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql_test.student <span class="operator">|</span> optimize <span class="operator">|</span> status   <span class="operator">|</span> OK                                                                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+----------+----------+-------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">1.17</span> sec)</span><br></pre></td></tr></table></figure><p>  Msg_text 显示</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Table</span> does <span class="keyword">not</span> support optimize, doing recreate <span class="operator">+</span> analyze instead</span><br></pre></td></tr></table></figure><p>  是因为该表的存储引擎是 InnoDB。根据官网介绍，在 MyISAM中，实现分析这张表，然后会整理相关的 MySQL datafile，之后回收未使用的空间；在 InnoDB 中，回收空间是简单通过 Alter table 进行整理空间。在优化期间，MySQL 会创建一个临时表，优化完成之后会删除原始表，然后会将临时表 rename 成为原始表。</p><blockquote><p>说明：</p><p>在多数的设置中，根本不需要运行 OPTIMIZE TABLE。即使对可变长度的行进行了大量的更新，也不需要经常运行，每周一次或每月一次即可，并且只需要对特定的表运行。</p></blockquote></li><li><p>方式二：使用 mysqlcheck 命令</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlcheck <span class="operator">-</span>o DatabaseName TableName <span class="operator">-</span>uroot <span class="operator">-</span>p<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br></pre></td></tr></table></figure><p>  mysqlcheck 是 Linux 中的 rompt，-o 是代表 Optimize。</p></li></ul></li></ul><h4 id="3-8-小结"><a href="#3-8-小结" class="headerlink" title="3.8 小结"></a>3.8 小结</h4><p>上述这些方法都是有利有弊的。比如：</p><ul><li>修改数据类型，节省存储空间的同时，要考虑到数据不能超过取值范围；</li><li>增加冗余字段的时候，不要忘了确保数据一致性；</li><li>把大表拆分，也意味着你的查询会增加新的连接，从而增加额外的开销和运维的成本。</li></ul><p>因此，你一定要结合实际的业务需求进行权衡。</p><h3 id="4-大表优化"><a href="#4-大表优化" class="headerlink" title="4. 大表优化"></a>4. 大表优化</h3><p>当 MySQL 单表记录数过大时，数据库的 CRUD 性能会明显下降，一些常见的优化措施如下：</p><h4 id="4-1-限定查询的范围"><a href="#4-1-限定查询的范围" class="headerlink" title="4.1 限定查询的范围"></a>4.1 限定查询的范围</h4><p><strong>禁止不带任何限制数据范围条件的查询语句</strong>。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。</p><h4 id="4-2-读-x2F-写分离"><a href="#4-2-读-x2F-写分离" class="headerlink" title="4.2 读&#x2F;写分离"></a>4.2 读&#x2F;写分离</h4><p>经典的数据库拆分方案，主库负责写，从库负责读。</p><ul><li><p>一主一从模式</p><p>  <img src="http://1.117.162.142:9000/blog/%E4%B8%80%E4%B8%BB%E4%B8%80%E4%BB%8E%E6%A8%A1%E5%BC%8F.png" alt="一主一从模式"></p></li><li><p>双主双从模式</p><p>  <img src="http://1.117.162.142:9000/blog/%E5%8F%8C%E4%B8%BB%E5%8F%8C%E4%BB%8E%E6%A8%A1%E5%BC%8F.png" alt="双主双从模式"></p></li></ul><h4 id="4-3-垂直拆分"><a href="#4-3-垂直拆分" class="headerlink" title="4.3 垂直拆分"></a>4.3 垂直拆分</h4><p>当数据量达到千万级以上时，有时候我们需要把一个数据库切分成多份，放到不同的数据库服务器上，减少对单一数据库服务器的访问压力。</p><p><img src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87-1.png" alt="垂直拆分"></p><ul><li>如果数据库中的数据表过多，可以采用垂直分库的方式，将关联的数据表部署在同一个数据库上。</li><li>如果数据表中的列过多，可以采用垂直分表的方式，将一张数据表分拆成多张数据表，把经常一起使用的列放到同一张表里。</li></ul><p><strong>垂直拆分的有点</strong>：可以是的列数据变小，在查询时减少读取的 BLOCK 数，减少 IO 次数。此外，垂直分区可以简化表的结构，易于维护。</p><p><strong>垂直拆分的缺点</strong>：主键会出现冗余，需要管理冗余列，并会引起 JOIN 操作。此外，垂直拆分会让事物变得更加复杂。</p><h4 id="4-4-水平拆分"><a href="#4-4-水平拆分" class="headerlink" title="4.4 水平拆分"></a>4.4 水平拆分</h4><ul><li>尽量控制单表数据量的大小，建议控制在 1000 万以内。1000 万并不是 MySQL 数据库的限制，过大会造成修改表结构、备份、恢复都会有很大的问题。此时可以用历史数据归档 (应用于日志数据)，水平分表 (应用于业务数据) 等手段来控制数据量大小。</li><li>这里我们主要考虑业务数据的水平分表策略。将大的数据表按照某个属性维度分拆成不同的小表，每张小表保持相同的表结构。比如你可以按照年份来划分，把不同年份的数据放到不同的数据表中。2017 年、2018 年和 2019 年的数据就可以分别放到三张数据表中。</li><li>水平分表近视解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升 MySQL 并发能力没有什么意义，所以水平拆分最好分库，从而达到分布式的目的。</li></ul><p><img src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87-2.png" alt="水平拆分"></p><p>水平拆分能够支持非常大的数据量存储，应用端改造也少，但分片事物难以解决，跨界点 Join 性能较差，逻辑复杂。《Java 工程师修炼之道》 的作者推荐<strong>尽量不要对数据进行分片，因为拆分会到来逻辑、部署、运维的各种复杂度</strong>，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络 IO。</p><p>下面补充一下数据库分片的两种常见方案：</p><ul><li><strong>客户端代理：分片逻辑在应用端，封装在 jar 包里，通过修改或着封装 JDBC 层来实现</strong>。当当网的 Sharding-JDBC、阿里的 TDDL 是两种比较常用的实现。</li><li><strong>中间件代理：在应用层和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中</strong>。我们现在谈的 Mycat、360 的 Atlas、网易的 DDB 等等都是这种架构的实现。</li></ul><h3 id="5-其它调优策略"><a href="#5-其它调优策略" class="headerlink" title="5. 其它调优策略"></a>5. 其它调优策略</h3><h4 id="5-1-服务器语句超时处理"><a href="#5-1-服务器语句超时处理" class="headerlink" title="5.1 服务器语句超时处理"></a>5.1 服务器语句超时处理</h4><p>在 MySQL 8.0 中可以设置服务器语句超时的限制，单位可以达到毫秒级别。当中断的执行语句超过设置的毫秒数后，服务器将终止查询影响不大的事物或连接，然后将错误报给客户端。</p><p>设置服务器语句超时的限制，可以通过设置系统变量 MAX_EXECUTION_TIME 来实现。默认情况下，MAX_EXECUTION_TIME 的值为 0，代表没有时间限制。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> MAX_EXECUTION_TIME<span class="operator">=</span><span class="number">2000</span>;</span><br><span class="line"><span class="keyword">SET</span> SESSION MAX_EXECUTION_TIME<span class="operator">=</span><span class="number">2000</span>; # 指定该会话中 <span class="keyword">SELECT</span> 语句的超时时间</span><br></pre></td></tr></table></figure><h4 id="5-2-创建全局通用表空间"><a href="#5-2-创建全局通用表空间" class="headerlink" title="5.2 创建全局通用表空间"></a>5.2 创建全局通用表空间</h4><p>MySQL 8.0 使用 CREATE TABLESPACE 语句来创建一个全局通用表空间。全局表空间可以被所有的数据库的表共享，而且相比于独享表空间，<strong>使用手动创建共享空间可以节约元数据方面的内存</strong>。可以在创建表的时候，指定属于哪个表空间，也可以对已有表进行表空间修改等。</p><p>下面创建名为 test1 的共享表空间，SQL 语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE test1 <span class="keyword">ADD</span> datafile `test1.ibd` file_block_size<span class="operator">=</span><span class="number">16</span>k;</span><br><span class="line"></span><br><span class="line"># 指定表空间，<span class="keyword">SQL</span> 语句如下：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">10</span>)) engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset utf8mb4 tablespace test1;</span><br><span class="line"></span><br><span class="line"># 也可以通过 <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 语句指定表空间</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test tablespace test1;</span><br></pre></td></tr></table></figure><p>因为是共享表空间，所以不能直接通过 drop table tbname 删除，这样操作并不能回收空间。当确定共享表空间的数据都没用，并且依赖该表空间的表均已经删除时，可以通过 drop tablespace 删除共享表空间来释放空间，如果依赖该共享表空间的表存在，就会删除失败。如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> TABLESPACE test1;</span><br><span class="line">Tablespace <span class="string">&#x27;test1&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> empty.</span><br></pre></td></tr></table></figure><p>所以应该首先删除依赖该表空间的数据表，SQL 语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> test;</span><br></pre></td></tr></table></figure><p>最后即可删除表空间，SQL 语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> TABLESPACE test1;</span><br></pre></td></tr></table></figure><h4 id="5-3-MySQL-8-0-新特性：隐藏索引对调优的帮助"><a href="#5-3-MySQL-8-0-新特性：隐藏索引对调优的帮助" class="headerlink" title="5.3 MySQL 8.0 新特性：隐藏索引对调优的帮助"></a>5.3 MySQL 8.0 新特性：隐藏索引对调优的帮助</h4><p>不可见索引的特性对于性能调试非常有用。在 MySQL 8.0 中，索引可以被隐藏和显示。当一个索引被隐藏时，它不会被查询优化器所使用。也就是说，管理员可以隐藏一个索引，然后观察对数据库的影响。如果数据库性能有所下降，就说明这个索引是有用的，于是将其恢复显示即可；如果数据库性能看不出变化，就说明这个索引是多余的，可以删掉了。</p><p>需要注意的是当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p><p>数据表中的主键不能被设置为 invisible。</p><h2 id="十一、事务基础知识"><a href="#十一、事务基础知识" class="headerlink" title="十一、事务基础知识"></a>十一、事务基础知识</h2><h3 id="1-数据库事务概述"><a href="#1-数据库事务概述" class="headerlink" title="1. 数据库事务概述"></a>1. 数据库事务概述</h3><p>事务是数据库区别于文件系统的重要特性之一，当我们有了事务就会让数据库始终保持一致性，同时我们还能通过事务的机制恢复到某个时间点，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失。</p><h4 id="1-1-存储引擎支持情况"><a href="#1-1-存储引擎支持情况" class="headerlink" title="1.1 存储引擎支持情况"></a>1.1 存储引擎支持情况</h4><p>SHOW ENGINES 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> engines;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> Engine             <span class="operator">|</span> Support <span class="operator">|</span> Comment                                                        <span class="operator">|</span> Transactions <span class="operator">|</span> XA   <span class="operator">|</span> Savepoints <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> ARCHIVE            <span class="operator">|</span> YES     <span class="operator">|</span> Archive storage engine                                         <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BLACKHOLE          <span class="operator">|</span> YES     <span class="operator">|</span> <span class="operator">/</span>dev<span class="operator">/</span><span class="keyword">null</span> storage engine (anything you write <span class="keyword">to</span> it disappears) <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MRG_MYISAM         <span class="operator">|</span> YES     <span class="operator">|</span> Collection <span class="keyword">of</span> identical MyISAM tables                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FEDERATED          <span class="operator">|</span> <span class="keyword">NO</span>      <span class="operator">|</span> Federated MySQL storage engine                                 <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MyISAM             <span class="operator">|</span> YES     <span class="operator">|</span> MyISAM storage engine                                          <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> PERFORMANCE_SCHEMA <span class="operator">|</span> YES     <span class="operator">|</span> Performance Schema                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> InnoDB             <span class="operator">|</span> <span class="keyword">DEFAULT</span> <span class="operator">|</span> Supports transactions, <span class="type">row</span><span class="operator">-</span>level locking, <span class="keyword">and</span> <span class="keyword">foreign</span> keys     <span class="operator">|</span> YES          <span class="operator">|</span> YES  <span class="operator">|</span> YES        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> MEMORY             <span class="operator">|</span> YES     <span class="operator">|</span> Hash based, stored <span class="keyword">in</span> memory, useful <span class="keyword">for</span> temporary tables      <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> CSV                <span class="operator">|</span> YES     <span class="operator">|</span> CSV storage engine                                             <span class="operator">|</span> <span class="keyword">NO</span>           <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> <span class="keyword">NO</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span></span><br></pre></td></tr></table></figure><p>能看出在 MySQL中国呢，只有 InnoDB 是支持事务的。</p><h4 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2 基本概念"></a>1.2 基本概念</h4><p><strong>事务</strong>：一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p><p><strong>事物处理的原则</strong>：保证所有事物都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事物都被提交 (commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事物回滚 (rollback) 到最初状态。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 案例：AA用户给BB用户转账<span class="number">100</span></span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;AA&#x27;</span>;</span><br><span class="line"># 服务器宕机</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;BB&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="1-3-事物的-ACID-特性"><a href="#1-3-事物的-ACID-特性" class="headerlink" title="1.3 事物的 ACID 特性"></a>1.3 事物的 ACID 特性</h4><ul><li><p><strong>原子性 (Atomicity)</strong></p><p>  原子性是指事物是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。即要么转账成功，要么转账失败，是不存在中间的状态。如果无法保证原子性会怎么样？就会出现数据不一致的情形，A 账户减去 100 元，而 B 账户增加 100 元操作失败，系统将无故丢失 100 元。</p></li><li><p><strong>一致性 (Consistency)</strong></p><p>  根据定义，一致性是指事务执行前后，数据从一个合法性状态变换到另一个合法性状态。这种状态是语义上的而不是语法上的，跟具体的业务有关。</p><p>  满足约定的约束的状态就叫做合法的状态。通俗一点，这状态是由自己来定义的 (比如满足现实世界中的约束)。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的！如果事物中的某个操作失败了，系统就会自动撤销当前正在执行的事物，返回到事物操作之前的状态。</p><p>  举例：A 账户有 200 元，转账 300 元出去，此时 A 账户余额为 -100 元。你自然就发现了此时数据是不一致的，为什么呢？因为你定义了一个状态，余额这列必须 &gt;&#x3D; 0。如果 A 转账 50 给 B 账户，但是 B 账户由于种种原因没有收到，此时数据也是不一致的，因为 A 和 B 账户的总金额必须不变。</p></li><li><p><strong>隔离性 (Isolation)</strong></p><p>  事物的隔离性是指一个事务的执行不能被其他事物干扰，即一个事务内部的操作及使用的数据对并发的其它事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><p>  如果无法保证隔离性会怎么样？假设 A 账户有 200 元，B 账户 0 元。A 账户往 B 账户转账两次，每次金额为 50 元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">50</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;AA&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">50</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;BB&#x27;</span>;</span><br></pre></td></tr></table></figure><p>  <img src="http://1.117.162.142:9000/blog/%E9%9A%94%E7%A6%BB%E6%80%A7%E6%A1%88%E4%BE%8B.png" alt="隔离性案例"></p></li><li><p><strong>持久性 (Durability)</strong></p><p>  持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其它操作和数据库故障不应该对其有任何影响。</p><p>  持久性是通过事务日志来保证的。日志包括了重做日志和回滚日志。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p><blockquote><p>总结</p><p>ACID 是事务的四大特性，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件，而持久性时我们的目的。</p><p>数据库事务，其实就是数据库设计者为了方便起见，把需要保证原子性、隔离性、一致性和持久性的一个或多个数据库操作称为一个事务。</p></blockquote></li></ul><h4 id="1-4-事务的状态"><a href="#1-4-事务的状态" class="headerlink" title="1.4 事务的状态"></a>1.4 事务的状态</h4><p>事务是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL 根据这些操作所执行的不同阶段把事务大致划分成几个状态：</p><ul><li><p><strong>活动的 (Active)</strong></p><p>  事务对应的数据库操作正在执行过程中时，该事务处于活动的状态。</p></li><li><p><strong>部分提交的 (Partially committed)</strong></p><p>  当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态。</p></li><li><p><strong>失败的 (Failed)</strong></p><p>  当事务处在活动的活着部分提交的状态时，可能遇到了某些错误 (数据库自身的错误、操作系统错误或者直接断电等) 而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在失败的状态。</p></li><li><p><strong>中止的 (Aborted)</strong></p><p>  如果事务执行了一部分而变为失败的状态，那么就需要把意境修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为回滚。当回滚操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了中止的状态。</p></li><li><p><strong>提交的 (Committed)</strong></p><p>  当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了提交的状态。一个基本的状态转换图如下所示：</p><p>  <img src="http://1.117.162.142:9000/blog/%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt="状态转换图"></p></li></ul><h3 id="2-如何使用事物"><a href="#2-如何使用事物" class="headerlink" title="2. 如何使用事物"></a>2. 如何使用事物</h3><p>使用事务有两种方式，分别为显式事务和隐式事务。</p><h4 id="2-1-显式事务"><a href="#2-1-显式事务" class="headerlink" title="2.1 显式事务"></a>2.1 显式事务</h4><p><strong>步骤一</strong>：<code>START TRANSACTION</code> 或者 <code>BEGIN</code>，作用是显式开启一个事务。</p><p><code>START TRANSACTION</code> 语句相较于 <code>BEGIN</code> 特别之处在于，后边能跟随几个修饰符：</p><ul><li><p><code>READ ONLY</code>：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p><blockquote><p>补充：只读事务中知识不允许修改那些其它事务也能访问到的表中的数据，对于临时表来说 (我们使用 <code>CREATE TMEPORARY TABLE</code> 创建的表)，由于它们只能在当前会话中可见，所有只读事务其实也是可以对临时表进行增、删、改操作的。</p></blockquote></li><li><p><code>READ WRITE</code>：标识当前事务是一个读写事务，也就是属于该事务的数据库操作即可以读取数据，也可以修改数据。</p></li><li><p><code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读。</p></li></ul><p>比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION READ <span class="keyword">ONLY</span>;# 开启一个只读事务</span><br><span class="line"><span class="keyword">START</span> TRANSACTION READ <span class="keyword">ONLY</span>, <span class="keyword">WITH</span> CONSISTENT SNAPSHOT;# 开启只读事务和一致性读</span><br><span class="line"><span class="keyword">START</span> TRANSACTION READ WRITE, <span class="keyword">WITH</span> CONSISTENT SNAPSHOT;# 开启读写事务和一致性读</span><br></pre></td></tr></table></figure><p>注意：</p><p><code>READ ONLY</code> 和 <code>READ WRITE</code> 是用来设置所谓的事务访问模式的，就是以只读还是读写的方式来访问数据库中的数据，一个事务的访问模式不能同时既设置为只读的也设置为读写的，所以不能同时把 <code>READ ONLY</code> 和 <code>READ WRITE</code> 放到 <code>START TRANSACTION</code> 语句后边。如果我们不显式指定事务的访问模式，那么该事务的访问模式就是读写模式。</p><p><strong>步骤二</strong>：一系列事务中的操作 (主要是 DML，不含 DDL)</p><p><strong>步骤三</strong>：提交事务或中止事务 (即回滚事务)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 提交事务。当提交事务后，对数据库的修改是永久性的。</span><br><span class="line"><span class="keyword">COMMIT</span>；</span><br><span class="line"># 回滚事务，即撤销正在进行的所有没有提交的修改</span><br><span class="line"><span class="keyword">ROLLBACK</span>；</span><br><span class="line"># 将事务回滚到某个保存点</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> [<span class="keyword">SAVEPOINT</span>]</span><br></pre></td></tr></table></figure><p>其中关于 SAVEPOINT 相关操作有：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。</span><br><span class="line"><span class="keyword">SAVEPOINT</span> 保存点名称;</span><br><span class="line"># 删除某个保存点</span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> 保存点名称;</span><br></pre></td></tr></table></figure><h4 id="2-2-隐式事务"><a href="#2-2-隐式事务" class="headerlink" title="2.2 隐式事务"></a>2.2 隐式事务</h4><p>MySQL 中有一个系统变量 <code>autocommit</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;autocommit&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> autocommit    <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br></pre></td></tr></table></figure><p>默认情况下，如我我们不显式的使用 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的自动提交。也就是说，不以 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 语句显式的开启一个事务，那么下边这两条语句就相当于放到两个独立的事务中去执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">10</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">10</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>当然，如果我们想关闭这种自动提交的功能，可以使用下边两种方法之一：</p><ul><li><p>显式的使用 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</p></li><li><p>把系统变量 autocommit 的值设置为 off，就像这样：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> OFF;</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul><p>这样的话，我们写入的多条语句就算是属于同一个事务了，直到我们显式的写出 COMMIT 语句来把这个事务提交掉，或者显式的写出 ROLLBACK 语句来把这个事务回滚掉。</p><blockquote><p>补充：Oracle 默认不自动提交，需要手写 COMMIT 命令，而 MySQL 默认自动提交。</p></blockquote><h4 id="2-3-隐式提交数据的情况"><a href="#2-3-隐式提交数据的情况" class="headerlink" title="2.3 隐式提交数据的情况"></a>2.3 隐式提交数据的情况</h4><ul><li><p><strong>数据定义语言 (DDL)</strong></p><p>  数据库对象，指的就是数据库、表、视图、存储过程等结构。当我们使用 CREATE、ALTER、DROP 等语句去修改数据库对象时，就会隐式的提交前边语句所属于的事务。即：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">SELECT...</span><br><span class="line">UPDATE...</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ...# 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure></li><li><p><strong>隐式使用或修改 mysql 数据库中的表</strong></p><p>  当我们使用 <code>ALTER USER</code>、<code>UPDATE USER</code>、<code>DROP USER</code>、<code>GRANT</code>、<code>RENAME USER</code>、<code>ALTER USER</code>、<code>REVOKE</code>、<code>SET PASSWORD</code> 等语句时也会隐式的提交前边语句所属于的事务。</p></li><li><p>事务控制或关于锁定的语句</p><p>  当我们在一个事务还没提交或者回滚时就又使用 <code>START TRANSACTION</code> 或者 <code>BEGIN</code> 语句开启了另一个事务时，会隐式的提交上一个事务。即：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">UPDATE</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;# 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure><p>  当前的 autocommit 系统变量的值为 OFF，我们手动把它调整为 ON 时，也会隐式的提交前边语句所属的事务。</p><p>  使用 <code>LOCK TABLES</code>、<code>UNLOCK TABLES</code> 等关于锁定的语句也会隐式的提交前边语句所属的事务。</p></li><li><p>加载数据的语句</p><p>  使用 <code>LOAD DATA</code> 语句来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务。</p></li><li><p>关于 MySQL 复制的一些语句</p><p>  使用 <code>START SLAVE</code>、<code>STOP SLAVE</code>、<code>RESET SLAVE</code>、<code>CHANGE MASTER TO</code> 等语句时会隐式的提交前边语句所属的事务。</p></li><li><p>其它的一些语句</p><p>  使用 <code>ANALYZE TABLE</code>、<code>CACHE INDEX</code>、<code>CHECK TABLE</code>、<code>FLUSH</code>、<code>LOAD INDEX INTO CACHE</code>、<code>OPTIMIZE TABLE</code>、<code>REPAIR TABLE</code>、<code>RESET</code> 等语句也会隐式的提交前边语句所属的事务。</p></li></ul><h3 id="3-事务隔离级别"><a href="#3-事务隔离级别" class="headerlink" title="3. 事务隔离级别"></a>3. 事务隔离级别</h3><p>MySQL 是一个客户端 &#x2F; 服务器架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接之后，就可以称为一个会话 (Session)。每个客户端都可以在自己的会话中想服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。事务由隔离性的特性，理论上在某个事务对某个数据进行访问时，其它事务应该进行 排队，当该事务提交之后，其它事务才可以继续访问这个数据。但是这样对性能影响太大，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，那就看二者如何权衡取舍了。</p><h4 id="3-1-数据准备-2"><a href="#3-1-数据准备-2" class="headerlink" title="3.1 数据准备"></a>3.1 数据准备</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">studentno <span class="type">INT</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  class <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (studentno)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;小姑娘&#x27;</span>, <span class="string">&#x27;1班&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="3-2-数据并发问题"><a href="#3-2-数据并发问题" class="headerlink" title="3.2 数据并发问题"></a>3.2 数据并发问题</h4><p>针对事务的隔离性和并发性，我们怎么做取舍呢？先看一下访问相同数据的事务在不保证串行执行 (也就是执行完一个在执行另一个) 的情况下可能会出现哪些问题：</p><ul><li><p><strong>脏写 (Dirty Write)</strong></p><p>  对于两个事务 Session A、Session B，如果事务 Session A 修改了另一个未提交事务 Session B 修改过的数据，那就意味着发生了脏写，示意图如下：</p><p>  <img src="http://1.117.162.142:9000/blog/%E8%84%8F%E5%86%99%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="脏写示意图"></p><p>  Session A 和 Session B 各开启了一个事务，Session B 中的事务先将 studentno 列为 1 的记录的 name 列更新为 ‘李四’，然后 Session A 中的事务接着又把这条 studentno 列为 1 的记录的 name 列更新为 ‘张三’。如果之后 Session B 中的事务进行了回滚，那么 Session A 中的更新也将不复存在，这种现象就称之为脏写。这时 Session A 中的事务就没有效果了，明明把数据更新了，最后也提交事物了，最后看到的数据什么变化也没有。这里大家对事务的隔离级别比较了解的话，会发现默认隔离级别下，上面 Session A 中的更新语句会处于等待状态，这里知识跟大家说明一下会出现这样现象。</p></li><li><p><strong>脏读 (Dirty Read)</strong></p><p>  对于两个事务 Session A、Session B，Session A 读取了已经被 Session B 更新但还没有被提交的字段。之后若 Session B 回滚，Session A 读取的内容就是临时且无效的。</p><p>  <img src="http://1.117.162.142:9000/blog/%E8%84%8F%E8%AF%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="脏读示意图"></p><p>  Session A 和 Session B 各开启了一个事务，Session B 中的事务先将 studentno 列为 1 的记录的 name 列更新为 ‘张三’，然后 Session A 中的事务再去查询这条 studentno 为 1 的记录，如果读到列 name 的值为 ‘张三’，而 Session B 中的事务稍后进行了回滚，那么 Session A 中的事务相当于读到了一个不存在的数据，这种现象就称之为脏读。</p></li><li><p><strong>不可重复读 (Non-Repeatable Read)</strong></p><p>  对于两个事务 Session A、Session B，Session A 读取了一个字段，然后 Session B 更新了该字段。之后 Session A 再次读取同一个字段，值就不同了。那就意味着发生了不可重复读。</p><p>  <img src="http://1.117.162.142:9000/blog/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="不可重复读示意图"></p><p>  我们在 Session B 中提交了几个 隐式事务 (注意是隐式事务，意味着语句结束事务就提交了)，这些事务都修改了 studentno 列为 1 的记录的列 name 的值，每次事物提交之后，如果 Session A 中的事务都可以查看到最新的值，这种现象也被称之为 不可重复读。</p></li><li><p><strong>幻读 (Phantom)</strong></p><p>  对于两个事务 Session A、Session B，Session A 从一个表中读取了一个字段，然后 Session B 在该表中插入了一些新的行。之后，如果 Session A 再次读取同一个表，就会多出几行。那就意味着发生了幻读。</p><p>  <img src="/myslq/%E5%B9%BB%E8%AF%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="幻读示意图"></p><p>  Session A 中的事务先根据条件 studentno &gt; 0 这个条件查询表 student，得到了列值为 ‘张三’ 的记录；之后 Session B 中提及哦啊了一个隐式事务，该事务向表 student 中插入了一条新纪录；之后 Session A 中的事务再根据相同的条件 studentno &gt; 0 查询表 student，得到的结果集中包含 Session B 中的事务新插入的那条记录，这种现象也被称之为幻读。我们把新插入的那些记录称之为 幻影记录。</p><p>  <strong>注意 1</strong>：</p><p>  如果 Session B 中删除了一些符合 studentno &gt; 0 的记录而不是插入新纪录，那 Session A 之后再根据 studentno &gt; 0 的条件读取的记录变少了，这种现象算不算幻读呢？这种现象不属于幻读，幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</p><p>  <strong>注意 2</strong>：</p><p>  那对于先前已经读到的记录，之后又读不到的情况呢？这相当于对每一条记录都发生了不可重复读的现象。幻读只是重点强调了读取到了之前读取没有获取到的记录。</p></li></ul><h4 id="3-3-SQL-中的四种隔离级别"><a href="#3-3-SQL-中的四种隔离级别" class="headerlink" title="3.3 SQL 中的四种隔离级别"></a>3.3 SQL 中的四种隔离级别</h4><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题按照严重性来排一下序 ：</p><blockquote><p>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p></blockquote><p>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。SQL 标准中设立了 4 个隔离级别：</p><ul><li><code>READ UNCOMMITTED</code>：读未提交，在该隔离级别，所有事物都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li><li><code>READ COMMITTED</code>：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别 (但不是 MySQL 默认的)。可以避免脏读，但不可重复读、幻读问题仍然存在。</li><li><code>REPEATABLE READ</code>：可重复读，事务 A 在读到一条数据之后，此时事务 B 对该数据进行了修改并提交，那么事务 A 再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这时 MySQL 的默认隔离级别。</li><li><code>SERIALIZABLE</code>：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其它事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li></ul><p>SQL 标准中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：</p><table><thead><tr><th>隔离级别</th><th>脏读可能性</th><th>不可重复读可能性</th><th>幻读可能性</th><th>加锁读</th></tr></thead><tbody><tr><td>READ UNCONMITED</td><td>YES</td><td>YES</td><td>YES</td><td>NO</td></tr><tr><td>READ COMMITED</td><td>NO</td><td>YES</td><td>YES</td><td>NO</td></tr><tr><td>REPEATABLE READ</td><td>NO</td><td>NO</td><td>YES</td><td>NO</td></tr><tr><td>SERIALIZABLE</td><td>NO</td><td>NO</td><td>NO</td><td>YES</td></tr></tbody></table><p>脏写怎么没涉及到？因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</p><p>不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4 种事务隔离级别与并发性能的关系如下：</p><p><img src="http://1.117.162.142:9000/blog/%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="四种事务隔离级别与并发性能的关系.png"></p><h4 id="3-4-MySQL-支持的四种隔离级别"><a href="#3-4-MySQL-支持的四种隔离级别" class="headerlink" title="3.4 MySQL 支持的四种隔离级别"></a>3.4 MySQL 支持的四种隔离级别</h4><p>不同的数据库厂商对 SQL 标准中规定的四种隔离级别支持不一样。比如，Oracle 就只支持 <code>READ COMMITTED (默认隔离级别)</code> 和 <code>SERIALIZABLE 隔离级别</code>。MySQL 虽然支持 4 种隔离级别，但与 SQL 标准中所规定的各级隔离级别允许发生的问题却有些出入，MySQL 在 REPEATABLE READ 隔离级别下，是可以禁止幻读问题的发生的。</p><p>MySQL 的默认隔离级别为 REPEATABLE READ，可以手动修改一下事务的隔离级别。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 查看隔离级别，MySQL <span class="number">5.7</span><span class="number">.20</span> 的版本之前：</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;tx_isolation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name         <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> tx_isolation <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"></span><br><span class="line"># MySQL <span class="number">5.7</span><span class="number">.20</span> 版本之后，引入 transaction_isolation 来替换 tx_isolation</span><br><span class="line"></span><br><span class="line"># 查看隔离级别，MySQL <span class="number">5.7</span><span class="number">.20</span> 的版本及之后：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name         <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> transaction_isolation <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"></span><br><span class="line"># 或者不同 MySQL 版本中都可以使用的：</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br></pre></td></tr></table></figure><h4 id="3-5-如何设置事务的隔离级别"><a href="#3-5-如何设置事务的隔离级别" class="headerlink" title="3.5 如何设置事务的隔离级别"></a>3.5 如何设置事务的隔离级别</h4><p>通过下面的语句修改事务的隔离级别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span> <span class="operator">|</span> SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;</span><br><span class="line"># 其中，隔离级别格式：</span><br><span class="line"><span class="operator">&gt;</span> READ UNCOMMITTED</span><br><span class="line"><span class="operator">&gt;</span> READ COMMITTED</span><br><span class="line"><span class="operator">&gt;</span> REPEATABLE READ</span><br><span class="line"><span class="operator">&gt;</span> SERIALIZABLE</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span> <span class="operator">|</span> SESSION] TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;隔离级别&#x27;</span></span><br><span class="line"># 其中，隔离级别格式：</span><br><span class="line"><span class="operator">&gt;</span> READ<span class="operator">-</span>UNCOMMITTED</span><br><span class="line"><span class="operator">&gt;</span> READ<span class="operator">-</span>COMMITTED</span><br><span class="line"><span class="operator">&gt;</span> REPEATABLE<span class="operator">-</span>READ</span><br><span class="line"><span class="operator">&gt;</span> SERIALIZABLE</span><br></pre></td></tr></table></figure><p>关于设置时使用 GLOBAL 或 SESSION 的影响：</p><ul><li><p>使用 GLOBAL 关键字 (在全局范围影响)：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line"># 或</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;SERIALIZABLE&#x27;</span></span><br></pre></td></tr></table></figure><p>  则：</p><ul><li>当前已经存在的会话无效</li><li>只对执行完该语句之后产生的会话起作用</li></ul></li><li><p>使用 SESSION 关键字 (在会话范围影响)：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line"># 或</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;SERIALIZABLE&#x27;</span></span><br></pre></td></tr></table></figure><p>  则：</p><ul><li>对当前会话的所有后续的事务有效</li><li>如果在事物之间执行，则对后续的事务有效</li><li>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</li></ul></li></ul><p>如果在服务器启动时想改变事务的默认隔离级别，可以修改启动参数 <code>TRANSACTION_ISOLATION</code> 的值。比如，在启动服务器时制定了 <code>TRANSACTION_ISOLATION = SERIALIZABLE</code>，那么事务的默认隔离级别就从原来的 <code>REPEATABLE-READ</code> 变成了 <code>SERIALIZABLE</code>。</p><h2 id="十二、MySQL-事务日志"><a href="#十二、MySQL-事务日志" class="headerlink" title="十二、MySQL 事务日志"></a>十二、MySQL 事务日志</h2><p>事务有 4 种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p><ul><li>事务的隔离性由锁机制实现。</li><li>而事务的原子性、一致性和持久性由事务的 redo 日志和 undo 日志来保证。<ul><li>REDO LOG 称为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li><li>UNDO LOG 称为回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li></ul></li></ul><p>有的 DBA 或许会认为 UNDO 是 REDO 的逆过程，其实不然。REDO 和 UNDO 都可以视为一种恢复操作，但是：</p><ul><li>REDO LOG：是存储引擎层 (innodb) 生成的日志，记录的是物理级别上的页修改操作，比如页号xxx、偏移量yyy写入了zzz数据。主要为了保证数据的可靠性；</li><li>UNDO LOG：是存储引擎层 (innodb) 生成的日志，记录的是逻辑操作日志，比如对某一行数据进行了 INSERT 语句操作，那么 UNDO LOG 就记录一条与之相反的 DELETE 操作。主要用于事务的回滚 (UNDO LOG 记录的是每个修改操作的逆操作) 和一致性非锁定读 (UNDO LOG 回滚行记录到某种特定的版本——MVCC，即多版本并发控制)。</li></ul><h3 id="1-redo-日志"><a href="#1-redo-日志" class="headerlink" title="1. redo 日志"></a>1. redo 日志</h3><p>InnoDB 存储引擎是以页为单位来管理存储空间的。在真正访问页面之前，需要把磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访问。所有的变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页会以一定的频率被刷入磁盘 (checkPoint 机制)，通过缓冲池来优化 CPU 和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p><h4 id="1-1-为什么需要-REDO-日志"><a href="#1-1-为什么需要-REDO-日志" class="headerlink" title="1.1 为什么需要 REDO 日志"></a>1.1 为什么需要 REDO 日志</h4><p>一方面，缓冲池可以帮助我们消除 CPU 和磁盘之间的鸿沟，checkpoint 机制可以保证数据的最终落盘，然而由于 checkpoint 并不是每次变更的时候就触发的，而是 master 线程隔一段时间去处理的。所以最坏的情况是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就丢失的，无法恢复。</p><p>另一方面，事务包含持久性的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库所做的更改也不能丢失。</p><p>那么如何保证这个持久性呢？一个简单的做法：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题：</p><ul><li><p>修改量与刷新磁盘工作量严重不成比例</p><p>  有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在 InnoDB 中是以页为单位来进行磁盘 IO 的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是 16KB 大小，只修改一个字节就要刷新 16KB 的数据到磁盘上显然是太小题大做了。</p></li><li><p>随机 IO 刷新较慢</p><p>  一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的 Buffer Pool 中的页面刷新到磁盘时，需要进行很多的随机 IO，随机 IO 比顺序 IO 要慢，尤其对于传统的机械硬盘来说。</p></li></ul><p>另一个解决的思路：我们只是想让已经提交了的事务对数据库中数据所作的修改永久有效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好。比如，某个事务将系统表空间中第 10 号页面中偏移量为 100 处的那个字节的值 1 改为 2。我们只需要记录一下：将第 0 号表空间的 10 号页面的偏移量为 100 处的值更新为 2。</p><p>InnoDB 引擎的事务采用了 WAL (Write-Ahead Logging)，这种技术的思想就是先写日志，在写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是 redo log。当发生宕机且数据未刷到磁盘的时候，可以通过 redo log 来回复，保证 ACID 中的 D，这就是 redo log 的作用。</p><p><img src="http://1.117.162.142:9000/blog/redo%E6%A6%82%E5%BF%B5%E5%9B%BE.png" alt="redo概念图"></p><h4 id="1-2-REDO-日志的好处、特点"><a href="#1-2-REDO-日志的好处、特点" class="headerlink" title="1.2 REDO 日志的好处、特点"></a>1.2 REDO 日志的好处、特点</h4><p><strong>好处</strong>：</p><ul><li>redo 日志降低了刷盘频率</li><li>redo 日志占用的空间非常小</li></ul><p>存储表空间 ID、页号、偏移量以及需要更新的值，所需的存储空间是很小的，刷盘快。</p><p><strong>特点</strong>：</p><ul><li>redo 日志是顺序写入磁盘的</li></ul><p>在执行事务的过程中，没执行一条语句，就可能产生若干条 redo 日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序 IO，效率比随机 IO 快。</p><ul><li>事务执行过程中，redo log 不断记录</li></ul><p>redo log 跟 bin log 的区别，redo log 是存储引擎层产生的，而 bin log 是数据库层产生的。假设一个事务，对表做 10 万行的记录插入，在这个过程中，一直不断往 redo log 顺序记录，而 bin log 不会记录，直到这个事务提交，才会一次写入到 bin log 文件中。</p><h4 id="1-3-redo-的组成"><a href="#1-3-redo-的组成" class="headerlink" title="1.3 redo 的组成"></a>1.3 redo 的组成</h4><p>Redo log 可以简单分为以下两个部分：</p><ul><li><p>重做日志的缓冲 (redo log buffer)，保存在内存中，是易失的。</p><p>  在服务器启动时就向操作系统申请了一大片称之为 redo log buffer 的连续内存空间，翻译成中文就是 redo 日志缓冲区。这片内存空间被划分成若干个连续的 redo log block。一个 redo log block 占用 512 字节大小。</p><p>  <img src="http://1.117.162.142:9000/blog/logbuffer%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="logbuffer结构示意图"></p><p>  <strong>参数设置：innodb_log_buffer_size：</strong></p><p>  redo log buffer 大小，默认 16M，最大值时 4096M，最小值为 1M。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%innodb_log_buffer_size%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name          <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_log_buffer_size <span class="operator">|</span> <span class="number">16777216</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br></pre></td></tr></table></figure></li><li><p>重做日志文件 (redo log file)，保存在硬盘中，是持久的。</p><p>  REDO 日志文件如图所示，其中的 ib_logfile0 和 ib_logfile1 即为 REDO 日志。</p></li></ul><h4 id="1-4-redo-的整体流程"><a href="#1-4-redo-的整体流程" class="headerlink" title="1.4 redo 的整体流程"></a>1.4 redo 的整体流程</h4><p>以一个更新事务为例，redo log 流转过程，如下图所示：</p><p><img src="http://1.117.162.142:9000/blog/%E6%9B%B4%E6%96%B0%E4%BA%8B%E5%8A%A1redolog.png" alt="更新事务"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝</span><br><span class="line">第二步：生成一条重做日志并写入 redo log buffer，记录的是数据被修改后的值</span><br><span class="line">第三步：当事务 commit 时，将 redo log buffer 中的内容刷新到 redo log file，对 redo log file 采用追加写的方式</span><br><span class="line">第四步：定期将内存中修改的数据刷新到磁盘中</span><br></pre></td></tr></table></figure><blockquote><p>体会：</p><p>Write-Ahead Log (预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。</p></blockquote><h4 id="1-5-redo-log-的刷盘策略"><a href="#1-5-redo-log-的刷盘策略" class="headerlink" title="1.5 redo log 的刷盘策略"></a>1.5 redo log 的刷盘策略</h4><p>redo log 的写入并不是直接写入磁盘的，InnoDB 引擎会在写 redo log 的时候先写 redo log buffer，之后以一定的频率刷入到真正的 redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。</p><p><img src="http://1.117.162.142:9000/blog/redolog%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5.png" alt="redo刷盘"></p><p>注意，redo log buffer 刷盘到 redo log file 的过程并不是真正的刷到磁盘中去，只是刷入到文件系统缓存 (page cache) 中去 (这是现代操作系统为了提高文件写入效率做的一个优化)，真正的写入会交给系统自己来决定 (比如 page cache 足够大了)。那么对于 InnoDB 来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了 (虽然整个系统宕机的概率还是比较小的)。</p><p>针对这种情况，InnoDB 给出 <code>innodb_flush_log_at_trx_commit</code> 参数，该参数控制 commit 提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p><ul><li>设置为 0：表示每次事务提交时不进行刷盘操作。(系统默认 master thread 每隔 1s 进行一次重做日志的同步)</li><li>设置为 1：表示每次事务提交时都将进行同步，刷盘操作 (默认值)</li><li>设置为 2：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由 os 自己决定什么时候同步到磁盘文件。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_flush_log_at_trx_commit&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                  <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_flush_log_at_trx_commit <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+-------+</span></span><br></pre></td></tr></table></figure><p>另外，InnoDB 存储引擎有一个后台线程，每隔 1 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存 (page cache)，然后调用刷盘操作。</p><p><img src="http://1.117.162.142:9000/blog/redolog%E5%88%B7%E7%9B%98-1.png" alt="redolog刷盘"></p><p>也就是说，一个没有提交事务的 redo log 记录，也可能会刷盘。因为在事务执行过程 redo log 记录是会写入 redo log buffer 中，这些 redo log 记录会被后台线程刷盘。</p><p><img src="http://1.117.162.142:9000/blog/redolog%E5%88%B7%E7%9B%98-2.png" alt="redolog刷盘"></p><p>除了后台线程每秒 1 次的轮训操作，还有一种情况，当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size (这个参数默认是 16M) 的一半的时候，后台线程会主动刷盘。</p><h4 id="1-6-不同刷盘策略演示"><a href="#1-6-不同刷盘策略演示" class="headerlink" title="1.6 不同刷盘策略演示"></a>1.6 不同刷盘策略演示</h4><ul><li><p>流程图</p><p>  <img src="http://1.117.162.142:9000/blog/innodb_flush_log_at_trx_commit%E4%B8%BA1.png" alt="刷盘策略流程图"></p><blockquote><p>小结：innodb_flush_log_at_trx_commit&#x3D;1</p><p>为 1 时，只要事务提交成功，redo log 记录就一定在硬盘里，不会有任何数据丢失。</p><p>如果事务执行期间 MySQL 挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。可以保证 ACID 的 D，数据绝对不会丢失，但是效率最差的。</p><p>建议使用默认值，虽然操作系统宕机的概率理论小于数据库宕机的概率，但是一般既然使用了事务，那么数据的安全相对来说更重要些。</p></blockquote><p>  <img src="http://1.117.162.142:9000/blog/innodb_flush_log_at_trx_commit%E4%B8%BA2.png" alt="innodb_flush_log_at_trx_commit=2"></p><blockquote><p>小结：innodb_flush_log_at_trx_commit&#x3D;2</p><p>为 2 时，只要事务提交成功，redo log buffer 中的内容只写入文件系统缓存 (page cache)。</p><p>如果仅仅只是 MySQL 挂了不会有任何数据丢失，但是操作系统宕机可能会有 1 秒数据的丢失，这种情况下无法满足 ACID 中的 D。但是数值 2 肯定是效率最高的。</p></blockquote><p>  <img src="http://1.117.162.142:9000/blog/innodb_flush_log_at_trx_commit%E4%B8%BA0.png" alt="innodb_flush_log_at_trx_commit为0"></p><blockquote><p>小结：innodb_flush_log_at_trx_commit&#x3D;0</p><p>为 0 时，master thread 中每 1 秒进行一次重做日志的 fsync 操作，因此实例 crash 最多丢失 1 秒钟内的事务。(master thread 是负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性)</p><p>数值 0 的话，是一种折中的做法，它的 IO 效率理论是高于 1 的，低于 2 的，这种策略也有丢失数据的风险，也无法保证 D。</p></blockquote></li></ul><h4 id="1-7-写入-redo-log-buffer-过程"><a href="#1-7-写入-redo-log-buffer-过程" class="headerlink" title="1.7 写入 redo log buffer 过程"></a>1.7 写入 redo log buffer 过程</h4><p><strong>1. 补充概念：Mini-Transaction</strong></p><p>MySQL 把对底层页面中的一次源自访问的过程称之为一个 <code>Mini-Transaction</code>，简称 <code>mtr</code>，比如，像某个索引对应的 B+ 树中插入一条记录的过程就是一个 <code>Mini-Transaction</code>。一个所谓的 <code>mtr</code> 可以包含一组 redo 日志，在进行崩溃恢复时这一组 <code>redo</code> 日志作为一个不可分割的整体。</p><p>一个事物可以包含若干条语句，每一条语句其实是由若干个 <code>mtr</code> 组成，每一个 <code>mtr</code> 又可以包含若干条 redo 日志，画个图表表示他们的关系就是这样：</p><img src="http://1.117.162.142:9000/blog/image-20230130150340421.png" alt="image-20230130150340421" style="zoom:50%;" /><p><strong>2. redo 日志写入 log buffer</strong></p><p>向 <code>log buffer</code> 中写入 redo 日志的过程是顺序的，也就是先往前边的 block 中写，当该 block 的空闲空间用完之后再往下一个 block 中写。当我们想往 <code>log buffer</code> 中写入 redo 日志时，第一个遇到的问题就是应该写在哪个 <code>block</code> 的那个偏移量处，所以 <code>InnoDB</code> 的设计者特意提供了一个称之为 <code>buf_free</code> 的全局变量，该变量指明后续写入的 redo 日志应该写入到 <code>log buffer</code> 哪个位置，如图所示：</p><p><img src="http://1.117.162.142:9000/blog/image-20230130150948881.png" alt="image-20230130150948881"></p><p>一个 mtr 执行过程中可能产生若干条 redo 日志，<code>这些 redo 日志是一个不可分割的组</code>，所以其实并不是每升成一条 redo 日志，就将其插入到 <code>log buffer</code> 中，而是每个 mtr 运行过程中产生的日志先暂时存放到一个地方，当该 mtr 结束的时候，将过程中产生的一组 redo 日志在全部复制到 <code>log buffer</code> 中。我们现在假设有两个名为 <code>T1</code>、<code>T2</code> 的事物，每个事物都包含 2 个 mtr，我们给这几个 mtr 命名一下：</p><ul><li>事物 <code>T1</code> 的两个 <code>mtr</code> 分别称为 <code>mtr_T1_1</code> 和 <code>mtr_T1_2</code>。</li><li>事物 <code>T2</code> 的两个 <code>mtr</code> 分别称为 <code>mtr_T2_1</code> 和 <code>mtr_T2_2</code>。</li></ul><p>每个 mtr 都会产生一组 redo 日志，用示意图来描述一下这些 mtr 产生的日志情况：</p><p><img src="http://1.117.162.142:9000/blog/image-20230130151633396.png" alt="image-20230130151633396"></p><p>不同的事物可能是<strong>并发</strong>执行的，所以 <code>T1</code> 、<code>T2</code> 之间的 <code>mtr</code> 可能是<strong>交替执行</strong>的。每当一个 <code>mtr</code> 执行完成时，伴随该 <code>mtr</code> 生成的一组 redo 日志就需要被复制到 <code>log buffer</code> 中，也就是说不同事物的 mtr 可能是交替写入 log buffer 的，我们画个示意图(为了美观，把一个 mtr 中产生的所有 redo 日志当做一个整体来画)：</p><p><img src="http://1.117.162.142:9000/blog/image-20230130151938838.png" alt="image-20230130151938838"></p><p>有的 mtr 产生的 redo 日志量非常大，比如 <code>mtr_t1_2</code> 产生的 redo 日志占用空间比较大，占用了 3 个 block 来存储。</p><p><strong>3. redo log block 的结构图</strong></p><p>一个 redo log block 是由<strong>日志头</strong>、<strong>日志体</strong>、<strong>日志尾</strong>组成。日志头占用 12 字节，日志尾占用 8 字节，所以一个 block 真正能存储的数据就是 512-12-8&#x3D;492 字节。</p><blockquote><p><strong>为什么一个 block 设计成 512 字节</strong>？</p><p>这个和磁盘的扇区有关，机械磁盘默认的扇区就是 512 字节，如果你要写入的数据大于 512 字节，那么要写入的扇区肯定不止一个，这时就要涉及到磁片的转动，找到下一个扇区，假设现在需要写入两个扇区 A 和 B，如果扇区 A 写入成功，扇区 B 写入失败，那么就会出现<strong>非原子性</strong>的写入，而如果每次只写入和扇区的大小一样的 512 字节，那么每次的写入都是原子性的。</p></blockquote><img src="http://1.117.162.142:9000/blog/image-20230130152723402.png" alt="image-20230130152723402" style="zoom:50%;" /><p>真正的 redo 日志都是存储到占用 496 字节大小的 <code>log block body</code> 中，图中的 <code>log block header</code> 和 <code>log block trailer</code> 存储的是一些<strong>管理信息</strong>，我们看看这些所谓的管理信息都有什么？</p><img src="http://1.117.162.142:9000/blog/image-20230130152940780.png" alt="image-20230130152940780" style="zoom:50%;" /><ul><li><code>log block header</code> 的属性分别如下：<ul><li><code>LOG_BLOCK_HDR_NO</code>：log buffer 是由 log block 组成，在内部 log buffer 就好似一个数组，因此 LOG_BLOCK_HDR_NO 用来标记这个数组中的位置，其是递增并且循环使用的，占用 4 个字节，但是由于第一位用来判断是否是 flush bit，所以最大的值为 2G。</li><li><code>LOG_BLOCK_HDR_DATA_LEN</code>：表示 block 中已经使用了多少字节，初始值为 12 (因为 log block body 从第 12 个字节处开始)。随着往 block 中写入的日志越来越多，本属性值也跟正增长。如果 log block body 已经被全部写满，那么本属性的值被设置为 512。</li><li><code>LOG_BLOCK_FIRST_REC_GROUP</code>：一条 redo 日志也可以称之为一条 redo 日志记录 (redo log record)，一个 mtr 会产生多条 redo 日志记录，这些 redo 日志记录被称之为一个 redo 日志记录组 (redo log record group)。LOG_BLOCK_FIRST_REC_GROUP 就代表该 block 中第一个 mtr 生成的 redo 日志记录组的偏移量 (其实也就是这个 block 里第一个 mtr 生成的第一条 redo 日志的偏移量)。如果该值的大小和 LOG_BLOCK_HDR_DATA_LEN 相同，则表示当前 log block 不包含新的日志。</li><li><code>LOG_BLOCK_CHECKPOINT_NO</code>：占用 4 字节，表示该 log block 最后被写入时的 checkpoint。</li></ul></li><li><code>log block trailer</code> 中属性的意思如下：<ul><li><code>LOG_BLOCK_CHECKSUM</code>：表示 block 的校验值，用于正确性校验 (其值和 LOG_BLOCK_HDR_NO 相同)，暂时不关心它。</li></ul></li></ul><h4 id="1-8-redo-log-file"><a href="#1-8-redo-log-file" class="headerlink" title="1.8 redo log file"></a>1.8 redo log file</h4><p><strong>1. 相关参数设置</strong></p><ul><li><code>innodb_log_group_home_dir</code>：指定 redo log 文件组所在的路径，默认值为 <code>./</code>，表示在数据库的数据目录下。MySQL 的默认数据目录 (<code>var/lib/mysql</code>) 下默认有两个名为 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>  的文件，log buffer 中的日志默认情况下就是刷新到这两个磁盘文件中。此 redo 日志文件位置还可以修改。</li><li><code>innodb_log_file_in_group</code>：指明 redo log file 的个数，命名方式如：ib_logfile0，ib_logfile1… ib_logfilen。默认 2 个。最大 100 个。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_log_files_in_group&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name             <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_log_files_in_group <span class="operator">|</span> <span class="number">2</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br></pre></td></tr></table></figure><ul><li><code>innodb_flush_log_at_trx_commit</code>：控制 redo log 刷新到磁盘的策略，默认为 1。</li><li><code>innodb_log_file_size</code>：单个 redo log 文件设置大小，默认值为 48M。最大值为 512G，注意最大值指的是整个 redo log 系列文件之后，即 (innodb_log_files_in_group * innodb_log_file_size) 不能大于最大值 512G。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_log_file_size&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name        <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_log_file_size <span class="operator">|</span> <span class="number">50331648</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br></pre></td></tr></table></figure><p>根据业务修改其大小，以便容纳较大的事物。编辑 my.cnf 文件并重启数据库生效，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br><span class="line">innodb_log_file_size=200M</span><br></pre></td></tr></table></figure><blockquote><p>在数据库实例更新比较频繁的情况下，可以适当加大 redo log 组数和大小。但也不推荐 redo log 设置过大，在 MySQL 崩溃恢复时会重新执行 redo 日志中的记录。</p></blockquote><p><strong>2. 日志文件组</strong></p><p>从上边的描述中可以看到，磁盘上的 redo 日志文件不止一个，而是以一个日志文件组的形式出现的。这些文件以 <code>ib_logfile[数字]</code>(数字可以是 0、1、2…) 的形式进行命名，每个 redo 日志文件大小都是一样的。</p><p>在将 redo 日志写入日志文件组时，是从 <code>ib_logfile0</code> 开始写，如果 <code>ib_logfile0</code> 写满了，就接着 <code>ib_logfile1</code> 写。同理，<code>ib_logfile1</code> 写满了就去写 <code>ib_logfile2</code>，依此类推。如果写到最后一个文件该咋办？那就重新转到 <code>ib_logfile0</code> 继续写，所以整个过程如下图所示：</p><img src="http://1.117.162.142:9000/blog/image-20230130155914261.png" alt="image-20230130155914261" style="zoom:50%;" /><p>总共的 redo 日志文件大小其实就是：<code>innodb_log_file_size * innodb_log_files_in_group</code>。</p><p>采用循环使用的方式向 redo 日志文件组里写数据的话，会导致后写入的 redo 日志覆盖掉前边写的 redo 日志？当然，所以 InnoDB 的设计者提出了 checkpoint 的概念。</p><p><strong>3. checkpoint</strong></p><p>在整个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint</p><ul><li><code>write pos</code> 是当前记录的位置，一边写一边后移</li><li><code>checkpoint</code> 是当前要擦除的位置，也是往后推移</li></ul><p>每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。每次 MySQL 家在日志文件恢复数据时，会清空加载过的 redo log 记录，并把 checkpoint 后移更新。write pos 和 checkpoint 之间的还空着的部分可以用来写入新的 redo log 记录。</p><img src="http://1.117.162.142:9000/blog/image-20230130160454246.png" alt="image-20230130160454246" style="zoom:50%;" /><p>如果 write pos 追上 checkpoint，表示日志文件组满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。</p><img src="http://1.117.162.142:9000/blog/image-20230130160628429.png" alt="image-20230130160628429" style="zoom:50%;" /><h4 id="1-9-redo-log-小结"><a href="#1-9-redo-log-小结" class="headerlink" title="1.9 redo log 小结"></a>1.9 redo log 小结</h4><p>redo log 的作用和它的刷盘时机、存储形式：</p><p><strong>InnoDB 的更新操作采用的是 Write Ahead Log(预先日志持久化)策略，即先写日志，再写入磁盘</strong>。</p><img src="http://1.117.162.142:9000/blog/image-20230130160811676.png" alt="image-20230130160811676" style="zoom:50%;" /><h3 id="2-Undo-日志"><a href="#2-Undo-日志" class="headerlink" title="2. Undo 日志"></a>2. Undo 日志</h3><p>redo log 是事务持久性的保证，undo log 是事务原子性的保证。在事务中<code>更新数据</code>的<code>前置操作</code>其实是要先写入一个 <code>undo log</code>。</p><h4 id="2-1-如何理解-Undo-日志"><a href="#2-1-如何理解-Undo-日志" class="headerlink" title="2.1 如何理解 Undo 日志"></a>2.1 如何理解 Undo 日志</h4><p>事务需要保证<code>原子性</code>，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如<code>服务器本身的错误</code>，<code>操作系统错误</code>，甚至是突然<code>断电</code>导的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入 <code>ROLLBACK</code> 语句结束当前事务的执行。</li></ul><p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为<code>回滚</code>，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合<code>原子性</code>要求。</p><p>每当我们要对一条记录做改动时(这里的改动可以指 <code>INSERT、DELETE、UPDATE</code>)，都需要”留一手”——把回滚时所需的东西记下来。比如:</p><ul><li><p>你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。(对于每个 INSERT,  InnoDB 存储引擎会完成一个 DELETE)</p></li><li><p>你删除了一条记录，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。(对于每个 DELETE，InnoDB 存储引擎会执行一个 INSERT)</p></li><li><p>你修改了一条记录，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。(对于每个 UPDATE，InnoDB 存储引擎会执行一个相反的 UPDATE，将修改前的行放回去)</p></li></ul><p>MySQL 把这些为了回滚而记录的这些内容称之为撤销日志或者回滚日志(即 undo log)。注意，由于查询操作 (SELECT) 并不会修改任何用户记录，所以在杳询操作行时，并不需要记录相应的 undo 日志</p><p>此外，undo log 会产生 redo log，也就是 undo log 的产生会伴随着 redo log 的产生，这是因为 undo log 也需要持久性的保护</p><h4 id="2-2-Undo-日志的作用"><a href="#2-2-Undo-日志的作用" class="headerlink" title="2.2 Undo 日志的作用"></a>2.2 Undo 日志的作用</h4><ul><li><p>作用1：回滚数据<br>  用户对 undo 日志可能有误解: undo 用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此。undo 是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。<br>  这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。</p></li><li><p>作用2：MVCC<br>  undo 的另一个作用是 MVCC，即在 InnoDB 存储引擎中 MVCC 的实现是通过 undo 来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过 undo 读取之前的行版本信息，以此实现非锁定读取。</p></li></ul><h4 id="2-3-Undo-的存储结构"><a href="#2-3-Undo-的存储结构" class="headerlink" title="2.3 Undo 的存储结构"></a>2.3 Undo 的存储结构</h4><p><strong>1. 回滚段与 undo 页</strong></p><p>InnoDB 对 undo log 的管理采用段的方式，也就是<code>回滚段（rollback segment）</code> 。每个回滚段记录了 <code>1024</code> 个 <code>undo log segment</code>，而在每个 undo log segment 段中进行 <code>undo页</code>的申请。</p><ul><li><p>在<code>InnoDB1.1 版本之前 </code>（不包括1.1版本），只有一个 rollback segment，因此支持同时在线的事务限制为<code>1024</code>。虽然对绝大多数的应用来说都已经够用。</p></li><li><p>从 1.1 版本开始 InnoDB 支持最大 <code>128个rollback segment</code>，故其支持同时在线的事务限制提高到了 <code>128*1024</code>。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_undo_logs&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_undo_logs <span class="operator">|</span> <span class="number">128</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br></pre></td></tr></table></figure><p>虽然 InnoDB1.1 版本支持了 128 个 rollback segment，但是这些 rollback segment 都存储于共享表空间 ibdata 中。从 lnnoDB1.2 版本开始，可通过参数对 rollback segment 做进一步的设置。这些参数包括:</p><ul><li><p><code>innodb_undo_directory</code>: 设置 rollback segment 文件所在的路径。这意味着 rollback segment 可以存放在共享表空间以外的位置，即可以设置为独立表空间。该参数的默认值为 “.&#x2F;”，表示当前 InnoDB 存储引擎的目录。</p></li><li><p><code>innodb_undo_logs</code>: 设置 rollback segment 的个数，默认值为 128。在 InnoDB1.2 版本中，该参数用来替换之前版本的参数innodb_rollback_segments。</p></li><li><p><code>innodb_undo_tablespaces</code> : 设置构成 rollback segment 文件的数量，这样 rollback segment 可以较为平均地分布在多个文件中。设置该参数后，会在路径 innodb_undo_directory 看到 undo 为前缀的文件，该文件就代表 rollback segment 文件。</p></li></ul><p><strong>undo 页的重用</strong></p><p>当我们开启一个事务需要写 undo log 的时候，就得先去 undo log segment 中去找到一个空闲的位置，当有空位的时候，就去申请 undo 页，在这个申请到的 undo 页中进行 undo log 的写入。我们知道mysql默认一页的大小是 16k。</p><p>为每一个事务分配一个页，是非常浪费的(除非你的事务非常长)，假设你的应用的 TPS(每秒处理的事务数目)为 1000，那么 1s 就需要 1000 个页，大概需要 16M 的存储，1 分钟大概需要 1G 的存储。如果照这样下去除非 MySQL 清理的非常勤快，否则随着时间的推移，磁盘空间会增长的非常快，而且很多空间都是浪费的。</p><p>于是 undo 页就被设计的可以重用了，当事务提交时，并不会立刻删除 undo 页。因为重用，所以这个 undo 页可能混杂着其他事务的undo log。undo log 在 commit 后，会被放到一个链表中，然后判断 undo 页的使用空间是否小于 3&#x2F;4，如果小于 3&#x2F;4 的话，则表示当前的 undo 页可以被重用，那么它就不会被回收，其他事务的 undo log 可以记录在当前 undo 页的后面。由于 undo log 是离散的，所以清理对应的磁盘空间时，效率不高。</p><p><strong>2. 回滚段与事务</strong></p><ol><li><p>每个事务只会使用一个回滚段 (rollback segment)，一个回滚段在同一时刻可能会服务于多个事务。</p></li><li><p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p></li><li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</p></li><li><p>回滚段存在于 undo 表空间中，在数据库中可以存在多个 undo 表空间，但同一时刻只能使用一个 undo 表空间。</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_undo_tablespaces&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name           <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_undo_tablespaces <span class="operator">|</span> <span class="number">2</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br></pre></td></tr></table></figure><ol start="5"><li><p>当事务提交时，InnoDB 存储引擎会做以下两件事情：</p><ul><li><p>将 undo log 放入列表中，以供之后的 purge 操作</p></li><li><p>判断 undo log 所在的页是否可以重用(低于 3&#x2F;4 可以重用)，若可以分配给下个事务使用</p></li></ul></li></ol><p><strong>3. 回滚段中的数据分类</strong></p><ul><li><p>未提交的回滚数据 (uncommitted undo information)：该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。</p></li><li><p>已经提交但未过期的回滚数据 (committed undo information)：该数据关联的事务已经提交，但是仍受到 undo retention 参数的保持时间的影响。</p></li><li><p>事务已经提交并过期的数据 (expired undo information)：事务已经提交，而且数据保存时间已经超过 undo retention 参数指定的时间，属于已经过期的数据。当回滚段满了之后，会优先覆盖”事务已经提交并过期的数据”。</p></li></ul><p>事务提交后并不能马上删除 undo log 及 undo log 所在的页。这是因为可能还有其他事务需要通过 undo log 来得到行记录之前的版本。故事务提交时将 undo log 放入一个链表中，是否可以最终删除 undo log 及 undo log 所在页由 purge 线程来判断。</p><h4 id="2-4-Undo-的类型"><a href="#2-4-Undo-的类型" class="headerlink" title="2.4 Undo 的类型"></a>2.4 Undo 的类型</h4><p>在 InnoDB 存储引擎中，undo log 分为：</p><ul><li><p>insert undo log<br>  insert undo log 是指在 insert 操作中产生的 undo log。因为 insert 操作的记录，只对事务本身可见，对其他事务不可见(这是事务隔离性的要求)，故该 undo log 可以在事务提交后直接删除。不需要进行 purge 操作。</p></li><li><p>update undo log<br>  update undo log 记录的是对 delete 和 update 操作产生的 undo log。该 undo log 可能需要提供 MVCC 机制，因此不能在事务提交时就进行删除。提交时放入 undo log 链表，等待 purge 线程进行最后的删除。</p></li></ul><h4 id="2-5-Undo-log-的生命周期"><a href="#2-5-Undo-log-的生命周期" class="headerlink" title="2.5 Undo log 的生命周期"></a>2.5 Undo log 的生命周期</h4><p><strong>1. 简要生成过程</strong></p><p>以下是 undo+redo 事务的简化过程</p><p>假设有 2 个数值，分别为 A&#x3D;1 和 B&#x3D;2，然后将 A 修改为 3，B 修改为 4</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. start transaction;</span><br><span class="line">2．记录A=1到undo <span class="built_in">log</span>;</span><br><span class="line">3. update A = 3;</span><br><span class="line">4．记录A=3 到redo <span class="built_in">log</span>;</span><br><span class="line">5．记录 B=2到undo loq;</span><br><span class="line">6. update B = 4;</span><br><span class="line">7．记录B = 4到redo <span class="built_in">log</span>;</span><br><span class="line">8．将redo <span class="built_in">log</span>刷新到磁盘;</span><br><span class="line">9. commit</span><br></pre></td></tr></table></figure><ul><li><p>在 1-8 步骤的任意一步系统宕机，事务未提交，该事务就不会对磁盘上的数据做任何影响。</p></li><li><p>如果在 8-9 之间宕机，回复之后可以选择回滚，也可以选择继续完成事务提交，因为此时 redo log 已经持久化。</p></li><li><p>若在 9 之后系统宕机，内存映射中变更的数据还来不及刷回磁盘，那么系统恢复之后，可以根据 redo log 把数据刷回磁盘。</p></li></ul><p><strong>只有 Buffer Pool 的流程</strong>：</p><img src="http://1.117.162.142:9000/blog/image-20230130163555532.png" alt="image-20230130163555532" style="zoom:50%;" /><p><strong>有了 Redo Log 和 Undo Log 之后</strong>：</p><img src="http://1.117.162.142:9000/blog/image-20230130163636605.png" alt="image-20230130163636605" style="zoom:50%;" /><p>在更新 Buffer Pool 中的数据之前，我们需要先将该数据事务开始之前的状态写入 Undo Log 中。假设更新到一半出错了，我们就可以通过 Undo Log 来回滚到事务开始前。</p><p><strong>2. 详细生成过程</strong></p><p>对于 InnoDB 引擎来说，每个行记录除了记录本身的数据之外，还有几个隐藏的列:</p><ul><li><p><code>DB_ROW_ID</code>: 如果没有为表显式的定义主键，并且表中也没有定义唯一索引，那么 InnoDB 会自动为表添加一个 row_id 的隐藏列作为主键。</p></li><li><p><code>DB_TRX_ID</code>: 每个事务都会分配一个事务 ID，当对某条记录发生变更时，就会将这个事务的事务 ID 写入 trx_id 中。</p></li><li><p><code>DB_ROLL_PTR</code>: 回滚指针，本质上就是指向 undo log 的指针。</p></li></ul><img src="http://1.117.162.142:9000/blog/image-20230130163934855.png" alt="image-20230130163934855" style="zoom:50%;" /><p>当我们执行 INSERT 时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (name) <span class="keyword">VALUES</span> (&quot;tom&quot;);</span><br></pre></td></tr></table></figure><p>插入的数据都会生成一条 insert undo log，并且数据的回滚指针会指向它。undo log 会记录 undo log 的序号、插入主键的列和值…，那么在进行 rollback 的时候，通过主键直接把对应的数据删除即可。</p><img src="http://1.117.162.142:9000/blog/image-20230130164048129.png" alt="image-20230130164048129" style="zoom:50%;" /><p>当我们执行 UPDATE 时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name<span class="operator">=</span> &quot;Sun&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><img src="http://1.117.162.142:9000/blog/image-20230130164206448.png" alt="image-20230130164206448" style="zoom:50%;" /><p>这时会把老的记录写入新的 undo log，让回滚指针指向新的 undo log，它的 undo no 是 1，并且新的 undo log 会指向老的 undo log (undo no&#x3D;0)。</p><p>假设现在执行:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> id<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;  </span><br></pre></td></tr></table></figure><img src="http://1.117.162.142:9000/blog/image-20230130164314445.png" alt="image-20230130164314445" style="zoom:50%;" /><p>对于更新主键的操作，会先把原来的数据 deletemark 标识打开，这时并没有真正的删除数据，真正的删除会交给清理线程去判断，然后在后面插入一条新的数据，新的数据也会产生 undo log，并且 undo log 的序号会递增。</p><p>可以发现每次对数据的变更都会产生一个 undo log，当一条记录被变更多次时，那么就会产生多条 undo log，undo log 记录的是变更前的日志，并且每个 undo log 的序号是递增的，那么当要回滚的时候，按照序号依次向前推，就可以找到我们的原始数据了。</p><p><strong>3. undo log 是如何回滚的</strong></p><p>以上面的例子来说，假设执行 rollback，那么对应的流程应该是这样：</p><ol><li>通过undo no&#x3D;3 的日志把 id&#x3D;2 的数据删除</li><li>通过 undo no&#x3D;2 的日志把 id&#x3D;1 的数据的 deletemark 还原成 0</li><li>通过 undo no&#x3D;1 的日志把 id&#x3D;1 的数据的 name 还原成 Tom</li><li>通过 undo no&#x3D;0 的日志把 id&#x3D;1 的数据删除</li></ol><p><strong>4. undo log 的删除</strong></p><ul><li>针对于 insert undo log</li></ul><p>因为 insert 操作的记录，只对事务本身可见，对其他事务不可见。故该 undo log 可以在事务提交后直接删除，不需要进行 purge 操作。</p><ul><li>针对于 update undo log</li></ul><p>该 undo log 可能需要提供 MVCC 机制，因此不能在事务提交时就进行删除。提交时放入 undo log 链表，等待 purge 线程进行最后的删除。</p><blockquote><p>补充: purge 线程两个主要作用是: <code>清理 undo 页</code>和<code>清除 page 里面带有 Delete_Bit 标识的数据行</code>。仕 InnoDB 中，事分中的 Delete 操作实际上并不是真正的删除掉数据行，而是一种 Delete Mark 操作，在记录上标识 Delete_Bit，而不删除记录。是一种”假删除”只是做了个标记，真正的删除工作需要后台 purge 线程去完成。</p></blockquote><h4 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h4><img src="http://1.117.162.142:9000/blog/image-20230130164835932.png" alt="image-20230130164835932" style="zoom:50%;" /><p>undo log 是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p><p>redo log 是物理日志，记录的是数据页的物理变化，undo log 不是 redo log 的逆过程。</p><h2 id="十三、锁"><a href="#十三、锁" class="headerlink" title="十三、锁"></a>十三、锁</h2><blockquote><p>事务的<code>隔离性</code>由<code>锁</code>来实现。</p></blockquote><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><code>锁</code>是计算机协调多个进程或线程<code>并发访问某一资源</code>的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等），我们就需要保证这个数据在任何时刻<code>最多只有一个线程在访问</code>，保证数据的<code>完整性</code>和<code>一致性</code>。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。</p><p>在数据库中，除传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对<code>并发操作进行控制</code>，因此产生了<code>锁</code>。同时<code>锁机制</code>也为实现MySQL的各个隔离级别提供了保证。<code>锁冲突</code>也是影响数据库<code>并发访问性能</code>的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p><h3 id="2-MySQL并发事务访问相同记录"><a href="#2-MySQL并发事务访问相同记录" class="headerlink" title="2. MySQL并发事务访问相同记录"></a>2. MySQL并发事务访问相同记录</h3><h4 id="2-1-读-读情况"><a href="#2-1-读-读情况" class="headerlink" title="2.1 读-读情况"></a>2.1 读-读情况</h4><p><code>读-读</code>情况，即并发事务相继读取相同的记录。<code>读取操作本身不会对记录有任何影响</code>，并不会引起什么问题，所以允许这种情况的发生。</p><h4 id="2-2-写-写情况"><a href="#2-2-写-写情况" class="headerlink" title="2.2 写-写情况"></a>2.2 写-写情况</h4><p><code>写-写</code>情况，即并发事务相继对相同的记录做出改动。</p><p>在这种情况下会发生<code>脏写</code>的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们<code>排队执行</code>，这个排队的过程其实是通过锁来实现的。这个所谓的锁其实是一个<code>内存中的结构</code>，在事务执行前本来是没有锁的，也就是说一开始是没有<code>锁结构</code>和记录进行关联的。</p><img src="http://1.117.162.142:9000/blog/image-20230131104306577.png" alt="image-20230131104306577" style="zoom:50%;" /><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。比如，事务T1要对这条记录做改动，就需要生成一个锁结构与之关联：</p><img src="http://1.117.162.142:9000/blog/image-20230131104331436.png" alt="image-20230131104331436" style="zoom:50%;" /><ul><li><code>trx信息:</code>代表这个锁结构是哪个事务生成的。</li><li><code>is_waiting:</code>代表当前事务是否在等待。</li></ul><p>当事务<code>T1</code>改动了这条记录后，就生成了一个<code>锁结构</code>与该记录关联，因为之前没有别的事务为这条记录加锁，所以<code>is_waiting</code>属性就是<code>false</code>，我们把这个场景就称之为<code>获取锁成功</code>，或者<code>加锁成功</code>，然后就可以继续执行操作了。<br>在事务<code>T1</code>提交之前，另一个事务<code>T2</code>也想对该记录做改动，那么先看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的<code>is_waiting</code>属性值为<code>true</code>, 表示当前事务需要等待，我们把这个场景就称之为<code>获取锁失败</code>，或者<code>加锁失败</code>，图示:</p><img src="http://1.117.162.142:9000/blog/image-20230131104526814.png" alt="image-20230131104526814" style="zoom:50%;" /><p>在事务T1提交之后，就会把该事务生成的<code>锁结构释放</code>掉，然后看看还有没有别的事务在等待获取锁，发现了事务T2还在等待获取锁，所以把事务T2对应的锁结构的<code>is_waiting属性设置为false</code>，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了。效果图就是这样:</p><img src="http://1.117.162.142:9000/blog/image-20230131104117421.png" alt="image-20230131104117421" style="zoom:50%;" /><p>小结几种说法：</p><ul><li><p>不加锁<br>  意思就是不需要在内存中生成对应的<code>锁结构</code>，可以直接执行操作。</p></li><li><p>获取锁成功，或者加锁成功<br>  意思就是在内存中生成了对应的<code>锁结构</code>，而且锁结构的<code>is_waiting</code>属性为<code>false</code>，也就是事务可以继续执行操作。</p></li><li><p>获取锁失败，或者加锁失败，或者没有获取到锁<br>  意思就是在内存中生成了对应的<code>锁结构</code>，不过锁结构的<code>is_waiting</code>属性为<code>true</code>，也就是事务需要等待，不可以继续执行操作。</p></li></ul><h4 id="2-3-读-写或写-读情况"><a href="#2-3-读-写或写-读情况" class="headerlink" title="2.3 读-写或写-读情况"></a>2.3 读-写或写-读情况</h4><p><code>读-写</code>或<code>写-读</code>，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>的问题。</p><p>各个数据库厂商对<code>SQL标准</code>的支持都可能不一样。比如MySQL在<code>REPEATABLE READ</code>隔离级别上就已经解决了幻读问题。</p><h4 id="2-4-并发问题的解决方案"><a href="#2-4-并发问题的解决方案" class="headerlink" title="2.4 并发问题的解决方案"></a>2.4 并发问题的解决方案</h4><p>怎么解决脏读、不可重复读、幻读这些问题呢？其实有两种可选的解决方案：</p><ul><li>方案一：读操作利用多版本并发控制（MVCC），写操作进行加锁。<br>  所谓的<code>MVCC</code>，就是生成一个<code>ReadView</code>，通过ReadView找到符合条件的记录版本（历史版本由<code>undo日志</code>构建)。查询语句只能<code>读到</code>在生成ReadView之前<code>已提交事务所做的更改</code>，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<code>写操作</code>肯定针对的是<code>最新版本的记录</code>，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<code>读-写</code>操作并不冲突。</li></ul><blockquote><p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p><ul><li>在READ COMMITTED隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象；</li><li>在REPEATABLE READ隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作才会生成一个ReadView，之后的SELECT操作都复用这个ReadView，这样也就避免了不可重复读和幻读的问题。</li></ul></blockquote><ul><li>方案二：读、写操作都采用<code>加锁</code>的方式。<br>  如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去<code>读取记录的最新版本</code>。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行加锁操作，这样也就意味着读操作和写操作也像<code>写-写</code>操作那样<code>排队执行</code>。</li></ul><p><code>脏读</code>的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p><p><code>不可重复读</code>产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p><p><code>幻读</code>问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在，所以读取的时候加锁就有点尴尬（因为你并不知道给谁加锁)。</p><ul><li>小结对比发现：<ul><li>采用<code>MVCC</code>方式的话，<code>读-写</code>操作彼此并不冲突，性能更高。</li><li>采用<code>加锁方式</code>的话，读-写操作彼此需要排队执行，<code>影响性能</code>。</li></ul></li></ul><p>一般情况下我们当然愿意采用<code>MVCC</code>来解决<code>读-写</code>操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用<code>加锁</code>的方式执行。下面就讲解下MySQL中不同类别的锁。</p><h3 id="3-锁的不同角度分类"><a href="#3-锁的不同角度分类" class="headerlink" title="3. 锁的不同角度分类"></a>3. 锁的不同角度分类</h3><img src="http://1.117.162.142:9000/blog/image-20230131105316516.png" alt="image-20230131105316516" style="zoom:50%;" /><h4 id="3-1-从数据操作的类型划分：读锁、写锁"><a href="#3-1-从数据操作的类型划分：读锁、写锁" class="headerlink" title="3.1 从数据操作的类型划分：读锁、写锁"></a>3.1 从数据操作的类型划分：读锁、写锁</h4><p>对于数据库中并发事务的读-读情况并不会引起什么问题。对于写-写、读-写或写-读这些情况可能会引起一些问题，需要使用MVCC或者加锁的方式来解决它们。在使用加锁的方式解决问题时，由于既要允许读-读情况不受影响，又要使写-写、读-写或写-读情况中的操作相互阻塞，所以MySQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为<code>共享锁(Shared Lock，SLock)</code>和<code>排他锁(Exclusive Lock，XLock)</code>也叫读锁(readlock)和写锁(write lock)。</p><ul><li><p><code>读锁：</code>也称为共享锁、英文用S表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</p></li><li><p><code>写锁：</code>也称为排他锁、英文用X表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</p></li></ul><p><strong>需要注意的是对于 InnoDB 引擎来说，读锁和写锁可以加在表上，也可以加在行上。</strong></p><p>举例(行级读写锁)∶如果一个事务T1已经获得了某个行r的读锁，那么此时另外的一个事务T2是可以去获得这个行r的读锁的，因为读取操作并没有改变行r的数据;但是，如果某个事务T3想获得行r的写锁，则它必须等待事务T1、T2释放掉行r上的读锁才行。</p><p>总结:这里的兼容是指对同一张表或记录的锁的兼容性情况。</p><table><thead><tr><th></th><th>X锁</th><th>S锁</th></tr></thead><tbody><tr><td>X锁</td><td>不兼容</td><td>不兼容</td></tr><tr><td>S锁</td><td>不兼容</td><td>兼容</td></tr></tbody></table><p><strong>3.1.1 锁定读</strong></p><p>在采用<code>加锁</code>方式解决脏读、不可重复读、幻读这些问题时，读取一条记录时需要获取该记录的S锁，其实是不严谨的，有时候需要在读取记录时就获取记录的X锁，来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的SELECT语句格式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对读取的记录加S锁:</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> SHARE;#(<span class="number">8.0</span>新增语法)</span><br></pre></td></tr></table></figure><p>在普通的SELECT语句后边加<code>LOCK IN SHARE MODE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加S锁，这样允许别的事务继续获取这些记录的S锁(比方说别的事务也使用<code>SELECT ... LOCK IN SHAREMODE</code>语句来读取这些记录)，但是不能获取这些记录的X锁(比如使用<code>SELECT ... FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的<code>x锁</code>，那么它们会阻塞，直到当前事务提交之后将这些记录上的<code>S锁</code>释放掉。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对读取的记录加X锁:</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>在普通的SELECT语句后边加<code>FOR UPDATE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加X锁，这样既不允许别的事务获取这些记录的S锁(比方说别的事务使用<code>SELECT ... LOCK IN SHARE MODE语句</code>来读取这些记录)，也不允许获取这些记录的X锁(比如使用<code>SELECT ... FOR UPDATE语句</code>来读取这些记录，或者直接修改这些记录)。如果别的事务想要获取这些记录的S锁或者X锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的X锁释放掉。</p><p><strong>MySQL8.0新特性:</strong></p><p>在5.7及之前的版本，SELECT …FOR UPDATE，如果获取不到锁，会一直等待，直到innodb_lock_wait_timeout超时。在8.0版本中，SELECT. FOR UPDATE，SELECT …FOR SHARE添加NOWAIT、SKIP LOCKED语法，跳过锁等待，或者跳过锁定。</p><p>通过添加NOWAIT、SKIP LOCKED语法，能够立即返回。如果查询的行已经加锁:</p><ul><li>那么NOWAIT会立即报错返回（等不到锁立即返回）</li><li>而SKIP LOCKED也会立即返回，只是返回的结果中不包含被锁定的行。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT. <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> NOWAIT</span><br><span class="line">SELECT. <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">SKIP</span> LOCKED</span><br></pre></td></tr></table></figure><p><strong>3.1.2 写操作</strong></p><p>平常所用到的<code>写操作</code>无非是<code>DELETE</code>、<code>UPDATE</code>、<code>INSERT</code>这三种:</p><ul><li>DELETE:<br>  对一条记录做DELETE操作的过程其实是先在<code>B+树</code>中定位到这条记录的位置，然后获取这条记录的<code>X锁</code>，再执行delete mark.操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</li><li>UPDATE∶在对一条记录做UPDATE操作时分为三种情况:<ul><li>情况1: 未修改该记录的<code>键值</code>，并且被更新的列占用的存储空间在修改前后<code>未发生变化</code>。<br>  则先在<code>B+树</code>中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原记录的位置进行修改操作。我们也可以把这个定位待修改记录在B+树中位置的过程看成是一个<code>获取X锁</code>的<code>锁定读</code>。</li><li>情况2∶未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。<br>  则先在B+树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表)，最后再插入一条新记录。这个定位待修改记录在B+树中位置的过程看成是一个获取<code>×锁</code>的<code>锁定读</code>，新插入的记录由<code>INSERT</code>操作提供的隐式锁进行保护。</li><li>情况3∶修改了该记录的键值，则相当于在原记录上做DELETE操作之后再来一次INSERT操作，加锁操作就需要按照<code>DELETE和INSERT</code>的规则进行了。</li></ul></li><li>INSERT :<br>  一般情况下，新插入一条记录的操作并不加锁，通过一种称之为<code>隐式锁</code>的结构来保护这条新插入的记录在本事务<code>提交前不被别的事务访问</code>。</li></ul><h4 id="3-2-从数据操作的粒度划分：表级锁、页级锁、行锁"><a href="#3-2-从数据操作的粒度划分：表级锁、页级锁、行锁" class="headerlink" title="3.2 从数据操作的粒度划分：表级锁、页级锁、行锁"></a>3.2 从数据操作的粒度划分：表级锁、页级锁、行锁</h4><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很<code>耗资源</code>的事情（涉及获取、检查、释放锁等动作)(越小消耗越大)。因此数据库系统需要在<code>高并响应</code>和<code>系统性能</code>两方面进行平衡，这样就产生了<code>“锁粒度(Lock granularity)”</code>的概念。</p><p>对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细;其实一个事务也可以在表级别进行加锁，自然就被称之为表级锁或者表锁，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。锁的粒度主要分为<code>表级锁、页级锁和行锁</code>。</p><p><strong>3.2.1 表锁（Table Lock）</strong></p><p>该锁会锁定整张表，它是MySQL中最基本的锁策略，<code>并不依赖于存储引擎</code>(不管你是MySQL的什么存储引擎，对于表锁的策略都是一样的)，并且表锁是<code>开销最小</code>的策略（因为粒度比较大)。由于表级锁一次会将整个表锁定，所以可以很好的<code>避免死锁</code>问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致<code>并发率大打折扣</code>。</p><p><strong>① 表级别的S锁、X锁</strong></p><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的<code>S锁或者X锁</code>的。在对某个表执行一些诸如ALTER TABLE、DROP TABLE这类的<code>DDL语句</code>时，其他事务对这个表并发执行诸如SELECT、NSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行DDL语句也会发生阻塞。这个过程其实是通过在server层使用一种称之为<code>元数据锁</code>（英文名：Metadata Locks，简称MDL）结构来实现的。</p><p>一般情况下，<code>不会使用</code>InnoDB存储引擎提供的<code>表级别的S锁和X锁</code>。只会在一些特殊情况下，比方说<code>崩溃恢复</code>过程中用到。比如，在系统变量<code>autocommit=0，innodb_table_locks = 1</code>时，手动获取InnoDB存储引擎提供的表t 的S锁或者X锁可以这么写：</p><ul><li><code>LOCK TABLES t READ：</code>InnoDB存储引擎会对表t加表级别的S锁。</li><li><code>LOCK TABLES t WRITE：</code>InnoDB存储引擎会对表t加表级别的X锁。</li></ul><p>不过尽量避免在使用InnoDB存储引擎的表上使用<code>LOCK TABLES</code>这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的行锁，关于InnoDB表级别的S锁和X锁大家了解一下就可以了。</p><p><strong>举例：MyISAM 引擎下的表锁</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 步骤一：创建表并添加数据</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> mylock(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">)engine myisam;# 存储引擎使用innodb也可以，知识不建议</span><br><span class="line"></span><br><span class="line"># 插入一条数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mylock(name) <span class="keyword">values</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 查询表中所有的数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mylock;</span><br><span class="line"></span><br><span class="line"># 步骤二：查看表上加过的锁</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> tables;  #主要关注in_use字段的值</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> tables <span class="keyword">where</span> In_use <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"># 步骤三：手动增加表锁命令</span><br><span class="line">lock tables t read; #存储引擎会对表t加表级别的共享锁。共享锁也叫读锁或s锁</span><br><span class="line">lock tables t <span class="keyword">where</span>; #存储引擎会对表t加表级别的排他锁。排他锁也叫独占锁、写锁或x锁</span><br><span class="line"></span><br><span class="line"># 步骤四：释放表锁</span><br><span class="line">unlock tables; # 使用此命令解锁当前加锁的表</span><br><span class="line"></span><br><span class="line"># 步骤五：加读锁</span><br><span class="line"># 为mylock表加read锁（读阻塞写），观察阻塞情况，流程如下</span><br></pre></td></tr></table></figure><img src="http://1.117.162.142:9000/blog/image-20230131112857176.png" alt="image-20230131112857176" style="zoom:50%;" /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 步骤流：加写锁</span><br><span class="line"># 为mylock加write锁，观察阻塞的情况，流程如下：</span><br></pre></td></tr></table></figure><img src="http://1.117.162.142:9000/blog/image-20230131113157484.png" alt="image-20230131113157484" style="zoom:50%;" /><p><strong>总结：</strong></p><p>MyISAM在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。InnoDB存储引擎是不会为这个表添加表级别的<code>读锁</code>或者<code>写锁</code>的。</p><p>MySQL的表级锁有两种模式：（以MyISAM表进行操作的演示）</p><ul><li>表共享读锁（Table Read Lock）</li><li>表独占写锁（Table Write Lock）</li></ul><table><thead><tr><th>锁类型</th><th>自己可读</th><th>自己可写</th><th>自己可操作其他表</th><th>他人可读</th><th>他人可写</th></tr></thead><tbody><tr><td>读锁</td><td>是</td><td>否</td><td>否</td><td>是</td><td>否，等</td></tr><tr><td>写锁</td><td>是</td><td>是</td><td>否</td><td>否，等</td><td>否，等</td></tr></tbody></table><p><strong>② 意向锁 （intention lock）</strong></p><p>InnoDB 支持多粒度锁（multiple granularity locking），它允许行级锁与表级锁共存，而 意向锁 就是其中的一种表锁。</p><p>1、意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁)的锁并存。</p><p>2、意向锁是一种不与行级锁冲突表级锁，这一点非常重要。</p><p>3、表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</p><p>意向锁分为两种：</p><ul><li><strong>意向共享锁 （intention shared lock, IS）</strong>：事务有意向对表中的某些行加 <strong>共享锁（S锁）</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 </span></span><br><span class="line"><span class="comment">-- 会自动加，不用管</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure><ul><li><strong>意向排他锁 （intention exclusive lock, IX）</strong>：事务有意向对表中的某些行加 <strong>排他锁（X锁）</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span></span><br><span class="line"><span class="comment">-- 会自动加，不用管</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>即：意向锁是由存储引擎<code>自己维护的</code>，用户无法手动操作意向锁，在为数据行加共享 &#x2F; 排他锁之前，InooDB 会先获取该数据行<code>所在数据表的对应意向锁</code>。</p><p><strong>意向锁要解决的问题</strong>:</p><p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁;如果存在意向锁，那么此时就会受到由T1控制的<code>表级别意向锁的阻塞</code>。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。<code>简单来说就是给更大一级别的空间示意里面是否已经上过锁</code>。</p><p>在数据表的场景中，<code>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了</code>(不这么做的话，想上表锁的那个程序，还要遍历有没有行锁)，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p><ul><li>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上<code>添加意向共享锁</code>。</li><li>如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上<code>添加意向排他锁</code>。</li></ul><p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。</p><p>因为共享锁与排他锁互斥，所以事务B在试图对X表加共享锁的时候，必须保证两个条件。 </p><p>(1）当前没有其他事务持有X表的排他锁</p><p>(2）当前没有其他事务持有X表中任意一行的排他锁。</p><p>为了检测是否满足第二个条件，事务B必须在确保X表不存在任何排他锁的前提下，去检测表中的每一行是否存在排他锁。很明显这是一个效率很差的做法，但是有了意向锁之后，情况就不一样了。</p><p>意向锁是怎么解决这个问题的呢?首先，我们需要知道意向锁之间的兼容互斥性，如下所示。</p><table><thead><tr><th></th><th>意向共享锁(lS)</th><th>意向排他锁(IX)</th></tr></thead><tbody><tr><td>意向共享锁(IS)</td><td>兼容</td><td>兼容</td></tr><tr><td>意向排他锁（IX)</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>即意向锁之间是互相兼容的，虽然意向锁和自家兄弟互相兼容，但是它会与普通的排他&#x2F;共享锁互斥。</p><table><thead><tr><th></th><th>意向共享锁(lS)</th><th>意向排他锁(IX)</th></tr></thead><tbody><tr><td>共享锁(S)表</td><td>兼容</td><td>互斥</td></tr><tr><td>排他锁（X)表</td><td>互斥</td><td>互斥</td></tr></tbody></table><p>注意这里的排他&#x2F;共享锁指的都是表锁，意向锁不会与行级的共享&#x2F;排他锁互斥。</p><p><strong>意向锁的并发性</strong></p><p>意向锁不会与行级的共享 &#x2F; 排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。（不然我们直接用普通的表锁就行了）</p><p>我们扩展一下上面 teacher表的例子来概括一下意向锁的作用（一条数据从被锁定到被释放的过程中，可能存在多种不同锁，但是这里我们只着重表现意向锁）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 事务A先获取了某一行的排他锁，并未提交：</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"># 事务A获取了teacher表上的意象排他锁，事务A获取了id为<span class="number">6</span>的数据行上的排他锁。时候事务B想要获取teacher表的共享锁。</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">lock tables teacher read;</span><br><span class="line"># 事务B检测到事务A持有teacher表的意象排他锁。事务B对teacher表的枷锁请求被阻塞(排斥)。最后事务C也想获取teacher表中某一行的排他锁。</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"># 事务C申请teacher表的意象排他锁。事务C检测到事务A持有teacher表的意象排他锁。因为意象锁之间并不互斥，所以事务C获取到了teacher表的意象排他锁。因为id为<span class="number">5</span>的数据行上不存在任何排他锁，最终事务C成功获取到了该数据行上的排他锁。</span><br></pre></td></tr></table></figure><p><strong>从上面的案例可以得到如下结论：</strong></p><ul><li><p>InnoDB 支持<code>多粒度锁</code>，特定场景下，行级锁可以与表级锁共存。</p></li><li><p>意向锁之间互不排斥，但除了 IS 与 S 兼容外，<code>意向锁会与 共享锁 / 排他锁 互斥</code>。</p></li><li><p>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</p></li><li><p>意向锁在保证并发性的前提下，实现了<code>行锁和表锁共存</code>且<code>满足事务隔离性</code>的要求。</p></li></ul><p><strong>③ 自增锁（AUTO-INC锁）</strong></p><p>在使用MySQL过程中，我们可以为表的某个列添加<code>AUTO_INCREMENT</code>属性。</p><p>插入数据是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是<code>“Simple inserts”</code>，<code>“Bulk inserts”</code>和<code>“Mixed-mode inserts”</code>。</p><ul><li><p><strong>“Simple inserts” （简单插入）</strong></p><p>  可以<code>预先确定要插入的行数</code>（当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行<code>INSERT...VALUES()</code>和<code>REPLACE</code>语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行数。</p></li><li><p><strong>“Bulk inserts” （批量插入）</strong></p><p>  <code>事先不知道要插入的行数</code>（和所需自动递增值的数量）的语句。比如INSERT … SELECT，REPLACE… SELECT和LOAD DATA语句，但不包括纯INSERT。InnoDB在每处理一行，为AUTO_INCREMENT列分配一个新值。</p></li><li><p><strong>“Mixed-mode inserts” （混合模式插入）</strong></p><p>  这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如INSERT INTO teacher (id,name) VALUES (1,‘a’), (NULL,‘b’), (5,‘c’), (NULL,‘d’);只是指定了部分id的值。另一种类型的“混合模式插入”是<code>INSERT ... ON DUPLICATE KEY UPDATE</code>。</p></li></ul><p>对于上面数据插入的案例，MySQL中采用了<code>自增锁</code>的方式来实现，<code>AUTO-INC锁是当向使用含有AUTO_INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁</code>，在执行插入语句时就在表级别加一个AUTO-INC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INC锁释放掉。<code>一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞</code>，可以保证<code>一个语句</code>中分配的递增值是<code>连续</code>的。也正因为此，其并发性显然并不高，<code>当我们向一个有AUTO_INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争</code>，这样的并发潜力其实是很低下的，所以innodb通过<code>innodb_autoinc_lock_mode</code>的不同取值来提供不同的锁定机制，来显著提高SQL语句的可伸缩性和性能。</p><p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）innodb_autoinc_lock_mode <span class="operator">=</span> <span class="number">0</span>(“传统”锁定模式)</span><br></pre></td></tr></table></figure><p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺<code>会限制并发能力</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">2</span>）innodb_autoinc_lock_mode <span class="operator">=</span> <span class="number">1</span>(“连续”锁定模式)</span><br></pre></td></tr></table></figure><p>在 MySQL 8.0 之前，连续锁定模式是<code>默认</code>的。</p><p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT …</p><p>SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p><p>对于“Simple inserts”（要插入的行数事先已知），则通过在<code>mutex（轻量锁）</code>的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（ <span class="number">3</span> ）innodb_autoinc_lock_mode <span class="operator">=</span> <span class="number">2</span>(“交错”锁定模式)</span><br></pre></td></tr></table></figure><p>从 MySQL 8.0 开始，交错锁模式是<code>默认</code>设置。</p><p>在这种锁定模式下，所有类INSERT语句都不会使用表级AUTO-INC锁，并且可以同时执行多个语句。这是最快和最可扩展的锁定模式，但是当使用基于语句的复制或恢复方案时，<code>从二进制日志重播SQL语句时，这是不安全的。(主从复制id可能不一致)</code></p><p>在此锁定模式下，自动递增值<code>保证</code>在所有并发执行的所有类型的insert语句中是唯一且单调递增的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号）， <strong>为任何给定语句插入的行生成的值可能不是连续的。</strong></p><p>如果执行的语句是“simple inserts”，其中要插入的行数已提前知道，除了“Mixed-mode inserts”之外，为单个语句生成的数字不会有间隙。然而，当执行“bulk inserts”时,在由任何给定语句分配的自动递增值中可能存在间隙。</p><p><strong>④ 元数据锁（MDL锁）</strong></p><p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个<code>表结构做变更</code>，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此， <strong>当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</strong></p><p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。<code>不需要显式使用</code>，在访问一个表的时候会被自动加上。</p><p><strong>3.2.2 InnoDB中的行锁</strong></p><p>行锁(Row Lock)也称为记录锁，顾名思义，就是锁住某一行（某条记录row)。需要的注意的是，MySQL服务器层并没有实现行锁机制，<strong>行级锁只在存储引擎层实现。</strong></p><p>优点: 锁定力度小，发生<code>锁冲突概率低</code>，可以实现的<code>并发度高</code>。</p><p>缺点: 对于<code>锁的开销比大</code>，加锁会比较慢，容易出现<code>死锁</code>情况。</p><p>InnoDB与MylSAM的最大不同有两点: <code>一是支持事务(TRANSACTION)</code>；<code>二是采用了行级锁</code>。</p><p>首先我们创建表如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">id <span class="type">INT</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">class <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line">再插入几条数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>) ,</span><br><span class="line">(<span class="number">8</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;二班&#x27;</span>) ,</span><br><span class="line">(<span class="number">15</span>,<span class="string">&#x27;赵六&#x27;</span>,<span class="string">&#x27;二班&#x27;</span>) ,</span><br><span class="line">(<span class="number">20</span>,<span class="string">&#x27;钱七&#x27;</span>,<span class="string">&#x27;三班&#x27;</span>);</span><br></pre></td></tr></table></figure><img src="http://1.117.162.142:9000/blog/image-20230131130330632.png" alt="image-20230131130330632" style="zoom:50%;" /><p>这里把B+树的索引结构做了一个超级简化，只把索引中的记录给拿了出来，下面看看都有哪些常用的行锁类型。</p><p><strong>① 记录锁（Record Locks）</strong></p><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为：<code>LOCK_REC_NOT_GAP</code>。比如我们把id值为 8 的<br>那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为 8 的记录，对周围的数据没有影响。</p><img src="http://1.117.162.142:9000/blog/image-20230131130426964.png" alt="image-20230131130426964" style="zoom:50%;" /><p>举例如下：<br><img src="http://1.117.162.142:9000/blog/image-20230131130452484.png" alt="image-20230131130452484" style="zoom:50%;" /></p><p>记录锁是有S锁和X锁之分的，称之为<code>S型记录锁</code>和<code>X型记录锁</code>。</p><ul><li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li><li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li></ul><p><strong>② 间隙锁（Gap Locks）</strong></p><p>MySQL在<code>REPEATABLE READ</code>隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用<code>MVCC</code>方案解决，也可以采用加锁方案解决。但是在使用<code>加锁</code>方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些<code>幻影记录</code>加上记录锁。InnoDB提出了一种称之为<code>Gap Locks的锁</code>，官方的类型名称为：<code>LOCK_GAP</code>，我们可以简称为gap锁。比如，把id值为 8 的那条记录加一个gap锁的示意图如下。</p><img src="http://1.117.162.142:9000/blog/image-20230131130756762.png" alt="image-20230131130756762" style="zoom:50%;" /><p>图中id值为 8 的记录加了gap锁，意味着<code>不允许别的事务在id值为 8 的记录前边的间隙插入新记录</code>，其实就是id列的值( 3 , 8 )这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为 4 的新记录，它定位到该条新记录的下一条记录的id值为 8 ，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间( 3 , 8 )中的新记录才可以被插入。</p><p>**gap锁的提出仅仅是为了防止插入幻影记录而提出的 **。虽然有<code>共享gap锁</code>和<code>独占gap锁</code>这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁（不论是共享gap锁还是独占gap锁)，并不会限制其他事务对这条记录加记录锁或者继续加gap锁。</p><table><thead><tr><th>session 1</th><th>session 2</th></tr></thead><tbody><tr><td>select *from student where id &#x3D;5 lock in share mode;</td><td></td></tr><tr><td></td><td>select * from student where id &#x3D; 5 for update;</td></tr></tbody></table><p>这里session 2并不会被堵住。因为表里并没有id&#x3D;5这个记录，因此session 1加的是间隙锁（3,8)。而session 2也是在这个间隙加的间隙锁。它们有共同的目标，即:保护这个间隙，不允许插入值。但，它们之间是不冲突的。</p><p>注意，给一条记录加了<code>gap锁</code>知识不允许其他事务往这条记录前边的间隙插入新纪录，那对于最后一条记录之后的间隙，也就是 student 表中 id 值为 20 的记录之后的间隙该咋办呢？也就是说给哪条记录加 <code>gap锁</code> 才能阻止其他事务插入 id 值在 (20, +∞) 这个区间的新纪录呢？这时候我们再将数据页时介绍的两条伪记录派上用场了：</p><ul><li><code>Infimum</code>记录，表示该页面中最小的记录</li><li><code>Supremum</code>记录，表示该页面中最大的记录</li></ul><p>为了实现组织其他事务插入id值在(20, +∞) 这个区间的新纪录，我们可以给索引中的最后一条记录，也就是id值为 20 的那条记录所在页面的 Supremum 记录加上一个 gap锁，如图所示：</p><img src="http://1.117.162.142:9000/blog/image-20230131131933042.png" alt="image-20230131131933042" style="zoom:50%;" /><p><strong>③ 临键锁（Next-Key Locks）</strong></p><p>有时候我们既想<code>锁住某条记录</code>，又想<code>阻止</code>其他事务在该记录前边的<code>间隙插入新记录</code>，所以InnoDB就提出了一种称之为<code>Next-Key Locks的锁</code>，官方的类型名称为：<code>LOCK_ORDINARY</code>，我们也可以简称为next-key锁。<code>Next-Key Locks</code>是在存储引擎innodb、事务级别在<code>可重复读</code>的情况下使用的数据库锁，innodb默认的锁就是Next-Key locks。比如吧id值为 8 的那条记录加一个 next-key锁的示意图如下：</p><img src="http://1.117.162.142:9000/blog/image-20230131132319500.png" alt="image-20230131132319500" style="zoom:50%;" /><p><code>next-key锁</code>的本纸就是一个记录锁和一个gap锁的合体，他技能保护该条记录，又能阻止别的事务将新纪录插入被保护记录前边的间隙。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">8</span> <span class="keyword">and</span> id <span class="operator">&gt;</span> <span class="number">3</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p><strong>④ 插入意向锁（Insert Intention Locks）</strong></p><p>我们说一个事务在<code>插入</code>一条记录时需要判断一下插入位置是不是被别的事务加了<code>gap锁</code>（<code>next-key锁</code>也包含<code>gap锁</code>），如果有的话，插入操作需要等待，直到拥有<code>gap锁</code>的那个事务提交。但是 InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构 ，表明有事务想在某个间隙中插入新记录，但是现在在等待。InnoDB就把这种类型的锁命名为<code>Insert Intention Locks</code>，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，我们称为插入意向锁。插入意向锁是一种Gap锁，不是意向锁，在insert操作时产生。</p><p>插入意向锁是在插入一条记录行前，由 <code>INSERT 操作产生的一种间隙锁。</code>该锁用以表示插入意向，当多个事务在同一区间(gap)插入位置不同的多条数据时，事物之间不需要互相等待。假设存在两条值分别为 4 和 7 的记录，两个不同的事务分别是图插入值为 5 和 6 的两条记录，每个事务在获取插入行上独占 (排他) 锁前，都会获取 (4, 7)之间的间隙锁，但是因为数据行之间并不冲突，所以两个事物之间并不会产生冲突(阻塞等待)。</p><p>总结来说，插入意向锁的特性可以分成两部分：</p><p>（1）插入意向锁是一种特殊的间隙锁——间隙锁可以锁定开区间的部分记录。</p><p>（2）插入意向锁之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身 (主键、唯一索引)不冲突，那么事务之间就不会出现冲突等待。</p><p>注意，虽然插入意向锁中含有意向锁三字，但是他并不属于意向锁而属于间隙锁，因为意象锁是表锁而插入意向锁是行锁。</p><p>事实上<strong>插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁</strong>。</p><p><strong>3.2.3 页锁</strong></p><p>页锁就是在<code>页的粒度</code>上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。 <strong>页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong></p><p>每个层级的锁数量是有限制的，因为锁会占用内存空间，<code>锁空间的大小是有限的</code>。当某个层级的锁数量超过了这个层级的阈值时，就会进行<code>锁升级</code>。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p><h4 id="3-3-从对待锁的态度划分-乐观锁、悲观锁"><a href="#3-3-从对待锁的态度划分-乐观锁、悲观锁" class="headerlink" title="3.3 从对待锁的态度划分:乐观锁、悲观锁"></a>3.3 从对待锁的态度划分:乐观锁、悲观锁</h4><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和<a href="https://so.csdn.net/so/search?q=%E6%82%B2%E8%A7%82%E9%94%81&spm=1001.2101.3001.7020">悲观锁</a>，从名字中也可以看出这两种锁是两种看待<code>数据并发的思维方式</code>。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的<code>设计思想</code>。</p><p><strong>悲观锁（Pessimistic Locking）</strong><br>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。</p><p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<code>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</code>）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p><p><strong>乐观锁（Optimistic Locking）</strong><br>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是<code>不采用数据库自身的锁机制，而是通过程序来实现</code>。在程序上，我们可以采用<code>版本号机制</code>或者<code>CAS机制实现</code>。<code>乐观锁适用于多读的应用类型，这样可以提高吞吐量</code>。在Java中java.util.concurrent.atomic包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。</p><p><strong>乐观锁的版本号机制</strong></p><p>在表中设计一个<code>版本字段 version</code>，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行<code>UPDATE ... SET version=version+1 WHERE version=version</code>。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</p><p><strong>2. 乐观锁的时间戳机制</strong></p><p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。</p><p>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或者时间戳），从而证明当前拿到的数据是否最新。</p><p><strong>两种锁的适用场景</strong></p><p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p><ul><li><code>乐观锁适合读操作多的场景</code>，相对来说写的操作比较少。它的优点在于程序实现，不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</li><li><code>悲观锁适合写操作多的场景</code>，因为写的操作具有<code>排它性</code>。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止<code>读 - 写</code>和<code>写 - 写</code>的冲突。</li></ul><h4 id="3-4-按加锁的方式划分：显式锁、隐式锁"><a href="#3-4-按加锁的方式划分：显式锁、隐式锁" class="headerlink" title="3.4 按加锁的方式划分：显式锁、隐式锁"></a>3.4 按加锁的方式划分：显式锁、隐式锁</h4><p><strong>隐式锁</strong><br>一个事务在<code>执行INSERT操作</code>时，如果即将插入的间隙已经被其他事务加了gap锁，那么本次INSERT操作会阻塞，并且当前事务会在该间隙上加一个<code>插入意向锁</code>，否则一般情况下<code>INSERT操作</code>是不加锁的。那如果一个事务首先插入了一条记录（此时并没有在内存生产与该记录关联的锁结构）,然后另一个事务：</p><ul><li><p>立即使用<code>SELECT...LOCK IN SHARE MODE</code>语句读取这条记录，也就是要获取这条记录的S锁，或者使用<code>SELECT...FOR UPDATE</code>语句读取这条记录，也就是要获取这条记录的X锁，怎么办？如果允许这种情况的发生，那么可能产生<code>脏读</code>问题。</p></li><li><p>立即修改这条记录，也就是要获取这条记录的X锁，怎么办？<br>  如果允许这种情况的发生，那么可能产生脏写问题。</p></li></ul><p>这时候我们前边提过的事务id又要起作用了。我们把聚簇索引和二级索引中的记录分开看一下：</p><ul><li><p>情景一： 对于聚簇索引记录来说，有一个<code>trx_id隐藏列</code>，</p></li><li><p>该隐藏列记录着最后改动该记录的事务id。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的trx_id隐藏列代表的的就是当前事务的事务id，如果其他事务此时想对该记录添加S锁或者X锁时，首先会看一下该记录的trx_id隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个X锁（也就是为当前事务创建一个锁结构，is_waiting属性是false），然后自己进入等待状态（也就是为自己也创建一个锁结构，is_waiting属性是true）。</p></li><li><p>情景二： 对于二级索引记录来说，本身并没有trx_id隐藏列，但是在二级索引页面的PageHeader部分有一个<code>PAGE_MAX_TRX_ID</code>属性，该属性代表对该页面做改动的最大的事务id，如果<code>PAGE_MAX_TRX_ID</code>属性值小于当前最小的活跃事务id，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复情景一的做法。</p></li></ul><p>即：一个事务对新插入的记录可以不显式的加锁（生成一个锁结构）,但是由于事务id的存在，相当于加了一个<code>隐式锁</code>。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。隐式锁是一种<code>延迟加锁</code>的机制，从而来减少加锁的数量。</p><p><strong>隐式锁的逻辑过程如下</strong>：</p><p>A. InnoDB的每条记录中都一个隐含的trx_id字段，这个字段存在于聚簇索引的B+Tree中。</p><p>B. 在操作一条记录前，首先根据记录中的trx_id检查该事务是否是活动的事务(未提交或回滚)。如果是活动的事务，首先将隐式锁转换为显式锁(就是为该事务添加一个锁)。</p><p>C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为waiting状态。如果没有冲突不加锁，跳到E。</p><p>D. 等待加锁成功，被唤醒，或者超时。</p><p>E. 写数据，并将自己的trx_id写入trx_id字段。</p><p><strong>显式锁</strong></p><p>通过特定的语句进行加锁，我们一般称之为显示加锁，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">显示加共享锁：</span><br><span class="line"><span class="keyword">select</span> ....  lock <span class="keyword">in</span> share mode</span><br><span class="line">显示加排它锁：</span><br><span class="line"><span class="keyword">select</span> ....  <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><h4 id="3-5-其它锁之：全局锁"><a href="#3-5-其它锁之：全局锁" class="headerlink" title="3.5 其它锁之：全局锁"></a>3.5 其它锁之：全局锁</h4><p>全局锁就是<code>对整个数据库实例加锁</code>。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用场景是：<code>做全库逻辑备份</code>。</p><p>全局锁的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables <span class="keyword">with</span> read lock</span><br></pre></td></tr></table></figure><h4 id="3-6-其它锁之：死锁"><a href="#3-6-其它锁之：死锁" class="headerlink" title="3.6 其它锁之：死锁"></a>3.6 其它锁之：死锁</h4><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。死锁示例：</p><table><thead><tr><th>事务1</th><th>事务2</th></tr></thead><tbody><tr><td>start transaction;update account set money&#x3D;10 where id&#x3D;1;</td><td>start transaction;</td></tr><tr><td></td><td>update account set money&#x3D;10 where id&#x3D;2;</td></tr><tr><td>update account set money&#x3D;20 where id&#x3D;2;</td><td></td></tr><tr><td></td><td>update account set money&#x3D;20 where id&#x3D;1;</td></tr></tbody></table><p>这时候，事务 1 在等待事务 2 释放id&#x3D;2的行锁，而事务 2 在等待事务 1 释放id&#x3D;1的行锁。 事务 1 和事务 2 在互相等待对方的资源释放，就是进入了死锁状态。</p><p><strong>产生死锁的必要条件</strong></p><ul><li>两个或者两个以上事务</li><li>每个事务都已经持有锁并且申请新的锁</li><li>锁资源同时只能被同一个事务持有或者不兼容</li><li>事务之间因为持有锁和申请锁导致彼此循环等待</li></ul><blockquote><p>死锁的关键在于：两个（或以上）的Session加锁的顺序不一致。</p></blockquote><p><strong>如何处理死锁</strong><br>当出现死锁以后，有两种策略：</p><ul><li><p><strong>等待，直到超时（innodb_lock_wait_timeout&#x3D;50s)。</strong></p><p>  即当两个事务互相等待时，当一个事务等待时间超过设置的國值时，<code>就将其回滚</code>，另外事务继续进行。这种方法简单有效，在innodb中，参数<code>innodb_lock_wait_timeout</code>用来设置超时时间。</p><p>  缺点：对于在线服务来说，这个等待时间往往是无法接受的。</p><p>  那将此值修改短一些，比如1s,0.1s是否合适？不合适，容易误伤到普通的锁等待。</p></li><li><p><strong>使用死锁检测进行死锁处理</strong></p><p>  方式1检测死锁太过被动，innodb还提供了<code>wait-for graph</code>算法来主动进行死锁检测，每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。</p><p>  这是一种较为<code>主动的死锁检测机制</code>，要求数据库保存<code>锁的信息链表</code>和<code>事务等待链表</code>两部分信息。</p>  <img src="http://1.117.162.142:9000/blog/image-20230131135751675.png" alt="image-20230131135751675" style="zoom:50%;" /><p>  基于这两个信息，可以绘制wait-for graph(等待图)</p>  <img src="http://1.117.162.142:9000/blog/image-20230131135848718.png" alt="image-20230131135848718" style="zoom:50%;" /><blockquote><p>死锁检测的原理是构建一个以事务为顶点、锁为边的有向图，判断有向图是否存在环，存在即有死锁。</p></blockquote><p>  一旦检测到回路、有死锁，这时候 InnoDB 存储引擎会选择<code>回滚 undo量最小的事务</code>，让其他事务继续执行(<code>innodb_deadlock_detect=on</code>表示开启这个逻辑)。</p><p>  缺点：每个新的被阻塞的线程，都要判断是不是由于自己的加入导致了死锁，这个操作时间复杂度是 O(n)。如果 100 个并发线程同时更新同一行，意味着要检测 100*100&#x3D;1万次，1万个线程就会有 1 千万次检测。</p><p>  <strong>如何解决</strong>？</p><ul><li>关闭死锁检测，但意味着可能会出现大量的超时，会导致业务有损。</li><li>控制并发访问的数量。比如在中间件中实现对于相同行的更新，在进入引擎之前排队，这样在 InnoDb 内部就不会有大量的死锁检测工作。</li></ul><p>  <strong>一进步的思路</strong>：</p><p>  可以考虑通过将一行改成逻辑上的多行来减少锁冲突。比如，连锁超市账户总额的记录，可以考虑放到多条记录上。账户总额等于这多个记录的值的总和。</p></li></ul><p><strong>如何避免死锁</strong></p><ul><li>合理设计索引，使业务 SQL 尽可能通过索引定位更少的行，减少锁竞争。</li><li>调整业务逻辑 SQL 执行顺序，避免 update&#x2F;delete 长时间持有锁的 SQL 在事务前面。</li><li>避免大事务，尽量将大事务拆成多个小事务来处理，小事务缩短锁定资源的时间，发生锁冲突的几率也更小。</li><li>在并发比较高的系统中，不要显式加锁，特别是在事务里显式加锁。如 select.. for update 语句，如果是在事务里运行了 start transaction 或设置了 autocommit &#x3D; 0，那么就会锁定所查找到的记录。</li><li>降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为 RC，可以避免掉很多因为 gap 锁造成的死锁。</li></ul><h3 id="4-锁的内存结构"><a href="#4-锁的内存结构" class="headerlink" title="4. 锁的内存结构"></a>4. 锁的内存结构</h3><p>我们前边说对一条记录加锁的本质就是在内存中创建一个<code>锁结构</code>与之关联，那么是不是一个事务对多条记录加锁，就要创建多个锁结构呢？比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#事务T1</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure><p>理论上创建多个<code>锁结构</code>没问题，但是如果一个事务要获取1000条记录的锁，生成10000个锁结构也太崩溃了！所以决定在对不同记录加锁时，如果符合下边这些条件的记录会放到一个锁结构中。</p><ul><li>在同一个事务中进行加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型是一样的</li><li>等待状态是一样的</li></ul><p>InnoDB存储引擎中的锁结构如下：</p><img src="http://1.117.162.142:9000/blog/image-20230131141425303.png" alt="image-20230131141425303" style="zoom:50%;" /><p><strong>结构解析：</strong></p><ol><li><p>锁所在的事务信息：<br> 不论是<code>表锁</code>还是<code>行锁</code>，都是在事务执行过程中生成的，哪个事务生成了这个<code>锁结构</code>，这里就记录这个事务的信息。</p><p> 此<code>锁所在的事务信息</code>在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p></li><li><p>索引信息：<br> 对于行锁来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p></li><li><p>表锁／行锁信息：<br> <code>表锁结构</code>和<code>行锁结构</code>在这个位置的内容是不同的：</p><ul><li><p>表锁：<br>  记载着是对哪个表加的锁，还有其他的一些信息。</p></li><li><p>行锁：</p><p>  记载了三个重要的信息：</p><ul><li><p>Space ID：记录所在表空间。</p></li><li><p>Page Number：记录所在页号。</p></li><li><p>n_bits：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits属性代表使用了多少比特位。</p><blockquote><p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后<br>也不至于重新分配锁结构</p></blockquote></li></ul></li></ul></li><li><p>type_mode：<br> 这是一个 32 位的数，被分成了lock_mode、lock_type和rec_lock_type三个部分，如图所示：</p></li></ol><img src="http://1.117.162.142:9000/blog/image-20230131141725339.png" alt="image-20230131141725339" style="zoom:50%;" /><ul><li><p>锁的模式（lock_mode），占用低 4 位，可选的值如下：</p><ul><li><p>LOCK_IS（十进制的 0 ）：表示共享意向锁，也就是IS锁。</p></li><li><p>LOCK_IX（十进制的 1 ）：表示独占意向锁，也就是IX锁。</p></li><li><p>LOCK_S（十进制的 2 ）：表示共享锁，也就是S锁。</p></li><li><p>LOCK_X（十进制的 3 ）：表示独占锁，也就是X锁。</p></li><li><p>LOCK_AUTO_INC（十进制的 4 ）：表示AUTO-INC锁。</p></li></ul><p>  在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p></li><li><p>锁的类型（lock_type），占用第 5 ～ 8 位，不过现阶段只有第 5 位和第 6 位被使用：</p><ul><li>LOCK_TABLE（十进制的 16 ），也就是当第 5 个比特位置为 1 时，表示表级锁。</li><li>LOCK_REC（十进制的 32 ），也就是当第 6 个比特位置为 1 时，表示行级锁。</li></ul></li><li><p>行锁的具体类型（rec_lock_type），使用其余的位来表示。只有在lock_type的值为</p><ul><li>LOCK_REC时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：</li><li>LOCK_ORDINARY（十进制的 0 ）：表示next-key锁。</li><li>LOCK_GAP（十进制的 512 ）：也就是当第 10 个比特位置为 1 时，表示gap锁。</li><li>LOCK_REC_NOT_GAP（十进制的 1024 ）：也就是当第 11 个比特位置为 1 时，表示正经记录锁。</li><li>LOCK_INSERT_INTENTION（十进制的 2048 ）：也就是当第 12 个比特位置为 1 时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li></ul></li><li><p>is_waiting属性呢？基于内存空间的节省，所以把is_waiting属性放到了type_mode这个 32位的数字中：</p><ul><li>LOCK_WAIT（十进制的 256 ） ：当第 9 个比特位置为 1 时，表示is_waiting为true，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示is_waiting为false，也就是当前事务获取锁成功。</li></ul></li></ul><ol start="5"><li>其他信息：<br> 为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</li><li>一堆比特位：<br> 如果是行锁结构的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的n_bits属性表示的。InnoDB数据页中的每条记录在记录头信息中都包含一个heap_no属性，伪记录Infimum的heap_no值为 0 ，Supremum的heap_no值为 1 ，之后每插入一条记录，heap_no值就增 1 。锁结构最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个heap_no，即一个比特位映射到页内的一条记录。</li></ol><h3 id="5-锁监控"><a href="#5-锁监控" class="headerlink" title="5. 锁监控"></a>5. 锁监控</h3><p>关于MySQL锁的监控，我们一般可以通过检查<code>InnoDB_row_lock</code>等状态变量来分析系统上的行锁的争夺情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                 <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_current_waits <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_time          <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_time_avg      <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_time_max      <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_waits         <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+-------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p><strong>对各个状态量的说明如下：</strong></p><ul><li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li><li><code>Innodb_row_lock_time</code>：从系统启动到现在锁定总时间长度；（等待总时长）</li><li><code>Innodb_row_lock_time_avg</code>：每次等待所花平均时间；（等待平均时长）</li><li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</li><li><code>Innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数；（等待总次数）</li></ul><p><strong>其他监控方法：</strong><br>MySQL把事务和锁的信息记录在了<code>information_schema库</code>中，涉及到的三张表分别是<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>。</p><p>MySQL5.7及之前，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。</p><p>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了<code>performance_schema.data_locks</code>，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，<code>performance_schema.data_locks</code>不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p><p>同时，<code>information_schema.INNODB_LOCK_WAITS</code>也被<code>performance_schema.data_lock_waits</code>所代替。</p><h2 id="十四、多版本并发控制"><a href="#十四、多版本并发控制" class="headerlink" title="十四、多版本并发控制"></a>十四、多版本并发控制</h2><h3 id="1-什么是-MVCC"><a href="#1-什么是-MVCC" class="headerlink" title="1. 什么是 MVCC"></a>1. 什么是 MVCC</h3><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的<code>并发控制</code>。这项技术使得在InnoDB的事务<a href="https://so.csdn.net/so/search?q=%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB&spm=1001.2101.3001.7020">隔离级别</a>下执行<code>一致性读</code>操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</p><p>MVCC没有正式的标准，在不同的DBMS中MVCC的实现方式可能是不同的，也不是普遍使用的(大家可以参考相关的DBMS文档)。这里讲解InnoDB 中MVCC的实现机制（MySQL其它的存储引擎并不支持它)。</p><h3 id="2-快照读与当前读"><a href="#2-快照读与当前读" class="headerlink" title="2. 快照读与当前读"></a>2. 快照读与当前读</h3><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理<code>读-写</code>冲突，做到即使有读写冲突时，也能做到<code>不加锁，非阻塞并发读</code>，而这个读指的就是<code>快照读</code>, 而非当前读。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p><h4 id="2-1-快照读"><a href="#2-1-快照读" class="headerlink" title="2.1 快照读"></a>2.1 快照读</h4><p>快照读又叫一致性读，读取的是快照数据。 <strong>不加锁的简单的 SELECT 都属于快照读</strong> ，即不加锁的非阻塞读；比如这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure><p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。</p><p>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</p><p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p><h4 id="2-2-当前读"><a href="#2-2-当前读" class="headerlink" title="2.2 当前读"></a>2.2 当前读</h4><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前读。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LOCK <span class="keyword">IN</span> SHARE MODE;  # 共享锁</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; # 排他锁</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span> ...  # 排他锁</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> ...  # 排他锁</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> ...  # 排他锁</span><br></pre></td></tr></table></figure><h3 id="3-复习"><a href="#3-复习" class="headerlink" title="3. 复习"></a>3. 复习</h3><h4 id="3-1-再谈隔离级别"><a href="#3-1-再谈隔离级别" class="headerlink" title="3.1 再谈隔离级别"></a>3.1 再谈隔离级别</h4><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：</p><img src="http://1.117.162.142:9000/blog/image-20230131142926434.png" alt="image-20230131142926434" style="zoom:50%;" /><p>在MySQL中，默认的隔离级别是可重复读，可以解决脏读和不可重复读的问题，如果仅从定义的角度来看，它并不能解决<a href="https://so.csdn.net/so/search?q=%E5%B9%BB%E8%AF%BB&spm=1001.2101.3001.7020">幻读</a>问题。如果我们想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力。</p><p>MVCC 可以不采用锁机制，而是通过乐观锁的方式来解决不可重复读和幻读问题!它可以在大多数情况下替代行级锁，降低系统的开销。</p><img src="http://1.117.162.142:9000/blog/image-20230131143022253.png" alt="image-20230131143022253" style="zoom:50%;" /><h4 id="3-2-隐藏字段、Undo-Log版本链"><a href="#3-2-隐藏字段、Undo-Log版本链" class="headerlink" title="3.2 隐藏字段、Undo Log版本链"></a>3.2 隐藏字段、Undo Log版本链</h4><p>回顾一下undo日志的版本链，对于使用<code>InnoDB</code>存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列(字段)。</p><ul><li><code>trx_id</code>：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。</li><li><code>roll_pointer</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到<code>undo日志</code>中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><p>举例：student 表数据如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> class  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 张三   <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>假设插入该记录的事务id为8，那么此刻该条记录的示意图如下所示:</p><img src="http://1.117.162.142:9000/blog/image-20230131143159781.png" alt="image-20230131143159781" style="zoom:50%;" /><blockquote><p>insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的UndoLog Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。</p></blockquote><p>假设之后两个事务id分别为 10 、 20 的事务对这条记录进行UPDATE操作，操作流程如下：</p><table><thead><tr><th align="center">发生时间顺序</th><th align="center">事务10</th><th align="center">事务20</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">BEGIN;</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center"></td><td align="center">BEGIN;</td></tr><tr><td align="center">3</td><td align="center">UPDATE student SET name&#x3D;“李四” WHERE id&#x3D;1;</td><td align="center"></td></tr><tr><td align="center">4</td><td align="center">UPDATE student SET name&#x3D;“王五” WHERE id&#x3D;1;</td><td align="center"></td></tr><tr><td align="center">5</td><td align="center">COMMIT;</td><td align="center"></td></tr><tr><td align="center">6</td><td align="center"></td><td align="center">UPDATE student SET name&#x3D;“钱七” WHERE id&#x3D;1;</td></tr><tr><td align="center">7</td><td align="center"></td><td align="center">UPDATE student SET name&#x3D;“宋八” WHERE id&#x3D;1;</td></tr><tr><td align="center">8</td><td align="center"></td><td align="center">COMMIT;</td></tr></tbody></table><blockquote><p>能不能在两个事务中交叉更新同一条记录呢?不能!这不就是一个事务修改了另一个未提交事务修改过的数据，脏写。<br>InnoDB使用锁来保证不会有脏写情况的发生，也就是在第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。</p></blockquote><p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个<code>roll_pointer</code>属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些<code>undo日志</code>都连起来，串成一个链表：</p><img src="http://1.117.162.142:9000/blog/image-20230131143518958.png" alt="image-20230131143518958" style="zoom:50%;" /><p>对该记录每次更新后，都会将旧值放到一条<code>undo日志</code>中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被<code>roll_pointer</code>属性连接成一个链表，我们把这个链表称之为<code>版本链</code>，版本链的头节点就是当前记录最新的值。</p><p>每个版本中还包含生成该版本时对应的<code>事务id</code>。</p><h3 id="4-MVCC实现原理之ReadView"><a href="#4-MVCC实现原理之ReadView" class="headerlink" title="4. MVCC实现原理之ReadView"></a>4. MVCC实现原理之ReadView</h3><p>MVCC 的实现依赖于： <code>隐藏字段</code>、<code>Undo Log</code>、<code>Read View</code> 。</p><h4 id="4-1-什么是ReadView"><a href="#4-1-什么是ReadView" class="headerlink" title="4.1 什么是ReadView"></a>4.1 什么是ReadView</h4><p>在MVCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在Undo Log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢?这时就需要用到ReadView了，它帮我们解决了行的可见性问题。</p><p>ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前<code>活跃事务的ID</code>(“活跃”指的就是，启动了但还没提交)。</p><h4 id="4-2-设计思路"><a href="#4-2-设计思路" class="headerlink" title="4.2 设计思路"></a>4.2 设计思路</h4><p>使用<code>READ UNCOMMITTED</code>隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</p><p>使用<code>SERIALIZABLE</code>隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p><p>使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务，都必须保证读到已经提交了的事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p><p>这个ReadView中主要包含 4 个比较重要的内容，分别如下：</p><ol><li><p><code>creator_trx_id</code>，创建这个 Read View 的事务 ID。</p><blockquote><p>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为 0 。</p></blockquote></li><li><p><code>trx_ids</code>，表示在生成ReadView时当前系统中活跃的读写事务的<code>事务id列表</code>。</p></li><li><p><code>up_limit_id</code>，活跃的事务中最小的事务 ID。</p></li><li><p><code>low_limit_id</code>，表示生成ReadView时系统中应该分配给下一个事务的<code>id</code>值。<code>low_limit_id </code>是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID</p><blockquote><p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为 1 ，2 ， 3 这三个事务，之后id为 3 的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括 1 和 2 ，up_limit_id的值就是 1 ，low_limit_id的值就是 4 。</p></blockquote></li></ol><p>举例:</p><p>trx_ids为tr2、tr3、tr:5和trx8的集合，系统的最大事务ID (low_limit_id)为trx8+1(如果之前没有其他的新增事务)，活跃的最小事务ID (up_limit_id)为trx2。</p><img src="http://1.117.162.142:9000/blog/image-20230131143947011.png" alt="image-20230131143947011" style="zoom:50%;" /><h4 id="4-3-ReadView的规则"><a href="#4-3-ReadView的规则" class="headerlink" title="4.3 ReadView的规则"></a>4.3 ReadView的规则</h4><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p><ul><li><p>如果被访问版本的trx_id属性值与ReadView中的<code>creator_trx_id</code>值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</p></li><li><p>如果被访问版本的trx_id属性值小于ReadView中的<code>up_limit_id</code>值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</p></li><li><p>如果被访问版本的trx_id属性值大于或等于ReadView中的<code>low_limit_id</code>值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</p></li><li><p>如果被访问版本的trx_id属性值在ReadView的<code>up_limit_id</code>和<code>low_limit_id</code>之间，那就需要判断一下trx_id属性值是不是在trx_ids列表中。</p><ul><li><p>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</p></li><li><p>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</p></li></ul></li></ul><h4 id="4-4-MVCC整体操作流程"><a href="#4-4-MVCC整体操作流程" class="headerlink" title="4.4 MVCC整体操作流程"></a>4.4 MVCC整体操作流程</h4><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p><ul><li>首先获取事务自己的版本号，也就是事务 ID；</li><li>生成 ReadView；</li><li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li><li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</li><li>最后返回符合规则的数据。</li></ul><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p><blockquote><p>lnnoDB中，MVCC是通过Undo Log + Read View进行数据读取，Undo Log保存了历史快照，而Read View规则帮我们判断当前版本的数据是否可见。</p></blockquote><p>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次Read View。</p><table><thead><tr><th align="center">事务</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">begin;</td><td align="center"></td></tr><tr><td align="center">select * from student where id &gt;2;</td><td align="center">获取一次Read View</td></tr><tr><td align="center">…</td><td align="center"></td></tr><tr><td align="center">select * from student where id &gt;2;</td><td align="center">获取一次Read View</td></tr><tr><td align="center">commit;</td><td align="center"></td></tr></tbody></table><blockquote><p>注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。</p></blockquote><p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：</p><img src="http://1.117.162.142:9000/blog/image-20230131144258799.png" alt="image-20230131144258799" style="zoom:50%;" /><h3 id="5-举例说明"><a href="#5-举例说明" class="headerlink" title="5 举例说明"></a>5 举例说明</h3><p>假设现在 student 表中只有一条由事务ID为 8 的事务插入的一条记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span><span class="keyword">from</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> class  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 张三   <span class="operator">|</span> 一班   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+--------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>MVCC只能在 read committed 和repeatable read 两个隔离级别下工作。接下来看一下 read committed 和repeatable read 所谓的生成readview 的时机不同到底不同在哪里</p><h4 id="5-1-READ-COMMITTED-隔离级别下"><a href="#5-1-READ-COMMITTED-隔离级别下" class="headerlink" title="5.1 READ COMMITTED 隔离级别下"></a>5.1 READ COMMITTED 隔离级别下</h4><p><strong>READ COMMITTED ：每次读取数据前都生成一个ReadView 。</strong><br>现在有两个事务id分别为 10 、 20 的事务在执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br></pre></td></tr></table></figure><blockquote><p>说明:事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句)，才会被<br>分配一个单独的事务id，这个事务id是递增的。所以我们才在事务2中更新些别的表的记录，目的是让它分<br>配事务id。</p></blockquote><p>此刻，表 student中id为1的记录得到的版本链表如下所示：</p><img src="http://1.117.162.142:9000/blog/image-20230131144803904.png" alt="image-20230131144803904" style="zoom:50%;" /><p>假设现在有一个使用READ COMMITTED隔离级别的事务开始执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、 <span class="number">20</span> 未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> ; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure><p>这个SELECT1的执行过程如下:</p><p>步骤1: 在执行SELECT语句时会先生成一个<code>ReadView</code> , ReadView的<code> trx_ids列表</code>的内容就是<code>[10，20]</code>，<code>up_limit_id为10</code>, <code>low_limit_id为21</code>, <code>creator_trx_id为0</code>。</p><p>步骤2:从版本链中挑选可见的记录，从图中看出，最新版本的列<code>name</code>的内容是<code>’王五’</code>，该版本的<code>trx_id</code>值为<code>10</code>，在<code>trx_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</p><p>步骤3:下一个版本的列<code>name</code>的内容是’李四’，该版本的<code>trx_id</code>值也为<code>10</code>，也在<code>trx_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</p><p>步骤4:下一个版本的列name的内容是’张三’，该版本的<code>trx_id</code>值为<code>8</code>，小于<code>ReadView</code>中的<code>up_limit_id</code>值<code>10</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘张三’的记录。</p><p>之后，我们把事务id为 10 的事务提交一下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>然后再到事务id为 20 的事务中更新一下表student中id为 1 的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;钱七&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;宋八&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br></pre></td></tr></table></figure><p>此刻，表student中id为 1 的记录的版本链就长这样：</p><p><img src="http://1.117.162.142:9000/blog/image-20230131144953806.png" alt="image-20230131144953806"></p><p>然后再到刚才使用READ COMMITTED隔离级别的事务中继续查找这个id为 1 的记录，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、 <span class="number">20</span> 均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> ; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction <span class="number">10</span>提交，Transaction <span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> ; # 得到的列name的值为<span class="string">&#x27;王五&#x27;</span></span><br></pre></td></tr></table></figure><p>这个<code>SELECT2</code>的执行过程如下:</p><p>步骤1:在执行<code>SELECT</code>语句时会又会单独生成一个<code>ReadView</code>，该<code>ReadView的trx_ids列表</code>的内容就是<code>[20],up_limitid为.20,low_limit_id为21, creator_trx_id为0。</code></p><p>步骤2:从版本链中挑选可见的记录，从图中看出，最新版本的列name的内容是‘宋八‘，该版本的trx_id值为20，在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</p><p>步骤3:下一个版本的列name的内容是‘钱七’，该版本的trx_id值为28，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。</p><p>步骤4:下一个版本的列name的内容是’王五’，该版本的trx_id值为10，小于ReadView中的up_limit_id值20，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘王五‘的记录。</p><p>以此类推，如果之后事务id为20的记录也提交了，再次在使用READ COMMITTED隔离级别的事务中查询表student中id值为1的记录时，得到的结果就是‘宋八’了，具体流程我们就不分析了。</p><blockquote><p>强调: 使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p></blockquote><h4 id="5-2-REPEATABLE-READ隔离级别下"><a href="#5-2-REPEATABLE-READ隔离级别下" class="headerlink" title="5.2 REPEATABLE READ隔离级别下"></a>5.2 REPEATABLE READ隔离级别下</h4><p>使用<code>REPEATABLE READ</code>隔离级别的事务来说，<code>只会在第一次</code>执行查询语句时生成一个<code>ReadView</code>，之后的查询就不会重复生成了。</p><p>比如，系统里有两个事务id分别为 10 、 20 的事务在执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此刻，表student 中id为 1 的记录得到的版本链表如下所示：</p><img src="http://1.117.162.142:9000/blog/image-20230131145345166.png" alt="image-20230131145345166" style="zoom:50%;" /><p>假设现在有一个使用<code>REPEATABLE READ</code>隔离级别的事务开始执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、 <span class="number">20</span> 未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> ; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure><p>这个SELECT1的执行过程如下（第一个ReadView和读已提交是一样的):</p><p>步骤1: 在执行SELECT语句时会先生成一个ReadView , ReadView的<code>trx_ids</code>列表的内容就是<code>[10，20]</code>，<code>up_limit_id为10</code>, <code>low_limit_id为21</code>, <code>creator_trx_id为0</code>。</p><p>步骤2:从版本链中挑选可见的记录，从图中看出，最新版本的列name的内容是’王五’，该版本的trx_id值为10，在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</p><p>步骤3:下一个版本的列name的内容是’李四’，该版本的trx_id值也为10，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。</p><p>步骤4:下一个版本的列name的内容是’张三’，该版本的trx_id值为8，小于ReadView中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为‘张三’的记录。</p><p>之后，我们把事务id为 10 的事务提交一下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>然后再到事务id为 20 的事务中更新一下表student中id为 1 的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;钱七&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;宋八&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span> <span class="number">1</span> ;</span><br></pre></td></tr></table></figure><p>此刻，表student 中id为 1 的记录的版本链长这样：</p><img src="http://1.117.162.142:9000/blog/image-20230131145607213.png" alt="image-20230131145607213" style="zoom:50%;" /><p>然后再到刚才使用REPEATABLE READ隔离级别的事务中继续查找这个id为 1 的记录，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、 <span class="number">20</span> 均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> ; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction <span class="number">10</span>提交，Transaction <span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> ; # 得到的列name的值仍为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure><p>这个<code>SELECT2</code>的执行过程如下:</p><p>步骤1: 因为当前事务的隔离级别为 <code>REPEATABLE READ</code>，而之前在执行 <code>SELECT1</code>时已经生成过<code>ReadView</code>了，所以此时直接复用之前的<code>ReadView</code>，之前的<code>ReadView</code>的<code>trx_ids</code>列表的内容就是<code>[10，20]</code>，<code>up_limit_id</code>为<code>10</code>, <code>low_limit_id</code>为<code>21</code>, <code>creator_trx_id</code>为<code>0</code>。</p><p>步骤2:然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>name</code>的内容是<code>宋八</code>，该版本的<code>trx_id</code>值为<code>20</code>，在<code>trx_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</p><p>步骤3:下一个版本的列<code>name</code>的内容是<code>’钱七’</code>，该版本的<code>trx_id</code>值为<code>20</code>，也在<code>trx_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</p><p>步骤4∶下一个版本的列<code>name</code>的内容是<code>’王五’</code>，该版本的<code>trx_id</code>值为<code>10</code>，而<code>trx_ids</code>列表中是包含值为<code>10</code>的<code>事务id``的，所以该版本也不符合要求，同理下一个列</code>name<code>的内容是</code>’李四’&#96;的版本也不符合要求。继续跳到下一个版本。</p><p>步骤5∶下一个版本的列<code>name</code>的内容是<code>‘张三’</code>，该版本的<code>trx_id</code>值为<code>80</code>，小于<code>ReadView</code>中的<code>up_limit_id</code>值<code>10</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>c</code>为<code>‘张三’</code>的记录。</p><p>两次<code>SELECT</code>查询得到的结果是重复的，记录的列<code>c</code>值都是<code>‘张三’</code>，这就是<code>可重复读</code>的含义。如果我们之后再把<code>事务id</code>为<code>20</code>的记录提交了，然后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个<code>id</code>为<code>1</code>的记录，得到的结果还是<code>‘张三’</code>，具体执行过程大家可以自己分析一下。</p><h4 id="5-3-如何解决幻读"><a href="#5-3-如何解决幻读" class="headerlink" title="5.3 如何解决幻读"></a>5.3 如何解决幻读</h4><p>接下来说明InnoDB 是如何解决幻读的。</p><p>假设现在表 student 中只有一条数据，数据内容中，主键 id&#x3D;1，隐藏的 trx_id&#x3D;10，它的 undo log 如下图所示。</p><img src="http://1.117.162.142:9000/blog/image-20230131150417858.png" alt="image-20230131150417858" style="zoom:50%;" /><p>假设现在有事务 A 和事务 B 并发执行，事务 A 的事务 id 为 20 ，事务 B 的事务 id 为 30 。</p><p>步骤 1 ：事务 A 开始第一次查询数据，查询的 SQL 语句如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">1</span> ;</span><br></pre></td></tr></table></figure><p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下：<code>trx_ids=[20,30]</code>，<code>up_limit_id=20</code>，<code>low_limit_id=31</code>，<code>creator_trx_id=20</code>。</p><p>由于此时表 student 中只有一条数据，且符合 where id&gt;&#x3D;1 条件，因此会查询出来。然后根据 ReadView机制，发现该行数据的trx_id&#x3D;10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p><p>结论：事务 A 的第一次查询，能读取到一条数据，id&#x3D;1。</p><p>步骤 2 ：接着事务 B(trx_id&#x3D;30)，往表 student 中新插入两条数据，并提交事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id,name) <span class="keyword">values</span>( <span class="number">2</span> ,<span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id,name) <span class="keyword">values</span>( <span class="number">3</span> ,<span class="string">&#x27;王五&#x27;</span>);</span><br></pre></td></tr></table></figure><p>此时表student 中就有三条数据了，对应的 undo 如下图所示：</p><img src="http://1.117.162.142:9000/blog/image-20230131150637422.png" alt="image-20230131150637422" style="zoom:50%;" /><p>步骤 3 ：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成ReadView。此时表 student 中的 3 条数据都满足 where id&gt;&#x3D;1 的条件，因此会先查出来。然后根据ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p><p>1 ）首先 id&#x3D;1 的这条数据，前面已经说过了，可以被事务 A 看到。</p><p>2 ）然后是 id&#x3D;2 的数据，它的 trx_id&#x3D;30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids&#x3D;[20,30]，因此在数组内，这表示 id&#x3D;2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</p><p>3 ）同理，id&#x3D;3 的这条数据，trx_id 也为 30 ，因此也不能被事务 A 看见。</p><p><img src="http://1.117.162.142:9000/blog/image-20230131150719757.png" alt="image-20230131150719757"></p><p>结论：最终事务 A 的第二次查询，只能查询出 id&#x3D;1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。</p><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>这里介绍了<code>MVCC</code>在<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事务的读-写、写-读操作并发执行，从而提升系统性能。</p><p>核心点在于 ReadView 的原理，<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两个隔离级别的一个很大不同就是生成ReadView的时机不同：</p><ul><li><code>READ COMMITTD</code>在每一次进行普通SELECT操作前都会生成一个ReadView</li><li><code>REPEATABLE READ</code>只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</li></ul><blockquote><p>说明: 我们之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除,而是执行一个所谓的delete mark操作，相当于只是对记录打上了一个删除标志位，这主要就是为MVCc服务的。</p></blockquote><p>通过MVCC我们可以解决:</p><ul><li><code>读写之间阻塞的问题。</code>通过MVCC可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。</li><li><code>降低了死锁的概率。</code>这是因为MVCC采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</li><li><code>解决快照读的问题。</code>当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</li></ul><h2 id="十五、其他数据库日志"><a href="#十五、其他数据库日志" class="headerlink" title="十五、其他数据库日志"></a>十五、其他数据库日志</h2><p>我们在讲解数据库事务时，讲过两种日志:<code>重做日志</code>、<code>回滚日志</code>。</p><p>对于线上数据库应用系统，突然遭遇数据库宕机怎么办?在这种情况下，定位宕机的原因就非常关键。我们可以查看数据库的错误日志。因为日志中记录了数据库运行中的诊断信息，包括了错误、警告和注释等信息。比如:从日志中发现某个连接中的SQL操作发生了死循环，导致内存不足，被系统强行终止了。明确了原因，处理起来也就轻松了，系统很快就恢复了运行。</p><p>除了发现错误，日志在数据复制、数据恢复、操作审计，以及确保数据的永久性和一致性等方面，都有着不可替代的作用。</p><p>千万不要小看日志 。很多看似奇怪的问题，答案往往就藏在日志里。很多情况下，只有通过查看日志才能发现问题的原因，真正解决问题。所以，一定要学会查看日志，养成检查日志的习惯，对提升你的数据库应用开发能力至关重要。</p><p>MySQL8.0 官网日志地址：<a href="https://dev.mysql.com/doc/refman/8.0/en/server-logs.html">https://dev.mysql.com/doc/refman/8.0/en/server-logs.html</a></p><h3 id="1-MySQL支持的日志"><a href="#1-MySQL支持的日志" class="headerlink" title="1. MySQL支持的日志"></a>1. MySQL支持的日志</h3><h4 id="1-1-日志类型"><a href="#1-1-日志类型" class="headerlink" title="1.1 日志类型"></a>1.1 日志类型</h4><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为<code>二进制日志</code>、<code>错误日志</code>、<code>通用查询日志</code>和<code>慢查询日志</code>，这也是常用的 4 种。MySQL 8又新增两种支持的日志：<code>中继日志</code>和<code>数据定义语句日志</code>。使用这些日志文件，可以查看MySQL内部发生的事情。</p><p><strong>这 6 类日志分别为：</strong></p><ul><li><p><code>慢查询日志： </code>记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</p></li><li><p><code>通用查询日志： </code>记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</p></li><li><p><code>错误日志：</code> 记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。<code>二进制日志：</code> 记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。</p></li><li><p><code>中继日志： </code>用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。</p></li><li><p><code>数据定义语句日志：</code> 记录数据定义语句执行的元数据操作。</p></li></ul><p>除二进制日志外，其他日志都是<code>文本文件</code>。默认情况下，所有日志创建于<code>MySQL数据目录</code>中。</p><h4 id="1-2-日志的弊端"><a href="#1-2-日志的弊端" class="headerlink" title="1.2 日志的弊端"></a>1.2 日志的弊端</h4><ul><li>日志功能会<code>降低MySQL数据库的性能</code>。例如，在查询非常频繁的MysQL数据库系统中，如果开启了通用查询日志和慢查询日志，MySQL数据库会花费很多时间记录日志。</li><li>日志会<code>占用大量的磁盘空间</code>。对于用户量非常大、操作非常频繁的数据库,日志文件需要的存储空间设置比数据库文件需要的存储空间还要大。</li></ul><h3 id="2-慢查询日志（show-query-log）"><a href="#2-慢查询日志（show-query-log）" class="headerlink" title="2. 慢查询日志（show query log）"></a>2. 慢查询日志（show query log）</h3><p>性能分析工具的使用已经讲过。</p><h3 id="3-通用查询日志（general-query-log）"><a href="#3-通用查询日志（general-query-log）" class="headerlink" title="3. 通用查询日志（general query log）"></a>3. 通用查询日志（general query log）</h3><p>通用查询日志用来<code>记录用户的所有操作</code>，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时， <strong>查看通用查询日志，还原操作时的具体场景</strong> ，可以帮助我们准确定位问题。</p><h4 id="3-1-问题场景"><a href="#3-1-问题场景" class="headerlink" title="3.1 问题场景"></a><strong>3.1 问题场景</strong></h4><p>在电商系统中，购买商品并且使用微信支付完成以后，却发现支付中心的记录并没有新增，此时用户再次使用支付宝支付，就会出现重复支付的问题。但是当去数据库中查询数据的时候，会发现只有一条记录存在。那么此时给到的现象就是只有一条支付记录，但是用户却支付了两次。</p><p>我们对系统进行了仔细检查，没有发现数据问题，因为用户编号和订单编号以及第三方流水号都是对的。可是用户确实支付了两次，这个时候，我们想到了检查通用查询日志，看看当天到底发生了什么。</p><p>查看之后，发现: 1月1日下午2点，用户使用微信支付完以后，但是由于网络故障，支付中心没有及时收到微信支付的回调通知，导致当时没有写入数据。1月1日下午2点30，用户又使用支付宝支付，此时记录更新到支付中心。1月1日晚上9点，微信的回调通知过来了，但是支付中心已经存在了支付宝的记录，所以只能覆盖记录了。</p><h4 id="3-2-查看当前状态"><a href="#3-2-查看当前状态" class="headerlink" title="3.2 查看当前状态"></a>3.2 查看当前状态</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> general_log <span class="operator">|</span> OFF <span class="operator">|</span> #通用查询日志处于关闭状态</span><br><span class="line"><span class="operator">|</span> general_log_file <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu01.log <span class="operator">|</span> #通用查询日志文件的名称是atguigu01.log</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure><h4 id="3-3-启动日志"><a href="#3-3-启动日志" class="headerlink" title="3.3 启动日志"></a>3.3 启动日志</h4><p><strong>方式 1 ：永久性方式</strong></p><p>修改my.cnf或者my.ini配置文件来设置。在[mysqld]组下加入log选项，并重启MySQL服务。格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">general_log<span class="operator">=</span><span class="keyword">ON</span></span><br><span class="line">general_log_file<span class="operator">=</span>[path[filename]] #日志文件所在目录路径，filename为日志文件名</span><br></pre></td></tr></table></figure><p>如果不指定目录和文件名，通用查询日志将默认存储在MySQL数据目录中的hostname.log文件中，hostname表示主机名。</p><p><strong>方式 2 ：临时性方式</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log<span class="operator">=</span><span class="keyword">on</span>;  # 开启通用查询日志</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log_file<span class="operator">=</span><span class="string">&#x27;path/filename&#x27;</span>; # 设置日志文件保存位置</span><br></pre></td></tr></table></figure><p>对应的，关闭操作SQL命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log<span class="operator">=</span>off;  # 关闭通用查询日志</span><br></pre></td></tr></table></figure><p>查看设置后情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;general_log%&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="3-4-查看日志"><a href="#3-4-查看日志" class="headerlink" title="3.4 查看日志"></a>3.4 查看日志</h4><p>通用查询日志是以文本文件的形式存储在文件系统中的，可以使用文本编辑器直接打开日志文件。每台MySQL服务器的通用查询日志内容是不同的。</p><ul><li>在Windows操作系统中，使用文本文件查看器；</li><li>在Linux系统中，可以使用vi工具或者gedit工具查看；</li><li>在Mac OSX系统中，可以使用文本文件查看器或者vi等工具查看。</li></ul><p>从<code>SHOW VARIABLES LIKE &#39;general_log%&#39;;</code>结果中可以看到通用查询日志的位置。</p><p>在通用查询日志里面，我们可以清楚地看到，什么时候开启了新的客户端登陆数据库，登录之后做了什么 SQL 操作，针对的是哪个数据表等信息。</p><h4 id="3-5-停止日志"><a href="#3-5-停止日志" class="headerlink" title="3.5 停止日志"></a>3.5 停止日志</h4><p><strong>方式 1 ：永久性方式</strong></p><p>修改my.cnf或者my.ini文件，把[mysqld]组下的general_log值设置为OFF或者把general_log一项注释掉。修改保存后，再重启MySQL服务，即可生效。<br><strong>举例 1 ：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">general_log<span class="operator">=</span>OFF</span><br></pre></td></tr></table></figure><p><strong>举例 2 ：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#general_log<span class="operator">=</span><span class="keyword">ON</span></span><br></pre></td></tr></table></figure><p><strong>方式 2 ：临时性方式</strong></p><p>使用SET语句停止MySQL通用查询日志功能：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log<span class="operator">=</span>off;</span><br></pre></td></tr></table></figure><p>查询通用日志功能：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;general_log%&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="3-6-删除-刷新日志"><a href="#3-6-删除-刷新日志" class="headerlink" title="3.6 删除\刷新日志"></a>3.6 删除\刷新日志</h4><p>如果数据的使用非常频繁，那么通用查询日志会占用服务器非常大的磁盘空间。数据管理员可以删除很长时间之前的查询日志，以保证MySQL服务器上的硬盘空间。</p><p><strong>手动删除文件</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;general_log%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以看出，通用查询日志的目录默认为MySQL数据目录。在该目录下手动删除通用查询日志atguigu 01 .log。</p><p>使用如下命令重新生成查询日志文件，具体命令如下。刷新MySQL数据目录，发现创建了新的日志文件。前提一定要开启通用日志。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p flush<span class="operator">-</span>logs</span><br></pre></td></tr></table></figure><h3 id="4-错误日志-error-log"><a href="#4-错误日志-error-log" class="headerlink" title="4. 错误日志(error log)"></a>4. 错误日志(error log)</h3><p>错误日志记录了 MySQL 服务器启动、停止运行的时间，以及系统启动、运行和停止过程中的诊断信息，包括错误、警告和提示等。</p><p>通过错误日志可以查看系统的运行状态，便于及时发现故障。如果 MySQL 服务出现异常，错误日志是发现问题、解决故障的首选。</p><h4 id="4-1-启动日志"><a href="#4-1-启动日志" class="headerlink" title="4.1 启动日志"></a>4.1 启动日志</h4><p>在MySQL数据库中，错误日志功能是默认开启的。而且，错误日志无法被禁止。</p><p>默认情况下，错误日志存储在MySQL数据库的数据文件夹下，名称默认为mysqld.log（Linux系统）或hostname.err（mac系统）。如果需要制定文件名，则需要在my.cnf或者my.ini中做如下配置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log<span class="operator">-</span>error<span class="operator">=</span>[path<span class="operator">/</span>[filename]] #path为日志文件所在的目录路径，filename为日志文件名</span><br></pre></td></tr></table></figure><p>修改配置项后，需要重启MySQL服务以生效。</p><h4 id="4-2-查看日志"><a href="#4-2-查看日志" class="headerlink" title="4.2 查看日志"></a>4.2 查看日志</h4><p>MySQL错误日志是以文本文件形式存储的，可以使用文本编辑器直接查看。查询错误日志的存储路径：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;log_err%&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="4-3-删除-刷新日志"><a href="#4-3-删除-刷新日志" class="headerlink" title="4.3 删除\刷新日志"></a>4.3 删除\刷新日志</h4><p>对于很久以前的错误日志，数据库管理员查看这些错误日志的可能性不大，可以将这些错误日志删除，以保证MySQL服务器上的硬盘空间。MySQL的错误日志是以文本文件的形式存储在文件系统中的，可以直接删除。</p><ul><li><p>第一步(方式一)：删除操作</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm <span class="operator">-</span>rf <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>mysqld.log</span><br></pre></td></tr></table></figure><p>  在运行状态下删除错误日志文件后，MySQL并不会自动创建日志文件。</p></li><li><p>第一步(方式二)：重命名文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> /var/log/mysqld.log /var/log/mysqld.log.old</span><br></pre></td></tr></table></figure></li><li><p>第二步：重建日志</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u root -p flush-logs</span><br></pre></td></tr></table></figure><p>  可能会报错：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#刷新日志</span><br><span class="line">[root<span class="variable">@kaito</span> log]# mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p flush<span class="operator">-</span>logs</span><br><span class="line">Enter password:</span><br><span class="line">mysqladmin: refresh failed; error: <span class="string">&#x27;Could not open file &#x27;</span><span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysqld.log<span class="string">&#x27; for error logging.&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  官网提示：</p>  <img src="http://1.117.162.142:9000/blog/image-20230131164521763.png" alt="image-20230131164521763" style="zoom:50%;" /></li></ul><p>补充操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install <span class="operator">-</span>omysql <span class="operator">-</span>gmysql <span class="operator">-</span>m0644 <span class="operator">/</span>dev<span class="operator">/</span><span class="keyword">null</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysqld.log</span><br></pre></td></tr></table></figure><p>·flush-logs·指令操作：</p><ul><li>MySQL5.5.7以前的版本，flush-logs将错误日志文件重命名为filename.err_old,并创建新的日志文件。</li><li>从MySQL5.5.7开始，flush-logs只是重新打开日志文件，并不做日志备份和创建的操作。</li><li>如果日志文件不存在，MySQL启动或者执行flush-logs时会自动创建新的日志文件。重新创建错误日志，大小为0字节。</li></ul><h3 id="5-二进制日志-bin-log"><a href="#5-二进制日志-bin-log" class="headerlink" title="5. 二进制日志(bin log)"></a>5. 二进制日志(bin log)</h3><p>binlog可以说是MySQL中<code>比较重要</code>的日志了，在日常开发及运维过程中，经常会遇到。</p><p>binlog即binary log，二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的DDL和DML等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、show等）。</p><p>它以<code>事件形式</code>记录并保存在<code>二进制文件</code>中。通过这些信息，我们可以再现数据更新操作的全过程。</p><blockquote><p>如果想要记录所有语句（例如，为了识别有问题的查询)，需要使用通用查询日志。</p></blockquote><p><strong>binlog主要应用场景：</strong></p><ul><li>一是用于<code>数据恢复</code>，如果MySQL数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器。</li><li>二是用于<code>数据复制</code>，由于日志的延续性和时效性，master把它的二进制日志传递给slaves来达到master-slave数据一致的目的。</li></ul><p>可以说MySQL<strong>数据库的数据备份、主备、主主、主从</strong>都离不开binlog,需要依靠binlog来同步数据，保证数据一致性。</p><img src="http://1.117.162.142:9000/blog/image-20230131165050932.png" alt="image-20230131165050932" style="zoom:50%;" /><h4 id="5-1-查看默认情况"><a href="#5-1-查看默认情况" class="headerlink" title="5.1 查看默认情况"></a>5.1 查看默认情况</h4><p>查看记录二进制日志是否开启：在MySQL8中默认情况下，二进制文件是开启的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                   <span class="operator">|</span> <span class="keyword">Value</span>                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> log_bin                         <span class="operator">|</span> <span class="keyword">ON</span>                          <span class="operator">|</span>  <span class="operator">/</span><span class="operator">/</span>开关</span><br><span class="line"><span class="operator">|</span> log_bin_basename                <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>binlog       <span class="operator">|</span> <span class="operator">/</span><span class="operator">/</span> 存放路径</span><br><span class="line"><span class="operator">|</span> log_bin_index                   <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>binlog.index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_trust_function_creators <span class="operator">|</span> <span class="keyword">ON</span>                          <span class="operator">|</span><span class="operator">/</span><span class="operator">/</span>  函数创建 </span><br><span class="line"><span class="operator">|</span> log_bin_use_v1_row_events       <span class="operator">|</span> OFF                         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sql_log_bin                     <span class="operator">|</span> <span class="keyword">ON</span>                          <span class="operator">|</span><span class="operator">/</span><span class="operator">/</span>变更<span class="keyword">sql</span>记录下来</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+-----------------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><ul><li><p><code>log_bin_basename:</code>是binlog日志的基本文件名，后面会追加标识来表示每一个文件</p></li><li><p><code>log_bin_index:</code>是binlog文件的素引文件，这个文件管理了所有的binlog文件的目录</p></li><li><p><code>log_bin_trust_function_creators:</code>限制存储过程，前面我们已经讲过了，这是因为二进制日志的一个重要功能是用于主从复制，而存储函数有可能导致主从的数据不一致。所以当开启二进制日志后，需要限制存储函数的创建、修改、调用。</p></li><li><p><code>log_bin_use_v1_row_events此只读系统变量已弃用</code>。ON表示使用版本1二进制日志行，OFF表示使用版本2二进制日志行（MySQL5.6的默认值为2)。</p></li></ul><h4 id="5-2-日志参数设置"><a href="#5-2-日志参数设置" class="headerlink" title="5.2 日志参数设置"></a>5.2 日志参数设置</h4><p><strong>方式 1 ：永久性方式</strong></p><p>修改MySQL的my.cnf或my.ini文件可以设置二进制日志的相关参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#启用二进制日志</span><br><span class="line">log<span class="operator">-</span>bin<span class="operator">=</span>atguigu<span class="operator">-</span>bin</span><br><span class="line">binlog_expire_logs_seconds<span class="operator">=</span> <span class="number">600</span></span><br><span class="line">max_binlog_size<span class="operator">=</span><span class="number">100</span>M</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示:</strong></p><ol><li>log-bin&#x3D;mysql-bin #打开日志(主机需要打开)，这个mysql-bin也可以自定义，这里也可以加上路径，如:&#x2F;home&#x2F;www&#x2F;mysql_bin_log&#x2F;mysql-bin</li><li>binlog_expire_logs_seconds:此参数控制二进制日志文件保留的时长单位是秒，默认2592000 30天 –14400 4小时;86400 1天; 259200 3天;</li><li>max_binlog_size:控制单个二进制日志大小，当前日志文件大小超过此变量时，执行切换动作。此参数的<code>最大和默认值是1GB</code>，该设置并<code>不能严格控制Binlog的大小</code>，尤其是Binlog比较靠近最大值而又遇到一个比较大事务时，为了保证事务的完整性，可能不做切换日志的动作只能将该事务的所有SQL都记录进当前日志，直到事务结束。一般情况下可采取默认值。</li></ol></blockquote><p><strong>设置带文件夹的bin-log日志存放目录</strong></p><p>如果想改变日志文件的目录和名称，可以对my.cnf或my.ini中的log_bin参数修改如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log<span class="operator">-</span>bin<span class="operator">=</span>&quot;/var/lib/mysql/binlog/atguigu-bin&quot;</span><br></pre></td></tr></table></figure><p>注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown <span class="operator">-</span>R <span class="operator">-</span>v mysql:mysql binlog</span><br></pre></td></tr></table></figure><blockquote><p>提示</p><p>数据库文件<code>最好不要与日志文件放在同一个磁盘上!</code>这样，当数据库文件所在的磁盘发生故障时，可以使用日志文件恢复数据。</p></blockquote><p><strong>方式 2 ：临时性方式</strong><br>如果不希望通过修改配置文件并重启的方式设置二进制日志的话，还可以使用如下指令，需要注意的是在mysql 8 中只有会话级别的设置，没有了global级别的设置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">global</span> 级别</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> sql_log_bin<span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">ERROR <span class="number">1228</span> (HY000): Variable <span class="string">&#x27;sql_log_bin&#x27;</span> <span class="keyword">is</span> a SESSION variable <span class="keyword">and</span> can`t be used</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">SET</span> <span class="keyword">GLOBAL</span></span><br><span class="line"></span><br><span class="line"># session级别</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> sql_log_bin <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> 秒)</span><br></pre></td></tr></table></figure><h4 id="5-3-查看日志"><a href="#5-3-查看日志" class="headerlink" title="5.3 查看日志"></a>5.3 查看日志</h4><p>当MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“.index”为后缀的文件，再创建一个以“filename”为名称、以“.000001”为后缀的文件。</p><p>MySQL服务重新启动一次，以“.000001”为后缀的文件就会增加一个，并且后缀名按 1 递增。即日志文件的数与MySQL服务启动的次数相同；如果日志长度超过了max_binlog_size的上限（默认是1GB），就会创建一个新的日志文件。</p><p>查看当前的二进制日志文件列表及大小。指令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Log_name           <span class="operator">|</span> File_size <span class="operator">|</span> Encrypted <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">156</span>       <span class="operator">|</span> <span class="keyword">No</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>所有对数据库的修改都会记录在binglog中。但binlog是二进制文件，无法直接查看，借助mysqlbinlog命令工具了。指令如下:在查看执行，先执行一条sQL语句，如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;张三_back&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">[root<span class="variable">@localhost</span> <span class="operator">~</span>]$ cd <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql</span><br><span class="line">[root<span class="variable">@localhost</span> <span class="operator">~</span>]$ mysqlbinlog  &quot;/var/lib/mysql/lqhdb-binlog.000001&quot;</span><br></pre></td></tr></table></figure><p>执行结果可以看到，这是一个简单的日志文件，日志中记录了用户的一些操作，这里并没有出现具体的SQL语句，这是因为binlog关键字后面的内容是经过编码后的二进制日志。</p><p>这里一个update语句包含如下事件</p><ul><li>Query事件负责开始一个事务(BEGIN)</li><li>Table_map事件负责映射需要的表</li><li>Update_rows事件负责写入数据</li><li>Xid事件负责结束事务</li></ul><p>下面命令将行事件以<code>伪SQL</code>的形式表现出来</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog <span class="operator">-</span>v &quot;/var/lib/mysql/binlog/test.000002&quot;</span><br></pre></td></tr></table></figure><p>前面的命令同时显示binlog格式的语句，使用如下命令不显示它</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog <span class="operator">-</span>v <span class="comment">--base64-output=DECODE-ROWS &quot;/var/lib/mysql/binlog/test.000002&quot;</span></span><br></pre></td></tr></table></figure><p>关于mysqlbinlog工具的使用技巧还有很多，例如只解析对某个库的操作或者某个时间段内的操作等。简单分享几个常用的语句，更多操作可以参考官方文档。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 可查看参数帮助</span><br><span class="line">mysqlbinlog <span class="comment">--no-defaults --help</span></span><br><span class="line"></span><br><span class="line"># 查看最后 <span class="number">100</span> 行</span><br><span class="line">mysqlbinlog <span class="comment">--no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |tail - 100</span></span><br><span class="line"></span><br><span class="line"># 根据position查找</span><br><span class="line">mysqlbinlog <span class="comment">--no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |grep -A </span></span><br><span class="line"><span class="number">20</span> <span class="string">&#x27;4939002&#x27;</span></span><br></pre></td></tr></table></figure><p>上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的查询命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> binlog events [<span class="keyword">IN</span> <span class="string">&#x27;log_name&#x27;</span>] [<span class="keyword">FROM</span> pos] [LIMIT [<span class="keyword">offset</span>,] row_count];</span><br></pre></td></tr></table></figure><ul><li><code>IN &#39;log_name&#39;：</code>指定要查询的binlog文件名（不指定就是第一个binlog文件）</li><li><code>FROM pos：</code>指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）</li><li><code>LIMIT [offset]：</code>偏移量(不指定就是 0 )</li><li><code>row_count :</code>查询总条数（不指定就是所有行）</li></ul><p>上面这条语句可以将指定的binlog日志文件，分成有效事件行的方式返回，并可使用limit指定pos点的起始偏移，查询条数。其它举例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#a、查询第一个最早的binlog日志:</span><br><span class="line"><span class="keyword">show</span> binlog events\G ;</span><br><span class="line"></span><br><span class="line">#b、指定查询mysql<span class="operator">-</span>bin<span class="number">.088802</span>这个文件</span><br><span class="line"><span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;atguigu-bin. 008002&#x27;</span>\G;</span><br><span class="line"></span><br><span class="line">#c、指定查询mysql<span class="operator">-</span>bin. <span class="number">080802</span>这个文件，从pos点:<span class="number">391</span>开始查起:</span><br><span class="line"><span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;atguigu-bin.008802&#x27;</span> <span class="keyword">from</span> <span class="number">391</span>\G;</span><br><span class="line"></span><br><span class="line">#d、指定查询mysql<span class="operator">-</span>bin<span class="number">.000802</span>这个文件，从pos点:<span class="number">391</span>开始查起，查询<span class="number">5</span>条（即<span class="number">5</span>条语句)</span><br><span class="line"><span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;atguigu-bin.000882&#x27;</span> <span class="keyword">from</span> <span class="number">391</span> limit <span class="number">5</span>\G</span><br><span class="line"></span><br><span class="line">#e、指定查询 mysql<span class="operator">-</span>bin<span class="number">.880002</span>这个文件，从pos点:<span class="number">391</span>开始查起，偏移<span class="number">2</span>行〈即中间跳过<span class="number">2</span>个）查询<span class="number">5</span>条（即<span class="number">5</span>条语句)。</span><br><span class="line"><span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;atguigu-bin.088882&#x27;</span> <span class="keyword">from</span> <span class="number">391</span> limit <span class="number">2</span>,<span class="number">5</span>\G;</span><br></pre></td></tr></table></figure><p>binlog格式查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;binlog_format&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> binlog_format <span class="operator">|</span> <span class="type">ROW</span>   <span class="operator">|</span> <span class="operator">/</span><span class="operator">/</span>行格式</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>除此之外，binlog还有 2 种格式，分别是<code>Statemen</code>和<code>Mixed</code></p><ul><li><p>Statement<br>  每一条会修改数据的sql都会记录在binlog中。</p><p>  优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。</p></li><li><p>Row<br>  5.1.5版本的MySQL才开始支持row level 的复制，它不记录sql语句上下文相关信息，仅保存哪条记录被修改。<br>  优点：row level 的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题。</p></li><li><p>Mixed<br>  从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。</p></li></ul><h4 id="5-4-使用日志恢复数据"><a href="#5-4-使用日志恢复数据" class="headerlink" title="5.4 使用日志恢复数据"></a>5.4 使用日志恢复数据</h4><p>mysqlbinlog恢复数据的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [option] filename<span class="operator">|</span>mysql –uuser <span class="operator">-</span>ppass;</span><br></pre></td></tr></table></figure><p>这个命令可以这样理解：使用mysqlbinlog命令来读取filename中的内容，然后使用mysql命令将这些内容恢复到数据库中。</p><ul><li>filename：是日志文件名。</li><li>option：可选项，比较重要的两对option参数是–start-date、–stop-date 和 –start-position、–stop-position。<ul><li>–start-date 和 - -stop-date：可以指定恢复数据库的起始时间点和结束时间点。</li><li>–start-position和–stop-position：可以指定恢复数据的开始位置和结束位置。</li></ul></li></ul><blockquote><p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必须在atguigu-bin.000002之前恢复。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flush logs; #可以生成新的binLog 文件，不然这个文件边恢复边变大是不行的。</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="type">binary</span> logs; # 显示有哪些binLog 文件</span><br></pre></td></tr></table></figure><p>恢复数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [option] filename<span class="operator">|</span>mysql –uuser <span class="operator">-</span>ppass;</span><br><span class="line"></span><br><span class="line">mysqlbinlog <span class="comment">--no-defaults  --start-position=236  --stop-position=1071 --database=my_db1 /var/lib/mysql/lqhdb-bin.000002 | /usr/bin/mysql -root -p123456 -v my_db1</span></span><br></pre></td></tr></table></figure><h4 id="5-5-删除二进制日志"><a href="#5-5-删除二进制日志" class="headerlink" title="5.5 删除二进制日志"></a>5.5 删除二进制日志</h4><p>MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。<code>PURGE MASTER LOGS</code>只删除指定部分的二进制日志文件，<code>RESET MASTER</code>删除所有的二进制日志文件。具体如下：</p><p><strong>1.PURGE MASTER LOGS：删除指定日志文件</strong></p><p>PURGE MASTER LOGS语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PURGE &#123;MASTER <span class="operator">|</span> <span class="type">BINARY</span>&#125; LOGS <span class="keyword">TO</span> ‘指定日志文件名’</span><br><span class="line"></span><br><span class="line">PURGE &#123;MASTER <span class="operator">|</span> <span class="type">BINARY</span>&#125; LOGS BEFORE ‘指定日期’</span><br></pre></td></tr></table></figure><p>**举例 **使用PURGE MASTER LOGS语句删除创建时间比binlog.000005早的所有日志</p><p>(1)多次重新启动MysSQL服务，便于生成多个日志文件。然后用SHOW语句显示二进制日志文件列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS;</span><br></pre></td></tr></table></figure><p>(2）执行PURGE MASTER LOGS语句删除创建时间比binlog.000005早的所有日志</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PURGE MASTER LOGS T0 &quot;binlog. 000005&quot;;</span><br></pre></td></tr></table></figure><p>(3）显示二进制日志文件列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHGW <span class="type">BINARY</span> LOGS;</span><br></pre></td></tr></table></figure><p><strong>举例</strong>:使用PURGE MASTER LOGS语句删除2020年10月25号前创建的所有日志文件。具体步骤如下:</p><p>(1) 显示二进制日志文件列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS;</span><br></pre></td></tr></table></figure><p>(2）执行mysqlbinlog命令查看二进制日志文件binlog.000005的内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog <span class="comment">--no-defaults &quot;/var/lib/mysql/binlog/atguigu-bin.000005&quot;</span></span><br></pre></td></tr></table></figure><p>结果可以看出20220105为日志创建的时间，即2022年1月05日。</p><p>(3）使用PURGE MASTER LOGS语句删除2o22年1月q5日前创建的所有日志文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PURGE MASTER LOGS before &quot;20220105&quot;;</span><br></pre></td></tr></table></figure><p>(4）显示二进制日志文件列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS;</span><br></pre></td></tr></table></figure><p>2022年01月05号之前的二进制日志文件都已经被删除，最后一个没有删除，是因为当前在用，还未记录最后的时间，所以未被删除。</p><p><strong>2.RESET MASTER:删除所有二进制日志文件</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reset master;</span><br></pre></td></tr></table></figure><h4 id="5-6-其它场景"><a href="#5-6-其它场景" class="headerlink" title="5.6 其它场景"></a>5.6 其它场景</h4><p>二进制日志可以通过数据库的<code>全量备份</code>和二进制日志中保存的<code>增量信息</code>，完成数据库的<code>无损失恢复</code>。但是，如果遇到数据量大、数据库和数据表很多（比如分库分表的应用）的场景，用二进制日志进行数据恢复，是很有挑战性的，因为起止位置不容易管理。</p><p>在这种情况下，一个有效的解决办法是<code>配置主从数据库服务器</code>，甚至是<code>一主多从</code>的架构，把二进制日志文件的内容通过中继日志，同步到从数据库服务器中，这样就可以有效避免数据库故障导致的数据异常等问题。</p><h3 id="6-再谈二进制日志"><a href="#6-再谈二进制日志" class="headerlink" title="6. 再谈二进制日志"></a>6. 再谈二进制日志</h3><h4 id="6-1-写入机制"><a href="#6-1-写入机制" class="headerlink" title="6.1 写入机制"></a>6.1 写入机制</h4><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。</p><p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程binlog cache大，如果存储内容超过了这个参数，就要暂存到磁盘(Swap)。binlog日志刷盘流程如下:</p><img src="http://1.117.162.142:9000/blog/image-20230131171836210.png" alt="image-20230131171836210" style="zoom:50%;" /><blockquote><ul><li>上图的write，是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。</li><li>上图的fsync，才是将数据持久化到磁盘的操作</li></ul></blockquote><p>write和fsync的时机，可以由参数sync_binlog控制，默认是 0 。为 0 的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的binglog 会丢失。如下图：</p><img src="http://1.117.162.142:9000/blog/image-20230131172036255.png" alt="image-20230131172036255" style="zoom:50%;" /><p>为了安全起见，可以设置为 1 ，表示每次提交事务都会执行fsync，就如同 redo log 刷盘流程 一样。最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。</p><img src="http://1.117.162.142:9000/blog/image-20230131172130789.png" alt="image-20230131172130789" style="zoom:50%;" /><p>在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p><h4 id="6-2-binlog与redolog对比"><a href="#6-2-binlog与redolog对比" class="headerlink" title="6.2 binlog与redolog对比"></a>6.2 binlog与redolog对比</h4><ul><li><p>redo log 它是<code>物理日志</code>，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎层产生的。</p></li><li><p>而 binlog 是<code>逻辑日志</code>，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于MySQL Server 层</p></li><li><p>虽然它们都属于持久化的保证，但是则重点不同。</p><ul><li>redo log让InnoDB存储引擎拥有了崩溃恢复能力。</li><li>binlog保证了MySQL集群架构的数据一致性。</li></ul></li></ul><h4 id="6-3-两阶段提交"><a href="#6-3-两阶段提交" class="headerlink" title="6.3 两阶段提交"></a>6.3 两阶段提交</h4><p>在执行更新语句过程，会记录 redo log 与 binlog 两块日志，以基本的事务为单位，redo log 在事务执行过程中可以不断写入，而 binlog 只有在提交事务时才写入，所以 redo log 与 binlog 的写入时机不一样。</p><img src="http://1.117.162.142:9000/blog/image-20230131172515589.png" alt="image-20230131172515589" style="zoom:50%;" /><p><strong>redo log 与 binlog 两份日志之间的逻辑不一致，会出现什么问题</strong>？</p><p>以 update 语句为例，假设 id&#x3D;2 的记录，字段 c 值是 0，把字段 c 值更新成 1，SQL 语句为 <code>update T set c = 1 where id = 2</code>。</p><p>假设执行过程中写完redo log 日之后，binlog 日志写期间发生了异常，会出现什么问题？</p><img src="http://1.117.162.142:9000/blog/image-20230131172810906.png" alt="image-20230131172810906" style="zoom:50%;" /><p>由于 binlog 没有写完就异常，这时候 binlog 里面没有对应的修改记录。因此，之后用 binlog 日志恢复数据时，就会少这一次更新，恢复出来的这一行 c 值是 0，而原库因为 redo log 日志恢复，这一行 c 值是 1，最终数据不一致。</p><img src="http://1.117.162.142:9000/blog/image-20230131173009465.png" alt="image-20230131173009465" style="zoom:50%;" /><p>为了解决两份日志之间的逻辑一致问题，InnoDB 存储引擎使用两阶段提交方案。原理很简单，将 redo log 的写入拆成了两个步骤，prepare 和 commit，这就是两阶段提交。</p><img src="http://1.117.162.142:9000/blog/image-20230131173144626.png" alt="image-20230131173144626" style="zoom:50%;" /><p>使用两阶段提交后，写入 binlog 时发生异常也不会有影响，因为 MySQL 根据 redo log 日志恢复数据时，发现 redo log 还处于 prepare 阶段，并且没有对应 binlog日志，就会回滚该事务。</p><img src="http://1.117.162.142:9000/blog/image-20230131173305299.png" alt="image-20230131173305299" style="zoom:50%;" /><p>另一个场景，redo log 设置 commit 阶段发生异常，那会不会回滚事务呢？</p><img src="http://1.117.162.142:9000/blog/image-20230131173412548.png" alt="image-20230131173412548" style="zoom:50%;" /><p>并不会回滚事务，他会执行上图框住的逻辑，虽然 redo log 是处于 prepare 阶段，但是能通过事务id找到对应的 binlog 日志，所以 MySQL 认为是完整的，就会提交事务恢复数据。</p><h3 id="7-中继日志-relay-log"><a href="#7-中继日志-relay-log" class="headerlink" title="7. 中继日志(relay log)"></a>7. 中继日志(relay log)</h3><h4 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h4><p>中继日志只在主从服务器架构的从服务器上存在 。从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入<code>本地的日志文件</code>中，这个从服务器本地的日志文件就叫<code>中继日志</code>。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的<code>数据同步</code>。</p><p>搭建好主从服务器之后，中继日志默认会保存在从服务器的数据目录下。</p><p>文件名的格式是：<code>从服务器名 - relay-bin.序号</code>。中继日志还有一个索引文件：从服务器名<code>- relay-bin.index</code>，用来定位当前正在使用的中继日志。</p><h4 id="7-2-查看中继日志"><a href="#7-2-查看中继日志" class="headerlink" title="7.2 查看中继日志"></a>7.2 查看中继日志</h4><p>中继日志与二进制日志的格式相同，可以用 mysqlbinlog 工具进行查看。下面是中继日志的一个片段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="type">TIMESTAMP</span><span class="operator">=</span> <span class="number">1618558728</span> <span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">950</span></span><br><span class="line">#<span class="number">210416</span> <span class="number">15</span>:<span class="number">38</span>:<span class="number">48</span> server id <span class="number">1</span> end_log_pos <span class="number">832</span> CRC32 <span class="number">0xcc16d651</span> Table_map:</span><br><span class="line">`atguigu`.`test` mapped <span class="keyword">to</span> number <span class="number">91</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">1000</span></span><br><span class="line">#<span class="number">210416</span> <span class="number">15</span>:<span class="number">38</span>:<span class="number">48</span> server id <span class="number">1</span> end_log_pos <span class="number">872</span> CRC32 <span class="number">0x07e4047c</span> Delete_rows: <span class="keyword">table</span> id</span><br><span class="line"><span class="number">91</span> flags: STMT_END_F <span class="comment">-- server id 1 是主服务器，意思是主服务器删了一行数据</span></span><br><span class="line">BINLOG <span class="string">&#x27;</span></span><br><span class="line"><span class="string">CD95YBMBAAAAMgAAAEADAAAAAFsAAAAAAAEABGRlbW8ABHRlc3QAAQMAAQEBAFHWFsw=</span></span><br><span class="line"><span class="string">CD95YCABAAAAKAAAAGgDAAAAAFsAAAAAAAEAAgAB/wABAAAAfATkBw==</span></span><br><span class="line"><span class="string">&#x27;</span><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">1040</span></span><br></pre></td></tr></table></figure><p>这一段的意思是，主服务器（“server id 1”）对表 atguigu.test 进行了 2 步操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定位到表 atguigu.test 编号是 91 的记录，日志位置是 832 ；</span><br><span class="line"></span><br><span class="line">删除编号是 91 的记录，日志位置是 872 。</span><br></pre></td></tr></table></figure><h4 id="7-3-恢复的典型错误"><a href="#7-3-恢复的典型错误" class="headerlink" title="7.3 恢复的典型错误"></a>7.3 恢复的典型错误</h4><p>如果从服务器宕机，有的时候为了系统恢复，要重装操作系统，这样就可能会导致你的服务器名称与之前不同。而中继日志里是包含从服务器名的。在这种情况下，就可能导致你恢复从服务器的时候，无法从宕机前的中继日志里读取数据，以为是日志文件损坏了，其实是名称不对了。</p><p>解决的方法也很简单，把从服务器的名称改回之前的名称。</p><h2 id="十六、主从复制"><a href="#十六、主从复制" class="headerlink" title="十六、主从复制"></a>十六、主从复制</h2><h3 id="1-主从复制概述"><a href="#1-主从复制概述" class="headerlink" title="1. 主从复制概述"></a>1. 主从复制概述</h3><h4 id="1-1-如何提升数据库并发能力"><a href="#1-1-如何提升数据库并发能力" class="headerlink" title="1.1 如何提升数据库并发能力"></a>1.1 如何提升数据库并发能力</h4><p>在实际工作中，我们常常将<code>Redis</code>作为缓存与<code>MySQL</code>配合来使用，当有请求的时候，首先会从缓存中进行查找，如果存在就直接取出。如果不存在再访问数据库，这样就<code>提升了读取的效率</code>，也减少了对后端数据库的<code>访问压力</code>。Redis的缓存架构是<code>高并发架构</code>中非常重要的一环。</p><img src="http://1.117.162.142:9000/blog/image-20230201091006326.png" alt="image-20230201091006326" style="zoom:50%;" /><p>此外，一般应用对数据库而言都是<code>“读多写少”</code>，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做<code>主从架构</code>、进行<code>读写分离</code>，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。</p><p>如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何优化<code>SQL和索引</code>，这种方式简单有效；其次才是采用<code>缓存的策略</code>，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用<code>主从架构</code>，进行读写分离。</p><h4 id="1-2-主从复制的作用"><a href="#1-2-主从复制的作用" class="headerlink" title="1.2 主从复制的作用"></a>1.2 主从复制的作用</h4><p>主从同步设计不仅可以提高数据库的吞吐量，还有以下 3 个方面的作用。</p><p><code>第 1 个作用：读写分离</code>。 我们可以通过主从复制的方式来<code>同步数据</code>，然后通过读写分离提高数据库并发处理能力。</p><img src="http://1.117.162.142:9000/blog/image-20230201091306074.png" alt="image-20230201091306074" style="zoom:50%;" /><p>其中一个是Master主库，负责写入数据，我们称之为：<code>写库</code>。</p><p>其它都是Slave从库，负责读取数据，我们称之为：<code>读库</code>。</p><p>当主库进行更新的时候，会自动将数据复制到从库中，而我们在客户端读取数据的时候，会从从库中进行读取。</p><p>面对“读多写少”的需求，采用读写分离的方式，可以实现更高的并发访问。同时，我们还能对从服务器进行负载均衡，让不同的读请求按照策略均匀地分发到不同的从服务器上，让读取更加顺畅。读取顺畅的另一个原因，就是减少了锁表的影响，比如我们让主库负责写，当主库出现写锁的时候，不会影响到从库进行SELECT的读取。</p><p><strong>第 2 个作用就是数据备份。</strong> 我们通过主从复制将主库上的数据复制到了从库上，相当于是一种热备份机制，也就是在主库正常运行的情况下进行的备份，不会影响到服务。</p><p><strong>第 3 个作用是具有高可用性。</strong> 数据备份实际上是一种冗余的机制，通过这种冗余的方式可以换取数据库的高可用性，也就是当服务器出现<code>故障</code>或<code>宕机</code>的情况下，可以<code>切换</code>到从服务器上，保证服务的正常运行。</p><p>关于高可用性的程度，我们可以用一个指标衡量，即正常可用时间&#x2F;全年时间。比如要达到全年99.999%的时间都可用，就意味着系统在一年中的不可用时间不得超过<code>365*24*60*(1-99.999%)=5.256分钟</code>(含系统崩溃的时间、日常维护操作导致的停机时间等)，其他时间都需要保持可用的状态。</p><p>实际上，更高的高可用性，意味着需要付出更高的成本代价。在现实中我们需要结合业务需求和成本来进行选择。</p><h3 id="2-主从复制的原理"><a href="#2-主从复制的原理" class="headerlink" title="2. 主从复制的原理"></a>2. 主从复制的原理</h3><p><code>Slave</code>会从<code>Master</code>读取<code>binlog</code>来进行数据同步。</p><h4 id="2-1-原理剖析"><a href="#2-1-原理剖析" class="headerlink" title="2.1 原理剖析"></a>2.1 原理剖析</h4><p><strong>三个线程</strong></p><p>实际上主从同步的原理就是基于 <a href="https://so.csdn.net/so/search?q=binlog&spm=1001.2101.3001.7020">binlog</a> 进行数据同步的。在主从复制过程中，会基于<code>3个线程</code>来操作，一个主库线程，两个从库线程。</p><img src="http://1.117.162.142:9000/blog/image-20230201091651293.png" alt="image-20230201091651293" style="zoom:50%;" /><p><code>二进制日志转储线程</code>（Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上加锁，读取完成之后，再将锁释放掉。</p><p><code>从库 I/O 线程会连接到主库</code>，向主库发送请求更新 Binlog。这时从库的 I&#x2F;O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</p><p><code>从库 SQL 线程</code>会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</p><img src="http://1.117.162.142:9000/blog/image-20230201091744050.png" alt="image-20230201091744050" style="zoom:50%;" /><blockquote><p>注意:<br>不是所有版本的MySQL都默认开启服务器的二进制日志。在进行主从同步的时候，我们需要先检查服务器是否已经开启了二进制日志。</p><p>除非特殊指定，默认情况下从服务器会执行所有主服务器中保存的事件。也可以通过配置，使从服务器执行特定的事件。</p></blockquote><p><strong>复制三步骤</strong><br>步骤 1 ：<code>Master</code>将写操作记录到二进制日志（<code>binlog</code>）。</p><p>步骤 2 ：<code>Slave</code>将<code>Master</code>的binary log events拷贝到它的<code>中继日志</code>（relay log）；</p><p>步骤 3 ：<code>Slave</code>重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从<code>接入点</code>开始复制。</p><p><strong>复制的问题</strong></p><p>复制的最大问题：<code>延时</code></p><h4 id="2-2-复制的基本原则"><a href="#2-2-复制的基本原则" class="headerlink" title="2.2 复制的基本原则"></a>2.2 复制的基本原则</h4><ul><li><p>每个Slave只有一个Master</p></li><li><p>每个Slave只能有一个唯一的服务器ID</p></li><li><p>每个Master可以有多个Slave</p></li></ul><h3 id="3-一主一从架构搭建"><a href="#3-一主一从架构搭建" class="headerlink" title="3. 一主一从架构搭建"></a>3. 一主一从架构搭建</h3><p>一台主机用于处理所有写请求，一台从机负责读请求，架构图如下：</p><img src="http://1.117.162.142:9000/blog/image-20230201092227168.png" alt="image-20230201092227168" style="zoom:50%;" /><h4 id="3-1-主机配置文件"><a href="#3-1-主机配置文件" class="headerlink" title="3.1 主机配置文件"></a>3.1 主机配置文件</h4><p>建议 MySQL 版本一直且后台以服务运行，主从所有配置项都在 <code>[mysqld]</code> 节点下，且都是小写字母。具体参数配置如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[必须]主服务器唯一ID</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[必须]启动二进制日志，指明路径。比如：自己本地的路径/log/mysqlbin</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[可选]0(默认)表示读写(主机)，1表示只读(从机)</span></span><br><span class="line"><span class="attr">read-only</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#设置日志文件保留的时长，单位是秒</span></span><br><span class="line"><span class="attr">binlog_expire_logs_seconds</span>=<span class="string">6000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#控制单个二进制日志大小。此参数的最大和默认值是1GB</span></span><br><span class="line"><span class="attr">max_binlog_size</span>=<span class="string">200M</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[可选]设置不要复制的数据库</span></span><br><span class="line"><span class="attr">binlog-ignore-db</span>=<span class="string">test</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[可选]设置需要复制的数据库，默认全部记录。</span></span><br><span class="line"><span class="attr">binlog-do-db</span>=<span class="string">需要复制的主数据库名字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[可选]设置binlog格式</span></span><br><span class="line"><span class="attr">binlog_format</span>=<span class="string">STATEMENT</span></span><br></pre></td></tr></table></figure><p>重启后台 mysql 服务，使配置生效</p><blockquote><p>注意：</p><p>先搭建完主从复制，在创建数据库。</p><p>MySQL 主从复制起始时，从机不继承主机数据。</p></blockquote><h4 id="3-2-从机配置文件"><a href="#3-2-从机配置文件" class="headerlink" title="3.2 从机配置文件"></a>3.2 从机配置文件</h4><p>主从所有配置项都在 <code>[mysqld]</code> 节点下，且都是小写字母。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[必须]从服务器唯一ID</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="string">2</span></span><br><span class="line"><span class="comment">#[可选]启用中继日志</span></span><br><span class="line"><span class="attr">relay-log</span>=<span class="string">mysql-relay</span></span><br></pre></td></tr></table></figure><p>重启后台 mysql 服务，使配置生效</p><blockquote><p>注意：主从机都关闭防火墙systemctl stop firewalld.service</p></blockquote><h4 id="3-3-主机：建立账户并授权"><a href="#3-3-主机：建立账户并授权" class="headerlink" title="3.3 主机：建立账户并授权"></a>3.3 主机：建立账户并授权</h4><p><strong>注意：如果使用的是MySQL8，需要如下的方式建立账户，并授权slave：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 创建用户</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;slave1&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;******&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 赋予权限</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;slave1&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"># 查看权限</span><br><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;slave1&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#此语句必须执行。否则会报错。</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;slave1&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;*******&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 刷新权限</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>查询Master的状态，并记录下File和Position的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+-------------------+------------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> File            <span class="operator">|</span> Position <span class="operator">|</span> Binlog_Do_DB      <span class="operator">|</span> Binlog_Ignore_DB <span class="operator">|</span> Executed_Gtid_Set <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+-------------------+------------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> test<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span>     <span class="number">1136</span> <span class="operator">|</span> test_master_slave <span class="operator">|</span>                  <span class="operator">|</span>                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+-------------------+------------------+-------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><blockquote><p>至此，不要再动主机，以免服务器状态变化</p></blockquote><h4 id="3-4-从机：配置需要复制的主机"><a href="#3-4-从机：配置需要复制的主机" class="headerlink" title="3.4 从机：配置需要复制的主机"></a>3.4 从机：配置需要复制的主机</h4><p>步骤一：从机上复制主机的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO</span><br><span class="line">MASTER_HOST=&#x27;主机的IP地址&#x27;,</span><br><span class="line">MASTER_USER=&#x27;主机用户名&#x27;,</span><br><span class="line">MASTER_PASSWORD=&#x27;主机用户名的密码&#x27;,</span><br><span class="line">MASTER_LOG_FILE=&#x27;mysql-bin.具体数字&#x27;,</span><br><span class="line">MASTER_LOG_POS=具体值;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> CHANGE MASTER <span class="keyword">TO</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;192.168.133.200&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> MASTER_USER<span class="operator">=</span><span class="string">&#x27;slave1&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;********&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;test-bin.000001&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> MASTER_LOG_POS<span class="operator">=</span><span class="number">1136</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected, <span class="number">8</span> warnings (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><p>步骤二：启动 slave 同步</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> SLAVE</span><br></pre></td></tr></table></figure><p>如果报错<code>Slave failed to initialize relay Log info structure from the repository</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 可以执行如下操作，删除之前的relay_log信息。然后重新执行 CHANGE MASTER <span class="keyword">TO</span> …语句即可。</span><br><span class="line">reset slave; #删除SLAVE数据库的relaylog日志文件，并重新启用新的relaylog文件</span><br></pre></td></tr></table></figure><p>步骤三：查看同步状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> slave status\G;</span><br></pre></td></tr></table></figure><img src="http://1.117.162.142:9000/blog/image-20230201100450108.png" alt="image-20230201100450108" style="zoom:50%;" /><p>图中两值为 yes 则为成功。</p><h4 id="3-5-测试"><a href="#3-5-测试" class="headerlink" title="3.5 测试"></a>3.5 测试</h4><p>主机新建库、新建表、insert记录，从机复制：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test_master_slave;</span><br><span class="line"></span><br><span class="line">use test_master_slave;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(id <span class="type">INT</span>,NAME <span class="type">VARCHAR</span>(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="3-6-停止主从同步"><a href="#3-6-停止主从同步" class="headerlink" title="3.6 停止主从同步"></a>3.6 停止主从同步</h4><ul><li><p>停止主从同步命令：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure></li><li><p>如何重新配置主从</p><p>  如果停止从服务器复制功能，再使用需要重新配置主从。否则会报错。</p></li></ul><p>重新配置主从，需要在从机上执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">reset master;</span><br></pre></td></tr></table></figure><h4 id="3-7-后续"><a href="#3-7-后续" class="headerlink" title="3.7 后续"></a>3.7 后续</h4><p>搭建主从复制：双主双从</p><p>一个主机 m1 用于处理所有写请求，它的从机 s1 和另一台主机 m2 还有它的从机 s2 负责所有读请求。当 m1 主机宕机后，m2 主机负责写请求，m1、m2互为备机。架构图如下：</p><img src="http://1.117.162.142:9000/blog/image-20230201101754925.png" alt="image-20230201101754925" style="zoom:50%;" /><h3 id="4-同步数据一致性问题"><a href="#4-同步数据一致性问题" class="headerlink" title="4. 同步数据一致性问题"></a>4. 同步数据一致性问题</h3><p><strong>主从同步的要求：</strong></p><ul><li>读库和写库的数据一致(最终一致)；</li><li>写数据必须写到写库；</li><li>读数据必须到读库(不一定)；</li></ul><h4 id="4-1-理解主从延迟问题"><a href="#4-1-理解主从延迟问题" class="headerlink" title="4.1 理解主从延迟问题"></a>4.1 理解主从延迟问题</h4><p>进行主从同步的内容是二进制日志，它是一个文件，在进行<code>网络传输</code>的过程中就一定会存在主从延迟（比如 500 ms），这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的<code>数据不一致性</code>问题。</p><p>导致主从延迟的时间点主要包括以下三个:</p><ul><li>1.主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1;</li><li>2.之后传给从库B，我们把从库B接收完这个binlog的时刻记为T2;</li><li>3.从库B执行完成这个事务，我们把这个时刻记为T3。</li></ul><h4 id="4-2-主从延迟问题原因"><a href="#4-2-主从延迟问题原因" class="headerlink" title="4.2 主从延迟问题原因"></a>4.2 主从延迟问题原因</h4><p>在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T 2 - T 1 的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。</p><p><strong>主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。</strong> 造成原因：</p><ol><li>从库的机器性能比主库要差</li><li>从库的压力大</li><li>大事务的执行</li></ol><ul><li><p>举例 1 ： 一次性用delete语句删除太多数据<br>  结论：后续再删除数据的时候，要控制每个事务删除的数据量，分成多次删除。</p></li><li><p>举例 2 ： 一次性用insert…select插入太多数据</p></li><li><p>举例: 3 ： 大表DDL<br>  比如在主库对一张500W的表添加一个字段耗费了 10 分钟，那么从节点上也会耗费 10 分钟。</p></li></ul><h4 id="4-3-如何减少主从延迟"><a href="#4-3-如何减少主从延迟" class="headerlink" title="4.3 如何减少主从延迟"></a>4.3 如何减少主从延迟</h4><p><strong>若想要减少主从延迟的时间，可以采取下面的办法：</strong></p><ul><li><p>降低多线程大事务并发的概率，优化业务逻辑</p></li><li><p>优化SQL，避免慢SQL，<code>减少批量操作</code>，建议写脚本以update-sleep这样的形式完成。</p></li><li><p><code>提高从库机器的配置</code>，减少主库写binlog和从库读binlog的效率差。</p></li><li><p>尽量采用<code>短的链路</code>，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。</p></li><li><p>实时性要求的业务读强制走主库，从库只做灾备，备份。</p></li></ul><h4 id="4-4-如何解决一致性问题"><a href="#4-4-如何解决一致性问题" class="headerlink" title="4.4 如何解决一致性问题"></a>4.4 如何解决一致性问题</h4><p>如果操作的数据存储在同一个数据库中，那么对数据进行更新的时候，可以对记录加写锁，这样在读取的时候就不会发生数据不一致的情况。但这时从库的作用就是备份，并没有起到读写分离，分担主库读压力的作用。</p><img src="http://1.117.162.142:9000/blog/image-20230201102611214.png" alt="image-20230201102611214" style="zoom:50%;" /><p>读写分离情况下，解决主从同步中数据不一致的问题， 就是解决主从之间<code>数据复制方式</code>的问题，如果按照数据一致性<code>从弱到强</code>来进行划分，有以下 3 种复制方式。</p><p><strong>方法 1 ：异步复制</strong></p><p>异步模式就是客户端提交COMMIT之后不需要等从库返回任何结果，而是直接将结果返回给客户端，这样做的好处是不会影响主库写的效率，但可能会存在主库宕机，而Binlog还没有同步到从库的情况，也就是此时的主库和从库数据不一致。这时候从从库中选择一个作为新主，那么新主则可能缺少原来主服务器中已提交的事务。所以，这种复制模式下的数据一致性是最弱的。</p><img src="http://1.117.162.142:9000/blog/image-20230201102713168.png" alt="image-20230201102713168" style="zoom:50%;" /><p><strong>方法 2 ：半同步复制</strong></p><p>MySQL5.5版本之后开始支持半同步复制的方式。原理是在客户端提交COMMIT之后不直接将结果返回给客户端，而是等待至少有一个从库接收到了Binlog，并且写入到中继日志中，再返回给客户端。</p><p>这样做的好处就是提高了数据的一致性，当然相比于异步复制来说，至少多增加了一个网络连接的延迟，降低了主库写的效率。</p><p>在MySQL5.7版本中还增加了一个<code>rpl_semi_sync_master_wait_for_slave_count</code>参数，可以对应答的从库数量进行设置，默认为1，也就是说只要有1个从库进行了响应，就可以返回给客户端。如果将这个参数调大，可以提升数据一致性的强度，但也会增加主库等待从库响应的时间。</p><img src="http://1.117.162.142:9000/blog/image-20230201102836729.png" alt="image-20230201102836729" style="zoom:50%;" /><p><strong>方法 3 ：组复制</strong></p><p>异步复制和半同步复制都无法最终保证数据的一致性问题，半同步复制是通过判断从库响应的个数来决定是否返回给客户端，虽然数据一致性相比于异步复制有提升，但仍然无法满足对数据一致性要求高的场景，比如金融领域。MGR 很好地弥补了这两种复制模式的不足。</p><p>组复制技术，简称 MGR（MySQL Group Replication）。是 MySQL 在 5.7.17 版本中推出的一种新的数据复制技术，这种复制技术是基于 Paxos 协议的状态机复制。</p><p><strong>MGR 是如何工作的</strong></p><p>首先我们将多个节点共同组成一个复制组，在执行<code>读写</code>（RW）事务的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于 <code>（N/2+1）</code>，这样才可以进行提交，而不是原发起方一个说了算。而针对<code>只读（RO）事务</code>则不需要经过组内同意，直接 COMMIT 即可。</p><p>在一个复制组内有多个节点组成，它们各自维护了自己的数据副本，并且在一致性协议层实现了原子消息和全局有序消息，从而保证组内数据的一致性。</p><img src="http://1.117.162.142:9000/blog/image-20230201103020826.png" alt="image-20230201103020826" style="zoom:50%;" /><p>MGR 将 MySQL 带入了数据强一致性的时代，是一个划时代的创新，其中一个重要的原因就是MGR 是基于 Paxos 协议的。Paxos 算法是由 2013 年的图灵奖获得者 Leslie Lamport 于 1990 年提出的，有关这个算法的决策机制可以搜一下。事实上，Paxos 算法提出来之后就作为<code>分布式一致性算法</code>被广泛应用，比如Apache 的 ZooKeeper 也是基于 Paxos 实现的。</p><h3 id="5-知识延伸"><a href="#5-知识延伸" class="headerlink" title="5. 知识延伸"></a>5. 知识延伸</h3><p>在主从架构的配置中，如果想要采取读写分离的策略，我们可以自己编写程序，也可以通过第三方的中间件来实现。</p><ul><li><p>自己编写程序的好处就在于比较自主，我们可以自己判断哪些查询在从库上来执行，针对实时性要求高的需求，我们还可以考虑哪些查询可以在主库上执行。同时，程序直接连接数据库，减少了中间件层，相当于减少了性能损耗。</p></li><li><p>采用中间件的方法有很明显的优势，功能强大，使用简单。但因为在客户端和数据库之间增加了中间件层会有一些性能损耗，同时商业中间件也是有使用成本的。我们也可以考虑采取一些优秀的开源工具。</p></li></ul><img src="http://1.117.162.142:9000/blog/image-20230201103234734.png" alt="image-20230201103234734" style="zoom:50%;" /><p>① Cobar属于阿里B2B事业群，始于 2008 年，在阿里服役 3 年多，接管3000+个MySQL数据库的schema,集群日处理在线SQL请求 50 亿次以上。由于Cobar发起人的离职，Cobar停止维护。</p><p>② Mycat是开源社区在阿里cobar基础上进行二次开发，解决了cobar存在的问题，并且加入了许多新的功能在其中。青出于蓝而胜于蓝。</p><p>③ OneProxy基于MySQL官方的proxy思想利用c语言进行开发的，OneProxy是一款商业收费的中间件。舍弃了一些功能，专注在性能和稳定性上。</p><p>④ kingshard由小团队用go语言开发，还需要发展，需要不断完善。</p><p>⑤ Vitess是Youtube生产在使用，架构很复杂。不支持MySQL原生协议，使用需要大量改造成本。</p><p>⑥ Atlas是 360 团队基于mysql proxy改写，功能还需完善，高并发下不稳定。</p><p>⑦ MaxScale是mariadb（MySQL原作者维护的一个版本） 研发的中间件</p><p>⑧ MySQLRoute是MySQL官方Oracle公司发布的中间件</p><img src="http://1.117.162.142:9000/blog/image-20230201103339191.png" alt="image-20230201103339191" style="zoom:50%;" /><img src="http://1.117.162.142:9000/blog/image-20230201103352864.png" alt="image-20230201103352864" style="zoom:50%;" /><p>主备切换</p><img src="http://1.117.162.142:9000/blog/image-20230201103437884.png" alt="image-20230201103437884" style="zoom:50%;" /><ul><li>主动切换</li><li>被动切换</li></ul><h1 id="十七、数据库备份与恢复"><a href="#十七、数据库备份与恢复" class="headerlink" title="十七、数据库备份与恢复"></a>十七、数据库备份与恢复</h1><h3 id="1-物理备份与逻辑备份"><a href="#1-物理备份与逻辑备份" class="headerlink" title="1. 物理备份与逻辑备份"></a>1. 物理备份与逻辑备份</h3><p><strong>物理备份</strong>：备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以用<code>xtrabackup</code>工具来进行物理备份。</p><p><strong>逻辑备份</strong>：对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL 中常用的逻辑备份工具为<code>mysqldump</code>。逻辑备份就是<code>备份sql语句</code>，在恢复的时候执行备份的sql语句实现数据库数据的重现。</p><h3 id="2-MySQLdump实现逻辑备份"><a href="#2-MySQLdump实现逻辑备份" class="headerlink" title="2. MySQLdump实现逻辑备份"></a>2. MySQLdump实现逻辑备份</h3><h4 id="2-1-备份一个数据库"><a href="#2-1-备份一个数据库" class="headerlink" title="2.1 备份一个数据库"></a>2.1 备份一个数据库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump –u 用户名称 –h 主机名称 –p密码 待备份的数据库名称[tbname, [tbname...]]&gt; 备份文件名称.sql</span><br></pre></td></tr></table></figure><blockquote><p>说明： 备份的文件并非一定要求后缀名为.sql，例如后缀名为.txt的文件也是可以的。</p></blockquote><h4 id="2-2-备份全部数据库"><a href="#2-2-备份全部数据库" class="headerlink" title="2.2 备份全部数据库"></a>2.2 备份全部数据库</h4><p>若想用mysqldump备份整个实例，可以使用<code> --all-databases</code> 或<code>-A</code>参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -pxxxxxx --all-databases &gt; all_database.sql </span><br><span class="line">mysqldump -uroot -pxxxxxx -A &gt; all_database.sql</span><br></pre></td></tr></table></figure><h4 id="2-3-备份部分数据库"><a href="#2-3-备份部分数据库" class="headerlink" title="2.3 备份部分数据库"></a>2.3 备份部分数据库</h4><p>使用 <code>--databases </code>或<code>-B</code>参数了，该参数后面跟数据库名称，多个数据库间用空格隔开。如果指定databases参数，备份文件中会存在创建数据库的语句，如果不指定参数，则不存在。语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldump –u user –h host –p --databases [数据库的名称1 [数据库的名称2...]] &gt; 备份文件名称.sql</span><br><span class="line"></span><br><span class="line">mysqldump -uroot -p --databases KK KK2 &gt;two_database.sql</span><br><span class="line">mysqldump -uroot -p -B KK KK12 &gt; two_database.sql</span><br></pre></td></tr></table></figure><h4 id="2-4-备份部分表"><a href="#2-4-备份部分表" class="headerlink" title="2.4 备份部分表"></a>2.4 备份部分表</h4><p>比如，在表变更前做个备份。语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump –u user –h host –p 数据库的名称 [表名1 [表名2...]] &gt; 备份文件名称.sql</span><br></pre></td></tr></table></figure><h4 id="2-5-备份单表的部分数据"><a href="#2-5-备份单表的部分数据" class="headerlink" title="2.5 备份单表的部分数据"></a>2.5 备份单表的部分数据</h4><p>有些时候一张表的数据量很大，我们只需要部分数据。这时就可以使用 <code>--where</code>选项了。where后面附带需要满足的条件。</p><p>举例：备份student表中id小于10的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu student <span class="comment">--where=&quot;id &lt; 10 &quot; &gt; student_part_id10_low_</span></span><br></pre></td></tr></table></figure><h4 id="2-6-排除某些表的备份"><a href="#2-6-排除某些表的备份" class="headerlink" title="2.6 排除某些表的备份"></a>2.6 排除某些表的备份</h4><p>如果我们想备份某个库，但是某些表数据量很大或者与业务关联不大，这个时候可以考虑排除掉这些表，同样的，选项<code>--ignore-table</code>可以完成这个功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p atguigu --ignore-table=atguigu.student &gt; no_stu_bak.sql</span><br></pre></td></tr></table></figure><h4 id="2-7-只备份结构或只备份数据"><a href="#2-7-只备份结构或只备份数据" class="headerlink" title="2.7 只备份结构或只备份数据"></a>2.7 只备份结构或只备份数据</h4><p>只备份结构的话可以使用<code>--no-data</code>简写为<code>-d</code>选项；只备份数据可以使用<code>--no-create-info</code>简写为<code>-t</code> 选项。</p><ul><li>只备份结构</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu <span class="comment">--no-data &gt; atguigu_no_data_bak.sql</span></span><br></pre></td></tr></table></figure><ul><li>只备份数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu <span class="comment">--no-create-info &gt; atguigu_no_create_info_bak.sql</span></span><br></pre></td></tr></table></figure><h4 id="2-8-备份中包含存储过程、函数、事件"><a href="#2-8-备份中包含存储过程、函数、事件" class="headerlink" title="2.8 备份中包含存储过程、函数、事件"></a>2.8 备份中包含存储过程、函数、事件</h4><p>mysqldump备份默认是不包含存储过程，自定义函数及事件的。可以使用 –routines 或<code>-R</code>选项来备份存储过程及函数，使用 –events 或<code>-E</code>参数来备份事件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="operator">-</span>R <span class="operator">-</span>E <span class="comment">--databases atguigu &gt; fun_atguigu_bak.sql</span></span><br></pre></td></tr></table></figure><h4 id="2-9-mysqldump常用选项"><a href="#2-9-mysqldump常用选项" class="headerlink" title="2.9 mysqldump常用选项"></a>2.9 mysqldump常用选项</h4><p>mysqldump其他常用选项如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--add-drop-database：在每个CREATE DATABASE语句前添加DROP DATABASE语句。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--add-drop-tables：在每个CREATE TABLE语句前添加DROP TABLE语句。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--add-locking：用LOCK TABLES和UNLOCK TABLES语句引用每个表转储。重载转储文件时插入得更快。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--all-database, -A：转储所有数据库中的所有表。与使用--database选项相同，在命令行中命名所有数据库。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--comment[=0|1]：如果设置为0，禁止转储文件中的其他信息，例如程序版本、服务器版本和主机。--skip- comments与--comments=0的结果相同。默认值为1，即包括额外信息。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--compact：产生少量输出。该选项禁用注释并启用--skip-add-drop-tables、--no-set-names、--skip- disable-keys和--skip-add-locking选项。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--compatible=name：产生与其他数据库系统或旧的MySQL服务器更兼容的输出，值可以为ansi、MySQL323、 MySQL40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_table_options或者 no_field_options。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--complete_insert, -c：使用包括列名的完整的INSERT语句。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--debug[=debug_options], -#[debug_options]：写调试日志。</span></span><br><span class="line"><span class="comment">--delete，-D：导入文本文件前清空表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--default-character-set=charset：使用charsets默认字符集。如果没有指定，就使用utf8。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--delete--master-logs：在主复制服务器上，完成转储操作后删除二进制日志。该选项自动启用-master- data。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--extended-insert，-e：使用包括几个VALUES列表的多行INSERT语法。这样使得转储文件更小，重载文件时可 以加速插入。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--flush-logs，-F：开始转储前刷新MySQL服务器日志文件。该选项要求RELOAD权限。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--force，-f：在表转储过程中，即使出现SQL错误也继续。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--lock-all-tables，-x：对所有数据库中的所有表加锁。在整体转储过程中通过全局锁定来实现。该选项自动关 闭--single-transaction和--lock-tables。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--lock-tables，-l：开始转储前锁定所有表。用READ LOCAL锁定表以允许并行插入MyISAM表。对于事务表（例 如InnoDB和BDB），--single-transaction是一个更好的选项，因为它根本不需要锁定表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--no-create-db，-n：该选项禁用CREATE DATABASE /*!32312 IF NOT EXIST*/db_name语句，如果给出- -database或--all-database选项，就包含到输出中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--no-create-info，-t：只导出数据，而不添加CREATE TABLE语句。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--no-data，-d：不写表的任何行信息，只转储表的结构。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--opt：该选项是速记，它可以快速进行转储操作并产生一个能很快装入MySQL服务器的转储文件。该选项默认开启， 但可以用--skip-opt禁用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--password[=password]，-p[password]：当连接服务器时使用的密码。</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>port<span class="operator">=</span>port_num，<span class="operator">-</span>P port_num：用于连接的TCP<span class="operator">/</span>IP端口号。</span><br><span class="line"></span><br><span class="line"><span class="comment">--protocol=&#123;TCP|SOCKET|PIPE|MEMORY&#125;：使用的连接协议。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--replace，-r –replace和--ignore：控制替换或复制唯一键值已有记录的输入记录的处理。如果指定-- replace，新行替换有相同的唯一键值的已有行；如果指定--ignore，复制已有的唯一键值的输入行被跳过。如果不 指定这两个选项，当发现一个复制键值时会出现一个错误，并且忽视文本文件的剩余部分。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--silent，-s：沉默模式。只有出现错误时才输出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--socket=path，-S path：当连接localhost时使用的套接字文件（为默认主机）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--user=user_name，-u user_name：当连接服务器时MySQL使用的用户名。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--verbose，-v：冗长模式，打印出程序操作的详细信息。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--xml，-X：产生XML输出</span></span><br></pre></td></tr></table></figure><p>运行帮助命令<code>mysqldump --help</code>，可以获得特定版本的完整选项列表。</p><blockquote><p>提示 如果运行mysqldump没有–quick或–opt选项，mysqldump在转储结果前将整个结果集装入内存。如果转储大数据库可能会出现问题，该选项默认启用，但可以用–skip-opt禁用。如果使用最新版本的mysqldump程序备份数据，并用于恢复到比较旧版本的MySQL服务器中，则不要使用–opt 或-e选项。</p></blockquote><h3 id="3-MySQL命令恢复数据"><a href="#3-MySQL命令恢复数据" class="headerlink" title="3. MySQL命令恢复数据"></a>3. MySQL命令恢复数据</h3><p>基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql –u root –p [dbname] <span class="operator">&lt;</span> backup.sql</span><br></pre></td></tr></table></figure><h4 id="3-1-单库备份中恢复单库"><a href="#3-1-单库备份中恢复单库" class="headerlink" title="3.1 单库备份中恢复单库"></a>3.1 单库备份中恢复单库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#备份文件中包含了创建数据库的语句</span><br><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="operator">&lt;</span> atguigu.sql</span><br><span class="line">#备份文件中不包含了创建数据库的语句</span><br><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu4<span class="operator">&lt;</span> atguigu.sql</span><br></pre></td></tr></table></figure><h4 id="3-2-全量备份恢复"><a href="#3-2-全量备份恢复" class="headerlink" title="3.2 全量备份恢复"></a>3.2 全量备份恢复</h4><p>如果我们现在有昨天的全量备份，现在想整个恢复，则可以这样操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql –u root –p <span class="operator">&lt;</span> all.sql</span><br></pre></td></tr></table></figure><h4 id="3-3-从全量备份中恢复单库"><a href="#3-3-从全量备份中恢复单库" class="headerlink" title="3.3 从全量备份中恢复单库"></a>3.3 从全量备份中恢复单库</h4><p>可能有这样的需求，比如说我们只想恢复某一个库，但是我们有的是整个实例的备份，这个时候我们可以从全量备份中分离出单个库的备份。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="operator">-</span>n <span class="string">&#x27;/^-- Current Database: `atguigu`/,/^-- Current Database: `/p&#x27;</span> all_database.sql <span class="operator">&gt;</span> atguigu.sql </span><br><span class="line">#分离完成后我们再导入KK.sql即可恢复单个库</span><br></pre></td></tr></table></figure><h4 id="3-4-从单库备份中恢复单表"><a href="#3-4-从单库备份中恢复单表" class="headerlink" title="3.4 从单库备份中恢复单表"></a>3.4 从单库备份中恢复单表</h4><p>这个需求还是比较常见的。比如说我们知道哪个表误操作了，那么就可以用单表恢复的方式来恢复。</p><p>举例：我们有atguigu整库的备份，但是由于class表误操作，需要单独恢复出这张表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat KK.sql <span class="operator">|</span> sed <span class="operator">-</span>e <span class="string">&#x27;/./&#123;H;$!d;&#125;&#x27;</span> <span class="operator">-</span>e <span class="string">&#x27;x;/CREATE TABLE `class`/!d;q&#x27;</span> <span class="operator">&gt;</span> class_structure.sql </span><br><span class="line">cat KK.sql <span class="operator">|</span> grep <span class="comment">--ignore-case &#x27;insert into `class`&#x27; &gt; class_data.sql </span></span><br><span class="line">#用shell语法分离出创建表的语句及插入数据的语句后 再依次导出即可完成恢复 </span><br><span class="line">use test; </span><br><span class="line">mysql<span class="operator">&gt;</span> source class_structure.sql; </span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected, <span class="number">1</span> warning (<span class="number">0.00</span> sec) </span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> source class_data.sql; </span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h3 id="4-物理备份：直接复制整个数据库"><a href="#4-物理备份：直接复制整个数据库" class="headerlink" title="4. 物理备份：直接复制整个数据库"></a>4. 物理备份：直接复制整个数据库</h3><p>直接将MySQL中的数据库文件复制出来。这种方法最简单，速度也最快。MySQL的数据库目录位置不一定相同：</p><ul><li><p>在Windows平台下，MySQL 8.0存放数据库的目录通常默认为 “ C:\ProgramData\MySQL\MySQL Server 8.0\Data ”或者其他用户自定义目录；</p></li><li><p>在Linux平台下，数据库目录位置通常为&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;；</p></li><li><p>在MAC OSX平台下，数据库目录位置通常为“&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data”</p></li></ul><p>但为了保证备份的一致性。需要保证：</p><ul><li>方式1：备份前，将服务器停止。</li><li>方式2：备份前，对相关表执行 FLUSH TABLES WITH READ LOCK 操作。这样当复制数据库目录中的文件时，允许其他客户继续查询表。同时，FLUSH TABLES语句来确保开始备份前将所有激活的索引页写入硬盘。</li></ul><p>这种方式方便、快速，但不是最好的备份方法，因为实际情况可能 不允许停止MySQL服务器 或者 锁住 表 ，而且这种方法 对InnoDB存储引擎 的表不适用。对于MyISAM存储引擎的表，这样备份和还原很方便，但是还原时最好是相同版本的MySQL数据库，否则可能会存在文件类型不同的情况。</p><p>注意，物理备份完毕后，执行<code>UNLOCK TABLES</code>来结算其他客户对表的修改行为。</p><blockquote><p>说明： 在MySQL版本号中，第一个数字表示主版本号，主版本号相同的MySQL数据库文件格式相同。</p></blockquote><p>此外，还可以考虑使用相关工具实现备份。比如， MySQLhotcopy 工具。MySQLhotcopy是一个Perl脚本，它使用LOCK TABLES、FLUSH TABLES和cp或scp来快速备份数据库。它是备份数据库或单个表最快的途径，但它只能运行在数据库目录所在的机器上，并且只能备份MyISAM类型的表。多用于mysql5.5之前。</p><h3 id="5-物理恢复：直接复制到数据库目录"><a href="#5-物理恢复：直接复制到数据库目录" class="headerlink" title="5. 物理恢复：直接复制到数据库目录"></a>5. 物理恢复：直接复制到数据库目录</h3><p>步骤：<br>1）演示删除备份的数据库中指定表的数据<br>2）将备份的数据库数据拷贝到数据目录下，并重启MySQL服务器<br>3）查询相关表的数据是否恢复。需要使用下面的 chown 操作。</p><p>要求</p><ul><li><p>必须确保备份数据的数据库和待恢复的数据库服务器的主版本号相同。</p><ul><li>因为只有MySQL数据库主版本号相同时，才能保证这两个MySQL数据库文件类型是相同的。</li></ul></li><li><p>这种方式对 MyISAM类型的表比较有效 ，对于InnoDB类型的表则不可用。</p><ul><li>因为InnoDB表的表空间不能直接复制。</li></ul></li><li><p>在Linux操作系统下，复制到数据库目录后，一定要将数据库的用户和组变成mysql，命令如下：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown <span class="operator">-</span>R mysql.mysql <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>dbname</span><br></pre></td></tr></table></figure><p>其中，两个mysql分别表示组和用户；“-R”参数可以改变文件夹下的所有子文件的用户和组；“dbname”参数表示数据库目录。</p><blockquote><p>提示 Linux操作系统下的权限设置非常严格。通常情况下，MySQL数据库只有root用户和mysql用户组下的mysql用户才可以访问，因此将数据库目录复制到指定文件夹后，一定要使用chown命令将文件夹的用户组变为mysql，将用户变为mysql。</p></blockquote><h3 id="6-表的导入与导出"><a href="#6-表的导入与导出" class="headerlink" title="6. 表的导入与导出"></a>6. 表的导入与导出</h3><h4 id="6-1-表的导出"><a href="#6-1-表的导出" class="headerlink" title="6.1 表的导出"></a>6.1 表的导出</h4><ol><li>使用SELECT…INTO OUTFILE导出文本文件</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%secure%&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">INTO</span> OUTFILE &quot;/var/lib/mysql-files/account.txt&quot;;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用mysqldump命令导出文本文件</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="operator">-</span>T &quot;/var/lib/mysql-files/&quot; atguigu account</span><br><span class="line"># 或</span><br><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="operator">-</span>T &quot;/var/lib/mysql-files/&quot; atguigu account <span class="comment">--fields-terminated- by=&#x27;,&#x27; --fields-optionally-enclosed-by=&#x27;\&quot;&#x27;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用mysql命令导出文本文件</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="comment">--execute=&quot;SELECT * FROM account;&quot; atguigu&gt; &quot;/var/lib/mysql-files/account.txt</span></span><br></pre></td></tr></table></figure><h4 id="6-2-表的导入"><a href="#6-2-表的导入" class="headerlink" title="6.2 表的导入"></a>6.2 表的导入</h4><ol><li>使用LOAD DATA INFILE方式导入文本文件</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">&#x27;/var/lib/mysql-files/account_0.txt&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> atguigu.account;</span><br><span class="line"># 或</span><br><span class="line">LOAD DATA INFILE <span class="string">&#x27;/var/lib/mysql-files/account_1.txt&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> atguigu.account FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span> ENCLOSED <span class="keyword">BY</span> <span class="string">&#x27;\&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用mysqlimport方式导入文本文件</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlimport <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu <span class="string">&#x27;/var/lib/mysql-files/account.txt&#x27;</span> <span class="comment">--fields-terminated- by=&#x27;,&#x27; -</span></span><br></pre></td></tr></table></figure><h3 id="7-数据库迁移"><a href="#7-数据库迁移" class="headerlink" title="7. 数据库迁移"></a>7. 数据库迁移</h3><h4 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h4><p>数据迁移(data migration) 是指选择、准备、提取和转换数据，并<strong>将数据从一个计算机存储系统永久地传输到另一个计算机存储系统的过程</strong>。此外，<strong>验证迁移数据的完整性</strong>和<strong>退役原来旧的数据存储</strong>，也被认为是整个数据迁移过程的一部分。</p><p>数据库迁移的原因是多样的，包括服务器或存储设备更换、维护或升级，应用程序迁移，网站集成，灾难恢复和数据中心迁移。</p><p>根据不同的需求可能要采取不同的迁移方案，但总体来说，MySQL数据迁移方案大值可以分为<strong>物理迁移</strong>和<strong>逻辑迁移</strong>两类。通常以尽可能自动化的方式执行，从而将人力资源从繁琐的任务中解放出来。</p><h4 id="7-2-迁移方案"><a href="#7-2-迁移方案" class="headerlink" title="7.2 迁移方案"></a>7.2 迁移方案</h4><ul><li><p>物理迁移</p><p>  物理迁移适用于大数据量下的整体迁移。使用物理迁移方案的优点是比较快速，但需要停机迁移并且要求 MySQL版本及配置必须和原服务器相同，也可能引起未知问题。</p><p>  物理迁移包括拷贝数据文件和使用 XtraBackup 备份工具两种。</p><p>  不同服务器之间可以采用物理迁移，我们可以在新的服务器上安装好同版本的数据库软件，创建好相同目录，建议配置文件也要和原数据库相同，然后从原数据库方拷贝来数据文件及日志文件，配置好文件组权限，之后在新服务器这边使用 mysqld 命令启动数据库。</p></li><li><p>逻辑迁移</p><p>  逻辑迁移适用范围更广，无论是部分迁移还是全量迁移，都可以使用逻辑迁移。逻辑迁移中使用最多的就是通过 mysqldump 等备份工具。</p></li></ul><h4 id="7-3-迁移注意点"><a href="#7-3-迁移注意点" class="headerlink" title="7.3 迁移注意点"></a>7.3 迁移注意点</h4><p><strong>1. 相同版本的数据库之间迁移注意点</strong></p><p>指的是在主版本号相同的 MySQL 数据库之间进行数据库移动。</p><p>方式1: 因为迁移前后 MySQL 数据库的主版本号相同，所以可以通过复制数据库目录来实现数据库迁移，但是物理迁移方式只适用于 MyISAM 引擎的表。对于 InnoDB 表，不能用直接复制文件的方式备份数据库。</p><p>方式2: 最常见和最安全的方式是使用 mysqldump 命令导出数据，然后再目标数据库服务器中使用 MySQL 命令导入。</p><p><strong>2. 不同版本的数据库之间迁移注意点</strong></p><p>例如，原来很多服务器使用5.7版本的MySQL数据库，在8.0版本推出来以后，改进了5.7版本的很多缺陷，因此需要把数据库升级到8.0版本。</p><p>旧版本与新版本的 MySQL 可能使用不同的默认字符集，例如有的旧版本中使用latin1作为默认字符集，而最新版本的 MySQL 默认字符集为 utf8mb4.如果数据库中有中文数据，那么迁移过程中需要对默认字符集进行修改，不然可能无法正常显示数据。</p><p>高版本的 MySQL 数据库通常都会兼容低版本，因此可以从低版本的MySQL 数据库迁移到高版本的MySQL数据库。</p><p><strong>3. 不同数据库之间迁移注意点</strong></p><p>不同数据库之间迁移是指从其他类型的数据库迁移到MySQL数据库，或者从MySQL数据库迁移到其他类型的数据库。这种迁移没有普适的解决方法。</p><p>迁移之前，需要了解不同数据库的架构， 比较它们之间的差异。不同数据库中定义相同类型的数据的关键字可能会不同。例如，MysQL中日期字段分为DATE和TIME两种，而ORACLE日期字段只有DATE; SQLServer数据库中有 ntext、Image等数据类型，MySQL数据库没有这些数据类型;MysQL支持的ENUM和SET类型，这些SQL Server数振库不支持。</p><p>另外，数据库厂商并没有完全按照SQL标准来设计数据库系统，导致不同的数据库系统的SQL语句有差别。例如，微软的SQL Server软件使用的是T-SQL语句，下-SQL中包含了非标准的SQL语句，不能和MySQL的SQL语句兼容。</p><p>不同类型数据库之间的差昇造成了互相迁移的困难，这些差异其实是商业公司故意造成的技术壁垒。但是不同头型的数据库之间的迁移并不是完全不可能。例如，可以使用 MyODBC 实现MySQL和SQL server之间的迁移。 MysQL 官方提供的工具 MySQL Migration Toolkit 也可以在不同数据之间进行数据迁移。MySQL迁移到Oracle时，需要使用mysqldump命令导出sql文件，然后， 手动更改sql文件中的CREATE语句。</p><h4 id="7-4-迁移小结"><a href="#7-4-迁移小结" class="headerlink" title="7.4 迁移小结"></a>7.4 迁移小结</h4><img src="http://1.117.162.142:9000/blog/image-20230201113541781.png" alt="image-20230201113541781" style="zoom:50%;" /><h3 id="8-误删数据库处理方式"><a href="#8-误删数据库处理方式" class="headerlink" title="8. 误删数据库处理方式"></a>8. 误删数据库处理方式</h3><p>传统的高可用架构是不能预防误删数据的，因为主库的一个drop table命呤，会通过binlog传给所有从库和级联从库，进而导致整个集群的实例都会执行这个命令。</p><p>为了找到解决误删数据的更高效的方法，我们需要先对和MySQL相关的误删数据，做下分类：</p><ol><li>使用delete语句误删数据行；</li><li>使用drop table或者truncate table语句误删数据表；</li><li>使用drop database 语句误删数据库；</li><li>使用rm命令误删整个MysQL实例。</li></ol><h4 id="8-1-delete：误删行"><a href="#8-1-delete：误删行" class="headerlink" title="8.1 delete：误删行"></a>8.1 delete：误删行</h4><p><strong>处理措施1：数据恢复</strong></p><p>使用<code>Flashback工具</code>恢复数据。</p><p>原理：修改binlog内容，拿回原库重放。如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行。</p><p>使用前提：<code>binlog_format=row</code> 和<code>binlog_row_image=FULL</code></p><p><strong>处理措施2：预防</strong></p><ul><li><p>代码上线前，必须<code>SQL审查</code>、<code>审计</code>。</p></li><li><p>建议可以打开<code>安全模式</code>，把 <code>sql_safe_updates</code> 参数设置为 <code>on</code>。强制要求加where 条件且where后需要是索引l字段，否则必须使用limit。否则就会报错。</p></li></ul><h4 id="8-2-truncate-x2F-drop：误删库-x2F-表"><a href="#8-2-truncate-x2F-drop：误删库-x2F-表" class="headerlink" title="8.2 truncate&#x2F;drop：误删库&#x2F;表"></a>8.2 truncate&#x2F;drop：误删库&#x2F;表</h4><p><strong>背景</strong>：</p><p>delete全表是很慢的，需要生成回滚日志、写redo、写binlog。所以，从性能角度考虑，优先考虑使用truncate table或者drop table命令。</p><p>使用delete命令删除的数据，你还可以用Flashback来恢复。而使用truncate &#x2F;drop table和drop database命令删除的数据，就没办法通过Flashback来恢复了。因为，即使我们配置了binlog_ format&#x3D;row，执行这三个命令时，记录的 binlog还是statement格式。binlog里面就只有一个truncate&#x2F;drop 语句，这些信息是恢复不出数据的。</p><p><strong>方案</strong>：</p><p>这种情况下恢复数据，需要使用全量备份与增量日志结合的方式。</p><p>方案的前提：有定期的全量备份，并且实时备份binlog </p><p>举例：有人误删了一个库，时间为下午3点。步骤如下：</p><ol><li>取最近一次全量备份。假设设置数据库库是一天一备，最近备份数据是当天凌晨2点；</li><li>用备份恢复出一个临时库;（注意：这里选择临时库，而不是直接操作主库）</li><li>取出凌晨2点之后的binlog日志；</li><li>剔除误删除数据的语句外，其它语句全部应用到临时库。（前面讲过binlog的恢复）</li><li>最后恢复到主库</li></ol><h4 id="8-3-预防使用truncate-x2F-drop误删库-x2F-表"><a href="#8-3-预防使用truncate-x2F-drop误删库-x2F-表" class="headerlink" title="8.3 预防使用truncate &#x2F;drop误删库&#x2F;表"></a>8.3 预防使用truncate &#x2F;drop误删库&#x2F;表</h4><p>上面我们说了使用truncate&#x2F;drop语句误删库&#x2F;表的恢复方案，在生产环境中可以通过下面建议的方案来尽量的避免类似的误操作。</p><p><strong>(1)权限分离</strong></p><ul><li><p>限制帐户权限，核心的数据库，一般都不能随便分配写权限，想要获取写权限需要审批。比如只给业务开发人员DML权限，不给truncate&#x2F;drop权限。即使是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。</p></li><li><p>不同的账号，不同的数据之问要进行权限分离，避免一个账号可以删除所有库。</p></li></ul><p><strong>(2)制定操作规范</strong></p><p>比如在删除数据表之前，必须先对表做改名操作（比如加_to_be_deleted ）。然后，观察一段时间，确保对业务无影响以后再删除这张表。</p><p><strong>(3)设置延迟复制备库</strong></p><p>简单的说延迟复制就是设置一个固定的延迟时间，比如1个小时，让从库落后主库一个小时。出现误删除操作小小时内，到这个备库上执行 <code>stop slave</code>，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。这里通过 <code>CHANGE MASTER TO MASTER_DELAY = N</code>命令，可以指定这个备库持续保持跟主库有N秒的延迟。比如把N设置为3600，即代表1个小时。</p><p>此外，延迟复制还可以用来解决以下问题：</p><p>① 用来做延迟测试，比如做好的数据库读写分离，把从库作为读库，那么想知道当数据产生延迟的时候到底会发生什么，就可以使用这个特性模拟延迟。</p><p>② 用于老数据的查询等需求，比如你经常需要查看某天前一个表或者字段的数值，你可能需要把备份恢复后进行查看，如果有延迟从库，比如延迟一周，那么就可以解决这样类似的需求。|</p><h4 id="8-4-rm：误删MySQL实例"><a href="#8-4-rm：误删MySQL实例" class="headerlink" title="8.4 rm：误删MySQL实例"></a>8.4 rm：误删MySQL实例</h4><p>对于一个有高可用机制的MySQL集群来说，不用担心 rm 删除数据。因为只删掉其中某一个节点数据的话，HA系统就会选出一个新的主库，从而保证整个集群的正常工作。我们把这个节点上的数据恢复回来后，再接入整个集群就好了。</p><p>但如果是恶意地把整个集群删除，那就需要考虑跨机房备份，跨城市备份。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 基础</title>
      <link href="/2022/10/25/mysql-basic/"/>
      <url>/2022/10/25/mysql-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="一、数据库概述"><a href="#一、数据库概述" class="headerlink" title="一、数据库概述"></a>一、数据库概述</h2><h3 id="1-RDBMS-与-非-RDBMS"><a href="#1-RDBMS-与-非-RDBMS" class="headerlink" title="1. RDBMS 与 非 RDBMS"></a>1. RDBMS 与 非 RDBMS</h3><h4 id="1-1-关系型数据库-RDBMS"><a href="#1-1-关系型数据库-RDBMS" class="headerlink" title="1.1 关系型数据库 (RDBMS)"></a>1.1 关系型数据库 (RDBMS)</h4><p>实质：</p><ul><li>这种类型的数据库是<code>最古老</code>的数据库类型，关系型数据库是把复杂的数据结构归结为简单的<code>二元关系</code> (即二维表格形式)。</li><li>关系型数据库以 <code>行（row）</code> 和 <code>列 (column)</code> 的形式存储数据，以便于用户理解。这一系列的行和列被称为<code>表 (table)</code>，一组表组成了一个 <code>库 (database)</code>。</li><li>表与表之间的数据记录有关系 (relationship)。现实世界中的各种实体以及实体之间的各种联系均用 <code>关系模型</code> 来表示。关系型数据库，就是建立在 <code>关系模型</code> 基础上的数据库。</li><li>SQL 就是关系型数据库的查询语言。</li></ul><p>优势：</p><ul><li><p>复杂查询</p><p>  可以用 SQL 语句方便的在一个表以及多个表之间做非常复杂的数据查询。</p></li><li><p>事物支持</p><p>  使得对于安全性能很高的数据访问要求得以实现。</p></li></ul><h4 id="1-2-非关系型数据库-非RDBMS"><a href="#1-2-非关系型数据库-非RDBMS" class="headerlink" title="1.2 非关系型数据库 (非RDBMS)"></a>1.2 非关系型数据库 (非RDBMS)</h4><p>非关系型数据库，可以看成传统关系型数据库的功能<code>阉割版本</code>，基于键值对存储数据，不需要经过 SQL 层的解析，<code>性能非常高</code>。同时，通过减少不常用的功能，进一步提高性能。目前基本上大部分主流的非关系型数据库都是免费的。</p><p>相比于 SQL，NoSQL 泛指非关系型数据库，包括了键值型数据库、文档型数据库、搜索引擎和列存储等，除此之外还包括徒刑数据库。也只有用 NoSQL 一词才能将这些技术囊括进来。</p><p><strong>键值型数据库</strong></p><p>间质性数据库通过 Key - Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key 作为唯一的标识符，有点事查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤 (比如 WHERE)，如果不知道去哪里找数据，就要遍历所有的键，这就回消耗大量的计算。键值型数据库典型的使用场景是作为<code>内存缓存</code>。<code>Redis</code> 是最流行的键值型数据库。</p><p><strong>文档型数据库</strong></p><p>此类数据库可存放并获取文档，可以是 XML、JSON 等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于兼职数据库所存放的“值”。<code>MongoDB</code> 是最流行的文档行数据库，此外，还有 CouchDB等。</p><p><strong>搜索引擎数据库</strong></p><p>虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是<strong>倒排索引</strong>。典型产品：<code>Solr</code>、<code>Elasticsearch</code>、<code>Splunk</code> 等。</p><p><strong>列式数据库</strong></p><p>列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储 (Row-based)，而列式数据库是将数据按列式存储到数据库中，这样做的好处是可以大量降低系统的 I&#x2F;O，适合于分布式文件系统，不足在于功能相对有限。典型产品：<code>HBase</code> 等。</p><p><strong>图形数据库</strong></p><p>图形数据库，利用了图这种数据结构存储了实体 (对象) 之间的关系。徒刑数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边 (关系) 来实现，特点在于能高效地解决复杂的关系问题。图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体 (对象) 之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：<code>Neo4J</code>、<code>InfoGrid</code> 等。</p><p><strong>NoSQL 的演变</strong></p><p>由于 SQL 一直称霸 DBMS，因此许多人在思考是否有一种数据库技术能远离 SQL，于是 NoSQL 诞生了，但是随着发展却发现越来越离不开 SQL。到目前为止 NoSQL 阵营中的 DBMS 都会有实现类似 SQL 的功能。下面是 NoSQL 这个名次在不同时期的诠释，从这些释义的变化中可以看出 <code>NoSQL 功能的演变</code>：</p><ul><li>1970: NoSQL &#x3D; We have no SQL</li><li>1980: NoSQL &#x3D; Know SQL</li><li>2000: NoSQL &#x3D; No SQL!</li><li>2005: NoSQL &#x3D; Not only SQL</li><li>2013: NoSQL &#x3D; No, SQL!</li></ul><p>NoSQL 对 SQL 做出了很好的补充，比如实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用 <code>性能更高、成本更低</code> 的非关系型数据库当然是更明智的选择。比如：日志搜集、排行榜、定时器等。</p><h3 id="2-关系型数据库设计规则"><a href="#2-关系型数据库设计规则" class="headerlink" title="2. 关系型数据库设计规则"></a>2. 关系型数据库设计规则</h3><ul><li>关系型数据库的典型数据结构就是<strong>数据表</strong>，这些数据表的组成都是结构化的 (Structured)。</li><li>将数据放到表中，表再放到库中。</li><li>一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。</li><li>表具有一些特性，这些特性定义了数据在表中如何存储，类似 Java 和 Python 中“类”的设计。</li></ul><h4 id="2-1-表、记录、字段"><a href="#2-1-表、记录、字段" class="headerlink" title="2.1 表、记录、字段"></a>2.1 表、记录、字段</h4><ul><li>E-R (entity-relationship，实体-联系) 模型中有三个主要概念是：<code>实体集</code>、<code>属性</code>、<code>联系集</code>。</li><li>一个实体集 (class) 对应于数据库中的一个表 (table)，一个实体 (instance) 则对应数据库表中的一行 (row)，也称为一条记录 (record)。一个属性 (arrtibute) 对应数据库表中的一列 (column)，也称为一个字段 (field)。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ORM 思想 (Object Relationship Mapping) 体现：</span><br><span class="line">数据库中的一个表  &lt;----&gt;  Java 或 Python 中的一个类</span><br><span class="line">表中的一条数据  &lt;----&gt;  类中的一个对象 (或实体)</span><br><span class="line">表中的一个列。&lt;----&gt;  类中的一个字段、属性 (field)</span><br></pre></td></tr></table></figure><h4 id="2-2-表的关联关系"><a href="#2-2-表的关联关系" class="headerlink" title="2.2 表的关联关系"></a>2.2 表的关联关系</h4><ul><li><p>表与表之间的数据记录有关系 (relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。</p></li><li><p>四种：</p><ul><li><p>一对一关联</p><p>  在实际的开发中应用不多，因为一对一可以创建成一张表。两种建表原则：外键唯一、外键是主键</p></li><li><p>一对多关联</p><p>  常见实例场景：客户表和订单表、分类表和商品表、部门表和员工表。一对多建表原则：在从表创建一个字段，字段作为外键指向主表的主键。</p></li><li><p>多对多关联</p><p>  要表示多对多关系，必须创建第三个表，该表通常称为联接表，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。</p></li><li><p>自我引用</p></li></ul></li></ul><h2 id="二、MySQL-安装"><a href="#二、MySQL-安装" class="headerlink" title="二、MySQL 安装"></a>二、MySQL 安装</h2><p>下载地址: <a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p><h3 id="1-检查是否安装-MySQL，并卸载"><a href="#1-检查是否安装-MySQL，并卸载" class="headerlink" title="1. 检查是否安装 MySQL，并卸载"></a>1. 检查是否安装 MySQL，并卸载</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查安装包</span></span><br><span class="line">rpm -qa | grep -i mysql. <span class="comment"># i 忽略大小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查mysql服务</span></span><br><span class="line">systemctl status mysqld.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line"><span class="comment"># 关闭mysql服务</span></span><br><span class="line">systemctl stop mysqld.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前mysql安装状况</span></span><br><span class="line">rpm -qa | grep -i mysql</span><br><span class="line">或</span><br><span class="line">yum list installed | grep mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载上述命令查询出来的已安装程序</span></span><br><span class="line">yum remove mysql-xxx mysql-xxx mysql-xxx mysql-xxx. <span class="comment"># 务必卸载干净，反复执行rpm -qa | grep -i mysql确认是否有残留</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除mysql相关文件</span></span><br><span class="line">find / -name mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除上述命令查找出的相关文件</span></span><br><span class="line"><span class="built_in">rm</span> -rf xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 my.cnf</span></span><br><span class="line"><span class="built_in">rm</span> -rf /etc/my.conf</span><br></pre></td></tr></table></figure><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于mysql安装过程中，会通过mysql用户在/tmp目录下新建tmp_db文件，所以给/tmp较大的权限。</span></span><br><span class="line"><span class="built_in">chmod</span> -R 777 /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装前，检查依赖</span></span><br><span class="line">rpm -qa | grep libaio</span><br><span class="line">rpm -qa | grep net-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按顺序安装</span></span><br><span class="line">rpm -ivh mysql-community-common-xxx.rpm</span><br><span class="line">rpm -ivh mysql-community-client-plugins-xxx.rpm</span><br><span class="line">rpm -ivh mysql-community-libs-xxx.rpm</span><br><span class="line">rpm -ivh mysql-community-client-xxx.rpm</span><br><span class="line">rpm -ivh mysql-community-server-xxx.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装过程可能存在错误信息</span></span><br><span class="line">mariadb-libs 被 mysql-community-libs-xxx 取代</span><br><span class="line"><span class="comment"># 执行 yum remove mysql-libs 解决，清除之前安装过的依赖即可。</span></span><br></pre></td></tr></table></figure><h3 id="3-查看-MySQL-版本"><a href="#3-查看-MySQL-版本" class="headerlink" title="3. 查看 MySQL 版本"></a>3. 查看 MySQL 版本</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql --version</span><br><span class="line">或</span><br><span class="line">mysqladmin --version</span><br><span class="line"><span class="comment"># 检车是否安装成功</span></span><br><span class="line">rpm -qa | grep -i mysql</span><br></pre></td></tr></table></figure><h3 id="4-服务的初始化"><a href="#4-服务的初始化" class="headerlink" title="4. 服务的初始化"></a>4. 服务的初始化</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了保证数据库目录与文件的所有者为 mysql 登录用户，如果你是以root身份运行mysql服务，需要执行下面的命令初始化</span></span><br><span class="line">mysqld --initialize --user=mysql</span><br><span class="line"><span class="comment"># --initialize 选项默认以安全模式来初始化，则会为root用户生成一个密码并将改密码标记为过期，登录后需要设置一个新的密码，生成的临时密码会往日志中记录一份。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看密码</span></span><br><span class="line"><span class="built_in">cat</span> /var/log/mysqld.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">systemctl status mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl start mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程</span></span><br><span class="line">ps -ef | grep -i mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看mysql服务是否自动自动</span></span><br><span class="line">systemctl list-unit-files | grep mysqld.service <span class="comment"># 默认是enabled</span></span><br><span class="line"><span class="comment"># 如果不是 enable </span></span><br><span class="line">systemctl <span class="built_in">enable</span> mysqld.service</span><br><span class="line"><span class="comment"># 如果不希望自启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> mysqld.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录mysql</span></span><br><span class="line">mysql -uroot -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改密码</span></span><br><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;new_password&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="5-远程登录"><a href="#5-远程登录" class="headerlink" title="5. 远程登录"></a>5. 远程登录</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网络是否畅通</span></span><br><span class="line">ping ip地址</span><br><span class="line"><span class="comment"># 远程访问端口,保证端口开放</span></span><br><span class="line">telnet ip地址 端口号</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭防火墙或打开端口</span></span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line"><span class="comment"># 查看开放的端口号</span></span><br><span class="line">firewalld-cmd --list-all</span><br><span class="line"><span class="comment"># 设置开放的端口号</span></span><br><span class="line">firewall-cmd --add-service=http --permanent</span><br><span class="line">firewall-cmd --add-port=3306/tcp --permanent</span><br><span class="line"><span class="comment"># 重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置mysql允许远程登录，默认是不允许</span></span><br><span class="line">use mysql;</span><br><span class="line">SELECT host,user FROM user;</span><br><span class="line">UPDATE user SET host=<span class="string">&#x27;%&#x27;</span> WHERE user = <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"><span class="comment"># 刷新权限</span></span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置新连接报错：错误号码：2058，原因是mysql密码加密方式变了，只会在mysql8版本中出现</span></span><br><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="6-数据目录"><a href="#6-数据目录" class="headerlink" title="6. 数据目录"></a>6. 数据目录</h3><ul><li><p>InnoDB 存储引擎，会在 data\数据库名 目录中产生一个或者两个文件：</p><ul><li>Xxx.frm文件：描述表结构文件，字段长度等</li><li>如果采用<strong>系统表空间</strong>模式，数据信息和索引信息都存储在 <code>ibdata1</code> 中</li><li>如果采用<strong>独立表空间</strong>存储模式，会在data\数据库名 中还产生<code>xxx.ibd</code> 文件 (存储数据信息和索引信息)</li></ul><p>  MySQL 5.7 中会在 data\数据库名 目录下生成db.opt 文件用于保存数据库的相关配置。比如字符集、比较规则。而 MySQL 8.0 不再提供 db.opt 文件，而是合并在 <code>.ibd</code> 文件中。</p></li><li><p>MyISAM 存储引擎，data\数据库名 文件夹中会产生三个文件：</p><ul><li>MySQL 5.7 中：xxx.frm：描述表结构文件，字段长度等。</li><li>MySQL 8.0 中 xxx.xxx.sdi：描述表结构文件，字段长度等</li><li>xxx.MYD (MYData)：数据信息文件，存储数据信息 (如果采用独立表存储模式)</li><li>x x x.MYI (MYIndex)：存放索引信息文件</li></ul></li></ul><h2 id="三、SQL-概述"><a href="#三、SQL-概述" class="headerlink" title="三、SQL 概述"></a>三、SQL 概述</h2><p> SQL 是用于访问和处理数据库的标准的计算机语言。</p><h3 id="1-SQL-的分类"><a href="#1-SQL-的分类" class="headerlink" title="1. SQL 的分类"></a>1. SQL 的分类</h3><ul><li>DDL (Data Definition Language，数据定义语言)，这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。<ul><li>主要的语句关键字包括：CREATE、ALTER、DROP、RENAME、TRUNCATE 等。</li></ul></li><li>DML (Data Manipulation Language， 数据操作语言)，用于添加、删除、更新和查找数据库记录，并检查数据完整性。<ul><li>主要的语句关键字包括：INSERT、DELETE、UPDATE、SELECT 等。</li><li><strong>SELECT 是 SQL 语言的基础，最为重要</strong>。</li></ul></li><li>DCL (Data Control Language，数据控制语言)，用于定义数据库、表、字段、用户的访问权限和安全级别。<ul><li>主要的语句关键字包括：COMMIT、ROLLBACK、SACEPOINT、GRANT、REVOKE 等。</li></ul></li></ul><h3 id="2-SQL-语言的规则和规范"><a href="#2-SQL-语言的规则和规范" class="headerlink" title="2. SQL 语言的规则和规范"></a>2. SQL 语言的规则和规范</h3><h4 id="2-1-基本规则"><a href="#2-1-基本规则" class="headerlink" title="2.1 基本规则"></a>2.1 基本规则</h4><ul><li>SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进</li><li>每条命令以 “;” 或 \g 或 \G 结束</li><li>关键字不能被缩写也不能分行</li><li>关于标点符号<ul><li>必须保证所有的 ()、单引号、双引号是成对结束的</li><li>必须使用英文状态下的半角输入方式</li><li>字符串行和日期类型的数据可以使用单引号 (‘ ‘) 表示</li><li>列的别名，尽量使用双引号 (“ “)，而且不建议省略 as</li></ul></li></ul><h4 id="2-2-SQL大小写规范"><a href="#2-2-SQL大小写规范" class="headerlink" title="2.2 SQL大小写规范"></a>2.2 SQL大小写规范</h4><ul><li>MySQL 在 Windows 环境下是大小写不敏感的</li><li>MySQL 在 Linux 环境下是大小写敏感的<ul><li>数据库名、表名、表的别名、变量名是严格区分大小写的</li><li>关键字、函数名、列名 (或字段名)、列的别名 (字段的别名) 是忽略大小写的。</li></ul></li><li>推荐采用统一的书写规范：<ul><li>数据库名、表名、表别名、字段名、字段别名等都小写</li><li>SQL 关键字、函数名、绑定变量等都大写</li></ul></li></ul><h4 id="2-3-注释"><a href="#2-3-注释" class="headerlink" title="2.3 注释"></a>2.3 注释</h4><p>可以使用如下格式的注释结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#单行注释</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 单行注释，--后必须空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="2-4-命名规则"><a href="#2-4-命名规则" class="headerlink" title="2.4 命名规则"></a>2.4 命名规则</h4><ul><li>数据库、表名不得超过 30 个字符，变量名限制为 29 个。</li><li>必须只能包含 A-Z，a-z，0-9，_ 共63个字符。</li><li>数据库名、表名、字段名等对象名中间不要包含空格。</li><li>同一个 MySQL 软件中，数据库不能同名，同一个库中，表不能重名，同一个表中，字段不能重名。</li><li>必须保证字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在 SQL 语句中使用 &#96;&#96; 引起来。</li><li>保持字段名和类型的一致性，在命名字段并为其制定数据类型的时候一定要保证一致性。加入数据类型在一个表里是整数，在另一个表里也一定要是整数。</li></ul><h3 id="3-最基本的-SELECT-语句"><a href="#3-最基本的-SELECT-语句" class="headerlink" title="3. 最基本的 SELECT 语句"></a>3. 最基本的 SELECT 语句</h3><ul><li><p><code>SELECT ···</code></p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span><span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span><span class="operator">+</span><span class="number">1</span> <span class="keyword">FROM</span> DUAL;  # DUAL 伪表</span><br></pre></td></tr></table></figure></li><li><p><code>SELECT 字段名1, 字段名2, ··· FROM 表名</code></p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, age, six <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>SELECT 字段名 AS 别名 FROM 表名</code></p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u_name name, u_age <span class="keyword">AS</span> age, u_six <span class="keyword">AS</span> &quot;six&quot; <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>   别名用 “ “，不要用 ‘ ‘ 号。AS 可省略。</p></li><li><p>去重：<code>SELECT DISTINCT 字段名 FROM 表名;</code></p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> age <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li><li><p>空值 (NULL) 参与运算</p><p>  NULL 不等于 0、” “、”NULL”，代表暂时没有值，NULL 参与运算，结果也为 NULL。例如：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age <span class="operator">+</span> <span class="number">2</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>  如果有一条记录的 age 为 NULL，那么执行 SQL 后，这条记录的结果仍然是 NULL。可以通过IFNULL() 函数给 NULL 赋值。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> IFNULL(age, <span class="number">0</span>) <span class="operator">+</span> <span class="number">2</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>  IFNULL() 会先判断 age 的值，如果为 NULL，则赋值为 0。</p></li><li><p>着重号 &#96;&#96;</p><p>  如果字段名或着表名与关键字相同，则需要用 &#96;&#96; 将字段名或表名引起来。例如：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> total <span class="keyword">FROM</span> `<span class="keyword">order</span>`;</span><br></pre></td></tr></table></figure></li><li><p>查询常数</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `熊猫` <span class="keyword">AS</span> name, last_name <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li><li><p>显示表结构 <code>DESCRIBE 表名</code> 或 <code>DESC 表名</code></p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">user</span>；</span><br><span class="line">或</span><br><span class="line"><span class="keyword">DESC</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li><li><p>过滤数据</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> age <span class="operator">&lt;</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> age <span class="operator">&lt;</span> <span class="number">20</span> <span class="keyword">AND</span> six <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="四、运算符"><a href="#四、运算符" class="headerlink" title="四、运算符"></a>四、运算符</h2><h3 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h3><table><thead><tr><th align="center">运算符</th><th align="center">名称</th><th align="center">作用</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加法运算符</td><td align="center">计算两个值或表达式的和</td><td align="center">SELECT A + B</td></tr><tr><td align="center">-</td><td align="center">减法运算符</td><td align="center">计算两个值或表达式的差</td><td align="center">SELECT A - B</td></tr><tr><td align="center">*</td><td align="center">乘法运算符</td><td align="center">计算两个值或表达式的乘积</td><td align="center">SELECT A * B</td></tr><tr><td align="center">&#x2F; 或 DIV</td><td align="center">除法运算符</td><td align="center">计算两个值或表达式的商</td><td align="center">SELECT A &#x2F; B, C DIV D</td></tr><tr><td align="center">% 或 MOD</td><td align="center">求模 (取余) 运算符</td><td align="center">计算两个值或表达式的余数</td><td align="center">SELECT A % B, C MOD D</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># <span class="operator">+</span>、<span class="operator">-</span>、<span class="operator">*</span>、<span class="operator">/</span> (或 DIV)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">+</span> <span class="number">1</span>, <span class="number">2</span> <span class="operator">-</span> <span class="number">1</span>, <span class="number">3</span> <span class="operator">*</span> <span class="number">2</span>, <span class="number">4</span> <span class="operator">/</span> <span class="number">2</span>, <span class="number">5</span> DIV <span class="number">2</span>, <span class="number">5</span> DIV <span class="number">0</span> <span class="keyword">FROM</span> DUAL;</span><br><span class="line"># 取模运算 <span class="operator">%</span> 或 MOD</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">4</span> <span class="operator">%</span> <span class="number">3</span>, <span class="number">-41</span> <span class="operator">%</span> <span class="number">2</span>, <span class="number">-42</span> <span class="operator">%</span> <span class="number">-4</span>, <span class="number">33</span> MOD <span class="number">-4</span> <span class="keyword">FROM</span> DUAL; # 结果的符号与被模值的符号相同</span><br></pre></td></tr></table></figure><h3 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a>2. 比较运算符</h3><p>比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回 1，比较的结果为假则返回 0，其他情况则返回 NULL。</p><table><thead><tr><th align="center">运算符</th><th align="center">名称</th><th align="center">作用</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td align="center">等于运算符</td><td align="center">判断两个值、字符串或表达式是否相等</td><td align="center">SELECT c FROM b WHERE a &#x3D; d</td></tr><tr><td align="center">&lt;&#x3D;&gt;</td><td align="center">安全等于运算符</td><td align="center">安全地判断两个值、字符串或表达式是否相等</td><td align="center">SELECT c FROM d WHERE a &lt;&#x3D;&gt; b</td></tr><tr><td align="center">&lt;&gt; 或 !&#x3D;</td><td align="center">不等于运算符</td><td align="center">判断两个值、字符串或表达式是否不相等</td><td align="center">SELECT c FROM d WHERE a &lt;&gt;b</td></tr><tr><td align="center">&lt;</td><td align="center">小于运算符</td><td align="center">判断前面的值、字符串或表达式是否小于后面的值、字符串或表达式</td><td align="center">SELECT c FROM d WHERE a &lt; b</td></tr><tr><td align="center">&gt;</td><td align="center">大于运算符</td><td align="center">判断前面的值、字符串或表达式是否大于后面的值、字符串或表达式</td><td align="center">SELECT c FROM d WHERE a &gt; b</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">小于等于运算符</td><td align="center">判断前面的值、字符串或表达式是否小于等于后面的值、字符串或表达式</td><td align="center">SELECT c FROM d WHERE a &lt;&#x3D; b</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">大于等于运算符</td><td align="center">判断前面的值、字符串或表达式是否大于等于后面的值、字符串或表达式</td><td align="center">SELECT c FROM d WHERE a &gt;&#x3D; b</td></tr></tbody></table><p>非符号类型的运算符：</p><table><thead><tr><th align="center">运算符</th><th align="center">名称</th><th align="center">作用</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">IS NULL</td><td align="center">为空运算符</td><td align="center">判断值、字符串或表达式是否为空</td><td align="center">SELECT c FROM b WHERE a IS NULL</td></tr><tr><td align="center">IS NOT NULL</td><td align="center">不为空运算符</td><td align="center">判断值、字符串或表达式是否不为空</td><td align="center">SELECT c FROM b WHERE a IS NOTNULL</td></tr><tr><td align="center">LEAST</td><td align="center">最小值运算符</td><td align="center">在多个值中返回最小值</td><td align="center">SELECT c FROM b WHERE a LEAST(e, f)</td></tr><tr><td align="center">GREATEST</td><td align="center">最大值运算符</td><td align="center">在多个值中返回最大值</td><td align="center">SELECT c FROM b WHERE a GREATEST(e, f)</td></tr><tr><td align="center">BETWEEN ··· AND ···</td><td align="center">两值之间的运算符</td><td align="center">判断一个值是否在两个值之间</td><td align="center">SELECT c FROM b WHERE a BETWEEN e AND f</td></tr><tr><td align="center">ISNULL</td><td align="center">为空运算符</td><td align="center">判断一个值、字符串或表达式是否为空</td><td align="center">SELECT c FROM b WHERE a ISNULL</td></tr><tr><td align="center">IN</td><td align="center">属于运算符</td><td align="center">判断一个值是否为列表中的任意一个值</td><td align="center">SELECT c FROM b WHERE a IN (e, f)</td></tr><tr><td align="center">NOT IN</td><td align="center">不属于运算符</td><td align="center">判断一个值是否为列表中的任意一个值</td><td align="center">SELECT c FROM b WHERE a NOT IN (e, f)</td></tr><tr><td align="center">LIKE</td><td align="center">模糊匹配运算符</td><td align="center">判断一个值是否符合模糊匹配规则</td><td align="center">SELECT c FROM b WHERE a LIKE B</td></tr><tr><td align="center">REGEXP</td><td align="center">正则表达式运算符</td><td align="center">判断一个值是否符合正则表达式的规则</td><td align="center">SELECT c FROM b WHERE a REGEXP B</td></tr><tr><td align="center">RLIKE</td><td align="center">正则表达式运算符</td><td align="center">判断一个值是否符合正则表达式的规则</td><td align="center">SELECT c FROM b WHERE a RLIKE B</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># <span class="operator">=</span> <span class="operator">&lt;=&gt;</span> <span class="operator">&lt;&gt;</span> <span class="operator">!=</span> <span class="operator">&lt;</span> <span class="operator">&lt;=</span> <span class="operator">&gt;</span> <span class="operator">&gt;=</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">2</span>, <span class="number">1</span> <span class="operator">!=</span> <span class="number">2</span>, <span class="number">1</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>, <span class="number">1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>,  <span class="number">0</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">FROM</span> DUAL; #结果：<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>。字符串存在隐士转换，如果转换数值不成功，则看做 <span class="number">0</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">=</span> <span class="keyword">NULL</span>, <span class="keyword">NULL</span> <span class="operator">=</span> <span class="keyword">NULL</span> <span class="keyword">FROM</span> DUAL; #结果：<span class="keyword">NULL</span> <span class="keyword">NULL</span> 只要有<span class="keyword">NULL</span>参与判断，都为<span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span>, <span class="keyword">NULL</span> <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span> <span class="keyword">FROM</span> DUAL; # 结果：<span class="number">0</span> <span class="number">1</span>。<span class="operator">&lt;=&gt;</span> 可以用来对 <span class="keyword">NULL</span> 进行判断，当两边均为 <span class="keyword">NULL</span> 时，返回 <span class="number">1</span>。一边为 <span class="keyword">NULL</span>，返回 <span class="number">0</span></span><br><span class="line"># <span class="keyword">IS</span> <span class="keyword">NULL</span>、<span class="keyword">NOT</span> <span class="keyword">NULL</span>、ISNULL</span><br><span class="line"><span class="keyword">SELECT</span> user_name, remark <span class="keyword">FROM</span> sys_user <span class="keyword">WHERE</span> remark <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> user_name, remark <span class="keyword">FROM</span> sys_user <span class="keyword">WHERE</span> remark <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> user_name, remark <span class="keyword">FROM</span> sys_user <span class="keyword">WHERE</span> ISNULL(remark);</span><br><span class="line"><span class="keyword">SELECT</span> user_name, remark <span class="keyword">FROM</span> sys_user <span class="keyword">WHERE</span> remark <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"># LEAST、GREATEST</span><br><span class="line"><span class="keyword">SELECT</span> LEAST(<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;v&#x27;</span>), GREATEST(<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;v&#x27;</span>) <span class="keyword">FROM</span> DUAL; # 结果：a v</span><br><span class="line"><span class="keyword">SELECT</span> LEAST(user_name, nick_name) <span class="keyword">FROM</span> sys_user;</span><br><span class="line"># <span class="keyword">BETWEEN</span> ··· <span class="keyword">AND</span> ···</span><br><span class="line"><span class="keyword">SELECT</span> user_name <span class="keyword">FROM</span> sys_user <span class="keyword">WHERE</span> dept_id <span class="keyword">BETWEEN</span> <span class="number">100</span> <span class="keyword">AND</span> <span class="number">104</span>;</span><br><span class="line"><span class="keyword">SELECT</span> user_name <span class="keyword">FROM</span> sys_user <span class="keyword">WHERE</span> dept_id <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">100</span> <span class="keyword">AND</span> <span class="number">104</span>;</span><br><span class="line"># <span class="keyword">IN</span>、<span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line"><span class="keyword">SELECT</span> user_name <span class="keyword">FROM</span> sys_user <span class="keyword">WHERE</span> dept_id <span class="keyword">IN</span> (<span class="number">100</span>, <span class="number">102</span>);</span><br><span class="line"><span class="keyword">SELECT</span> user_name <span class="keyword">FROM</span> sys_user <span class="keyword">WHERE</span> dept_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">100</span>, <span class="number">102</span>);</span><br><span class="line"># <span class="keyword">LIKE</span></span><br><span class="line"><span class="keyword">SELECT</span> user_name <span class="keyword">FROM</span> sys_user <span class="keyword">WHERE</span> user_name <span class="keyword">LIKE</span> <span class="string">&#x27;a%&#x27;</span>; #以 a 开头</span><br><span class="line"><span class="keyword">SELECT</span> user_name <span class="keyword">FROM</span> sys_user <span class="keyword">WHERE</span> user_name <span class="keyword">LIKE</span> <span class="string">&#x27;%a&#x27;</span>; #以 a 结尾</span><br><span class="line"><span class="keyword">SELECT</span> user_name <span class="keyword">FROM</span> sys_user <span class="keyword">WHERE</span> user_name <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span>; #包含 a</span><br><span class="line"><span class="keyword">SELECT</span> user_name <span class="keyword">FROM</span> sys_user <span class="keyword">WHERE</span> user_name <span class="keyword">LIKE</span> <span class="string">&#x27;_a%&#x27;</span>; #第二个字符是 a</span><br><span class="line"><span class="keyword">SELECT</span> user_name <span class="keyword">FROM</span> sys_user <span class="keyword">WHERE</span> user_name <span class="keyword">LIKE</span> <span class="string">&#x27;%m%n%&#x27;</span> <span class="keyword">OR</span> user_name <span class="keyword">LIKE</span> <span class="string">&#x27;%n%m%&#x27;</span>; #包含 m 和 n</span><br><span class="line"># REGEXP、RLIKE</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys_user <span class="keyword">WHERE</span> user_name REGEXP <span class="string">&#x27;^a&#x27;</span>; #以 a 开头</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys_user <span class="keyword">WHERE</span> user_name REGEXP <span class="string">&#x27;s$&#x27;</span>; #以 s 结尾</span><br></pre></td></tr></table></figure><h3 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h3><p>逻辑运算符主要用来判断表达式的真假，在 MySQL 中，逻辑运算符的返回结果为 1、0 或者 NULL。</p><table><thead><tr><th align="center">运算符</th><th align="center">作用</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">NOT 或 !</td><td align="center">逻辑非</td><td align="center">SELECT NOT a</td></tr><tr><td align="center">AND 或 &amp;&amp;</td><td align="center">逻辑与</td><td align="center">SELECT a AND b, c &amp;&amp; d</td></tr><tr><td align="center">OR 或 ||</td><td align="center">逻辑或</td><td align="center">SELECT a OR b, c || d</td></tr><tr><td align="center">XOR</td><td align="center">逻辑异或</td><td align="center">SELECT a XOR b</td></tr></tbody></table><p>::: tip</p><p>AND 和 OR 可以一起使用，但是在使用时要注意两者的优先级，由于 AND 的优先级高级 OR，因此先对 AND 两边的操作数进行操作，再与 OR 中的操作数结合。</p><p>:::</p><h3 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a>4. 位运算符</h3><p>位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，最后将计算结果从二进制变回十进制数。</p><p>MySQL 支持的位运算符如下：</p><table><thead><tr><th align="center">运算符</th><th align="center">作用</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">按位与 (位 AND)</td><td align="center">SELECT a &amp; b</td></tr><tr><td align="center">|</td><td align="center">按位或 (位 OR)</td><td align="center">SELECT a | b</td></tr><tr><td align="center">^</td><td align="center">按位异或 (位 XOR)</td><td align="center">SELECT a ^ b</td></tr><tr><td align="center">~</td><td align="center">按位取反</td><td align="center">SELECT a ~ b</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">按位右移</td><td align="center">SELECT a &gt;&gt; b</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">按位左移</td><td align="center">SELECT a &lt;&lt; b</td></tr></tbody></table><h3 id="5-运算符的优先级"><a href="#5-运算符的优先级" class="headerlink" title="5. 运算符的优先级"></a>5. 运算符的优先级</h3><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">:&#x3D;，&#x3D; (赋值)</td></tr><tr><td align="center">2</td><td align="center">||，OR，XOR</td></tr><tr><td align="center">3</td><td align="center">&amp;&amp;，AND</td></tr><tr><td align="center">4</td><td align="center">NOT</td></tr><tr><td align="center">5</td><td align="center">BETWEEN，CASE，WHERE，THEN 和 ELSE</td></tr><tr><td align="center">6</td><td align="center">&#x3D; (比较运算符)，&lt;&#x3D;&gt;，&gt;&#x3D;，&gt;，&lt;&#x3D;，&lt;，&lt;&gt;，!&#x3D;，IS，LIKE，REGEXP 和 IN</td></tr><tr><td align="center">7</td><td align="center">|</td></tr><tr><td align="center">8</td><td align="center">&amp;</td></tr><tr><td align="center">9</td><td align="center">&lt;&lt; 与 &gt;&gt;</td></tr><tr><td align="center">10</td><td align="center">- 和 +</td></tr><tr><td align="center">11</td><td align="center">*，&#x2F;，DIV，% 和 MOD</td></tr><tr><td align="center">12</td><td align="center">^</td></tr><tr><td align="center">13</td><td align="center">- (负号) 和 ~ (按位取反)</td></tr><tr><td align="center">14</td><td align="center">!</td></tr><tr><td align="center">15</td><td align="center">()</td></tr></tbody></table><p>数字编号越大，优先级越高，优先级高的运算符先进行计算。</p><h2 id="五、排序与分页"><a href="#五、排序与分页" class="headerlink" title="五、排序与分页"></a>五、排序与分页</h2><h3 id="1-排序数据"><a href="#1-排序数据" class="headerlink" title="1. 排序数据"></a>1. 排序数据</h3><blockquote><p>如果 SQL 中没有使用排序，则返回数据默认按照数据添加顺序返回。</p></blockquote><h4 id="1-1-排序规则"><a href="#1-1-排序规则" class="headerlink" title="1.1 排序规则"></a>1.1 排序规则</h4><ul><li>使用 ORDER BY 子句排序。(默认为 ASC 升序)<ul><li>ASC (ascend)：升序</li><li>DESC (descend)：降序</li></ul></li><li>ORDER BY 子句在 SELECT 语句的结尾。</li></ul><h4 id="1-2-单列排序"><a href="#1-2-单列排序" class="headerlink" title="1.2 单列排序"></a>1.2 单列排序</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> a <span class="keyword">ORDER</span> <span class="keyword">BY</span> b <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h4 id="1-3-多列排序"><a href="#1-3-多列排序" class="headerlink" title="1.3 多列排序"></a>1.3 多列排序</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> a <span class="keyword">ORDER</span> <span class="keyword">BY</span> b <span class="keyword">DESC</span>, c <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h3 id="2-分页"><a href="#2-分页" class="headerlink" title="2. 分页"></a>2. 分页</h3><h4 id="2-1-实现规则"><a href="#2-1-实现规则" class="headerlink" title="2.1 实现规则"></a>2.1 实现规则</h4><ul><li><p>分页远离</p><p>  所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。</p></li><li><p>MySQL 中国使用 LIMIT 实现分页</p></li><li><p>格式</p><p>  <code>LIMIT 偏移量, 行数</code> 或 <code>LIMIT pageNo, pageSize</code></p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> a LIMIT <span class="number">0</span>, <span class="number">10</span>; # 前 <span class="number">10</span> 条记录</span><br></pre></td></tr></table></figure></li><li><p>分页显示公式：**(当前页数 - 1) * 每页条数，每页条数**</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> a LIMIT (pageNo <span class="operator">-</span> <span class="number">1</span>) <span class="operator">*</span> pageSize, pageSize;</span><br></pre></td></tr></table></figure></li><li><p>注意：LIMIT 子句必须放在整个 SELECT 语句的最后。</p></li><li><p>使用 LIMIT 的好处</p><p>  约束返回结果的数量可以<code>减少数据表的网络传输量</code>，也可以<code>提升查询效率</code>。如果知道返回结果只有 1 条，就可以使用 <code>LIMIT 1</code>，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回。</p></li></ul><p>:::tip</p><p>MySQL 8.0 中可以使用 <code>LIMIT 3 OFFSET 4</code>，意思是获取从第 5 条记录开始后面的 3 条记录，和 <code>LIMIT 4, 3;</code> 返回的结果相同。</p><p>:::</p><h2 id="六、多表查询"><a href="#六、多表查询" class="headerlink" title="六、多表查询"></a>六、多表查询</h2><h3 id="1-笛卡尔积-交叉连接"><a href="#1-笛卡尔积-交叉连接" class="headerlink" title="1. 笛卡尔积 (交叉连接)"></a>1. 笛卡尔积 (交叉连接)</h3><p>笛卡尔乘积是一个数学运算。假设有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数几位两个集合中元素个数的乘积。</p><h4 id="1-1-产生笛卡尔积错误的条件："><a href="#1-1-产生笛卡尔积错误的条件：" class="headerlink" title="1.1 产生笛卡尔积错误的条件："></a>1.1 产生笛卡尔积错误的条件：</h4><ul><li>省略多个表的连接条件 (或关联条件)</li><li>连接条件 (或关联条件) 无效</li><li>所有表中的所有行互相连接</li></ul><h3 id="2-7-种-SQL-JOIN-的实现"><a href="#2-7-种-SQL-JOIN-的实现" class="headerlink" title="2. 7 种 SQL JOIN 的实现"></a>2. 7 种 SQL JOIN 的实现</h3><p><img src="http://1.117.162.142:9000/blog/sqljoin.png" alt="sqljoin"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span>左连接</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, ··· <span class="keyword">FROM</span> table1 t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2 t2 <span class="keyword">ON</span> t1.key <span class="operator">=</span> t2.key;</span><br><span class="line">#<span class="number">2.</span>右连接</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, ··· <span class="keyword">FROM</span> table1 t1 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table2 t2 <span class="keyword">ON</span> t1.key <span class="operator">=</span> t2.key;</span><br><span class="line">#<span class="number">3.</span>左连接不包含相同部分</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, ··· <span class="keyword">FROM</span> table1 t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2 t2 <span class="keyword">ON</span> t1.key <span class="operator">=</span> t2.key <span class="keyword">WHERE</span> t2.key <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line">#<span class="number">4.</span>右连接不包含相同部分</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, ··· <span class="keyword">FROM</span> table1 t1 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table2 t2 <span class="keyword">ON</span> t1.key <span class="operator">=</span> t2.key <span class="keyword">WHERE</span> t1.key <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p>mysql 不支持 SQL 99 的 FULL JOIN，但是可以使用 UNION 操作符来替代。</p><h4 id="2-1-合并查询结果"><a href="#2-1-合并查询结果" class="headerlink" title="2.1 合并查询结果"></a>2.1 合并查询结果</h4><p>利用 UNION 关键字，可以给出多条 SELECT 语句，并将它们的结果组合成单个结果集。合并式，两个表对应的列数和数据类型必须相同，并且相互对应。各个 SELECT 语句之间使用 UNION 或 UNION ALL 关键字分隔。</p><p>语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, ··· <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, ··· <span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure><h4 id="2-2-UNION-的使用"><a href="#2-2-UNION-的使用" class="headerlink" title="2.2 UNION 的使用"></a>2.2 UNION 的使用</h4><p><img src="http://1.117.162.142:9000/blog/union%E6%93%8D%E4%BD%9C%E7%AC%A6.png" alt="UNION操作符"></p><p>UNION 操作符返回两个查询的结果集的并集，然后去除重复记录。</p><h4 id="2-3-UNION-ALL-操作符"><a href="#2-3-UNION-ALL-操作符" class="headerlink" title="2.3 UNION ALL 操作符"></a>2.3 UNION ALL 操作符</h4><p><img src="http://1.117.162.142:9000/blog/unionall%E6%93%8D%E4%BD%9C%E7%AC%A6.png" alt="unionall操作符"></p><p>UNION ALL 操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。</p><p>:::tip</p><p>执行 UNION ALL 语句时所需要的资源比 UNION 语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用 UNION ALL 语句，以提高数据查询的效率。</p><p>:::</p><p>用 UNION ALL 替换 FULL JOIN。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">5.</span>满外连接</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, ··· <span class="keyword">FROM</span> table1 t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2 t2 <span class="keyword">ON</span> t1.key <span class="operator">=</span> t2.key</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, ··· <span class="keyword">FROM</span> table1 t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2 t2 <span class="keyword">ON</span> a.key <span class="operator">=</span> t1.key <span class="keyword">WHERE</span> t2.key <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line">#<span class="number">6.</span>满外连接，不包含相同部分</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, ··· <span class="keyword">FROM</span> table1 t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2 t2 <span class="keyword">ON</span> t1.key <span class="operator">=</span> t2.key <span class="keyword">WHERE</span> t2.key <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, ··· <span class="keyword">FROM</span> table1 t1 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table2 t2 <span class="keyword">ON</span> t1.key <span class="operator">=</span> t2.key <span class="keyword">WHERE</span> t1.key <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><h2 id="七、函数"><a href="#七、函数" class="headerlink" title="七、函数"></a>七、函数</h2><h3 id="1-不同-DBMS-函数的差异"><a href="#1-不同-DBMS-函数的差异" class="headerlink" title="1. 不同 DBMS 函数的差异"></a>1. 不同 DBMS 函数的差异</h3><p>在使用 SQL 语言的时候，不是直接和着门语言打交道，而是通过它使用不同的数据库软件，即 DBMS。<strong>DBMS 之间的差异性很大，远大于同一个语言不通版本之间的差异</strong>。实际上，只有很少的函数是被 DBMS 同时支持的。比如，大多数 DBMS 使用 || 或者 + 来做拼接符，而在 MySQL 中的字符串拼接函数为 concat()。大部分 DBMS 会有自己特定的函数，这就意味着<strong>采用 SQL 函数的代码可移植性是很差的</strong>，因此在使用函数的时候需要特别注意。</p><h3 id="2-MySQL-的内置函数及分类"><a href="#2-MySQL-的内置函数及分类" class="headerlink" title="2. MySQL 的内置函数及分类"></a>2. MySQL 的内置函数及分类</h3><p>MySQL 提供了丰富的内置函数，这些函数使得数据的维护与管理更加方便，能够更好地提供数据的分析与统计功能，在一定程度上提高了开发人员进行数据与统计的效率。</p><p>MySQL 提供的内置函数从 <code>实现的功能角度</code> 可以分为数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数、获取 MySQL 信息函数、聚合函数等。这些内置函数可以分为两类：<code>单行函数</code>、<code>聚合函数 (或分组函数)</code>。</p><p><img src="http://1.117.162.142:9000/blog/%E4%B8%A4%E7%A7%8Dsql%E5%87%BD%E6%95%B0.png" alt="两种sql函数"></p><h3 id="3-单行函数"><a href="#3-单行函数" class="headerlink" title="3. 单行函数"></a>3. 单行函数</h3><ul><li>操作数据对象</li><li>接受参数返回一个结果</li><li><strong>只对一行进行变换</strong></li><li><strong>每行返回一个结果</strong></li><li>可以嵌套</li><li>参数可以是一列或一个值</li></ul><h4 id="3-1-数值函数"><a href="#3-1-数值函数" class="headerlink" title="3.1 数值函数"></a>3.1 数值函数</h4><p>基本函数：</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>ABS(x)</td><td>返回 x 的绝对值</td></tr><tr><td>SIGN(x)</td><td>返回 x 的符号。整数返回 1，负数返回 -1，0 返回 0</td></tr><tr><td>PI()</td><td>返回圆周率的值</td></tr><tr><td>CEIL(x)，CEILING(x)</td><td>返回大于或等于某个值的最小整数</td></tr><tr><td>FLOOR(x)</td><td>返回小于或等于某个值的最大整数</td></tr><tr><td>LEAST(e1, e2, e3, ···)</td><td>返回列表中的最小值</td></tr><tr><td>GREATEST(e1, e2, e3, ···)</td><td>返回列表中的最大值</td></tr><tr><td>MOD(x, y)</td><td>返回 x 除以 y 后的余数</td></tr><tr><td>RAND()</td><td>返回 0～1 的随机值</td></tr><tr><td>RAND(x)</td><td>返回 0～1 的随机值，其中 x 的值用作种子值，相同的 x 值会产生相同的随机数</td></tr><tr><td>ROUND(x)</td><td>返回一个对 x 的值进行四舍五入后，最接近于 x 的整数</td></tr><tr><td>ROUND(x, y)</td><td>返回一个对 x 的值进行四舍五入后最接近 x 的值，并保留到小数点后 y 位</td></tr><tr><td>TRUNCATE(x, y)</td><td>返回数字 x 截断为 y 位小数的结果</td></tr><tr><td>SQRT(x)</td><td>返回 x 的平方根。当 x 的值为负数时，返回 NULL</td></tr></tbody></table><p><strong>数值函数可以嵌套</strong>。</p><p>角度与弧度互换函数：</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>RADIANS(x)</td><td>将角度转化为弧度，其中，参数 x 为角度值</td></tr><tr><td>DEGREES(x)</td><td>将弧度转化为角度，其中，参数 x 为弧度值</td></tr></tbody></table><p>三角函数：</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>SIN(x)</td><td>返回 x 的正弦值，其中，参数 x 为弧度值</td></tr><tr><td>ASIN(x)</td><td>返回 x 的反正弦值，即获取正弦为 x 的值。如果 x 的值不在 -1 到 1 之间，则返回 NULL</td></tr><tr><td>COS(x)</td><td>返回 x 的余弦值，其中，参数 x 为弧度值</td></tr><tr><td>ACOS(x)</td><td>返回 x 的反余弦值，即获取余弦为 x 的值。如果 x 的值不在 -1 到 1 之间，则返回 NULL</td></tr><tr><td>TAN(x)</td><td>返回 x 的正切值，其中，参数 x 为弧度值</td></tr><tr><td>ATAN(x)</td><td>返回 x 的反正切值，即返回正切值为 x 的值</td></tr><tr><td>ATAN2(m, n)</td><td>返回两个参数的反正切值</td></tr><tr><td>COT(x)</td><td>返回 x 的余切值，其中，x 为弧度值</td></tr></tbody></table><p>指数与对数：</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>POW(x, y), POWER(x, y)</td><td>返回 x 的 y 次方</td></tr><tr><td>EXP(x)</td><td>返回 e 的 x 次方，其中 e 是一个常数，2.718281828459045</td></tr><tr><td>LN(x), LOG(x)</td><td>返回以 e 为底的 x 的对数，当 x &lt;&#x3D; 0 时，返回的结果为 NULL</td></tr><tr><td>LOG10(x)</td><td>返回以 10 为底的 x 的对数，当 x &lt;&#x3D; 0 时，返回的结果为 NULL</td></tr><tr><td>LOG2(x)</td><td>返回以 2 为底的 x 的对数，当 x &lt;&#x3D; 0 时，返回的结果为 NULL</td></tr></tbody></table><p>进制间的转换：</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>BIN(x)</td><td>返回 x 的二进制编码</td></tr><tr><td>HEX(x)</td><td>返回 x 的十六进制编码</td></tr><tr><td>OCT(x)</td><td>返回 x 的八进制编码</td></tr><tr><td>CONV(x, f1, f2)</td><td>返回 f1 进制数变成 f2 进制数</td></tr></tbody></table><h4 id="3-2-字符串函数"><a href="#3-2-字符串函数" class="headerlink" title="3.2 字符串函数"></a>3.2 字符串函数</h4><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>ASCII(s)</td><td>返回字符串 s 中的第一个字符的 ASCII 码值</td></tr><tr><td>CHAE_LENGTH(s)</td><td>返回字符串 s 的字符数。作用与CHAEACTER_LENGTH(s) 相同</td></tr><tr><td>LENGTH(s)</td><td>返回字符串 s 的字节数，和字符集有关</td></tr><tr><td>CONCAT(s1, s2, s3, ···)</td><td>连接 s1, s2, s3, ··· 为一个字符串</td></tr><tr><td>CONCAT_WS(x, s1, s2, s3, ···)</td><td>同 CANCAT(s1, s2, s3, ···) 函数，但是每个字符串之间要加上 x</td></tr><tr><td>INSERT(str, idx, len, replacestr)</td><td>将字符串 str 从 idx 位置开始，len 个字符长的子串替换为字符串 replacestr</td></tr><tr><td>REPLACE(str, a, b)</td><td>用字符串 b 替换字符串 str 中所有出现的字符串 a</td></tr><tr><td>UPPER(s) 或 UCASE(s)</td><td>将字符串 s 的所有字母转成大写字母</td></tr><tr><td>LOWER(s) 或 LCASE(s)</td><td>将字符串 s 的所有字母转成小写字母</td></tr><tr><td>LEFT(str, n)</td><td>返回字符串 str 最左边的 n 个字符</td></tr><tr><td>RIGHT(str, n)</td><td>返回字符串 str 最右边的 n 个字符</td></tr><tr><td>LPAD(str, len, pad)</td><td>用字符串 pad 对 str 最左边进行填充，直到 str 的长度为 len 个字符</td></tr><tr><td>RPAD(str, len, pad)</td><td>用字符串 pad 对 str 最右边进行填充，直到 str 的长度为 len 个字符</td></tr><tr><td>LTRIM(s)</td><td>去掉字符串 s 左侧的空格</td></tr><tr><td>RTRIM(s)</td><td>去掉字符串 s 右侧的空格</td></tr><tr><td>TRIM(s)</td><td>去掉字符串 s 开始与结尾的空格</td></tr><tr><td>TRIM(s1FROM s)</td><td>去掉字符串 s 开始与结尾的 s1</td></tr><tr><td>TRIM(LEADING s1 FROM s)</td><td>去掉字符串 s 开始处的 s1</td></tr><tr><td>TRIM(TRAILING s1 FROM s)</td><td>去掉字符串 s 结尾处的 s1</td></tr><tr><td>REPEAT(str, n)</td><td>返回 str 重复 n 次的结果</td></tr><tr><td>SPACE(n)</td><td>返回 n 个空格</td></tr><tr><td>STRCMP(s1, s2)</td><td>比较字符串s1，s2 的 ASCII 码值的大小</td></tr><tr><td>SUBSTR(s, index, len)</td><td>返回从字符串 s 的 index 位置其 len 个字符，作用与 SUBSTRING(s, n, len) 相同</td></tr><tr><td>LOCATE(substr, str)</td><td>返回字符串 substr 在字符串 str 中首次出现的位置，作用与 POSITION(substrate IN str)、INSTR(str, substr) 相同。未找到，返回 0</td></tr><tr><td>ELT(m, s1, s2, ···, sn)</td><td>返回指定位置的字符串，如果 m &#x3D; 1，则返回 s1，如果 m &#x3D; 2，则返回 s2，如果 m &#x3D; n，则返回 sn</td></tr><tr><td>FIELD(s1, s2, ···, sn)</td><td>返回字符串 s 在字符串列表中第一次出现的位置</td></tr><tr><td>FIND_IN_SET(s1, s2)</td><td>返回字符串 s1 在字符串 s2 中出现的位置。其中，字符串 s2 是一个以逗号分隔的字符串</td></tr><tr><td>REVERSE(s)</td><td>返回s反转后的字符串</td></tr><tr><td>NULLIF(value1, value2)</td><td>比较两个字符串，如果 value1 与 value2 相等，则返回 NULL，否则返回 value1</td></tr></tbody></table><p>:::tip</p><p>MySQL 中，字符串的位置是从 1 开始的。</p><p>:::</p><h4 id="3-3-日期和时间函数"><a href="#3-3-日期和时间函数" class="headerlink" title="3.3 日期和时间函数"></a>3.3 日期和时间函数</h4><p>获取日期、时间：</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>CURDATE(), CURRENT_DATE()</td><td>返回当前日期，只包含年、月、日</td></tr><tr><td>CURTIME(), CURRENT_TIME()</td><td>返回当前时间，只包含时、分、秒</td></tr><tr><td>NOW() &#x2F; SYSDATE() &#x2F; CURRENT_TIMESTAMP() &#x2F; LOCALTIME() &#x2F; LOCALTIMESTAMP()</td><td>返回当前系统日期和时间</td></tr><tr><td>UTC_DATE()</td><td>返回 UTC (世界标准时间) 日期</td></tr><tr><td>UTC_TIME()</td><td>返回 UTC (世界标准时间) 时间</td></tr></tbody></table><p>日期与时间戳的转换：</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>UNIX_TIMESTAMP()</td><td>以 UNIX 时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP() -&gt; 1634348884</td></tr><tr><td>UNIX_TIMESTAMP(date)</td><td>将时间 date 以 UNIX 时间戳的形式返回。</td></tr><tr><td>FROM_UNIXTIME(timestamp)</td><td>将 UNIX 时间戳的时间转换为普通格式的时间</td></tr></tbody></table><p>获取月份、星期、星期数、天数等函数：</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>YEAE(date) &#x2F; MONTH(date) &#x2F; DAY(date)</td><td>返回具体的日期值</td></tr><tr><td>HOUR(time) &#x2F; MINUTE(time) &#x2F; SECOND(time)</td><td>返回具体的时间值</td></tr><tr><td>MONTHNAME(date)</td><td>返回月份：January，······</td></tr><tr><td>DAYNAME(date)</td><td>返回星期几：MONDAY， TUESDAY……SUNDAY</td></tr><tr><td>WEEKDAY(date)</td><td>返回周几，注意，周 1 是 0，周 2 是 1，……，周日是 6</td></tr><tr><td>QUARTER(date)</td><td>返回日期对应的季度，范围为 1～4</td></tr><tr><td>WEEK(date), WEEKOFYEAR(date)</td><td>返回一年中的第几周</td></tr><tr><td>DAYOFYEAR(date)</td><td>返回日期是一年中的第几天</td></tr><tr><td>DAYOFMONTH(date)</td><td>返回日期位于所在月份的第几天</td></tr><tr><td>DAYOFWEEK(date)</td><td>返回周几，注意：周日是 1，周一是 2，……，周六是 7</td></tr></tbody></table><p>日期的操作函数：</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>EXTRACT(type FROM date)</td><td>返回指定日期中特定的部分，type 指定返回值</td></tr></tbody></table><p>EXTRACT(type FROM date) 函数中 type 的取值与含义：</p><table><thead><tr><th>type 取值</th><th>含义</th></tr></thead><tbody><tr><td>MICROSECOND</td><td>返回毫秒数</td></tr><tr><td>SECOND</td><td>返回秒数</td></tr><tr><td>MINUTE</td><td>返回分钟数</td></tr><tr><td>HOUR</td><td>返回小时数</td></tr><tr><td>DAY</td><td>返回天数</td></tr><tr><td>WEEK</td><td>返回日期在一年中的第几个星期</td></tr><tr><td>MONTH</td><td>返回日期在一年中的第几个月</td></tr><tr><td>QUARTER</td><td>返回日期在一年中的第几个季度</td></tr><tr><td>YEAE</td><td>返回日期的年份</td></tr><tr><td>SECOND_MICROSECOND</td><td>返回秒和毫秒值</td></tr><tr><td>MINUTE_MICROSECOND</td><td>返回分钟和毫秒值</td></tr><tr><td>MINUTE_SECOND</td><td>返回分钟和秒值</td></tr><tr><td>HOUR_MICROSECOND</td><td>返回小时和毫秒值</td></tr><tr><td>HOUR_SECOND</td><td>返回小时和秒值</td></tr><tr><td>HOUR_MINUTE</td><td>返回小时和分钟值</td></tr><tr><td>DAY_MICROSECOND</td><td>返回天和毫秒值</td></tr><tr><td>DAY_SECOND</td><td>返回天和秒值</td></tr><tr><td>DAY_MINUTE</td><td>返回天和分钟值</td></tr><tr><td>DAY_HOUR</td><td>返回天和小时</td></tr><tr><td>YEAR_MONTH</td><td>返回年和月</td></tr></tbody></table><p>时间和秒种转换的函数：</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>TIME_TO_SEC(time)</td><td>将 time 转化为妙并返回结果值。转化的公式为：<code>小时 * 3600 + 分钟 * 60 + 秒</code></td></tr><tr><td>SEC_TO_TIME(seconds)</td><td>将 seconds 描述转化为包含小时、分钟和秒的时间</td></tr></tbody></table><p>计算日期和时间的函数：</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>DATE_ADD(datetime, INTERVAL express type), ADDDATE(date, INTERVAL express type)</td><td>返回与给定日期时间相差 INTERVAL 时间段的日期时间</td></tr><tr><td>DATE_SUB(date, INTERVAL expr type), SUBDATE(date, INTERVAL express type)</td><td>返回与 date 相差 INTERVAL 时间间隔的日期</td></tr><tr><td>ADDTIME(time1, time2)</td><td>返回 time1 加上 time2 的时间，当 time2 为一个数字时，代表的是秒，可以为负数</td></tr><tr><td>SUBTIME(time1, time2)</td><td>返回 time1 减去 time2 的时间，当 time2 为一个数字时，代表的是秒，可以为负数</td></tr><tr><td>DATEDIFF(date1, date2)</td><td>返回 date1 - date2 的日期间隔天数</td></tr><tr><td>TIMEDIFF(time1, time2)</td><td>返回 time1 - time2 的时间间隔</td></tr><tr><td>FROM_DAYS(N)</td><td>返回从 0000 年 1 月 1 日起，N 天以后的日期</td></tr><tr><td>TO_DAYS(date)</td><td>返回日期 date 距离 0000 年 1 月 1 日的天数</td></tr><tr><td>LAST_DAY(date)</td><td>返回 date 所在月份的最后一天的日期</td></tr><tr><td>MAKEDATE(year, n)</td><td>针对给定年份与所在年份中的天数返回一个日期</td></tr><tr><td>MAKETIME(hour, minute, second)</td><td>将给定的小时、分钟和秒组合成时间并返回</td></tr><tr><td>PERIOD_ADD(time, n)</td><td>返回 time 加上 n 后的时间</td></tr></tbody></table><p>上述函数中 type 的取值：</p><table><thead><tr><th>时间类型</th><th>含义</th></tr></thead><tbody><tr><td>HOUR</td><td>小时</td></tr><tr><td>MINUTE</td><td>分钟</td></tr><tr><td>SECOND</td><td>秒</td></tr><tr><td>YEAR</td><td>年</td></tr><tr><td>MONTH</td><td>月</td></tr><tr><td>DAY</td><td>日</td></tr><tr><td>YEAR_MONTH</td><td>年和月</td></tr><tr><td>DAY_HOUR</td><td>日和小时</td></tr><tr><td>DAY_MINUTE</td><td>日和分钟</td></tr><tr><td>DAY_SECOND</td><td>日和秒</td></tr><tr><td>HOUR_MINUTE</td><td>小时和分钟</td></tr><tr><td>HOUR_SECOND</td><td>小时和秒</td></tr><tr><td>MINUTE_SECOND</td><td>分钟和秒</td></tr></tbody></table><p>日期的格式化与解析</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>DATE_FORMAT(date, fmt)</td><td>按照字符串 fmt 格式化日期 date 值</td></tr><tr><td>TIME_FORMAT(time, fmt)</td><td>按照字符串 fmt 格式化时间 time 值</td></tr><tr><td>GET_FORMAT(date_type, format_type)</td><td>返回日期字符串的显示格式</td></tr><tr><td>STR_TO_DATE(str, fmt)</td><td>按照字符串 fmt 对 str 进行解析，解析为一个日期</td></tr></tbody></table><p> 上述非 GET_FORMAT 函数中 fmt 参数常用的格式符：</p><table><thead><tr><th>格式符</th><th>说明</th><th>格式符</th><th>说明</th></tr></thead><tbody><tr><td>%Y</td><td>4 位数字表示年份</td><td>%y</td><td>表示两位数字表示年份</td></tr><tr><td>%M</td><td>月名表示月份（January, ……）</td><td>%m</td><td>两位数字表示月份(01, 02, ···)</td></tr><tr><td>%b</td><td>缩写的月名(Jan., Feb., ······)</td><td>%c</td><td>数字表示月份 (1, 2, 3, ···)</td></tr><tr><td>%D</td><td>英文后缀表示月中的天数 (1st, 2nd, 3rd, ···)</td><td>%d</td><td>两位数字表示月中的天数 (01, 02, ···)</td></tr><tr><td>%e</td><td>数字形式表示月中的天数 (1, 2, 3, 4, 5, ···)</td><td></td><td></td></tr><tr><td>%H</td><td>两位数字表示小数，24小时制 (01，02，···)</td><td>%h 和 %I</td><td>两位数字表示小时，12小时制 (01, 02, ···)</td></tr><tr><td>%k</td><td>数字形式的消失，24小时制 (1, 2, 3)</td><td>%l</td><td>数字形式表示小时，12小时制 (1，2，3，4，···)</td></tr><tr><td>%i</td><td>两位数字表示分钟 (00, 01, 02)</td><td>%S 和 %s</td><td>两位数字表示秒 (00, 01, 02, ···)</td></tr><tr><td>%W</td><td>一周中的星期名称 (Sunday, ···)</td><td>%a</td><td>一周中的星期缩写 (Sun., Mon., Tues., ···)</td></tr><tr><td>%w</td><td>以数字表示周中的天数 (0 &#x3D; Sunday, 1 &#x3D; Monday, ···)</td><td></td><td></td></tr><tr><td>%j</td><td>以 3 位数字表示年中的天数 (001, 002, ···)</td><td>%U</td><td>以数字表示年中的第几周，(1, 2, 3) 其中 Sunday 位周中第一天</td></tr><tr><td>%u</td><td>以数字表示年中的第几周，(1, 2, 3, ···) 其中Monday 为周中第一天</td><td></td><td></td></tr><tr><td>%T</td><td>24 小时制</td><td>%r</td><td>12 小时制</td></tr><tr><td>%p</td><td>AM 或 PM</td><td>%%</td><td>表示 %</td></tr></tbody></table><p>GET_FORMAT 函数中 date_type 和 format_type参数取值如下：</p><table><thead><tr><th>日期类型</th><th>格式化类型</th><th>返回的格式化字符串</th></tr></thead><tbody><tr><td>DATE</td><td>USA</td><td>%m.%d.%Y</td></tr><tr><td>DATE</td><td>JIS</td><td>%Y-%m-%d</td></tr><tr><td>DATE</td><td>ISO</td><td>%Y-%m-%d</td></tr><tr><td>DATE</td><td>EUR</td><td>%d.%m.%Y</td></tr><tr><td>DATE</td><td>INTERNAL</td><td>%Y%m%d</td></tr><tr><td>TIME</td><td>USA</td><td>%h:%i%s%p</td></tr><tr><td>TIME</td><td>JIS</td><td>%H:%i:%s</td></tr><tr><td>TIME</td><td>ISO</td><td>%H:%i:%s</td></tr><tr><td>TIME</td><td>EUR</td><td>%H.%i.%s</td></tr><tr><td>TIME</td><td>INTERNAL</td><td>%H%i%s</td></tr><tr><td>DATETIME</td><td>USA</td><td>%Y-%m-%d %H.%i.%s</td></tr><tr><td>DATETIME</td><td>JIS</td><td>%Y-%m-%d %H:%i:%s</td></tr><tr><td>DATETIME</td><td>ISO</td><td>%Y-%m-%d %H:%i:%s</td></tr><tr><td>DATETIME</td><td>EUR</td><td>%Y-%m-%d %H.%i.%s</td></tr><tr><td>DATETIME</td><td>INTERNAL</td><td>%Y%m%d %H%i%s</td></tr></tbody></table><h4 id="3-4-流程控制函数"><a href="#3-4-流程控制函数" class="headerlink" title="3.4 流程控制函数"></a>3.4 流程控制函数</h4><p>流程处理函数可以根据不同的条件，执行不同的处理流程，可以在 SQL 语句中实现不同的条件选择。MySQL 中的流程处理函数主要包括 IF()、IFNULL() 和 CASE() 函数。</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>IF(value, value1, value2)</td><td>如果value的值为 TRUE，返回 value1，否则返回value2</td></tr><tr><td>IFNULL(value1, value2)</td><td>如果 value1 不为 NULL，返回 value1，否则返回 value2</td></tr><tr><td>CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 ······[ELSE resultn] END</td><td>相当于 Java 的 if···else if···else</td></tr><tr><td>CASE expo WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 ……[ELSE 值n] END</td><td>相当于 Java 的 switch···case···</td></tr></tbody></table><h4 id="3-5-加密与解密函数"><a href="#3-5-加密与解密函数" class="headerlink" title="3.5 加密与解密函数"></a>3.5 加密与解密函数</h4><p>加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防止数据被他人窃取。这些函数在保证数据库安全时非常有用。</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>PASSWORD(str)</td><td>返回字符串 str 的加密版本，41位长的字符串。加密结果不可逆，常用于用户的密码加密。(8.0 已弃用)</td></tr><tr><td>MD5(str)</td><td>返回字符串 str 的 md5 加密后的值，也是一种加密方式。若参数为 NULL，则会返回 NULL。</td></tr><tr><td>SHA(str)</td><td>从原明文密码 str 计算并返回加密后的密码字符串，当参数为 NULL 时，返回 NULL。SHA 加密算法比 MD5 更加安全。</td></tr><tr><td>ENCODE(value, password_seed)</td><td>返回使用 password_seed 作为加密密码加密 value。</td></tr><tr><td>DECODE(value, password_seed)</td><td>返回使用 password_seed 作为加密密码解密 value。</td></tr></tbody></table><h4 id="3-6-MySQL-信息函数"><a href="#3-6-MySQL-信息函数" class="headerlink" title="3.6 MySQL 信息函数"></a>3.6 MySQL 信息函数</h4><p>MySQL 中内置了一些可以查询 MySQL 信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地对数据库进行维护工作。</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>VERSION()</td><td>返回当前 MySQL 的版本号</td></tr><tr><td>CONNECTION_ID()</td><td>返回当前 MySQL 服务器的连接数</td></tr><tr><td>DATABASE(), SCHEMA()</td><td>返回 MySQL 命令行当前所在的数据库</td></tr><tr><td>USER(), CURRENT_USER(), SYSTEM_USER(), SESSION_USER()</td><td>返回当前连接 MySQL 的用户名，返回结果格式为“主机名@用户名”</td></tr><tr><td>CHARSET(value)</td><td>返回字符串 value 自变量的字符集</td></tr><tr><td>COLLATION(value)</td><td>返回字符串 value 的比较规则</td></tr></tbody></table><h4 id="3-7-其他函数"><a href="#3-7-其他函数" class="headerlink" title="3.7 其他函数"></a>3.7 其他函数</h4><p>MySQL 中有些函数无法对其进行具体分类，但是这些函数在 MySQL 的开发和运维过程中也是不容忽视的。</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>FORMAT(value, n)</td><td>返回对数字 value 进行格式化后的结果数据。n 表示四舍五入后保留到小数点后 n 位</td></tr><tr><td>CONV(value, from, to)</td><td>将 value 的值进行不同进制之间的转换</td></tr><tr><td>INET_ATON(ipvalue)</td><td>将以点分隔的 IP 地址转化为一个数字</td></tr><tr><td>INET_NTOA(value)</td><td>将数字形式的 IP 地址转化为以点分隔的 IP 地址</td></tr><tr><td>BENCHMARK(n, expr)</td><td>将表达式 expr 重复执行 n 次。用于测试 MySQL 处理 expr 表达式所耗费的时间</td></tr><tr><td>CONVERT(value USING char_code)</td><td>将 value 所使用的字符编码修改为 char_code</td></tr></tbody></table><h3 id="4-聚合函数"><a href="#4-聚合函数" class="headerlink" title="4. 聚合函数"></a>4. 聚合函数</h3><p>聚合函数也叫聚集、分组函数，它是对一组数据进行汇总的函数，输入的是一组数据的集合，输出的是单个值。<strong>聚合函数不能嵌套</strong>。          </p><h4 id="4-1-MySQL-中常用的聚合函数类型："><a href="#4-1-MySQL-中常用的聚合函数类型：" class="headerlink" title="4.1 MySQL 中常用的聚合函数类型："></a>4.1 MySQL 中常用的聚合函数类型：</h4><ul><li><p>AVG() 和 SUM()</p><p>  只适用于数值类型的字段或变量</p></li><li><p>MAX() 和 MIN()</p><p>  适用于数值类型、字符串类型、日期时间类型的字段或变量</p></li><li><p>COUNT()</p><p>  作用：计算制定字段在查询结果中出现的个数</p><p>  计算表中有多少条记录：<code>COUNT(*)、COUNT(1)</code>。COUNT(具体字段) 并不能准确的计算出表中记录条数，因为有可能为 NULL。</p><p>  <code>AVG = SUM / COUNT</code></p></li></ul><h4 id="4-2-GROUP-BY-的使用"><a href="#4-2-GROUP-BY-的使用" class="headerlink" title="4.2 GROUP BY 的使用"></a>4.2 GROUP BY 的使用</h4><p>使用 GROUP BY 子句将表中的数据分成若干组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, group_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span>   </span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> group_by_expression]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span>];</span><br></pre></td></tr></table></figure><p>:::tip</p><p>SELECT 中出现的非组函数的字段必须声明在 GROUP BY 中。</p><p>反之，GROUP BY 中生命的字段可以不出现在 SELECT 中。</p><p>:::</p><p><strong>GROUP BY 中使用 WITH ROLLUP</strong></p><p>使用 WITH ROLLUP 关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的综合，即统计记录数量。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, group_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> group_by_expression <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>];</span><br></pre></td></tr></table></figure><p>:::tip</p><p>当使用 ROLLUP时，不能同时使用 ORDER BY 子句进行结果排序，即 ROLLUP 和 ORDER BY 是互相排斥的。</p><p>:::</p><h4 id="4-3-HAVING-的使用"><a href="#4-3-HAVING-的使用" class="headerlink" title="4.3 HAVING 的使用"></a>4.3 HAVING 的使用</h4><p>过滤分组：HAVING 子句</p><ol><li>行已被分组。</li><li>使用了聚合函数。</li><li>满足 HAVING 子句中条件的分组将被显示。</li><li>HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, group_function</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> group_by_expression]</span><br><span class="line">[<span class="keyword">HAVING</span> group_condition]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span>];</span><br></pre></td></tr></table></figure><p><strong>WHERE 和 HAVING 的对比</strong></p><p>区别一：<strong>WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件</strong>。</p><p>这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为，在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成的。另外，WHERE 排除的记录不在包括在分组中。</p><p>区别二：<strong>如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接后筛选</strong>。</p><p>这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>WHERE</td><td>先筛选数据在关联，执行效率高</td><td>不能使用分组中的计算函数进行筛选</td></tr><tr><td>HAVING</td><td>可以使用分组中的计算函数</td><td>在最后的结果集中进行筛选，执行效率较低</td></tr></tbody></table><p> 开发中的选择：</p><p>WHERE 和 HAVING 也不是互相排斥的，可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组统计函数的条件用 HAVING，普通条件用 WHERE。这样，既利用了 WHERE 条件的高效快速，又发挥了HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别。</p><h4 id="4-4-SQL-语句的执行过程"><a href="#4-4-SQL-语句的执行过程" class="headerlink" title="4.4 SQL 语句的执行过程"></a>4.4 SQL 语句的执行过程</h4><p>查询的结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, group_function</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line">[<span class="keyword">LEFT</span> <span class="operator">/</span> <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> <span class="keyword">condition</span>]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> group_by_expression]</span><br><span class="line">[<span class="keyword">HAVING</span> group_condition]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span> <span class="keyword">ASC</span> <span class="operator">/</span> <span class="keyword">DESC</span>]</span><br><span class="line">[LIMIT pageNum, pageSize];</span><br></pre></td></tr></table></figure><p>SELECT 执行顺序：</p><ol><li><p>关键字的顺序是不能颠倒的：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> ... <span class="keyword">GROUP</span> <span class="keyword">BY</span> ... <span class="keyword">HAVING</span> ... <span class="keyword">ORDER</span> <span class="keyword">BY</span> ... LIMIT ...</span><br></pre></td></tr></table></figure></li><li><p>SELECT 语句的执行顺序：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">HAVING</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">DISTINCT</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">-</span><span class="operator">&gt;</span> LIMIT</span><br></pre></td></tr></table></figure> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> left_table</span><br><span class="line"><span class="keyword">ON</span> join_condition</span><br><span class="line"><span class="keyword">LEFT</span> <span class="operator">/</span> <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> right_table</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> group_by_list</span><br><span class="line"><span class="keyword">HAVING</span> having_condition</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DISTINCT</span> select_list</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_by_condition</span><br><span class="line">LIMIT limit_number;</span><br></pre></td></tr></table></figure><p> 在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。</p></li><li><p>SQL 的执行原理</p><p> SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p><ol><li>首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt1-1；</li><li>通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；</li><li>添加外部行。如果使用的是左连接、右连接或者全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。</li></ol><p> 当然如果我们操作的是两张以上的表，还会重复上面的步骤，知道所有表都被处理完为止。这个过程得到是我们的原始数据。</p><p> 当我们拿到了查询数据表的原始数据，也就是最终的虚拟表 vt1，就可以在此基础上再进行 WHERE 阶段。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表 vt2。</p><p> 然后进入第三步和第四步，也就是 GROUP 和 HAVING 阶段。在这个阶段中，实际上是在虚拟表 vt2 的基础上进行分组和分组过滤，得到中间的虚拟表 vt3 和 vt4。</p><p> 当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 SELECT 和 DISTINCT 阶段。</p><p> 首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表 vt5-1 和 vt5-2。</p><p> 当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 ORDER BY 阶段，得到虚拟表 vt6。</p><p> 最后在 vt6 的基础上，取出指定行的记录，也就是 LIMIT 阶段，得到最终的结果，对应的是虚拟表 vt7。</p><p> 当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。</p></li></ol><h2 id="八、子查询"><a href="#八、子查询" class="headerlink" title="八、子查询"></a>八、子查询</h2><h3 id="1-子查询的基本使用"><a href="#1-子查询的基本使用" class="headerlink" title="1. 子查询的基本使用"></a>1. 子查询的基本使用</h3><ul><li><p>子查询的基本语法结构：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> select_list</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">WHERE</span> expr operator</span><br><span class="line">(<span class="keyword">SELECT</span> select_list</span><br><span class="line">                   <span class="keyword">FROM</span> <span class="keyword">table</span>);</span><br></pre></td></tr></table></figure></li><li><p>子查询在主查询之前一次执行完成。</p></li><li><p>子查询的结果被主查询使用。</p></li><li><p>注意事项：</p><ul><li>子查询要包含在括号内</li><li>将子查询放在比较条件的右侧</li><li>单行操作符对应单行子查询，多行操作符对应多行子查询</li></ul></li></ul><h3 id="2-子查询的分类"><a href="#2-子查询的分类" class="headerlink" title="2. 子查询的分类"></a>2. 子查询的分类</h3><p>按子查询的结果返回一条还是多条记录分：</p><ul><li>单行子查询</li><li>多行子查询</li></ul><p>按子查询是否被执行多次分：</p><ul><li>相关子查询</li><li>不相关子查询</li></ul><p>子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询。同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询。</p><p>单行子查询比较操作符：</p><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>&#x3D;</td><td>Equal to</td></tr><tr><td>&gt;</td><td>Greater than</td></tr><tr><td>&gt;&#x3D;</td><td>Greater than or equal to</td></tr><tr><td>&lt;</td><td>Less than</td></tr><tr><td>&lt;&#x3D;</td><td>Less than or equal to</td></tr><tr><td>&lt;&gt;</td><td>Not equal to</td></tr></tbody></table><p>多行子查询比较操作符：</p><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>IN</td><td>等于列表中的任意一个</td></tr><tr><td>ANY</td><td>需要和单行比较操作符一起使用，和子查询返回的某一个值比较</td></tr><tr><td>ALL</td><td>需要和单行比较操作符一起使用，和子查询返回的所有值比较</td></tr><tr><td>SOME</td><td>实际上是 ANY 的别名，作用相同，一般常使用 ANY</td></tr></tbody></table><p>相关子查询</p><p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为关联子查询。</p><p>相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2,...</span><br><span class="line"><span class="keyword">FROM</span> table1 <span class="keyword">outer</span></span><br><span class="line"><span class="keyword">WHERE</span> column1 operator</span><br><span class="line">(<span class="keyword">SELECT</span> column1, column2</span><br><span class="line">                   <span class="keyword">FROM</span> table2</span><br><span class="line">                   <span class="keyword">WHERE</span> expr1 <span class="operator">=</span> outer.expr2);</span><br></pre></td></tr></table></figure><p>:::tip</p><p>在查询语句中，除了在 GROUP BY 和 LIMIT 中不能使用子查询，其他地方都能使用子查询</p><p>:::</p><h2 id="九、创建和管理表"><a href="#九、创建和管理表" class="headerlink" title="九、创建和管理表"></a>九、创建和管理表</h2><h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h3><h4 id="1-1-一条数据存储的过程"><a href="#1-1-一条数据存储的过程" class="headerlink" title="1.1 一条数据存储的过程"></a>1.1 一条数据存储的过程</h4><p>存储数据是处理数据的第一步。只有正确地把数据存储起来，才能进行有效的处理和分析。否则，只能是一团乱麻，无从下手。一个完整的数据存储过程总共有 4 步，分别是<strong>创建数据库、确认字段、创建数据表、插入数据</strong>。</p><p>从系统结构的层次看，MySQL 数据库系统从大到小依次是数据库<code>服务器</code>、<code>数据库</code>、<code>数据表</code>、数据表的<code>行和列</code>。所以需要先创建一个数据库，而不是直接创建数据表。</p><h4 id="1-2-标识符命名规则"><a href="#1-2-标识符命名规则" class="headerlink" title="1.2 标识符命名规则"></a>1.2 标识符命名规则</h4><ul><li>数据库名、表名不得超过 30 个字符，变量名限制为 29 个</li><li>必须只能包含 A-Z，a-z，0-9，_ 共 63 个字符</li><li>数据库名、表名、字段名等对象名中间不要包含空格</li><li>同一个 MySQL 软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li><li>必须保证字段没有和保留子、数据库系统或常用方法冲突。如果坚持使用，要在 SQL 中使用 &#96;&#96; 引起来</li><li>保持字段名和类型的一致性：在命名字段并为其制定数据类型的时候一定要保证一致性，加入数据类型在一个表里是整数，那在另一个表里可就别变成字符型了。</li></ul><h4 id="1-3-MySQL-中的数据类型"><a href="#1-3-MySQL-中的数据类型" class="headerlink" title="1.3 MySQL 中的数据类型"></a>1.3 MySQL 中的数据类型</h4><table><thead><tr><th>类型</th><th>类型举例</th></tr></thead><tbody><tr><td>整数类型</td><td>TINYINT、SMALLINT、MEDIUMINT、INT (或 INTEGER)、BIGINT</td></tr><tr><td>浮点类型</td><td>FLOAT、DOUBLE</td></tr><tr><td>定点数类型</td><td>DECIMAL</td></tr><tr><td>位类型</td><td>BIT</td></tr><tr><td>日期时间类型</td><td>YEAR、TIME、DATE、DATETIME、TIMESTAMP</td></tr><tr><td>文本字符串类型</td><td>CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td></tr><tr><td>枚举类型</td><td>ENUM</td></tr><tr><td>集合类型</td><td>SET</td></tr><tr><td>二进制字符串类型</td><td>BINARY、VAEBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td></tr><tr><td>JSON类型</td><td>JSON 对象、JSON 数组</td></tr><tr><td>空间数据类型</td><td>单值：GEOMETRY、POINT、LINESTRING、POLYGON；<br />集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</td></tr></tbody></table><p>其中，常用的几类类型介绍如下：</p><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>INT</td><td>从 -2<sup>31</sup> 到 2<sup>31</sup> - 1 的整型数据。存储大小为 4 个字节</td></tr><tr><td>CHAR(size)</td><td>定长字符数据。若未指定，默认为 1 个字符，最大长度 255</td></tr><tr><td>VARCHAR(size)</td><td>可变长字符数据，根据字符串实际长度保存，必须指定长度</td></tr><tr><td>FLOAT(M, D)</td><td>单精度，占用 4 个字节，M &#x3D; 整数位 + 小数位，D &#x3D; 小数位。D ≤ M ≤ 255，0 ≤ D ≤ 30，默认 M + D ≤ 6</td></tr><tr><td>DOUBLE(M, D)</td><td>双精度，占用 8 个字节，D ≤ M ≤ 255，0 ≤ D ≤ 30，默认 M + D ≤ 15</td></tr><tr><td>DECIMAL(M, D)</td><td>高精度小数，占用 M + 2 个字节，D ≤ M ≤ 65，0 ≤ D ≤ 30，最大取值范围与 DOUBLE 相同</td></tr><tr><td>DATE</td><td>日期型数据，格式 ‘YYYY-MM-DD’</td></tr><tr><td>BLOB</td><td>二进制形式的长文本数据，最大可达 4G</td></tr><tr><td>TEXT</td><td>长文本数据，最大可达 4G</td></tr></tbody></table><h3 id="2-创建和管理数据库"><a href="#2-创建和管理数据库" class="headerlink" title="2. 创建和管理数据库"></a>2. 创建和管理数据库</h3><h4 id="2-1-创建数据库"><a href="#2-1-创建数据库" class="headerlink" title="2.1 创建数据库"></a>2.1 创建数据库</h4><ul><li><p>方式一：创建数据库</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名；</span><br></pre></td></tr></table></figure></li><li><p>方式二：创建数据库并指定字符集</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集；</span><br></pre></td></tr></table></figure></li><li><p>方式三：判断数据库是否已经存在，不存在则创建数据库 (推荐)</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 数据库名；</span><br></pre></td></tr></table></figure></li></ul><p>如果 MySQL 中已经存在相关的数据库，则忽略创建语句，不再创建数据库。</p><p>:::tip</p><p>DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的。</p><p>:::  </p><h4 id="2-2-使用数据库"><a href="#2-2-使用数据库" class="headerlink" title="2.2 使用数据库"></a>2.2 使用数据库</h4><ul><li><p>查看当前所有的数据库</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASE;</span><br></pre></td></tr></table></figure></li><li><p>查看当前正在使用的数据库</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br></pre></td></tr></table></figure></li><li><p>查看置顶库下所有的表</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES <span class="keyword">FROM</span> 数据库名;</span><br></pre></td></tr></table></figure></li><li><p>查看数据库的创建信息</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名\G</span><br></pre></td></tr></table></figure></li><li><p>使用、切换数据库</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-修改数据库"><a href="#2-3-修改数据库" class="headerlink" title="2.3 修改数据库"></a>2.3 修改数据库</h4><ul><li><p>更改数据库字符集</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集; #比如：gbk、utf 等</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-4-删除数据库"><a href="#2-4-删除数据库" class="headerlink" title="2.4 删除数据库"></a>2.4 删除数据库</h4><ul><li><p>方式一：删除指定的数据库</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE 数据库名;</span><br></pre></td></tr></table></figure></li><li><p>方式二：删除指定的数据库 (推荐)</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> 数据库名;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-创建和管理表"><a href="#3-创建和管理表" class="headerlink" title="3. 创建和管理表"></a>3. 创建和管理表</h3><h4 id="3-1-创建表"><a href="#3-1-创建表" class="headerlink" title="3.1 创建表"></a>3.1 创建表</h4><p>方式一：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 表名(</span><br><span class="line">字段<span class="number">1</span>，数据类型 [约束条件] [默认值],</span><br><span class="line">  字段<span class="number">2</span>，数据类型 [约束条件] [默认值],</span><br><span class="line">    字段<span class="number">3</span>，数据类型 [约束条件] [默认值],</span><br><span class="line">    ……</span><br><span class="line">  [表约束条件]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 表名 </span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span> </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><p>将查询结果作为表数据进行创建。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> 表名;#显示表结构</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名\G #查看数据表结构和创建时的详细语句等</span><br></pre></td></tr></table></figure><h4 id="3-2-修改表"><a href="#3-2-修改表" class="headerlink" title="3.2 修改表"></a>3.2 修改表</h4><p>使用 ALTER TABLE 语句可以实现：</p><ul><li>向已有的表中添加列</li><li>修改现有表中的列</li><li>删除现有表中的列</li><li>重命名现有表中的列</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#添加字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 字段名 字段类型 <span class="keyword">FIRST</span> <span class="operator">/</span> AFTER 字段名; #<span class="keyword">FIRST</span> 表示添加到最前面，AFTER 指定添加到某字段后面</span><br><span class="line">#修改字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名</span><br><span class="line">#重命字段名</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 字段名</span><br><span class="line">#删除字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> 字段名</span><br></pre></td></tr></table></figure><h4 id="3-3-重命名表"><a href="#3-3-重命名表" class="headerlink" title="3.3 重命名表"></a>3.3 重命名表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> oldName <span class="keyword">TO</span> newName;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> oldName RENAME <span class="keyword">TO</span> newName;</span><br></pre></td></tr></table></figure><h4 id="3-4-删除表"><a href="#3-4-删除表" class="headerlink" title="3.4 删除表"></a>3.4 删除表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> 表名;</span><br></pre></td></tr></table></figure><p>:::warning</p><p>DROP TABLE 语句不能回滚</p><p>:::</p><h4 id="3-5-清空表"><a href="#3-5-清空表" class="headerlink" title="3.5 清空表"></a>3.5 清空表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名；</span><br><span class="line">或</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><p>:::warning</p><p>TRUNCATE TABLE 语句不能回滚</p><p>:::</p><h3 id="4-DCL-中的-COMMIT-和-ROLLBACK-的使用"><a href="#4-DCL-中的-COMMIT-和-ROLLBACK-的使用" class="headerlink" title="4. DCL 中的 COMMIT 和 ROLLBACK 的使用"></a>4. DCL 中的 COMMIT 和 ROLLBACK 的使用</h3><p><strong>COMMIT</strong>：提交数据。一旦执行 COMMIT，则数据被永久的保存在了数据库中，意味着数据不可以回滚。</p><p><strong>ROLLBACK</strong>：回滚数据。一旦执行 ROLLBACK，则可以实现数据的回滚。回滚到最近的一次 COMMIT 之后。</p><p><strong>DDL 和 DML 说明：</strong></p><ol><li>DDL 的操作一旦执行，就不可以回滚。指令 SET autocommit &#x3D; FALSE 对 DDL 无效。因为在执行完 DDL 之后，一定回执行一次 COMMIT。而此时 COMMIT 操作不受 SET autocommit &#x3D; FALSE 的影响。</li><li>DML 的操作默认情况也是一旦执行就不可回滚。但是可以在执行 DML 之前执行 SET  autocommit &#x3D; FALSE，则执行的 DML 操作就可以实现回滚。</li></ol><blockquote><p>阿里开发规范：</p><p>【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事物日志资源少，但 TRUNCATE 无事物且不出发 TRIGGER，有可能造成事故，故不建议再开发代码中使用此语句。</p><p>说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p></blockquote><h3 id="5-阿里巴巴《Java-开发手册》之-MySQL-字段命名"><a href="#5-阿里巴巴《Java-开发手册》之-MySQL-字段命名" class="headerlink" title="5. 阿里巴巴《Java 开发手册》之 MySQL 字段命名"></a>5. 阿里巴巴《Java 开发手册》之 MySQL 字段命名</h3><ul><li><p>【强制】表名、字段名必须使用小写字母或数字， 禁止出现数字开头，禁止两个下划线中间只<br>  出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p><ul><li>正例： getter_admin， task_config， level3_name</li><li>反例： GetterAdmin， taskConfig， level_3_name</li></ul></li><li><p>【强制】禁用保留字，如 desc、 range、 match、 delayed 等， 请参考 MySQL 官方保留字。</p></li><li><p>【强制】表必备三字段： id, gmt_create, gmt_modified。</p><ul><li>说明： 其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。 gmt_create,<br>  gmt_modified 的类型均为 date_time 类型。</li></ul></li><li><p>【推荐】表的命名最好是加上“业务名称_表的作用”。</p><ul><li>正例： tiger_task &#x2F; tiger_reader &#x2F; mpp_config</li></ul></li><li><p>【推荐】库名与应用名称尽量一致。</p></li><li><p>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</p><ul><li>正例： 如下表，其中无符号值可以避免误存负数， 且扩大了表示范围。</li></ul><table><thead><tr><th>对象</th><th>年龄区间</th><th>类型</th><th>字节</th><th>表示范围</th></tr></thead><tbody><tr><td>人</td><td>150岁之内</td><td>tinying unsigned</td><td>1</td><td>无符号值：0～255</td></tr><tr><td>龟</td><td>数百岁</td><td>smallint unsigned</td><td>2</td><td>无符号值：0～65535</td></tr><tr><td>恐龙化石</td><td>数千万年</td><td>int unsigned</td><td>4</td><td>无符号值：0～约 43 亿</td></tr><tr><td>太阳</td><td>约 50 亿年</td><td>bigint unsigned</td><td>8</td><td>无符号值：0～约 10<sup>19</sup></td></tr></tbody></table></li></ul><h3 id="6-如何理解清空表、删除表等操作需谨慎？"><a href="#6-如何理解清空表、删除表等操作需谨慎？" class="headerlink" title="6. 如何理解清空表、删除表等操作需谨慎？"></a>6. 如何理解清空表、删除表等操作需谨慎？</h3><p><strong>表删除</strong>操作将把表的定义和表中的数据一起删除，并且 MySQL在执行删除操作时，不会有任何的确认信息提示，因此执行行删除操作时应当慎重。在删除表前，最好对表中的数据进行备份，这样当操作失误时可以对数据进行恢复，以免造成无法挽回的后果。</p><p>同样的，在使用 <code>ALTER TABKE</code> 进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进行完整的备份，因为数据库的改变时无法撤销的，如果添加了一个不需要的字段，可以将其删除；相同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。</p><h3 id="7-MySQL-8-新特性——DDL-的原子化"><a href="#7-MySQL-8-新特性——DDL-的原子化" class="headerlink" title="7. MySQL 8 新特性——DDL 的原子化"></a>7. MySQL 8 新特性——DDL 的原子化</h3><p>在 MySQL 8.0 版本中，InnoDB 表的 DDL 支持事物完整性，即 DDL 操作要么成功要么回滚。DDL 操作回滚日志写入到 data dictionary 数据字典表 mysql.innodb_ddl_log (该表是隐藏的表，通过 show tables 无法看到) 中，用于回滚操作。通过设置参数，可将 DDL 操作日志打印输出到 MySQL 错误日志中。</p><h2 id="十、数据处理之增删改"><a href="#十、数据处理之增删改" class="headerlink" title="十、数据处理之增删改"></a>十、数据处理之增删改</h2><h3 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a>1. 插入数据</h3><h4 id="1-1-方式一：VALUES-的方式添加"><a href="#1-1-方式一：VALUES-的方式添加" class="headerlink" title="1.1 方式一：VALUES 的方式添加"></a>1.1 方式一：VALUES 的方式添加</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">VALUES</span> 中字段的顺序需要和表结构中字段的声明顺序一致</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名</span><br><span class="line"><span class="keyword">VALUES</span>(value1, value2, value3, ...);</span><br><span class="line"># <span class="keyword">value</span> 与 <span class="keyword">column</span> 保持一致</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(column1, column2, column3, ...)</span><br><span class="line"><span class="keyword">VALUES</span>(value1, value2, value3, ...);</span><br><span class="line"># 一次性插入多条数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(column1, column2, column3, ...)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(value1, value2, value3, ...),</span><br><span class="line">(value1, value2, value3, ...),</span><br><span class="line">(value1, value2, value3, ...);</span><br></pre></td></tr></table></figure><h4 id="1-2-方式二：将查询结果插入到表中"><a href="#1-2-方式二：将查询结果插入到表中" class="headerlink" title="1.2 方式二：将查询结果插入到表中"></a>1.2 方式二：将查询结果插入到表中</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table1</span><br><span class="line">(column1, column2, column3, ...)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">(column1, column2, column3, ...)</span><br><span class="line"><span class="keyword">FROM</span> table2</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><h3 id="2-删除数据"><a href="#2-删除数据" class="headerlink" title="2. 删除数据"></a>2. 删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1, column2 <span class="operator">=</span> value2, column3 <span class="operator">=</span> value3, ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><h3 id="3-修改数据"><a href="#3-修改数据" class="headerlink" title="3. 修改数据"></a>3. 修改数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><h3 id="4-MySQL-8-新特性——计算列"><a href="#4-MySQL-8-新特性——计算列" class="headerlink" title="4. MySQL 8 新特性——计算列"></a>4. MySQL 8 新特性——计算列</h3><p>什么叫计算列呢？简单来说就是某一列的值是通过别的列计算得到的。例如，a 列值为 1、b 列值为 2，c 列不需要手动插入，定义 a + b 的结果为 c 的值，那么 c 就是计算列，是通过别的列计算得到的。</p><p>在 MySQL 8.0 中，CREATE TABLE 和 ALTER TABLE 中都支持增加计算列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb1(</span><br><span class="line">id <span class="type">INT</span>,</span><br><span class="line">a <span class="type">INT</span>,</span><br><span class="line">b <span class="type">INT</span>,</span><br><span class="line">c <span class="type">INT</span> GENERATED ALWAYS <span class="keyword">AS</span> (a <span class="operator">+</span> b) VIRTUAL);</span><br></pre></td></tr></table></figure><p>计算列不管是插入数据还是修改数据时，相应的列的值发生改变，计算列也会跟着改变，而且插入时，不用插入计算列。</p><h2 id="十一、MySQL-数据类型精讲"><a href="#十一、MySQL-数据类型精讲" class="headerlink" title="十一、MySQL 数据类型精讲"></a>十一、MySQL 数据类型精讲</h2><h3 id="1-MySQL-中的数据类型"><a href="#1-MySQL-中的数据类型" class="headerlink" title="1. MySQL 中的数据类型"></a>1. MySQL 中的数据类型</h3><table><thead><tr><th>类型</th><th>类型举例</th></tr></thead><tbody><tr><td>整数类型</td><td>TINYINT、SMALLINT、MEDIUMINT、INT (或 INTEGER)、BIGINT</td></tr><tr><td>浮点类型</td><td>FLOAT、DOUBLE</td></tr><tr><td>定点数类型</td><td>DECIMAL</td></tr><tr><td>位类型</td><td>BIT</td></tr><tr><td>日期时间类型</td><td>YEAR、TIME、DATE、DATETIME、TIMESTAMP</td></tr><tr><td>文本字符串类型</td><td>CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td></tr><tr><td>枚举类型</td><td>ENUM</td></tr><tr><td>集合类型</td><td>SET</td></tr><tr><td>二进制字符串类型</td><td>BINARY、VAEBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td></tr><tr><td>JSON类型</td><td>JSON 对象、JSON 数组</td></tr><tr><td>空间数据类型</td><td>单值：GEOMETRY、POINT、LINESTRING、POLYGON；<br />集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</td></tr></tbody></table><p>常见数据类型的属性：</p><table><thead><tr><th>MySQL关键字</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>数据列可包含 NULL 值</td></tr><tr><td>NOT NULL</td><td>数据列不可包含 NULL 值</td></tr><tr><td>DEFAULT</td><td>默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键</td></tr><tr><td>AUTO_INCREMENT</td><td>自动递增，适用于整数类型</td></tr><tr><td>UNSIGNED</td><td>无符号</td></tr><tr><td>CHARACTER SET name</td><td>指定一个字符集</td></tr></tbody></table><h3 id="2-整数类型"><a href="#2-整数类型" class="headerlink" title="2. 整数类型"></a>2. 整数类型</h3><table><thead><tr><th align="left">整数类型</th><th align="center">字节</th><th align="center">有符号数取值范围</th><th align="left">无符号数取值范围</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="center">1</td><td align="center">-128～127</td><td align="left">0～255</td></tr><tr><td align="left">SMALLINT</td><td align="center">2</td><td align="center">-32768～32767</td><td align="left">0～65535</td></tr><tr><td align="left">MEDIUMINT</td><td align="center">3</td><td align="center">-8388608～8388607</td><td align="left">0～16777215</td></tr><tr><td align="left">INT (或 INTEGER)</td><td align="center">4</td><td align="center">-2147483648～2147483647</td><td align="left">0～4294967295</td></tr><tr><td align="left">BIGINT</td><td align="center">8</td><td align="center">-9223372036854775808～9223372036854775807</td><td align="left">0～18446744073709551615</td></tr></tbody></table><p><strong>可选属性：</strong></p><p>整数类型的可选属性有三个：</p><ul><li><p>M</p><p>  M 表示显示宽度，M 的取值范围时 (0, 255)。例如，int(5)：当数据宽度小于 5 位时，在数字前面需要用字符填满宽度。该项功能需要配合 ZEROFILL 使用，表示用 0 填满宽度，否则指定显示宽度无效。</p><p>  显示宽度不会对插入的数据有任何影响，如果插入的数据宽度超过了显示宽度限制，还是按照类型的实际宽度进行保存，即 <code>显示宽度与类型可以存储的值范围无关</code>。<strong>从 MySQL 8.0.17 开始，整数数据类型不推荐使用显示宽度属性</strong>。</p><p>  整数数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。</p></li><li><p>UNSINGED</p><p>  无符号类型 (非负)，所有的整数类型都有一个可选的属性 UNSIGNED (无符号属性)，无符号整数类型的最小取值为 0.所以，如果需要在 MySQL 数据库中保存非负整数值时，可以将整数类型设置为无符号类型。</p><p>  int 类型默认显示宽度为 int(11)，无符号 int 类型默认显示宽度为 int(10)。</p></li><li><p>ZEROFILL</p><p>  0 填充，(如果某列是 ZEROFILL，那么 MySQL 会自动为当前列添加 UNSIGNED 属性)，如果指定了 ZEROFILL 知识表示不够 M 位时，用 0 在左边填充，如果超过 M 位，只要不超过数据存储范围即可。</p><p>  原来，在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。int(2)、int(4)、int(8) 在磁盘上都是占用 4 bytes 的存储空间。也就是说，<strong>int(M)，必须和 UNSIGNED ZEROFILL 一起使用才有意义</strong>。如果整数值超过 M 位，就按照实际位数存储。知识无须再用字符 0 进行填充。</p></li></ul><p><strong>使用场景：</strong></p><p>TINYINT：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。</p><p>SMALLINT：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。</p><p>MEDIUMINT：用于较大整数的计算，比如车站每日的客流量等。</p><p>INT、INTEGER：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。</p><p>BIGINT：只有当处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等。</p><p><strong>如何选择：</strong></p><p>在评估用哪种整数类型的时候，需要考虑存储空间和可靠性的平衡问题：一方面，用占用字节数少的整数类型可以节省存储空间；另一方面，要是为了节省存储空间，使用的整数类型取值范围太小，一旦遇到超出取值范围的情况，就可能引起系统错误，影响可靠性。</p><p>在实际工作中，<strong>系统故障产生的成本远远超过增加几个字段存储空间所产生的成本</strong>。所以，建议首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。 </p><h3 id="3-浮点类型"><a href="#3-浮点类型" class="headerlink" title="3. 浮点类型"></a>3. 浮点类型</h3><h4 id="3-1-类型介绍"><a href="#3-1-类型介绍" class="headerlink" title="3.1 类型介绍"></a>3.1 类型介绍</h4><p>浮点数和定点数类型的特点是可以处理小数，你可以把整数看成小数的一个 特例。因此，浮点数和定点数的使用场景，比整数大多了。MySQL 支持的浮点数类型，分别是 FLOAT、DOUBLE、REAL。</p><ul><li><p>FLOAT 表示单精度浮点数；</p></li><li><p>DOUBLE 表示双精度浮点数；</p><table><thead><tr><th align="center">类型</th><th align="center">有符号数取值范围</th><th align="center">无符号数取值范围</th><th align="center">占用字节数</th></tr></thead><tbody><tr><td align="center">FLOAT</td><td align="center">(-3.402823466E+38, -1.175494351E), 0, (1.175494351E-38, 3.402823466351E+38)</td><td align="center">0, (1.175494351E-38, 3.402823466351E+38)</td><td align="center">4</td></tr><tr><td align="center">DOUBLE</td><td align="center">(-1.7976931348623157E+308, -2.225073858072014E-308), 0, (2.2250738585072014E-308, 1.7976931348623157E+308)</td><td align="center">0, (2.225073858072014E-308, 1.7976931348623157E+308)</td><td align="center">8</td></tr></tbody></table></li><li><p>REAL 默认是 DOUBLE。如果把 SQL 模式设定为启用 <code>REAL_AS_FLOAT</code>，那么，MySQL 就认为 REAL 是 FLOAT。如果要启用 <code>REAL_AS_FLOAT</code>，就可以通过一下 SQL 语句实现：</p><p>  <code>SET sql_mode = &quot;REAL_AS_FLOAT&quot;;</code></p></li></ul><p><strong>问题1</strong>：FLOAT 和 DOUBLE 这两种数据类型的区别是什么？</p><p>FLOAT 占用字节数少，取值范围更小；DOUBLE 占用字节数多，取值范围也大。</p><p><strong>问题2</strong>：为什么浮点数类型的无符号取值范围，只相当于有符号数取值范围的一半，也就是只相当于有符号数取值范围大于等于零的部分呢？</p><p>MySQL 存储浮点数的格式为：<code>符号(S)</code>、<code>尾数(M)</code>、和<code>阶码(E)</code>。因此，无论有没有符号，MySQL 的浮点数都会存储表示符号的部分。因此，所谓的无符号取值范围，其实就是有符号数取值范围大于等于零的部分。</p><h4 id="3-2-数据精度说明"><a href="#3-2-数据精度说明" class="headerlink" title="3.2 数据精度说明"></a>3.2 数据精度说明</h4><p>对于浮点类型，在 MySQL 中单精度值使用 4 个字节，双精度值使用 8 个字节。</p><ul><li><p>MySQL 允许使用非标准语法 (其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么用)：</p><p>  FLOAT(M, D) 或 DOUBLE(M, D)。这里，M 称为精度，D 称为标度。(M, D) 中 M &#x3D; 整数位 + 小数位，D &#x3D; 小数位。D ≤ M ≤ 255, 0 ≤ D ≤ 30</p></li><li><p>FLOAT 和 DOUBLE 类型在不指定 (M, D) 时，默认会按照实际的精度 (由实际的硬件和操作系统决定) 来显示。</p></li><li><p>说明：浮点类型，也可以加 UNSIGNED，但是不会改变数据范围，例如：FLOAT(3, 2) UNSIGNED 仍然只能表示 0 ～ 9099 的范围。</p></li><li><p>不管是否显式设置了精度 (M, D)，这里 MySQL 的处理方案如下：</p><ul><li>如果存储时，整数部分超出了范围，MySQL 就会报错，不允许存这样的值</li><li>如果存储时，小数点部分若超出范围，就分以下情况：<ul><li>若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。例如在 FLOAT(5, 2) 列内插入 999.009，近似结果是 999.01。</li><li>若四舍五入后，整数部分超出范围，则 MySQL 报错，并拒绝处理。如 FLOAT(5, 2) 列内插入 999.995 和 -99.995 都会报错。</li></ul></li></ul></li><li><p>从 MySQL 8.0.17 开始，FLOAT(M, D) 和 DOUBLE(M, D) 用法在官方文档中已经明确不推荐使用，将来可能被移除。另外，关于浮点型 FLOAT 和 DOUBLE 的 UNSIGNED 也不推荐使用了，将来也可能被移除。</p></li></ul><h4 id="3-3-精度误差说明"><a href="#3-3-精度误差说明" class="headerlink" title="3.3 精度误差说明"></a>3.3 精度误差说明</h4><p>浮点数类型有个缺陷，就是不精准。比如：设计一个表，有 price 这个字段，插入值分别为 0.47, 0.44, 0.19，期待的运行结果是：0.47 + 0.44 + 0.19 &#x3D; 1.1。但是使用 sum() 查询结果为 1.0999999999999999。</p><p>虽然误差很小，但是确实存在，为什么会存在这样的误差？问题还是出现在 MySQL 对浮点类型数据的存储方式上。</p><p>MySQL 用 4 个字节存储 FLOAT 类型数据，用 8 个字节来存储 DOUBLE 类型数据。无论哪个，都是采用二进制的方式来进行存储的。比如 9.625，用二进制来表示，就是 1001.101，或者表达成 1.001101× 2<sup>3</sup>。如果尾数不是 0 或 5 (比如 9.624)，就无法使用一个二进制数来精确表达。进而，就只好在取值允许的范围内进行四舍五入。</p><p>在编程中，如果用到浮点数，要特别注意误差问题：<strong>因为浮点数是不准确的，所以要避免使用 &#x3D; 来判断两个数是否相等</strong>。同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成不可挽回的损失。那么，MySQL 有没有精确的数据类型呢？当然有，这就是定点数类型：<strong>DECIMAL</strong>。</p><h3 id="4-定点数类型"><a href="#4-定点数类型" class="headerlink" title="4. 定点数类型"></a>4. 定点数类型</h3><h4 id="4-1-类型介绍"><a href="#4-1-类型介绍" class="headerlink" title="4.1 类型介绍"></a>4.1 类型介绍</h4><ul><li><p>MySQL 中的定点数类型只有 DECIMAL 一种类型。</p><table><thead><tr><th align="center">数据类型</th><th align="center">字节数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">DECIMAL(M, D), DEC, NUMERIC</td><td align="center">M + 2 字节</td><td align="center">有效范围由 M 和 D 决定</td></tr></tbody></table><p>  使用 DECIMAL(M, D) 的方式表示高精度小数。其中，M 被称为精度，D 被称为标度。D ≤ M ≤ 65,0 ≤ D ≤30。D &lt; M。例如，定义 DECIMAL(5, 2) 的类型，表示该取值范围是 -999.99～999.99。</p></li><li><p>DECIMAL(M, D) 的最大取值范围与 DOUBLE 类型一样，但是有效的数据范围是由 M 和 D 决定的。DECIMAL 的存储空间并不是固定的，由精度值 M 决定，总共占用存储空间为 M + 2 个字节。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些。</p></li><li><p>定点数在 MySQL 内部是以字符串的形式进行存储，这就决定了它一定是精准的。</p></li><li><p>当 DECIMAL 类型不指定精度和标度时，其默认为 DECIMAL(10, 0)。当数据的精度超出了定点数类型的精度范围时，则 MySQL 同样会进行四舍五入处理。</p></li><li><p>浮点数 vs 定点数</p><ul><li>浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微笑误差的科学计算场景 (比如计算化学、分子建模、流体动力学等)</li><li>定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 (比如涉及金额计算的场景)</li></ul></li></ul><h4 id="4-2-开发中经验"><a href="#4-2-开发中经验" class="headerlink" title="4.2 开发中经验"></a>4.2 开发中经验</h4><blockquote><p>“由于 DECIMAL 数据类型的精准性，在我们的项目中，除了极少数 (比如商品编号) 用到整数类型外，其他的数值都用的是 DECIMAL，原因就是这个项目所处的零售行业，要求精准，一分钱也不能差。“——来自某项目经理</p></blockquote><h3 id="5-位类型：BIT"><a href="#5-位类型：BIT" class="headerlink" title="5. 位类型：BIT"></a>5. 位类型：BIT</h3><p>BIT 类型中存储的是二进制值，类似 010101。</p><table><thead><tr><th align="center">二进制字符串类型</th><th align="center">长度</th><th align="center">长度范围</th><th align="center">占用空间</th></tr></thead><tbody><tr><td align="center">BIT(M)</td><td align="center">M</td><td align="center">1 ≤ M ≤ 64</td><td align="center">约为 (M + 7) &#x2F; 8 个字节</td></tr></tbody></table><p>BIT 类型，如果没有指定 (M)，默认是 1 位。这个 1 位，表示只能存 1 位二进制值。这里 (M) 是表示二进制的位数，位数最小值为 1，最大值为 64。</p><p>注意：在向 BIT 类型的字段中插入数据时，一定要确保插入的数据在 BIT 类型支持的范围内。</p><h3 id="6-日期和时间类型"><a href="#6-日期和时间类型" class="headerlink" title="6. 日期和时间类型"></a>6. 日期和时间类型</h3><p>日期与时间是重要的信息，在我们的系统中，几乎所有的数据表都用得到。原因是客户需要知道数据的时间标签，从而进行数据查询、统计和处理。</p><p>MySQL 有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL 8.0 版本支持的日期和时间类型主要有：YEAR 类型、TIME 类型、DATE 类型、DATETIME 类型和 TIMESTAMP 类型。</p><ul><li>YEAR 类型通常用来表示年</li><li>DATE 类型通常用来表示年、月、日</li><li>TIME 类型通常用来表示时、分、秒</li><li>DATETIME 类型通常用来表示年、月、日、时、分、秒</li><li>TIMESTAMP 类型通常用来表示带时区的年、月、日、时、分、秒</li></ul><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">字节</th><th align="center">日期格式</th><th align="center">最小值</th><th align="center">最大值</th></tr></thead><tbody><tr><td align="center">YEAR</td><td align="center">年</td><td align="center">1</td><td align="center">YYYY 或 YY</td><td align="center">1901</td><td align="center">2155</td></tr><tr><td align="center">TIME</td><td align="center">时间</td><td align="center">3</td><td align="center">HH:MM:SS</td><td align="center">-838:59:59</td><td align="center">838:59:59</td></tr><tr><td align="center">DATE</td><td align="center">日期</td><td align="center">3</td><td align="center">YYYY-MM-DD</td><td align="center">1000-01-01</td><td align="center">9999-12-03</td></tr><tr><td align="center">DATETIME</td><td align="center">日期时间</td><td align="center">8</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">1000-01-01 00:00:00</td><td align="center">9999-12-31 23:59:59</td></tr><tr><td align="center">TIMESTAMP</td><td align="center">日期时间</td><td align="center">4</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">1979-01-01 00:00:00 UTC</td><td align="center">2038-1-19 03:14:07 UTC</td></tr></tbody></table><p>可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，要根据实际需要灵活选取。</p><p>为什么时间类型 TIME 的取值范围不是 -23:59:59～23:59:59 呢？</p><p>因为 MySQL 设计的 TIME 类型，不光表示一天之类的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过 24 小时。</p><h4 id="6-1-YEAR-类型"><a href="#6-1-YEAR-类型" class="headerlink" title="6.1 YEAR 类型"></a>6.1 YEAR 类型</h4><p>YEAR 类型用来表示年份，在所有的日期时间类型中所占用的存储空间最小，只需要 1 个字节的存储空间。</p><p>在 MySQL 中，YEAR 有以下几种存储格式：</p><ul><li>以 4 位字符串或数字格式表示 YEAR 类型，其格式为 YYYY，最小值为 1901，最大值为 2155。</li><li>以 2 位字符串格式表示 YEAR 类型，最小值为 00，最大值为 99。<ul><li>当取值为 01 到 69 时，表示 2001 到 2069；</li><li>当取值为 70 到 99 时，表示 1970 到 1999；</li><li>当取值整数的 0 或 00 添加的话，那么是 0000 年；</li><li>当取值是日期&#x2F;字符串的 ‘0’ 添加的话，是 2000 年。</li></ul></li></ul><p>从 MySQL 5.5.27 开始，2 位格式的YEAR 已经不推荐使用。YEAR 默认格式就是 “YYYY”，没必要写成 YEAE(4)，从 MySQL 8.0.19 开始，不推荐使用指定显示宽度的 YEAR(4) 数据类型。</p><h4 id="6-2-DATE-类型"><a href="#6-2-DATE-类型" class="headerlink" title="6.2 DATE 类型"></a>6.2 DATE 类型</h4><p>DATE 类型表示日期，没有时间部分，格式为 <code>YYYY-MM-DD</code>，其中 YYYY 表示年份，MM 表示月份，DD 表示日期。</p><p>需要 3 个字节的存储空间。在向 DATE 类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li>以 <code>YYYY-MM-DD</code> 格式或者 <code>YYYYMMDD</code> 格式表示的字符串日期，其最小取值为 1000-01-01，最大取值为 9999-12-03。<code>YYYYMMDD</code> 格式会被转化为 <code>YYYY-MM-DD</code> 格式。</li><li>以 <code>YY-MM-DD</code> 格式或者 <code>YYMMDD</code> 格式表示的字符串日期，此格式中，年份为两位数值或字符串满足 YEAR 类型的格式条件为：当年份取值为 00 到 69 时，会被转化为 2000 到 2069；当年份取值为 70 到 99 时，会被转化为 1970 到 1999。</li><li>使用 <code>CURRENT_DATE()</code> 或者 <code>NOW()</code> 函数，会插入当前系统的日期。</li></ul><h4 id="6-3-TIME-类型"><a href="#6-3-TIME-类型" class="headerlink" title="6.3 TIME 类型"></a>6.3 TIME 类型</h4><p>TIME 类型用来表示时间，不包含日期部分。在 MySQL 中，需要 3 个字节的存储空间来存储 TIME 类型的数据，可以使用 <code>HH:MM:SS</code> 格式来表示 TIME 类型，其中 HH 表示小时，MM 表示分钟，SS 表示秒。</p><p>在 MySQL 中，向 TIME 类型的字段插入数据时，也可以使用几种不同的格式。</p><ul><li><p>可以使用带有冒号的字符串</p><p>  比如 <code>&#39;D HH:MM:SS&#39;</code>、<code>&#39;HH:MM:SS&#39;</code>、<code>&#39;HH:MM&#39;</code>、<code>&#39;D HH:MM&#39;</code>、<code>&#39;D HH&#39;</code> 或 <code>&#39;SS&#39;</code> 格式，都能被正确得插入 TIME 类型的字段中。其中 D 表示天，其最小值为 0，最大值为 34。如果使用带有 D 格式的字符串插入 TIME 类型的字段时，D 会被转化为小时，计算格式为 <code>D * 24 + HH</code>。当使用带有冒号并且不带 D 的字符串表示时间时，表示当天的时间，比如 12:10 表示 12:10:00，而不是 00:12:10。</p></li><li><p>可以使用不带有冒号的字符串或者数字，格式为 <code>&#39;HHMMSS&#39;</code> 或 <code>HHMMSS</code>。</p><p>  如果插入一个不合法的字符串或者数字，MySQL 在存储数据时，会将其自动转化为 00:00:00 进行存储。比如 1210，MySQL 会将最右边的两位解析成秒，表示 00:12:10，而不是 12:10:00。</p></li><li><p>使用 <code>CURRENT_TIME()</code> 或者 <code>NOW()</code>，会插入当前系统的时间。</p></li></ul><h4 id="6-4-DATETIME-类型"><a href="#6-4-DATETIME-类型" class="headerlink" title="6.4 DATETIME 类型"></a>6.4 DATETIME 类型</h4><p>DATETIME 类型在所有的日期时间类型中占用的存储空间最大，总共需要 8 个字节的存储空间。在格式上为 DATE 类型和 TIME 类型的组合，可以表示为 <code>YYYY-MM-DD HH:MM:SS</code>，其中 YYYY 表示年份，MM 表示月份，DD 表示日期，HH 表示小时，MM 表示分钟，SS 表示秒。</p><p>在向 DATETIME 类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li>以 <code>YYYY-MM_DD HH:MM:SS</code> 格式或者 <code>YYMMDDHHMMSS</code> 格式的字符串插入 DATETIME 类型的字段时，最小值为 1000-01-01 00:00:00，最大值为 9999-12-03 23:59:59。<ul><li>以 <code>YYMMDDHHMMSS</code> 格式的数字插入 DATETIME 类型的字段时，会被转化为 <code>YYYY-MM_DD HH:MM:SS</code> 格式。</li></ul></li><li>以 <code>YYYY-MM_DD HH:MM:SS</code> 格式 或者 <code>YYMMDDHHMMSS</code> 格式的字符串插入 DATETIME 类型的字段时，两位数的年份规则符合 YEAR 类型的规则，00 到 69 表示 2000 到 2069；70 到 99 表示 1970 到 1999。</li><li>使用函数 <code>CURRENT_TIMESTAMP()</code> 和 <code>NOW()</code>，可以向 DATETIME 类型的字段插入系统的当前日期和时间。</li></ul><h4 id="6-5-TIMESTAMP-类型"><a href="#6-5-TIMESTAMP-类型" class="headerlink" title="6.5 TIMESTAMP 类型"></a>6.5 TIMESTAMP 类型</h4><p>TIMESTAMP 类型也可以表示日期时间，其显示格式与 DATETIME 类型相同，都是 <code>YYYY-MM_DD HH:MM:SS</code>，需要 4 个字节的存储空间。但是 TIMESTAMP 存储的时间范围比 DATETIME 要小很多，只能存储 “1970-01-01 00:00:01 UTC” 到 “2033-01-19 03:14:07 UTC” 之间的时间。其中，UTC 表示时间统一时间，也叫作世界标准时间。</p><ul><li><strong>存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用 TIMESTAMP 存储的同一个时间值，在不同的时区查询时会显示不同的时间</strong>。</li></ul><p>向 TIMESTAMP 类型的字段插入数据时，当插入的数据格式满足 YY-MM-DD HH:MM:SS 和 YYMMDDHHMMSS 时，两位数值的年份同样符合 YEAR 类型的规则条件，只不过表示的时间范围要小很多。</p><p>如果想 TIMESTAMP 类型的字段插入的时间超出了 TIMESTAMP 类型的范围，则 MySQL 会抛出错误信息。</p><p><strong>TIMESTAMP 和 DATETIME 的区别</strong>：</p><ul><li>TIMESTAMP 存储空间比较小，表示的日期时间范围也比较小</li><li>底层存储方式不同，TIMESTAMP 底层存储的是毫秒值，距离 1970-01-01 00:00:00 毫秒的毫秒值</li><li>两个日期比较大小或日期计算时，TIMESTAMP 更方便、更快</li><li>TIMESTAMP 和时区有关。TIMESTAMP 会根据用户的时区不同，显示不同的结果。而 DATETIME 则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。</li></ul><h4 id="6-6-开发中经验"><a href="#6-6-开发中经验" class="headerlink" title="6.6 开发中经验"></a>6.6 开发中经验</h4><p>用的最多的日期时间类型，就是 DATETIME。虽然 MySQL 也支持 YEAR (年)、TIME (时间)、DATE (日期) 以及 TIMESTAMP 类型，但是在实际项目中，尽量用 DATETIME 类型。因为这个数据类型包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。毕竟，如果日期时间信息分散在好几个字段，很不容易记，而且查询的时候，SQL 语句也会更加复杂。</p><p>此外，一般存注册时间、商品发布时间等，不建议使用 DATETIME 存储，而是使用<strong>时间戳</strong>，因为 DATETIME 虽然直观，但不便于计算。</p><h3 id="7-文本字符串类型"><a href="#7-文本字符串类型" class="headerlink" title="7. 文本字符串类型"></a>7. 文本字符串类型</h3><p>在实际的项目中，我们还经常遇到一种数据，就是字符串数据。</p><p>MySQL 中国，文本字符串总体上分为 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET 等类型。</p><table><thead><tr><th align="center">文本字符串类型</th><th align="center">值的长度</th><th align="center">长度范围</th><th align="center">占用的存储空间</th></tr></thead><tbody><tr><td align="center">CHAR(M)</td><td align="center">M</td><td align="center">0 ≤ M ≤ 255</td><td align="center">M个字节</td></tr><tr><td align="center">VARCHAR(M)</td><td align="center">M</td><td align="center">0 ≤ M ≤ 65535</td><td align="center">M + 1 个字节</td></tr><tr><td align="center">TINYTEXT</td><td align="center">L</td><td align="center">0 ≤ L ≤ 255</td><td align="center">L + 2 个字节</td></tr><tr><td align="center">TEXT</td><td align="center">L</td><td align="center">0 ≤ L ≤ 65535</td><td align="center">L + 2 个字节</td></tr><tr><td align="center">MEDIUMTEXT</td><td align="center">L</td><td align="center">0 ≤ L ≤ 16777215</td><td align="center">L + 3 个字节</td></tr><tr><td align="center">LONGTEXT</td><td align="center">L</td><td align="center">0 ≤ L ≤ 4294967295</td><td align="center">L + 4 个字节</td></tr><tr><td align="center">ENUM</td><td align="center">L</td><td align="center">1 ≤ L ≤ 65535</td><td align="center">1 或 2 个字节</td></tr><tr><td align="center">SET</td><td align="center">L</td><td align="center">0 ≤ L ≤ 64</td><td align="center">1，2，3，4 或 8 个字节</td></tr></tbody></table><h4 id="7-1-CHAR-与-VARCHAR-类型"><a href="#7-1-CHAR-与-VARCHAR-类型" class="headerlink" title="7.1 CHAR 与 VARCHAR 类型"></a>7.1 CHAR 与 VARCHAR 类型</h4><p>CHAR 和 VARCHAR 类型都可以存储比较短的字符串。</p><table><thead><tr><th align="center">字符串 (文本) 类型</th><th align="center">特点</th><th align="center">长度</th><th align="center">长度范围</th><th align="center">占用的存储空间</th></tr></thead><tbody><tr><td align="center">CHAR(M)</td><td align="center">固定长度</td><td align="center">M</td><td align="center">0 ≤ M ≤ 255</td><td align="center">M 个字节</td></tr><tr><td align="center">VARCHAR</td><td align="center">可变长度</td><td align="center">M</td><td align="center">0 ≤ M ≤ 65535</td><td align="center">(实际长度 + 1) 个字节</td></tr></tbody></table><p><strong>CHAR 类型</strong>：</p><ul><li>CHAR(M) 类型一般需要预先定义字符串长度。如果不指定 (M)，则表示长度默认是 1 个字符。</li><li>如果保存时，数据的实际长度比 CHAR 类型声明的长度小，则会在右侧填充空格以达到指定的长度。当 MySQL 检索 CHAR 类型的数据时，CHAR 类型的字段会去除尾部的空格。</li><li>定义 CHAR 类型字段时，声明的字段长度即为 CHAR 类型字段所占的存储空间的字节数。</li></ul><p><strong>VARCHAR 类型</strong>：</p><ul><li><p>VARCHAR(M) 定义时，必须指定长度 M，否则报错。</p></li><li><p>MySQL 4.0 版本以下，varchar(20): 指的是 20 字节，如果存放 UTF8 汉字时，只能存 6 个 (每个汉字 3 字节)；</p><p>  MySQL 5.0 版本以上，varchar(20): 指的是 20 字符。</p></li><li><p>检索 VARCHAR 类型的字段数据时，会保留数据尾部的空格。VARCHAR 类型的字段所占用的存储空间为字符串实际长度加 1 个字节。</p></li></ul><p><strong>哪些情况使用 CHAR 或 VARCHAR 更好</strong>？</p><table><thead><tr><th align="center">类型</th><th align="center">特点</th><th align="center">空间上</th><th align="center">时间上</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">CHAR(M)</td><td align="center">固定长度</td><td align="center">浪费存储空间</td><td align="center">效率高</td><td align="center">存储不大，速度要求高</td></tr><tr><td align="center">VARCHAR(M)</td><td align="center">可变长度</td><td align="center">节省存储空间</td><td align="center">效率低</td><td align="center">非 CHAR 的情况</td></tr></tbody></table><ul><li><p>情况1：存储很短的信息。</p><p>  比如门牌号码 101，201……这样很短的信息应该用 char，因为 varchar 还要占个 byte 用于存储信息长度，本来打算节约存储的，结果得不偿失。</p></li><li><p>情况2：固定长度的。</p><p>  比如使用 uuid 作为主键，那用 char 应该更合适。因为他固定长度，varchar 动态改变长度的特性就消失了，而且还要占个长度信息。</p></li><li><p>情况3：十分频繁改变 column。</p><p>  因为 varchar 每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于 char 来说是不需要的。</p></li><li><p>情况4：具体存储引擎的情况：</p><ul><li><code>MyISAM</code> 数据存储引擎和数据列：MyISAM 数据表，最好使用固定长度 (CHAR) 的数据列代替可变长度 (VARCHAR) 的数据列。这样使得整个表静态化，从而使数据检索更快，用空间换时间。</li><li><code>MEMORY</code> 存储引擎和数据列：MEMORY 数据表目前都适用固定长度的数据行存储，因此无论使用 CHAR 或 VARCHAR 列都没有关系，两者都是作为 CHAR 类型处理的。</li><li><code>InnoDB</code> 存储引擎，建议使用 VARCHAR 类型。因为对于 InnoDB 数据表，内部的行存储格式并没有区分固定长度和可变长度列 (所有数据行都使用指向数据列值的头指针)，而且<strong>主要影响性的因素是数据行使用的存储总量</strong>，由于 char 平均占用的空间多余 varchar，所以除了简短并且固定长度的，其他考虑 varchar。这样节省空间，对磁盘 I&#x2F;O 和数据存储总量比较好。</li></ul></li></ul><h4 id="7-2-TEXT-类型"><a href="#7-2-TEXT-类型" class="headerlink" title="7.2 TEXT 类型"></a>7.2 TEXT 类型</h4><p>在 MySQL 中，TEXT 用来保存文本类型的字符串，总共包含 4 种类型，分别为 TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT 类型。</p><p>在向 TEXT 类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和 VARCHAR 类型相同。</p><p>每种 TEXT 类型保存的数据长度和所占用的存储空间不同，如下：</p><table><thead><tr><th align="center">文本字符串类型</th><th align="center">特点</th><th align="center">长度</th><th align="center">长度范围</th><th align="center">占用的存储空间</th></tr></thead><tbody><tr><td align="center">TINYTEXT</td><td align="center">小文本、可变长度</td><td align="center">L</td><td align="center">0</td><td align="center">L + 2 个字节</td></tr><tr><td align="center">TEXT</td><td align="center">文本、可变长度</td><td align="center">L</td><td align="center">0 ≤ L ≤ 255</td><td align="center">L + 2 个字节</td></tr><tr><td align="center">MEDIUMTEXT</td><td align="center">中等文本、可变长度</td><td align="center">L</td><td align="center">0 ≤ L ≤ 65535</td><td align="center">L + 3 个字节</td></tr><tr><td align="center">LONGTEXT</td><td align="center">大文本、可变长度</td><td align="center">L</td><td align="center">0 ≤ L ≤ 4294967295 (相当于 4 GB)</td><td align="center">L + 4 个字节</td></tr></tbody></table><p><strong>由于实际存储的长度不确定，MySQL 不允许 TEXT 类型的字段做主键</strong>。遇到这种情况，只能采用 CHAR(M) 或 VARCHAR(M)。</p><p><strong>开发中经验</strong>：</p><p>TEXT 文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用 CHAR、VARCHAR 来替代。还有 TEXT 类型不用加默认值，加了也没用。而且 text 和 blob 类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含 TEXT 字段，建议单独分出去，单独用一个表。</p><h3 id="8-ENUM-类型"><a href="#8-ENUM-类型" class="headerlink" title="8. ENUM 类型"></a>8. ENUM 类型</h3><p>ENUM 类型也叫作枚举类型，ENUM 类型的取值范围需要定义字段时进行指定。设置字段值时，ENUM 类型只允许从成员中选取单个值，不能一次选取多个值。</p><p>其所需要的存储空间由定义 ENUM 类型时指定的成员个数决定。</p><table><thead><tr><th align="center">文本字符串类型</th><th align="center">长度</th><th align="center">长度范围</th><th align="center">占用的存储空间</th></tr></thead><tbody><tr><td align="center">ENUM</td><td align="center">L</td><td align="center">1 ≤ L ≤ 65535</td><td align="center">1 或 2 个字节</td></tr></tbody></table><ul><li>当 ENUM 类型包含 1～255 个成员时，需要 1 个字节的存储空间。</li><li>当 ENUM 类型包含 256～65535 个成员时，需要 2 个字节的存储空间。</li><li>ENUM 类型的成员个数的上限为 65535 个。</li></ul><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_enum(</span><br><span class="line">season ENUM(<span class="string">&#x27;春&#x27;</span>,<span class="string">&#x27;夏&#x27;</span>,<span class="string">&#x27;秋&#x27;</span>,<span class="string">&#x27;冬&#x27;</span>,<span class="string">&#x27;unknow&#x27;</span>)</span><br><span class="line">)；</span><br></pre></td></tr></table></figure><h3 id="9-SET-类型"><a href="#9-SET-类型" class="headerlink" title="9. SET 类型"></a>9. SET 类型</h3><p>SET 表示一个字符串对象，可以包含 0 个或多个成员，但成员个数的上限为 64。设置字段值时，可以取取值范围内的 0 个或多个值。</p><p>当 SET 类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：</p><table><thead><tr><th>成员个数范围 (L 表示实际成员个数)</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>1 ≤ L ≤ 8</td><td>1 个字节</td></tr><tr><td>9 ≤ L ≤ 16</td><td>2 个字节</td></tr><tr><td>17 ≤ L ≤ 24</td><td>3 个字节</td></tr><tr><td>25 ≤ L ≤ 32</td><td>4 个字节</td></tr><tr><td>33 ≤ L ≤ 64</td><td>8 个字节</td></tr></tbody></table><p>SET 类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET 类型在选取成员时，可以一次选择多个成员，这一点与 ENUM 类型不同。</p><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_set(</span><br><span class="line">s <span class="keyword">SET</span> (<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="10-二进制字符串类型"><a href="#10-二进制字符串类型" class="headerlink" title="10. 二进制字符串类型"></a>10. 二进制字符串类型</h3><p>MySQL 中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。</p><p>MySQL 中支持的二进制字符串类型主要包括 BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 类型。</p><p><strong>BINARY 与 VARBINBAY 类型</strong></p><p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，只是它们存储的是二进制字符串。</p><p>BINARY(M) 为固定长度的二进制字符串，M 表示最多能存储的字节数，取值范围是 0～255 个字符。如果位置定 (M)，表示只能存储 1 个字节。例如 BINATY(8)，表示最多能存储 8 个字节，如果字段值不足 (M) 个字节，将在右边填充’\0’ 以补齐指定长度。</p><p>VARBINARY(M) 为可变长度的二进制字符串，M 表示最多能存储的字节数，总字节数不能超过行的字节长度限制 65535，另外还要考虑额外字节开销，VARBINARY 类型的数据除了存储数据本身外，还需要 1 或 2 个字节来存储数据的字节数。VARBINARY 类型必须指定 (M)，否则报错。</p><table><thead><tr><th align="center">二进制字符串类型</th><th align="center">特点</th><th align="center">值的长度</th><th align="center">占用空间</th></tr></thead><tbody><tr><td align="center">BINARY(M)</td><td align="center">固定长度</td><td align="center">M (0 ≤ M ≤ 255)</td><td align="center">M 个字节</td></tr><tr><td align="center">VARBINARY(M)</td><td align="center">可变长度</td><td align="center">M (0 ≤ M ≤ 65535)</td><td align="center">M + 1 个字节</td></tr></tbody></table><p><strong>BLOB 类型</strong></p><p>BLOB 是一个二进制大对象，可以容纳可变数量的数据。</p><p>MySQL中的 BLOB 类型包括 TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 4 种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如图片、音频和视频等。</p><p>需要注意的是，在实际工作中，往往不会在 MySQL 数据库中使用 BLOB 类型存储大对象数据，通常会将图片、音频和视频文件存储到服务器磁盘上，并将图片、音频和视频的访问路径存储到 MySQL 中。</p><table><thead><tr><th align="center">二进制字符串类型</th><th align="center">值的长度</th><th align="center">长度范围</th><th align="center">占用空间</th></tr></thead><tbody><tr><td align="center">TINYBLOB</td><td align="center">L</td><td align="center">0 ≤ L ≤ 255</td><td align="center">L + 1 个字节</td></tr><tr><td align="center">BLOB</td><td align="center">L</td><td align="center">0 ≤ L ≤ 65535 (相当于 64 KB)</td><td align="center">L + 2 个字节</td></tr><tr><td align="center">MEDIUMBLOB</td><td align="center">L</td><td align="center">0 ≤ L ≤ 16777215 (相当于 16 MB)</td><td align="center">L + 3 个字节</td></tr><tr><td align="center">LONGBLOB</td><td align="center">L</td><td align="center">0 ≤ L ≤ 4294967295 (相当于 4 GB)</td><td align="center">L + 4 个字节</td></tr></tbody></table><p><strong>TEXT 和 BLOB 的使用注意事项</strong>：</p><p>在使用 text 和 blob 字段类型时要注意以下几点，以便更好的发挥数据库的性能。</p><ul><li>BLOB 和 TEXT 值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的“<strong>空洞</strong>”，以后填入这些“空洞”的记录可能长度不同。为了提高性能，建议定期使用 <code>OPTIMIZE TABLE</code> 功能对这类表进行碎片整理。</li><li>如果需要对大文本字段进行模糊查询，MySQL 提供了<strong>前缀索引</strong>。但是仍然要在不必要的时候避免检索大型的 BLOB 或 TEXT 值。例如 SELECT * 查询就不是很好的想法，除非你能确定作为约束条件的 WHERE 子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。</li><li>把 BLOB 或 TEXT 列<strong>分离到单独的表</strong>中。在某些环境下，如果把这些数据列移动到第二章数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会<strong>减少主表中的碎片</strong>，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过网络传输大量的 BLOB 或 TEXT 值。</li></ul><h3 id="11-JSON-类型"><a href="#11-JSON-类型" class="headerlink" title="11. JSON 类型"></a>11. JSON 类型</h3><p>JSON (JavaScript Object Notation) 是一种轻量级的<strong>数据交换格式</strong>。简介和清晰的层次结构使得 JSON 称为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。<strong>JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式</strong>。</p><p>在 MySQL 5.7 中，就已经支持 JSON 数据类型。在 MySQL 8.x 版本中，JSON 类型提供了可以进行自动验证的 JSON 文档和优化的存储结构，使得在 MySQL 中存储和读取 JSON 类型的数据更加方便的高效。</p><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建包含一个 JSON 类型的字段js 的表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_json(</span><br><span class="line">js json</span><br><span class="line">);</span><br><span class="line"># 向表中插入 JSON 数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_json (js)</span><br><span class="line"><span class="keyword">VALUEs</span>(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;tom&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;province&quot;:&quot;chongqing&quot;, &quot;city&quot;:&quot;fengdu&quot;&#125;&#125;&#x27;</span>);</span><br><span class="line"># 检索 JSON 类型的字段中数据的某个具体值时，可以使用 &quot;-&gt;&quot; 和 &quot;-&gt;&gt;&quot; 符号。</span><br><span class="line"><span class="keyword">SELECT</span> js <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.name&#x27;</span> <span class="keyword">AS</span> name, js <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.age&#x27;</span> <span class="keyword">AS</span> age, js <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.address.province&#x27;</span> <span class="keyword">AS</span> province, js <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.address.city&#x27;</span> <span class="keyword">AS</span> city <span class="keyword">FROM</span> test_json;</span><br></pre></td></tr></table></figure><h3 id="12-空间类型"><a href="#12-空间类型" class="headerlink" title="12. 空间类型"></a>12. 空间类型</h3><p>MySQL 空间类型扩展支持地理特征的生成、存储和分析。这里的地理特征表示世界上具有位置的任何东西，可以是一个实体，例如一座山；可以是空间，例如一座办公楼；也可以是一个可定义的位置，例如一个十字路口等。MySQL 中使用 <code>Geometry (几何)</code> 来表示所有地理特征。Geometry 指一个点或点的集合，代表世界上任何具有未知的事物。</p><p>MySQL 的空间数据类型 (Spatial Data Type) 对应于 OpenGIS 类，包括单值类型：GEOMETRY、POINT、LINESTRING、POLYGON 以及集合类型：MULTIPOINT、MULTILINESTRING、NULTIPOLYGON、GEOMETRYCOLLECTION。</p><ul><li>Geometry 是所有空间集合类型的基类，其他类型如 POINT、LINESTRING、POLYGON 都是 Geometry 的子类。<ul><li>Point，顾名思义就是点，又一个坐标值。例如 POINT(121.213342 31.234532)，POINT(30 10)，坐标值支持 DECIMAL 类型，经度 (longitude) 在前，纬度 (latitude) 在后，用空格分隔。</li><li>LineString，线，由一系列点连接而成。如果线从头至尾没有交叉，那就是简单的 (simple)；如果起点和终点重叠，那就是封闭的 （closed)。例如LINESTRING(30 10, 10 30, 40 40)，点与点之间用逗号分隔，一个点中的经纬度用空格分隔，与 POINT 格式一致。</li><li>Polygon，多边形。可以是一个实心平面形，即没有内部边界，也可以有空洞，类似纽扣。最简单的就是只有一个外边界的情况，例如 POLYGON((0 0,10 0, 10 10, 0 10)。</li></ul></li></ul><h3 id="13-小结及选择建议"><a href="#13-小结及选择建议" class="headerlink" title="13. 小结及选择建议"></a>13. 小结及选择建议</h3><p>在定义数据类型时，如果确定是整数，就用 INT；如果是小数，一定用定点数类型 DECIMAL(M, D)；如果是日期与时间，就用 DATETIME。</p><p>这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两面的，可靠性好，并不意味着高效。比如，TEXT 虽然使用方便，但是效率不如 CHAR(M) 和 VARCHAR(M)。</p><p>关于字符串的选择，建议参考如下阿里巴巴的 《Java 开发手册》规范：</p><p><strong>阿里巴巴《Java 开发手册》之 MySQL 数据库</strong>：</p><ul><li>任何字段如果为非负数，必须是 unsigned。</li><li>【强制】小数类型为 decimal，禁止使用 float 和 double。<ul><li>说明： float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</li></ul></li><li>【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</li><li>【强制】 varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</li></ul><h2 id="十二、约束"><a href="#十二、约束" class="headerlink" title="十二、约束"></a>十二、约束</h2><h3 id="1-约束-constraint-概述"><a href="#1-约束-constraint-概述" class="headerlink" title="1. 约束 (constraint) 概述"></a>1. 约束 (constraint) 概述</h3><h4 id="1-1-为什么需要约束"><a href="#1-1-为什么需要约束" class="headerlink" title="1.1 为什么需要约束"></a>1.1 为什么需要约束</h4><p>数据完整性 (Data Integrity) 是指数据的精确性 (Accuracy) 和可靠性 (Reliability)。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。</p><p>为了保证数据的完整性，SQL 规范以约束的方式对表数据进行额外的条件限制。从以下四个方面考虑：</p><ul><li>实体完整性 (Entity Integrity)：例如，同一个表中，不能存在两条完全相同无法区分的记录。</li><li>域完整性 (Domain Integrity)：例如：年龄范围 0～120，性别范围”男&#x2F;女”。</li><li>引用完整性 (Referential Integrity)：例如：员工所在部门，在部门表中要能找到这个部门</li><li>用户自定义完整性 (User-defined Integrity)：例如：用户名唯一、密码不能为空，本部门经理的工资不能高于本部门职工的平均工资的 5 倍。</li></ul><h4 id="1-2-什么是约束"><a href="#1-2-什么是约束" class="headerlink" title="1.2 什么是约束"></a>1.2 什么是约束</h4><p>约束是表级的强制规定。可以在创建表时规定约束 (通过 CREATE TABLE 语句)，或者在表创建之后通过 ALTER TABLE 语句规定约束。</p><h4 id="1-3-约束的分类"><a href="#1-3-约束的分类" class="headerlink" title="1.3 约束的分类"></a>1.3 约束的分类</h4><ul><li>根据约束数据列的限制，约束可分为：<ul><li>单列约束：每个约束只约束一列</li><li>多列约束：每个约束可约束多列数据</li></ul></li><li>根据约束的作用范围，约束可分为：<ul><li>列级约束：只能作用在一个列上，跟在列的定义后面</li><li>表级约束：可以作用在多个列上，不与列一起，而是单独定义</li></ul></li></ul><table><thead><tr><th></th><th>位置</th><th>支持的约束类型</th><th>是否可以起约束名</th></tr></thead><tbody><tr><td>列级约束</td><td>列的后面</td><td>语法都支持，但外键没有效果</td><td>不可以</td></tr><tr><td>表级约束</td><td>所有列的下面</td><td>默认和非空不支持，其他支持</td><td>可以 (主键没有效果)</td></tr></tbody></table><ul><li>根据约束起的作用，约束可分为：<ul><li>NOT NULL 非空约束，规定某个字段不能为空</li><li>UNIQUE 唯一约束，规定某个字段在整个表中是唯一的</li><li>PRIMARY KEY 主键 (非空且唯一) 约束</li><li>FOREIGN KEY 外键约束</li><li>CHECK 检查约束</li><li>DEFAULT 默认值约束</li></ul></li></ul><blockquote><p>注意：MySQL 不支持 check 约束，但是可以使用 check 约束，而没有任何效果</p></blockquote><ul><li><p>查看某个表已有的约束</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># information_schema 数据库名 (系统库)</span><br><span class="line"># table_constraints 标名称 (专门存储各个表的约束)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints</span><br><span class="line"><span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;标名称&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-非空约束"><a href="#2-非空约束" class="headerlink" title="2.非空约束"></a>2.非空约束</h3><h4 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a>2.1 作用</h4><p>限定某个字段&#x2F;某列的值不允许为空</p><h4 id="2-2-关键字"><a href="#2-2-关键字" class="headerlink" title="2.2 关键字"></a>2.2 关键字</h4><p>NOT NULL</p><h4 id="2-3-特点"><a href="#2-3-特点" class="headerlink" title="2.3 特点"></a>2.3 特点</h4><ul><li>默认，所有的类型的值都可以是 NULL，包括 INT、FLOAT 等数据类型</li><li>非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空</li><li>一个表可以有很多列都分别限定了非空</li><li>空字符串”不等于 NULL”，0 也不等于 NULL</li></ul><h4 id="2-4-添加非空约束"><a href="#2-4-添加非空约束" class="headerlink" title="2.4 添加非空约束"></a>2.4 添加非空约束</h4><ul><li><p>建表时</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  表名称(</span><br><span class="line">column1 数据类型,</span><br><span class="line">  column2 数据类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  column3 数据类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>建表后</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称</span><br><span class="line">MODIFY <span class="keyword">column</span> 数据类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-5-删除非空约束"><a href="#2-5-删除非空约束" class="headerlink" title="2.5 删除非空约束"></a>2.5 删除非空约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 MODIFY <span class="keyword">column</span> 数据类型 <span class="keyword">NULL</span>;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 MODIFY <span class="keyword">column</span> 数据类型;</span><br></pre></td></tr></table></figure><h3 id="3-唯一性约束"><a href="#3-唯一性约束" class="headerlink" title="3. 唯一性约束"></a>3. 唯一性约束</h3><h4 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1 作用"></a>3.1 作用</h4><p>用来限制某个字段&#x2F;某列的值不能重复。</p><h4 id="3-2-关键字"><a href="#3-2-关键字" class="headerlink" title="3.2 关键字"></a>3.2 关键字</h4><p>UNIQUE</p><h4 id="3-3-特点"><a href="#3-3-特点" class="headerlink" title="3.3 特点"></a>3.3 特点</h4><ul><li>同一个表可以有多个唯一约束。</li><li>唯一约束可以是某一列的值唯一，也可以多个列组合的值唯一。</li><li>唯一性约束允许列值为空。</li><li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</li><li>MySQL 会给唯一约束的列上默认创建一个唯一索引。</li></ul><h4 id="3-4-添加唯一约束"><a href="#3-4-添加唯一约束" class="headerlink" title="3.4 添加唯一约束"></a>3.4 添加唯一约束</h4><ul><li><p>建表时</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 列级约束</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名称(</span><br><span class="line">column1 数据类型,</span><br><span class="line">  column2 数据类型 <span class="keyword">UNIQUE</span>,</span><br><span class="line">  column3 数据类型 <span class="keyword">UNIQUE</span> KEY,</span><br><span class="line">);</span><br><span class="line"># 表级约束</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名称(</span><br><span class="line">column1 数据类型,</span><br><span class="line">  column2 数据类型 <span class="keyword">UNIQUE</span>,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> 约束名 <span class="keyword">UNIQUE</span> 字段名</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>建表后</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 字段列表中如果是一个字段，表示该列的值唯一，如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> KEY(字段列表);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 MODIFY 字段名 数据类型 <span class="keyword">UNIQUE</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-5-关于复合唯一约束"><a href="#3-5-关于复合唯一约束" class="headerlink" title="3.5 关于复合唯一约束"></a>3.5 关于复合唯一约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名称(</span><br><span class="line">column1 数据类型,</span><br><span class="line">  column2 数据类型,</span><br><span class="line">  column3 数据类型,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY(字段列表)# 字段列表中写的是多个字段名，用逗号分隔，表示多个字段的组合是唯一的。</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="3-6-删除唯一约束"><a href="#3-6-删除唯一约束" class="headerlink" title="3.6 删除唯一约束"></a>3.6 删除唯一约束</h4><ul><li>添加唯一性约束的列上也会自动创建唯一索引。</li><li>删除唯一约束只能通过删除唯一索引的方式删除。</li><li>删除时需要制定唯一索引名，唯一索引名就和唯一约束名一样。</li><li>如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和 () 中排在第一个的列名相同。也可以自定义唯一性约束名。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名&#x27;</span>; # 查看都有哪些约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line"><span class="keyword">DROP</span> INDEX 唯一索引名;</span><br></pre></td></tr></table></figure><blockquote><p>注意：可以通过 <code>show index from 表名称;</code> 查看表的索引</p></blockquote><h3 id="4-主键约束"><a href="#4-主键约束" class="headerlink" title="4. 主键约束"></a>4. 主键约束</h3><h4 id="4-1-作用"><a href="#4-1-作用" class="headerlink" title="4.1 作用"></a>4.1 作用</h4><p>用来唯一标识表中的一行记录。</p><h4 id="4-2-关键字"><a href="#4-2-关键字" class="headerlink" title="4.2 关键字"></a>4.2 关键字</h4><p>PRIMARY KEY</p><h4 id="4-3-特点"><a href="#4-3-特点" class="headerlink" title="4.3 特点"></a>4.3 特点</h4><ul><li>主键约束相当于唯一约束 + 非空约束的组合，主键约束列不允许重复，也不允许出现空值。</li><li>一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。</li><li>主键约束对应着表中的一列或者多列 (复合主键)。</li><li>如果是多列组合的符合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。</li><li>MySQL 的主键名总是 PRIMARY，就算自己命名了主键约束名也没用。</li><li>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引 (能够根据主键查询的，就根据主键查询，效率跟高)。如果删除主键约束了，主键约束对应的索引就自动删除了。</li><li>需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。</li></ul><h4 id="4-4-添加主键约束"><a href="#4-4-添加主键约束" class="headerlink" title="4.4 添加主键约束"></a>4.4 添加主键约束</h4><ul><li>建表时：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 列级约束</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名称(</span><br><span class="line">column1 数据类型 <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  column2 数据类型 <span class="keyword">UNIQUE</span>,</span><br><span class="line">  column3 数据类型 <span class="keyword">UNIQUE</span> KEY,</span><br><span class="line">);</span><br><span class="line"># 表级约束 复合主键</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名称(</span><br><span class="line">column1 数据类型,</span><br><span class="line">  column2 数据类型 <span class="keyword">UNIQUE</span>,</span><br><span class="line">  column3 数据类型 <span class="keyword">UNIQUE</span> KEY,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> 约束名 <span class="keyword">PRIMARY</span> KEY(column1, column2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>建表后：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (字段名);</span><br></pre></td></tr></table></figure><h4 id="4-5-删除主键约束"><a href="#4-5-删除主键约束" class="headerlink" title="4.5 删除主键约束"></a>4.5 删除主键约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure><h3 id="5-自增列"><a href="#5-自增列" class="headerlink" title="5. 自增列"></a>5. 自增列</h3><h4 id="5-1-作用"><a href="#5-1-作用" class="headerlink" title="5.1 作用"></a>5.1 作用</h4><p>某个字段的值自增</p><h4 id="5-2-关键字"><a href="#5-2-关键字" class="headerlink" title="5.2 关键字"></a>5.2 关键字</h4><p>AUTO_INCREMENT</p><h4 id="5-3-特点和要求"><a href="#5-3-特点和要求" class="headerlink" title="5.3 特点和要求"></a>5.3 特点和要求</h4><ul><li>一个表最多只能有一个自增长列</li><li>当需要产生唯一标识符或顺序值时，可设置自增长</li><li>自增长列约束的列必须是键列 (主键列，唯一键列)</li><li>自增约束的列的数据类型必须是整数类型</li><li>如果自增列指定了 0 和 NULL，会在当前最大值的基础上自增；如果自增列手动置顶了具体值，直接赋值为具体值。</li></ul><h4 id="5-4-指定自增约束"><a href="#5-4-指定自增约束" class="headerlink" title="5.4 指定自增约束"></a>5.4 指定自增约束</h4><ul><li>建表时：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 标名称(</span><br><span class="line">column1 数据类型 <span class="keyword">PRIMARY</span> KEY ATUO_INCREMENT,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 标名称(</span><br><span class="line">column1 数据类型 <span class="keyword">UNIQUE</span> KEY ATUO_INCREMENT,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>建表后：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 </span><br><span class="line">MODIFY <span class="keyword">column</span> 数据类型 ATUO_INCREMENT;</span><br></pre></td></tr></table></figure><h4 id="5-5-删除自增约束"><a href="#5-5-删除自增约束" class="headerlink" title="5.5 删除自增约束"></a>5.5 删除自增约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 </span><br><span class="line">MODIFY <span class="keyword">column</span> 数据类型; # 去掉 ATUO_INCREMENT</span><br></pre></td></tr></table></figure><h4 id="5-6-MySQL-8-0-新特性——自增变量的持久化"><a href="#5-6-MySQL-8-0-新特性——自增变量的持久化" class="headerlink" title="5.6 MySQL 8.0 新特性——自增变量的持久化"></a>5.6 MySQL 8.0 新特性——自增变量的持久化</h4><p>在 MySQL 8.0 之前，自增主键 ATUO_INCREMENT 的值如果大于 max(primary key) + 1，在 MySQL 重启后，会重置 ATUO_INCREMENT &#x3D; max(primary key) + 1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。在 MySQL 5.7 系统中，对于自增主键的分配规则，是由 InnoDB 数据字典内部一个计数器来决定的，而该计数器只在内存中维护，并不会持久化道磁盘中。当数据库重启时，该计数器会被初始化。在 MySQL 8.0 系统中将自增主键的计数器持久化道重做日志中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB 会根据重做日志中的信息来初始化计数器的内存值。</p><h3 id="6-外键约束"><a href="#6-外键约束" class="headerlink" title="6. 外键约束"></a>6. 外键约束</h3><h4 id="6-1-作用"><a href="#6-1-作用" class="headerlink" title="6.1 作用"></a>6.1 作用</h4><p>限定某个表的某个字段的引用完整性。</p><p>比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分。</p><h4 id="6-2-关键字"><a href="#6-2-关键字" class="headerlink" title="6.2 关键字"></a>6.2 关键字</h4><p>FOREIGN KEY</p><h4 id="6-3-主表和从表-x2F-父表和子表"><a href="#6-3-主表和从表-x2F-父表和子表" class="headerlink" title="6.3 主表和从表&#x2F;父表和子表"></a>6.3 主表和从表&#x2F;父表和子表</h4><p>主表 (父表)：被引用的表，被参考的表。</p><p>从表 (子表)：引用别人的表，参考别人的表。</p><h4 id="6-4-特点"><a href="#6-4-特点" class="headerlink" title="6.4 特点"></a>6.4 特点</h4><ul><li><p>从表的外键列，必须引用&#x2F;参考主表的键 (主键或唯一约束的列)</p><p>  为什么？因为被依赖&#x2F;被参考的值必须是唯一的。</p></li><li><p>在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名，也可以指定外键约束名。</p></li><li><p>创建 (CRETE) 表时就指定外键约束的话，先创建主表，再创建从表。</p></li><li><p>删表时，先删从表 (或先删外键约束)，在删除主表。</p></li><li><p>当主表的记录被从表参照时，主要的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据。</p></li><li><p>在 “从表”中指定外键约束，并且一个表可以建立多个外键约束。</p></li><li><p>从表的外键列与主表被参照的列名可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现“ERROR 1005 (HY000): Can’t crete table’database.tablename’(errno:150”。</p></li><li><p>当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。但是索引名是列名，不是外键的约束名。(根据外键查询效率很高)</p></li><li><p>删除外键约束后，必须手动删除对应的索引。</p></li></ul><h4 id="6-5-添加外键约束"><a href="#6-5-添加外键约束" class="headerlink" title="6.5 添加外键约束"></a>6.5 添加外键约束</h4><ul><li><p>建表时</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 主表名称(</span><br><span class="line">column1 数据类型 <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  column2 数据类型</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 从表名称(</span><br><span class="line">column1 数据类型 <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  column2 数据类型 ，</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> 外键约束名称 <span class="keyword">FOREIGN</span> KEY (从表字段) <span class="keyword">REFERENCES</span> 主表名(主表字段)</span><br><span class="line">);</span><br><span class="line"># 从表的某个字段的数据类型必须与主表字段的数据类型一致，逻辑意义也一样</span><br><span class="line"># 从表的某个字段的字段名可以与主表字段名一样，也可以不一样</span><br><span class="line"><span class="comment">-- FOREIGN KEY：在表级别指定子表中的列</span></span><br><span class="line"><span class="comment">-- REFERENCES：表示在父表中的列</span></span><br></pre></td></tr></table></figure></li><li><p>建表后</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span> 约束名] <span class="keyword">FOREIGN</span> KEY (从表字段) <span class="keyword">REFERENCES</span> 主表名(主表字段) [<span class="keyword">ON</span> <span class="keyword">UPDATE</span> xx][<span class="keyword">ON</span> <span class="keyword">DELETE</span> xx];</span><br></pre></td></tr></table></figure></li></ul><p>总结：约束关系是针对双方的</p><ul><li>添加了外键约束后，主表的修改和删除数据受约束</li><li>添加了外键约束后，从表的添加和修改数据受约束</li><li>在从表上建立外键，要求主表必须存在</li><li>删除主表时，要求从表先删除，或将从表中外键引用该主表的关系先删除</li></ul><h4 id="6-6-约束等级"><a href="#6-6-约束等级" class="headerlink" title="6.6 约束等级"></a>6.6 约束等级</h4><ul><li>Cascade 方式：在父表上 update&#x2F;delete 记录时，同步 update&#x2F;delete 掉子表的匹配记录</li><li>Set null 方式：在父表上 update&#x2F;delete 记录时，将子表上匹配记录的列设为 null，但是要注意子表的外键列不能为 not null</li><li>No action 方式：如果子表中有匹配的记录，则不允许对父表对应候选键进行 update&#x2F;delete 操作</li><li>Restrict 方式：同 no action，都是立即检查外键约束</li><li>Set default 方式：父表有变更时，子表将外键列设制成一个默认的值，但 InnoDb 不能识别。</li></ul><p>如果没有置顶等级，就相当于 Restrict 方式。</p><p><strong>对于外键约束，最好是采用：<code>ON UPDATE CASCADE ON DELETE RESTRICT</code> 的方式</strong>。</p><h4 id="6-7-删除外键约束"><a href="#6-7-删除外键约束" class="headerlink" title="6.7 删除外键约束"></a>6.7 删除外键约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 第一步先查看约束名和删除外键约束</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名称&#x27;</span>; #查看某个表的约束名</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键约束名;</span><br><span class="line"></span><br><span class="line">#第二步查看索引名和删除索引。注意只能手动删除</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表名称;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> INDEX 索引名;</span><br></pre></td></tr></table></figure><h4 id="6-8-开发场景"><a href="#6-8-开发场景" class="headerlink" title="6.8 开发场景"></a>6.8 开发场景</h4><p><strong>问题一：如果两个表之间有关系 (一对一、一对多)，它们之间是否一定要建外键约束</strong>？</p><p>答：不是的</p><p><strong>问题二：建和不建外键约束有什么区别</strong>？</p><p>答：建外键约束，你的操作 (创建表、删除表、添加、修改、删除) 会受到限制，从语法层面受到限制。例如：在员工表中不可能添加一个员工信息，他的部门的值在部门表中找不到。</p><p>不建外键约束，你的操作 (创建表、删除表、添加、修改、删除) 不受限制，要保证数据的引用完整性，只能依靠程序员的自觉，或者是在 Java 程序中进行限定。例如：在员工表中，可以添加一个员工信息，它的部门指定为一个完全不存在的部门。</p><p><strong>问题三：那么建和不建外键约束和查询有没有关系</strong>？</p><p>答：没有</p><blockquote><p>在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会因为外键约束的系统开销而变得非常慢。所以，MySQL 允许你不使用系统自带的外键约束，在应用层面完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</p></blockquote><h4 id="6-9-阿里开发规范"><a href="#6-9-阿里开发规范" class="headerlink" title="6.9 阿里开发规范"></a>6.9 阿里开发规范</h4><p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p><p>说明：(概念解释) 学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时出发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p><h3 id="7-CHECK-约束"><a href="#7-CHECK-约束" class="headerlink" title="7. CHECK 约束"></a>7. CHECK 约束</h3><h4 id="7-1-作用"><a href="#7-1-作用" class="headerlink" title="7.1 作用"></a>7.1 作用</h4><p>检查某个字段的值是否符合 xx 要求，一般指的是值的范围。</p><h4 id="7-2-关键字"><a href="#7-2-关键字" class="headerlink" title="7.2 关键字"></a>7.2 关键字</h4><p>CHECK</p><h4 id="7-3-说明：MySQL-5-7-不支持"><a href="#7-3-说明：MySQL-5-7-不支持" class="headerlink" title="7.3 说明：MySQL 5.7 不支持"></a>7.3 说明：MySQL 5.7 不支持</h4><p>MySQL 5.7 可以使用 check 约束，但 check 约束对数据验证没有任何作用。添加数据时，没有任何错误或警告。但是 MySQL 8.0 中可以使用 check 约束了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  age <span class="type">INT</span> <span class="keyword">CHECK</span>(age <span class="operator">&gt;</span> <span class="number">20</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="8-DEFAULT-约束"><a href="#8-DEFAULT-约束" class="headerlink" title="8. DEFAULT 约束"></a>8. DEFAULT 约束</h3><h4 id="8-1-作用"><a href="#8-1-作用" class="headerlink" title="8.1 作用"></a>8.1 作用</h4><p>给某个字段&#x2F;某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显示赋值，则赋值为默认值。</p><h4 id="8-2-关键字"><a href="#8-2-关键字" class="headerlink" title="8.2 关键字"></a>8.2 关键字</h4><p>DEFAULT</p><h4 id="8-3-如果给字段加默认值"><a href="#8-3-如果给字段加默认值" class="headerlink" title="8.3 如果给字段加默认值"></a>8.3 如果给字段加默认值</h4><ul><li>建表时：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名称(</span><br><span class="line">column1 数据类型 <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  column1 数据类型 <span class="keyword">UNIQUE</span> KEY <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  column1 数据类型 <span class="keyword">UNIQUE</span> KEY,</span><br><span class="line">  column1 数据类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> 默认值</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>建表后：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 MODIFY <span class="keyword">column</span> 数据类型 <span class="keyword">DEFAULT</span> 默认值;</span><br><span class="line"># 如果这个字段原来有非空约束，你还保留非空约束，那么在加载默认值约束是，海的保留非空约束，否则非空约束就被删除了。</span><br><span class="line"># 同理，再给某个字段加非空约束也一样，如果这个字段原来有默认值的约束，你想保留，也要在 modify 语句中保留默认值约束，否则就删除了</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 MODIFY 字段名 数据类型 <span class="keyword">DEFAULT</span> 默认值 <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><h4 id="8-4-删除默认值约束"><a href="#8-4-删除默认值约束" class="headerlink" title="8.4 删除默认值约束"></a>8.4 删除默认值约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 MODIFY <span class="keyword">column</span> 数据类型;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 MODIFY <span class="keyword">column</span> 数据类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="9-面试题"><a href="#9-面试题" class="headerlink" title="9. 面试题"></a>9. 面试题</h3><ul><li><p>为什么建表时，加 NOT NULL DEFAULT 或 DEFAULT 0 ？</p><p>  答：不想让表中出现 NULL 值。</p></li><li><p>为什么不想要 NULL 值？</p><p>  答：1. 不好比较。NULL 是一种特殊值，比较时只能用专门的 IS NULL 和 IS NOT NULL 来比较。碰到运算符，通常返回 NULL。</p><p>  ​2. 效率不高。影响提高索引效果。因此，我们往往在建表时 NOT NULL DEFAULT 或 DEFAULT 0。</p></li><li><p>带 AUTO_INCREMENT 约束的字段值是从 1 开始的吗？</p><p>  在 MySQL 中，默认 AUTO_INCREMENT 的初始值是 1，每新增一条记录，字段值自动加 1.设置自增属性的时候，还可以指定第一条插入记录的自增字段的值，这样插入的记录的自增字段值从初识值开始递增，如在表中插入第一条记录，同时指定 id 值为 5，则以后插入的记录的 id 就会从 6 开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。</p></li><li><p>并不是每个表都可以任意选择存储引擎？</p><p>  外键约束不能跨引擎使用。</p><p>  MySQL 支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。</p></li></ul><h2 id="十三、视图"><a href="#十三、视图" class="headerlink" title="十三、视图"></a>十三、视图</h2><h3 id="1-常见的数据库对象"><a href="#1-常见的数据库对象" class="headerlink" title="1. 常见的数据库对象"></a>1. 常见的数据库对象</h3><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>表 TABLE</td><td>表示存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录</td></tr><tr><td>数据字典</td><td>就是系统表，存放数据库相关信息的表。系统表的数据通常有数据库系统维护，程序员通常不应该修改，只可查看</td></tr><tr><td>约束 CONSTRAINT</td><td>执行数据校验的规则，用于保证数据完整性的规则</td></tr><tr><td>视图 VIEW</td><td>一个或者多个数据表里的数据的逻辑显示，视图并不存储数据</td></tr><tr><td>索引 INDEX</td><td>用于提高查询性能，相当于数的目录</td></tr><tr><td>存储过程 PROCEDURE</td><td>用于完成一次完成的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境</td></tr><tr><td>存储函数 FUNCTION</td><td>用于完成一次特定的计算，具有一个返回值</td></tr><tr><td>触发器</td><td>相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理</td></tr></tbody></table><h3 id="2-视图概述"><a href="#2-视图概述" class="headerlink" title="2. 视图概述"></a>2. 视图概述</h3><h4 id="2-1-为什么使用视图？"><a href="#2-1-为什么使用视图？" class="headerlink" title="2.1 为什么使用视图？"></a>2.1 为什么使用视图？</h4><p>视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的价格，则不会提供给他。再比如，人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中则不提供这个字段。</p><h4 id="2-2-视图的理解"><a href="#2-2-视图的理解" class="headerlink" title="2.2 视图的理解"></a>2.2 视图的理解</h4><ul><li>视图是一种虚拟表，本身是不具有数据的，占用很少的内存空间，它是 SQL 中的一个重要概念。</li><li>视图建立在已有表的基础上，视图赖以建立的这些表称为基表。</li><li>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生改变，反之亦然。</li><li>向视图提供数据内容的语句为 SELECT 语句，可以将视图理解为存储起来的 SELECT 语句。<ul><li>在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之依然。</li></ul></li><li>视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，他可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</li></ul><h3 id="3-创建视图"><a href="#3-创建视图" class="headerlink" title="3. 创建视图"></a>3. 创建视图</h3><ul><li><p>在 CREATE VIEW 语句中嵌入子查询</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE]</span><br><span class="line">[ALGORITHM <span class="operator">=</span> &#123;UNDEFINED <span class="operator">|</span> <span class="keyword">MERGE</span> <span class="operator">|</span> TEMPTABLE&#125;]</span><br><span class="line"><span class="keyword">VIEW</span> 视图名称 [(字段列表)]</span><br><span class="line"><span class="keyword">AS</span> 查询语句</span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span><span class="operator">|</span><span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION]</span><br></pre></td></tr></table></figure></li><li><p>精简版</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span> 查询语句</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-1-创建单表视图"><a href="#3-1-创建单表视图" class="headerlink" title="3.1 创建单表视图"></a>3.1 创建单表视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> column1 col1, column2 col2, column3 col3</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称 (col1, col2, col3)</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, column3</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br><span class="line"></span><br><span class="line"># 查看视图</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 视图名称;</span><br></pre></td></tr></table></figure><h4 id="3-2-创建多表视图"><a href="#3-2-创建多表视图" class="headerlink" title="3.2 创建多表视图"></a>3.2 创建多表视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> t1.column1 col1, t2.column2 col2, t2.column3 col3</span><br><span class="line"><span class="keyword">FROM</span> table1 t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2 t2</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">condition</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称 (col1, col2, col3)</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> t1.column1, t2.column2, t2.column3</span><br><span class="line"><span class="keyword">FROM</span> table1 t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2 t2</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">condition</span>;</span><br><span class="line"></span><br><span class="line"># 查看视图</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 视图名称;</span><br></pre></td></tr></table></figure><p><strong>利用视图对数据进行格式化</strong></p><p>我们经常需要输出某个格式的内容，比如想输出员工姓名和对应的部门名，对应格式为 emp_name(department_name)，就可以使用视图来完成数据格式化的操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp_depart</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(last_name, <span class="string">&#x27;(&#x27;</span>,department,<span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span> emp_dept</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure><h4 id="3-3-基于视图创建视图"><a href="#3-3-基于视图创建视图" class="headerlink" title="3.3 基于视图创建视图"></a>3.3 基于视图创建视图</h4><p>当我们创建好一张视图之后，还可以在它的基础上继续创建视图。</p><h3 id="4-查看视图"><a href="#4-查看视图" class="headerlink" title="4. 查看视图"></a>4. 查看视图</h3><p>语法1: 查看数据库的表对象、视图对象</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure><p>语法2: 查看视图的结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> <span class="operator">/</span> <span class="keyword">DESCRIBE</span> 视图名称;</span><br></pre></td></tr></table></figure><p>语法3: 查看视图的属性信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看视图信息(显示数据表的存储引擎、版本、数据行数和数据大小等)</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;视图名称&#x27;</span>\G</span><br></pre></td></tr></table></figure><p>执行结果显示，注释 Comment 为 VIEW，说明该表为视图，其他的信息为 NULL，说明这是一个虚标。</p><p>语法4: 查看视图的详细定义信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称;</span><br></pre></td></tr></table></figure><h3 id="5-修改视图的数据"><a href="#5-修改视图的数据" class="headerlink" title="5. 修改视图的数据"></a>5. 修改视图的数据</h3><h4 id="5-1-一般情况"><a href="#5-1-一般情况" class="headerlink" title="5.1 一般情况"></a>5.1 一般情况</h4><p>MySQL 支持使用 INSERT、UPDATE 和 DELETE 语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 视图名称 <span class="keyword">SET</span> <span class="keyword">column</span> <span class="operator">=</span> <span class="keyword">value</span> <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 视图名称 <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><h4 id="5-2-不可更新的视图"><a href="#5-2-不可更新的视图" class="headerlink" title="5.2 不可更新的视图"></a>5.2 不可更新的视图</h4><p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在一对一的关系。另外当视图定义出现如下情况时，视图不支持更新操作：</p><ul><li>在定义视图的时候指定了 <code>ALGORITHM = TEMPTABLE</code>，视图将不支持 INSERT 和 DELETE 操作；</li><li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持 INSERT 操作；</li><li>在定义视图的 SELECT 语句中使用了 JOIN 联合查询，视图将不支持 INSERT 和 DELETE 操作；</li><li>在定义视图的 SELECT 语句后的字段列表中使用了数学表达式或子查询，视图将不支持 INSERT，也不支持 UPDATE 使用了数学表达式、子查询的字段值；</li><li>在定义视图的 SELECT 语句后的字段列表中使用 DISTINCT、聚合函数、GROUP BY、HAVING、UNION 等，视图将不支持 INSERT、UPDATE、DELETE；</li><li>在定义视图的 SELECT 语句中包含了子查询，而子查询中引用了 FROM 后面的表，视图将不支持 INSERT、UPDATE、DELETE；</li><li>视图定义给予一个不可更新视图；</li><li>常量视图。</li></ul><blockquote><p>虽然可以更新视图数据，但总的来说，视图作为虚拟表，主要用于方便查询，不建议更逊视图的数据。对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。</p></blockquote><h3 id="6-修改、删除视图"><a href="#6-修改、删除视图" class="headerlink" title="6. 修改、删除视图"></a>6. 修改、删除视图</h3><h4 id="6-1-修改视图"><a href="#6-1-修改视图" class="headerlink" title="6.1 修改视图"></a>6.1 修改视图</h4><ul><li><p>方式一：使用 <code>CREATE OR REPLACE VIEW</code> 子句修改视图</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> 视图名</span><br><span class="line">(col1, col2, col3)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, column3</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><blockquote><p>说明：CREATE VIEW 子句中各列的别名应和子查询中各列相对应。</p></blockquote></li><li><p>方式二：ALTER VIEW</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-2-删除视图"><a href="#6-2-删除视图" class="headerlink" title="6.2 删除视图"></a>6.2 删除视图</h4><ul><li><p>删除视图只是删除视图的定义，并不会删除基表的数据。</p></li><li><p>删除视图的语法：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> IF <span class="keyword">EXISTS</span> 视图名称;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> IF <span class="keyword">EXISTS</span> 视图名称<span class="number">1</span>, 视图名称<span class="number">2</span>, 视图名称<span class="number">3</span>, ....;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>说明：基于视图 a、b 创建了新的视图 c，如果将视图 a 或视图 b 删除，会导致视图 c 的查询失败。这样的视图 c 需要手动删除或修改，否则影响使用。</p></blockquote><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><h4 id="7-1-视图优点"><a href="#7-1-视图优点" class="headerlink" title="7.1 视图优点"></a>7.1 视图优点</h4><ul><li><p>操作简单</p><p>  将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表于表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简化了开发人员对数据库的操作。</p></li><li><p>减少数据冗余</p><p>  视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。</p></li><li><p>数据安全</p><p>  MySQL 将用户对数据的访问限制在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有隔离性。视图相当于在用户和实际的数据表之间加了一层虚拟表。</p><p>  同时，MySQL 可以根据权限将用户对数据的访问限制在某些视图上，用户不需要查询数据库，可以直接通过视图获取数据表中的信息。这在一定程度上保障了数据表中数据的安全性。</p></li><li><p>适应灵活多变的需求</p><p>  当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。</p></li><li><p>能够分解复杂的查询逻辑</p><p>  数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。</p></li></ul><h4 id="7-2-视图不足"><a href="#7-2-视图不足" class="headerlink" title="7.2 视图不足"></a>7.2 视图不足</h4><p>如果我们在实际数据表的基础上创建视图，那么，如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护。特别是嵌套的视图 (就是在视图的基础上创建视图)，维护会变得比较复杂，可读性不好，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。</p><p>实际项目中，如果视图过多，会导致数据库维护成本的问题。</p><p>所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优。</p><h2 id="十四、存储过程与存储函数"><a href="#十四、存储过程与存储函数" class="headerlink" title="十四、存储过程与存储函数"></a>十四、存储过程与存储函数</h2><p>MySQL 从 5.0 版本开始支持存储过程和函数。存储过程和函数能够将复杂的 SQL 逻辑封装在一起，应用程序无需关注存储过程和函数内部复杂的 SQL 逻辑，而只需要简单地调用存储过程和函数即可。</p><h3 id="1-存储过程概述"><a href="#1-存储过程概述" class="headerlink" title="1. 存储过程概述"></a>1. 存储过程概述</h3><h4 id="1-1-理解"><a href="#1-1-理解" class="headerlink" title="1.1 理解"></a>1.1 理解</h4><p><strong>含义</strong>：存储过程是英文 <code>Stored Procedure</code>。它的思想很简单，就是一组经过预先编译的 SQL 语句的封装。</p><p>执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p><p><strong>好处：</strong></p><ul><li>简化操作，提高了 SQL 语句的重用性，减少了开发程序员的压力</li><li>减少操作过程中的事物，提高效率</li><li>减少网络传输量 (客户端不需要把所有的 SQL 语句通过网络发给服务器)</li><li>减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性</li></ul><p><strong>和视图、函数的对比：</strong></p><p>它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是虚拟表，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以直接操作底层数据表，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。</p><p>一旦存储过程被创建出来，使用它就像使用函数一样简单，直接通过调用存储过程名即可。相较于函数，存储过程是没有返回值的。</p><h4 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2 分类"></a>1.2 分类</h4><p>存储过程的参数类型可以是 IN、OUT 和 INOUT。根据这点分类如下：</p><ul><li>没有参数 (无参数无返回)</li><li>仅仅带 IN 类型 (有参数无返回)</li><li>仅仅带 OUT 类型 (无参数有返回)</li><li>既带 IN 又带 OUT (有参数有返回)</li><li>带 INOUT (有参数有返回)</li></ul><p>注意：IN、OUT、INOUT 都可以在一个存储过程中带多个。</p><h3 id="2-创建存储过程"><a href="#2-创建存储过程" class="headerlink" title="2. 创建存储过程"></a>2. 创建存储过程</h3><h4 id="2-1-语法分析"><a href="#2-1-语法分析" class="headerlink" title="2.1 语法分析"></a>2.1 语法分析</h4><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(<span class="keyword">IN</span><span class="operator">|</span><span class="keyword">OUT</span><span class="operator">|</span><span class="keyword">INOUT</span> 参数名 参数类型，...)</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">存储过程体</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><p>参数前面的符号的意思</p><ul><li><p><code>IN</code>：当前参数为输入参数，也就是表示入参；</p><p>  存储过程只是读取这个参数的值。如果没有定义参数种类，默认就是 IN，表示输入参数。</p></li><li><p><code>OUT</code>：当前参数为输出参数，也就是表示出参；</p><p>  执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。</p></li><li><p><code>INOUT</code>：当前参数既可以为输入参数，也可以为输出参数。</p></li></ul></li><li><p>形参类型可以是 MySQL 数据库中的任意类型。</p></li><li><p><code>characteristics</code> 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LANGUAGE</span> <span class="keyword">SQL</span></span><br><span class="line"><span class="operator">|</span> [<span class="keyword">NOT</span>] <span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="operator">|</span> &#123;<span class="keyword">CONTAINS</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">NO</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">READS</span> <span class="keyword">SQL</span> DATA <span class="operator">|</span> <span class="keyword">MODIFIES</span> <span class="keyword">SQL</span> DATA&#125;</span><br><span class="line"><span class="operator">|</span> <span class="keyword">SQL</span> SECURITY &#123;DEFINER <span class="operator">|</span> INVOKER&#125;</span><br><span class="line"><span class="operator">|</span> COMMENT <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>LANGUAGE SQL</code>：说明存储过程执行体是由 SQL 语句组成的，当前系统支持的语言为 SQL。</li><li><code>[NOT] DETERMINISTIC</code>：指明存储过程执行的结果是否确定。DETERMINISTIC 表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC 表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为 NOT DETERMINISTIC。</li><li><code>&#123;CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA&#125;</code>：指明子程序使用 SQL 语句的限制。<ul><li><code>CONTAINS SQL</code>  表示当前存储过程的子程序包含 SQL 语句，但是并不包含读写数据的 SQL 语句；</li><li><code>NO SQL</code> 表示当前存储过程的子程序中不包含任何 SQL 语句；</li><li><code>READS SQL DATA</code> 表示当前存储过程的子程序中包含读数据的 SQL 语句；</li><li><code>MODIFIES SQL DATA</code> 表示当前存储过程的子程序中包含写数据的 SQL 语句。</li><li>默认情况下，系统会指定为 CONTAINS SQL。</li></ul></li><li><code>SQL SECURITY &#123;DEFINER | INVOKER&#125;</code>：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。<ul><li><code>DEFINER</code> 表示只有当前存储过程的创建者或者定义者才能执行当前存储过程；</li><li><code>INVOKER</code> 表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。</li><li>如果没有设置相关的值，则 MySQL 默认指定值为 DEFINER。</li></ul></li><li><code>COMMENT &#39;string&#39;</code>：注释信息，可以用来描述存储过程。</li></ul></li><li><p>存储过程体中可以有多条 SQL 语句，如果仅仅一条 SQL 语句，则可以省略 BEGIN 和 END 编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的 SQL 语句。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> BEGIN...END：中间包含了多个语句，每个语句都以<span class="string">&#x27;;&#x27;</span>好为结束符。</span><br><span class="line"><span class="number">2.</span> <span class="keyword">DECLARE</span>：用来声明变量，使用的位置在于 <span class="keyword">BEGIN</span> ... <span class="keyword">END</span> 语句中间，而且需要在其他语句使用之前进行变量的生命。</span><br><span class="line"><span class="number">3.</span> <span class="keyword">SET</span>：赋值语句，用于对变量进行赋值。</span><br><span class="line"><span class="number">4.</span> <span class="keyword">SELECT</span> ... <span class="keyword">INTO</span>：把从数据表中查询的结果存放到变量中，也就是为变量赋值。</span><br></pre></td></tr></table></figure></li><li><p>需要设置新的结束标记</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER 新的结束标记</span><br></pre></td></tr></table></figure><p>  因为 MySQL 默认的语句结束符号为分号 “;”。为了避免与存储过程中 SQL 语句结束符相冲突，需要使用 DELIMITER 改变存储过程的结束符。</p><p>  比如：<code>DELIMITER //</code> 语句的作用是将 MySQL 的结束符设置为 <code>//</code>，并以 <code>END //</code> 结束存储过程。存储过程定义完毕之后再使用 <code>DELIMITER ;</code> 恢复默认结束符。DELIMITER 也可以指定其他符号作为结束符。</p><p>  当使用 DEMILITER 命令时，应该避免使用反斜杠 ‘\‘ 字符，因为反斜线是 MySQL 的转义字符。</p><p>  示例：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(<span class="keyword">IN</span><span class="operator">|</span><span class="keyword">OUT</span><span class="operator">|</span><span class="keyword">INOUT</span> 参数名 参数类型, ...)</span><br><span class="line">[characteristics]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">sql</span>语句<span class="number">1</span>;</span><br><span class="line"><span class="keyword">sql</span>语句<span class="number">2</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-存储过程调用"><a href="#3-存储过程调用" class="headerlink" title="3. 存储过程调用"></a>3. 存储过程调用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> 存储过程名(实参列表)</span><br></pre></td></tr></table></figure><ul><li><p>调用 IN 模式的参数</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> 存储过程名(<span class="string">&#x27;值&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>调用 OUT 模式的参数</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@name</span>;</span><br><span class="line"><span class="keyword">CALL</span> 存储过程名(<span class="variable">@name</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@name</span>;</span><br></pre></td></tr></table></figure></li><li><p>调用 INOUT 模式的参数</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@name</span> <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">CALL</span> 存储过程名(<span class="variable">@name</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@name</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-存储函数的使用"><a href="#4-存储函数的使用" class="headerlink" title="4. 存储函数的使用"></a>4. 存储函数的使用</h3><h4 id="4-1-语法分析"><a href="#4-1-语法分析" class="headerlink" title="4.1 语法分析"></a>4.1 语法分析</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名(参数名 参数类型,...)</span><br><span class="line"><span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">函数体 # 函数体中肯定有 <span class="keyword">return</span> 语句</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p> 说明：</p><ul><li><p>参数列表：指定参数为 IN、OUT 或 INOUT 只对 PROCEDURE 是合法的，FUNCTION 中总是默认为 IN 参数。</p></li><li><p>RETURNS type 语句表示函数返回数据的类型。</p><p>  RETURNS 子句只能对 FUNCTION 做指定，对函数而言这是强制的。它用来指定函数的返回类型，而且函数体必须包含一个 <code>RETURN value</code> 语句。</p></li><li><p><code>characteristic</code> 创建函数时指定的对函数的约束。取值与创建存储过程时相同。</p></li><li><p>函数体也可以用 <code>BEGIN ... END</code> 来表示 SQL 代码的开始和结束。托过函数题已有一条语句，也可以省略 <code>BEGIN ... END。</code></p></li></ul><h4 id="4-2-调用存储函数"><a href="#4-2-调用存储函数" class="headerlink" title="4.2 调用存储函数"></a>4.2 调用存储函数</h4><p>在 MySQL 中，存储函数的使用方法与 MySQL 内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与 MySQL 内部函数是一个性质的。区别在于，存储函数是用户自定义的，而内部函数是 MySQL 的开发者定义的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 函数名(实参列表)</span><br></pre></td></tr></table></figure><h4 id="4-3-对比存储函数和存储过程"><a href="#4-3-对比存储函数和存储过程" class="headerlink" title="4.3 对比存储函数和存储过程"></a>4.3 对比存储函数和存储过程</h4><table><thead><tr><th></th><th>关键字</th><th>调用语法</th><th>返回值</th><th>应用场景</th></tr></thead><tbody><tr><td>存储过程</td><td>PROCEDURE</td><td>CALL 存储过程()</td><td>理解为有 0 个或多个</td><td>一般用于更新</td></tr><tr><td>存储函数</td><td>FUNCTION</td><td>SELECT 函数()</td><td>只能是一个</td><td>一般用于查询结果为一个值并返回时</td></tr></tbody></table><p>此外，<strong>存储函数可以放在查询语句中使用，存储过程不行</strong>。反之，存储过程的功能更加强大，包括能够执行对表的操作 (比如创建表，删除表等) 和事物操作，这些功能是存储函数不具备的。</p><h3 id="5-存储过程和函数的查看、修改、删除"><a href="#5-存储过程和函数的查看、修改、删除" class="headerlink" title="5. 存储过程和函数的查看、修改、删除"></a>5. 存储过程和函数的查看、修改、删除</h3><h4 id="5-1-查看"><a href="#5-1-查看" class="headerlink" title="5.1 查看"></a>5.1 查看</h4><ul><li><p>使用 SHOW CREATE 语句查看存储过程和函数的创建信息</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; 存储过程或函数名</span><br></pre></td></tr></table></figure></li><li><p>使用 SHOW STATUS 语句查看存储过程和函数的状态信息</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; STATUS [<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span>]</span><br></pre></td></tr></table></figure><p>  这个语句返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。</p><p>  <code>[LIKE &#39;pattern&#39;]</code>：匹配存储过程或函数的名称，可以省略。当省略不写时，会列出 MySQL 数据库中存在的所有存储过程或函数的信息。 </p></li><li><p>从 information_schema.Routines 表中查看存储过程和函数的信息</p><p>  MySQL 中存储过程和函数的信息存储在 information_schema 数据库下的 Routines 表中。可以通查查询该表的记录来查询存储过程和函数的信息。其基本语法形式如下：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.Routines</span><br><span class="line"><span class="keyword">WHERE</span> ROUTINE_NAME <span class="operator">=</span> <span class="string">&#x27;存储过程或函数的名&#x27;</span> [<span class="keyword">AND</span> ROUTINE_TYPE <span class="operator">=</span> &#123;<span class="string">&#x27;PROCEDURE | FUNCTION&#x27;</span>&#125;]</span><br></pre></td></tr></table></figure><p>  说明：如果在 MySQL 数据库中存在存储过程和函数名称相同的情况，最好指定 ROUTINE_TYPE 查询条件来指明查询的是存储过程还是存储函数。</p></li></ul><h4 id="5-2-修改"><a href="#5-2-修改" class="headerlink" title="5.2 修改"></a>5.2 修改</h4><p>修改存储过程或函数，不影响存储过程或函数的功能，只是修改相关特性。使用 ALTER 语句实现。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; 存储过程或函数的名 [characteristic ...]</span><br></pre></td></tr></table></figure><p>其中，<code>characteristic</code> 指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="keyword">CONTAINS</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">NO</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">READS</span> <span class="keyword">SQL</span> DATA <span class="operator">|</span> <span class="keyword">MODIFIES</span> <span class="keyword">SQL</span> DATA&#125;</span><br><span class="line"><span class="operator">|</span> <span class="keyword">SQL</span> SECURITY &#123;DEFINER <span class="operator">|</span> INVOKER&#125;</span><br><span class="line"><span class="operator">|</span>COMMENT <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>CONTAINS SQL</code>，表示子程序包含 SQL 语句，但不包含读或写数据的语句。</li><li><code>NO SQL</code>，表示子程序中不包含 SQL 语句。</li><li><code>READS SQL DATA</code>，表示子程序中包含读数据的语句。</li><li><code>MODIFIES SQL DATA</code>，表示子程序中包含写数据的语句</li><li><code>SQL SECURITY &#123;DEFINER | INVOKER&#125;</code>，指明谁有权限来执行。<ul><li><code>DEFINER</code>，表示只有定义者自己才能够执行。</li><li><code>INVOKER</code>，表示调用者可以执行。</li></ul></li><li><code>COMMENT &#39;string&#39;</code>，表示注释信息。</li></ul><blockquote><p>修改存储过程使用 ALTER PROCEDURE 语句，修改存储函数使用 ALTER FUNCTION 语句。但是，这两个语句的结构是一样的，语句中的所有参数也是一样的。</p></blockquote><h4 id="5-3-删除"><a href="#5-3-删除" class="headerlink" title="5.3 删除"></a>5.3 删除</h4><p>删除存储过程和函数，可以使用 DROP 语句，其语法结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; [IF <span class="keyword">EXISTS</span>] 存储过程或函数的名</span><br></pre></td></tr></table></figure><p><code>IF EXITST</code>：如果程序或函数不存储，他可以防止发生错误，产生一个用 <code>SHOW WARNINGS</code> 查看的警告。</p><h3 id="6-关于存储过程和函数使用的争议"><a href="#6-关于存储过程和函数使用的争议" class="headerlink" title="6. 关于存储过程和函数使用的争议"></a>6. 关于存储过程和函数使用的争议</h3><p>尽管存储过程有诸多优点，但是对于存储过程的使用，一致都存在很多争议，比如有些公司对于大型项目要求使用存储过程，而有些公司在手册中明确禁止使用存储过程。</p><h4 id="6-1-优点"><a href="#6-1-优点" class="headerlink" title="6.1 优点"></a>6.1 优点</h4><ul><li><strong>存储过程可以一次编译多次使用</strong>。存储过程只在创建时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。</li><li><strong>可以减少开发工作量</strong>。将代码封装成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以重复使用，在减少开发工作量的同时，还能保证代码的结构清晰。</li><li><strong>存储过程的安全性强</strong>。在设定存储过程的时候可以设置对用户的使用权限，这样就和视图一样具有较强的安全性。</li><li><strong>可以减少网络传输量</strong>。因为代码封装存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。</li><li><strong>良好的封装性</strong>。再进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要连接一次即可。</li></ul><h4 id="6-2-缺点"><a href="#6-2-缺点" class="headerlink" title="6.2 缺点"></a>6.2 缺点</h4><p>基于上面的优点，不少大公司都要求大型项目使用存储过程，比如微软、IBM 公司。但是国内的阿里并不推荐开发人员使用存储过程。</p><blockquote><p><strong>阿里开发规范</strong></p><p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p></blockquote><ul><li><strong>可移植性差</strong>。存储过程不能夸数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</li><li><strong>调试困难</strong>。只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。</li><li><strong>存储过程的版本管理很困难</strong>。比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</li><li><strong>它不适合高并发的场景</strong>。高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，增加数据库的压力，显然就不适用了。</li></ul><h2 id="十五、变量、流程控制与游标"><a href="#十五、变量、流程控制与游标" class="headerlink" title="十五、变量、流程控制与游标"></a>十五、变量、流程控制与游标</h2><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h3><p>在 MySQL 数据库的存储过程中和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据。</p><p>在 MySQL 数据库中，变量分为<strong>系统变量</strong>以及<strong>用户自定义变量</strong>。</p><h4 id="1-1-系统变量"><a href="#1-1-系统变量" class="headerlink" title="1.1 系统变量"></a>1.1 系统变量</h4><p><strong>分类</strong>：</p><p>变量由系统定义，不是用户定义，数据服务器层面。启动 MySQL 服务，生成 MySQL 服务实例期间，MySQL 将为 MySQL 服务器内存中的系统变量赋值，这些系统变量定义了当前 MySQL 服务实例的属性、特征。这些系统变量的值要么是编译 MySQL 时参数的默认值，要么是配置文件 (例如 my.ini 等) 中的参数值。</p><p>系统变量分为全局系统变量 (需要添加 global 关键字) 以及会话系统变量 (需要添加 session 关键字)，有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为 local 变量。如果不写，默认会话级别。静态变量 (在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改) 属于特殊的全局系统变量。</p><p>每一个 MySQL 客户机成功连接 MySQL 服务器后，都会产生与之对应的会话。会话期间，MySQL 服务实例会在 MySQL 服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。</p><p>如图：</p><p><img src="http://1.117.162.142:9000/blog/mysql%E4%BC%9A%E8%AF%9D.png" alt="mysql会话"></p><ul><li>全局系统变量针对于所有会话 (连接) 有效，但不能跨重启</li><li>会话系统变量仅针对于当前会话 (连接) 有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。</li><li>会话 1 对某个全局系统变量值的修改会导致会话 2 中同一个全局系统变量值的修改。</li></ul><p>在 MySQL 中有些系统变量只能是全局的，例如 max_connections 用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如 character_set_clent 用于设置客户端的字符集；有些系统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。</p><p><strong>查看系统变量</strong>：</p><ul><li><p>查看所有活部分系统变量</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有全局变量</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES;</span><br><span class="line"></span><br><span class="line"># 查看所有会话变量</span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES;</span><br><span class="line"></span><br><span class="line"># 查看满足条件的部分系统变量</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%标识符%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 查看满足条件的部分会话变量</span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%标识符%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>查看指定系统变量</p><p>  作为 MySQL 编码规范，MySQL 中的系统变量以两个 <code>@@</code> 开头，其中 <code>@@global</code> 仅用于标记全局系统变量，<code>@@session</code> 仅用于标记会话系统变量。<code>@@</code> 首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看指定的系统变量的值</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.变量名;</span><br><span class="line"></span><br><span class="line"># 查看指定的会话变量的值</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@session</span>.变量名;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">SELECT</span> @@变量名;</span><br></pre></td></tr></table></figure></li><li><p>修改系统变量的值</p><p>  有些时候，数据库管理员需要修改系统变量的默认值，以便修改当前会话或者 MySQL 服务实例的属性、特征。具体方法：</p><ul><li>修改 MySQL 配置文件，继而修改 MySQL 系统变量的值 (该方法需要重启 MySQ L 服务)</li><li>在 MySQL 服务运行期间，使用 set 命令重新设置系统变量的值</li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 为某个系统变量赋值</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@global</span>.变量名 <span class="operator">=</span> 变量值;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> 变量名 <span class="operator">=</span> 变量值;</span><br><span class="line"></span><br><span class="line"># 为某个会话变量赋值</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.变量名 <span class="operator">=</span> 变量值;</span><br><span class="line"><span class="keyword">SET</span> SESSION 变量名 <span class="operator">=</span> 变量值;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-用户变量"><a href="#1-2-用户变量" class="headerlink" title="1.2 用户变量"></a>1.2 用户变量</h4><p><strong>用户变量分类</strong></p><p>用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以一个 <code>@</code> 开头。根据作用范围不同，又分为会话用户变量和局部变量。</p><ul><li>会话用户变量：作用域和会话变量一样，只对当前连接会话有效。</li><li>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在存储过程和函数中使用。</li></ul><p><strong>会话用户变量</strong></p><ul><li><p>定义</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 方式<span class="number">1</span>: “<span class="operator">=</span>” 或 “:<span class="operator">=</span>”</span><br><span class="line"><span class="keyword">SET</span> @用户变量 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SET</span> @用户变量 :<span class="operator">=</span> 值;</span><br><span class="line"></span><br><span class="line"># 方式<span class="number">2</span>: “:<span class="operator">=</span>“ 或 <span class="keyword">INTO</span> 关键字</span><br><span class="line"><span class="keyword">SELECT</span> @用户变量 :<span class="operator">=</span> 表达式 [<span class="keyword">FROM</span> 等子句];</span><br><span class="line"><span class="keyword">SELECT</span> 表达式 <span class="keyword">INTO</span> @用户变量 [<span class="keyword">FROM</span> 等子句];</span><br></pre></td></tr></table></figure></li><li><p>查看用户变量的值 (查看、比较、运算等)</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @用户变量;</span><br></pre></td></tr></table></figure></li></ul><p><strong>局部变量</strong></p><p>定义：可以使用 DECLARE 语句定义一个局部变量</p><p>作用域：仅仅在定义它的 BEGIN … END 中有效</p><p>位置：只能放在 BEGIN … END 中，而且只能放在第一句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"># 生命局部变量</span><br><span class="line"><span class="keyword">DECLARE</span> 变量名<span class="number">1</span> 变量数据类型 [<span class="keyword">DEFAULT</span> 变量默认值];</span><br><span class="line"><span class="keyword">DECLARE</span> 变量名<span class="number">1</span>, 变量名<span class="number">2</span>, ... 变量数据类型 [<span class="keyword">DEFAULT</span> 变量默认值];</span><br><span class="line">  </span><br><span class="line">  # 为局部变量赋值</span><br><span class="line">  <span class="keyword">SET</span> 变量名<span class="number">1</span> <span class="operator">=</span> 值;</span><br><span class="line">  <span class="keyword">SELECT</span> 值 <span class="keyword">INTO</span> 变量名<span class="number">2</span> [<span class="keyword">FROM</span> 子句];</span><br><span class="line">  </span><br><span class="line">  # 查看局部变量的值</span><br><span class="line">  <span class="keyword">SELECT</span> 变量<span class="number">1</span>, 变量<span class="number">2</span>, 变量<span class="number">3</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><ul><li><p>定义变量</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 变量名 类型 [<span class="keyword">default</span> 值];#如果没有 <span class="keyword">DEFAULT</span> 子句，初始值为 <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure></li><li><p>变量赋值</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 方式一：一般用于赋简单的值</span><br><span class="line"><span class="keyword">SET</span> 变量名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SET</span> 变量名 :<span class="operator">=</span> 值;</span><br><span class="line"># 方式二：一般用于赋表中的字段值</span><br><span class="line"><span class="keyword">SELECT</span> 字段名或表达式 <span class="keyword">INTO</span> 变量名 <span class="keyword">FROM</span> 表;</span><br></pre></td></tr></table></figure></li><li><p>使用变量 (查看、比较、运算等)</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 局部变量名;</span><br></pre></td></tr></table></figure></li></ul><p><strong>对比会话用户变量与局部变量</strong></p><table><thead><tr><th></th><th>作用域</th><th>定义位置</th><th>语法</th></tr></thead><tbody><tr><td>会话用户变量</td><td>当前会话</td><td>会话的任何地方</td><td>加 @ 符号，不用指定类型</td></tr><tr><td>局部变量</td><td>定义它的 BEGIN … END 中</td><td>BEGIN … END 的第一句话</td><td>一般不用加 @，需要指定类型</td></tr></tbody></table><h3 id="2-定义条件与处理程序"><a href="#2-定义条件与处理程序" class="headerlink" title="2. 定义条件与处理程序"></a>2. 定义条件与处理程序</h3><p>定义条件是事先定义程序执行过程中可能遇到的问题，处理程序定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。</p><p>说明：定义条件和处理程序在存储过程、存储函数中都是支持的。</p><p>案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 创建名为 UpdateDataNoCondition 的存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> UpdateDataNoCondition()</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> email <span class="operator">=</span> <span class="keyword">NULL</span> <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Able&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@x</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> email <span class="operator">=</span> <span class="string">&#x27;aaabble&#x27;</span> <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Able&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"># 调用</span><br><span class="line"><span class="keyword">CALL</span> UpdateDataNoCondition();</span><br><span class="line"># 报错</span><br><span class="line">ERROR <span class="number">1048</span> (<span class="number">23000</span>): <span class="keyword">Column</span> <span class="string">&#x27;email&#x27;</span> cannot be <span class="keyword">null</span></span><br><span class="line"># 查看变量 <span class="variable">@x</span> 的值</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@x</span>;</span><br></pre></td></tr></table></figure><p>此时 @x 的值为 1。结合创建存储过程的 SQL 语句代码可以得出：在存储过程中未定义条件和处理程序，且当存储过程中执行的 SQL 语句报错时，MySQL 数据库会抛出错误，并退出当前 SQL 逻辑，不再向下继续执行。</p><h4 id="2-1-定义条件"><a href="#2-1-定义条件" class="headerlink" title="2.1 定义条件"></a>2.1 定义条件</h4><p>定义条件就是给 MySQL 中的错误码命名，这有助于存储的程序代码更清晰。它将一个错误名字和指定的错误条件关联起来。这个名字可以随后被用在定义处理程序的 DECLARE HANDLER 语句中。</p><p>定义条件使用 DECLARE 语句，语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 错误名称 <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> 错误码(或错误条件)</span><br></pre></td></tr></table></figure><p>错误码的说明：</p><ul><li>MySQL_error_code 和 sqlstate_value 都可以表示 MySQL 的错误。<ul><li>MySQL_error_code 是数值类型错误代码。</li><li>sqlstate_value 是长度为 5 的字符串类型错误代码。</li></ul></li><li>例如，在 ERROR 1418 (HY000) 中，1418 是 MySQL_error_code，’HY000’ 是 sqlstate_value。</li></ul><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 定义 “Field_Not_Be_NULL” 错误名与 MySQL 中违反非空约束条件</span><br><span class="line"># 使用 MySQL_error_code</span><br><span class="line"><span class="keyword">DECLARE</span> Field_Not_Be_NULL <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="number">1048</span>;</span><br><span class="line"># 使用 sqlstate_value</span><br><span class="line"><span class="keyword">DECLARE</span> Field_Not_Be_NULL <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;23000&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 定义 “ERROR <span class="number">1148</span>(<span class="number">42000</span>)“ 错误，名称为 command_not_allowed。</span><br><span class="line"># 使用 MySQL_error_code</span><br><span class="line"><span class="keyword">DECLARE</span> command_not_allowed <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="number">1148</span>;</span><br><span class="line">#使用 sqlstate_value</span><br><span class="line"><span class="keyword">DECLARE</span> command_not_allwed <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;42000&#x27;</span>; </span><br></pre></td></tr></table></figure><h4 id="2-2-定义处理程序"><a href="#2-2-定义处理程序" class="headerlink" title="2.2 定义处理程序"></a>2.2 定义处理程序</h4><p>可以为 SQL 执行过程中发生的某种类型的错误定义特殊的处理程序。定义处理程序时，使用 DECLARE 语句的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 处理方式 HANDLER <span class="keyword">FOR</span> 错误类型 处理语句</span><br></pre></td></tr></table></figure><ul><li>处理方式：处理方式有 3 个取值：<code>CONTINUE</code>、<code>EXIT</code>、<code>UNDO</code>。<ul><li><code>CONTINUE</code>：表示遇到错误不处理，继续执行。</li><li><code>EXIT</code>：表示遇到错误马上退出。</li><li><code>UNDO</code>：表示遇到错误后撤回之前的操作。MySQL 中暂时不支持这样的操作。</li></ul></li><li>错误类型 (即条件) 可以有如下取值：<ul><li><code>SQLSTATE &#39;字符串错误码&#39;</code>：表示长度为 5 的 sqlstate_value 类型的错误代码；</li><li><code>MySQL_error_code</code>：匹配数值类型错误代码；</li><li><code>错误名称</code>：表示 DECLARE … CONDITION 定义的错误条件名称；</li><li><code>SQLWARNING</code>：匹配所有以 01 开头的 SQLSTATE 错误代码；</li><li><code>NOT FOUND</code>：匹配所有以 02 开头的 SQLSTATE 错误代码。</li><li><code>SQLEXCEPTION</code>：匹配所有没有被 SQLWARNING 或 NOT FOUND 捕获的 SQLSTATE 错误代码。</li></ul></li><li>处理语句：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是像 <code>SET 变量 = 值</code> 这样的简单语句，也可以是使用 <code>BEGIN ... END</code> 编写的复合语句。</li></ul><p>定义处理程序的集中方式，代码如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 方法一：捕获 sqlstate_value</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;42S02&#x27;</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 方法二：捕获 mysql_error_value</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="number">1146</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> NO_SUCH_TABLE;</span><br><span class="line"></span><br><span class="line"># 方法三：先定义条件，再调用</span><br><span class="line"><span class="keyword">DECLARE</span> no_such_table <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="number">1146</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> NO_SUCH_TABLE <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 方法四：使用 <span class="keyword">SQLWARNING</span></span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLWARNING</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;ERROR&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 方法五：使用 <span class="keyword">NOT</span> FOUND</span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 方法六：使用 <span class="keyword">SQLEXCEPTION</span></span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLEXCEPTION</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;ERROR&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="3-流程控制"><a href="#3-流程控制" class="headerlink" title="3. 流程控制"></a>3. 流程控制</h3><p>解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL 操作。流程控制语句的作用就是控制存储过程中 SQL 语句的执行顺序，是我们完成复杂操作必不可少的一部分。只要是执行的程序，流程就分为三大类：</p><ul><li>顺序结构：程序从上往下依次执行</li><li>分支结构：程序按条件进行选择执行，从两条或多条路径中选择一条执行</li><li>循环结构：程序满足一定条件下，重复执行一组语句</li></ul><p>针对 MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。</p><ul><li>条件判断语句：IF 语句和 CASE 语句</li><li>循环语句：LOOP、WHILE 和 REPEAT 语句</li><li>跳转语句：ITERATE 和 LEAVE 语句</li></ul><h4 id="3-1-分支结构之-IF"><a href="#3-1-分支结构之-IF" class="headerlink" title="3.1 分支结构之 IF"></a>3.1 分支结构之 IF</h4><ul><li><p>IF 语句的语法结构是：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IF 表达式<span class="number">1</span> <span class="keyword">THEN</span> 操作<span class="number">1</span></span><br><span class="line">[ELSEIF 表达式<span class="number">2</span> <span class="keyword">THEN</span> 操作<span class="number">2</span>] ......</span><br><span class="line">[<span class="keyword">ELSE</span> 操作N]</span><br><span class="line"><span class="keyword">END</span> IF</span><br></pre></td></tr></table></figure><p>  根据表达式的结果为 TRUE 或 FALSE 执行相应的语句。这里 “[]” 中的内容是可选的。</p></li><li><p>特点：不同的表达式对应不同的操作；使用在 <code>BEGIN ... END</code> 中。</p></li></ul><h4 id="3-2-分支结构之-CASE"><a href="#3-2-分支结构之-CASE" class="headerlink" title="3.2 分支结构之 CASE"></a>3.2 分支结构之 CASE</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">CASE</span> 语句的语法结构<span class="number">1</span>：类似于 switch</span><br><span class="line"><span class="keyword">CASE</span> 表达式</span><br><span class="line"><span class="keyword">WHEN</span> 值<span class="number">1</span> <span class="keyword">THEN</span> 结果<span class="number">1</span>或语句<span class="number">1</span>(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">WHEN</span> 值<span class="number">2</span> <span class="keyword">THEN</span> 结果<span class="number">2</span>或语句<span class="number">2</span>(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">case</span>](如果是放在 <span class="keyword">BEGIN</span> ... <span class="keyword">END</span> 中需要加上<span class="keyword">case</span>。如果放在 <span class="keyword">SELECT</span> 后面不需要加)</span><br><span class="line"></span><br><span class="line"># <span class="keyword">CASE</span> 语句的语法结构<span class="number">2</span>：类似于多重 if</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> 值<span class="number">1</span> <span class="keyword">THEN</span> 结果<span class="number">1</span>或语句<span class="number">1</span>(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">WHEN</span> 值<span class="number">2</span> <span class="keyword">THEN</span> 结果<span class="number">2</span>或语句<span class="number">2</span>(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">case</span>](如果是放在 <span class="keyword">BEGIN</span> ... <span class="keyword">END</span> 中需要加上<span class="keyword">case</span>。如果放在 <span class="keyword">SELECT</span> 后面不需要加)</span><br></pre></td></tr></table></figure><h4 id="3-3-循环结构值-LOOP"><a href="#3-3-循环结构值-LOOP" class="headerlink" title="3.3 循环结构值 LOOP"></a>3.3 循环结构值 LOOP</h4><p>LOOP 循环语句用来重复执行某些语句。LOOP 内的语句移植重复执行知道循环被退出 (使用 LEAVE 子句)，跳出循环过程。</p><p>LOOP 语句的基本格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[loop_label:] LOOP</span><br><span class="line">循环执行的语句</span><br><span class="line"><span class="keyword">END</span> LOOP [loop_label]</span><br></pre></td></tr></table></figure><p>其中，loop_label 表示 LOOP 语句的标注名称，该参数可以省略。</p><h4 id="3-4-循环结构之-WHILE"><a href="#3-4-循环结构之-WHILE" class="headerlink" title="3.4 循环结构之 WHILE"></a>3.4 循环结构之 WHILE</h4><p>WHILE 语句创建一个带条件判断的循环过程。WHILE 在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环。WHILE 语句的基本格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[while_label:] WHILE 循环条件 DO</span><br><span class="line">循环体</span><br><span class="line"><span class="keyword">END</span> WHILE [while_label]</span><br></pre></td></tr></table></figure><p>while_label 为 WHILE 语句的标注名称；如果循环条件结果为真，WHILE 语句内的语句或语句群被执行，直至循环条件为假，退出循环。</p><h4 id="3-5-循环结构之-REPEAT"><a href="#3-5-循环结构之-REPEAT" class="headerlink" title="3.5 循环结构之 REPEAT"></a>3.5 循环结构之 REPEAT</h4><p>REPEAT 语句创建一个带条件判断的循环过程。与 WHILE 循环不同的是，REPEAT 循环首先会执行一次循环，然后再 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。</p><p>REPEAT 语句的基本格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[repeat_label:] REPEAT</span><br><span class="line">循环体的语句</span><br><span class="line">UNTIL 结束循环的条件表达式</span><br><span class="line"><span class="keyword">END</span> REPEAT [repeat_label]</span><br></pre></td></tr></table></figure><p>repeat_label 为 REPEAT 语句的标注名称，该参数可以省略；REPEAT 语句内的语句或语句群被重复，直至 expr_confition 为真。</p><p><strong>对比三种循环结构</strong>：</p><ul><li>这三种循环都可以省略名称，但如果循环中添加了循环控制语句 (LEAVE 或 ITERATE) 则必须添加名称</li><li>LOOP：一般用于实现简单的“死”循环</li><li>WHILE：先判断后执行</li><li>REPEAT：先执行后判断，无条件执行至少一次</li></ul><h4 id="3-6-跳转语句之-LEAVE-语句"><a href="#3-6-跳转语句之-LEAVE-语句" class="headerlink" title="3.6 跳转语句之 LEAVE 语句"></a>3.6 跳转语句之 LEAVE 语句</h4><p>LEAVE 语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出程序体的操作。相当于 Java 中的 break。</p><p>基本格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEAVE 标记名</span><br></pre></td></tr></table></figure><p>其中，label 参数表示循环的标志。LEAVE 和 BEGIN … END 或循环一起被使用。</p><h4 id="3-7-跳转语句之-ITERATE-语句"><a href="#3-7-跳转语句之-ITERATE-语句" class="headerlink" title="3.7 跳转语句之 ITERATE 语句"></a>3.7 跳转语句之 ITERATE 语句</h4><p>ITERATE 语句：只能用在循环语句 (LOOP、REPEAT 和 WHILE 语句)内，表示重新开始循环，将执行顺序转到语句段开头处。相当于 Java 中的 continue。</p><p>语句基本格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITERATE label</span><br></pre></td></tr></table></figure><p>Label 参数表示循环的标志。ITERATE 语句必须跟在循环标志前面。</p><h3 id="4-游标"><a href="#4-游标" class="headerlink" title="4. 游标"></a>4. 游标</h3><h4 id="4-1-什么是游标-或光标"><a href="#4-1-什么是游标-或光标" class="headerlink" title="4.1 什么是游标 (或光标)"></a>4.1 什么是游标 (或光标)</h4><p>虽然我们可以通过筛选条件 WHERE 和 HAVING，或者是限定返回记录的关键字 LIMIT 返回一条记录，但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是随意定位到某一条记录，并对记录的数据进行处理。</p><p>这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。游标让 SQL 这种面向集合的语言有了相面过程开发的能力。</p><p>在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标充当了指针的作用，可以通过操作游标来对数据行进行操作。MySQL 中游标可以在存储过程和函数中使用。</p><h4 id="4-2-使用游标的步骤"><a href="#4-2-使用游标的步骤" class="headerlink" title="4.2 使用游标的步骤"></a>4.2 使用游标的步骤</h4><p>游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。</p><p>如果想要使用游标，一般需要经历四个步骤。不同的 DBMS 中，使用游标的语法可能略有不同。</p><ul><li><p>第一步，声明游标</p><p>  在 MySQL 中，使用 DECLARE 关键字来声明游标，其语法的基本形式如下：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> select_statement;</span><br></pre></td></tr></table></figure><p>  这个语法适用于 MySQL、SQL Server、DB2 和 MariaDB。如果是用 Oracle 或者 PostgreSQL，需要写成：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">IS</span> select_statement;</span><br></pre></td></tr></table></figure><p>  要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代替的是 SELECT 语句，返回一个用于创建游标的结果集。</p></li><li><p>第二步，打开游标</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> cursor_name</span><br></pre></td></tr></table></figure><p>  当定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的逐条读取结果集中的记录作准备。</p></li><li><p>第三步，使用游标 (从游标中取得数据)</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> cursor_name <span class="keyword">INTO</span> var_name [, var_name] ...</span><br></pre></td></tr></table></figure><p>  这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。</p><p>  注意：var_name 必须在声明游标之前就定义好。<strong>游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致</strong>，否则，在存储过程执行的时候，MySQL 会提示错误。</p></li><li><p>第四步，关闭游标</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> cursor_name</span><br></pre></td></tr></table></figure><p>  有 OPEN 就会有 CLOSE，也就是打开和关闭游标。当我们使用完游标后需要关闭掉该游标。因为游标会占用系统资源，如果不及时关闭，<strong>游标会一直保持到存储过程结束</strong>，影响系统运行的效率。而关闭游标的操作，会释放游标占用的系统资源。</p><p>  关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。</p></li></ul><h4 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a>4.3 小结</h4><p>游标是 MySQL 的一个重要的功能，为逐条读取结果集中的数据，提供了完美的解决方案。跟在应用层实现相同的功能相比，游标可以在存储程序中使用，效率高，程序要更加简洁。</p><p>但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行加锁，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会消耗系统资源，造成内存不足，这是因为游标是在内存中进行的处理。</p><p>建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。</p><h3 id="5-MySQL-8-0-的新特性——全局变量的持久化"><a href="#5-MySQL-8-0-的新特性——全局变量的持久化" class="headerlink" title="5. MySQL 8.0 的新特性——全局变量的持久化"></a>5. MySQL 8.0 的新特性——全局变量的持久化</h3><p>在 MySQL 数据库中，全局变量可以通过 <code>SET GLOBAL</code> 语句来设置。例如，设置服务器语句超时的限制，可以通过设置系统变量 max_execution_time 来实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> MAX_EXECUTION_TIME <span class="operator">=</span> <span class="number">2000</span>;</span><br></pre></td></tr></table></figure><p>使用 <code>SET GLOBAL</code> 语句设置的变量值只会临时生效。数据库重启后，服务器又会从 MySQL 配置文件中读取变量的默认值。</p><p>MySQL 8.0 版本增加了 <code>SET PERSIST</code> 命令。例如，设置服务器的最大连接数为 1000：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PERSIST max_connections <span class="operator">=</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>MySQL 会讲该命令的配置保存到数据目录下的mysqld-auto.cnf 文件中，下次启动时会读取该文件，用其中的配置来覆盖默认的配置文件。</p><h2 id="十六、触发器"><a href="#十六、触发器" class="headerlink" title="十六、触发器"></a>十六、触发器</h2><p>在实际开发中，我们将常会遇到这样的情况：有 2 个或者多个相互关联的表，如商品信息和库存信息分别存放在 2 个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时在库存表中添加一条库存记录。</p><p>这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用事物包裹起来，确保这两个操作成为一个院子操作，要么全部执行，要么全部不执行。要是遇到特殊的情况，可能还需要对数据进行手动维护，这样就很容易忘记其中的一步，导致数据缺失。</p><p>这个时候，咱们就可以使用触发器。你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数据的插入操作。这样一来，即不同担心忘记添加库存数据二导致的数据缺失了。</p><h3 id="1-触发器的概述"><a href="#1-触发器的概述" class="headerlink" title="1. 触发器的概述"></a>1. 触发器的概述</h3><p>MySQL 从 5.0.2 版本开始支持触发器。MySQL 的触发器和存储过程一样，都是嵌入到 MySQL 服务器的一段程序。触发器是由时间来出发某个操作，这些事件包括 INSERT、UPDATE、DELETE 事件。所谓事件就是指用户的动作或者出发某项行为。如果定义了出发程序，当数据库执行这些语句时候，就相当于事件发生了，就会自动激发触发器执行相应的操作。</p><p>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p><h3 id="2-触发器的创建"><a href="#2-触发器的创建" class="headerlink" title="2. 触发器的创建"></a>2. 触发器的创建</h3><h4 id="2-1-创建触发器语法"><a href="#2-1-创建触发器语法" class="headerlink" title="2.1 创建触发器语法"></a>2.1 创建触发器语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名称</span><br><span class="line">&#123;BEFORE <span class="operator">|</span> AFTER&#125; &#123;<span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span>&#125; <span class="keyword">ON</span> 表名</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">触发器执的语句快;  </span><br></pre></td></tr></table></figure><ul><li>表名：表示触发器监控的对象</li><li><code>BEFORE|AFTER</code>：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。</li><li><code>INSERT|UPDATE|DELETE</code>：表示出发的事件。<ul><li>INSERT 表示插入记录时触发；</li><li>UPDATE 表示更新记录时触发；</li><li>DELETE 表示删除记录时触发。</li></ul></li><li><code>触发器执行的语句块</code>：可以是单条 SQL 语句，也可以是由 <code>BEGIN ... END</code> 结构组成的复合语句块。</li></ul><h3 id="3-查看、删除触发器"><a href="#3-查看、删除触发器" class="headerlink" title="3. 查看、删除触发器"></a>3. 查看、删除触发器</h3><h4 id="3-1-查看触发器"><a href="#3-1-查看触发器" class="headerlink" title="3.1 查看触发器"></a>3.1 查看触发器</h4><p>查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 方式一：查看当前数据库的所有触发器的定义</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TRIGGER</span> \G</span><br><span class="line"></span><br><span class="line"># 方式二：查看当前数据库中某个触发器的定义</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名;</span><br><span class="line"></span><br><span class="line"># 方式三：从系统库 information_schema 的 TRIGGERS 表中查询 “salary_check_trigger” 触发器的信息。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.TRIGGERS;</span><br></pre></td></tr></table></figure><h4 id="3-2-删除触发器"><a href="#3-2-删除触发器" class="headerlink" title="3.2 删除触发器"></a>3.2 删除触发器</h4><p>触发器也是数据库对象，删除触发器也用 DROP 语句，语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> IF <span class="keyword">EXISTS</span> 触发器名称;</span><br></pre></td></tr></table></figure><h3 id="4-触发器的优缺点"><a href="#4-触发器的优缺点" class="headerlink" title="4. 触发器的优缺点"></a>4. 触发器的优缺点</h3><h4 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a>4.1 优点</h4><ul><li>触发器可以确保数据的完整性。</li><li>触发器可以帮助我们记录操作日志。</li><li>触发器还可以用在操作数据钱，对数据进行合法性检查。</li></ul><h4 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a>4.2 缺点</h4><ul><li>触发器最大的一个问题就是可读性差。</li><li>相关数据的变更，可能会导致触发器出错。</li></ul><h4 id="4-3-注意点"><a href="#4-3-注意点" class="headerlink" title="4.3 注意点"></a>4.3 注意点</h4><p>注意：如果在子表中定义了外键约束，并且外键制定了 <code>ON UPDATE/DELETE CASCADE/SET NULL</code> 子句，此时修改父表被引用的键值或删除父表被引用的记录时，也会引起子表的修改和删除操作，此时基于子表的 UPDATE 和 DELETE 语句定义的触发器并不会被激活。</p><h2 id="十七、MySQL-8-其它新特性"><a href="#十七、MySQL-8-其它新特性" class="headerlink" title="十七、MySQL 8 其它新特性"></a>十七、MySQL 8 其它新特性</h2><h3 id="1-MySQL-8-新特性概述"><a href="#1-MySQL-8-新特性概述" class="headerlink" title="1. MySQL 8 新特性概述"></a>1. MySQL 8 新特性概述</h3><p><code>MySQL 从 5.7 版本直接跳跃发布了 8.0 版本</code>，可见这是一个令人兴奋的里程碑版本。MySQL 8 版本在功能上做了显著的改进与增强，开发者对 MySQL 的源代码进行了重构，最突出的一点是多 MySQL Optimizer 优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。</p><h4 id="1-1-MySQ-L-8-0-新增特性"><a href="#1-1-MySQ-L-8-0-新增特性" class="headerlink" title="1.1 MySQ L 8.0 新增特性"></a>1.1 MySQ L 8.0 新增特性</h4><ul><li><p>更简便的 NoSQL 支持</p><p>  NoSQL 泛指非关系型数据库和数据存储。随着互联网平台的规模飞速发展，传统的关系型数据库已经越来越不能满足需求。从 5.6 版本开始，MySQL 就开始支持简单的 NoSQL 存储功能。MySQL 8 对这一功能做了优化，以更灵活的方式实现 NoSQL 功能，不再依赖模式 (schema)。</p></li><li><p>更好的索引</p><p>  在查询中，正确地使用索引可以提高查询的效率。MySQL 8 中新增了隐藏索引和降序索引。隐藏索引可以用来测试去掉索引对查询性能的影响。在查询中混合存在多列索引时，使用降序索引可以提高查询的性能。</p></li><li><p>更完善的 JSON 支持</p><p>  MySQL 从 5.7 开始支持原生 JSON 数据的存储，MySQL 8 对这一功能做了优化，增加了聚合函数 <code>JSON_ARRAYAGG()</code> 和 <code>JSON_OBJECTAGG()</code>，将参数聚合为 JSON 数组或对象，新增了行内操作符 -&gt;&gt;，是列路径运算符 -&gt; 的增强，对 JSON 排序做了提升，并优化了 JSON 的更新操作。</p></li><li><p>安全和账户管理</p><p>  MySQL 8 中新增了 <code>caching_sha2_password</code> 授权插件、角色、密码历史记录和 FIPS 模式支持，这些特性提高了数据库的安全性和性能，使数据库管理员能够灵活地进行账户管理工作。</p></li><li><p>InnoDB 的变化</p><p>  <code>InnoDB 是 MySQL 默认的存储引擎</code>，是事物型数据库的首选引擎，支持事物安全表 (ACID)，支持行锁定和外键。在 MySQL 8 版本中，InnoDB 在自增、索引、加密、死锁、共享锁等方面做了大量的改进和优化，并且支持原子数据定义语言 (DDL)，提高了数据安全性，对事物提供更好的支持。</p></li><li><p>数据字典</p><p>  在之前的 MySQL 版本中，字典数据都存储在原数据文件和非事物表中。从 MySQL 8 开始新增了事物数据字典，在这个字典里存储着数据库对象信息，这些数据字典存储在内部事务表中。</p></li><li><p>原子数据定义语句</p><p>  MySQL 8 开始支持原子数据定义语句 (Automic DDL)，即 原子 DDL。目前，只有 InnoDB 存储引擎支持原子 DDL。原子数据定义语句 (DDL) 将与 DDL 操作相关的数据字典更新、存储引擎操作、二进制日志写入结合到一个单独的原子事物中，这是的即使服务器崩溃，事物也会提交或回滚。</p><p>  使用支持原子操作的存储引擎所创建的表，在执行 <code>DROP TABLE</code>、<code>CREATE TABLE</code>、<code>ALTER TABLE</code>、<code>RENAME TABLE</code>、<code>TRUNCATE TABLE</code>、 <code>CREATE TABLESPACE</code>、<code>DROP TABLESPACE</code> 等操作时，都支持原子操作，即事物要么完全操作成功，要么失败后回滚，不再进行部分提交。</p><p>  对于 MySQL 5.7 复制到 MySQL 8 版本中的语句，可以添加 <code>IF EXITST</code> 或 <code>IF NOT EXITST</code> 语句来避免发生错误。</p></li><li><p>资源管理</p><p>  MySQL 8 开始支持创建和管理资源组，允许将服务器内运行的线程分配给特定的分组，以便线程根据组内可用资源执行。组属性能够控制组内资源，启用或限制组内资源消耗。数据库管理员能够根据不同的工作负载适当地更改这些属性。</p><p>  目前，CPU 时间是可控资源，由“虚拟 CPU” 这个概念来表示，此术语包含 CPU 的核心数，超线程，硬件线程等等。服务器在启动时确定可用的虚拟 CPU 数量。拥有对应权限的数据库管理员可以将这些 CPU 与资源组关联，并为资源组分配线程。</p><p>  资源组组件为 MySQL 中的资源组管理提供了 SQL 接口。资源组的属性用于定义资源组。MySQL 中存在两个默认组， 系统组和用户组，默认的组不能被删除，其属性也不能被更改。对于用户自定义的组，资源组创建时可初始化所有的属性，除去名字和类型，其他属性都可在创建之后进行更改。</p><p>  在一些平台下，或进行了某些 MySQL 的配置时，资源管理的功能将受到限制，甚至不可用。例如，如果安装了线程池插件，或者使用的是 macOS 系统，资源管理将处于不可用状态。在 FreeBSD 和 Solaris 系统中，资源线程优先级将失效。在 Linux 系统中，只有配置了 CAP_SYS_NICE 属性，资源管理优先级才能发挥作用。</p></li><li><p>字符集支持</p><p>  MySQL 8 中默认的字符集由 latin1 更改为 utf8mb4，并首次增加了日语所特定使用的集合，<code>utf8mb4_ja_0900_as_cs</code>。</p></li><li><p>优化器增强</p><p>  MySQL 优化器开始支持隐藏索引和降序索引。隐藏索引不会被优化器使用，验证索引的必要性时不需要删除索引，先将索引隐藏，如果优化器性能无影响就可以真正地删除索引。降序索引允许优化器对多个列进行排序，并且允许排序顺序不一致。</p></li><li><p>公用表表达式</p><p>  公用表表达式 (Common Table Expressions) 简称 CTE，MySQL 现在支持递归和非递归两种形式的 CTE。CTE 通过在 SELECT 语句或其他特定语句前使用 WITH 语句对临时结果集进行命名。</p><p>  基础语法如下：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> cte_name (col_name1, col_name2 ...) <span class="keyword">AS</span> (Subquery)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cte_name;</span><br></pre></td></tr></table></figure><p>  Subquery 代表子查询，子查询前使用 WITH 语句将结果集命名为 cte_name，在后续的查询中即可使用 cte_name 进行查询。</p></li><li><p>窗口函数</p><p>  MySQL 8 开始支持窗口函数。在之前的版本中已存在的大部分聚合函数在 MySQL 8 中也可以作为窗口函数来使用。</p><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>CUME_DIST()</td><td>累计的分布值</td></tr><tr><td>DENSE_RANK()</td><td>对当前记录不间断排序</td></tr><tr><td>FIRST_VALUE()</td><td>返回窗口首行记录的对应字段值</td></tr><tr><td>LAG()</td><td>返回对应字段的前 N 行记录</td></tr><tr><td>LAST_VALUE()</td><td>返回窗口尾行记录的对应字段值</td></tr><tr><td>LEAD()</td><td>返回对应字段的后 N 行记录</td></tr><tr><td>NTH_VALUE()</td><td>返回第 N 条记录对应的字段值</td></tr><tr><td>NTILE()</td><td>将区划分为 N 组，并返回组的数量</td></tr><tr><td>PERCENT_RANK()</td><td>返回 0 到 1 之间的小数，表示某个字段值在数据分区中的排名</td></tr><tr><td>RANK()</td><td>返回分区内每条记录对应的排名</td></tr><tr><td>ROW_NUMBER()</td><td>返回每一条记录对应的序号，且不重复</td></tr></tbody></table></li><li><p>正则表达式支持</p><p>  MySQL 在 8.0.4 以后的版本中采用支持 Unicode 的国际化组件库实现正则表达式操作，这种方式不仅能提供完全的 Unicode 支持，而且是多字节安全编码。MySQL 增加了 <code>REGEXP_LIKE()</code>、<code>EGEXP_INSTR()</code>、<code>REGEXP_REPLACE()</code> 和 <code>REGEXP_SUBSTR()</code> 等函数来提升性能。另外，regexp_stack_limit 和 regexp_time_limit 系统变量能够通过匹配引擎来控制资源消耗。</p></li><li><p>内部临时表</p><p>  <strong>TempTable 存储引擎取代 MEMORY 存储引擎成为内部临时表的默认存储引擎</strong>。TempTable 存储引擎为 VARCHAR 和 VARBINARY  列提供高效存储。internal_tmp_mem_storage_engine 会话变量定义了内部临时表的存储引擎，可选的值有两个，TempTable 和  MEMORY，其中 TempTable 为默认的存储引擎。temptable_max_ram 系统配置项定义了 TempTable 存储引擎可使用的最大内存数量。</p></li><li><p>日志记录</p><p>  在MySQL 8 中错误日志子系统由一系列 MySQL 组件构成。这些组件的构成由系统变量 log_error_services 来配置，能够实现日志事件的过滤和写入。</p></li><li><p>备份锁</p><p>  新的备份锁允许在线备份期间执行数据操作语句，同时阻止可能造成快照不一致的操作。新备份锁由 LOCK INSTANCE FOR BACKUP 和 UNLOCK INSTANCE 语法提供支持，执行这些操作需要备份管理员特权。</p></li><li><p>增强的 MySQL 复制</p><p>  MySQL 8 复制支持对 JSON 文档进行部分更新的二进制日志记录，该记录使用紧凑的二进制格式，从而节省记录完整 JSON 文档的空间。当使用基于语句的日志记录时，这种紧凑的日志记录会自动完成，并且可以通过将新的 binlog_row_value_options 系统变量值设置为 PARTIAL_JSON 来启用。</p></li></ul><h4 id="1-2-MySQL-8-0-移除的旧特性"><a href="#1-2-MySQL-8-0-移除的旧特性" class="headerlink" title="1.2 MySQL 8.0 移除的旧特性"></a>1.2 MySQL 8.0 移除的旧特性</h4><p>在 MySQL 5.7 版本上开发的应用程序如果使用了 MySLQ 8.0 移除的特性，语句可能会失败，或者产生不同的执行结果。为了避免这些问题，对于使用了移除特性的应用，应当尽力修正避免使用这些特性，并尽可能使用替代方法。</p><ul><li><p>查询缓存</p><p>  查询缓存已被移除，删除的项有：</p><ul><li>语句：<code>FLUSH QUERY CACHE</code> 和 <code>RESET QUERY CACHE</code>。</li><li>系统变量：<code>query_cache_limit</code>、<code>query_cache_min_res_unit</code>、<code>query_cache_size</code>、<code>query_cache_type</code>、<code>query_cache_wlock_invalidate</code>。</li><li>状态变量：<code>Cache_free_blocks</code>、<code>Cache_free_memory</code>、<code>Cache_hits</code>、<code>Cache_inserts</code>、<code>Cache_lowmen_prunes</code>、<code>Cache_not_cached</code>、<code>Cache_queries_in_cache</code>、<code>Qcache_total_blocks</code>。</li><li>线程状态：<code>checking privileges on cached query</code>、<code>checking query cache for query</code>、<code>invalidating query cache entries</code>、<code>sending cached result to client</code>、<code>storing result in query cache</code>、<code>waiting for query cache lock</code>。</li></ul></li><li><p>加密相关</p><p>  删除的加密相关的内容有：ENCODE()、DECODE()、ENCRYPT()、DES_ENCRYPT() 和 DES_DECRYPT() 函数，配置项 des-key-file，系统变量 have_crypt，FLUSH 语句的 DES_KEY_FILE 选项，HAVE_CRYPT CMake 选项。</p><p>  对于移除的 ENCRYPT() 函数，考虑使用 SHA2() 替代，对于其他移除的函数，使用 AES_ENCRYPT() 和 AES_DECRYPT() 替代。</p></li><li><p>空间函数相关</p><p>  在 MySQL 5.7 版本中，多个空间函数已被标记为过时。这些过时的函数在 MySQL 8 中都已被移除，只保留了对应的 ST_ 和 MBR 函数。</p></li><li><p>\N 和 NULL</p><p>  在 SQL 语句中，解析器不再将 \N 视为 NULL，所以在 SQL 语句中应使用 NULL 代替 \N。这项变化不会影响使用 <code>LOAD DATA INFILE</code> 或者 <code>SELECT ... INTO OUTFILE</code> 操作文件的导入和导出。在这类操作中，NULL 仍等同于 \N。</p></li><li><p>mysql_install_db</p><p>  在 MySQL 分布中，已移除了 mysql_install_db 程序，数据字典初始化需要调用带着 –initialize 或者 –initialize-insecure 选项的 mysqld 来代替实现。另外，–bootstrap 和 INSTALL_SCRIPTDIR CMake 也已被删除。</p></li><li><p>通用分区处理程序</p><p>  通用分区处理程序已从 MySQL 服务中被移除。为了实现给定表分区，表所使用的存储引擎需要自有的分区处理程序。</p><p>  提供本地分区支持的 MySQL 存储引擎有两个，即 InnoDB 和 NDB，而在 MySQL 8 中 只支持 InnoDB。</p></li><li><p>系统和状态变量信息</p><p>  在 INFORMATION_SCHEMA 数据库中国呢，对系统和状态变量信息不再进行维护。GLOBAL_VARIABLES、SESSION_VARIABLES、GLOBAL_STATUS、SESSION_STATUS 表都已被删除。另外，系统变量 show_compatibility_56 也已被删除。被删除的状态变量有 Slave_heartbeat_period、slave_last_heartbeat、Slave_received_heartbeats、Slave_retried_transactions、Slave_running。以上被删除的内容都可使用性能模式中对应的内容进行替代。</p></li><li><p>mysql_plugin 工具</p><p>  mysql_plugin 工具用来配置 MySQL 服务器插件，现已被删除，可使用 –plugin-load 或 –plugin-load-add 选项在服务器启动时加载插件或者在运行时使用 INSTALL PLUGIN 语句加载插件来替代该工具。</p></li></ul><h3 id="2-窗口函数"><a href="#2-窗口函数" class="headerlink" title="2. 窗口函数"></a>2. 窗口函数</h3><h4 id="2-1-窗口函数分类"><a href="#2-1-窗口函数分类" class="headerlink" title="2.1 窗口函数分类"></a>2.1 窗口函数分类</h4><p>MySQL 从 8.0 版本开始支持窗口函数。窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果集合成一条记录，而窗口函数是将结果置于每一条数据记录中。</p><p>窗口函数可以分为静态窗口函数和动态窗口函数。</p><ul><li>静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同；</li><li>动态窗口函数的窗口大小会随着记录的不同而变化。</li></ul><p>窗口函数总体上可以分为序号函数、分布函数、前后函数、首尾函数和其它函数。</p><table><thead><tr><th>函数分类</th><th>函数</th><th>函数说明</th></tr></thead><tbody><tr><td>序号函数</td><td>ROW_NUMBER()<br />RANK()<br />DENSE_RANK()</td><td>顺序排序<br />并列排序，会跳过重复的序号，比如序号为1、1、3<br />并列排序，不会跳过重复的序号，比如序号为1、1、2</td></tr><tr><td>分布函数</td><td>PERCENT_RANK()<br />CUME_DIST()</td><td>等级值百分比<br />累积分布值</td></tr><tr><td>前后函数</td><td>LAG(expr, n)<br />LEAD(expr, n)</td><td>返回当前行的前 n 行的 expr 值<br />返回当前行的后 n 行的 expr 值</td></tr><tr><td>首尾函数</td><td>FIRST_VALUE(expr)<br />LAST_VALUE(expr, n)</td><td>返回第一个 expr 值<br />返回最后一个 expr 值</td></tr><tr><td>其它函数</td><td>NTH_VALUE(expr, n)<br />NTILE(n)</td><td>返回第 n 个 expr 值<br />将分区中的有序数据分为 n 个桶，记录桶编号</td></tr></tbody></table><h4 id="2-2-语法结构"><a href="#2-2-语法结构" class="headerlink" title="2.2 语法结构"></a>2.2 语法结构</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数 <span class="keyword">OVER</span> ([<span class="keyword">PARTITION</span> <span class="keyword">BY</span> 字段名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段名 <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>])</span><br><span class="line">或</span><br><span class="line">函数 <span class="keyword">OVER</span> 窗口名 _ <span class="keyword">WINDOW</span> 窗口名 <span class="keyword">AS</span> ([<span class="keyword">PARTITION</span> <span class="keyword">BY</span> 字段名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段名 <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>])</span><br></pre></td></tr></table></figure><ul><li>OVER 关键字指定函数窗口的范围。<ul><li>如果省略后面括号中的内容，则窗口会包含满足 WHERE 条件的所有记录，窗口函数会基于所有满足 WHERE 条件的记录进行计算。</li><li>如果 OVER 关键字后面的括号不为空，则可以使用如下语法设置窗口。</li></ul></li><li>窗口名：为窗口设置一个别名，用来标识窗口。</li><li>PARTITION BY 子句：指定窗口函数按照哪些字段就行分组。分组后，窗口函数可以在每个分组中分别执行。</li><li>ORDER BY 子句：指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号。</li><li>FRAME 子句：为分区中的某个子集定义规则，可以用来作为滑动窗口使用。</li></ul><h4 id="2-3-分类讲解"><a href="#2-3-分类讲解" class="headerlink" title="2.3 分类讲解"></a>2.3 分类讲解</h4><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 创建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">category_id <span class="type">INT</span>,</span><br><span class="line">category <span class="type">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">price <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">stock <span class="type">INT</span>,</span><br><span class="line">upper_time DATETIME</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 添加数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> goods(category_id, category, NAME, price, stock, upper_time)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;女装/女士精品&#x27;</span>, <span class="string">&#x27;T恤&#x27;</span>, <span class="number">39.90</span>, <span class="number">1000</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;女装/女士精品&#x27;</span>, <span class="string">&#x27;连衣裙&#x27;</span>, <span class="number">79.90</span>, <span class="number">2500</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;女装/女士精品&#x27;</span>, <span class="string">&#x27;卫衣&#x27;</span>, <span class="number">89.90</span>, <span class="number">1500</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;女装/女士精品&#x27;</span>, <span class="string">&#x27;牛仔裤&#x27;</span>, <span class="number">89.90</span>, <span class="number">3500</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;女装/女士精品&#x27;</span>, <span class="string">&#x27;百褶裙&#x27;</span>, <span class="number">29.90</span>, <span class="number">500</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;女装/女士精品&#x27;</span>, <span class="string">&#x27;呢绒外套&#x27;</span>, <span class="number">399.90</span>, <span class="number">1200</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;户外运动&#x27;</span>, <span class="string">&#x27;自行车&#x27;</span>, <span class="number">399.90</span>, <span class="number">1000</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;户外运动&#x27;</span>, <span class="string">&#x27;山地自行车&#x27;</span>, <span class="number">1399.90</span>, <span class="number">2500</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;户外运动&#x27;</span>, <span class="string">&#x27;登山杖&#x27;</span>, <span class="number">59.90</span>, <span class="number">1500</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;户外运动&#x27;</span>, <span class="string">&#x27;骑行装备&#x27;</span>, <span class="number">399.90</span>, <span class="number">3500</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;户外运动&#x27;</span>, <span class="string">&#x27;运动外套&#x27;</span>, <span class="number">799.90</span>, <span class="number">500</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;户外运动&#x27;</span>, <span class="string">&#x27;滑板&#x27;</span>, <span class="number">499.90</span>, <span class="number">1200</span>, <span class="string">&#x27;2020-11-10 00:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure><p>针对 goods 表中的数据来验证每个窗口函数的功能。</p><ul><li><p>序号函数 - <code>ROW_NUMBER()</code> 函数</p><p>  对数据中的序号进行顺序显示。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 查询 goods 数据表中每个商品分类下价格降序排列的各个商品信息。</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span> ) <span class="keyword">AS</span> row_num,</span><br><span class="line">id, category_id, category, NAME, price, stock </span><br><span class="line"><span class="keyword">FROM</span> goods;</span><br><span class="line"># 结果</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+----+-------------+---------------------+-----------------+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> row_num <span class="operator">|</span> id <span class="operator">|</span> category_id <span class="operator">|</span> category            <span class="operator">|</span> NAME            <span class="operator">|</span> price   <span class="operator">|</span> stock <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+----+-------------+---------------------+-----------------+---------+-------+</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">1</span> <span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 呢绒外套        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>  <span class="number">1200</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 卫衣            <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span>  <span class="number">1500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">3</span> <span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 牛仔裤          <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span>  <span class="number">3500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">4</span> <span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 连衣裙          <span class="operator">|</span>   <span class="number">79.90</span> <span class="operator">|</span>  <span class="number">2500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">5</span> <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> T恤             <span class="operator">|</span>   <span class="number">39.90</span> <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">6</span> <span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 百褶裙          <span class="operator">|</span>   <span class="number">29.90</span> <span class="operator">|</span>   <span class="number">500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">1</span> <span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 山地自行车      <span class="operator">|</span> <span class="number">1399.90</span> <span class="operator">|</span>  <span class="number">2500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span> <span class="number">11</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 运动外套        <span class="operator">|</span>  <span class="number">799.90</span> <span class="operator">|</span>   <span class="number">500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">3</span> <span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 滑板            <span class="operator">|</span>  <span class="number">499.90</span> <span class="operator">|</span>  <span class="number">1200</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">4</span> <span class="operator">|</span>  <span class="number">7</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 自行车          <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">5</span> <span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 骑行装备        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>  <span class="number">3500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">6</span> <span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 登山杖          <span class="operator">|</span>   <span class="number">59.90</span> <span class="operator">|</span>  <span class="number">1500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+----+-------------+---------------------+-----------------+---------+-------+</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"># 查询 goods 数据表中每个商品分类下价格最高的 <span class="number">3</span> 种商品信息。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">( <span class="keyword">SELECT</span> <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span> ) <span class="keyword">AS</span> row_num, id, category_id, category, NAME, price, stock <span class="keyword">FROM</span> goods ) t </span><br><span class="line"><span class="keyword">WHERE</span> row_num <span class="operator">&lt;=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+----+-------------+---------------------+-----------------+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> row_num <span class="operator">|</span> id <span class="operator">|</span> category_id <span class="operator">|</span> category            <span class="operator">|</span> NAME            <span class="operator">|</span> price   <span class="operator">|</span> stock <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+----+-------------+---------------------+-----------------+---------+-------+</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">1</span> <span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 呢绒外套        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>  <span class="number">1200</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 卫衣            <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span>  <span class="number">1500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">3</span> <span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 牛仔裤          <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span>  <span class="number">3500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">1</span> <span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 山地自行车      <span class="operator">|</span> <span class="number">1399.90</span> <span class="operator">|</span>  <span class="number">2500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span> <span class="number">11</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 运动外套        <span class="operator">|</span>  <span class="number">799.90</span> <span class="operator">|</span>   <span class="number">500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">3</span> <span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 滑板            <span class="operator">|</span>  <span class="number">499.90</span> <span class="operator">|</span>  <span class="number">1200</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+----+-------------+---------------------+-----------------+---------+-------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>序号函数 - <code>RANK()</code> 函数</p><p>  对序号进行并列排序，并且会跳过重复的序号，比如序号为 1、1、3。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 获取goods 数据表中各类别的价格从高到低排序的各商品信息。</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">RANK</span>() <span class="keyword">OVER</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span> ) <span class="keyword">AS</span> row_num,</span><br><span class="line">id, category_id, category, NAME, price, stock </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">goods;</span><br><span class="line"># 结果：</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+----+-------------+---------------------+-----------------+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> row_num <span class="operator">|</span> id <span class="operator">|</span> category_id <span class="operator">|</span> category            <span class="operator">|</span> NAME            <span class="operator">|</span> price   <span class="operator">|</span> stock <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+----+-------------+---------------------+-----------------+---------+-------+</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">1</span> <span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 呢绒外套        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>  <span class="number">1200</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 卫衣            <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span>  <span class="number">1500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 牛仔裤          <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span>  <span class="number">3500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">4</span> <span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 连衣裙          <span class="operator">|</span>   <span class="number">79.90</span> <span class="operator">|</span>  <span class="number">2500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">5</span> <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> T恤             <span class="operator">|</span>   <span class="number">39.90</span> <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">6</span> <span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 百褶裙          <span class="operator">|</span>   <span class="number">29.90</span> <span class="operator">|</span>   <span class="number">500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">1</span> <span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 山地自行车      <span class="operator">|</span> <span class="number">1399.90</span> <span class="operator">|</span>  <span class="number">2500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span> <span class="number">11</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 运动外套        <span class="operator">|</span>  <span class="number">799.90</span> <span class="operator">|</span>   <span class="number">500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">3</span> <span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 滑板            <span class="operator">|</span>  <span class="number">499.90</span> <span class="operator">|</span>  <span class="number">1200</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">4</span> <span class="operator">|</span>  <span class="number">7</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 自行车          <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">4</span> <span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 骑行装备        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>  <span class="number">3500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">6</span> <span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 登山杖          <span class="operator">|</span>   <span class="number">59.90</span> <span class="operator">|</span>  <span class="number">1500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+----+-------------+---------------------+-----------------+---------+-------+</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>序号函数 - <code>DENSE_RANK()</code> 函数</p><p>  对序号进行并列排序，并且不会跳过重复的序号，比如序号为 1、1、2。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 获取 goods 数据表中各类别的价格从高到低排序的各商品信息。</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span> ) <span class="keyword">AS</span> row_num,</span><br><span class="line">id, category_id, category, NAME, price, stock </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">goods;</span><br><span class="line"></span><br><span class="line"># 结果：</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+----+-------------+---------------------+-----------------+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> row_num <span class="operator">|</span> id <span class="operator">|</span> category_id <span class="operator">|</span> category            <span class="operator">|</span> NAME            <span class="operator">|</span> price   <span class="operator">|</span> stock <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+----+-------------+---------------------+-----------------+---------+-------+</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">1</span> <span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 呢绒外套        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>  <span class="number">1200</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 卫衣            <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span>  <span class="number">1500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 牛仔裤          <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span>  <span class="number">3500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">3</span> <span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 连衣裙          <span class="operator">|</span>   <span class="number">79.90</span> <span class="operator">|</span>  <span class="number">2500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">4</span> <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> T恤             <span class="operator">|</span>   <span class="number">39.90</span> <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">5</span> <span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 百褶裙          <span class="operator">|</span>   <span class="number">29.90</span> <span class="operator">|</span>   <span class="number">500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">1</span> <span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 山地自行车      <span class="operator">|</span> <span class="number">1399.90</span> <span class="operator">|</span>  <span class="number">2500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span> <span class="number">11</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 运动外套        <span class="operator">|</span>  <span class="number">799.90</span> <span class="operator">|</span>   <span class="number">500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">3</span> <span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 滑板            <span class="operator">|</span>  <span class="number">499.90</span> <span class="operator">|</span>  <span class="number">1200</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">4</span> <span class="operator">|</span>  <span class="number">7</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 自行车          <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">4</span> <span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 骑行装备        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>  <span class="number">3500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">5</span> <span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span>           <span class="number">2</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 登山杖          <span class="operator">|</span>   <span class="number">59.90</span> <span class="operator">|</span>  <span class="number">1500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+----+-------------+---------------------+-----------------+---------+-------+</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>分布函数 - <code>PERCENT_RANK()</code> 函数</p><p>  是等级值百分比函数。按照 <code>(rank - 1) / (rows - 1)</code> 进行计算。其中，rank 的值为使用 RANK() 函数产生的序号，rows 的值为当前窗口的总记录数。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 计算 goods 数据表中名称为“女士<span class="operator">/</span>女士精品”的类别下的商品的 PERCENT_RANK 值。</span><br><span class="line"></span><br><span class="line"># 写法一：</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">RANK</span>() <span class="keyword">OVER</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span> ) <span class="keyword">AS</span> r,</span><br><span class="line"><span class="built_in">PERCENT_RANK</span>() <span class="keyword">OVER</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span> ) <span class="keyword">AS</span> pr,</span><br><span class="line">id, category_id, category, NAME, price, stock </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">goods </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">category_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># 写法二：</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">RANK</span>() <span class="keyword">OVER</span> w <span class="keyword">AS</span> r,</span><br><span class="line"><span class="built_in">PERCENT_RANK</span>() <span class="keyword">OVER</span> w <span class="keyword">AS</span> pr,</span><br><span class="line">id, category_id, category, NAME, price, stock </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">goods </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">category_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span> );</span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line"><span class="operator">+</span><span class="comment">---+-----+----+-------------+---------------------+--------------+--------+-------+</span></span><br><span class="line"><span class="operator">|</span> r <span class="operator">|</span> pr  <span class="operator">|</span> id <span class="operator">|</span> category_id <span class="operator">|</span> category            <span class="operator">|</span> NAME         <span class="operator">|</span> price  <span class="operator">|</span> stock <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+-----+----+-------------+---------------------+--------------+--------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span>   <span class="number">0</span> <span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 呢绒外套     <span class="operator">|</span> <span class="number">399.90</span> <span class="operator">|</span>  <span class="number">1200</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span> <span class="number">0.2</span> <span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 卫衣         <span class="operator">|</span>  <span class="number">89.90</span> <span class="operator">|</span>  <span class="number">1500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span> <span class="number">0.2</span> <span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 牛仔裤       <span class="operator">|</span>  <span class="number">89.90</span> <span class="operator">|</span>  <span class="number">3500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span> <span class="operator">|</span> <span class="number">0.6</span> <span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 连衣裙       <span class="operator">|</span>  <span class="number">79.90</span> <span class="operator">|</span>  <span class="number">2500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span> <span class="operator">|</span> <span class="number">0.8</span> <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> T恤          <span class="operator">|</span>  <span class="number">39.90</span> <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">6</span> <span class="operator">|</span>   <span class="number">1</span> <span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span>           <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 百褶裙       <span class="operator">|</span>  <span class="number">29.90</span> <span class="operator">|</span>   <span class="number">500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+-----+----+-------------+---------------------+--------------+--------+-------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>分布函数 - <code>CUME_DIST()</code> 函数</p><p>  查询小于或等于某个值的比例</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 查询 goods 数据表中小于或等于当前价格的比例。</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">CUME_DIST</span>() <span class="keyword">OVER</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">ASC</span> ) <span class="keyword">AS</span> cd,</span><br><span class="line">id, category, NAME, price</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">goods;</span><br><span class="line"></span><br><span class="line">#结果：</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+----+---------------------+-----------------+---------+</span></span><br><span class="line"><span class="operator">|</span> cd                  <span class="operator">|</span> id <span class="operator">|</span> category            <span class="operator">|</span> NAME            <span class="operator">|</span> price   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+----+---------------------+-----------------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0.16666666666666666</span> <span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 百褶裙          <span class="operator">|</span>   <span class="number">29.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">0.3333333333333333</span> <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> T恤             <span class="operator">|</span>   <span class="number">39.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>                 <span class="number">0.5</span> <span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 连衣裙          <span class="operator">|</span>   <span class="number">79.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">0.8333333333333334</span> <span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 卫衣            <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">0.8333333333333334</span> <span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 牛仔裤          <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>                   <span class="number">1</span> <span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 呢绒外套        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0.16666666666666666</span> <span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 登山杖          <span class="operator">|</span>   <span class="number">59.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>                 <span class="number">0.5</span> <span class="operator">|</span>  <span class="number">7</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 自行车          <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>                 <span class="number">0.5</span> <span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 骑行装备        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">0.6666666666666666</span> <span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 滑板            <span class="operator">|</span>  <span class="number">499.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">0.8333333333333334</span> <span class="operator">|</span> <span class="number">11</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 运动外套        <span class="operator">|</span>  <span class="number">799.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>                   <span class="number">1</span> <span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 山地自行车      <span class="operator">|</span> <span class="number">1399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+----+---------------------+-----------------+---------+</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>前后函数 - <code>LAG(expr, n)</code> 函数</p><p>  返回当前行的前 n 行的 expr 的值。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 查询 goods 表中前一个商品价格与当前商品价格的差值。</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">id, category, NAME, price, pre_price, price <span class="operator">-</span> pre_price <span class="keyword">AS</span> diff_price </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">id, category, NAME, price, <span class="built_in">LAG</span>( price, <span class="number">1</span> ) <span class="keyword">OVER</span> w <span class="keyword">AS</span> pre_price </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price ) </span><br><span class="line">) t;</span><br><span class="line"></span><br><span class="line"># 结果：</span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------------------+-----------------+---------+-----------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> category            <span class="operator">|</span> NAME            <span class="operator">|</span> price   <span class="operator">|</span> pre_price <span class="operator">|</span> diff_price <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------------------+-----------------+---------+-----------+------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 百褶裙          <span class="operator">|</span>   <span class="number">29.90</span> <span class="operator">|</span>      <span class="keyword">NULL</span> <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> T恤             <span class="operator">|</span>   <span class="number">39.90</span> <span class="operator">|</span>     <span class="number">29.90</span> <span class="operator">|</span>      <span class="number">10.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 连衣裙          <span class="operator">|</span>   <span class="number">79.90</span> <span class="operator">|</span>     <span class="number">39.90</span> <span class="operator">|</span>      <span class="number">40.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 卫衣            <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span>     <span class="number">79.90</span> <span class="operator">|</span>      <span class="number">10.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 牛仔裤          <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span>     <span class="number">89.90</span> <span class="operator">|</span>       <span class="number">0.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 呢绒外套        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>     <span class="number">89.90</span> <span class="operator">|</span>     <span class="number">310.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 登山杖          <span class="operator">|</span>   <span class="number">59.90</span> <span class="operator">|</span>      <span class="keyword">NULL</span> <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 自行车          <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>     <span class="number">59.90</span> <span class="operator">|</span>     <span class="number">340.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 骑行装备        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>    <span class="number">399.90</span> <span class="operator">|</span>       <span class="number">0.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 滑板            <span class="operator">|</span>  <span class="number">499.90</span> <span class="operator">|</span>    <span class="number">399.90</span> <span class="operator">|</span>     <span class="number">100.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">11</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 运动外套        <span class="operator">|</span>  <span class="number">799.90</span> <span class="operator">|</span>    <span class="number">499.90</span> <span class="operator">|</span>     <span class="number">300.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 山地自行车      <span class="operator">|</span> <span class="number">1399.90</span> <span class="operator">|</span>    <span class="number">799.90</span> <span class="operator">|</span>     <span class="number">600.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------------------+-----------------+---------+-----------+------------+</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>前后函数 - <code>LEAD(expr, n)</code> 函数</p><p>  返回当前行的后 n 行的 expr 的值。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 查询 goods 数据表中后一个商品价格与当前商品价格的差值。</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">id, category, NAME, behind_price, price,behind_price <span class="operator">-</span> price <span class="keyword">AS</span> diff_price </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">id, category, NAME, price, <span class="built_in">LEAD</span>( price, <span class="number">1</span> ) <span class="keyword">OVER</span> w <span class="keyword">AS</span> behind_price </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price )) t;</span><br><span class="line"></span><br><span class="line"># 结果:</span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------------------+-----------------+--------------+---------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> category            <span class="operator">|</span> NAME            <span class="operator">|</span> behind_price <span class="operator">|</span> price   <span class="operator">|</span> diff_price <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------------------+-----------------+--------------+---------+------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 百褶裙          <span class="operator">|</span>        <span class="number">39.90</span> <span class="operator">|</span>   <span class="number">29.90</span> <span class="operator">|</span>      <span class="number">10.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> T恤             <span class="operator">|</span>        <span class="number">79.90</span> <span class="operator">|</span>   <span class="number">39.90</span> <span class="operator">|</span>      <span class="number">40.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 连衣裙          <span class="operator">|</span>        <span class="number">89.90</span> <span class="operator">|</span>   <span class="number">79.90</span> <span class="operator">|</span>      <span class="number">10.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 卫衣            <span class="operator">|</span>        <span class="number">89.90</span> <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span>       <span class="number">0.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 牛仔裤          <span class="operator">|</span>       <span class="number">399.90</span> <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span>     <span class="number">310.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 呢绒外套        <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 登山杖          <span class="operator">|</span>       <span class="number">399.90</span> <span class="operator">|</span>   <span class="number">59.90</span> <span class="operator">|</span>     <span class="number">340.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 自行车          <span class="operator">|</span>       <span class="number">399.90</span> <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>       <span class="number">0.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 骑行装备        <span class="operator">|</span>       <span class="number">499.90</span> <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>     <span class="number">100.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 滑板            <span class="operator">|</span>       <span class="number">799.90</span> <span class="operator">|</span>  <span class="number">499.90</span> <span class="operator">|</span>     <span class="number">300.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">11</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 运动外套        <span class="operator">|</span>      <span class="number">1399.90</span> <span class="operator">|</span>  <span class="number">799.90</span> <span class="operator">|</span>     <span class="number">600.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 山地自行车      <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">1399.90</span> <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------------------+-----------------+--------------+---------+------------+</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>首尾函数 - <code>FIRST_VALUE(expr)</code> 函数 和 <code>LAST_VALUE（expr)</code> 函数</p><p>  <code>FIRST_VALUE(expr)</code> 函数返回第一个 expr 的值。<code>LAST_VALUE（expr)</code> 函数 返回最后一个 expr 的值。</p><blockquote><p>注意：</p><p>在 LAST_VALUE(expr) 函数中，默认帧规范为 <code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>，这意味着框架从第一行开始，到当前行结束。为了获取所有数据中最后一条，需要将框架规格更改为 <code>RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING </code>。</p></blockquote>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># 按照价格排序，查询第一个商品的价格信息</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">id, category, NAME, price, stock, <span class="built_in">FIRST_VALUE</span>( price ) <span class="keyword">OVER</span> w <span class="keyword">AS</span> first_price </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price );</span><br><span class="line"></span><br><span class="line"># 结果：</span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------------------+-----------------+---------+-------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> category            <span class="operator">|</span> NAME            <span class="operator">|</span> price   <span class="operator">|</span> stock <span class="operator">|</span> first_price <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------------------+-----------------+---------+-------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 百褶裙          <span class="operator">|</span>   <span class="number">29.90</span> <span class="operator">|</span>   <span class="number">500</span> <span class="operator">|</span>       <span class="number">29.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> T恤             <span class="operator">|</span>   <span class="number">39.90</span> <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span>       <span class="number">29.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 连衣裙          <span class="operator">|</span>   <span class="number">79.90</span> <span class="operator">|</span>  <span class="number">2500</span> <span class="operator">|</span>       <span class="number">29.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 卫衣            <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span>  <span class="number">1500</span> <span class="operator">|</span>       <span class="number">29.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 牛仔裤          <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span>  <span class="number">3500</span> <span class="operator">|</span>       <span class="number">29.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 呢绒外套        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>  <span class="number">1200</span> <span class="operator">|</span>       <span class="number">29.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 登山杖          <span class="operator">|</span>   <span class="number">59.90</span> <span class="operator">|</span>  <span class="number">1500</span> <span class="operator">|</span>       <span class="number">59.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 自行车          <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span>       <span class="number">59.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 骑行装备        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>  <span class="number">3500</span> <span class="operator">|</span>       <span class="number">59.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 滑板            <span class="operator">|</span>  <span class="number">499.90</span> <span class="operator">|</span>  <span class="number">1200</span> <span class="operator">|</span>       <span class="number">59.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">11</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 运动外套        <span class="operator">|</span>  <span class="number">799.90</span> <span class="operator">|</span>   <span class="number">500</span> <span class="operator">|</span>       <span class="number">59.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 山地自行车      <span class="operator">|</span> <span class="number">1399.90</span> <span class="operator">|</span>  <span class="number">2500</span> <span class="operator">|</span>       <span class="number">59.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------------------+-----------------+---------+-------+-------------+</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line"># 按照价格排序，查询最后一个商品的价格信息</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">id, category, NAME, price, stock, <span class="built_in">LAST_VALUE</span>( price ) <span class="keyword">OVER</span> w <span class="keyword">AS</span> last_price </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">RANGE</span> <span class="keyword">BETWEEN</span> UNBOUNDED PRECEDING <span class="keyword">AND</span> UNBOUNDED FOLLOWING );</span><br><span class="line"></span><br><span class="line"># 结果：</span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------------------+-----------------+---------+-------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> category            <span class="operator">|</span> NAME            <span class="operator">|</span> price   <span class="operator">|</span> stock <span class="operator">|</span> last_price <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------------------+-----------------+---------+-------+------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 百褶裙          <span class="operator">|</span>   <span class="number">29.90</span> <span class="operator">|</span>   <span class="number">500</span> <span class="operator">|</span>     <span class="number">399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> T恤             <span class="operator">|</span>   <span class="number">39.90</span> <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span>     <span class="number">399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 连衣裙          <span class="operator">|</span>   <span class="number">79.90</span> <span class="operator">|</span>  <span class="number">2500</span> <span class="operator">|</span>     <span class="number">399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 卫衣            <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span>  <span class="number">1500</span> <span class="operator">|</span>     <span class="number">399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 牛仔裤          <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span>  <span class="number">3500</span> <span class="operator">|</span>     <span class="number">399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 呢绒外套        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>  <span class="number">1200</span> <span class="operator">|</span>     <span class="number">399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 登山杖          <span class="operator">|</span>   <span class="number">59.90</span> <span class="operator">|</span>  <span class="number">1500</span> <span class="operator">|</span>    <span class="number">1399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 自行车          <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>  <span class="number">1000</span> <span class="operator">|</span>    <span class="number">1399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 骑行装备        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>  <span class="number">3500</span> <span class="operator">|</span>    <span class="number">1399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 滑板            <span class="operator">|</span>  <span class="number">499.90</span> <span class="operator">|</span>  <span class="number">1200</span> <span class="operator">|</span>    <span class="number">1399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">11</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 运动外套        <span class="operator">|</span>  <span class="number">799.90</span> <span class="operator">|</span>   <span class="number">500</span> <span class="operator">|</span>    <span class="number">1399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 山地自行车      <span class="operator">|</span> <span class="number">1399.90</span> <span class="operator">|</span>  <span class="number">2500</span> <span class="operator">|</span>    <span class="number">1399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------------------+-----------------+---------+-------+------------+</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>其它函数 - <code>NTH_VALUE(expr, n)</code> 函数</p><p>  返回第 n 个 expr 的值。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 查询 goods 数据表中排名第 <span class="number">3</span> 和 第 <span class="number">4</span> 的价格信息</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">id, category, NAME, price, <span class="built_in">NTH_VALUE</span>( price, <span class="number">2</span> ) <span class="keyword">OVER</span> w <span class="keyword">AS</span> second_price, <span class="built_in">NTH_VALUE</span>(price, <span class="number">3</span>) <span class="keyword">OVER</span> w <span class="keyword">AS</span> third_price </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price );</span><br><span class="line"></span><br><span class="line"># 结果：</span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------------------+-----------------+---------+--------------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> category            <span class="operator">|</span> NAME            <span class="operator">|</span> price   <span class="operator">|</span> second_price <span class="operator">|</span> third_price <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------------------+-----------------+---------+--------------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 百褶裙          <span class="operator">|</span>   <span class="number">29.90</span> <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span>        <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> T恤             <span class="operator">|</span>   <span class="number">39.90</span> <span class="operator">|</span>        <span class="number">39.90</span> <span class="operator">|</span>        <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 连衣裙          <span class="operator">|</span>   <span class="number">79.90</span> <span class="operator">|</span>        <span class="number">39.90</span> <span class="operator">|</span>       <span class="number">79.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 卫衣            <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span>        <span class="number">39.90</span> <span class="operator">|</span>       <span class="number">79.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 牛仔裤          <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span>        <span class="number">39.90</span> <span class="operator">|</span>       <span class="number">79.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 呢绒外套        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>        <span class="number">39.90</span> <span class="operator">|</span>       <span class="number">79.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 登山杖          <span class="operator">|</span>   <span class="number">59.90</span> <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span>        <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 自行车          <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>       <span class="number">399.90</span> <span class="operator">|</span>      <span class="number">399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 骑行装备        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span>       <span class="number">399.90</span> <span class="operator">|</span>      <span class="number">399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 滑板            <span class="operator">|</span>  <span class="number">499.90</span> <span class="operator">|</span>       <span class="number">399.90</span> <span class="operator">|</span>      <span class="number">399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">11</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 运动外套        <span class="operator">|</span>  <span class="number">799.90</span> <span class="operator">|</span>       <span class="number">399.90</span> <span class="operator">|</span>      <span class="number">399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 山地自行车      <span class="operator">|</span> <span class="number">1399.90</span> <span class="operator">|</span>       <span class="number">399.90</span> <span class="operator">|</span>      <span class="number">399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------------------+-----------------+---------+--------------+-------------+</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>其它函数 - <code>NTILE(n)</code> 函数</p><p>  将分区中的有序数据分为 n 个桶，记录桶编号。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 将 goods 表中的商品按照价格分为 <span class="number">3</span> 组。</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="built_in">NTILE</span>(<span class="number">3</span>) <span class="keyword">OVER</span> w <span class="keyword">AS</span> nt, id, category, NAME, price</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price );</span><br><span class="line"></span><br><span class="line"># 结果：</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----+---------------------+-----------------+---------+</span></span><br><span class="line"><span class="operator">|</span> nt <span class="operator">|</span> id <span class="operator">|</span> category            <span class="operator">|</span> NAME            <span class="operator">|</span> price   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----+---------------------+-----------------+---------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 百褶裙          <span class="operator">|</span>   <span class="number">29.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> T恤             <span class="operator">|</span>   <span class="number">39.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 连衣裙          <span class="operator">|</span>   <span class="number">79.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 卫衣            <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 牛仔裤          <span class="operator">|</span>   <span class="number">89.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> 女装<span class="operator">/</span>女士精品       <span class="operator">|</span> 呢绒外套        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 登山杖          <span class="operator">|</span>   <span class="number">59.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span>  <span class="number">7</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 自行车          <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 骑行装备        <span class="operator">|</span>  <span class="number">399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 滑板            <span class="operator">|</span>  <span class="number">499.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> <span class="number">11</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 运动外套        <span class="operator">|</span>  <span class="number">799.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> 户外运动            <span class="operator">|</span> 山地自行车      <span class="operator">|</span> <span class="number">1399.90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----+---------------------+-----------------+---------+</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h4><p>窗口函数的特点是可以分组，而且可以在分组内排序。另外，窗口函数不会因为分组而减少原表中的行数，这对我们在原表数据的基础上进行统计和排序非常有用。</p><h3 id="3-新特性2-公用表表达式"><a href="#3-新特性2-公用表表达式" class="headerlink" title="3. 新特性2: 公用表表达式"></a>3. 新特性2: 公用表表达式</h3><p>公用表表达式 (或通用表表达式) 简称 CTE (Common Table Expressions)。CTE 是一个命名的临时结果集，作用范围是当前语句。CTE 可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的，CTE 可以引用其它 CTE，但子查询不能引用其它子查询。所以，可以考虑代替子查询。</p><p>一句语法结构和执行方式的不同，公用表表达式分为<strong>普通公用表表达式</strong>和<strong>递归公用表表达式</strong>两种。</p><h4 id="3-1-普通公用表表达式"><a href="#3-1-普通公用表表达式" class="headerlink" title="3.1 普通公用表表达式"></a>3.1 普通公用表表达式</h4><p>普通公用表表达式的语法结构是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> CTE名称</span><br><span class="line"><span class="keyword">AS</span> (子查询)</span><br><span class="line"><span class="keyword">SELECT</span><span class="operator">|</span><span class="keyword">DELETE</span><span class="operator">|</span><span class="keyword">UPDATE</span> 语句;</span><br></pre></td></tr></table></figure><p>普通公用表表达式类似于子查询，不过跟子查询不同的是，它可以被多次引用，而且可以被其他的普通公用表表达式所引用。</p><h4 id="3-2-递归公用表表达式"><a href="#3-2-递归公用表表达式" class="headerlink" title="3.2 递归公用表表达式"></a>3.2 递归公用表表达式</h4><p>递归公用表表达式也是一种公用表表达式，只不过，除了普通公用表表达式的特点以外，它还有自己的特点，就是可以调用自己。它的语法结构是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span></span><br><span class="line">CTE名称 <span class="keyword">AS</span> (子查询)</span><br><span class="line"><span class="keyword">SELECT</span><span class="operator">|</span><span class="keyword">DELETE</span><span class="operator">|</span><span class="keyword">UPDATE</span> 语句;</span><br></pre></td></tr></table></figure><p>递归公用表表达式由两部分组成，分别是种子查询和递归查询，中间通过关键字 UNION [ALL] 进行连接。这里的<strong>种子查询，意思就是获得递归的初始值</strong>。这个查询只会运行一次，以创建初始数据集，之后递归查询会一直执行，直到没有任何新的查询数据产生，递归返回。</p><h4 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h4><p>公用表表达式可以替代子查询，而且可以被多次引用。递归公用表表达式对查询有一个共同根结点的树形结构数据非常高效，可以轻松搞定其他查询方式难以处理的查询。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2022/09/02/dsa/"/>
      <url>/2022/09/02/dsa/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构绪论"><a href="#数据结构绪论" class="headerlink" title="数据结构绪论"></a>数据结构绪论</h2><blockquote><p>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</p><p>程序设计 &#x3D; 数据结构 + 算法</p></blockquote><h3 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h3><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p><strong>描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</strong></p><p>比如我们现在常用的搜索引擎，一般会有网页、MP3、图片、视频等分类。MP3就是声音数据，图片是图像数据，而网页其实指的就是全部数据的搜索，包括最重要的数字和字符等文字数据。</p><p>也就是说，这里说的数据，其实就是符号，而且这些符号必须具备两个前提：</p><ul><li>可以输入到计算机中。</li><li>能被计算机程序处理。</li></ul><p>对于整型、实型等数值类型，可以进行数值计算。</p><p>对于字符数据类型，就需要进行非数值的处理。而声音、图像、视频等其实是可以通过编码的手段编程字符数据来处理的。</p><h4 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h4><p><strong>组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</strong></p><p>比如，在人类中，什么是数据元素呀？当然是人了。</p><p>畜类呢？牛、马、羊、狗等动物就是禽类的数据元素。</p><h4 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h4><p><strong>一个数据元素可以由若干个数据项组成。</strong></p><p>比如人这样的数据元素，可以有眼、耳、鼻、嘴、手等这些数据项，也可以有姓名、年龄、性别等数据项，具体有哪些数据项，要视你做的系统来决定。</p><p><strong>数据项是数据不可分割的最小单位</strong>。把数据项定义为最小单位是为了更好地解决问题。但真正讨论问题是，数据元素才是数据结构中建立数据模型的着眼点。就像讨论一部电影是，是讨论这部电影角色这样的“数据元素”，而不是针对这个角色的姓名或年龄这样的“数据项”去研究分析。</p><h4 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h4><p><strong>是性质相同的数据元素的集合，是数据的子集。</strong></p><p>性质相同指数据元素具有相同数量和类型的数据项，比如，人都有姓名、生日、性别等相同的数据项。</p><p>既然数据对象是数据的子集，在实际应用中，处理的数据元素通常具有相同性质，在不产生混淆的情况下，我们豆浆数据对象简称为数据。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>结构，简单的理解就是关系，比如分子结构，就是说组成分子的原子之间的排列方式。严格点说，结构是指各个组成部分相互搭配和排列的方式。在现实世界中，<strong>不同数据元素之间不是独立的，而是存在特定的关系，我们将这些关系称为结构。</strong></p><blockquote><p>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</p></blockquote><p>在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。</p><h3 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h3><p>按照视点的不同，把数据结构分为逻辑结构和物理结构。</p><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p><strong>是指数据对象中数据元素之间的相互关系</strong>。逻辑结构分为以下四种：</p><ol><li><p>集合结构</p><p> <strong>集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系</strong>。各个数据元素是“平等”的，它们的共同属性是“同属于一个集合”。数据结构中的集合关系就类似于数学中的集合。</p><p> <img src="http://1.117.162.142:9000/blog/%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84.png" alt="集合结构"></p></li><li><p>线性结构</p><p> <strong>线性结构中的数据元素之间是一对一的关系</strong>。</p><p> <img src="http://1.117.162.142:9000/blog/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.png" alt="线性结构"></p></li><li><p>树形结构</p><p> <strong>树形结构中的数据元素之间存在一种一对多的层次关系</strong>。</p><p> <img src="http://1.117.162.142:9000/blog/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.png" alt="树形结构"></p></li><li><p>图形结构</p><p> <strong>图形结构的数据元素是多对多的关系</strong>。</p><p> <img src="http://1.117.162.142:9000/blog/%E5%9B%BE%E5%BD%A2%E7%BB%93%E6%9E%84.png" alt="图形结构"></p></li></ol><p>在用示意图表示数据的逻辑结构时，要注意两点：</p><ul><li>将每个数据元素看作一个结点，用圆圈表示。</li><li>元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，那么用带箭头的连线表示。</li></ul><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p><strong>也叫存储结构，是指数据的逻辑结构在计算机中的存储形式</strong>。</p><p>数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。存储器主要是针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。</p><p>数据的存储结构应正确反应数据元素之间的逻辑关系，这才是最为关键的，如何存储数据元素之间的逻辑关系，是实现物理结构的重点和难点。</p><p>数据元素的存储结构形式有两种：顺序结构和链式结构。</p><ol><li><p>顺序存储结构</p><p> <strong>是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的</strong>。</p><p> <img src="http://1.117.162.142:9000/blog/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="顺序存储结构"></p><p> 这种存储结构其实很简单，就是排队占位。大家都按顺序排好，每个人站一段空间，大家谁也别插谁的队。数组就是这样的顺序存储结构。当你告诉计算机，你要建立一个有9个整型数据的数组时，计算机就在内存中找了片空地，按照一个整型所站位置的大小乘9，开辟一段连续的空间，于是第一个数组数据就放在第一个位置，第二个数据放在第二个，这样一次摆放。</p></li><li><p>链式存储结构</p><p> 但是并不是一直都像顺序存储结构这样简单和有规律，实际上，总会有人插队，也会有人要上厕所、有人会放弃排队。所以这个队伍当中会添加新成员，也有可能会去掉老元素，整个结构时刻都处于变化中。显然，面对这样时常要变化的结构，顺序存储结构是不科学的。</p><p> 现在如银行、医院等地方，设置了排队系统，也就是每个人去了，先领一个号，等着叫号，叫到时去办理业务或看病。在等待的时候，你爱在哪就在哪，可以坐着、站着或者走动，甚至出去逛一圈，只要及时回来就行。你关注的是前一个号有没有被叫到，叫到了，下一个就轮到了。、</p><p> <strong>链式存储结构是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的</strong>。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关数据元素的位置。</p><p> <img src="http://1.117.162.142:9000/blog/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="链式存储结构"></p><p> 显然，链式存储结构灵活多了，数据存在哪里不重要，只要有一个指针存放了相应的地址就能找到它了。</p><p> 逻辑结构是面向问题的，而物理结构就是面向计算机的，其基本的目标就是将数据及其逻辑关系存储到计算机的内存中。</p></li></ol><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><strong>是指一组性质相同的值的集合及定义在此集合上的一些操作的总称</strong>。</p><p>数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。</p><p>在计算机中，内存也不是无限大的，如果要计算一个如 1 + 1 &#x3D; 2、3 + 5 &#x3D; 8 这样的整型数字的加减乘除运算，显然不需要开辟很大的适合小数甚至字符运算的内存空间。于是计算机的研究者们就考虑，要对数据进行分类，分出来多种数据类型。</p><p>在C语言中，按照取值的不同，数据类型可以分为两类：</p><ul><li>原子类型：是<strong>不可以再分解的基本类型</strong>，包括整型、实型、字符型等。</li><li>结构类型：由<strong>若干个类型组合而成，是可以再分解的</strong>。例如，整型数组是由若干整型数据组成。</li></ul><p>比如，在C语言中变量声明 int a, b, 这就意味着，再给变量 a 和 b 赋值时不能超出 int 的取值范围，变量 a 和 b 之间的运算只能是 int 类型所允许的运算。</p><p>因为不同的计算机又不同的硬件系统，这就要求程序语言最终通过编译器或解释器转换成底层语言，如汇编语言甚至是通过机器语言的数据类型来实现的。可事实上，高级语言的编程者不管最终程序运行在什么计算机上，他的目的就是为了实现两个整型数字的运算，如 a + b、a - b、 a × b、a &#x2F; b 等，他才不关心在计算机内部是如何表示的，也不想知道 CPU 为了实现 1 + 2 进行几次开关操作，这些操作是如何实现的，对高级语言开发者来讲根本不重要。于是我们就会考虑，无论什么计算机、什么计算机语言，大都会面临着如整数运算、实数运算、字符运算等操作，我们可以考虑把它们都抽象出来。</p><p><strong>抽象是指抽取出事物具有的普遍性的本质</strong>。它是抽出问题的特征而忽略非本质的细节，是对具体事务的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。</p><h4 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><p>对已有的数据类型进行抽象，就有了抽象数据类型。</p><p><strong>抽象数据类型(Abstract Data Type, ADT)：是指一个数字模型及定义在该模型上的一组操作</strong>。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</p><p>比如，各个计算机，不管是大型机、小型机、PC、平板电脑、PDA，甚至智能手机都拥有“整数”类型，也需要整数间的运算，那么整型其实就是一个抽象数据类型，尽管它在上面提到的这些在不同计算机中实现方法上可能不一样，但由于其定义的数学特性相同，在计算机编程者看来，他们都是相同的。因此，<strong>“抽象”的意义在于数据类型的数学抽象特性</strong>。</p><p>而且，抽象数据类型不仅仅指那些已经定义并实现的数据类型，还可以是计算机编程者在设计软件程序时自己定义的数据类型，比如我们编写关于计算机绘图或者地图类的软件系统，经常都会用到坐标。也就是说，总是有成对出现的 x 和 y ，在 3D 系统中还有 z 出现，既然这三个整型数字始终在一起出现，我们就定义一个叫 ponit 的抽象数据类型，它有 x、y、z 三个整型变量，这样我们很方便地操作一个 point 数据变量就能知道这一点的坐标了。</p><p>事实上，<strong>抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性</strong>。抽象数据类型把实际生活中的问题分解为多个规模小且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。</p><p>抽象数据类型的标准格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名</span><br><span class="line">Data</span><br><span class="line">  抽象元素之间逻辑关系的定义</span><br><span class="line">Operation</span><br><span class="line">  操作 <span class="number">1</span></span><br><span class="line">  初始条件</span><br><span class="line">  操作结果描述</span><br><span class="line">  操作 <span class="number">2</span></span><br><span class="line">  ……</span><br><span class="line">  操作 n</span><br><span class="line">  ……</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>用图表示数据结构的相关概念</p><p><img src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5.png" alt="数据结构概念"></p><p>由这些概念，给出了数据结构的定义：数据结构是相互之间存在一种或多种特定关系的数据元素的集合。同样是结构，从不同的角度来讨论，会有不同的分类。</p><p><img src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88.png" alt="数据元素集合"></p><p>最后，还介绍了抽象数据类型及它的描述方法。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p></blockquote><h3 id="两种算法的比较"><a href="#两种算法的比较" class="headerlink" title="两种算法的比较"></a>两种算法的比较</h3><p>要求写一个求 1 + 2 + 3 + …… + 100 结果的程序。</p><p>常规方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br></pre></td></tr></table></figure><p>伟大数学家高斯童年方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;</span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br></pre></td></tr></table></figure><p>高斯所用方法相当于另一种等差数列的算法，不仅仅可以用于计算 1 到 100，就是加到 一千，一万（需要更改整型变量类型为长整型，否则会溢出），也很快速。但是用常规循环方式，计算机要循环一千，一万次的加法运算。</p><h3 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h3><p>如今普遍认可的对算法的定义是：<strong>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</strong></p><p>算法定义中，提到了指令，指令能被人或机器等计算装置执行。它可以是计算机指令，也可以是我们平时的语言文字。</p><p>为了解决某个或某类问题，需要把指令表示成一定的操作序列，操作序列包括一组操作，每一个操作都完成特定的功能，这就是算法了。</p><h3 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h3><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>输入和输出特性比较容易理解，<strong>算法具有零个或多个输入</strong>。尽管对于绝大多数算法来说，输入参数都是必要的，但对于个别情况，如打印“Hello World”这样的代码，不需要任何输入参数，因此算法的输入可以是零个。<strong>算法至少有一个或多个输出</strong>，算法是一定需要输出的，不需要输出，你用这个算法干嘛？输出的形式可以是打印输出，也可以是返回一个或多个值等。</p><h4 id="有穷性"><a href="#有穷性" class="headerlink" title="有穷性"></a>有穷性</h4><p><strong>指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成</strong>。现实中经常会写出死循环的代码，这就是不满足有穷性。当然这里有穷的概念并不是纯数学意义的，而是在实际应用当中合理的、可以接受的“有边界”。</p><h4 id="确定性"><a href="#确定性" class="headerlink" title="确定性"></a>确定性</h4><p><strong>算法的每一步骤都具有确定的含义，不会出现二义性</strong>。算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义。</p><h4 id="可行性"><a href="#可行性" class="headerlink" title="可行性"></a>可行性</h4><p><strong>算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成</strong>。可行性意味着算法可以转换为程序上机运行，并得到正确的结果。尽管在目前计算机界也存在那种没有实现的极为复杂的算法，不是说理论上不能实现，而是因为过于复杂，我们当前的编程方法、工具和大脑限制了这个工作，不过这都是理论研究领域的问题，不属于我们现在要考虑的范围。</p><h3 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h3><h4 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h4><p><strong>算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案</strong>。</p><p>但是算法的“正确”通常在用法上有很大的差别，大体分为以下四个层次。</p><ol><li>算法程序没有语法错误。</li><li>算法程序对于合法的输入数据能够产生满足要求的输出结果。</li><li>算法程序对于非法的输入数据能够得出满足规格说明的结果。</li><li>算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。</li></ol><p>对于这四层含义，层次 1 要求最低，但是仅仅没有语法错误实在谈不上是好算法。而层次 4 是最困难的，我们几乎不可能逐一验证所有的输入都得到正确的结果。</p><p>因此算法的正确性在大部分情况下都不可能用程序来证明，而是用数学方法证明的。证明一个复杂算法在所有层次上都是正确的，代价非常昂贵。所以一般情况下，我们把层次 3 作为一个算法是否正确的标准。</p><h4 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h4><p><strong>算法设计的另一目的就是为了便于阅读、理解和交流</strong>。</p><p>可读性高有助于人们理解算法，晦涩难懂的算法往往隐含错误，不易被发现，并且难于调试和修改。我们写代码的目的，一方面是为了让计算机执行，但还有一个重要的目的是为了便于他人阅读，让人理解和交流，自己将来也可能阅读，如果可读性不好，时间长了自己都不知道写了些什么。可读性是算法好坏很重要的标志。</p><h4 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h4><p>一个好的算法还应该能对输入数据不合法的情况做合适的处理。比如输入的时间或者距离不应该是负数等。</p><p><strong>当输入数据不合法时，算法也能做出相关处理，而不是产生异常或命名奇妙的结果</strong>。</p><h4 id="时间效率高和存储量低"><a href="#时间效率高和存储量低" class="headerlink" title="时间效率高和存储量低"></a>时间效率高和存储量低</h4><p>好的算法还应该具备时间效率高和存储量低的特点。</p><p>时间效率指的是算法的执行时间，对于同一个问题，如果有多个算法能够解决，执行时间短的算法效率高，执行时间长的效率低。存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间。<strong>设计算法应该尽量满足时间效率高和存储量低的需求</strong>。在生活中，人们都希望花最少的钱，用最短的时间，办最大的事，算法也是一样的思想，最好用最少的存储空间，花最少的时间，办成同样的事就是好的算法。</p><p>综上，好的算法，应该具有正确性、可读性、健壮性、高效率和低存储量的特征。</p><h3 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h3><h4 id="事后统计方法"><a href="#事后统计方法" class="headerlink" title="事后统计方法"></a>事后统计方法</h4><p><strong>这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低</strong>。</p><p>缺点：</p><ul><li>必须依据算法事先编制好程序，这通常需要花费大量的时间和精力。</li><li>时间的比较依赖计算机硬件和软件等环境因素，有时会掩盖算法本身的优劣。</li><li>算法的测试数据设计困难，并且程序的运行时间往往还与测试数据的规模有很大关系，效率高的算法在小的测试数据面前往往得不到提现。</li></ul><h4 id="事前分析估算法"><a href="#事前分析估算法" class="headerlink" title="事前分析估算法"></a>事前分析估算法</h4><p><strong>在计算机程序编制前，依据统计方法对算法进行估算</strong>。</p><p>一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：</p><ol><li>算法采用的策略、方法。</li><li>编译产生的代码质量。</li><li>问题的输入规模。</li><li>机器执行指令的速度。</li></ol><p>第 1 条时算法好坏的根本，第 2 条要由软件来支持，第 4 条要看硬件性能。抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间，<strong>依赖于算法的好坏和问题的输入规模</strong>。所谓<strong>问题输入规模是指输入量的多少</strong>。</p><p>比较两种求和算法：</p><p>第一种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;<span class="comment">// 执行 1 次</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">// 执行了 n + 1 次</span></span><br><span class="line">  sum = sum + i;<span class="comment">// 执行 n 次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);<span class="comment">// 执行 1 次</span></span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;<span class="comment">// 执行 1 次</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;<span class="comment">// 执行 1 次</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);<span class="comment">// 执行 1 次</span></span><br></pre></td></tr></table></figure><p>显然，第一种算法，执行了 1 + (n + 1) + n + 1 &#x3D; 2n + 3 次；而第二种算法，是 1 + 1 + 1 &#x3D; 3 次。事实上，两个算法的第一条和最后一条语句是一样的，所以我们关注的代码其实是中间的那部分，我们把循环看做一个整体，忽略头尾循环判断的开销，那么这两个算法其实就是 n 次与 1 次的差距。算法好坏显而易见。</p><p>我们不关心编写程序所用的程序设计语言是什么，也不关心这些程序将跑在什么样的计算机中，我们只关心它所实现的算法。这样，不计那些循环索引的递增和循环终止条件、变量声明、打印结果等操作，<strong>最终，在分析程序的运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤</strong>。</p><h3 id="函数的渐近增长"><a href="#函数的渐近增长" class="headerlink" title="函数的渐近增长"></a>函数的渐近增长</h3><p>判断算法 A 和算法 B 哪个更好。假设两个算法的输入规模都是 n，算法 A 要做 2n + 3 次操作，你可以理解为先有一个 n 次的循环，执行完成后，再有一个 n 次循环，最后有三次赋值或运算，共 2n + 3 次操作。算法 B 要做 3n + 1 次操作。</p><table><thead><tr><th align="center">次数</th><th align="center">算法 A (2n + 3)</th><th align="center">算法A’ (2n)</th><th align="center">算法 B (3n + 1)</th><th align="center">算法 B’ (3n)</th></tr></thead><tbody><tr><td align="center">n &#x3D; 1</td><td align="center">5</td><td align="center">2</td><td align="center">4</td><td align="center">3</td></tr><tr><td align="center">n &#x3D; 2</td><td align="center">7</td><td align="center">4</td><td align="center">7</td><td align="center">6</td></tr><tr><td align="center">n &#x3D; 3</td><td align="center">9</td><td align="center">6</td><td align="center">10</td><td align="center">9</td></tr><tr><td align="center">n &#x3D; 10</td><td align="center">23</td><td align="center">20</td><td align="center">31</td><td align="center">30</td></tr><tr><td align="center">n &#x3D; 100</td><td align="center">203</td><td align="center">200</td><td align="center">301</td><td align="center">300</td></tr></tbody></table><p>当 n &#x3D; 1 时，算法 A 效率不如算法 B (次数比算法 B 要多一次)。而当 n &#x3D; 2 时，两者效率相同；当 n &gt; 2 时，算法 A 就开始优于算法 B 了，随着 n 的增加，算法 A比算法 B 越来越好了(执行的次数比 B 要少)。于是可以得出结论，算法 A 总体上要好过算法 B。</p><p>输入规模 n 在没有限制的情况下，只要超过一个数值 N，这个函数就总是大于另一个函数，我们称函数时渐近增长的。</p><blockquote><p>函数的渐近增长：给定两个函数 f(n) 和 g(n)，如果存在一个整数 N, 使得对于所有的 n &gt; N，f(n) 总是比 g(n) 大，那么，就说 f(n) 的增长渐近快于 g(n)。</p></blockquote><p>从中可以发现，随着 n 的增大，后面的 +3 还是 +1 其实是不影响最重的算法变化的，例如算法 A’ 与算法 B’，所以，<strong>可以忽略这些加法常数</strong>。</p><p>第二个例子，算法 C 是 4n + 8，算法 D 是 2n<sup>2</sup> + 1</p><table><thead><tr><th align="center">次数</th><th align="center">算法 C (4n + 8)</th><th align="center">算法C’ (n)</th><th align="center">算法 D (2n<sup>2</sup> + 1)</th><th align="center">算法 D’ (n<sup>2</sup>)</th></tr></thead><tbody><tr><td align="center">n &#x3D; 1</td><td align="center">12</td><td align="center">1</td><td align="center">3</td><td align="center">1</td></tr><tr><td align="center">n &#x3D; 2</td><td align="center">16</td><td align="center">2</td><td align="center">9</td><td align="center">4</td></tr><tr><td align="center">n &#x3D; 3</td><td align="center">20</td><td align="center">3</td><td align="center">19</td><td align="center">9</td></tr><tr><td align="center">n &#x3D; 10</td><td align="center">48</td><td align="center">10</td><td align="center">201</td><td align="center">100</td></tr><tr><td align="center">n &#x3D; 100</td><td align="center">408</td><td align="center">100</td><td align="center">20001</td><td align="center">10000</td></tr><tr><td align="center">n &#x3D; 1000</td><td align="center">4008</td><td align="center">1000</td><td align="center">2000001</td><td align="center">1000000</td></tr></tbody></table><p>当 n ≤ 3 的时候，算法 C 要差于算法 D (因为算法 C 次数比较多)，但当 n &gt; 3后，算法 C 的优势就越来越优于算法 D 了，到后来更是远远胜过。而当后面的常数去掉后，我们发现其实结果没有发生改变。甚至哪怕去掉与 n 相乘的常数，这样的结果也没发生改变，算法 C’ 的次数随着 n 的增长，还是远小于算法 D’。也就是说，<strong>与最高次项相乘的常数并不重要</strong>。</p><p>第三个例子。算法 E 是 2n<sup>2</sup> + 3n + 1，算法 F 是 2n<sup>3</sup> + 3n + 1。</p><table><thead><tr><th align="center">次数</th><th align="center">算法 E (2n<sup>2</sup> + 3n + 1)</th><th align="center">算法E’ (n<sup>2</sup>)</th><th align="center">算法 F (2n<sup>3</sup> + 3n + 1)</th><th align="center">算法 F’ (n<sup>3</sup>)</th></tr></thead><tbody><tr><td align="center">n &#x3D; 1</td><td align="center">6</td><td align="center">1</td><td align="center">6</td><td align="center">1</td></tr><tr><td align="center">n &#x3D; 2</td><td align="center">15</td><td align="center">4</td><td align="center">23</td><td align="center">8</td></tr><tr><td align="center">n &#x3D; 3</td><td align="center">28</td><td align="center">9</td><td align="center">64</td><td align="center">27</td></tr><tr><td align="center">n &#x3D; 10</td><td align="center">231</td><td align="center">100</td><td align="center">2031</td><td align="center">1000</td></tr><tr><td align="center">n &#x3D; 100</td><td align="center">20301</td><td align="center">10000</td><td align="center">2000301</td><td align="center">1000000</td></tr></tbody></table><p>当 n &#x3D; 1的时候，算法 E 与算法 F 结果相同，但当 n &gt; 1后，算法 E 的优势就要开始优于算法 F，随着 n 的增大，差异非常明显。通过观察发现，<strong>最高次项的指数大的，函数随着 n 的增大，结果也会变得增长特别快</strong>。</p><p>最后一个例子，算法 G 是 2n<sup>2</sup>，算法 H 是 3n + 1，算法 I 是 2n<sup>2</sup> + 3n + 1 。</p><table><thead><tr><th align="center">次数</th><th align="center">算法 G (2n<sup>2</sup>)</th><th align="center">算法H (3n + 1)</th><th align="center">算法 I (2n<sup>2</sup> + 3n + 1)</th></tr></thead><tbody><tr><td align="center">n &#x3D; 1</td><td align="center">2</td><td align="center">4</td><td align="center">6</td></tr><tr><td align="center">n &#x3D; 2</td><td align="center">8</td><td align="center">7</td><td align="center">15</td></tr><tr><td align="center">n &#x3D; 5</td><td align="center">50</td><td align="center">16</td><td align="center">66</td></tr><tr><td align="center">n &#x3D; 10</td><td align="center">200</td><td align="center">31</td><td align="center">231</td></tr><tr><td align="center">n &#x3D; 100</td><td align="center">20000</td><td align="center">301</td><td align="center">20301</td></tr><tr><td align="center">n &#x3D; 1000</td><td align="center">2000000</td><td align="center">3001</td><td align="center">2003001</td></tr><tr><td align="center">n &#x3D; 10000</td><td align="center">200000000</td><td align="center">30001</td><td align="center">200030001</td></tr><tr><td align="center">n &#x3D; 100000</td><td align="center">20000000000</td><td align="center">300001</td><td align="center">20000300001</td></tr><tr><td align="center">n &#x3D; 1000000</td><td align="center">2000000000000</td><td align="center">3000001</td><td align="center">2000003000001</td></tr></tbody></table><p>当 n 的值越来越大时，3n + 1 已经没法和 2n<sup>2</sup> 的结果相比较，最终几乎可以忽略不计。也就是说，随着 n 值变得非常大以后，算法 G 其实已经很趋近于算法 I。于是我们可以得到这样一个结论，<strong>一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项(最高阶项)的阶数</strong>。</p><p>判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的。根据几个例子，如果可以对比这几个算法的关键执行次数函数的渐近增长性，基本就可以分析出：<strong>某个算法，随着 n 的增大，它会越来越优于另一个算法，或者越来越差于另一算法</strong>。这其实就是事前估算方法的理论依据，通过算法时间复杂度来估算算法时间效率。</p><h3 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h3><h4 id="算法时间复杂度定义"><a href="#算法时间复杂度定义" class="headerlink" title="算法时间复杂度定义"></a>算法时间复杂度定义</h4><blockquote><p>在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间量度，计作：T(n) &#x3D; O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函数。</p></blockquote><p>这样用大写 O() 来体现算法时间复杂度的方法，我们称之为大 O 记法。</p><p>一般情况下，随着 n 的增大，T(n) 增长最慢的算法为最优算法。</p><p>显然，由此算法时间复杂度的定义可知，我们的三个求和算法的时间复杂度分别为 O(n)，O(1)，O(n<sup>2</sup>)。O(1) 叫作常数阶、O(n) 叫作线性阶、O(n<sup>2</sup>)叫作平方阶。</p><h4 id="推导大-O-阶方法"><a href="#推导大-O-阶方法" class="headerlink" title="推导大 O 阶方法"></a>推导大 O 阶方法</h4><ol><li>用常数 1 取代运行时间中的所有加法常数。</li><li>在修改后的运行次数函数中，只保留最高阶项。</li><li>如果最高阶项存在且不是 1，则去除与这个项相乘的常数。得到的结果就是大 O 阶。</li></ol><h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4><p>首先顺序结构的时间复杂度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, sum = <span class="number">0</span>, n = <span class="number">100</span>;<span class="comment">// 执行 1 次</span></span><br><span class="line">sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;<span class="comment">// 执行 1 次</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);<span class="comment">// 执行 1 次</span></span><br></pre></td></tr></table></figure><p>这个算法的运行次数是 f(n) &#x3D; 3。根据推到大 O 阶的方法，第一步就是把常数项 3 改为 1。在保留最高阶项时，发现更本没有最高阶项，所以这个算法的时间复杂度为 O(1)。</p><p>对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着 n 的变大而发生改变，所以单纯的分支结构(不包含在循环结构中)，其时间复杂度也是 O(1)。</p><h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><p>线性阶的循环结构会复杂很多。要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集运行的次数。因此，我们要<strong>分析算法的复杂度，关键就是要分析循环结构的运行情况</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码，它的循环的时间复杂度为 O(n)，因为循环体中的代码需要执行 n 次。</p><h4 id="常数阶-1"><a href="#常数阶-1" class="headerlink" title="常数阶"></a>常数阶</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt; n) &#123;</span><br><span class="line">  count = count * <span class="number">2</span>;</span><br><span class="line">  <span class="comment">/* 时间复杂度为 O(1) 的程序步骤序列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于每次 count 乘以 2 之后，就距离 n 更近了一分。也就是说，有多少个 2 相乘后大于 n，则会退出循环。由 2<sup>x</sup> &#x3D; n 得到 x &#x3D; log<sub>2</sub>n。所以这个循环的时间复杂度为O(logn)。</p><h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="comment">/* 时间复杂度为O(1)的程序步骤序列 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个循环嵌套，它的内循环的时间复杂度为 O(n)，外层的循环，不过是内部这个时间复杂度为 O(n) 的语句，在循环 n 次。所以这段代码的时间复杂度为 O(n<sup>2</sup>)。</p><p>如果外循环的循环次数改为了 m，时间复杂度就变为 O(m × n)。</p><h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><table><thead><tr><th align="center">执行次数函数</th><th align="center">阶</th><th align="center">非正式术语</th></tr></thead><tbody><tr><td align="center">12</td><td align="center">O(1)</td><td align="center">常数阶</td></tr><tr><td align="center">2n + 3</td><td align="center">O(n)</td><td align="center">线性阶</td></tr><tr><td align="center">3n<sup>2</sup> + 2n + 1</td><td align="center">O(n<sup>2</sup>)</td><td align="center">平方阶</td></tr><tr><td align="center">5log<sub>2</sub>n + 20</td><td align="center">O(logn)</td><td align="center">对数阶</td></tr><tr><td align="center">2n + 3nlog<sub>2</sub>n + 19</td><td align="center">O(nlogn)</td><td align="center">nlogn阶</td></tr><tr><td align="center">6n<sup>3</sup> + 2n<sup>2</sup> + 3n + 4</td><td align="center">O(n<sup>3</sup>)</td><td align="center">立方阶</td></tr><tr><td align="center">2<sup>n</sup></td><td align="center">O(2<sup>n</sup>)</td><td align="center">指数阶</td></tr></tbody></table><p>常用的时间复杂度所含飞的时间从小到大依次是：</p><p><strong>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</strong></p><blockquote><p>O(n<sup>3</sup>)，过大的 n 会使得结果变得不现实。O(2<sup>n</sup>) 和 O(n!) 等除非是很小的 n 值，否则哪怕 n 只是 100，都是噩梦般的运行时间。所以这种不切实际的算法时间复杂度，一般不讨论。</p></blockquote><h3 id="最坏情况与平均情况"><a href="#最坏情况与平均情况" class="headerlink" title="最坏情况与平均情况"></a>最坏情况与平均情况</h3><p>查找一个有 n 个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度为 O(1)，但也有可能这个数字就在最后一个位置上待着，那么算法的时间复杂度就是O(n)，这是最坏的一种情况了。</p><p><strong>最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间</strong>。</p><p>而平均运行时间也就是从概率的角度看，这个数字在每一个位置的可能性是相同的，所以平均的查找时间为 n &#x2F; 2 次后发现这个目标元素。</p><p><strong>平均运行时间是所有情况中最有意义的，因为它是期望的运行时间</strong>。也即是说，我们运行一段程序代码时，是希望看到平均运行时间。可现实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。</p><p>对算法的分析，一种方法时计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。另一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。<strong>一般在没有特殊说明的情况下，都是指最坏时间复杂度</strong>。</p><h3 id="算法空间复杂度"><a href="#算法空间复杂度" class="headerlink" title="算法空间复杂度"></a>算法空间复杂度</h3><p>我们在写代码时，完全可以用空间来换取时间，比如说，要判断某某年是不是闰年，你可能会花一点心思写了一个算法，而且由于是一个算法，也就意味着，每次给一个年份，都是要通过计算得到是否是闰年的结果。还有另一个办法就是，事先建立一个有 2050 个元素的数组(年数略比现实多一点)，然后把所有的年份按下标的数字对应，如果是闰年，此数组项的值就是 1，如果不是值为 0。这样，所谓的判断某一年是否是闰年，就变成了查找这个数组的某一项的值是多少的问题。此时，我们运算是最小化了，但是硬盘上或者内存中需要存储这个 2050 个 0 和 1。</p><p>这是通过一笔空间上的开销来换取计算时间的小技巧。到底哪一个好，其实要看用在什么地方。</p><p><strong>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) &#x3D; O(f(n))，其中，n 为问题的规模，f(n) 为语句所占存储空间的函数。</strong></p><p>一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为 O(1)。</p><p>通常，我们都使用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求。当不用限定词地使用“复杂度”时，通常都是指时间复杂度。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>算法的定义：算法时解决特定问题求解步骤的描述，在计算机中为指令的有限序列，并且每条指令表示一个或多个操作。</p><p>算法的特性：有穷性、确定性、可行性、输入、输出</p><p>算法的设计的要求：正确性、可读性、健壮性、高效率和低存储量需求</p><p>算法的度量方法：事后统计方法(不科学、不准确)、事前分析估算方法</p><p>函数的渐近增长：给定两个函数 f(n) 和 g(n)，如果存在一个整数 N, 使得对于所有的 n &gt; N，f(n) 总是比 g(n) 大，那么，就说 f(n) 的增长渐近快于 g(n)。于是我们可以得出一个结论，判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的，如果我们可以对比算法的关键执行次数函数的渐近增长性，基本就可以分析出：某个算法，随着 n 的变大，它会越来越优于另一算法，或者越来越差于另一算法。</p><p>推导大 O 阶：</p><ol><li>用常数 1 取代运行时间中的所有加法常数。</li><li>在修改后的运行次数函数中，只保留最高阶项。</li><li>如果最高阶项存在且不是 1，则去除与这个项相乘的常数。得到的结果就是大 O 阶。</li></ol><p>常见的时间复杂度所耗时间的大小排列：</p><p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h3><blockquote><p>零个或多个数据元素的有限序列。</p></blockquote><p>首先它是一个序列。也就是说，元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继。</p><p>然后，线性表强调是有限的，元素个数当然也是有限的。事实上，在计算机中处理的对象都是有限的，那种无限的数据，只存在于数学的概念中。</p><p>用数学语言来进行定义：<strong>若将线性表记为 (a<sub>1</sub>, ···, a<sub>i-1</sub>, a<sub>i</sub>, a<sub>i+1</sub>, ···, a<sub>n</sub>), 则表中  a<sub>i-1</sub> 领先于 a<sub>i</sub>，a<sub>i</sub> 领先于 a<sub>i+1</sub>，称 a<sub>i+1</sub> 是 a<sub>i</sub> 的直接前驱元素，a<sub>i+1</sub> 是 a<sub>i</sub> 的直接后继元素。当 i &#x3D; 1，2，……，n-1 时，a<sub>i</sub> 有且仅有一个直接后继，当 i &#x3D; 2，3，……，n 时，a<sub>i</sub> 有且仅有一个直接前驱。</strong> 。</p><p><strong>所以线性表元素的个数 n (n ≥ 0) 定义为线性表的长度，当 n &#x3D; 0 时，称为空表</strong>。</p><p>在非空表中的每个数据元素都有一个确定的位置，如 a<sub>i</sub> 是第一个数据元素，a<sub>n</sub> 是最后一个数据元素，a<sub>i</sub> 是第 i 个数据元素，称 i 为数据元素 a<sub>i</sub> 在线性表中的位序。</p><h3 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT线性表(<span class="built_in">list</span>)</span><br><span class="line">Data</span><br><span class="line">  线性表的数据对象集合为&#123;a₁, a₂, ···, an&#125;，每个元素的类型均为 DataType。其中，除第一个元素 a₁ 外，每一个元素有且只有一个直接前驱元素，除了最后一个元素 an 外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。</span><br><span class="line">Operation</span><br><span class="line">  <span class="title function_">InitList</span><span class="params">(*L)</span>:初始化操作，建立一个空的线性表L</span><br><span class="line">  ListEmpty（L):若线性表为空，返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span></span><br><span class="line">    <span class="title function_">ClearList</span><span class="params">(*L)</span>:将线性表清空</span><br><span class="line">    <span class="title function_">GetElem</span><span class="params">(L, i, *e)</span>:将线性表 L 中的第 i 个位置元素值返回给 e</span><br><span class="line">    <span class="title function_">LocateElem</span><span class="params">(L, e)</span>:在线性表 L 中查找于给定值 e 相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回 0 表示失败</span><br><span class="line">    <span class="title function_">ListInsert</span><span class="params">(*L, i, e)</span>:在线性表 L 中的第 i 个位置插入新元素 e</span><br><span class="line">    <span class="title function_">ListDelete</span><span class="params">(*L, i, *e)</span>:删除线性表 L 中第 i 个位置元素，并用 e 返回其值</span><br><span class="line">    <span class="title function_">ListLength</span><span class="params">(L)</span>:返回线性表 L 的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p>对于不同的应用，线性表的基本操作是不同的，上述操作是最基本的，对于实际问题中涉及的关于线性表的更复杂操作，完全可以用这些基本操作的组合来实现。</p><h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3><h4 id="顺序存储定义"><a href="#顺序存储定义" class="headerlink" title="顺序存储定义"></a>顺序存储定义</h4><blockquote><p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p></blockquote><p>线性表 (a<sub>1</sub>, a<sub>1</sub>, ……, a<sub>n</sub>) 的顺序存储结构</p><p><img src="http://1.117.162.142:9000/blog/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png" alt="顺序存储"></p><h4 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h4><p>线性表的顺序存储结构，就是在内存中找了块区域，通过占位的形式，把一定的内存空间给占了，然后把相同数据类型的数据元素一次存放在这块空地种。既然线性表的每个数据元素的类型都相同，所以可以用 C 语言(其他语言也相同)的一维数组来实现顺序存储结构，即把第一个数据元素存到数组下标为 0 的位置中，接着把线性表相邻的元素存储在数组中相邻的位置。</p><p>线性表顺序存储的结构代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20<span class="comment">// 存储空间初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;<span class="comment">// ElemType 类型根据实际情况而定，这里假设为 int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> ElemType data[MAXSIZE];<span class="comment">// 数组存储数据元素，最大值为MAXSIZE</span></span><br><span class="line">  <span class="type">int</span> length;<span class="comment">// 线性表当前长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>顺序存储结构需要三个属性：</p><ul><li>存储空间的起始位置：数据 data，它的存储位置就是存储空间的存储位置</li><li>线性表的最大存储容量：数组长度 MaxSize</li><li>线性表的当前长度</li></ul><h4 id="数据长度于线性表长度区别"><a href="#数据长度于线性表长度区别" class="headerlink" title="数据长度于线性表长度区别"></a>数据长度于线性表长度区别</h4><p>数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。</p><p>在任一时刻，线性表的长度应该小于等于数组的长度。</p><h4 id="地址计算方法"><a href="#地址计算方法" class="headerlink" title="地址计算方法"></a>地址计算方法</h4><p>由于我们数数都是从 1 开始开始数的，线性表的定义起始也是 1，在程序设计中，数组的小表是从 0 开始的，所以线性表的第 i 个元素要存储在数组下标为 i-1 的位置，即数据元素的序号和存放它的数组下标之间存在对应关系。</p><p>用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，因此分配的数组空间要大于等于当前线性表的长度。</p><p><strong>存储器中的每个存储单元都有自己的编号，这个编号称为地址</strong>。由于每个数据元素，不管它是整型、实型还是字符型，它都是需要占用一定的存储单元空间的。假设占用的是 c 个存储单元，那么线性表中第 i+1 个数据元素的存储位置和第 i 个数据元素的存储位置满足下列关系(LOC 表示获得存储位置的函数)。</p><blockquote><p>LOC(a<sub>i+1</sub>) &#x3D; LOC(a<sub>i</sub>) + c</p></blockquote><p>所以对于第 i 个数据元素 a<sub>i</sub> 的存储位置可以由 a<sub>1</sub> 推算得出：</p><blockquote><p>LOC(a<sub>i</sub>) &#x3D; LOC(a<sub>1</sub>) + (i - 1) * c</p></blockquote><p>通过这个公式，随时可以算出线性表中任意位置的地址，不管它是第一个还是最后一个，都是相同的时间。那么对每个线性表位置的存入或者取出数据，对于计算机来说都是相等的时间，也就是一个常数，因此从时间复杂度的概念来看，它的存取时间性能为 O(1)。通常把具有这一特点的存储结构称为随机存取结构。</p><h3 id="顺序存储结构的插入和删除"><a href="#顺序存储结构的插入和删除" class="headerlink" title="顺序存储结构的插入和删除"></a>顺序存储结构的插入和删除</h3><h4 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h4><p>对于线性表的顺序存储结构来说，如果我们要实现 GetElem 操作，即将线性表 L 中第 i 个位置元素值返回，其实是非常简单的。只要 i 的数值在数组下标范围内，就是把数组第 i-1 下标的值返回即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line">Status <span class="title function_">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i, ElemType *e)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(L.length == <span class="number">0</span> || i &lt; <span class="number">1</span> || i &gt; L.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e = L.data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps: 这里的返回值类型 Status 是一个整数，返回 OK 代表 1，ERROR 代表 0。**时间复杂度为O(1)**。</p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>插入算法的思路：</p><ul><li>如果插入位置不合理，抛出异常；</li><li>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；</li><li>从最后一个元素开始向前遍历到第 i 歌位置，分别将它们都向后移动一个位置；</li><li>将要插入元素填入位置 i 处；</li><li>表长加 1。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(SqList *L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  <span class="keyword">if</span>(L -&gt; length == MAXSIZE)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L -&gt; length + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span>(i &lt;= L -&gt; length) &#123;</span><br><span class="line">    <span class="keyword">for</span>(k = L -&gt; length - <span class="number">1</span>; k &gt;= i <span class="number">-1</span>; k--)</span><br><span class="line">      L -&gt; data[k + <span class="number">1</span>] = L -&gt; data[k];</span><br><span class="line">  &#125;</span><br><span class="line">  L -&gt; data[i - <span class="number">1</span>] = e;</span><br><span class="line">  L -&gt; length++;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>删除算法的思路：</p><ul><li>如果删除位置不合理，抛出异常；</li><li>取出删除元素；</li><li>从删除元素位置开始便利到最后一个元素位置，分别将它们都向前移动一个位置；</li><li>表长减1。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(SqList *L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  <span class="keyword">if</span>(L -&gt; length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L -&gt; length)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  *e = L -&gt; data[i - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span>(i &lt; L -&gt; length) &#123;</span><br><span class="line">    <span class="keyword">for</span>(k = i;k &lt; L -&gt; length; k++)</span><br><span class="line">      L -&gt; data[k<span class="number">-1</span>] = L -&gt; data[k];</span><br><span class="line">  &#125;</span><br><span class="line">  L -&gt; length--;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入和删除操作的时间复杂度：</p><p>最好的情况是，如果元素要插入到最后一个位置，或者删除最后一个元素，此时时间复杂度为 O(1)，因为不需要移动元素。</p><p>最坏的情况是，如果元素要插入到第一个位置或者删除第一个元素，那就意味着要移动所有的元素向后或者向前，所以这个时间复杂度为 O(n)。</p><p>至于平均的情况，由于元素插入到第 i 个位置，或删除第 i 个元素，需要移动 n-1 个元素。根据概率原理，每个位置插入或删除的可能性是相同的，也就说位置靠前，移动元素多，位置靠后，移动元素少。最终平均移动次数和最中间的那个元素的移动次数相等，为 (n-1)&#x2F;2。根据时间复杂度的推导，平均时间复杂度还是 O(n)。</p><p>这说明线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是 O(1)；而插入或删除时，时间复杂度都是 O(n)。</p><h4 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h4><p>优点：</p><ul><li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间</li><li>可以快速地存取表中任一位置的元素</li></ul><p>缺点：</p><ul><li>插入和删除操作需要移动大量元素</li><li>当线性表长度变化较大时，难以确定存储空间的容量</li><li>造成存储空间的“碎片”</li></ul><h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h3><h4 id="线性表链式存储结构定义"><a href="#线性表链式存储结构定义" class="headerlink" title="线性表链式存储结构定义"></a>线性表链式存储结构定义</h4><p><img src="http://1.117.162.142:9000/blog/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="链式存储结构"></p><p>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。意味着，这些数据元素可以存在内存未被占用的任意位置。</p><p>顺序存储结构每个元素之需要存数据元素信息就可以了。链式存储结构除了要存数据元素信息外，还要存储他的后继元素的存储地址。</p><p>因此， <strong>为了表示每个数据元素 a<sub>i</sub> 与其直接后继数据元素 a<sub>i+1</sub> 之间的逻辑关系，对数据元素 a<sub>i</sub> 来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素 a<sub>i</sub> 的存储映像，称为结点(Node)。</strong></p><p><strong>n 个结点(a<sub>i</sub> 的存储映像)链结成一个链表，即为线性表 (a<sub>1</sub>, a<sub>2</sub>, ···, a<sub>n</sub>) 的链式存储结构，因为此链表的每个节点中只包含一个指针域，所以叫做单链表</strong>。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起。</p><p>对于线性表来说，总得有个头有个尾，链表也不例外。把<strong>链表中第一个结点的存储位置叫做头指针</strong>，那么整个链表的存取就必须是从头指针开始进行了。之后的每一个结点，其实就是上一个的后继指针指向的位置。最后一个，当然就意味着直接后继不存在了，所以规定，线性链表的最后一个结点指针为“空” (通常用 NULL 或 “^” 符号表示)。</p><p>有时为了更加方便地对链表进行操作，会在<strong>单链表的第一个结点前附设一个结点，称为头结点</strong>。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针。</p><h4 id="头指针域头结点的异同"><a href="#头指针域头结点的异同" class="headerlink" title="头指针域头结点的异同"></a>头指针域头结点的异同</h4><p>头指针：</p><ul><li>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针；</li><li>头指针具有标识作用，所以常用头指针冠以链表的名字</li><li>无论链表是否为空，头指针均不为空。头指针是链表的必要元素</li></ul><p>头结点：</p><ul><li>头结点是为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义(也可存放链表的长度)</li><li>有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了</li><li>头结点不一定是链表必须要素</li></ul><h4 id="线性表链式存储结构代码描述"><a href="#线性表链式存储结构代码描述" class="headerlink" title="线性表链式存储结构代码描述"></a>线性表链式存储结构代码描述</h4><p>单链表中，在 C 语言中可用结构指针来描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure><p>从这个结构定义中，<strong>结点由存放数据元素的数据域存放后继结点地址的指针域组成</strong>。假设 p 是指向线性表第 i 个元素的指针，则该结点 a<sub>i</sub> 的数据域可以用 p -&gt; data 来表示，p -&gt; data 的值是一个数据元素，结点 a<sub>i</sub> 的指针域可以用 p -&gt; next 来表示，p -&gt; next 的值是一个指针。指向第 i+1 个元素，即指向 a<sub>i+1</sub> 的指针。也就是说，如果 p -&gt; data &#x3D; a<sub>i</sub>，那么 p -&gt; next -&gt; data &#x3D; a<sub>i+1</sub>。</p><h3 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h3><p>获得链表第 i 个数据的算法思路：</p><ul><li>声明一个结点 p 指向链表第一个结点，初始化 j 从 1 开始；</li><li>当 j &lt; i 时，就遍历链表，让 P 的指针向后移动，不断指向下一结点，j 累加 1；</li><li>若到链表末尾 p 为空，则说明第 i 个元素不存在；</li><li>否则查找成功，返回结点 p 的数据。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i, ElemType *e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  LinkList p;<span class="comment">// 声明一结点 p</span></span><br><span class="line">  p = L -&gt; next;<span class="comment">// 让 p 指向链表 L 的第一个结点</span></span><br><span class="line">  j = <span class="number">1</span>;<span class="comment">// j 为计数器</span></span><br><span class="line">  <span class="keyword">while</span>(p &amp;&amp; j &lt; i) &#123;<span class="comment">// p 不为空或者计数器 j 还没有等于 i 时，循环继续</span></span><br><span class="line">    p = p -&gt; next;<span class="comment">// 让 p 指向下一个结点</span></span><br><span class="line">    ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!p || j &gt; i)</span><br><span class="line">    <span class="keyword">return</span> ERROR;<span class="comment">// 第 i 个元素不存在</span></span><br><span class="line">  *e = p -&gt; data;<span class="comment">// 取第 i 个元素的数据</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简而言之就是从头开始找，知道第 i 个元素为止。这个算法的时间复杂度取决于 i 的位置，当 i &#x3D; 1 时，则不需要遍历，第一个取出数据；当 i &#x3D; n 时则遍历 n - 1 次才可以。因此最坏情况的时间复杂度时 O(n)。</p><p>由于单链表的结构中没有定义表长，所以不能事先知道要循环多少次，因此就不方便使用 for 循环来控制循环。主要核心思想就是“<strong>工作指针后移</strong>“。</p><h3 id="单链表的插入和删除"><a href="#单链表的插入和删除" class="headerlink" title="单链表的插入和删除"></a>单链表的插入和删除</h3><h4 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h4><p>假设存储元素 e 的结点为 s，要实现结点 p、p -&gt; next 和 s 之间逻辑关系的变化，只需将结点 s 插入到结点 p 和 p -&gt; next 之间即可。只需要让 s -&gt; next 和 p -&gt; next 的指针做一点改变即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s -&gt; next = p -&gt; next;</span><br><span class="line">p -&gt; next = s;</span><br></pre></td></tr></table></figure><p>这两句代码就是让 p 的后继结点改成 s 的 后继结点，再把结点 s 变成 p 的后继结点</p><p>单链表第 i 个数据插入结点的算法思路：</p><ol><li>声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始；</li><li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1；</li><li>若到链表末尾 p 为空，则说明第 i 个元素不存在；</li><li>否则查找成功，在系统中生成一个空结点 s；</li><li>将数据元素 e 赋值给 s -&gt; data；</li><li>单链表的插入标准语句 s -&gt; next &#x3D; p -&gt; next; p -&gt; next &#x3D; s;</li><li>返回成功。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(LinkList *L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  LinkList p, s;</span><br><span class="line">  p = *L;</span><br><span class="line">  j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(p &amp;&amp; j &lt; i) &#123;</span><br><span class="line">    p = p -&gt; next;<span class="comment">// 寻找第 i 个结点</span></span><br><span class="line">    ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!p || j&gt; i) </span><br><span class="line">    <span class="keyword">return</span> ERROR;<span class="comment">// 第 i 个元素不存在</span></span><br><span class="line">  s = (LinkList) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(Node));<span class="comment">// 生成新结点（C 标准函数）</span></span><br><span class="line">  s -&gt; data = e;</span><br><span class="line">  s -&gt; next = P -&gt; next;<span class="comment">// 将 p 的后继结点赋值给 s 的后继</span></span><br><span class="line">  p -&gt; next = s;<span class="comment">// 将 s 赋值给 p 的后继</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mallloc 标准函数的作用是生成一个新的结点，其类型与 Node 是一样，其实质就是在内存中找了一块空地，准备用来存放 e 数据 s 结点。</p><h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><p>单链表第 i 个数据删除结点的算法思路：</p><ol><li>声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始；</li><li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一个结点，j 累加 1；</li><li>若到链表末尾 p 为空，则说明第 i 个元素不存在；</li><li>否则查找成功，将欲删除的结点 p -&gt; next 赋值给 q；</li><li>单链表的删除标准语句 p -&gt; next &#x3D; q -&gt; next；</li><li>将 q 结点中的数据赋值给 e，作为返回；</li><li>释放 q 结点；</li><li>返回成功。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(LinkList *L, <span class="type">int</span> i, ElemType *e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  LinkList p, q;</span><br><span class="line">  p = *L;</span><br><span class="line">  j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(p -&gt; next &amp;&amp; j &lt; i) &#123;<span class="comment">// 遍历寻找第 i 个元素</span></span><br><span class="line">    p = p -&gt; next;</span><br><span class="line">    ++j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!(p -&gt;next) || j &gt; i)</span><br><span class="line">    <span class="keyword">return</span> ERROR;<span class="comment">// 第 i 个元素不存在</span></span><br><span class="line">  q = p -&gt; next;</span><br><span class="line">  p -&gt; next = q -&gt; next;<span class="comment">// 将 q 的后继赋值给 p 的后继</span></span><br><span class="line">  *e = q -&gt; next;<span class="comment">// 将 q 结点中的数据给 e</span></span><br><span class="line">  <span class="built_in">free</span>(q);<span class="comment">// 让系统回收此结点，释放内存</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free 标准函数的作用是让系统回收一个 Node 结点，释放内存。</p><p>不管是单链表插入还是删除算法，其实都是由两个部分组成：遍历查找第 i 个元素；插入和删除元素。</p><p>从整个算法来看，它们的时间复杂度都是 O(n)。如果在不知道第 i 个元素的指针位置，单链表数据结构在插入和删除操作上，与线性表的顺序存储结构没有太大优势。但是如果知道第 i 个元素为止，对于顺序存储结构来说，每一次插入或删除都需要移动 n - i 个元素，每次都是 O(n)。而单链表，只需要在第一次时，找到第 i 个位置的指针，此时为 O(n)，接下来只是简单地通过赋值移动指针而已，时间复杂度都是 O(1)。所以，<strong>对于插入或删除数据越频繁的操作，单链表的效率优势越明显</strong>。</p><h3 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h3><p>顺序存储结构的创建，其实就是一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。而单链表和顺序存储结构就不一样，它不像顺序存储结构这么集中，它可以很散，是一种动态结构。对于每个链表来说，它所占空间的大小和位置是不需要预先分配划定的，可以根据系统的情况和实际的需求及时生成。</p><p>创建单链表的过程就是一个动态生成链表的过程。即从“空表”的初始状态起，一次建立各元素结点，并逐个插入链表。</p><p>单链表整表创建的算法思路：</p><ol><li>声明一结点 p 和计数器变量 i；</li><li>初始化一空链表 L；</li><li>让 L 的头结点的指针指向 NULL，即建立一个带头结点的单链表；</li><li>循环：<ul><li>生成一个新结点赋值给 p；</li><li>随机生成一数字赋值给 p 的数据域 p -&gt; data;</li><li>将 p 插入到头结点与前一新结点之间。</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateListHead</span><span class="params">(LinkList *L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  LinkList p;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  srand(time(<span class="number">0</span>));<span class="comment">// 初始化随机数种子</span></span><br><span class="line">  *L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">  (*L) -&gt; next = <span class="literal">NULL</span>;<span class="comment">// 先建立一个带头结点的单链表</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">// 生成新结点</span></span><br><span class="line">    p -&gt; data = rand() % <span class="number">100</span> + <span class="number">1</span>;<span class="comment">// 随机生成 100 以内的数字</span></span><br><span class="line">    p -&gt; next = (*L) -&gt; next;</span><br><span class="line">    (*L) -&gt; next = p;<span class="comment">// 插入到表头</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种算法用的是插队的方法，就是始终让新结点在第一的位置。称为头插法。</p><p>也可以把新结点放到最后，称为尾插法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateListTail</span><span class="params">(LinkList *L, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  LinkList p, r;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  srand(time(<span class="number">0</span>));<span class="comment">// 初始化随机数种子</span></span><br><span class="line">  *L (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">// 为整个线性表</span></span><br><span class="line">  r = *L;<span class="comment">// r 为指向尾部的结点</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">// 生成新结点</span></span><br><span class="line">    p -&gt; data = rand() % <span class="number">100</span> + <span class="number">1</span>;<span class="comment">// 随机生成 100 以内的数字</span></span><br><span class="line">    r -&gt; next = p;<span class="comment">// 将表尾终端结点的指针指向新结点</span></span><br><span class="line">    r = p;<span class="comment">// 将当前的新结点定义为表尾终端结点</span></span><br><span class="line">  &#125;</span><br><span class="line">  r -&gt; next = <span class="literal">NULL</span>;<span class="comment">// 表示当前链表结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>L 与 r 的关系，L 是指整个单链表，而 r 是指向尾结点的变量，r 会随着循环不断地变化结点，而 L 则是随着循环增长为一个多结点的链表。</p><h3 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h3><p>单链表整表删除的算法思路：</p><ol><li>声明一结点 p 和 q；</li><li>降低一个结点赋值给 P；</li><li>循环：<ul><li>将下一结点赋值给 q；</li><li>释放 p；</li><li>将 q 赋值给 p。</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">ClearList</span><span class="params">(LinkList *L)</span> &#123;</span><br><span class="line">  LinkList p,q;</span><br><span class="line">  p = (*L) -&gt; next;<span class="comment">// p 指向第一个结点</span></span><br><span class="line">  <span class="keyword">while</span>(p) &#123;<span class="comment">// 没到表尾</span></span><br><span class="line">    q = p -&gt; next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = q;</span><br><span class="line">  &#125;</span><br><span class="line">  (*L) -&gt; next = <span class="literal">NULL</span>;<span class="comment">// 头结点指针域为空</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h3><p>单链表结构和顺序存储结构对比：</p><ul><li>存储分配方式<ul><li>顺序存储结构用一段连续的存储单元依次存储线性表的数据元素</li><li>单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素</li></ul></li><li>时间性能<ul><li>查找<ul><li>顺序存储结构 O(1)</li><li>单链表 O(n)</li></ul></li><li>插入和删除<ul><li>顺序存储结构需要平均移动表长一半的元素，时间为 O(n)</li><li>单链表在现出某位置的指针后，插入和删除时间仅为 O(1)</li></ul></li></ul></li><li>空间性能<ul><li>顺序存储结构需要与分配存储空间，分大了，浪费，分小了易发生上溢</li><li>单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制</li></ul></li></ul><p>结论：</p><ul><li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。</li><li>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。</li></ul><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>让数组的元素都是由两个数据域组成，data 和 cur。也就是说，数组的每个下标都对应一个 data 和一个 cur。数据域 data，用来存放数据元素，也就是通常要处理的数据；而游标 cur 相当于单链表中的 next 指针，存放该元素的后继在数组中的下标。称这种<strong>用数组描述的链表叫做静态链表</strong>，这种描述方法叫做游标实现法。</p><p>为了我们方便插入数据，可以把数组建立得大一些，以便有一些空闲空间可以便于插入时不至于溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">// 假设链表的最大长度是 1000</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="type">int</span> cur;<span class="comment">// 游标(Cursor)，为 0 时表示无指向</span></span><br><span class="line">&#125; Component, StaticLinkList[MAXSIZE]</span><br></pre></td></tr></table></figure><p>另外对数组第一个和最后一个元素作为特殊元素处理，不存数据。把未被使用的数组元素称为备用链表。而数组第一个元素，即下标为 0 的元素的 cur 就存放备用链表的第一个结点的下标；而数组的最后一个元素的 cur 则存放第一个有数值的元素的下标，相当于单链表中的头结点作用，当整个链表为空时，则为 O<sup>2</sup>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// space[0].cur 为头指针，“0” 表示空指针</span></span><br><span class="line">Status <span class="title function_">InitList</span><span class="params">(StaticLinkList space)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)</span><br><span class="line">    space[i].cur = i + <span class="number">1</span>;</span><br><span class="line">  space[MAXSIZE - <span class="number">1</span>].cur = <span class="number">0</span>;<span class="comment">// 目前静态链表为空，最后一个元素的 cur 为 0</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态链表的插入操作"><a href="#静态链表的插入操作" class="headerlink" title="静态链表的插入操作"></a>静态链表的插入操作</h4><p>静态链表中要解决的是如何用静态模拟动态链表结构的存储空间的分配，需要时申请，无用时释放。</p><p>动态链表中，结点的申请和释放分别用 malloc() 和 free() 两个函数来实现。在静态链表中，操作的是数组，不存在像动态链表的结点申请和释放问题，要自己实现两个函数，才能做插入和删除的操作。</p><p>为了辨明数组中哪些分量未被使用，解决的办法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若备用空间链表非空，则返回分配的结点下标，否则返回 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Malloc_SLL</span><span class="params">(StaticLinkList space)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = space[<span class="number">0</span>].cur;<span class="comment">// 当前数组第一个元素的 cur 存的值，就是要返回的第一个备用空闲的下标</span></span><br><span class="line">  <span class="keyword">if</span>(space[<span class="number">0</span>].cur)</span><br><span class="line">    space[<span class="number">0</span>].cur = space[i].cur;<span class="comment">// 由于要拿出一个分量来使用了，所以我们就得把它的下一个分量用来做备用</span></span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码一方面它的作用就是返回一个下标值，这个值就是数组头元素的 cur 存的空闲的下标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 L 中第 i 个元素之前插入新的数据元素 e</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(StaticLinkList L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j, k, l;</span><br><span class="line">  k = MAX_SIZE - <span class="number">1</span>；<span class="comment">// 注意 k 首先是最后一个元素的下标</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; ListLength(L) + <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> ERROR;</span><br><span class="line">  j = Malloc_SSL(L);<span class="comment">// 获得空闲分量的下标</span></span><br><span class="line">  <span class="keyword">if</span>(j) &#123;</span><br><span class="line">    L[j].data = e;<span class="comment">// 将数据赋值给此分量的 data</span></span><br><span class="line">    <span class="keyword">for</span>(l = <span class="number">1</span>; l &lt;= i - <span class="number">1</span>; l++)<span class="comment">// 找到第 i 个元素之前的位置</span></span><br><span class="line">      k = L[k].cur;</span><br><span class="line">    L[j].cur = L[k].cur;<span class="comment">// 把第 i 个元素之前的 cur 赋值给新元素的 cur</span></span><br><span class="line">    L[k].cur = j;<span class="comment">// 把新元素的下标赋值给第 i 个元素之前元素的 cur</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态链表的删除操作"><a href="#静态链表的删除操作" class="headerlink" title="静态链表的删除操作"></a>静态链表的删除操作</h4><p>删除元素是，原来需要释放结点的函数 free()，也由自己实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除在 L 中第 i 个数据元素 e</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(StaticLinkList L, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j, k;</span><br><span class="line">  <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; ListLength(L))</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  k = MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)</span><br><span class="line">    k = L[k].cur;</span><br><span class="line">  j = L[k].cur;</span><br><span class="line">  L[k].cur = L[j].cur;</span><br><span class="line">  Free_SSL(L, j);</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将下标为 k 的空闲结点回收到备用链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Free_SSL</span><span class="params">(StaticLinkList space, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">  space[k].cur = space[<span class="number">0</span>].cur;<span class="comment">//把第一个元素 cur 值赋给要删除的分量</span></span><br><span class="line">  space[<span class="number">0</span>].cur = k;<span class="comment">// 把要删除的分量下标赋值给第一个元素的 cur</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始条件：静态链表 L 已存在。操作结果：返回 L 中数据元素个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(StaticLinkList L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = L[MAXSIZE - <span class="number">1</span>].cur;</span><br><span class="line">  <span class="keyword">while</span>(i) &#123;</span><br><span class="line">    i = L[i].cur;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态链表的优缺点"><a href="#静态链表的优缺点" class="headerlink" title="静态链表的优缺点"></a>静态链表的优缺点</h4><p>优点：</p><ul><li>在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。</li></ul><p>缺点：</p><ul><li>没有解决连续存储分配带来的表长难以确定的问题</li><li>失去了顺序存储结构随机存取的特性</li></ul><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>**将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linked list)**。</p><p>其实循环链表和单链表的主要差异在于循环的判断条件上，原来是判断 p -&gt; next 是否为空，现在则是 p -&gt; next 不等于头结点，则循环未结束。</p><p>在单链表中，有了头结点时，可以用 O(1) 的时间访问第一个结点，但对于要访问到最后一个结点，却需要 O(n) 时间，因为需要将单链表全部扫描一遍。</p><p>有没有可能用 O(1) 的时间由链表指针访问到最后一个结点呢？</p><p>需要改造一下循环链表，不用头指针，而是用指向终端结点的为指针来表示循环链表。终端结点用尾指针 rear 指示，则查找终端结点是 O(1)，而开始结点，其实就是 rear -&gt; next -&gt; next，其时间复杂度也为 O(1)。</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>在单链表中，有了 next 指针，这使得要查找下一结点的时间复杂度为 O(1)。可是如果要查找的是上一结点的话，那最坏的时间复杂度就是 O(n)了，因为每次都要从头开始遍历查找。为了克服单一性这一缺点，设计了双向链表。<strong>双向链表 (double linked list) 是在单链表的每个结点中，在设置一个指向其前驱结点的指针域</strong>。所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性表的双向链表存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> &#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">prior</span>;</span><span class="comment">// 直接前驱指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span> *<span class="title">next</span>;</span><span class="comment">// 直接后继指针</span></span><br><span class="line">&#125; DulNode, *DuLinkList;</span><br></pre></td></tr></table></figure><p>双向链表是单链表中扩展出来的结构，所以它的很多操作是和单链表相同的，比如求长度 ListLength，查找元素的 GetElem，获得元素位置的 LocateElem 等，这些操作都只要涉及一个方向的指针即可，另一个指针多了也不能提供什么帮助。</p><p>插入操作时，假设存储元素 e 的结点为 s，要实现将结点 s 插入到结点 p 和 p -&gt; next 之间需要以下几步：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s -&gt; prior = p;<span class="comment">// 把 p 赋值给 s 的前驱</span></span><br><span class="line">s -&gt; next = p -&gt; next;<span class="comment">// 把 p -&gt; next 赋值给 s 的后继</span></span><br><span class="line">p -&gt; next -&gt; prior = s;<span class="comment">// 把 s 赋值给 p -&gt; next 的前驱</span></span><br><span class="line">p -&gt; next = s;<span class="comment">// 把 s 赋值给 p 的后继</span></span><br></pre></td></tr></table></figure><p>删除操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; prior -&gt; next = p -&gt; next;<span class="comment">// 把 p -&gt; next 赋值给 p -&gt; prior 的后继</span></span><br><span class="line">p -&gt; next -&gt; prior = p -&gt; prior;<span class="comment">// 把 p -&gt; prior 赋值给 p -&gt; next 的前驱</span></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">// 释放结点</span></span><br></pre></td></tr></table></figure><p>双向链表对于单链表来说，多了 prior 指针。另外它由于每个结点都需要记录两份指针，所以在空间上是要占用略多一些的。不过由于它良好的对称性，使得对某个结点的前后结点的操作，带来了方便，可以有效提高算法的时间性能。也就是用空间来换时间。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>线性表：是零个或多个相同类型的数据元素的有限序列。</p><p>由与顺序存储结构的插入和删除操作不方便，引出了链式存储结构，它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点。、</p><p>链式存储结构的不同形式：单链表、循环链表和双向链表。</p><p><img src="http://1.117.162.142:9000/blog/%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%88%86%E7%B1%BB.png" alt="线性表分类"></p><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><blockquote><p>栈与队列：</p><p>栈是限定仅在表尾进行插入和删除操作的线性表。</p><p>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。</p></blockquote><h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><h4 id="栈的定义-1"><a href="#栈的定义-1" class="headerlink" title="栈的定义"></a>栈的定义</h4><blockquote><p>栈 (stack) 是限定仅在表尾进行插入和删除操作的线性表。</p></blockquote><p>把允许插入和删除的一端称为栈顶 (top)，另一端称为栈底 (bottom)，不含任何数据元素的栈称为空栈。栈又称为后进先出 (Last In First Out) 的线性表，简称 LIFO 结构。</p><p>栈是一个线性表，也就是说栈元素具有线性关系，即前驱后继关系。只不过它是一种特殊的线性表而已。定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。</p><p><strong>栈的插入操作，叫作进栈，也成压栈、入栈。栈的删除操作，叫作出栈，也有的叫作弹栈。</strong></p><p><img src="http://1.117.162.142:9000/blog/%E8%BF%9B%E6%A0%88%E5%87%BA%E6%A0%88.png" alt="进栈出栈"></p><h4 id="进栈出栈变化形式"><a href="#进栈出栈变化形式" class="headerlink" title="进栈出栈变化形式"></a>进栈出栈变化形式</h4><blockquote><p>是不是最先进栈的元素就只能是最后出栈呢？</p></blockquote><p>在不是所有元素都进栈的情况下，事先进去的元素也可以出栈，只要保证栈顶元素出栈即可。</p><p>例如有 3 个整型数字 1、2、3 一次进栈，会有一下几种出栈次序。</p><ul><li>1、2、3 进，再 3、2、1 出。出栈顺序为 321。</li><li>1 进，1 出，2 进，2 出，3 进，3 出。出栈顺序为 123。</li><li>1 进，2 进，2 出，1 出，3 进，3 出。出栈顺序为 213。</li><li>1 进，1 出，2 进，3 进，3 出，2 出。出栈顺序为 132。</li><li>1 进，2 进，2 出，3 进，3 出，1 出。出栈顺序为 231。</li></ul><p>没有可能出现 312 这种出栈顺序，因为 3 先出栈，说明 3 曾经进栈，意味着 1 和 2 已经进栈了，此时 2 一定在 1 的上面。</p><h3 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h3><p>对于栈来讲，理论上线性表的操作特性他都具备，可由于它的特殊性，所以针对它在操作上会有些变化。特别是插入和删除操作，push 和 pop，一般叫作进栈和出栈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 栈(<span class="built_in">stack</span>)</span><br><span class="line">Data</span><br><span class="line">  同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">  <span class="title function_">InitStack</span><span class="params">(*S)</span>: 初始化操作，建立一个空栈 S。</span><br><span class="line">  <span class="title function_">DestroyStack</span><span class="params">(*S)</span>: 若栈存在，则销毁它。</span><br><span class="line">  <span class="title function_">ClearStack</span><span class="params">(*S)</span>: 将栈清空。</span><br><span class="line">  <span class="title function_">StackEmpty</span><span class="params">(S)</span>: 若栈为空，返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line">  <span class="title function_">GetTop</span><span class="params">(S, *e)</span>: 若栈存在且为空，用 e 返回 S 的栈顶元素。</span><br><span class="line">  <span class="title function_">Push</span><span class="params">(*S, e)</span>: 若栈 s 存在，插入新元素 e 到栈 S 中并成为栈顶元素。</span><br><span class="line">  <span class="title function_">Pop</span><span class="params">(*S, *e)</span>: 删除栈 S 中栈顶元素，并用 e 返回其值。</span><br><span class="line">  <span class="title function_">StackLength</span><span class="params">(S)</span>: 返回栈 S 的元素个数。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p>栈本身就是线性表，所以线性表的顺序存储和链式存储对于栈来说，也是同样适用的。</p><h3 id="栈的顺序存储结构及实现"><a href="#栈的顺序存储结构及实现" class="headerlink" title="栈的顺序存储结构及实现"></a>栈的顺序存储结构及实现</h3><h4 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h4><blockquote><p>线性表使用数组实现的，但是栈只能一头插入删除，所以要考虑用数组的哪一端作为栈顶和栈底比较好。</p></blockquote><p>下标为 0 的一端作为栈底比较好，因为首元素都存在栈底，变化最小，所以让它做栈底。</p><p>定义一个 top 变量来指示栈顶元素在数组中的位置，这 top 就如同中学物理学过的游标卡尺的游标，可以来回移动，意味着栈顶的 top 可以变大变小，但无论如何游标不能超出尺的长度。同理，若存储栈的长素为 StackSize，则栈顶位置 top 必须小于 StackSize。当栈存在一个元素时，top 等于 0，因此通常把空栈的判定条件定为 top 等于 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;<span class="comment">// SElemType 类型根据实际情况而定，这里假设为 int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  SElemType data[MAXSIZE];</span><br><span class="line">  <span class="type">int</span> top;<span class="comment">// 用于栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><h4 id="栈的顺序存储结构——进栈操作"><a href="#栈的顺序存储结构——进栈操作" class="headerlink" title="栈的顺序存储结构——进栈操作"></a>栈的顺序存储结构——进栈操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入元素 e 为新的栈顶元素</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqStack *S, SElemType e)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(S -&gt; top == MAXSIZE - <span class="number">1</span>) &#123;<span class="comment">// 栈满</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">  S -&gt; top++;<span class="comment">// 栈顶指针增加 1</span></span><br><span class="line">  S -&gt; data[S -&gt; top] = e;<span class="comment">// 将新元素赋值给栈顶空间</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈的顺序存储结构——出栈操作"><a href="#栈的顺序存储结构——出栈操作" class="headerlink" title="栈的顺序存储结构——出栈操作"></a>栈的顺序存储结构——出栈操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若栈不空，则删除 S 的栈顶元素，用 e 返回其值，并返回 OK；否则返回 ERROR</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqStack *S, SElemType *e)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(S -&gt; top == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  *e = S -&gt; data[S -&gt; top];<span class="comment">// 将要删除的栈顶元素赋值给 e</span></span><br><span class="line">  S -&gt; top--;<span class="comment">// 栈顶指针减 1</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入栈和出栈操作都没有涉及到任何循环语句，时间复杂度均是 O(1)。</p><h3 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h3><p>如果有两个相同类型的栈，为它们各自开辟了数组空间，极有可能是第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。可以用一个数组来存储两个栈。数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为 0 处，另一个栈的栈底为数组的末端，即下标为为数组长度 n - 1 处。这样，两个栈如果增加元素，就是两端点向中间延伸。</p><p><img src="http://1.117.162.142:9000/blog/%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4.png" alt="两栈共享空间"></p><p>它们在数组的两端，向中间靠拢。top1 和 top2 是栈 1 和 栈 2 的栈顶指针。当栈 1 为空时，就是 top1 &#x3D; -1 时；而当 top2 等于 n 时，即是栈 2 为空时。若栈 2 是空栈，栈 1 的 top1 &#x3D; n - 1 时，就是栈 1 满了。反之，当栈 1 为空栈时，top2  &#x3D; 0 时，为栈 2 满。但更多的情况是两个指针之间相差 1 时，即 top1 + 1 &#x3D;&#x3D; top2 为栈满。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两栈共享空间结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  SElemType data[MAXSIZE];</span><br><span class="line">  <span class="type">int</span> top1;<span class="comment">// 栈 1 栈顶指针</span></span><br><span class="line">  <span class="type">int</span> top2;<span class="comment">// 栈 2 栈顶指针</span></span><br><span class="line">&#125;SqDoubleStack;</span><br></pre></td></tr></table></figure><p>对于两栈共享空间的 push 方法，除了要插入元素值参数外，还需要有一个判断是栈 1 还是栈 2 的栈号 stackNumber。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入元素 e 为新的栈顶元素</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqDoubleStack *S, SElemType e, <span class="type">int</span> stackNumber)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(S -&gt; top1 + <span class="number">1</span> == S -&gt; top2)<span class="comment">// 栈已满，不能再 push 新元素了</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span>(stackNumber == <span class="number">1</span>)<span class="comment">// 栈 1 有元素进栈</span></span><br><span class="line">    S -&gt; data[++S -&gt; top1] = e;<span class="comment">// 若栈 1 则先 top1 + 1 后给数组元素赋值</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(stackNumber == <span class="number">2</span>)<span class="comment">// 栈 2 有元素进栈</span></span><br><span class="line">    S -&gt; data[--S -&gt; top2] = e;<span class="comment">// 若栈 2 则先 top2 - 1 后给数组元素赋值</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在开始已经判断了是否有栈满的情况，所以后面的 top1 + 1 或 top2 -1 是不担心溢出问题的。</p><p>对于两栈共享空间的 pop方法，参数就只是判断栈 1 栈 2 的参数 stackNumber。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若栈不空，则删除 S 的栈顶元素，用 e 返回其值，并返回 OK；否则返回 ERROR</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqDoubleStack *S, SElemType *e, <span class="type">int</span> stackNumber)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(stackNumber == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(S -&gt; top1 == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">return</span> ERROR;<span class="comment">// 说明栈 1 已经是空栈，溢出</span></span><br><span class="line">    *e = S -&gt; data[S -&gt; top1--];<span class="comment">// 将栈 1 的栈顶元素出栈</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(stackNumber == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(S -&gt; top2 == MAXSIZE)</span><br><span class="line">      <span class="keyword">return</span> ERROR;<span class="comment">// 说明栈 2 已经是空栈，溢出</span></span><br><span class="line">    *e = S -&gt; data[S -&gt; top2++];<span class="comment">// 将栈 2 的栈顶元素出栈</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，使用这样的数据结构，通常都是当两个栈的空间需求有相反的关系时，也就是一个栈增长时另一个栈在缩短的情况。当然，这只是针对两个具有相同数据类型的栈的一个设计上的技巧，如果不是相同数据类型的栈，这种办法不但不能更好地处理问题，反而会使问题变得更复杂。</p><h3 id="栈的链式存储结构及实现"><a href="#栈的链式存储结构及实现" class="headerlink" title="栈的链式存储结构及实现"></a>栈的链式存储结构及实现</h3><h4 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h4><p><strong>栈的链式存储结构，简称链栈</strong>。对于链栈来说，栈顶是放在单链表的头部，栈顶在头部，单链表中的中结点也失去了意义，所以是不需要头结点的。</p><p><img src="http://1.117.162.142:9000/blog/%E9%93%BE%E6%A0%88.png" alt="链栈"></p><p>对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间，如果真的发生，那此时的计算机操作系统已经面临司机崩溃的情况，而不是这个链栈是否溢出的问题。</p><p>但对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是 top &#x3D; NULL 的时候。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">  SElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode, *LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span> &#123;</span></span><br><span class="line">  LinkStackPtr top;</span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure><p>链栈的操作绝大部分都和单链表类似，指示在插入和删除上，特殊一些。</p><h4 id="栈的链式存储结构——进栈操作"><a href="#栈的链式存储结构——进栈操作" class="headerlink" title="栈的链式存储结构——进栈操作"></a>栈的链式存储结构——进栈操作</h4><p>对于链栈的进栈 push 操作，假设元素值为 e 的新结点是 s，top 为栈顶指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入元素 e 为新的栈顶元素</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(LinkStack *S, SElemType e)</span> &#123;</span><br><span class="line">  LinkStackPtr s = (LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">  s -&gt; data = e;</span><br><span class="line">  s -&gt; next = S -&gt; top;<span class="comment">// 把当前的栈顶元素赋值给新结点的直接后继</span></span><br><span class="line">  S -&gt; top = s;<span class="comment">// 将新的结点 s 赋值给栈顶指针</span></span><br><span class="line">  S -&gt; count++;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈的链式存储结构——出栈操作"><a href="#栈的链式存储结构——出栈操作" class="headerlink" title="栈的链式存储结构——出栈操作"></a>栈的链式存储结构——出栈操作</h4><p>至于链栈的出栈 pop操作，也是很简单的三句操作。假设变量 p 用来存储要删除的栈顶结点，将栈顶指针下移一位，最后释放 p 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若栈不空，则删除 S 的栈顶元素，用 e 返回其值，并返回 OK；否则返回 ERROR</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(LinkStack *S, SElemType *e)</span> &#123;</span><br><span class="line">  LinkStackPtr p;</span><br><span class="line">  <span class="keyword">if</span>(StackEmpty(*S))</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  *e = S -&gt; top -&gt; data;</span><br><span class="line">  p = S -&gt; top;<span class="comment">// 将栈顶结点赋值给 p</span></span><br><span class="line">  S -&gt; top = S -&gt; top -&gt; next;<span class="comment">// 使得栈顶指针下移一位，指向后一结点</span></span><br><span class="line">  <span class="built_in">free</span>(p);<span class="comment">// 释放结点 p</span></span><br><span class="line">  S -&gt; count--;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链栈的进栈 push 和出栈 pop操作都没有任何循环，时间复杂度都是 O(1)。</p><p>对比一下顺序栈和链栈，它们在时间复杂度上是一样的，均为 O(1)。对于空间性能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，但它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。所以它们的区别和线性表中讨论的一样，<strong>如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些</strong>。</p><h3 id="栈的作用"><a href="#栈的作用" class="headerlink" title="栈的作用"></a>栈的作用</h3><p>栈的引入简化了程序设计的问题，划分了不同关注层次，是的思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。</p><p>所以现在的很多高级语言，比如 Java、C# 等都有对栈结构的封装，不用关心它的实现细节，就可以直接使用 Stack 的 push 和 pop 方法，很方便。</p><h3 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h3><blockquote><p>栈有一个很重要的应用：在程序设计语言中实现了递归。</p></blockquote><h4 id="斐波那契数列实现"><a href="#斐波那契数列实现" class="headerlink" title="斐波那契数列实现"></a>斐波那契数列实现</h4><table><thead><tr><th align="center">1</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">5</th><th align="center">8</th><th align="center">13</th><th align="center">21</th><th align="center">34</th><th align="center">55</th><th align="center">89</th><th align="center">144</th></tr></thead></table><p>表格中的数据特点：前两相邻两项之和，构成了后一项。</p><p>用数学函数定义：</p><p>F(n) &#x3D; 0，当 n &#x3D; 0；</p><p>F(n) &#x3D; 1，当 n &#x3D; 1；</p><p>F(n) &#x3D; F(n -1) + F(n - 2)，当 n &gt; 1</p><p>常用迭代方法实现，输出前 40 位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">40</span>];</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    System.out.print(a[<span class="number">0</span>] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.print(a[<span class="number">1</span>] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">        a[i] = a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>];</span><br><span class="line">        System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契的递归函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fbi</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fbi(i - <span class="number">1</span>) + fbi(i - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">40</span>; j++)</span><br><span class="line">        System.out.print(fbi(j) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归的定义"><a href="#递归的定义" class="headerlink" title="递归的定义"></a>递归的定义</h4><p><strong>把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，乘坐递归函数。每个递归定义必须至少有一个条件，满足时递归不再进行，既不再引用自身而是返回值退出</strong>。</p><p>迭代和递归的区别：迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会消耗大量的时间和内存。迭代则不需要反复调用和占用额外的内存。因此应该视不同情况选择不同的代码实现方式。</p><h3 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h3><blockquote><p>队列 (queue) 是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p></blockquote><p><strong>队列是一种先进先出 (First In First Out) 的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头</strong>。</p><p><img src="http://1.117.162.142:9000/blog/%E9%98%9F%E5%88%97.png" alt="队列"></p><h3 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h3><p>同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 队列(Queue)</span><br><span class="line">Data</span><br><span class="line">  同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">  <span class="title function_">InitQueue</span><span class="params">(*Q)</span>: 初始化操作，建立一个空队列 Q。</span><br><span class="line">  <span class="title function_">DestroyQueue</span><span class="params">(*Q)</span>: 若队列 Q 存在，则销毁它。</span><br><span class="line">  <span class="title function_">ClearQueue</span><span class="params">(*Q)</span>: 将队列 Q 清空。</span><br><span class="line">  <span class="title function_">QueueEmpty</span><span class="params">(Q)</span>: 若队列 Q 为空，返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line">  <span class="title function_">GetHead</span><span class="params">(Q, *e)</span>: 若队列 Q 存在且非空，用 e 返回队列 Q 的队头元素。</span><br><span class="line">  <span class="title function_">EndQueue</span><span class="params">(*Q, e)</span>: 若队列 Q 存在，插入新元素 e 到队列 Q 中并成为队尾元素。</span><br><span class="line">  <span class="title function_">DeQueue</span><span class="params">(*Q, *e)</span>: 删除队列 Q 中队头元素，并用 e 返回其值。</span><br><span class="line">  <span class="title function_">QueueLength</span><span class="params">(Q)</span>: 返回队列 Q 的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><h4 id="队列顺序存储的不足"><a href="#队列顺序存储的不足" class="headerlink" title="队列顺序存储的不足"></a>队列顺序存储的不足</h4><p>假设一个队列有 n 个元素，则顺序存储的队列需建立一个大于 n 的数组，并把队列的所有元素存储在数组的前 n 个单元，数组下标为 0 的一端即是队头。所谓的入队列操作，其实就是在队尾追加一个元素，不需要移动任何元素，因此时间复杂度为 O(1)。</p><p>与栈不同的是，队列元素的出列是在队头，即下标为 0 的位置，那也就意味着，队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为 0 的位置不为空，此时时间复杂度为 O(n)。</p><p>队列不限制元素必须存储在数组的前 n 个单元这一条件，出队的性能就会大大增加。也就是说，队头不需要一定在下标为 0 的位置。</p><p>为了避免当只有一个元素时，队头和队尾重合使得处理变得麻烦，所以引入两个指针，front 指针指向队头元素，rear 指针指向队尾元素的下一个位置，这样当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列。</p><p>假设是长度为 5 的数组，初始状态，front 与 rear 指针均指向下标为 0 的位置。然后入队 a1、a2、a3、a4，front 指针依然指向下标为 0 位置，而 rear 指针指向下标为 4 的位置。</p><p>出队 a1、a2，则 front 指针指向下标为 2 的位置，rear 不变，在入队 a5，此时 front 指针不变，rear 指针移动到数组之外。因为此时数组末尾元素已经占用，再向后加，就会产生数组越界的错误。可实际上，队列在下标为 0 和 1 的地方还是空闲的。这种现象叫做“假溢出”。</p><h4 id="循环队列定义"><a href="#循环队列定义" class="headerlink" title="循环队列定义"></a>循环队列定义</h4><p>解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。<strong>我们把队列的这种头尾相接的顺序存储结构称为循环队列</strong>。</p><p>继续上面的例子，入队 a5 时，rear 改为指向下标为 0 的位置，这样就不会造成指针指向不明的问题了。</p><p>接着入队 a6，将它放置于下标为 0 处，rear 指针指向下标为 1 处。若再入队a7，则 rear 指针就与 front 指针重合，同时指向下标为 2 的位置。</p><p>空队列时，front 等于 rear， 但是现在队列满时，也是 front 等于 rear，如何判断此时的队列究竟是空还是满呢？</p><ul><li>方法一：设置一个标志变量 flag，当 front &#x3D;&#x3D; rear，且 flag &#x3D; 0 时为空队列，当 front &#x3D;&#x3D; rear，且 flag &#x3D; 1 时为满队列。</li><li>方法二：当队列空时，条件就是 front &#x3D;&#x3D; rear，当队列满时，修改其条件，保留一个元素空间。队列满时，数组中还有一个空闲单元。</li></ul><p>方法二中，由于 rear 可能比 front 大，也可能比 front 小，所以尽管指向差一个位置时就是满的情况，但也可能是相差整整一圈。所以队列的最大尺寸为 QueueSize，那么<strong>队列满的条件是 (rear + 1) % QueueSize &#x3D;&#x3D; front</strong> (取模 “%” 的目的就是为了整合 rear 与 front 大小为一个问题)。</p><p>另外，当 rear &gt; front 时，此时队列的长度为 rear - front。但当 rear &lt; front 时，队列长度分为两段，一段是 QueueSize - front，另一段是 0 + rear，加在一起，队列长度为 rear - front + QueueSize。因此通用的计算队列长度公式为：</p><p><strong>(rear - front + QueueSize) % QueueSize</strong></p><p>循环队列的顺序存储结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;<span class="comment">// QElemType 类型根据实际情况而定，这里假设为 int </span></span><br><span class="line"><span class="comment">// 循环队列的顺序存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  QElemType data[MAXSIZE];</span><br><span class="line">  <span class="type">int</span> front;<span class="comment">// 头指针</span></span><br><span class="line">  <span class="type">int</span> rear;<span class="comment">// 尾指针，若队列不空，指向队列尾元素的下一个位置</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p>循环队列的初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个空队列</span></span><br><span class="line">Status <span class="title function_">InitQueue</span><span class="params">(SqQueue *Q)</span> &#123;</span><br><span class="line">  Q -&gt; front = <span class="number">0</span>;</span><br><span class="line">  Q -&gt; rear = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环队列求队列长度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 Q 的元素个数，也就是队列的当前长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueLength</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (Q.rear - Q.front + MAXSIZE) % MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环队列的入队列操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若队列未满，则插入元素 e 为 Q 新的队列元素</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(SqQueue *Q, QElemType e)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>((Q -&gt; rear + <span class="number">1</span>) % MAXSIZE == Q -&gt; front)<span class="comment">// 队列满的判断</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  Q -&gt; data[Q -&gt; rear] = e;<span class="comment">// 将元素 e 赋值给队尾</span></span><br><span class="line">  Q -&gt; rear = (Q -&gt; rear + <span class="number">1</span>) % MAXSIZE;<span class="comment">// rear 指针向后移一位置，若到最后则转到数组头部</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环队列的出队操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(SqQueue *Q, QElemType *e)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(Q -&gt; front == Q -&gt; rear)<span class="comment">// 队列空的判断</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  *e = Q -&gt; data[Q -&gt; front];<span class="comment">// 将队列元素赋值给 e</span></span><br><span class="line">  Q -&gt; front = (Q -&gt; front + <span class="number">1</span>) % MAXSIZE;<span class="comment">// front 指针向后移一位置，若到最后则转到数组头部</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的链式存储结构及实现"><a href="#队列的链式存储结构及实现" class="headerlink" title="队列的链式存储结构及实现"></a>队列的链式存储结构及实现</h3><p><strong>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，把它称为链队列</strong>。为了操作上的方便，我们将队头指针指向链队列的头结点，而队列指针指向终端结点。</p><p><img src="http://1.117.162.142:9000/blog/%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0.png" alt="队列的链式存储结构及实现"></p><p>空队列时，front 和 rear 都指向头结点。</p><p>链队列的结构为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;<span class="comment">// QElemType 类型根据实际情况而定，这里假设为 int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span><span class="comment">// 结点结构</span></span><br><span class="line">  QElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">// 队列的链表结构</span></span><br><span class="line">  QueuePtr front, rear;<span class="comment">// 队头、队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><h4 id="队列的链式存储结构——入队操作"><a href="#队列的链式存储结构——入队操作" class="headerlink" title="队列的链式存储结构——入队操作"></a>队列的链式存储结构——入队操作</h4><p>入队操作就是在链表尾部插入结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入元素 e 为 Q 的新的队尾元素</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(LinkQueue *Q, QElemType e)</span> &#123;</span><br><span class="line">  QueuePtr s = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">  <span class="keyword">if</span>(!s)<span class="comment">// 存储分配失败</span></span><br><span class="line">    <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">  s -&gt; data = e;</span><br><span class="line">  s -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">  Q -&gt; rear -&gt; next = s;<span class="comment">// 把拥有元素 e 新结点 s 赋值给原队尾结点的后继</span></span><br><span class="line">  Q -&gt; rear = s;<span class="comment">// 把当前的 s 设置为队尾结点，rear 指向 s</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="队列的链式存储结构——出队操作"><a href="#队列的链式存储结构——出队操作" class="headerlink" title="队列的链式存储结构——出队操作"></a>队列的链式存储结构——出队操作</h4><p>出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素时，则需将 rear 指向头结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若队列不空，删除 Q 的队列元素，用 e 返回其值，并返回 OK，否则返回 ERROR</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(LinkQueue *Q, QElemType *e)</span> &#123;</span><br><span class="line">  QueuePtr p;</span><br><span class="line">  <span class="keyword">if</span>(Q -&gt; front == Q -&gt; rear)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  p = Q -&gt; front -&gt; next;<span class="comment">// 将预删除的队头结点暂存给 p</span></span><br><span class="line">  *e = p -&gt; data;<span class="comment">// 将预删除的队头结点的值赋值给 e</span></span><br><span class="line">  Q -&gt; front -&gt; next = p -&gt; next;<span class="comment">// 将原队头结点后继 p -&gt; next 赋值给头结点后继</span></span><br><span class="line">  <span class="keyword">if</span>(Q -&gt; rear == p)<span class="comment">// 若队头是队尾，则删除后将 rear 指向头结点</span></span><br><span class="line">    Q -&gt; rear = Q -&gt; front;</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于循环队列与链队列的比较，可以从两方面来考虑， 从时间上，其实它们的基本操作都是常数时间，即都为 O(1) 的，不过循环队列是实现申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。对于空间上来说，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵活。总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果无法预估队列的长度时，则用链队列。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>栈 (Stack) 是限定仅在表尾进行插入和删除操作的线性表。</p><p>队列 (queue) 是只允许在一段进行插入操作，而在另一端进行删除操作的线性表。</p><p>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。</p><p>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得插入和删除是 O(n) 的时间复杂度变成了 O(1)。</p><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h3><blockquote><p>串：是由零个或多个字符组成的有限序列，又名叫字符串。</p></blockquote><p><strong>一般记为 s &#x3D; “a<sub>1</sub>a<sub>2</sub> …… a<sub>n</sub>“ (n ≥ 0)<strong>，其中，s 是串的名称，用双引号括起来的字符序列是串的值，注意单引号不属于串的内容。a<sub>i</sub> (1 ≤ i ≤ n) 可以是字母、数字或其他字符，i 就是该字符在串中的位置。</strong>串中的字符数目 n 称为串的长度</strong>，定义中谈到的“有限”是指长度 n 是一个有限的数值。**零个字符的串称为空串 (null string)**，它的长度为零，可以直接用两双引号 “” 表示，也可以用希腊字母 𝛟 来表示。所谓的序列，说明串的相邻字符之间具有前驱和后继的关系。</p><p>空格串，是只包含空格的串。注意它与空串的区别，空格串是有内容长度的，而且可以不止一个空格。</p><p>子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。</p><p>子串在主串中的位置就是子串的第一个字符在主串中的序号。</p><p>“over”、“end“、”lie“ 其实可以认为是 ”lover“、”friend“、”believe“ 这些单词字符串的子串。</p><h3 id="串的比较"><a href="#串的比较" class="headerlink" title="串的比较"></a>串的比较</h3><p>两个数字，很容易比较大小。2 比 1 大，这完全正确，可是两个字符串如何比较？比如 ”silly“、”stupid“ 这样的同样表达”愚蠢的“的单词字符串，它们在计算机中的大小其实取决于它们挨个字母的前后顺序。它们的第一个字母都是 ”s”，我们认为不存在大小差异，而第二个字母，由于 “i” 字母比 “t” 字母要靠前，所以 “i“ &lt; “t”，于是我们说 “silly” &lt; “stupid”。</p><p>事实上，串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的是字符在对应字符集中的序号。</p><p>计算机中的常用字符是使用标准的 ASCII 编码，更准确一点，由 7 位二进制数表示一个字符，总共可以表示 128 个字符。后来发现一些特殊符号的出现，128 个不够用，于是扩展 ASCII 码由 8 位二进制数表示一个字符，总共可以表示 256 个字符，这已经足够满足以英语为主的语言和特殊符号进行输入、存储、输出等操作的字符需要了。可是，单我们国家就有除汉族外的满、回、藏、蒙古、维吾尔等多个少数民族文字，换作全世界估计要有成百上千种语言与文字，显然这 256 个字符是不够的，因此后来就有了 Unicode 编码，比较常用的是由 16 位二进制数表示一个字符，这样总共就可以表示 216 个字符，约是 65 万多个字符，足够表示世界上所有语言的所有字符了。当然，为了和 ASCII 码兼容，Unicode 的前 256 个字符与 ASCII 码完全相同。</p><p>所以如果在 C 语言中比较两个串是否相等，必须是它们串的长度以及它们各个对应位置的字符都相等时，才算是相等的。即给定两个串：s &#x3D; “a<sub>1</sub>a<sub>2</sub> …… a<sub>n</sub>“，t &#x3D; “b<sub>1</sub>b<sub>2</sub> …… b<sub>m</sub>“，当且仅当 n &#x3D; m，且 a<sub>1</sub> &#x3D; b<sub>1</sub>，a<sub>2</sub> &#x3D; b<sub>2</sub>，…… ，a<sub>n</sub> &#x3D; a<sub>m</sub> 时，我们认为 s &#x3D; t。</p><blockquote><p>那么对于两个串不相等时，如何判定它们的大小？</p></blockquote><p><strong>给定两个串：s &#x3D; “a<sub>1</sub>a<sub>2</sub> …… a<sub>n</sub>“，t &#x3D; “b<sub>1</sub>b<sub>2</sub> …… b<sub>m</sub>“，当满足一下条件之一时，s &lt; t。</strong></p><ol><li><p>**n &lt; m，且 a<sub>i</sub> &#x3D; b<sub>i</sub> (i &#x3D; 1, 2, …… , n)**。</p><p> 例如当 s &#x3D; “hap”，t &#x3D; “happy”，就有 s &lt; t。因为 t 比 s 多出了两个字母。</p></li><li><p>**存在某个 k ≤ min(m, n)，使得 <sub>i</sub> &#x3D; b<sub>i</sub> (i &#x3D; 1, 2, ……, k - 1)，且a<sub>k</sub> &lt; b<sub>k</sub>**。</p><p> 例如当 s &#x3D; “happen”，t &#x3D; “happy”，因为两串的前 4 个字母均相同，而两串第 5 个字母 (k 值)，字母 e 的 ASCII 码是 101，而字母 y 的 ASCII 码是 121，显然 e &lt; y，所以 s &lt; t。</p></li></ol><h3 id="串的抽象数据类型"><a href="#串的抽象数据类型" class="headerlink" title="串的抽象数据类型"></a>串的抽象数据类型</h3><p>串的逻辑结构和线性表很相似，不同之处在于串针对的是字符集，也就是串中的元素都是字符，哪怕串中的字符是 “123” 这样的数字组成，或者 “2022-08-08” 这样的日期组成，它们都只能理解为长度为 3 和长度为 10 的字符串，每个元素都是字符而已。</p><p>因此，对于串的基本操作与线性表是有很大差别的。线性表更关注的是单个元素的操作，比如查找一个元素，插入或删除一个元素，但串中更多的是查找子串位置、得到指定位置子串、替换子串等操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ADT 串(<span class="built_in">string</span>)</span><br><span class="line">Data</span><br><span class="line">  串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">  <span class="title function_">StrAssign</span><span class="params">(T, *chars)</span>: 生成一个其值等于字符串常量 chars 的串 T。</span><br><span class="line">  <span class="title function_">StrCopy</span><span class="params">(T, S)</span>: 串 S 存在，由串 S 复制得串 T。</span><br><span class="line">  <span class="title function_">ClearString</span><span class="params">(S)</span>: 串 S 存在，将串清空。</span><br><span class="line">  <span class="title function_">StringEmpty</span><span class="params">(S)</span>: 若串 S 为空，返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line">  <span class="title function_">StrCompare</span><span class="params">(S, T)</span>: 若 S &gt; T，返回值 &gt; 0，若 S = T，返回 <span class="number">0</span>，若 S &lt; T，返回值 &lt; <span class="number">0</span>。</span><br><span class="line">  StrLength(S): 返回串 S 的元素个数，即串的长度。</span><br><span class="line">  Concat(T, S1, S2): 用 T 返回由 S1 和 S2 连接而成的新串。</span><br><span class="line">  SubString(Sub, S, pos, len): 串 S 存在，<span class="number">1</span> ≤ pos ≤ StrLength(S)，且 <span class="number">0</span> ≤ len ≤ StrLength(S) - pos + <span class="number">1</span>，用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串。</span><br><span class="line">  Index(S, T, pos): 串 S 和 T 存在，T 是非空串，<span class="number">1</span> ≤ pos ≤ StrLength(S)。若主串 S 中存在和串 T 值相同的子串，则返回它在主串 S 中第 pos 个字符之后第一次出现的位置，否则返回 <span class="number">0</span>。</span><br><span class="line">  Replace(S, T, V): 串 S、T 和 V 存在，T 是非空串。用 V 替换主串 S 中出现的所有与 T 相等的不重叠的子串。</span><br><span class="line">  StrInsert(S, pos, T): 串 S 和 T 存在，<span class="number">1</span> ≤ pos ≤ StrLength(S) + <span class="number">1</span>。在串 S 的第 pos 个字符之前插入串 T。</span><br><span class="line">  StrDelete(S, pos, len): 串 S 存在，<span class="number">1</span> ≤ pos ≤StrLength(S) - len + <span class="number">1</span>。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p>操作 Index 的实现算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 为非空串。若主串 S 中第 pos 个字符之后存在与 T 相等的子串，则返回第一个这样的子串在 S 中的位置，否则返回 0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(String S, String T, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n, m, i;</span><br><span class="line">  String sub;</span><br><span class="line">  <span class="keyword">if</span>(pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    n = StrLength(S);<span class="comment">// 得到主串 S 的长度</span></span><br><span class="line">    m = StrLength(T);<span class="comment">// 得到子串 T 的长度</span></span><br><span class="line">    i = pos;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n - m + <span class="number">1</span>) &#123;</span><br><span class="line">      SubString(sub, S, i, m);<span class="comment">// 取主串第 i 个位置，长度与 T 相等子串给 sub</span></span><br><span class="line">      <span class="keyword">if</span>(StrCompare(sub, T) != <span class="number">0</span>)<span class="comment">// 如果两串不相等</span></span><br><span class="line">        ++i;</span><br><span class="line">      <span class="keyword">else</span><span class="comment">// 如果两串相等</span></span><br><span class="line">        <span class="keyword">return</span> i;<span class="comment">// 则返回 i 值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 若无子串与 T 相等，返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h3><h4 id="串的顺序存储结构"><a href="#串的顺序存储结构" class="headerlink" title="串的顺序存储结构"></a>串的顺序存储结构</h4><p>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义。</p><p>既然是定长数组，就存在一个预定义的最大串长度，一般可以将实际的串长度值保存在数组的 0 下标位置 (也可以定义存储在数组的最后一个下标位置)。有些编程语言觉得存个数字占个空间麻烦。它规定在串值后面加一个不计入串长度的结束标记字符，比如 “\0“ 来表示串值的终结。但是，当遍历计算串长度时，会发现结束标记字符也是占用了一个空间的。</p><p>以上所说的串的顺序存储方式其实是有问题的，因为字符串的操作，比如两串的连接 Concat、新串的插入 StrInsert，以及字符串的替换 Replace，都有可能使得串序列的长度超过了数组的长度 MaxSize。</p><h4 id="串的链式存储结构"><a href="#串的链式存储结构" class="headerlink" title="串的链式存储结构"></a>串的链式存储结构</h4><p>对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用 “#” 或其它非串值字符补全。</p><p><img src="http://1.117.162.142:9000/blog/%E4%B8%B2%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="串的链式存储结构"></p><p>当然，这里一个结点存多少个字符才合适就变得很重要，这会直接影响着串处理的效率，需要根据实际情况做出选择。但串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。</p><h3 id="朴素的模式匹配算法"><a href="#朴素的模式匹配算法" class="headerlink" title="朴素的模式匹配算法"></a>朴素的模式匹配算法</h3><p><strong>子串的定位操作通常称做串的模式匹配</strong>。</p><p>假设要从下面的主串 S &#x3D; “goodgoogle” 中，找到 T &#x3D; “google” 这个子串的位置。步骤如下：</p><ol><li>主串 S 第一位开始，S 与 T 前三个字母都匹配成功，但 S 第四个字母是 d 而 T 的是 g。第一位匹配失败。</li><li>主串 S 第二位开始，主串 S 首字母是 o，要匹配的 T 首字母是 g，匹配失败。</li><li>主串 S 第三位开始，主串 S 首字母是 o，要匹配 T 首字母是 g，匹配失败。</li><li>主串 S 第四位开始，主串 S 首字母是 d，要匹配的 T 首字母是 g，匹配失败。</li><li>主串 S 第五位开始，S 与 T，6 个字母全匹配，匹配成功。</li></ol><p>简单的说，就是对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做 T 的长度的小循环，直到匹配成功或全部遍历完成为止。</p><p>假设主串 S 和要匹配的子串 T 的长度存在 S[0] 与 T[0] 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回子串 T 在主串中第 pos 个字符之后的位置。若不存在，则函数返回值为 0。T 非空，1 ≤ pos ≤ StrLength(S)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(String s, String T, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = pos;<span class="comment">// i 用于主串 S 中当前位置下标，若 pos 不为 1，则从 pos 位置开始匹配</span></span><br><span class="line">  <span class="type">int</span> j = <span class="number">1</span>;<span class="comment">// j 用于子串 T 中当前位置下标值</span></span><br><span class="line">  <span class="keyword">while</span>(i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) &#123;<span class="comment">// 若 i 小于 S 长度且 j 小于 T 的长度时循环</span></span><br><span class="line">    <span class="keyword">if</span>(S[i] == T[j]) &#123;<span class="comment">// 两字母相等则继续</span></span><br><span class="line">      ++i;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 指针后退重新开始匹配</span></span><br><span class="line">      i = i - j + <span class="number">2</span>;<span class="comment">// i 退回到上次匹配首位的下一位</span></span><br><span class="line">      j = <span class="number">1</span>;<span class="comment">// j 退回到子串 T 的首位</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(j &gt; T[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好的情况是一开始就匹配成功，比如 “googlegood” 中去找 “google”，时间复杂度为 O(1)。如果在 “abcdefgoogle” 中去找 “google”，那么时间复杂度为 O(n + m)，其中 n 为主串长度，m 为要匹配的子串长度。根据等概率原则，平均是 (n + m) &#x2F; 2 次查找，时间复杂度为 O(n + m)。</p><p>最坏的情况是每次不成功的匹配都发生在串 T 的最后一个字符。例如主串为 S &#x3D; “00000000000000000000000000000000000001”，而要匹配的子串为 T &#x3D; ”0000000001“，前者是有 49 个 ”0“ 和 1 个 ”1“ 的主串，后者是有 9 个 ”0“ 和 1 个 ”1“ 的子串。在匹配时，每次都得将 T 中字符循环到最后一位才发现它们不匹配。这样等于 T 串需要在 S 串 的前 40 个位置都需要判断 10 次，并得出不匹配的结论。</p><p>知道最后第 41 个位置，因为全部匹配相等，所以不需要再继续进行下去。如果最终没有课匹配的子串，比如是 T &#x3D; ”0000000002“，到了第 41 位置判断不匹配后同样不需要继续比对下去。因此最坏情况的时间复杂度为 O((n - m + 1) * m)。</p><p>对于计算机来说，处理的都是二进位的 0 和 1 的串，一个字符的 ASCII 码也可以看成是 8 位的二进位 01 串，当然，汉字等所有的字符也都可以看成是多个 0 和 1 串。再比如像计算机图形也可以理解为是由许许多多个 0 和 1 的串组成。所以在计算机的运算当中，模式匹配操作可说是随处可见，而刚才的这个算法，就显得太低效了。</p><h3 id="KMP-模式匹配算法"><a href="#KMP-模式匹配算法" class="headerlink" title="KMP 模式匹配算法"></a>KMP 模式匹配算法</h3><p>D.EKnuth、J.H.Morris 和 V.R.Pratt (其中 Knuth 和 Pratt 共同研究，Morris 独立研究) 发表了一个<strong>匹配模式算法，可以大大避免重复遍历的情况，称之为克努特——莫里斯——普拉特算法，简称 KMP 算法</strong>。</p><h4 id="KMP-模式匹配算法原理"><a href="#KMP-模式匹配算法原理" class="headerlink" title="KMP 模式匹配算法原理"></a>KMP 模式匹配算法原理</h4><p>如果主串 S &#x3D; “abcdefgab”，匹配 T &#x3D; “abcdex”，如果用朴素算法的话，前 5 个字母，两个串完全相等，知道第 6 个字母，”f“ 与 ”x“ 不等，如 ① 所示。</p><p><img src="http://1.117.162.142:9000/blog/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%951.png" alt="朴素模式匹配算法"></p><p>接下来，按照朴素模式匹配算法，应该是图中 ②③④⑤⑥的顺序。即主串 S 中当 i &#x3D; 2、3、4、5、6 时，首字符与子串 T 的首字符均不等。</p><p>对于要匹配的子串 T 来说，“abcdex” 首字母 “a“ 与后面的串 ”bcdex“ 中任意一个字符都不相等。也就是说，既然 ”a“ 不与自己后面的子串中任何一个字符相等，那么对于图中 ① 来说，前五位字符分别相等，意味着子串 T 的首字符 ”a“ 不可能与 S 串的第 2 位到第 5 位的字符相等。②③④⑤ 的判断都是多余的。</p><p>这是理解 KMP 算法的关键。如果 T 串中首字符 ”a” 与 T 中后面的字符均不相等。而 T 串的第二位的 “b” 与 S 串中第二位的 “b”在 ① 中已经判断是相等的，那么也就意味着，T 串中首字符 “a“ 与 S 串中的第二位 ”b“ 是不需要判断也知道它们是不可能相等了，这样 ② 这一步判断是可以省略的。</p><p>同样道理，在知道 T 串中首字符 ”a” 与 T 中后面的字符均不相等的前提下，T 串的 “a” 与 S 串后面的 “c”、“d”、“e” 也都可以在 ① 之后就可以确定是不相等的，所以这个算法当中 ②③④⑤ 没有必要，只保留 ①⑥ 即可。</p><p>之所以保留 ⑥ 中的判断是因为在 ① 中 T[6] ≠ S[6]，尽管已经知道 T[1] ≠ T[6]，但也不能判定 T[1] 一定不等于 S[6]，因此需要保留 ⑥ 这一步。</p><blockquote><p>如果 T 串后面也含有首字符 “a” 的字符怎么办？</p></blockquote><p>假设 S &#x3D; “abcabcabc”，T &#x3D; “abcabx”。对于开始的判断，前 5 个字符完全相等，第6个字符不等，如图中的 ①。此时，T 的首字符 “a” 与 T 的第二位字符 “b”、第三位字符 “c” 均不相等，所以不需要做判断，步骤 ②③ 都是多余的。</p><p><img src="http://1.117.162.142:9000/blog/%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%952.png" alt="朴素模式匹配算法2"></p><p>因为 T 的首位 “a” 与 T 第四位的 “a” 相等，第二位的 “b” 与第五位的 “b” 相等。而在 ① 时，第四位的 “a” 与 第五位的 “b” 已经与主串 S 中相应位置比较过了，是相等的，因此可以判定，T 的首字符 “a”、第二位的字符 “b” 与 S 的第四位字符和第五位字符也不需要比较了，肯定也是相等的。所以 ④⑤ 这两个比较得出字符相等的步骤也可以省略。</p><p>也就是说，对于在子串中有与首字符相等的字符，也是可以省略一部分不必要的判断步骤。省略掉 ⑥ 中 T 串前两位 “a” 与 “b” 同 S 串中的 4、5位置字符匹配操作。</p><p>对比这两个例子，会发现在 ① 时，我们的 i 值，也就是主串当前位置的下标是 6，②③④⑤，i 值是2、3、4、5，到了 ⑥，i 值才又回到了 6.即我们在朴素的模式匹配算法中，主串的 i 值是不断地回溯来完成的。而分析发现，这种回溯其实是可以不需要的，KMP 模式匹配算法就是为了让这没必要的回溯不发生。</p><p>既然 i 值不回溯，也就是不可以变小，那么要考虑的变化就是 j 值了。通过观察也发现，T 串的首字符与自身后面字符的比较，发现如果有相等字符，j 值的变化就会不相同。也就是说，这个 j 值的变化与主串起时没什么关系，关键就取决于 T 串的结构中是否有重复的问题。</p><p>第一个例子中，由于 T &#x3D; “abcdex”，当中没有任何重读的字符，所以 j 就由 6 变为 1。而第二个例子中 T &#x3D; “abcabx”，前缀的 “ab” 与最后 “x” 之前串的后缀 “ab” 是相等的。因此 j 就由 6 变为了 3。可以得出规律，j 值的多少取决于当前字符之前的串的前后缀的相似度。</p><p>把 T 串各个位置的 j 值的变化定义为一个数组 next，那么 next 的长度就是 T 串的长度。得出下面的函数定义：</p><p>next[j] &#x3D; 0，当 j &#x3D; 1 时，</p><p>next[j] &#x3D; Max{ k | 1 &lt; k &lt; j, 且 ‘p<sub>1 ··· k - 1</sub>‘ &#x3D; ‘p<sub>j - k + 1</sub> ··· p<sub>j - 1</sub>‘} 当集合和不空时，</p><p>next[j] &#x3D; 1，其他情况</p><h4 id="next-数组值推导"><a href="#next-数组值推导" class="headerlink" title="next 数组值推导"></a>next 数组值推导</h4><blockquote><p>具体如何推导出一个串的 next 数组值？</p></blockquote><ol><li><p>T &#x3D; “abcdex”</p><table><thead><tr><th align="center">j</th><th align="center">123456</th></tr></thead><tbody><tr><td align="center">模式串 T</td><td align="center">abcdex</td></tr><tr><td align="center">next[j]</td><td align="center">011111</td></tr></tbody></table><ul><li>当 j &#x3D; 1 时，next[1] &#x3D; 0；</li><li>当 j &#x3D; 2 时，j 由 1 到 j - 1 就只有字符 “a”，属于其他情况 next[2] &#x3D; 1；</li><li>当 j &#x3D; 3 时，j 由 1 到 j - 1 串是 “ab”，显然 ”a“ 与 ”b“ 不相等，属其他情况，next[3] &#x3D; 1；</li><li>以后同理，所以最终此 T 串的 next[j] &#x3D; 011111。</li></ul></li><li><p>T &#x3D; “abcabx”</p><table><thead><tr><th align="center">j</th><th align="center">123456</th></tr></thead><tbody><tr><td align="center">模式串 T</td><td align="center">abcabx</td></tr><tr><td align="center">next[j]</td><td align="center">011123</td></tr></tbody></table><ul><li>当 j &#x3D; 1 时，next[1] &#x3D; 0；</li><li>当 j &#x3D; 2 时，同上例说明，next[2] &#x3D; 1；</li><li>当 j &#x3D; 3 时，同上，next[3] &#x3D; 1；</li><li>当 j &#x3D; 4 时，同上，next[4] &#x3D; 1；</li><li>当 j &#x3D; 5 时，此时 j 由 j - 1 的串是 “abca”，前缀字符 “a” 与后缀字符 “a” 相等，因此可推算出 k 值为2 (由 p<sub>1 ··· k - 1</sub>‘ &#x3D; ‘p<sub>j - k + 1</sub> ··· p<sub>j - 1</sub>，得到 p<sub>1</sub> &#x3D; p<sub>4</sub>)，因此 next[5] &#x3D; 2；</li><li>当 j &#x3D; 6 时，j 由 1 到 j - 1 的串是 “abcab”，由于前缀字符 “ab” 与后缀 “ab” 相等，所以 next[6] &#x3D; 3。</li></ul><p> 我们可以根据经验得到如果前后缀一个字符相等，k 值是 2，两个字符 k 值是 3，n 个相等 k 值就是 n + 1。</p></li><li><p>T &#x3D; “ababaaaba”</p><table><thead><tr><th align="center">j</th><th align="center">123456789</th></tr></thead><tbody><tr><td align="center">模式串 T</td><td align="center">ababaaaba</td></tr><tr><td align="center">next[j]</td><td align="center">011234223</td></tr></tbody></table><ul><li>当 j &#x3D; 1 时，next[1] &#x3D; 0；</li><li>当 j &#x3D; 2 时，同上，next[2] &#x3D; 1；</li><li>当 j &#x3D; 3 时，同上，next[3] &#x3D; 1；</li><li>当 j &#x3D; 4 时，j 由 1 到 j - 1 的串是 “aba”，前缀字符 “a” 与后缀字符 “a“ 相等，next[4] &#x3D; 2；</li><li>当 j &#x3D; 5 时，此时 j 由 j - 1 的串是 “abab”，前缀字符 “ab” 与后缀字符 “ab” 相等，所以 next[5] &#x3D; 3；</li><li>当 j &#x3D; 6 时，j 由 1 到 j - 1 的串是 “ababa”，由于前缀字符 “aba” 与后缀 “aba” 相等，所以 next[6] &#x3D; 4；</li><li>当 j &#x3D; 7 时，j 由 1 到 j - 1 的串是 “ababaa”，由于前缀字符 “ab” 与后缀 “aa” 并不相等，只有 ”a“ 相等，所以 next[7] &#x3D; 2；</li><li>当 j &#x3D; 8 时，j 由 1 到 j - 1 的串是 “ababaaa”，只有 “a” 相等，所以 next[8] &#x3D; 2；</li><li>当 j &#x3D; 9 时，j 由 1 到 j - 1 的串是 “ababaaab”，由于前缀字符 “ab” 与后缀 “aba” 相等，所以 next[9] &#x3D; 3。</li></ul></li><li><p>T &#x3D; “aaaaaaaab”</p><table><thead><tr><th align="center">j</th><th align="center">123456789</th></tr></thead><tbody><tr><td align="center">模式串 T</td><td align="center">aaaaaaaab</td></tr><tr><td align="center">next[j]</td><td align="center">012345678</td></tr></tbody></table><ul><li>当 j &#x3D; 1 时，next[1] &#x3D; 0；</li><li>当 j &#x3D; 2 时，同上，next[2] &#x3D; 1；</li><li>当 j &#x3D; 3 时，j 由 1 到 j - 1 的串是 “aa”，前缀字符 “a” 与后缀字符 “a“ 相等，next[3] &#x3D; 2；</li><li>当 j &#x3D; 4 时，j 由 1 到 j - 1 的串是 “aaa”，前缀字符 “aa” 与后缀字符 “aa“ 相等，next[4] &#x3D; 3；</li><li>……</li><li>当 j &#x3D; 9 时，j 由 1 到 j - 1 的串是 “aaaaaaaa”，由于前缀字符 “aaaaaaa” 与后缀 “aaaaaaa” 相等，所以 next[9] &#x3D; 8。</li></ul></li></ol><h4 id="KMP-模式匹配算法实现"><a href="#KMP-模式匹配算法实现" class="headerlink" title="KMP 模式匹配算法实现"></a>KMP 模式匹配算法实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过计算返回子串的 next 数组。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(String T, <span class="type">int</span> *next)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i,j;</span><br><span class="line">  i = <span class="number">1</span>;</span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; T[<span class="number">0</span>]) &#123;<span class="comment">// 此处 T[0] 表示串 T 的长度</span></span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">0</span> || T[i] == T[j]) &#123;<span class="comment">// T[i] 表示后缀的单个字符；T[j] 表示前缀的单个字符</span></span><br><span class="line">      ++i;</span><br><span class="line">      ++j;</span><br><span class="line">      next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      j = next[j];<span class="comment">// 若字符不相同，则 j 值回溯</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是为了计算出当前要匹配的串 T 的 next 数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回子串 T 在主串 S 中第 pos 个字符之后的位置。若不存在，则函数返回值为 0。T 非空，1 ≤ pos ≤ StrLength(S)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(String S, String T, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = pos;<span class="comment">// i 用于主串 S 当前位置下标值，若 pos 不为 1，则从 pos 位置开始匹配</span></span><br><span class="line">  <span class="type">int</span> j = <span class="number">1</span>;<span class="comment">// j 用于子串 T 中当前位置下标值</span></span><br><span class="line">  <span class="type">int</span> next[<span class="number">255</span>];<span class="comment">// 定义一 next 数组</span></span><br><span class="line">  get_next(T, next);<span class="comment">// 对串 T 作分析，得到 next 数组</span></span><br><span class="line">  <span class="keyword">while</span>(i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) &#123;<span class="comment">// 若 i 小于 S 的长度且 j 小于 T 的长度时，循环继续</span></span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">0</span> || S[i] == T[j]) &#123;<span class="comment">// 两字母相等则继续，与朴素算法增加了 j = 0 判断</span></span><br><span class="line">      ++i;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">// 指针后退重新开始匹配</span></span><br><span class="line">      j = next[j];<span class="comment">// j 退回合适的位置，i 值不变</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(j &gt; T[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 get_next 函数来说，若 T 的长度为 m，因只涉及到简单的单循环，其时间复杂度为 O(m)，而由于 i 值的不回溯，是的 index_KMP 算法效率得到了提高，while 循环的时间复杂度为 O(n)。因此整个算法的时间复杂度为 O(n + m)。相较于朴素模式匹配算法的 O((n - m + 1) * m) 来说，好一些。KMP算法仅当模式与主串之间存在许多 “部分匹配” 的情况下才体现出它的优势，否则两者差异并不明显。</p><h4 id="KMP-模式匹配算法改进"><a href="#KMP-模式匹配算法改进" class="headerlink" title="KMP 模式匹配算法改进"></a>KMP 模式匹配算法改进</h4><p>KMP 算法是有缺陷的，比如当主串 S &#x3D; “aaaabcde”，子串 T &#x3D; “aaaaax”，其 next 数组分别为 012345，在开始时，当 i &#x3D; 5、j &#x3D; 5 时，发现 “b“ 与 “a” 不相等，如图中的 ①，因此 j &#x3D; next[5] &#x3D; 4，如图中的 ②，此时 “b” 与第 4 位置的 “a” 依然不相等，j &#x3D; next[4] &#x3D; 3，如果中的 ③，后依次是 ④⑤，直到 j &#x3D; next[1] &#x3D; 0 时，根据算法，此时 ++i、j++，得到 i &#x3D; 6、j &#x3D; 1，如图中的 ⑥。</p><p><img src="http://1.117.162.142:9000/blog/KMP%E7%AE%97%E6%B3%95.png" alt="KMP算法"></p><p>但是可以看出 ②③④⑤ 步骤其实是多余的的判断。由于 T 串的第二、三、四、五位置的字符都与首位 “a” 相等，那么可以用首位 next[1] 的值去取代与它相等的字符后续 next[j] 的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求模式串 T 的 next 函数修正值并存入数组 nextval</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_nextval</span><span class="params">(String T, <span class="type">int</span> *nextval)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  i = <span class="number">1</span>;</span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; T[<span class="number">0</span>]) &#123;<span class="comment">// 此处 T[0] 表示串 T 的长度</span></span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">0</span> || T[i] == T[j]) &#123;<span class="comment">// T[i] 表示后缀的单个字符，T[j] 表示前缀的单个字符</span></span><br><span class="line">      ++i;</span><br><span class="line">      ++j;</span><br><span class="line">      <span class="keyword">if</span>(T[i] != T[j])<span class="comment">// 若当前字符与前缀字符不同</span></span><br><span class="line">        nextval[i] = j;<span class="comment">// 则当前的 j 为 nextval 在 i 位置的值</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        nextval[i] = nextval[j];<span class="comment">// 如果与前缀字符相同，则将前缀字符的 nextval值赋值给nextval 在 i 位置的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      j = nextval[i];<span class="comment">// 若字符不相同，则 j 值回溯</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际匹配算法，只需要将 “get_next(T, next);” 改为 “get_nextval(T, next);” 即可。</p><h4 id="nextval-数组值推导"><a href="#nextval-数组值推导" class="headerlink" title="nextval 数组值推导"></a>nextval 数组值推导</h4><p>经过优化后，nextval 值与 next 值不完全相同了。</p><ol><li><p>T &#x3D; “ababaaaba”</p><table><thead><tr><th align="center">j</th><th align="center">123456789</th></tr></thead><tbody><tr><td align="center">模式串 T</td><td align="center">ababaaaba</td></tr><tr><td align="center">next[j]</td><td align="center">011234223</td></tr><tr><td align="center">nextval[j]</td><td align="center">010104210</td></tr></tbody></table><p> 先算出 next 数组的值分别为 001234223，然后再分别判断。</p><ul><li>当 j &#x3D; 1 时，nextval[1] &#x3D; 0；</li><li>当 j &#x3D; 2 时，因第二位字符 “b“ 的 next 值是 1，而第一位就是 ”a”，它们不相等，所以 nextval[2] &#x3D; next[1] &#x3D; 1；</li><li>当 j &#x3D; 3 时，因第三位字符 “a“ 的 next 值是 1，所以与第一位就是 ”a” 比较相等，所以 nextval[3] &#x3D; nextval[1] &#x3D; 0；</li><li>当 j &#x3D; 4 时，第四位的字符 “b” next 值为 2，所以与第二位的 “b” 相比较得到结果是相等，因此 nextval[4] &#x3D; nextval[2] &#x3D; 1；</li><li>当 j &#x3D; 5 时，next 值为 3，第五个字符 “a” 与第三个字符 ”a” 相等，所以 nextval[5] &#x3D; nextval[3] &#x3D; 0；</li><li>当 j &#x3D; 6 时，next 值为 4，第六个字符 “a” 与第四个字符 “b” 不相等，所以 nextval[6] &#x3D; 4；</li><li>当 j &#x3D; 7 时，next 值为 2，第七个字符 “a“ 与第二个字符 ”b“ 不相等，所以 nextval[7] &#x3D; 2；</li><li>当 j &#x3D; 8 时，next 值为 2，第八个字符 “b” 与第二个字符 ”b“ 相等，所以 nextval[8] &#x3D; nextval[2] &#x3D; 1；</li><li>当 j &#x3D; 9 时，next 值为 3，第九个字符 “a” 与第三个字符 ”a” 相等，所以 nextval[9] &#x3D; nextval[3] &#x3D; 1。</li></ul></li><li><p>T &#x3D; “aaaaaaaab”</p><table><thead><tr><th align="center">j</th><th align="center">123456789</th></tr></thead><tbody><tr><td align="center">模式串 T</td><td align="center">aaaaaaaab</td></tr><tr><td align="center">next[j]</td><td align="center">012345678</td></tr><tr><td align="center">Nextval[j]</td><td align="center">00000008</td></tr></tbody></table><p> 先算出 next 数组的值分别为 012345678，然后再分别判断。</p><ul><li>当 j &#x3D; 1 时，nextval[1] &#x3D; 0；</li><li>当 j &#x3D; 2 时，next 值为 1，第二个字符与第一个字符相等，所以 nextval[2] &#x3D; nextval[1] &#x3D; 0；</li><li>同样的道理，其后都为 0……</li><li>当 j &#x3D; 9，next 值为 8，第九个字符 “b” 与第八个字符 “a” 不相等，所以 nextval[9] &#x3D; 8。、</li></ul><p> 改进后的 KMP 算法，它是在计算出 next 值的同时，如果 a 位字符与它 next 值指向的 b 位字符相等，则该 a 位的 nextval 就指向 b 位的 nextval 值，如果不等，则该 a 位的 nextval 值就是它自己 a 位的next 的值。</p></li></ol><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>串 (string) 是由零个或多个字符组成的有限序列，又名叫字符串。本质上，它是一种线性表的扩展，但相对于线性表关注一个个元素来说说，串这种结构更多的是关注它子串的应用问题，如查找、替换等操作。KMP 算法的学习，要有效地去理解 index 函数当中的实现细节。</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><blockquote><p>树 (Tree) 是 n (n ≥ 0) 个结点的有限集。n &#x3D; 0 时称为空树。在任意一棵非空树中：(1) 有且仅有一个特定的称为根 (Root) 的结点； (2) 当 n &gt; 1 时，其余结点可分为 m (m &gt; 0) 个互不相交的有限集 T<sub>1</sub>、T<sub>2</sub>、······、T<sub>m</sub>，其中每个集合本身又是一棵树，并且称为根的子树 (SubTree)。</p></blockquote><p><img src="http://1.117.162.142:9000/blog/%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89.png" alt="树的定义"></p><ol><li>n &gt; 0 时根结点是唯一的，不可能存在多个根结点，别和现实中的大树混在一起，现实中的树有很多根须，那是真实的树，数据结构中的树是只能有一个根结点。</li><li>m &gt; 0 时，子树的个数没有限制，但它们一定是互不相交的。</li></ol><h4 id="结点分类"><a href="#结点分类" class="headerlink" title="结点分类"></a>结点分类</h4><p>树的结点包含一个数据元素及若干指向其子树的分支。<strong>结点拥有的子树称为结点的度 (Degree)。度为 0 的结点称为叶结点 (Leaf) 或终端结点；度不为 0 的结点称为非终端结点或分支结点。除根结点外，分支结点也称为内部结点。树的度是树内各结点的度的最大值</strong>。</p><p><img src="http://1.117.162.142:9000/blog/%E7%BB%93%E7%82%B9%E5%92%8C%E5%BA%A6.png" alt="结点和度"></p><h4 id="结点间关系"><a href="#结点间关系" class="headerlink" title="结点间关系"></a>结点间关系</h4><p><strong>结点的子树的根称为该结点的孩子 (Child)，相应地，该结点称为孩子的双亲 (Parent)。同一个双亲的孩子之间互称兄弟 (Sibling)。结点的祖先是从根到该结点所经分枝上的所有结点。以某结点为根的子树中的任一结点都称为该结点的子孙</strong>。</p><h4 id="树的其它相关概念"><a href="#树的其它相关概念" class="headerlink" title="树的其它相关概念"></a>树的其它相关概念</h4><p><strong>结点的层次 (Level) 从根开始定义起，根为第一层，跟的孩子为第二层。双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度 (Depth) 或高度。</strong></p><p><img src="http://1.117.162.142:9000/blog/%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1.png" alt="树的层次"></p><p><strong>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树</strong>。</p><p><strong>森林 (Forest) 是 m (m ≥ 0) 棵互不相交的树的集合</strong>。对树中每个结点而言，其子树的集合即为森林。</p><h3 id="树的抽象数据类型"><a href="#树的抽象数据类型" class="headerlink" title="树的抽象数据类型"></a>树的抽象数据类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ADT 树 (tree)</span><br><span class="line">Data</span><br><span class="line">  树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系。</span><br><span class="line">Operation</span><br><span class="line">  <span class="title function_">InitTree</span><span class="params">(*T)</span>: 构造空树 T。</span><br><span class="line">  <span class="title function_">DestroyTree</span><span class="params">(*T)</span>: 销毁树 T。</span><br><span class="line">  <span class="title function_">CreateTree</span><span class="params">(*T, definition)</span>: 按 definition 中给出树的定义来构造树。</span><br><span class="line">  <span class="title function_">ClearTress</span><span class="params">(*T)</span>: 若树 T 存在，则将树 T 清为空树。</span><br><span class="line">  <span class="title function_">TreeEmpty</span><span class="params">(T)</span>: 若 T 为空树，返回 <span class="literal">true</span>，否则返回 <span class="literal">false</span>。</span><br><span class="line">  <span class="title function_">TreeDepth</span><span class="params">(T)</span>: 返回 T 的深度。</span><br><span class="line">  <span class="title function_">Root</span><span class="params">(T)</span>: 返回 T 的根结点。</span><br><span class="line">  <span class="title function_">Value</span><span class="params">(T, cur_e)</span>: cur_e 是树 T 中一个结点，返回此结点的值。</span><br><span class="line">  <span class="title function_">Assign</span><span class="params">(T, cur_e, value)</span>: 给树 T 的结点 cur_e 赋值为 value。</span><br><span class="line">  <span class="title function_">Parent</span><span class="params">(T, cur_e)</span>: 若 cur_e 是树 T 的非根结点，则返回它的双亲，否则返回空。</span><br><span class="line">  <span class="title function_">LeftChild</span><span class="params">(T, cur_e)</span>: 若 cur_e 是树 T 的非叶结点，则返回它的最左孩子，否则返回空。</span><br><span class="line">  <span class="title function_">RightSibling</span><span class="params">(T, cur_e)</span>: 若 cur_e 有右兄弟，则返回它的右兄弟，否则返回空。</span><br><span class="line">  <span class="title function_">InsertChild</span><span class="params">(*T, *p, i, c)</span>: 其中 p 指向树 T 的某个结点，i 为所指结点 p 的度加上 1，非空树 c 与 T 不相交，操作结果为插入 c 为树 T 中 p 指结点的第 i 棵子树。</span><br><span class="line">  <span class="title function_">DeleteChild</span><span class="params">(*T, *p, i)</span>: 其中 p 指向树 T 的某个结点，i 为所指结点 p 的度，操作结果为删除 T 中 p 所指结点的第 i 棵子树。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p>树这种结构，除了根结点外，其余每个结点，他不一定有孩子，但是一定有且仅有一个双亲。假设以一组连续空间存储树的结点，同时<strong>在每个结点中，附设一个指示器指示其双亲结点到链表中的位置</strong>。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。结点结构如下表所示。</p><table><thead><tr><th align="center">data</th><th align="center">parent</th></tr></thead></table><p>其中 data 是数据域，存储结点的数据信息。而 parent 是指针域，存储该结点的双亲在数组中的下标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树的双亲表示法结点结构定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> TElemType;<span class="comment">// 树结点的数据类型，目前暂定为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span> &#123;</span><span class="comment">// 结点结构</span></span><br><span class="line">  TElemType data;<span class="comment">// 结点数据</span></span><br><span class="line">  <span class="type">int</span> parent;<span class="comment">// 双亲位置</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">// 树结构</span></span><br><span class="line">  PTNode nodes[MAX_TREE_SIZE];<span class="comment">// 结点数组</span></span><br><span class="line">  <span class="type">int</span> r, n;<span class="comment">// 根的位置和结点数</span></span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure><p>由于根结点是没有双亲的，所以我们约定根结点的位置域设置为 -1，所有的结点都存有它双亲的位置。</p><p><img src="http://1.117.162.142:9000/blog/%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89.png" alt="树的定义"></p><table><thead><tr><th align="center">下标</th><th align="center">data</th><th align="center">parent</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">A</td><td align="center">-1</td></tr><tr><td align="center">1</td><td align="center">B</td><td align="center">0</td></tr><tr><td align="center">2</td><td align="center">C</td><td align="center">0</td></tr><tr><td align="center">3</td><td align="center">D</td><td align="center">1</td></tr><tr><td align="center">4</td><td align="center">E</td><td align="center">2</td></tr><tr><td align="center">5</td><td align="center">F</td><td align="center">2</td></tr><tr><td align="center">6</td><td align="center">G</td><td align="center">3</td></tr><tr><td align="center">7</td><td align="center">H</td><td align="center">3</td></tr><tr><td align="center">8</td><td align="center">I</td><td align="center">3</td></tr><tr><td align="center">9</td><td align="center">J</td><td align="center">4</td></tr></tbody></table><p>这样的存储结构，可以根据结点的 parent 指针很容易找到它的双亲结点，所用的时间复杂度为 O(1)，直到 parent 为 -1 时，表示找到了树结点的根。可是如果要知道结点的孩子是谁，就需要遍历整个结构才行。可以增加一个结点最左边孩子的域，这里叫作长子域，这样就很容易得到结点的孩子。如果没有孩子的结点，这个长子域就设置为 -1。</p><table><thead><tr><th align="center">下标</th><th align="center">data</th><th align="center">parent</th><th align="center">firstchild</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">A</td><td align="center">-1</td><td align="center">-1</td></tr><tr><td align="center">1</td><td align="center">B</td><td align="center">0</td><td align="center">3</td></tr><tr><td align="center">2</td><td align="center">C</td><td align="center">0</td><td align="center">4</td></tr><tr><td align="center">3</td><td align="center">D</td><td align="center">1</td><td align="center">6</td></tr><tr><td align="center">4</td><td align="center">E</td><td align="center">2</td><td align="center">9</td></tr><tr><td align="center">5</td><td align="center">F</td><td align="center">2</td><td align="center">-1</td></tr><tr><td align="center">6</td><td align="center">G</td><td align="center">3</td><td align="center">-1</td></tr><tr><td align="center">7</td><td align="center">H</td><td align="center">3</td><td align="center">-1</td></tr><tr><td align="center">8</td><td align="center">I</td><td align="center">3</td><td align="center">-1</td></tr><tr><td align="center">9</td><td align="center">J</td><td align="center">4</td><td align="center">-1</td></tr></tbody></table><p>对于有 0 个或 1 个孩子结点来说，这样的结构是解决了要找结点孩子的问题了。甚至是有 2 个孩子，知道了长子是谁，另一个当然就是次子了。</p><p>另外一个问题场景，我们很关注各兄弟之间的关系，双亲表示法无法体现这样的关系，可以增加一个右兄弟域来体现兄弟关系，每一个结点如果它存在右兄弟，则记录下右兄弟的下标。如果右兄弟不存在，则复制为 -1。</p><table><thead><tr><th align="center">下标</th><th align="center">data</th><th align="center">parent</th><th align="center">rightsib</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">A</td><td align="center">-1</td><td align="center">-1</td></tr><tr><td align="center">1</td><td align="center">B</td><td align="center">0</td><td align="center">2</td></tr><tr><td align="center">2</td><td align="center">C</td><td align="center">0</td><td align="center">-1</td></tr><tr><td align="center">3</td><td align="center">D</td><td align="center">1</td><td align="center">-1</td></tr><tr><td align="center">4</td><td align="center">E</td><td align="center">2</td><td align="center">5</td></tr><tr><td align="center">5</td><td align="center">F</td><td align="center">2</td><td align="center">-1</td></tr><tr><td align="center">6</td><td align="center">G</td><td align="center">3</td><td align="center">7</td></tr><tr><td align="center">7</td><td align="center">H</td><td align="center">3</td><td align="center">8</td></tr><tr><td align="center">8</td><td align="center">I</td><td align="center">3</td><td align="center">-1</td></tr><tr><td align="center">9</td><td align="center">J</td><td align="center">4</td><td align="center">-1</td></tr></tbody></table><p>但如果结点的孩子很多，超过了 2 个。我们又关注结点的双亲、又关注结点的孩子、还关注结点的兄弟，而且对时间遍历要求还比较高，那么我们还可以把此结构扩展为有双亲域、长子域、再有右兄弟域。<strong>存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于给予该存储结构的运算是否适合、是否方便，时间复杂度好不好等</strong>。</p><h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><p>由于树中每个结点可能有多棵子树，可以考虑用多重链表，即<strong>每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫作多重表表示法</strong>。树的每个结点的度，也就是它的孩子个数是不同的。所以可以设计两种方案来解决。</p><ul><li><p>方案一</p><p>  一种是指针域的个数就等于树的度，树的度是树各个结点度的最大值。</p><table><thead><tr><th align="center">data</th><th align="center">child1</th><th align="center">child2</th><th align="center">child3</th><th align="center">……</th><th align="center">childd</th></tr></thead></table><p>  其中 data 是数据域。child1 到 childd 是指针域，用来指向该结点的孩子结点。</p><p>  <img src="http://1.117.162.142:9000/blog/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%951.png" alt="孩子表示法1"></p><p>  这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。但是如果树的各结点度相差很小时，那就意味着开辟的空间被充分利用了，这时存储结构的缺点反而变成了优点。</p></li><li><p>方案二</p><p>  第二种方案每个结点指针域的个数等于该结点的度，专门取一个位置来存储结点指针域的个数，其结构如表。</p><table><thead><tr><th align="center">data</th><th align="center">degree</th><th align="center">child1</th><th align="center">child2</th><th align="center">……</th><th align="center">childd</th></tr></thead></table><p>  其中 data 为数据域，degree 为度域，也就是存储该结点的孩子结点的个数，child1 到 childd 为指针域，指向该结点的各个孩子的结点。</p><p>  <img src="http://1.117.162.142:9000/blog/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%952.png" alt="孩子表示法2"></p><p>  这种方法克服了浪费空间的缺点，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上会带来时间上的损耗。</p><p>  为了要遍历整棵树，把每个结点放到一个顺序存储结构的数组中是合理的，但每个结点的孩子有多少是不确定的，所以我们再对每个结点的孩子建立一个单链表体现它们的关系。</p><p>  <strong>孩子表示法把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</strong>。</p><p>  <img src="http://1.117.162.142:9000/blog/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%953.png" alt="孩子表示法3"></p><p>  孩子链表的孩子结点：</p><table><thead><tr><th align="center">child</th><th align="center">next</th></tr></thead></table><p>  其中 child 是数据域，用来存储某个结点在表头数组中的下标。next 是指针域，用来存储指向某结点的下一个孩子结点的指针。</p><p>  表头数组的表头结点：</p><table><thead><tr><th align="center">data</th><th align="center">firstchild</th></tr></thead></table><p>  其中 child 是数据域，存储某结点的数据信息。firstchild 是头指针域，存储该结点的孩子链表的头指针。</p><p>  孩子表示法的结构定义：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树的孩子表示法结构定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> &#123;</span><span class="comment">// 孩子结点</span></span><br><span class="line">  <span class="type">int</span> child;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *ChildPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">// 表头结构</span></span><br><span class="line">  TElemType data;</span><br><span class="line">  ChildPtr firstchild;</span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">// 树结构</span></span><br><span class="line">  CTBox nodes[MAX_TREE_SIZE];<span class="comment">// 结点数组</span></span><br><span class="line">  <span class="type">int</span> r, n;<span class="comment">// 根的位置和结点树</span></span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure><p>  这样的结构对于要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。</p><p>  但是也存在问题，如何知道某个结点的双亲是谁？将双亲表示法和孩子表示法综合一下。</p><p>  <img src="http://1.117.162.142:9000/blog/%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%954.png" alt="孩子表示法4"></p><p>  把这种算法称为双亲孩子表示法，是孩子表示法的改进。</p></li></ul><h4 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h4><p><strong>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</strong>。</p><table><thead><tr><th align="center">data</th><th align="center">firstchild</th><th align="center">rightsib</th></tr></thead></table><p>其中 data 是数据域，firstchild 为指针域，存储该结点的第一个孩子结点的存储地址，rightsib 是指针域，存储该结点的右兄弟结点的存储地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树的孩子兄弟表示法结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">  TElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">rightsib</span>;</span></span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure><p>示意图：</p><p><img src="http://1.117.162.142:9000/blog/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%951.png" alt="孩子兄弟表示法1"></p><p>这种表示法，给查找某个结点的某个孩子带来了方便，只需要通过 firstchild 找到此结点的长子，然后再通过长子结点的 rightsib 找到它的二弟，接着一直下去，直到找到具体的孩子。当然想找某个结点的双亲，这个表示法也是有缺陷的。</p><p>其实这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树。</p><p><img src="http://1.117.162.142:9000/blog/%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%952.png" alt="孩子兄弟表示法2"></p><p>这样就可以充分利用二叉树的特性和算法来处理这棵树了。</p><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><blockquote><p>二叉树 (Binary Tree) 是 n (n ≥ 0) 个结点的有限集合，该集合或者为空集 (称为空二叉树)，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p></blockquote><p><img src="http://1.117.162.142:9000/blog/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树"></p><h4 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h4><p>特点：</p><ul><li>每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。</li><li>左子树和右子树是有顺序的，次序不能任意颠倒。</li><li>即是树中某结点只有一棵子树，也要区分它是左子树还是右子树。</li></ul><p>二叉树具有五种基本形态：</p><ol><li>空二叉树。</li><li>只有一个根结点。</li><li>根结点只有左子树。</li><li>根结点只有右子树。</li><li>根结点既有左子树又有右子树。</li></ol><h4 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h4><ul><li><p><strong>斜树</strong></p><p>  <strong>所有结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树</strong>。</p></li><li><p><strong>满二叉树</strong></p><p>  <strong>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树</strong>。</p><p>  满二叉树的特点有：</p><ul><li>叶子只能出现在最下一层。出现在其他层就不可能达成平衡。</li><li>非叶子结点的度一定是 2。</li><li>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</li></ul></li><li><p><strong>完全二叉树</strong></p><p>  <strong>对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i (1 ≤ i ≤ n) 的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树</strong>。</p><p>  完全二叉树的特点：</p><ul><li>叶子结点只能出现在最下两层。</li><li>最下层的叶子一定集中在左部连续位置。</li><li>倒数二层，若有叶子结点，一定都在右部连续位置。</li><li>如果结点度为 1，则该结点只有左孩子，既不存在只有右子树的情况。</li><li>同样结点树的二叉树，完全二叉树的深度最小。</li></ul></li></ul><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质 1"></a>性质 1</h4><p>**在二叉树的第 i 层上至多有 2<sup>i - 1</sup> 个结点 (i ≥ 1)**。</p><h4 id="性质-2"><a href="#性质-2" class="headerlink" title="性质 2"></a>性质 2</h4><p>**深度为 k 的二叉树至多有 2<sup>k</sup> - 1 个结点 (k ≥ 1)**。</p><h4 id="性质-3"><a href="#性质-3" class="headerlink" title="性质 3"></a>性质 3</h4><p><strong>对任何一棵二叉树 T，如果其终端结点数为 n<sub>0</sub>，度为 2 的结点树为 n<sub>2</sub>，则 n<sub>0</sub> &#x3D; n<sub>2</sub> + 1</strong>。</p><h4 id="性质-4"><a href="#性质-4" class="headerlink" title="性质 4"></a>性质 4</h4><p>**具有 n 个结点的完全二叉树的深度为 [log<sub>2</sub>n] + 1 ([x] 表示不大于 x 的最大整数)**。</p><h4 id="性质-5"><a href="#性质-5" class="headerlink" title="性质 5"></a>性质 5</h4><p><strong>如果对一棵有 n 个结点的完全二叉树 (其深度为 [log<sub>2</sub>n] + 1) 的结点按层序编号 (从第 1 层到第 [log<sub>2</sub>n] + 1 层，每层从左到右)，对任一结点 i (1 ≤ i ≤ n) 有：</strong></p><ol><li><strong>如果 i &#x3D; 1，则结点 i 是二叉树的根，无双亲；如果 i &gt; 1，则其双亲是结点 [i &#x2F; 2]。</strong></li><li><strong>如果 2i &gt; n，则结点 i 无左孩子 (结点 i 为叶子结点)；否则其左孩子是结点 2i。</strong></li><li><strong>如果 2i + 1 &gt; n，则结点 i 无右孩子；否则其右孩子是结点 2i + 1。</strong></li></ol><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="二叉树顺序存储结构"><a href="#二叉树顺序存储结构" class="headerlink" title="二叉树顺序存储结构"></a>二叉树顺序存储结构</h4><p>二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等。</p><p><img src="http://1.117.162.142:9000/blog/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A81.png" alt="完全二叉树顺序存储1"></p><p>将这棵二叉树存入到数组中，相应的下标对应其同样的位置。</p><p><img src="http://1.117.162.142:9000/blog/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A82.png" alt="完全二叉树顺序存储2"></p><p>由于完全二叉树严格的定义，所以用顺序结构也可以表现出二叉树的结构。对于一般的二叉树，尽管层序编号不能反映逻辑关系，但是可以将其按完全二叉树编号，只不过，把不存在的结点设置为 “^” 而已。浅色结点表示不存在。</p><p><img src="http://1.117.162.142:9000/blog/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A83.png" alt="完全二叉树顺序存储3"></p><p><img src="/../.vuepress/public/dsa/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A84.png" alt="完全二叉树顺序存储4"></p><p>考虑一种极端的情况，一棵深度为 k 的右斜树，它只有 k 个结点，却需要分配 2<sup>k</sup> - 1 个存储单元空间，这显然是对存储空间的浪费。</p><p><img src="http://1.117.162.142:9000/blog/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A85.png" alt="完全二叉树顺序存储5"></p><p>所以顺序存储结构一般只用于完全二叉树。</p><h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p><strong>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域</strong>是比较自然的想法，<strong>称这样的链表叫作二叉链表</strong>。结点结构如图。</p><table><thead><tr><th align="center">lchild</th><th align="center">data</th><th align="center">child</th></tr></thead></table><p>其中 data 是数据域，lchild 和 rchild 都是指针域，分别存放指向左孩子和右孩子的指针。</p><p>二叉链表的结点结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的二叉链表结点结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span><span class="comment">// 结点结构</span></span><br><span class="line">  TElemType data;<span class="comment">// 结点数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125; BiTnode, *BiTree;</span><br></pre></td></tr></table></figure><p>结构示意图：</p><p><img src="http://1.117.162.142:9000/blog/%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8.png" alt="二叉链表"></p><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><blockquote><p>二叉树的遍历 (traversing binary tree) 是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p></blockquote><h4 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a>二叉树遍历方法</h4><ol><li><p><strong>前序遍历</strong></p><p> <strong>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。</strong></p><p> <img src="http://1.117.162.142:9000/blog/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="前序遍历"></p></li><li><p><strong>中序遍历</strong></p><p> <strong>规则是若树为空，则空操作返回，否则从根结点开始 (注意并不是先访问根结点)，中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树</strong>。</p><p> <img src="http://1.117.162.142:9000/blog/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="中序遍历"></p></li><li><p><strong>后序遍历</strong></p><p> <strong>规则是若树为空，则空操作返回，否则从左到右线叶子后结点的方式遍历访问左右子树，最后是访问根结点</strong>。</p><p> <img src="http://1.117.162.142:9000/blog/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="后序遍历"></p></li><li><p><strong>层序遍历</strong></p><p> <strong>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问</strong>。</p><p> <img src="http://1.117.162.142:9000/blog/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.png" alt="层序遍历"></p></li></ol><h4 id="前序遍历算法"><a href="#前序遍历算法" class="headerlink" title="前序遍历算法"></a>前序遍历算法</h4><p>二叉树的定义是用递归的方式，所以，实现遍历算法也可以采用递归，而且极其简洁明了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的前序遍历递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraverse</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T -&gt; data);<span class="comment">// 显示结点数据，可以更改为其它对结点操作</span></span><br><span class="line">  PreOrderTraverse(T -&gt; lchild);<span class="comment">// 在先序遍历左子树</span></span><br><span class="line">  PreOrderTraverse(T -&gt; rchild);<span class="comment">// 最后先序遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历算法"><a href="#中序遍历算法" class="headerlink" title="中序遍历算法"></a>中序遍历算法</h4><p>中序遍历算法和前序遍历算法仅仅只是在代码的顺序上的差异。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的中序遍历递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  InOrderTraverse(T -&gt; lchild);<span class="comment">// 中序遍历左子树</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T -&gt; data);<span class="comment">// 显示结点数据，可以更改为其它对结点操作</span></span><br><span class="line">  InOrderTraverse(T -&gt; rchild);<span class="comment">// 最后中序遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历算法"><a href="#后序遍历算法" class="headerlink" title="后序遍历算法"></a>后序遍历算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的后序遍历递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderTraverse</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  PostOrderTraverse(T -&gt; lchild);<span class="comment">// 先后序遍历左子树</span></span><br><span class="line">  PostOrderTraverse(T -&gt; rchild);<span class="comment">// 再后序遍历右子树</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T -&gt; data);<span class="comment">// 显示结点数据，可以更改为其它对结点操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="推导遍历结果"><a href="#推导遍历结果" class="headerlink" title="推导遍历结果"></a>推导遍历结果</h4><p>二叉树遍历的两个性质：</p><ul><li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li><li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li></ul><p><strong>已知前序和后序遍历，是不能确定一棵二叉树的</strong>。因为无法确定子结点是左还是右。</p><h3 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h3><p>要在内存中建议一个树，为了能让每个结点确认是否有左右孩子，将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值，比如 ‘#’。称这种处理后的二叉树为原二叉树的扩展二叉树。扩展二叉树就可以做到一个遍历序列确定一棵二叉树了。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按前序输入二叉树中结点的值 (一个字符)</span></span><br><span class="line"><span class="comment">// &#x27;#&#x27; 表示空树，构造二叉链表表示二叉树 T</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree *T)</span> &#123;</span><br><span class="line">  TElemType ch;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">  <span class="keyword">if</span>(ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    *T = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    *T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">if</span>(!*T)</span><br><span class="line">      <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    (*T) -&gt; data = ch;<span class="comment">// 生成根结点</span></span><br><span class="line">    CreateBiTree(&amp;(*T) -&gt; lchild);<span class="comment">// 构造左子树</span></span><br><span class="line">    CreateBiTree(&amp;(*T) -&gt; rchild);<span class="comment">// 构造右子树</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立二叉树也是利用了递归的原理。只不过在原来应该是打印结点的地方，改成了生成结点、给结点赋值的操作而已。</p><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h4 id="线索二叉树原理"><a href="#线索二叉树原理" class="headerlink" title="线索二叉树原理"></a>线索二叉树原理</h4><p><strong>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树 (Threaded Binary Tree)。对二叉树以某种次序遍历使其变为线索二叉树的过程称作是线索化</strong>。</p><p>结点结构：</p><table><thead><tr><th align="center">lchild</th><th align="center">ltag</th><th align="center">data</th><th align="center">rtag</th><th align="center">rchild</th></tr></thead></table><ul><li>ltag 为 0 时指向该结点的左孩子，为 1 时 指向该结点的前驱。</li><li>rtag 为 0 时指向该结点的右孩子，为 1 时 指向该结点的后继。</li></ul><h4 id="线索二叉树结构实现"><a href="#线索二叉树结构实现" class="headerlink" title="线索二叉树结构实现"></a>线索二叉树结构实现</h4><p>二叉树的线索存储结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的二叉线索存储结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>Link, Thread&#125; PointerTag;<span class="comment">// Link == 0 表示指向左右孩子指针，Threed == 1 表示指向前驱或后继的线索</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode</span> &#123;</span><span class="comment">// 二叉线索存储结点结构</span></span><br><span class="line">  TElemType data;<span class="comment">// 结点数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">// 左右孩子指针</span></span><br><span class="line">  PointerTag LTag;</span><br><span class="line">  PointerTag RTag;<span class="comment">// 左右标志</span></span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure><p>线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以<strong>线索化的过程就是在遍历的过程中修改空指针的过程</strong>。</p><p>中序遍历线索化的递归函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BiThrTree pre;<span class="comment">// 全局变量，始终指向刚刚访问过的结点</span></span><br><span class="line"><span class="comment">// 中序遍历进行中序线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThreading</span><span class="params">(BiThrTree p)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(p) &#123;</span><br><span class="line">    InThreading(p -&gt; lchild);<span class="comment">// 递归左子树线索化</span></span><br><span class="line">    <span class="keyword">if</span>(!p -&gt; lchild) &#123;</span><br><span class="line">      p -&gt; LTag = Thread;<span class="comment">// 前驱线索</span></span><br><span class="line">      p -&gt; lchild = pre;  <span class="comment">// 左孩子指针指向前驱</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!pre -&gt; rchild) &#123;</span><br><span class="line">      pre -&gt; RTag = Thread;<span class="comment">// 后继线索</span></span><br><span class="line">      pre -&gt; rchild = p;<span class="comment">// 前驱右孩子指针指向后继 (当前结点 p)</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre = p;<span class="comment">// 保持 pre 指向 p 的前驱</span></span><br><span class="line">    InThreading(p -&gt; rchild);  <span class="comment">// 递归右子树线索化</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T 指向头结点，头结点左链 lchild 指向根结点，头结点右链 rchild 指向中序遍历的最后一个结点。中序遍历二叉线索链表表示的二叉树 T</span></span><br><span class="line">Status <span class="title function_">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span> &#123;</span><br><span class="line">  BiThrTree p;</span><br><span class="line">  p = T -&gt; lchild;<span class="comment">// p 指向根结点</span></span><br><span class="line">  <span class="keyword">while</span>(p != T) &#123;<span class="comment">// 空树或遍历结束时</span></span><br><span class="line">    <span class="keyword">while</span>(p -&gt; LTag == Link)<span class="comment">// 当 LTag == 0 时循环到中序序列第一个结点</span></span><br><span class="line">      p = p -&gt; lchild;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p -&gt; data);<span class="comment">// 显示结点数据，可以更改为其它对结点操作</span></span><br><span class="line">    <span class="keyword">while</span>(p -&gt; RTag == Thread &amp;&amp; p -&gt; rchild != T) &#123;</span><br><span class="line">      p = p -&gt; rchild;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p -&gt; data);</span><br><span class="line">    &#125;</span><br><span class="line">    p = p -&gt; rchild;<span class="comment">// p 进至其右子树根</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</p><h3 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h3><h4 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h4><p>将树转换为二叉树的步骤如下：</p><ol><li>加线。在所有兄弟结点之间加一条连线。</li><li>去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其它孩子结点之间的连线。</li><li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。</li></ol><h4 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h4><p>森林是由若干树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。</p><ol><li>把每个树转换为二叉树。</li><li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。</li></ol><h4 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h4><p>二叉树转换为树是树转换为二叉树的逆过程，也就是反过来做而已。</p><ol><li>加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……，反正就是左孩子的 n 个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。、</li><li>去线。删除原二叉树中所有结点与其右孩子结点的连线。</li><li>层次调整。使之结构层次分明。</li></ol><h4 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h4><p>判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。</p><ol><li>从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。</li><li>再将每棵分离后的二叉树转换为树即可。</li></ol><h4 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h4><p>树的遍历分为两种方式</p><ol><li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。</li><li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。</li></ol><p>森林的遍历也分为两种方式：</p><ol><li><strong>前序遍历</strong>：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。</li><li><strong>后序遍历</strong>：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。</li></ol><h3 id="赫夫曼树及其应用"><a href="#赫夫曼树及其应用" class="headerlink" title="赫夫曼树及其应用"></a>赫夫曼树及其应用</h3><h4 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h4><p>例子：对于老师来讲，对试卷评分的时候，根据统一的标准换算得出五级分制的成绩。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &lt; <span class="number">60</span>)</span><br><span class="line">  b = <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a &lt; <span class="number">70</span>)</span><br><span class="line">  b = <span class="string">&quot;及格&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a &lt; <span class="number">80</span>)</span><br><span class="line">  b = <span class="string">&quot;中等&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a &lt; <span class="number">90</span>)</span><br><span class="line">  b = <span class="string">&quot;良好&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  b = <span class="string">&quot;优秀&quot;</span>;</span><br></pre></td></tr></table></figure><p>上面的程序，使得所有的成绩都需要先判断是否及格，再逐级而上得到结果。输入量很大的时候，其实算法是有效率问题的。</p><p><img src="http://1.117.162.142:9000/blog/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%912.png" alt="赫夫曼树2"></p><p>如果在实际的学习生活中，学生的成绩在 5 个等级上的分布规律如表所示</p><table><thead><tr><th align="center">分数</th><th align="center">0 ~ 59</th><th align="center">60 ~ 69</th><th align="center">70 ~ 79</th><th align="center">80 ~ 89</th><th align="center">90 ~ 100</th></tr></thead><tbody><tr><td align="center">所占比例</td><td align="center">5%</td><td align="center">15%</td><td align="center">40%</td><td align="center">30%</td><td align="center">10%</td></tr></tbody></table><p>那么 70 分以上大约占总数 80% 的成绩都需要经过 3 次以上的判断才可以得到结果，这很不合理。中等成绩 (70 ~ 79 分之间) 比例最高，其次是良好成绩，不及格的所占比例最小。重新把这棵二叉树进行分配：</p><p><img src="http://1.117.162.142:9000/blog/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%913.png" alt="赫夫曼树3"></p><h4 id="赫夫曼树定义与原理"><a href="#赫夫曼树定义与原理" class="headerlink" title="赫夫曼树定义与原理"></a>赫夫曼树定义与原理</h4><p>把上面两棵二叉树简化成叶子结点带权的二叉树。其中 A 表示不及格、B 表示及格、C 表示中等、D 表示良好、E 表示优秀。每个叶子的分支线上的数字就是5级分制的成绩所占比例数。</p><p><img src="http://1.117.162.142:9000/blog/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%911.png" alt="赫夫曼树1"></p><p><strong>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度</strong>。上图二叉树 a 中，根结点到结点 D 的路径长度为 4，二叉树 b 中根结点到结点 D 的路径长度为 2。<strong>树的路径长度就是从树根到每一结点的路径长度之和</strong>。二叉树 a 的树路径长度就为 1 + 1 + 2 + 2 + 3 + 3 +4 + 4 &#x3D; 20。二叉树 b 的树路径长度就为 1 + 2 +3 + 3 + 2 + 1 + 2 + 2 &#x3D; 16。</p><p>如果考虑到带权的结点，结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。假设有 n 个权值 {W<sub>1</sub>, W<sub>2</sub>, ……, W<sub>n</sub>}，构造一棵有 n 个叶子结点的二叉树，每个叶子结点带权 W<sub>k</sub>，每个叶子的路径长度为 1k，通常记作，则其中<strong>带权路径长度 WPL 最小的二叉树称作赫夫曼树</strong>。</p><p>赫夫曼算法描述：</p><ol><li>根据给定的 n 个权值 {W<sub>1</sub>, W<sub>2</sub>, ……, W<sub>n</sub>} 构成 n 棵二叉树的集合 F &#x3D; {T<sub>1</sub>, T<sub>2</sub>, ……, T<sub>n</sub>}，其中每棵二叉树 T<sub>i</sub> 中只有一个带权为 W<sub>i</sub> 根结点，其左右子树均为空。</li><li>在 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</li><li>在 F 中删除这两棵树，同时将新得到的二叉树加入 F 中。</li><li>重复 2 和 3 步骤，知道 F 只含一棵树为止。这棵树便是赫夫曼树。</li></ol><h4 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h4><p>赫夫曼树更大的目的是为了解决当年远距离通信 (主要是电报) 的数据传输的最优化问题。</p><p>比如有一段文字内容为 “BADCADFEED“ 要网络传输给别人，显然用二进制的数字 (0 和 1) 来表示是很自然的想法。这段文字只有六个字母 ABCDEF，可以用相应的二进制数据表示。</p><table><thead><tr><th align="center">字母</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th></tr></thead><tbody><tr><td align="center">二进制字符</td><td align="center">000</td><td align="center">001</td><td align="center">010</td><td align="center">011</td><td align="center">100</td><td align="center">101</td></tr></tbody></table><p>这样真正传输的数据就是编码后的 “001000011010000011101100100011”，对方接收时可以按照 3 位 一分来译码。如果一篇文章很长，这样的二进制串也将非常的可怕。而且事实上，不管是英文、中文或是其它语言，字母或汉字的出现频率是不相同的，比如英语中的几个元音字母 “a e i o u”，中文中的 “的 了 有 在” 等汉字都是频率极高。</p><p>假设六个字母的频率为 A 27，B 8，C 15，D 15，E 30，F 5，合起来正好是 100%。那就意味着，可以完全重新按照赫夫曼树来规划它们。</p><p><img src="http://1.117.162.142:9000/blog/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%914.png" alt="赫夫曼树4"></p><p>左图为构造赫夫曼树的过程的权值显示，右图为将权值左分支改为 0，右分支改为 1 后的赫夫曼树。</p><p>对这六个字母用其从树根到叶子所经过路径的 0 或 1 来编码，可以得到如表所示的定义。</p><table><thead><tr><th align="center">字母</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th><th align="center">F</th></tr></thead><tbody><tr><td align="center">二进制字符</td><td align="center">01</td><td align="center">1001</td><td align="center">101</td><td align="center">00</td><td align="center">11</td><td align="center">1000</td></tr></tbody></table><p>将文字内容为 “BADCADFEED” 再次编码，对比可以发现结果串变小了。</p><ul><li>原编码二进制串：001000011010000011101100100011 ( 共 30 个字符 )</li><li>新编码二进制串：1001010010101001000111100 ( 共 25 个字符 )</li></ul><p>也就是说，数据被压缩了，节约了大约 17% 的存储或传输成本。随着字符的增多和多字符权重的不同，这种压缩会更加显出其优势。</p><p>当接收到 1001010010101001000111100 这样压缩过的新编码时，应该怎么解码？</p><p>编码中非 0 即 1，长短不等的话其实是很容易混淆的，所以<strong>若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称作前缀编码</strong>。</p><p>在解码时，要用到赫夫曼树，己发送发和接收方必须要约定好同样的复合曼编码规则。</p><p>当接收到 1001010010101001000111100 时，由约定好的赫夫曼树可知，1001 得到第一个字母是 B，接下来 01 意味着第二个字符是 A。其余的也相应的可以得到，从而成功解码。</p><p><strong>一般地，设需要编码的字符集为 { d<sub>1</sub>, d<sub>2</sub>, …… , d<sub>n</sub> }，各个字符在电文中出现的次数或频率集合为  { w<sub>1</sub>, w<sub>2</sub>, …… , w<sub>n</sub> }，以 d<sub>1</sub>, d<sub>2</sub>, …… , d<sub>n</sub> 作为叶子结点，以 w<sub>1</sub>, w<sub>2</sub>, …… , w<sub>n</sub> 作为相应叶子结点的权值来构造一颗赫夫曼树。规定赫夫曼树的左右分支代表 0，右分支代表 1，则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码</strong>。</p><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>树的相关概念：子树、结点、度、叶子、分支结点、双亲、孩子、层次、深度、森林。</p><p>树的存储结构：双亲表示法、孩子表示法、孩子兄弟表示法。</p><p>二叉树每个结点最多两棵子树，有左右之分，提到了斜树、满二叉树、完全二叉树等。</p><p>二叉树的存储结构由于其特殊性是的既可以用顺序存储结构又可以用链式存储结构表示。</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p>在线性表中， 数据元素之间是被串起来的，仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继。在树形结构中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关。折合一对父母可以有多个孩子，但每个孩子却只能有一对父母是一个道理。在图形结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。</p><blockquote><p>图 (Graph) 是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为: G (V, E)，其中 G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。</p></blockquote><p>对于图的定义，需要明确几个注意的地方：</p><ul><li>线性表中我们把数据元素叫元素，树中将数据元素叫结点，**在图中数据元素，称之为顶点 (Vertex)**。</li><li>线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。在图结构中，不允许没有丁点。在定义中，若 V 是顶点的集合，则强调了顶点集合 V 有穷非空。</li><li>线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而<strong>图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示</strong>，边集可以是空的。</li></ul><h4 id="各种图定义"><a href="#各种图定义" class="headerlink" title="各种图定义"></a>各种图定义</h4><p><strong>无向边：若顶点 v<sub>i</sub> 到 v<sub>j</sub> 之间的边没有方向，则称这条边为无向边 (Edge)，用无序偶对 (v<sub>i</sub>, v<sub>j</sub>)来表示</strong>。如果图中任意两个顶点之间的边都是无向边，则称该图为**无向图 (Undirected graphs)**。</p><p><img src="http://1.117.162.142:9000/blog/%E6%97%A0%E5%90%91%E8%BE%B9.png" alt="无向边"></p><p>由于是无向的，连接顶点 A 与 D 的边，可以表示成无序对 (A, D)，也可以写成 (D, A)。对于图中无向图 G<sub>1</sub> 来说，G<sub>1</sub>  &#x3D; (V<sub>1</sub>, {E<sub>1</sub>})，其中顶点集合 V<sub>1</sub> &#x3D; {A, B, C, D}；边集合 E<sub>1</sub> &#x3D; {(A, B), {B, C}, (C, D), (D, A), (A, C)}。</p><p><img src="http://1.117.162.142:9000/blog/%E6%9C%89%E5%90%91%E8%BE%B9.png" alt="有向边"></p><p>**有向边：若从顶点 V<sub>i</sub> 到V<sub>j</sub> 的边有方向，则称这条边为有向边，也称为弧 (Arc)<strong>。用有序偶 &lt;V<sub>i</sub>, V<sub>j</sub>&gt; 来表示，V<sub>i</sub> 称为弧尾 (Tail)，V<sub>j</sub> 称为弧头 (Head)。如果图中任意两个顶点之间的边都是有向边，则称该图为</strong>有向图 (Directed graphs)<strong>。上图是一个有向图，</strong>连接顶点 A 到 D 的有向边就是弧，A 是弧尾，D 是弧头，&lt;A, D&gt; 表示弧，注意不能写成&lt;D, A&gt;**。对于图中的有向图 G<sub>2</sub> 来说，G<sub>2</sub> &#x3D; (V<sub>2</sub>, {E<sub>2</sub>})，其中顶点集合 V<sub>2</sub> &#x3D; {A, B, C, D}；弧集合 E<sub>2</sub> &#x3D; {&lt;A, D&gt;, &lt;B, A&gt;, &lt;C, A&gt;, &lt;B, C&gt;}。</p><p><strong>无向边有小括号 “( )” 表示，而有向边则是用尖括号 “&lt;&gt;”表示</strong>。</p><p><strong>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图</strong>。</p><p><strong>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图</strong>。含有 n 个顶点的无向完全图有 n*(n-1)&#x2F;2 条边。</p><p><strong>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图</strong>。含有 n 个顶点的有向完全图有 n*(n-1) 条边。<br>从这里也可以得到结论，对于具有 n 个顶点和 e 条边数的图，无向图 0 ≤ e ≤ n(n-1)&#x2F;2，有向图 0 ≤ e ≤ n(n-1)。</p><p><strong>又很少条边或弧的图称为稀疏图，反之称为稠密图</strong>。这里稀疏和稠密是模糊的概念，都是相对而言的。</p><p>有些图的边或弧具有与它相关的数字，这种**与图的边或弧相关的数叫做权 (weight)<strong>。这些权可以表示从一个顶点到另一个顶点的距离或耗费。</strong>这种带权的图通常称为网 (Network)**。</p><p>**假设有两个图 G &#x3D; (V, {E}) 和 G’ &#x3D; (V’, {E’})，如果 V’⊆ V 且 E’ ⊆ E，则称 G’ 为 G 的子图 (Subgraph)**。</p><h4 id="图的顶点与边间关系"><a href="#图的顶点与边间关系" class="headerlink" title="图的顶点与边间关系"></a>图的顶点与边间关系</h4><p>**对于无向图 G &#x3D; (V, {E})，如果边 (v, v’) ∈ E，则称顶点 v 和 v’ 互为邻接点 (Adjacent)，即 v 和 v’ 相邻接。边 (v, v’) 依附 (incident) 与顶点 v 和 v’，或者说 (v, v’) 与顶点 v 和 v’ 相关联。顶点 v 的度 (Degree) 是和 v 相关联的边的数目，记为TD(v)**。</p><p>**对于有向图 G &#x3D; (V, {E})，如果弧 &lt;v, v’&gt; ∈ E，则称顶点 v 邻接到顶点 v’，顶点 v’ 邻接自顶点 v。弧 &lt;v, v’&gt; 和顶点 v，v’相关联。以顶点 v 为头的弧的数目称为 v 的入度 (InDegree)，记为 ID(v)；以 v 为尾的弧的数目称为 v 的出度 (OutDegree)，记为OD(v)；顶点 v 的度为 TD(v) &#x3D; ID(v) + OD(v)**。</p><p><strong>无向图 G &#x3D; (V, {E}) 中从顶点 v 到顶点 v’ 的路径 (Path) 是一个顶点序列 (v&#x3D;v<sub>i,0</sub>, v<sub>i,1</sub>, ···, v<sub>i,m</sub>)，其中 (v<sub>i,j-1</sub>) ∈ E，1 ≤ j ≤ m</strong>。</p><p><strong>路径的长度是路径上的边或弧的数目。第一个顶点到最后一个顶点相同的路径称为回路或环 (Cycle)。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环</strong>。</p><h4 id="连通图相关术语"><a href="#连通图相关术语" class="headerlink" title="连通图相关术语"></a>连通图相关术语</h4><p>**图中任意两个顶点 v<sub>i</sub>、v<sub>j</sub> ∈ E，v<sub>i</sub> 和 v<sub>j</sub> 都是连通的，则称 G 是连通图 (Connected Graph)**。</p><p><strong>无向图中的极大连通子图称为连通分量</strong>。注意连通分量的概念，它强调：</p><ul><li>要是子图；</li><li>子图要是连通的；</li><li>连通子图含有极大顶点数；</li><li>具有极大顶点数的连通子图包含依附于这些顶点的所有边。</li></ul><p><strong>在有向图 G 中，如果对于每一对 v<sub>i</sub>、v<sub>j</sub> ∈ V、v<sub>i</sub> ≠ v<sub>j</sub>，从 v<sub>i</sub> 到 v<sub>j</sub> 和从v<sub>j</sub> 到 v<sub>i</sub> 都存在路径，则称 G 是强连通图。有向图中的极大强连通子图称做有向图的强连通分量</strong>。</p><p>所谓的<strong>一个连通图的生成树是一个极小的连通子图，它含有图中全部的 n 个顶点，但只有足以构成一棵树的 n-1 条边。如果一个有向图恰有一个顶点的入度为 0，其余顶点的入度均为 1，则是一颗有向树</strong>。对有向树的理解比较容易，所谓入度为 0 其实就是相当于树中的根结点，其余顶点入度为 1 就是说树的非根结点的双亲只有一个。<strong>一个有向图的生成森林由若干棵有向数组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧</strong>。</p><h4 id="图的定义与术语总结"><a href="#图的定义与术语总结" class="headerlink" title="图的定义与术语总结"></a>图的定义与术语总结</h4><p><strong>图</strong>按照有无方向分为<strong>无向图</strong>和<strong>有向图</strong>。无向图由<strong>顶点</strong>和<strong>边</strong>构成，有向图由<strong>顶点</strong>和<strong>弧</strong>构成。弧有<strong>弧尾</strong>和<strong>弧头</strong>之分。</p><p>图按照边或弧的多少分<strong>稀疏图</strong>和<strong>稠密图</strong>。如果任意两个顶点之间都存在边叫<strong>完全图</strong>，有向的叫<strong>有向完全图</strong>。若无重复的边或顶点到自身的边则叫<strong>简单图</strong>。</p><p>图中顶点之间有<strong>邻接点</strong>、<strong>依附</strong>的概念。无向图顶点的边数叫做<strong>度</strong>，有向图顶点分为<strong>入度</strong>和<strong>出度</strong>。</p><p>图上的边或弧上带权则称为<strong>网</strong>。</p><p>图中顶点间存在<strong>路径</strong>，两顶点存在路径则说明是<strong>连通</strong>的，如果路径最终回到起始点则称为<strong>环</strong>，当中不重复叫<strong>简单路径</strong>。若任意两顶点都是连通的，则图就是<strong>连通图</strong>，有向则称<strong>强连通图</strong>。图中有子图，若子图极大连通则就是<strong>连通分量</strong>，有向的则称<strong>强连通分量</strong>。</p><p>无向图中连通且 n 个顶点 n - 1 条边叫<strong>生成树</strong>。有向图中一顶点入度为 0 其余顶点入度为 1 的叫<strong>有向树</strong>。一个有向图由若干棵有向树构成生成<strong>森林</strong>。</p><h3 id="图的抽象数据类型"><a href="#图的抽象数据类型" class="headerlink" title="图的抽象数据类型"></a>图的抽象数据类型</h3><p>图作为一种数据结构，它的抽象数据类型带有自己特点，正因为它的复杂，运用广泛，使得不同的应用需要不同的运算集合，构成不同的抽象数据操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ADT 图 (Graph)</span><br><span class="line">Data</span><br><span class="line">  顶点的有穷非空集合和边的集合</span><br><span class="line">Operation</span><br><span class="line">  <span class="title function_">CreateGraph</span><span class="params">(*G, V, VR)</span>: 按照顶点集合 V 和边弧集 VR 的定义构造图 G。</span><br><span class="line">  <span class="title function_">DestroyGraph</span><span class="params">(*G)</span>: 图 G 存在则销毁。</span><br><span class="line">  <span class="title function_">LocateVex</span><span class="params">(G, u)</span>: 若图 G 中存在顶点 u，则返回图中的位置。</span><br><span class="line">  <span class="title function_">GetVex</span><span class="params">(G, v)</span>: 返回图 G 中顶点 v 的值。</span><br><span class="line">  <span class="title function_">PutVex</span><span class="params">(G, v, value)</span>: 将图 G 中顶点 v 赋值 value。</span><br><span class="line">  <span class="title function_">FirstAdjVex</span><span class="params">(G, *v)</span>: 返回顶点 v 的一个邻接点，若顶点在 G 中无邻接顶点返回空。</span><br><span class="line">  <span class="title function_">NextAdVex</span><span class="params">(G, v, *w)</span>: 返回顶点 v 相对于顶点 w 的下一个邻接顶点，若 w 是 v 的最后一个邻接点则返回“空”。</span><br><span class="line">  <span class="title function_">InsertVex</span><span class="params">(*G, v)</span>: 在图 G 中增添新顶点 v。</span><br><span class="line">  <span class="title function_">DeleteVex</span><span class="params">(*G, v)</span>: 删除图 G 中顶点 v 及其相关的弧。</span><br><span class="line">  <span class="title function_">InsertArc</span><span class="params">(*G, v, w)</span>: 在图 G 中增添弧 &lt;v, w&gt;，若 G 是无向图，还需要增添对称弧 &lt;w, v&gt;。</span><br><span class="line">  <span class="title function_">DeleteArc</span><span class="params">(*G, v, w)</span>: 在图 G 中删除弧 &lt;v, w&gt;，若 G 是无向图，则还删除对称弧 &lt;w, v&gt;。</span><br><span class="line">  <span class="title function_">DFSTraverse</span><span class="params">(G)</span>: 对图 G 中进行深度优先遍历，在遍历过程对每个顶点调用。</span><br><span class="line">  <span class="title function_">HFSTraverse</span><span class="params">(G)</span>: 对图 G 中进行广度优先遍历，在遍历过程对每个顶点调用。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><p>图的存储结构相较线性表与树来说就复杂了，平时所说的“顶点的位置”或“邻接点的位置”只是一个相对的概念。其实从图的逻辑结构定义来看，图上任何一个顶点都可被看成是第一个顶点，任一顶点的临界点之间也不存在次序关系。正由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在内存中的物理位置来表示元素之间的关系，也就是说，图不可能用简单的顺序存储结构来表示。而多重链表的方式，即以一个数据域和多个指针域组成的结点表示图中的一个顶点，尽管可以实现图结构。如果各顶点的度数相差很大，按度数最大的顶点设计结点结构会造成很多存储单元的浪费，而若按每个顶点自己的度数设计不同的顶点结构，又带来操作的不变。</p><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>考虑到图是顶点和边或弧两部分组成。合在一起比较困难，那就很自然地考虑到分两个结构来分别存储。顶点不分大小、主次，所以用一个一维数组来存储是很不错的选择。而边或弧由于是顶点与顶点之间的关系，一维搞不定，那就考虑用一个二维数组来存储。</p><p><strong>图的邻接矩阵 (Adjacency Matrix) 存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组 (称为邻接矩阵) 存储图中的边或弧的信息</strong>。</p><p>设图 G 有 n 个顶点，则邻接矩阵是一个 n*n 的方阵，定义为：</p><p>Arc[i][j] &#x3D; 1, 若 (v<sub>i</sub>, v<sub>j</sub>) ∈ E 或 &lt; v<sub>i</sub>, v<sub>j</sub> &gt;∈ E</p><p>Arc[i][j] &#x3D; 0，反之</p><p><img src="http://1.117.162.142:9000/blog/%E6%97%A0%E5%90%91%E5%9B%BE.png" alt="无向图"></p><p>可以设置两个数组，顶点数组为 vertex[4] &#x3D; {v<sub>0</sub>, v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>}，边数组 arc[4][4] 为上面右图中的一个矩阵。对于矩阵的主对角线的值，即 arc[0][0] 、arc[1][1]、arc[2][2]、arc[3][3]，全为 0 是因为不存在顶点到自身的边，比如 v<sub>0</sub> 到 v<sub>0</sub>。arc[0][1] &#x3D; 1 是因为 v<sub>0</sub> 到 v<sub>1</sub> 的边存在，而 arc[1][3] &#x3D; 0 是因为 v<sub>1</sub> 到 v<sub>3</sub> 的边不存在。并且由于是无向图， v<sub>1</sub> 到 v<sub>3</sub> 的边不存在，意味着 v<sub>3</sub> 到 v<sub>1</sub> 的边也不存在。所以无向图的边数组是一个对称矩阵。</p><p>要知道某个顶点的度，其实就是这个顶点 v<sub>i</sub> 在邻接矩阵中第 i 行 (或第 i 列) 的元素之和。求顶点 v<sub>i</sub> 的所有邻接点就是将矩阵中第 i 行元素扫描一遍，arc[i][j] 为 1 就是邻接点。</p><p>邻接矩阵的创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;<span class="comment">// 顶点类型应由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;<span class="comment">// 边上的权值类型应由用户定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVEX 100<span class="comment">// 最大顶点数，应由用户定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 65535<span class="comment">// 用 65535 来代表 ∞</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  VertexType vexs[MAXVEX];<span class="comment">// 顶点表</span></span><br><span class="line">  EdgeType arc[MAXVEX][MAXVEX];<span class="comment">// 邻接矩阵，可看作边表</span></span><br><span class="line">  <span class="type">int</span> numVertexes, numEdges;<span class="comment">// 图中当前的顶点数和边数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><p>无向网图的创建代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立无向网图的邻接矩阵表示</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateMGraph</span><span class="params">(MGraph *G)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j, k, w;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输入顶点数和边数:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d, %d&quot;</span>, &amp;G -&gt; numVertexes, &amp;G -&gt; numEdges);<span class="comment">// 输入顶点数和边数</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G -&gt; numVertexes; i++)<span class="comment">// 读入顶点信息，建立顶点表</span></span><br><span class="line">    <span class="built_in">scanf</span>(&amp;G -&gt; vexs[i]);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G -&gt; numVertexes; i++)</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G -&gt; numVertexes; j++)</span><br><span class="line">      G -&gt; arc[i][j] = INFINITY;<span class="comment">// 邻接矩阵初始化</span></span><br><span class="line">  <span class="keyword">for</span>(k = <span class="number">0</span>; k -&gt; numEdges; k++) &#123;<span class="comment">// 读入 numEdges条边，建立邻接矩阵</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入边 (vi, vj) 上的下标 i，下标 j 和权 w: \n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d, %d, %d&quot;</span>, &amp;i, &amp;j, &amp;w);<span class="comment">// 输入边 (vi, vj) 上的权 w</span></span><br><span class="line">    G -&gt; arc[i][j] = w;</span><br><span class="line">    G -&gt; arc[i][j] = G -&gt; arc[i][j];<span class="comment">// 因为是无向图，矩阵对称</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中也可以得到，n 个顶点和 e 条边的无向网图的创建，时间复杂度为 O(n + n<sup>2</sup> + e)，其中对邻接矩阵 Garc 的初始化耗费了 O(n<sup>2</sup>) 的时间。</p><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>邻接矩阵是不错的一种图存储结构，对于边数相对顶点较少的图，这种结构是存在对存储空间的极大浪费的。</p><p>**数组与链表相结合的存储方法称为邻接表 (Adjacency List)**。</p><p>邻接表的处理办法：</p><ol><li>图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元素还需要存储指向第一个令结点的指针，以便于查找该顶点的边信息。</li><li>图中每个顶点 v<sub>i</sub> 的所有令结点构成一个线性表，由于邻接点的个数不定，所以用单链表存储，无向图称为顶点 v<sub>i</sub> 的边表，有向图则称为顶点 v<sub>i</sub> 作为弧尾的出边表。</li></ol><p><img src="http://1.117.162.142:9000/blog/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="无向图的邻接表结构"></p><p>上图是一个无向图的邻接表结构。从图中知道，顶点表的各个结点由 data 和 firstedge 两个域表示，data 是数据域，存储顶点的信息，firstedge 是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。边表结点由 adjvex 和 next 两个域组成。adjvex 是临界点域，存储某顶点的临接点在顶点表中的下标，next 则存储指向边表中下一个结点的指针。比如 v<sub>1</sub> 顶点与 v<sub>0</sub>、v<sub>2</sub> 互为邻接点，则在 v<sub>1</sub> 的边表中，adjvex 分别为 v<sub>0</sub> 的 0 和 v<sub>2</sub> 的 2。</p><p>这样的结构，对于要获得图的相关信息也是很方便的。比如想要知道某个顶点的度，就去查找这个顶点的边表中结点的个数。若要判断顶点 v<sub>ℹ</sub> 到 v<sub>j</sub> 是否存在边，只需要测试顶点 v<sub>i</sub> 的边表中 adjvex 是否存在结点 v<sub>j</sub>的下标 j 就行了。若求顶点的所有邻接点，其实就是对此顶点的边表进行遍历，得到 adjvex 域对应的顶点就是邻接点。</p><p><img src="http://1.117.162.142:9000/blog/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E9%80%86%E9%82%BB%E6%8E%A5%E8%A1%A8.png" alt="有向图的逆邻接表"></p><p>若是有向图，邻接表结构是类似的，比如上图中第一幅图的邻接表就是第二幅图。但要注意的是有向图由于有方向，是以顶点为弧尾来存储边表的，这样很容易就可以得到每个顶点的出度。但也有时为了便于确定顶点的入度或以顶点为弧头的弧，可以建立<strong>一个有向图的逆邻接表，即对每个顶点 v<sub>1</sub> 都建立一个链接为 v<sub>i</sub> 为弧头的表</strong>。如上图的第三幅图。</p><p>此时很容易就可以算出某个顶点的入度和出度是多少，判断两顶点是否存在弧也很容易实现。</p><p>对于带权值的网图，可以在边表结点定义中再增加一个 weight 的数据域，存储权值信息即可。</p><p>结点定义的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;<span class="comment">// 顶点类型应由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;<span class="comment">// 边上的权值类型应由用户定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span><span class="comment">// 边表结点</span></span><br><span class="line">  <span class="type">int</span> adjvex;<span class="comment">// 临界点域，存储该顶点对应的下标</span></span><br><span class="line">  EdgeType weight;<span class="comment">// 用于存储权值，对于非网图可以不需要</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span><span class="comment">// 链域，指向下一个邻接点</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> &#123;</span><span class="comment">// 顶点表结点</span></span><br><span class="line">  VertexType data;<span class="comment">// 顶点域，存储顶点信息</span></span><br><span class="line">  EdgeNode *firstedge;<span class="comment">// 边表头指针</span></span><br><span class="line">&#125;VertexNode, AdjList[MAXVEX];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  AdjList adjList;</span><br><span class="line">  <span class="type">int</span> numVertexes, numEdges;<span class="comment">// 图中当前顶点数和边数</span></span><br><span class="line">&#125;GraphAdjList;</span><br></pre></td></tr></table></figure><p>无向图的邻接表创建代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立图的邻接表结构</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateALGraph</span><span class="params">(GraphAdjList *G)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j, k;</span><br><span class="line">  EdgeNode *e;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输入顶点数和边数:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;G -&gt; numVertexes, &amp;G -&gt; numEdges);<span class="comment">// 输入顶点数和边数</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G -&gt; numVertexes; i++) &#123;<span class="comment">// 读入顶点信息，建立顶点表</span></span><br><span class="line">    <span class="built_in">scanf</span>(&amp;G -&gt; adjList[i].data);<span class="comment">// 输入顶点信息</span></span><br><span class="line">    G -&gt; adjList[i].firstedge = <span class="literal">NULL</span>;<span class="comment">// 将边表置为空表</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G -&gt; numEdges; k++) &#123;<span class="comment">// 建立边表</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;输入边（vi, vj) 上的顶点序号: \n&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d, %d&quot;</span>, &amp;i, &amp;j);<span class="comment">// 输入边 (vi, vj) 上的顶点序号</span></span><br><span class="line">  e = (EdgeNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));<span class="comment">// 向内存中申请空间，生成边表结点</span></span><br><span class="line">  e -&gt; adjvex = j;<span class="comment">// 邻接序号为 j</span></span><br><span class="line">  e -&gt; next = G -&gt; adjList[i].firstedge = e;<span class="comment">// 将 e 指针指向当前顶点指向的结点</span></span><br><span class="line">  G -&gt; adjList[i].firstedge = e;<span class="comment">// 将当前顶点的指针指向 e</span></span><br><span class="line">  e = (EdgeNode *)nalloc(<span class="keyword">sizeof</span>(EdgeNode));<span class="comment">// 向内存申请空间，生成边表结点</span></span><br><span class="line">  e -&gt; adjvex = i;<span class="comment">// 邻接序号为 i</span></span><br><span class="line">  e -&gt; next = G -&gt; adjList[j].firstedge;<span class="comment">// 将 e 指针指向当前顶点指向的结点</span></span><br><span class="line">  G -&gt; adjList[j].firstedge = e;<span class="comment">// 将当前顶点的指针指向 e</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>15 开始的代码是应用了在单链表创建中的头插法，由于对于无向图，一条边对应都是两个顶点，所以在循环中，一次就针对 i 和 j 分别进行了插入。本算法的时间复杂度，对于 n 个顶点 e 条边来说，很容易得出是 O(n+e)。</p><h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><p><strong>把邻接表与逆邻接表结合起来的存储方法叫做十字链表</strong>。</p><p>重新定义顶点表结点结构。</p><table><thead><tr><th align="center">data</th><th align="center">firstin</th><th align="center">firstout</th></tr></thead></table><p>其中 first 表示入边表头指针，指向该顶点的入边表中第一个结点，firstout 表示出边表头指针，指向该顶点的出边表中的第一个结点。</p><p>重新定义的边表结点结构。</p><table><thead><tr><th align="center">tailvex</th><th align="center">headvex</th><th align="center">headlink</th><th align="center">taillink</th></tr></thead></table><p>其中 tailvex 是指起点在顶点表的下标，headvex 是指弧终点在顶点表中的下标，headlink 是指入边表指针域，指向终点相同的下一条边，taillink 是指边表指针域，指向起点相同的下一条边。如果是网，还可以再增加一个 weight 域来存储权值。</p><p><img src="http://1.117.162.142:9000/blog/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8.png" alt="十字链表"></p><p>上图顶点依然是存入一个一位数组 {v<sub>0</sub>, v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>}，实线箭头指针的图示完全与之前的邻接表相同。就以顶点 v<sub>0</sub> 来说，firstout 指向的是出边表中的第一个结点 v<sub>3</sub>。所以 v<sub>0</sub> 边表结点的 headvex &#x3D; 3，而 tailvex 其实就是当前顶点 v<sub>0</sub> 的下标 0，由于 v<sub>0</sub> 只有一个出边顶点，所以 headlink 和 taillink 都是空。</p><p>图中虚线箭头的含义，它其实就是此图的逆邻接表的表示。对于 v<sub>0</sub> 来说，它有两个顶点 v<sub>1</sub> 和 v<sub>2</sub> 的入边。因此 v<sub>0</sub> 的 firstin 指向顶点 v<sub>1</sub> 的边表结点中 headvex 为 0 的结点，如图中的 ①。接着由入边结点的 headlink 指向下一个入边顶点 v<sub>2</sub>，如图中的 ②。对于顶点 v<sub>1</sub>，它有一个入边顶点 v<sub>2</sub>，所以它的 firstin 指向顶点 v<sub>2</sub> 的边表结点中 headvex 为 1 的结点，如图中的 ③。顶点 v<sub>2</sub> 和 v<sub>3</sub> 也是同样有一个入边顶点，如图中 ④ 和 ⑤。</p><p>十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以 v<sub>i</sub> 为尾的弧，也容易找到以 v<sub>i</sub> 为头的弧，因而容易求得顶点的出度和入度。而且它除了结构复杂一点外，其实创建图算法的时间复杂度和邻接表相同，因此，在有向图的应用中，十字链表是非常好的数据结构模型。</p><h4 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h4><p><img src="http://1.117.162.142:9000/blog/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A81.png" alt="邻接多重表"></p><p>若要删除左图的 (v<sub>0</sub>, v<sub>2</sub>) 这条边，需要对邻接表结构中右边表的阴影两个结点进行删除操作，显然这是比较繁琐的。所以仿照十字链表的方式，对边表结点的结构进行一些改造，也许就可以避免刚才提到的问题。</p><p>重新定义的边表结点结构：</p><table><thead><tr><th align="center">ivex</th><th align="center">ilink</th><th align="center">jvex</th><th align="center">jlink</th></tr></thead></table><p>其中 <strong>ivex 和 jvex 是与某条边依附的两个顶点表中下标。ilink 指向依附顶点 ivex 的下一条边，jlink 指向依附顶点 jvex 的下一条边。这就是邻接多重表结构</strong>。</p><p><img src="http://1.117.162.142:9000/blog/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A82.png" alt="邻接多重表"></p><p>左图中有 4 个顶点和 5 条边，显然，应该先将 4 个顶点和 5 条边的边表结点画出来。由于是无向图，所以 ivex 是 0、jvex 是1 还是反过来都是无所谓的，不过为了绘图方便，都将 ivex 值设置得与一旁的顶点下标相同。</p><p><img src="http://1.117.162.142:9000/blog/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A83.png" alt="邻接多重表"></p><p>首先连线的 ①②③④ 就是将顶点的 firstedge 指向一条边，顶点下标要与 ivex 的值相同，这很好理解。接着，由于顶点 v<sub>0</sub> 的 (v<sub>0</sub>, v<sub>1</sub>) 边的邻边有 (v<sub>0</sub>, v<sub>3</sub>) 和 (v<sub>0</sub>, v<sub>2</sub>)。因此 ⑤⑥ 的连线就是满足指向下一条依附于顶点 v<sub>0</sub> 的边的目标，注意 ilink 指向的结点的 jvex 一定要和它本身的 ivex 的值相同。同样的道理，连线 ⑦ 就是指 (v<sub>1</sub>, v<sub>0</sub>) 这条边，它是相当于顶点 v<sub>1</sub> 指向 (v<sub>1</sub>, v<sub>2</sub>) 边后的下一条。v<sub>2</sub> 有三条边依附，所以在 ③ 之后就有了 ⑧⑨。连线 ⑩ 的就是顶点 v<sub>3</sub> 在连线 ④ 之后的下一条边。左图一共有 5 条边，所以右图有 10 条连线，完全符合预期。</p><p>邻接多重边与邻接表的差别，仅仅是在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。这样对边的操作就方便多了，若要删除左图的 (v<sub>0</sub>, v<sub>2</sub>) 这条边，只需要将右图的 ⑥⑨ 的链接指向改为 ^ 即可。</p><h4 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h4><p><strong>边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标 (begin)、终点下标 (end) 和权 (weight) 组成</strong>。显然边集数组关注的是边的集合，在边集数组中要查找一个顶点的度需要扫描整个边数组，效率并不高。因此它更适合对边依次进行处理的操作，而不适合对顶点相关的操作。</p><p><img src="http://1.117.162.142:9000/blog/%E8%BE%B9%E9%9B%86%E6%95%B0%E7%BB%84.png" alt="边集数组"></p><p>定义的边数组结构如表</p><table><thead><tr><th align="center">begin</th><th align="center">end</th><th align="center">weight</th></tr></thead></table><p>其中 begin 是存储起点下标，end 是存储终点下标，weight 是存储权值。</p><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>图的遍历和树的遍历类似，**从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历 (Traversing Graph)**。</p><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p><strong>深度优先遍历 (Depth_First_Search)，也有称为深度优先搜索，简称 DFS</strong>。深度优先遍历其实就是一个递归的过程，其实就像一棵树的前序遍历。<strong>它从图中某个顶点 v 出发，访问此顶点，然后从 v 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 v 有路径相通的顶点都被访问到</strong>。事实上，这是连通图，对于非连通图，只需要对它的连通分量分别进行深度优先遍历，即在先前一个顶点进行一次深度优先遍历后，<strong>若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点做起始点，重复上述过程，直至图中所有顶点都被访问到为止</strong>。</p><p>邻接矩阵方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Boolean;<span class="comment">// Boolean 是布尔类型，其值是 TRUE 或 FALSE</span></span><br><span class="line">Boolean visited[MAX];<span class="comment">// 访问标志的数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(MGraph G, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  visited[i] = TRUE;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G.vexs[i]);<span class="comment">// 打印顶点，也可以其它操作</span></span><br><span class="line">  <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.numVertexes; j++) </span><br><span class="line">    <span class="keyword">if</span>(G.arc[i][j] == <span class="number">1</span> &amp;&amp; !visited[j])</span><br><span class="line">      DFS(G, j);<span class="comment">// 对未访问的邻接顶点递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 邻接矩阵的深度遍历操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(MGraph G)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++)</span><br><span class="line">    visited[i] = FALSE;<span class="comment">// 初始所有顶点状态都是未访问过状态</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++)</span><br><span class="line">    <span class="keyword">if</span>(!visited[i])<span class="comment">// 对未访问过的顶点调用 DFS， 若是连通图，只会执行一次</span></span><br><span class="line">      DFS(G, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果图结构是邻接表结构，其 DFSTraverse 函数的代码是几乎相同的，只是在递归函数中因为将数组换成了链表而有不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接表的深度优先递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphAdjList GL, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  EdgeNode *p;</span><br><span class="line">  visited[i] = TRUE;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, GL -&gt; adjList[i].data);<span class="comment">// 打印顶点，也可以其它操作</span></span><br><span class="line">  p = GL -&gt; adjList[i].firstedge;</span><br><span class="line">  <span class="keyword">while</span>(p) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[p -&gt; adjvex])</span><br><span class="line">      DFS(GL, p -&gt; adjvex);<span class="comment">// 对未访问的邻接点递归调用</span></span><br><span class="line">    p = p -&gt; next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 邻接表的深度遍历操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(GraphAdjList GL)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL -&gt; numVertexes; i++) </span><br><span class="line">    visited[i] = FALSE;<span class="comment">// 初始所有顶点状态都是未访问过状态</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL -&gt; numVertexes; i++)  </span><br><span class="line">    <span class="keyword">if</span>(!visited[i])<span class="comment">// 对未访问过的顶点调用 DFS，若是连通图，只会执行一次</span></span><br><span class="line">    DFS(GL, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比两个不同存储结构的深度优先遍历算法，对于 n 个顶点 e 条边的图来说，邻接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此都需要 O(n<sup>2</sup>) 的时间。而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是 O(n + e)。显然对于点多少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。</p><p>对于有向图而言，由于它只是对通道存在可行或不可行，算法上没有变化，是完全可以通用的。</p><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p><strong>广度优先遍历 (Breadth_First_Search)，又称为广度优先搜索，简称 BFS</strong>。</p><p>如果说图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似于树的层序遍历了。将下图的第一幅图稍微变形，变形原则是顶点 A 放置在最上第一层，让与它有边的顶点 B、F 为第二层，再让与 B 和 F 有边的顶点 C、I、G、E 为第三层，再将这四个顶点有边的 D、H 放在第四层，如第二幅图所示。此时在视觉上感觉图的形状发生了变化，其实顶点和边的关系是完全相同的。</p><p><img src="http://1.117.162.142:9000/blog/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.png" alt="广度优先遍历"></p><p>邻接矩阵结构的广度优先遍历算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵的广度遍历算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(MGraph G)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  Queue Q ;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++) </span><br><span class="line">    visited[i] = FALSE;</span><br><span class="line">  InitQueue(&amp;Q);<span class="comment">// 初始化一辅助用的队列</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++) &#123;<span class="comment">// 对每一个顶点做循环</span></span><br><span class="line">    <span class="keyword">if</span>(!visited[i]) &#123;<span class="comment">// 若是未访问过就处理</span></span><br><span class="line">      visited[i] = TRUE;<span class="comment">// 设置当前顶点访问过</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G.vexs[i]);<span class="comment">// 打印顶点，也可以其它操作</span></span><br><span class="line">      EnQueue(&amp;Q, i);<span class="comment">// 将此顶点如队列</span></span><br><span class="line">      <span class="keyword">while</span>(!QueueEmpty(Q)) &#123;<span class="comment">// 若当前队列不为空</span></span><br><span class="line">        DeQueue(&amp;Q, &amp;i);<span class="comment">// 将队中元素出队列，赋值给 i</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.numVertexes;j++) &#123;</span><br><span class="line">          <span class="comment">// 判断其他顶点若与当前顶点存在边且未访问过</span></span><br><span class="line">          <span class="keyword">if</span>(G.arc[i][j] == <span class="number">1</span> ** !visited[j]) &#123;</span><br><span class="line">            visited[j] = TRUE;<span class="comment">// 将找到的此顶点标记为已访问</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, G.vexs[j]);<span class="comment">// 打印顶点</span></span><br><span class="line">            EnQueue(&amp;Q, j);<span class="comment">// 将找到的此顶点入队列</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于邻接表的广度优先遍历，代码与邻接矩阵差异不大。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接表的广度遍历算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(GraphAdjList GL)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  EdgeNode *p;</span><br><span class="line">  Queue Q;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL -&gt; numVertexes; i++)</span><br><span class="line">    visited[i] = FALSE;</span><br><span class="line">  InitQueue(&amp;Q);</span><br><span class="line">  <span class="keyword">for</span>(i= <span class="number">0</span>; i &lt; GL -&gt; numVertexes; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">      visited[i] = TRUE;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, GL -&gt; adjList[i].data);<span class="comment">// 打印顶点，也可以其它操作</span></span><br><span class="line">      EnQueue(&amp;Q, i);</span><br><span class="line">      <span class="keyword">while</span>(!QueueEmpty(Q)) &#123;</span><br><span class="line">        DeQueue(&amp;Q, &amp;i);</span><br><span class="line">        p = GL -&gt; adjList[i].firstedge;<span class="comment">// 找到当前顶点边表链表头指针</span></span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">          <span class="keyword">if</span>(!visited[p -&gt; adjvex]) &#123;<span class="comment">// 若此顶点未被访问</span></span><br><span class="line">            visited[p -&gt; adjvex] = TRUE;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, GL - &gt; adjList[p -&gt; adjvex].data);</span><br><span class="line">            EnQueue(&amp;Q, p -&gt; adjvex);<span class="comment">// 将此顶点入队列</span></span><br><span class="line">          &#125;</span><br><span class="line">          p = p -&gt; next;<span class="comment">// 指针指向先一个邻接点</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比图的深度优先遍历与广度优先遍历算法，它们在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同。可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。不过如果图顶点和边非常多，不能在短时间内遍历完成，遍历的目的是为了寻找合适的顶点，那么选择哪种遍历就要仔细斟酌了。深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况。</p><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>**把构造连通网的最小代价生成树称为最小生成树 (Minimum Cost Spanning Tree)**。</p><h4 id="普里姆-Prim-算法"><a href="#普里姆-Prim-算法" class="headerlink" title="普里姆 (Prim) 算法"></a>普里姆 (Prim) 算法</h4><p><img src="http://1.117.162.142:9000/blog/Prim-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png" alt="Prim-邻接矩阵"></p><p>构造邻接矩阵，一个存储结构为 MGraph 的 G。G 有 9 个顶点，它的 arc 二维数组如右图所示。数组中的65535 用 ∞ 表示。</p><p>于是普里姆 (Prim) 算法代码如下，左侧数字为行号。其中 INFINITY 为权值极大值，不妨是 65535，MAXVEX 为顶点个数最大值，此处大于等于 9 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prim 算法生成最小生成树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MiniSpanTree_Prim</span><span class="params">(MGraph G)</span> &#123;</span><br><span class="line">  <span class="type">int</span> min, i, j, k;</span><br><span class="line">  <span class="type">int</span> adjvex[MAXVEX];<span class="comment">// 保存相关顶点下标</span></span><br><span class="line">  <span class="type">int</span> lowcost[MAXVEX];<span class="comment">// 保存相关顶点间边的权值</span></span><br><span class="line">  lowcost[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">// 初始化第一个权值为 0，即 v0加入生成树，lowcost 的值为 0，在这里就是此下标的顶点已经加入生成树</span></span><br><span class="line">  adjvex[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">// 初始化第一个顶点下标为 0 </span></span><br><span class="line">  <span class="keyword">for</span>(i = i; i &lt; G.numVertexes; i++) &#123;<span class="comment">// 循环除下标为 0 外的全部顶点</span></span><br><span class="line">    lowcost[i] = G.arc[<span class="number">0</span>][i];<span class="comment">// 将 v0 顶点与之有边的权值存入数组</span></span><br><span class="line">    adjvex[i] = <span class="number">0</span>;<span class="comment">// 初始化都为 v0 的下标</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; G.numVertexes; i++) &#123;</span><br><span class="line">    min = INFINITY;<span class="comment">// 初始化最小权值为 ∞，通常设置为不可能的大数字入 32767、65535 等</span></span><br><span class="line">    j = <span class="number">1</span>; k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; G.numVertexes) &#123;<span class="comment">// 循环全部顶点</span></span><br><span class="line">      <span class="keyword">if</span>(lowcost[j] != <span class="number">0</span> &amp;&amp; lowcost[j] &lt; min) &#123;<span class="comment">// 如果权值不为 0 且权值小于 min</span></span><br><span class="line">        min = lowcost[j];<span class="comment">// 则让当前权值称为最小值</span></span><br><span class="line">        k = j;<span class="comment">// 将当前最小值的下标存入 k</span></span><br><span class="line">      &#125;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)&quot;</span>, adjvex[k], k);<span class="comment">// 打印当前顶点边中权值最小边</span></span><br><span class="line">    lowcost[k] = <span class="number">0</span>;<span class="comment">// 将当前顶点的权值设置为 0，表示此顶点已经完成任务</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; G.numVertexes; j++) &#123;<span class="comment">// 循环所有顶点</span></span><br><span class="line">      <span class="keyword">if</span>(lowcost[j] != <span class="number">0</span> &amp;&amp; G.arc[k][j] &lt; lowcost[j]) &#123;<span class="comment">// 若下标为 k 顶点各边权值小于此前这些顶点未被加入生成树权值</span></span><br><span class="line">        lowcost[j] = G.arc[k][j];<span class="comment">// 将较小权值存入 lowcost</span></span><br><span class="line">        adjvex[j] = k;<span class="comment">// 将下标为 k 的顶点存入 adjvex</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>程序开始运行，由 4～5 行，创建了两个一维数组 lowcost 和 adjvex，长度都为顶点个数 9。</p></li><li><p>第 6～7 行分别给这两个数组的第一个下标位赋值为 0，arjvex[0] &#x3D; 0 其实意思就是现在从顶点 v<sub>0</sub> 开始 (事实上，最小生成树从哪个顶点开始计算都无所谓，假定从 v<sub>0</sub> 开始)，lowcost[0] &#x3D; 0 就表示 v<sub>0</sub> 已经被纳入到最小生成树中，之后凡是 lowcost 数组中的值被设置为 0 就是表示此下标的顶点被纳入最小生成树。</p></li><li><p>第 8～11 行表示读取右图邻接矩阵的第一行数据。将数值赋值给 lowcost 数组，所以此时 lowcost 数组值为{0, 10, 65535, 65535, 65535, 11,65535, 65535, 65535}，而 arjvex 则全部为 0。此时，我们已经完成了整个初始化的工作，准备开始生成。</p></li><li><p>第 12～31 行，整个循环过程就是构造最小生成树的过程。</p></li><li><p>第 13～14 行，将 min 设置为了一个极大值 65535，它的目的是为了之后找到一定范围内的最小权值。j 是用来做顶点下标循环的变量，k 是用来存储最小权值的顶点下标。</p></li><li><p>第 15～21行，循环中不断修改 min 为当前 lowcost 数组中最小值，并用 k 保留此最小值的顶点下标。经过循环后，min &#x3D; 10，k &#x3D; 1。 注意16行 if 判断的lowcost[j] !&#x3D; 0 表示已经是生成树的顶点不参与最小权值的查找。</p></li><li><p>第 22 行，因 k &#x3D; 1，adjvex[1] &#x3D; 0，所以打印结果为 (0, 1)，表示 v<sub>0</sub> 至 v<sub>1</sub> 边为最小生成树的第一条边。如下图</p><p> <img src="http://1.117.162.142:9000/blog/Prim-2.png" alt="Prim-2"></p></li><li><p>第 23 行，此时因 k &#x3D; 1 将 lowcost[k] &#x3D; 0 就是说顶点 v<sub>1</sub> 纳入到最小生成树中。此时 lowcost 数组值为 {0, 0, 65535, 65535, 65535, 11, 65535, 65535, 65535}。</p></li><li><p>第 24～30 行，j 循环由 1 至 8，因 k &#x3D; 1，查找邻接矩阵的第 v<sub>1</sub> 行的各个权值，与 lowcost 的对应值比较，若更小则修改 lowcost 值，并将 k 值存入 adjvex 数组中。因第 v<sub>1</sub> 行有 18、16、12 均比 65535 小，所以最终 lowcost 数组的值为：{0, 0, 18, 65535, 65535, 11, 16, 655365, 12}。adjvex 数组的值为：{0, 0, 1, 0, 0, 0, 1, 0, 1}。这里第 25 行 if 判断的 lowcost[j] !&#x3D; 0 也说明 v<sub>0</sub> 和 v<sub>1</sub> 已经是生成树的顶点不参与最小权值的比对了。</p></li><li><p>再次循环，由第 13～22 行，此时 min &#x3D; 11，k &#x3D; 5，adjvex[5] &#x3D; 0。因此打印结构为 (0, 5)。表示 v<sub>0</sub> 至 v<sub>5</sub> 边为最小生成树的第二条边，如下图所示。</p><p><img src="http://1.117.162.142:9000/blog/Prim-3.png" alt="Prim-3"></p></li><li><p>接下来执行到 31 行，lowcost 数组的值为：{0, 0, 18, 65535, 26, 0, 16, 65535, 12}。adjvex 数组的值为：{0, 0, 1, 0, 5, 0, 1, 0, 1}。</p></li><li><p>之后，通过不断的转换，构造的过程如下图所示。</p><p><img src="http://1.117.162.142:9000/blog/Prim-4.png" alt="Prim-4"></p></li></ol><p>普里姆 (Prim) 算法定义：假设 N &#x3D; (P, {E}) 是连通网，TE 是 N 上最小生成树中边的集合。算法从 U &#x3D; {u<sub>0</sub>} (u<sub>0</sub> ∈ V)，TE &#x3D; {} 开始。重复执行下述操作。在所有 u ∈ U，v ∈ V - U 的边(u, v) ∈ E 中找一条代价最小的边(u<sub>0</sub>, v<sub>0</sub>) 并入集合 TE，同时 v<sub>0</sub> 并入 U，直至 U &#x3D; V 为止。此时 TE 中必有 n - 1 条边，则 T &#x3D; (V, {TE}) 为 N 的最小生成树。</p><p>由算法代码中的循环嵌套可得知此算法的时间复杂度为 O(n<sup>2</sup>)。</p><h4 id="克鲁斯卡尔-Kruskal-算法"><a href="#克鲁斯卡尔-Kruskal-算法" class="headerlink" title="克鲁斯卡尔 (Kruskal) 算法"></a>克鲁斯卡尔 (Kruskal) 算法</h4><p>直接以边为目标去构建，因为权值是在边上，直接去找最小权值的边来构建生成树也是很自然的想法，只不过构建时要考虑是否会形成环流而已。此时就用到了图的存储结构中的边集数组结构。以下是 edge 边集数组结构的定义代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对边集数组 Edge 结构的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> begin;</span><br><span class="line">  <span class="type">int</span> end;</span><br><span class="line">  <span class="type">int</span> weight;</span><br><span class="line">&#125;Edge;</span><br></pre></td></tr></table></figure><p><img src="http://1.117.162.142:9000/blog/Kruskal-1.png" alt="Kruskal-1"></p><p>将在普里姆算法构建的邻接矩阵通过程序转化为上图的右图的边集数组，并且对它们安全值从小到大排序。</p><p>克鲁斯卡尔算法代码如下。其中 MAXEDGE 为边数量的极大值，此处大于等于 15 即可，MAXVEX 为顶点个数最大值，此处大于等于 9 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kruskal 算法生成最小生成树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MiniSpanTree_Kruskal</span><span class="params">(MGraph G)</span> &#123;<span class="comment">// 生成最小生成树</span></span><br><span class="line">  <span class="type">int</span> i, n, m;</span><br><span class="line">  Edge edges[MAXEDGE];<span class="comment">// 定义边集数组</span></span><br><span class="line">  <span class="type">int</span> parent[MAXVEX];<span class="comment">// 定义一数组用来判断边与边是否形成环路</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++) </span><br><span class="line">    parent[i] = <span class="number">0</span>;<span class="comment">// 初始化数组值为 0</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.numVertexes; i++) &#123;<span class="comment">// 循环每一条边</span></span><br><span class="line">    n = Find(parent, edges[i].begin);</span><br><span class="line">    m = Find(parent, edges[i].end);</span><br><span class="line">    <span class="keyword">if</span>(n != m) &#123;<span class="comment">// 假如 n 与 m 不等，说明此边没有与现有生成树形成环路</span></span><br><span class="line">      parent[n] = m;<span class="comment">// 将此边的结尾顶点放入下标为起点的 parent 中，表示此顶点已经在生成树集合中</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d) %d&quot;</span>, edges[i].begin, edges[i].end, edges[i].weight);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> *parent, <span class="type">int</span> f)</span> &#123;<span class="comment">// 查找连线顶点的尾部下标</span></span><br><span class="line">  <span class="keyword">while</span>(parent[f] &gt; <span class="number">0</span>)</span><br><span class="line">    f = parent[f];</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>程序开始运行，第 5 行之后，省略掉颇占篇幅但却很容易实现的将邻接矩阵转换为边集数组，并按权值从小到大排序的代码，也就是说，从第 5 行开始，已经有了结构为 edge，数据内容是上图有边的一维数组 edges。</p></li><li><p>第 5～7 行，生命一个数组 parent，并将它的值都初始化为 0。</p></li><li><p>第 8～15 行，开始对边集数组做循环遍历，开始时，i &#x3D; 0。</p></li><li><p>第 9 行，调用了第 17～21 行的函数 Find，传入的参数是数组 parent 和当前权值最小边 (v<sub>4</sub>, v<sub>7</sub>) 的 begin：4。因为 parent 中全都是 0 所以传出值使得 n &#x3D; 4。</p></li><li><p>第 10 行，传入 (v<sub>4</sub>, v<sub>7</sub>) 的 end：7。传出值使得 m &#x3D; 7。</p></li><li><p>第 11～14 行，很显然 n 与 m 不等，因此 parent[4] &#x3D; 7。此时 parent 数组值为 {0, 0, 0, 0, 7, 0, 0, 0, 0}，并且打印得到 “(4, 7) 7”。此时已经将边  (v<sub>4</sub>, v<sub>7</sub>) 纳入到最小生成树中。如下图。</p><p> <img src="http://1.117.162.142:9000/blog/Kruskal-2.png" alt="Kruskal-2"></p></li><li><p>循环返回，执行 9～14 行，此时 i &#x3D; 1，edge[1] 得到边 (v<sub>2</sub>, v<sub>8</sub>)，n &#x3D; 2，m &#x3D; 8，parent[2] &#x3D; 8，打印结果为 “(2, 8) 8”，此时 parent 数组值为 {0, 0, 8, 0, 7, 0, 0, 0, 0}，这也就表示边 (v<sub>4</sub>, v<sub>7</sub>) 和 边 (v<sub>2</sub>, v<sub>8</sub>) 已经纳入到最小生成树。如下图。</p><p> <img src="http://1.117.162.142:9000/blog/Kruskal-3.png" alt="Kruskal-3"></p></li><li><p>再次执行 9～14 行，此时 i &#x3D; 2，edge[2] 得到边 (v<sub>0</sub>, v<sub>1</sub>)，n &#x3D; 0，m &#x3D; 1，parent[0] &#x3D; 1，打印结果为 “(0, 1) 10”，此时 parent 数组值为 {1, 0, 8, 0, 7, 0, 0, 0, 0}，此时边 (v<sub>4</sub>, v<sub>7</sub>)、(v<sub>2</sub>, v<sub>8</sub>) 和 (v<sub>0</sub>, v<sub>1</sub>) 已经纳入到最小生成树，如图。</p><p> <img src="http://1.117.162.142:9000/blog/Kruskal-4.png" alt="Kruskal-4"></p></li><li><p>当 i &#x3D; 3、4、5、6 时，分别将边 (v<sub>0</sub>, v<sub>5</sub>)、(v<sub>1</sub>, v<sub>8</sub>)、(v<sub>3</sub>, v<sub>7</sub>) 和 (v<sub>1</sub>, v<sub>6</sub>) 纳入到最小生成树中。</p><p> <img src="http://1.117.162.142:9000/blog/Kruskal-5.png" alt="Kruskal-5"></p><p> 从上图的最右图 i &#x3D; 6 的粗线连线可以得到，其实是有两个连通的边集合 A 与 B 中纳入到最小生成树中的。如下图所示。当 parent[0] &#x3D; 1，表示 v<sub>0</sub> 和 v<sub>1</sub> 已经在生成树的边集合 A 中。此时将 parent[0] &#x3D; 1 的 1 改为下标，由 parent[1] &#x3D; 5, 表示 v<sub>1</sub> 和 v<sub>5</sub> 在边集合 A 中，parent[5] &#x3D; 8 表示 v<sub>5</sub> 与 v<sub>8</sub> 在边集合 A 中，parent[8] &#x3D; 6 表示 v<sub>8</sub> 与v<sub>6</sub> 在边集合 A 中，parent[6] &#x3D; 0 表示集合 A 暂时到头，此时边集合 A 有 v<sub>0</sub>、v<sub>1</sub>、v<sub>5</sub>、v<sub>8</sub>、v<sub>6</sub>。查看 parent 中没有查看的值，parent[2] &#x3D; 8 表示 v<sub>2</sub> 与v<sub>8</sub> 在一个集合中，因此 v<sub>2</sub> 也在边集合 A 中。再由 parent[3] &#x3D; 7、parent[4] &#x3D; 7 和 parent[7] &#x3D; 0 可知 v<sub>3</sub>、v<sub>4</sub>、v<sub>7</sub> 在另一个边集合 B 中。</p><p> <img src="http://1.117.162.142:9000/blog/Kruskal-6.png" alt="Kruskal-6"></p></li><li><p>当 i &#x3D; 7 时，第 10 行，调用 Find 函数，会传入参数 edges[7].begin &#x3D; 5。此时第 18 行，parent[5] &#x3D; 8 &gt; 0，所以 f &#x3D; 8，再循环得 parent[8] &#x3D; 6。因 parent[6] &#x3D; 0 所以 Find 返回后第 10 行得到 n &#x3D; 6.而此时第 11 行，传入参数 edges[7].end &#x3D; 6 得到 m &#x3D; 6。此时 n &#x3D; m，不再打印，继续下一循环。这就告诉我们，因为边 (v<sub>5</sub>, v<sub>6</sub>) 使得边集合 A 形成了环路。因此不能将它纳入到最小生成树中，如上图所示。</p></li><li><p>当 i &#x3D; 8 时，与上面相同，由于边 (v<sub>1</sub>, v<sub>2</sub>) 使得边集合 A 形成了环路。因此不能将它纳入到最小生成树中。</p></li><li><p>当 i &#x3D; 9 时，边 (v<sub>6</sub>, v<sub>7</sub>)，第 10 行得到 n &#x3D; 6，第 11 行得到 m &#x3D; 7，因此 parent[6] &#x3D; 7，打印 “(6, 7) 19”。此时 parent 数组值为 {1, 5, 8, 7, 7, 8, 7, 0, 6}，如下图。</p><p> <img src="http://1.117.162.142:9000/blog/Kruskal-7.png" alt="Kruskal-7"></p></li><li><p>此后边的循环均造成环路，最终最小生成树即为上图。</p></li></ol><p>克鲁斯卡尔 (Kruskal) 算法的定义：假设 N &#x3D; (V, {E}) 是连通图，则令最小生成树的初始状态为只有 n 个顶点而无边的非连通图 T &#x3D; {V, {}}，图中每个顶点自成一个连通分量。在 E 中选择代价最小的边，若该边依附的顶点落在 T 中不同的连通分量上，则将此边加入到 T 中，否则舍去此边而选择下一条代价最小的边。以此类推，直至 T 中所有顶点都在同一连通分量上为止。</p><p>此算法的 Find 函数由边数 e 决定，时间复杂度为 O(loge)，而外面有一个 for 循环 e 次。所以克鲁斯卡尔算法的时间复杂度为 O(eloge)。</p><p>对比两个算法，克鲁斯卡尔算法主要是针对边来展开，边数少时效率会非常高，所以对于稀疏图有很大优势；而普里姆算法对于稠密图，即边数非常多的情况会更好一些。</p><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>在网图和非网图中，最短路径的含义是不同的。由于非网图它没有边上的权值，所谓的最短路径，其实就是指两顶点之间经过的边数最少的路径；而<strong>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点</strong>。显然，研究网图更有实际意义，就地图来说，距离就是两顶点间的权值之和。而非网图完全可以理解为所有的边的权值都为 1 的网。</p><h4 id="迪杰斯特拉-Dijkstra-算法"><a href="#迪杰斯特拉-Dijkstra-算法" class="headerlink" title="迪杰斯特拉 (Dijkstra) 算法"></a>迪杰斯特拉 (Dijkstra) 算法</h4><p>这是一个按路径长度递增的次序产生最短路径的算法。它的思路大体是这样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVEX 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 65535</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Pathmatirx[MAXVEX];<span class="comment">// 用于存储最短路径下标的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ShortPathTable[MAXVEX];<span class="comment">// 用于存储到各点最短路径的权值和</span></span><br><span class="line"><span class="comment">// Dijkstra 算法，求有向网 G 的 v0 顶点到其余顶点 v 最短路径 P[v] 及带权长度 D[v], P[v] 的值为前驱顶点下标，D[v] 表示 v0 到 v 的最短路径长度和。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath_Dijkstra</span><span class="params">(MGraph G, <span class="type">int</span> v0, Pathmatirx *P, ShortPathTable *D)</span> &#123;</span><br><span class="line">  <span class="type">int</span> v, w, k, min;</span><br><span class="line">  <span class="type">int</span> final[MAXVEX];<span class="comment">// final[w] = 1 表示求得顶点 v0 至 vw 的最短路径</span></span><br><span class="line">  <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.numVertexes; v++) &#123;<span class="comment">// 初始化数据</span></span><br><span class="line">    final[v] = <span class="number">0</span>;<span class="comment">// 全部顶点初始化为未知最短路径状态</span></span><br><span class="line">    (*D)[v] = G.matirx[v0][v];<span class="comment">// 将与 v0 点有连线的顶点加上权值</span></span><br><span class="line">    (*P)[v] = <span class="number">0</span>;<span class="comment">// 初始化路径数组 p 为 0</span></span><br><span class="line">  &#125;</span><br><span class="line">  (*D)[v0] = <span class="number">0</span>;<span class="comment">// v0 至 v0 路径为 0</span></span><br><span class="line">  final[v0] = <span class="number">1</span>;<span class="comment">// v0 至 v0 不需要求路径</span></span><br><span class="line">  <span class="comment">// 开始主循环，每次求得 v0 到某个 v 顶点的最短路径</span></span><br><span class="line">  <span class="keyword">for</span>(v = <span class="number">1</span>; v &lt; G.numVertexes; v++) &#123;</span><br><span class="line">    min = INFINITY;<span class="comment">// 当前所知离 v0 顶点的最近距离</span></span><br><span class="line">    <span class="keyword">for</span>(w = <span class="number">0</span>;w &lt; G.numVertexes; w++) &#123;<span class="comment">// 寻找离 v0 最近的顶点</span></span><br><span class="line">      <span class="keyword">if</span>(!final[w] &amp;&amp; (*D)[w] &lt; min) &#123;</span><br><span class="line">        k = w;</span><br><span class="line">        min = (*D)[w];<span class="comment">// w 顶点离 v0 顶点更近</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    final[k] = <span class="number">1</span>;<span class="comment">// 将目前找到的最近的顶点位置为 1</span></span><br><span class="line">    <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.numVertexes; w++) &#123;<span class="comment">// 修正当前最短路径及距离</span></span><br><span class="line">      <span class="comment">// 如果经过 v 顶点的路径比现在这条路径的长度短的话</span></span><br><span class="line">      <span class="keyword">if</span>(!final[w] &amp;&amp; (min + G.matirx[k][w] &lt; (*D)[w])) &#123;</span><br><span class="line">        <span class="comment">// 说明找到了更短的路径，修改 D[w] 和 P[w]</span></span><br><span class="line">        (*D)[w] = min + G.matirx[k][w];<span class="comment">// 修改当前路径长度</span></span><br><span class="line">        (*P)[w] = k;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用此函数前，需要为下图中的左图准备邻接矩阵 MGraph 的 G，如右图，并且定义参数 v<sub>0</sub> 为 0。</p><p><img src="http://1.117.162.142:9000/blog/Dijkstra-1.png" alt="Dijkstra"></p><ol><li><p>程序开始运行，第 4 行final 数组是为了 v<sub>0</sub> 到某顶点是否已经求得最短路径的标记，如果 v<sub>0</sub> 到 v<sub>w</sub> 已经有结果，则 final[w] &#x3D; 1。</p></li><li><p>第 9～13 行，是在对数据进行初始化的工作。此时 final 数组值均为 0，表示所有的点都未求得最短路径。D 数组为 {65535, 1, 5, 65535, 65535, 65535, 65535, 65535, 65535}。因为 v<sub>0</sub> 到 v<sub>1</sub> 和 v<sub>2</sub> 的边权值为 1 和 5。P 数组全为0，表示目前没有路径。</p></li><li><p>第 14 行，表示 v<sub>0</sub> 到 v<sub>0</sub> 自身，权值和结果为 0。D 数组为 {0, 1, 5, 65535, 65535, 65535, 65535, 65535, 65535}。第 15 行，表示 v<sub>0</sub> 点算是已经求得最短路径，因此 final[0] &#x3D; 1。此时 final 数组为 {1, 0, 0, 0, 0, 0, 0, 0, 0}。此时整个初始化工作完成。</p></li><li><p>第 17～35 行，为主循环，每次循环求得 v<sub>0</sub> 与一个顶点的最短路径。因此 v 从 1 而不是 0 开始。</p></li><li><p>第 18～24 行，先令 min 为 65535 的极大值，通过 w 循环，与 D[w] 比较找到最小值 min &#x3D; 1, k &#x3D; 1。</p></li><li><p>第 25 行，由 k &#x3D; 1，表示与 v<sub>0</sub> 最近的顶点是 v<sub>1</sub>，并且由 D[1] &#x3D; 1，知道此时 v<sub>0</sub> 到 v<sub>1</sub> 的最短距离是 1。因此将 v<sub>1</sub> 对应的 final[1] 设置为 1。此时 final 数组为 {1, 1, 0, 0, 0, 0, 0, 0, 0}。</p></li><li><p>第 26～34 行是一循环，此循环甚为关键。它的目的是在刚才已经找到 v<sub>0</sub> 与 v<sub>1</sub> 的最短路径的基础上，对 v<sub>1</sub> 与其他顶点的边进行计算，得到 v<sub>0</sub> 与它们的当前最短距离，如下图。因为 min &#x3D; 1，所以本来 D[2] &#x3D; 5，现在 v<sub>0</sub> → v<sub>1</sub> → v<sub>2</sub> &#x3D; D[2] &#x3D; min + 3 &#x3D; 4，v<sub>0</sub> → v<sub>1</sub> → v<sub>3</sub> &#x3D; D[3] &#x3D; min + 7 &#x3D; 8，v<sub>0</sub> → v<sub>1</sub> → v<sub>4</sub> &#x3D; D[4] &#x3D; min + 5 &#x3D; 6，因此，D 数组当前值为 {0, 1, 4, 8, 6, 65535, 65535, 65535, 65535}。而 P[2] &#x3D; 1，P[3] &#x3D; 1，P[4] &#x3D; 1，它表示的意思是 v<sub>0</sub> 到 v<sub>2</sub>、v<sub>3</sub>、v<sub>4</sub> 点的最短路径它们的前驱均是 v<sub>1</sub>。此时 P 数组值为：{0, 0, 1, 1, 1, 0, 0, 0, 0}。</p><p> <img src="http://1.117.162.142:9000/blog/Dijkstra-2.png" alt="Dijkstra-2"></p></li><li><p>重新开始循环，此时 i &#x3D; 2。第 18～24 行，对 w 循环，注意因为 final[0] &#x3D; 1 和final[1] &#x3D; 1，由第 20 行的 !final[w] 可知，v<sub>0</sub> 与 v<sub>1</sub> 并不参与最小值的获取。通过循环比较，找到最小值 min &#x3D; 4，k &#x3D; 2。</p></li><li><p>第 25 行，由 k &#x3D; 2，表示已经求出 v<sub>0</sub> 与 v<sub>2</sub> 的最短路径，并且由 D[2] &#x3D; 4，知道最短距离是 4。因此将 v<sub>2</sub> 对应的 final[2] 设置为 1，此时 final 数组为：{1, 1, 1, 0, 0, 0, 0, 0, 0}。</p></li><li><p>第 26～34 行。在刚才已经找到 v<sub>0</sub> 与 v<sub>2</sub> 的最短路径的基础上，对 v<sub>2</sub> 与其它顶点的边，进行计算，得到 v<sub>0</sub> 与它们的当前最短距离，如下图。因为 min &#x3D; 4，所以本来 D[4] &#x3D; 6，现在 v<sub>0</sub> → v<sub>2</sub> → v<sub>4</sub> &#x3D; D[4] &#x3D; min + 1 &#x3D; 5，v<sub>0</sub> → v<sub>2</sub> → v<sub>5</sub> &#x3D; D[5] &#x3D; min + 7 &#x3D; 11，因此，D 数组当前值为：{0, 1, 3, 8, 5, 11, 65535, 65535, 65535}。而原本 P[4] &#x3D; 1，此时 P[4] &#x3D; 2，P[5] &#x3D; 2，它表示 v<sub>0</sub> 到 v<sub>4</sub>、v<sub>5</sub> 点的最短路径它们的前驱均是 v<sub>2</sub>。此时 P 数组值为：{0, 0, 1, 1, 2, 2, 0, 0, 0}。</p><p><img src="http://1.117.162.142:9000/blog/Dijkstra-3.png" alt="Dijkstra"></p></li><li><p>重新开始循环，此时 i &#x3D; 3。第 18～24 行，通过对 w 循环比较找到最小值 min &#x3D; 5， k &#x3D; 4。</p></li><li><p>第 25 行，由 k &#x3D; 4，表示已经求出 v<sub>0</sub> 到 v<sub>4</sub> 的最短路径，并且由 D[4] &#x3D; 5，知道最短距离是 5。因此将 v<sub>4</sub> 对应的 final[4] 设置为 1。此时 final 数组为：{1, 1, 1, 0, 1, 0, 0, 0, 0}。</p></li><li><p>第 26～24 行。对 v<sub>4</sub> 与其他顶点的边进行计算，得到 v<sub>0</sub> 与它们的当前最短距离，如下图所示。因为 min &#x3D; 5，所以本来 D[3] &#x3D; 8，现在 v<sub>0</sub> → v<sub>4</sub> → v<sub>3</sub> &#x3D; D[3] &#x3D; min + 2 &#x3D; 7，本来 D[5] &#x3D; 11，现在 v<sub>0</sub> → v<sub>4</sub> → v<sub>5</sub> &#x3D; D[5] &#x3D; min + 3 &#x3D; 8，另外 v<sub>0</sub> → v<sub>4</sub> → v<sub>6</sub> &#x3D; D[6] &#x3D; min + 6 &#x3D; 11，v<sub>0</sub> → v<sub>4</sub> → v<sub>7</sub> &#x3D; D[7] &#x3D; min + 9 &#x3D; 14，因此，D 数组当前值为：{0, 1, 4, 7, 5, 8, 11, 14, 65535}。而原本 P[3] &#x3D; 1，此时 P[3] &#x3D; 4，原本 P[5] &#x3D; 2，此时 P[5] &#x3D;  4，另外 P[6] &#x3D; 4，P[7] &#x3D; 4，它表示 v<sub>0</sub> 到 v<sub>3</sub>、v<sub>5</sub>、v<sub>6</sub>、v<sub>7</sub> 点的最短路径它们的前驱均是 v<sub>4</sub>。此时 P 数组值为：{0, 0, 1, 4, 2, 4, 4, 4, 0}。</p><p> <img src="http://1.117.162.142:9000/blog/Dijkstra-4.png" alt="Dijkstra"></p></li><li><p>之后的循环就完全类似了。得到最终的结果，如下图。此时 final 数组为：{1, 1, 1, 1, 1, 1, 1, 1, 1}，它表示所有的顶点均完成了最短路径的查找工作。此时D数组为：{0, 1, 4, 7, 5, 8, 10, 12, 16}，它表示 v<sub>0</sub> 到各个顶点的最短路径数，比如 D[8]-1+3+1+2+3+2+4 &#x3D; 16。此时的 P 数组为：{0, 0, 1, 4, 2, 4, 3, 6, 7}，这串数字可能略为难理解一些。比如 P[8] &#x3D; 7，它的意思是 v<sub>0</sub> 到 v<sub>8</sub> 的最短路径，顶点 v<sub>8</sub> 的前驱顶点是 v<sub>7</sub>，再由 P[7] &#x3D; 6 表示 v<sub>7</sub> 的前驱是 v<sub>6</sub>， P[6] &#x3D; 3，表示 v<sub>6</sub> 的前驱是 v<sub>3</sub>。这样就可以得到，v<sub>0</sub>到 v<sub>8</sub> 的最短路径为v<sub>8</sub> ← v<sub>7</sub> ← v<sub>6</sub> ← v<sub>3</sub> ← v<sub>4</sub> ← v<sub>2</sub> ← v<sub>1</sub> ← v<sub>0</sub>。</p><p> <img src="http://1.117.162.142:9000/blog/Dijkstra-5.png" alt="Dijkstra"></p></li></ol><p>其实最终返回的数组 D 和数组 P，是可以得到 v<sub>0</sub> 到任意一个顶点的最短路径和路径长度的。例如 v<sub>0</sub> 到 v<sub>8</sub> 的最短路径并没有经过 v<sub>5</sub>，但我们已经知道 v<sub>0</sub> 到 v<sub>5</sub> 的最短路径了。由 D[5] &#x3D; 8 可知它的路径长度为 8，由P[5] &#x3D; 4 可知 v<sub>5</sub> 的前驱顶点是 v<sub>4</sub>，所以 v<sub>0</sub> 到 v<sub>5</sub> 的最短路径是 v<sub>0</sub> → v<sub>1</sub> → v<sub>2</sub> → v<sub>4</sub> → v<sub>5</sub>。</p><p>也就是说，我们通过迪杰斯特拉（Dijkstra）算法解决了从某个源点到其余各顶点的最短路径问题。从循环嵌套可以很容易得到此算法的时间复杂度为 0(n<sup>2</sup>)，尽管有同学觉得，可不可以只找到从源点到某一个特定终点的最短路径，其实这个问题和求源点到其他所有顶点的最短路径一样复杂，时间复杂度依然是 0(n<sup>2</sup>)。</p><h4 id="佛洛依德-Floyd-算法"><a href="#佛洛依德-Floyd-算法" class="headerlink" title="佛洛依德 (Floyd) 算法"></a>佛洛依德 (Floyd) 算法</h4><p><img src="http://1.117.162.142:9000/blog/Floyd-1.png" alt="Floyd"></p><p>上图是一个最简单的 3 个顶点连通网图。先定义两个二维数组 D[3][3] 和 P[3][3]，D 代表顶点到顶点的最短路径权值和的矩阵。P 代表 对应顶点的最小路径的前驱矩阵。在未分析任何顶点之前，将 D 命名为 D<sup>-1</sup>，其实他就是初始的图的邻接矩阵。将 P 命名为 P<sup>-1</sup>，初始化为图中所示的矩阵。</p><p>首先，所有的顶点经过 v<sub>0</sub> 后到达另一顶点的最短路径。因为只有三个顶点，因此需要查看 v<sub>1</sub> → v<sub>0</sub> → v<sub>2</sub>， 得到 D<sup>-1</sup>[1][0] + D<sup>-1</sup>[0][2] &#x3D; 2 + 1 &#x3D; 3。D<sup>-1</sup>[1][2] 表示的是 v<sub>1</sub> → v<sub>2</sub> 的权值为 5，发现 D<sup>-1</sup>[1][2] &gt; D<sup>-1</sup>[1][0] + D<sup>-1</sup>[0][2]，通俗的话讲就是 v<sub>1</sub> → v<sub>0</sub> → v<sub>2</sub> 比直接 v<sub>1</sub> → v<sub>2</sub> 距离还要近。所以让 D-1[1][2] &#x3D; D<sup>-1</sup>[1][0] + D<sup>-1</sup>[0][2] &#x3D; 3，同样的 D<sup>-1</sup>[2][1] &#x3D; 3，于是就有了 D<sup>0</sup> 的矩阵。因为有变化，所以 P 矩阵对应的 P<sup>-1</sup>[1][2] 和 P<sup>-1</sup>[2][1] 也修改为当前中转的顶点 v<sub>0</sub> 的下标 0，于是就有了 P<sup>0</sup>。也就是说 D<sup>0</sup>[v][w] &#x3D; min{D<sup>-1</sup>[v][w], D<sup>-1</sup>[v][0] + D<sup>-1</sup>[0][w]}。</p><p>接下来，其实也就是在 D<sup>0</sup> 和 P<sup>0</sup> 的基础上继续处理所有顶点经过 v<sub>1</sub> 和 v<sub>2</sub> 后到达另一顶点的最短路径，得到 D<sup>1</sup> 和 P<sup>1</sup>，D<sup>2</sup> 和 P<sup>2</sup> 完成所有顶点到所有顶点的最短路径计算工作。</p><p><img src="http://1.117.162.142:9000/blog/Floyd-2.png" alt="Floyd"></p><p>首先针对上图的做网图准备两个矩阵 D<sup>-1</sup> 和 P<sup>-1</sup> ，D<sup>-1</sup> 就是网图的邻接矩阵，P<sup>-1</sup> 初设为 P[i][j] &#x3D; j 这样的矩阵，它主要用来存储路径。</p><p>求所有顶点到所有顶点的最短路径代码如下，Pathmatirx 和 ShortPathTable 都是二维数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Pathmatirx[MAXVEX][MAXVEX];</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ShortPathTable[MAXVEX][MAXVEX];</span><br><span class="line"><span class="comment">// Floyd 算法，求网图 G 中个顶点 v 到其余顶点 w 最短路径 P[v][w] 及带权长度 D[v][w]</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath_Floyd</span><span class="params">(MGraph G, Pathmatirx *P, ShortPathTable *D)</span> &#123;</span><br><span class="line">  <span class="type">int</span> v, w, k;</span><br><span class="line">  <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.numVertexes; ++v) &#123;</span><br><span class="line">    <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.numVertexes; ++w) &#123;</span><br><span class="line">      (*D)[v][w] = G.matirx[v][w];<span class="comment">// (*D)[v][w] 值即为对应点间的权值</span></span><br><span class="line">      (*P)[v][w] = w;<span class="comment">// 初始化 P</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.numVertexes; ++k) &#123;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>; v &lt; G.numVertexes; ++v) &#123;</span><br><span class="line">      <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.numVertexes; ++w) &#123;</span><br><span class="line">        <span class="keyword">if</span>((*D)[v][w] &gt; (*D)[v][k] + (*D)[k][w]) &#123;</span><br><span class="line">          <span class="comment">// 如果经过下标为 k 顶点路径比原来两点间路径更短，将当前两点间权值设为更小的一个</span></span><br><span class="line">          (*D)[v][w] &gt; (*D)[v][k] + (*D)[k][w];</span><br><span class="line">          (*P)[v][w] &gt; (*P)[v][k];<span class="comment">// 路径设置经过下标为 k 的顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>程序开始运行，第 6～11 行就是初始化了 D 和 P，使得它们称为上图的两个矩阵。从矩阵也得到，v<sub>0</sub> → v<sub>1</sub> 路径权值是 1，v<sub>0</sub> → v<sub>2</sub> 路径权值是 5，v<sub>0</sub> → v<sub>3</sub> 无边连线，所以路径权值为极大值 65535。</p></li><li><p>第 12～22 行，是算法的主循环，一共三层嵌套，k 代表的就是中转顶点的下标。v 代表起始顶点，w 代表结束顶点。</p></li><li><p>当 K &#x3D; 0 时，也就是所有的顶点都经过 v<sub>0</sub> 中转，计算是否有最短路径的变化。可惜结果是，没有任何变化，如下图。</p><p> <img src="http://1.117.162.142:9000/blog/Floyd-3.png" alt="Floyd"></p></li><li><p>当 K &#x3D; 1 时，也就是所有的顶点都经过 v<sub>1</sub> 中转。此时，当 v &#x3D; 0 时，原本D[0][2] &#x3D; 5，现在由于 D[0][1] + D[1][2] &#x3D; 4。因此由第 17 行代码，二者取其最小值，得到 D[0][2] &#x3D; 4，同理可得 D[0]p3] &#x3D; 8、D[0][4] &#x3D; 6，当 v &#x3D; 2、3、4 时，也修改了一些数据，如下左图虚线框数据。由于这些最小权值的修正，所以在路径矩阵 P 上，也要做处理，将它们都改为当前的 P[v][k] 值，如代码的 18 行。</p><p> <img src="http://1.117.162.142:9000/blog/Floyd-4.png" alt="Floyd"></p></li><li><p>接下来就是 k &#x3D; 2 一直到 8 结束，表示针对每个顶点做中转得到的计算结果，当然，D<sup>0</sup> 是以 D<sup>1</sup> 为基础，D<sup>1</sup> 是以 D<sup>0</sup> 为基础，……，D<sup>8</sup> 是以 D<sup>7</sup> 为基础。最终当 k &#x3D; 8 时，两矩阵数据如下图所示。</p><p> <img src="http://1.117.162.142:9000/blog/Floyd-5.png" alt="Floyd"></p></li></ol><p>​至此，最短路就算是完成了，可以看到矩阵第 v<sub>0</sub> 行的数值与迪杰斯特拉 (Dijkstra) 算法求得的 D 数组的数值是完全相同，都是 {0, 1, 4, 7, 5, 8, 10, 12, 16}。而且这里是所有顶点到所有顶点的最短路径权值和都可以计算出。</p><p>如何由 P 这个路径数组的出具体的最短路径？以 v<sub>0</sub> 到 v<sub>8</sub> 为例，从上图的右图第 v<sub>8</sub> 列，P[0][8] &#x3D; 1，得到要经过顶点 v<sub>1</sub>，然后将 1 取代 0 得到 P[1][8] &#x3D; 2，说明要经过 v<sub>2</sub>，然后将 2 取代 1 得到 P[2][8] &#x3D; 4，说明要经过 v<sub>4</sub>，然后将 4 取代 2 得到 P[4][8] &#x3D; 3，说明要经过 v<sub>3</sub>，……，这样很容易就推导出最终的最短路径值为 v<sub>0</sub> → v<sub>1</sub> → v<sub>2</sub> → v<sub>4</sub> → v<sub>3</sub> → v<sub>6</sub> → v<sub>7</sub> → v<sub>8</sub>。</p><p>求最短路径的显示代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(v = <span class="number">0</span>;v &lt; G.numVertexes; ++v) &#123;</span><br><span class="line">  <span class="keyword">for</span>(w = v + <span class="number">1</span>; w &lt; G.numVertexes; w++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;v%d-v%d weight: %d &quot;</span>, v, w, D[v][w]);</span><br><span class="line">    k = P[v][w];<span class="comment">// 获得第一个路径顶点下标</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; path: %d&quot;</span>, v);<span class="comment">// 打印源点</span></span><br><span class="line">    <span class="keyword">while</span>(k != w) &#123;<span class="comment">// 如果路径顶点下标不是终点</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot; -&gt; %d&quot;</span>, k);<span class="comment">// 打印路径顶点</span></span><br><span class="line">      k = P[k][w];<span class="comment">// 获得下一个路径顶点下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; -&gt; %d\n&quot;</span>, w);<span class="comment">// 打印终点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果面临需要求所有顶点致所有顶点的最短路径问题时，弗洛伊德 (Floyd) 算法应该是不错的选择。</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><h4 id="拓扑排序介绍"><a href="#拓扑排序介绍" class="headerlink" title="拓扑排序介绍"></a>拓扑排序介绍</h4><p>**在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为 AOV 网 (Activity On Vertex Network)**。AOV 网中的弧表示活动之间存在的某种制约关系。另外就是 AOV 网中不能存在回路。</p><p><strong>设 G &#x3D; (V, E) 是一个具有 n 个顶点的有向图，V 中的顶点序列 v<sub>1</sub>，v<sub>2</sub>，……，v<sub>n</sub>，满足若从顶点 v<sub>i</sub> 到 v<sub>j</sub> 有一条路径，则在顶点序列中顶点 v<sub>i</sub> 必在顶点 v<sub>j</sub> 之前。则称这样的顶点序列为一个拓扑序列</strong>。</p><p>所谓<strong>拓扑排序，其实就是对一个有向图构造拓扑序列的过程</strong>。构造时会有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环 (回路) 的 AOV 网；如果输出顶点数少了，哪怕是少了一个，也说明这个网存在环 (回路)，不是 AOV 网。</p><p>一个不存在回路的 AOV 网，可以将它应用在各种各样的工程或项目的流程图中，满足各种应用场景的需要，所以实现拓扑排序的算法就很有价值了。</p><h4 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h4><p>对 AOV 网进行拓扑排序的基本思路是：从 AOV 网中选择一个入度为。的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者 AOV 网中不存在入度为 0 的顶点为止。</p><p>首先我们需要确定一下这个图需要使用的数据结构。前面求最小生成树和最短路径时，我们用的都是邻接矩阵，但由于拓扑排序的过程中，需要删除顶点，显然用邻接表会更加方便。因此我们需要为 A0V 网建立一个邻接表。考虑到算法过程中始终要查找入度为 0 的顶点，我们在原来顶点表结点结构中，增加一个入度域 in，结构如下表所示，其中 in 就是入度的数字。</p><table><thead><tr><th align="center">in</th><th align="center">data</th><th align="center">firstedge</th></tr></thead></table><p><img src="http://1.117.162.142:9000/blog/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-1.png" alt="拓扑排序"></p><p>因此对于上图的 AOV 网，可以得到下图的邻接表数据结构。</p><p><img src="http://1.117.162.142:9000/blog/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-2.png" alt="拓扑排序"></p><p>在拓扑排序算法中，涉及的结构代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span><span class="comment">// 边表结点</span></span><br><span class="line">  <span class="type">int</span> adjvex;<span class="comment">// 邻接点域，存储该顶点对应的下标</span></span><br><span class="line">  <span class="type">int</span> weight;<span class="comment">// 用于存储权值，对于非网图可以不需要</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span><span class="comment">// 链域，指向下一个邻接点</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span> &#123;</span><span class="comment">// 顶点表结点</span></span><br><span class="line">  <span class="type">int</span> in;<span class="comment">// 顶点入度</span></span><br><span class="line">  <span class="type">int</span> data;<span class="comment">// 顶点域，存储顶点信息</span></span><br><span class="line">  EdgeNode *firstedge;<span class="comment">// 边表头指针</span></span><br><span class="line">&#125;VertexNode, AdjList[MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  AdjList adjList;</span><br><span class="line">  <span class="type">int</span> numVertexes, numEdges;<span class="comment">// 图中当前顶点数和边数</span></span><br><span class="line">&#125;graphAdjList, *GraphAdjList;</span><br></pre></td></tr></table></figure><p>在算法中，还需要辅助的数据结构——栈，用来存储处理过程中入度为 0 的顶点，木的是为了避免每个查找时都要去遍历顶点表找有没有入度为 0 的顶点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序，若 GL 无回路，则输出拓扑排序序列并返回 OK，若有回路返回 ERROR</span></span><br><span class="line">Status <span class="title function_">TopologicalSort</span><span class="params">(GraphAdjList GL)</span> &#123;</span><br><span class="line">  EdgeNode *e;</span><br><span class="line">  <span class="type">int</span> i, k, gettop;</span><br><span class="line">  <span class="type">int</span> top = <span class="number">0</span>;<span class="comment">// 用于栈指针下标</span></span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">// 用于统计输出顶点的个数</span></span><br><span class="line">  <span class="type">int</span> *<span class="built_in">stack</span>;<span class="comment">// 建栈存储入度为 0 的顶点</span></span><br><span class="line">  <span class="built_in">stack</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(GL -&gt; numVertexes * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL -&gt; numVertexes; i++)</span><br><span class="line">    <span class="keyword">if</span>(GL -&gt; adjList[i].in == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">stack</span>[++top] = i;<span class="comment">// 将入度为 0 的顶点入栈</span></span><br><span class="line">  <span class="keyword">while</span>(top != <span class="number">0</span>) &#123;</span><br><span class="line">    gettop = <span class="built_in">stack</span>[top--];<span class="comment">// 出栈</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, GL -&gt; adjList[gettop].data);<span class="comment">// 打印此顶点</span></span><br><span class="line">    count++;<span class="comment">// 统计输出顶点数</span></span><br><span class="line">    <span class="keyword">for</span>(e = GL -&gt; adjList[gettop].firstedge; e; e = e -&gt; next) &#123;<span class="comment">// 对此顶点弧表遍历</span></span><br><span class="line">      k = e -&gt; adjvex;</span><br><span class="line">      <span class="keyword">if</span>(!(--GL -&gt; adjList[k].in))<span class="comment">// 将 k 号顶点邻接点的入度减 1</span></span><br><span class="line">        <span class="built_in">stack</span>[++top] = k;<span class="comment">// 若为 0 则入栈，以便于下次循环输出</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(count &lt; GL -&gt; numVertexes)<span class="comment">// 如果 count 小于顶点数，说明存在环</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>程序开始运行，第 3～7 行都是变量的定义，其中 stack 是一个栈，用来存储整型的数字。</p></li><li><p>第 8～10 行，作了一个循环判断，把入度为 0 的顶点下标都入栈，如下右图邻接表可知，此时 stack 应该为：{0, 1, 3}，即 v<sub>0</sub>、v<sub>1</sub>、v<sub>3</sub> 的顶点入度为 0，如下图。</p><p> <img src="http://1.117.162.142:9000/blog/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-3.png" alt="拓扑排序"></p></li><li><p>第 12～21 行，while 循环，当栈中有数据元素时，始终循环。</p></li><li><p>第 13～15 行，v<sub>3</sub> 出栈得到 gettop &#x3D; 3。并打印此顶点，然后 count 加 1。</p></li><li><p>第 16～20 行，循环其实是对 v<sub>3</sub> 顶点对应的弧链表进行遍历，即下图中的灰色部分，找到 v<sub>3</sub> 连结的两个顶点 v<sub>2</sub> 和 v<sub>13</sub>，并将它们的入度减少一位，此时 v<sub>2</sub> 和 v<sub>13</sub> 的 in 值都为 1。它的目的是为了将 v<sub>3</sub> 顶点上的弧删除。</p><p> <img src="http://1.117.162.142:9000/blog/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-4.png" alt="拓扑排序"></p></li><li><p>再次循环，第 12～21 行。此时处理的是顶点 v<sub>1</sub>。经过出栈、打印、count &#x3D; 2 后，我们对 v<sub>1</sub> 到 v<sub>2</sub>、v<sub>4</sub>、v<sub>8</sub> 的弧进行了遍历。并同样减少了它们的入度数，此时， v<sub>2</sub> 入度为 0，于是由第 18～19 行知，v<sub>2</sub> 入栈，如下图所示。试想，如果没有在顶点表中加入 in 这个入度数据域，18 行的判断就必须要是循环，这显然是要消耗时间的，利用空间换取了时间。</p><p> <img src="http://1.117.162.142:9000/blog/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-5.png" alt="拓扑排序"></p></li><li><p>接下来就是同样的处理方式了。下图展示了 v<sub>2</sub>、v<sub>6</sub>、v<sub>5</sub>、v<sub>8</sub> 的打印删除过程，后面还剩几个顶点都类似。</p><p> <img src="http://1.117.162.142:9000/blog/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-6.png" alt="拓扑排序">   <img src="/../.vuepress/public/dsa/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-7.png" alt="拓扑排序"></p></li><li><p>最终拓扑排序打印结果为 3 -&gt; 1 -&gt; 2 -&gt; 6-&gt; 0 -&gt; 4 -&gt; 5 -&gt; 8 -&gt; 7 -&gt; 12 -&gt; 9 -&gt; 10 -&gt; 13 -&gt; 11。当然这结果并不是唯一的一种拓扑排序方案。</p></li></ol><p>分析整个算法，对一个具有 n 个顶点 e 条弧的 AOV 网来说，第 8～10 行扫描顶点表，将入度为 0 的顶点入栈的时间复杂度为 O(n)，而之后的 while 循环中，每个顶点进一次栈，出一次栈，入度减 1 的操作共执行了 e 次，所以整个算法的时间复杂度为 O(n + e)。</p><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>**在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，称之为 AOE 网 (Acticity On Edge Network)**。把 AOE 网中没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点。由于一个工程，总有一个开始，一个结束，所以正常情况下，AOE 网只有一个源点一个汇点。</p><p>AOE 网时表示工程流程的，所以它就具有明显的工程的特性。如有在某顶点所代表的事件发生后，从该顶点出发的各活动才能开始。只有在进入某点的各活动都已结束，该顶点代表的事件才能发生。</p><p>尽管 AOE 网与 AOV 网都是用来对工程建模的，但他们还是有很大的不同，主要体现在 AOV 网是顶点表示活动的网，他只描述活动之际拿的制约关系，而 AOE 网是用边表示活动的网，边上的权值表示活动持续的时间。</p><p><strong>路径上各个活动所持续的时间之河称为路径长度，从源点到汇点具有最大长度的路径叫关键路径，在关键路径上的活动叫关键活动</strong>。</p><h4 id="关键路径算法原理"><a href="#关键路径算法原理" class="headerlink" title="关键路径算法原理"></a>关键路径算法原理</h4><p>定义如下几个参数：</p><ol><li>时间的最早发生时间 etv (earliest time of vertex)：即顶点 v<sub>k</sub> 的最早发生时间。</li><li>时间的最晚发生时间 ltv (latest time of vertex)：即顶点 v<sub>k</sub> 的最晚发生时间。也就是每个顶点对应的事件最晚需要开始的时间，超出此事件将会延误整个工期。</li><li>活动的最早开工时间 ete (earliest time of edge)：即弧 a<sub>k</sub> 的最早发生时间。</li><li>活动的最晚开工时间 lte (latest time of edge)：即弧 a<sub>k</sub> 的最晚发生时间，也就是不推迟工期的最晚开工时间。</li></ol><p>由 1 和 2 可以求得 3 和 4，然后再根据 ete[k] 是否与 lte[k] 相等来判断 a<sub>k</sub> 是否是关键活动。</p><h4 id="关键路径算法"><a href="#关键路径算法" class="headerlink" title="关键路径算法"></a>关键路径算法</h4><p>将下图的 AOE 网转化为邻接表结构，注意与拓扑排序时邻接表结构不同的地方在于，这里弧链表增加了 weight 域，用来存储弧的权值。</p><p><img src="http://1.117.162.142:9000/blog/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-1.png" alt="关键路径算法"></p><p>求事件的最早发生时间 etv 的过程，就是从头至尾找拓扑序列的过程，因此，在求关键路径之前，需要先调用一次拓扑序列算法的代码来计算 etv 和拓扑序列列表。为此，在程序开始处声明几个全局变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *etv, *ltv;<span class="comment">// 事件最早发生时间和最迟发生时间数组</span></span><br><span class="line"><span class="type">int</span> *stack2;<span class="comment">// 用于存储拓扑序列的栈</span></span><br><span class="line"><span class="type">int</span> top2;<span class="comment">// 用于 stack2 的指针</span></span><br></pre></td></tr></table></figure><p>其中 stack2 用来存储拓扑序列，以便后面求关键路径时使用。</p><p>改进过的求拓扑序列算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序，用于关键路径计算</span></span><br><span class="line">Status <span class="title function_">TopologicalSort</span><span class="params">(GraphAdjList GL)</span> &#123;</span><br><span class="line">  EdgeNode *e;</span><br><span class="line">  <span class="type">int</span> i, k, gettop;</span><br><span class="line">  <span class="type">int</span> top = <span class="number">0</span>;<span class="comment">// 用于栈指针下标</span></span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;<span class="comment">// 用于统计输出顶点的个数</span></span><br><span class="line">  <span class="type">int</span> *<span class="built_in">stack</span>;<span class="comment">// 建栈将入度为 0 的顶点入栈</span></span><br><span class="line">  <span class="built_in">stack</span> = (<span class="type">int</span> *)<span class="built_in">malloc</span>(GL -&gt; numVertexes * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; GL -&gt; adjList[i].in)</span><br><span class="line">    <span class="built_in">stack</span>[++top] = i;</span><br><span class="line">  top2 = <span class="number">0</span>;<span class="comment">// 初始化为 0</span></span><br><span class="line">  etv = (<span class="type">int</span> *)<span class="built_in">malloc</span>(GL -&gt; numVertexes * <span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">// 事件最早发生时间</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; GL -&gt; numVertexes; i++)</span><br><span class="line">    etv[i] = <span class="number">0</span>;<span class="comment">// 初始化为 0</span></span><br><span class="line">  stack2 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(GL -&gt; numVertexes * <span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">// 初始化</span></span><br><span class="line">  <span class="keyword">while</span>(top != <span class="number">0</span>) &#123;</span><br><span class="line">    gettop = <span class="built_in">stack</span>[top--];</span><br><span class="line">    count++;</span><br><span class="line">    stack2[++top2] = gettop;<span class="comment">// 将弹出的顶点序号压入拓扑序列的栈</span></span><br><span class="line">    <span class="keyword">for</span>(e = GL -&gt; adkList[gettop].firstedge; e; e = e -&gt; next) &#123;</span><br><span class="line">      k = e -&gt; adjvex;</span><br><span class="line">      <span class="keyword">if</span>(!(--GL -&gt; adjList[k].in))</span><br><span class="line">        <span class="built_in">stack</span>[++top] = k;</span><br><span class="line">      <span class="keyword">if</span>((etv[gettop] + e -&gt; weigth) &gt; etv[k])<span class="comment">// 求各顶点事件最早发生时间值</span></span><br><span class="line">        etv[k] = etv[gettop] + e -&gt; weight;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(count &lt; GL -&gt; numVertexes)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 10～14 行为初始化全局变量 etv 数组、top2 和 stack2 的过程。第 19 行就是将本是要输出的拓扑序列压入全局栈 stack2 中。第 24～25 行很关键，它是求 etv 数组的每一个元素的值。比如，加入已经求得顶点 v<sub>0</sub> 对应的 etv[0] &#x3D; 0，顶点 v<sub>1</sub> 对应的 etv[1] &#x3D; 3，顶点 v<sub>2</sub> 对应的 etv[2] &#x3D; 4，现在我们需要求顶点 v<sub>3</sub> 对应的 etv[3]，其实就是求 etv[1] + len&lt;v<sub>1</sub>, v<sub>3</sub>&gt; 与 etv[2] + len&lt;v<sub>2</sub>, v<sub>3</sub>&gt; 的较大值。显然 3 + 5 &lt; 4 +8，得到 etv[3] &#x3D; 12，如下图。在代码中 e -&gt; weight 就是当前弧的长度。</p><p><img src="http://1.117.162.142:9000/blog/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-2.png" alt="关键路径算法"></p><p>由此得出计算顶点 v<sub>k</sub> 即求 etv[k] 的最早发生时间的公式是：</p><p>etc[k] &#x3D; 0, 当 k &#x3D; 0 时；</p><p>etc[k] &#x3D; max{etc[i] + len&lt;v<sub>i</sub>, v<sub>k</sub>&gt;}，当 k ≠ 0 且 &lt;v<sub>i</sub>, v<sub>k</sub>&gt; ∈ P[k] 时</p><p>其中 P[K] 表示所有到达顶点 v<sub>k</sub> 的弧的集合。</p><p>求关键路径的算法代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求关键路径，GL 为有向图，输出 GL 的各项关键活动</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CriticalPath</span><span class="params">(GraphAdjList GL)</span> &#123;</span><br><span class="line">  EdgeNode *e;</span><br><span class="line">  <span class="type">int</span> i, gettop, k, j;</span><br><span class="line">  <span class="type">int</span> ete, lte;<span class="comment">// 声明活动最早发生时间和最迟发生时间变量</span></span><br><span class="line">  TopologicalSort(GL);<span class="comment">// 求拓扑序列，计算数组 etv 和 stack2 的值</span></span><br><span class="line">  ltv = (<span class="type">int</span> *)<span class="built_in">malloc</span>(GL -&gt; numVertexes * <span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">// 事件最晚发生时间</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Gl -&gt; numVertexes; i++)</span><br><span class="line">    ltv[i] = tev[GL -&gt; numVertexes - <span class="number">1</span>];<span class="comment">// 初始化 ltv</span></span><br><span class="line">  <span class="keyword">while</span>(top2 != <span class="number">0</span>) &#123;<span class="comment">// 计算 ltv</span></span><br><span class="line">    gettop = stack2[top2--];<span class="comment">// 将拓扑序列出栈，后进先出</span></span><br><span class="line">    <span class="keyword">for</span>(e = GL -&gt; adjList[gettop].firstedge; e; e = e -&gt; next) &#123; <span class="comment">// 求各顶点事件的最迟发生时间 ltv 值</span></span><br><span class="line">      k = e -&gt; adjvex;</span><br><span class="line">      <span class="keyword">if</span>(ltv[k] - e -&gt; weight &lt; ltv[gettop])<span class="comment">// 求各顶点事件最晚发生时间 ltv</span></span><br><span class="line">        ltv[gettop] = ltv[k] - e -&gt; weight;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; Gl -&gt; numVertexes; j++) &#123;<span class="comment">// 求 ete，lte 和关键活动</span></span><br><span class="line">    <span class="keyword">for</span>(e = GL -&gt; adjList[j].firstedge; e; e = e -&gt; next) &#123;</span><br><span class="line">      k = e -&gt; adjvex;</span><br><span class="line">      ete = etv[j];<span class="comment">// 活动最早发生时间</span></span><br><span class="line">      lte = ltv[k] - e -&gt; weight;<span class="comment">// 活动最迟发生时间</span></span><br><span class="line">      <span class="keyword">if</span>(ete == lte)<span class="comment">// 两者相等即在关键路径上</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;v%d, v%d&gt; length: %d , &quot;</span>, GL - adjList[j].data, GL -&gt; adjList[k].data, e -&gt; weight);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>程序开始执行。第 5 行 声明了 ete 和 lte 两个活动最早最晚发生时间变量。</p></li><li><p>第 6 行，调用求拓扑序列的函数。执行完毕后，全局变量数组 etv 和 栈 stack 的值如下图所示，top2 &#x3D; 10。</p><p> <img src="http://1.117.162.142:9000/blog/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-3.png" alt="关键路径算法"></p></li><li><p>第 7～9 行为初始化全局变量 ltv 数组，因为 etv[9] &#x3D; 27，所以数组 ltv 当前的值为：{27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27}</p></li><li><p>∈第 10～17 行为 ltv 的循环。第 11 行，先讲 stack2 的栈头出栈，由后进先出得到 gettop &#x3D; 9。根据邻接表中，v<sub>9</sub> 没有弧表，所以 12～16 行循环体未执行。</p></li><li><p>再次来到 11 行，gettop &#x3D; 8，在第 12～16 行的循环中，v<sub>8</sub> 的弧表只有一条 &lt;v<sub>8</sub>, v<sub>9</sub>&gt;，第 13 行得到 k &#x3D; 9，因为 ltv[9] - 3 &lt; ltv[8]，所以 ltv[8] &#x3D; ltv[9] - 3 &#x3D; 24，如下图。</p><p> <img src="http://1.117.162.142:9000/blog/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-4.png" alt="关键路径算法"></p></li><li><p>再次循环，当 gettop &#x3D; 7、5、6 时，同理可算出 ltv 相对应的值为19、25、13，此时 ltv 值为：{27, 27, 27, 27, 27, 13, 25, 19, 24, 27}</p></li><li><p>当 gettop &#x3D; 4 时，由邻接表可得到 v<sub>4</sub> 有两条弧 &lt;v<sub>4</sub>, v<sub>6</sub>&gt;、&lt;v<sub>4</sub>, v<sub>7</sub>&gt;，通过第 12～16 行的循环，可以得到 ltv[4] &#x3D; min(ltv[7] - 4, ltv[6] - 9) &#x3D; min(19 - 4, 25 - 9) &#x3D; 15，如下图所示。</p><p> <img src="http://1.117.162.142:9000/blog/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-5.png" alt="关键路径算法"></p><p> 得出计算顶点 v<sub>k</sub> 即求 ltv[k] 的最晚发生的公式是：</p><p> ltv[k] &#x3D; etc[k]，当 k &#x3D; n - 1；</p><p> ltv[k] &#x3D; min{ltv[j] + len &lt; &lt;v<sub>k</sub>, v<sub>j</sub>&gt;}，当 k &lt; n - 1 且 &lt;v<sub>k</sub>, v<sub>j</sub>&gt; ∈ S[k] 时</p><p> 其中 S[K] 表示所有从顶点 v<sub>k</sub> 出发的弧的集合。</p></li><li><p>第 18～26 行是来求另两个变量活动最早开始事件 ete 和活动最晚开始事件 lte，并对相同下标的它们做比较。两重循环嵌套是对邻接表的顶点和每个顶点的弧表遍历。</p></li><li><p>当 j &#x3D; 0，从 v<sub>0</sub> 点开始，有 &lt;v<sub>0</sub>, v<sub>2</sub>&gt; 和 &lt;v<sub>0</sub>, v<sub>1</sub>&gt; 两条弧。当 k &#x3D; 2 时，ete &#x3D; etv[j] &#x3D; etv[0] &#x3D; 0。lte &#x3D; ltv[k] - e -&gt; weight &#x3D; ltv[2] -len &lt;v<sub>0</sub>, v<sub>2</sub>&gt; &#x3D; 4 - 4 &#x3D; 0，此时 ete &#x3D; lte，表示弧 &lt;v<sub>0</sub>, v<sub>2</sub>&gt; 是关键活动，因此打印。当 k &#x3D; 1时，ete &#x3D; etv[j] &#x3D; etv[0] &#x3D; 0。lte &#x3D; liv[k] -e -&gt; weight &#x3D; ltv[1] -len&lt;v<sub>0</sub>, v<sub>1</sub>&gt; &#x3D; 7 - 3 &#x3D; 4，此时 ete ≠ lte，因此 &lt;v<sub>0</sub>, v<sub>1</sub>&gt; 并不是关键活动，如下图。</p><p> <img src="http://1.117.162.142:9000/blog/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-6.png" alt="关键路径算法"></p></li><li><p>j &#x3D; 1 一直到 j &#x3D; 9 为止，做法是完全相同的，关键路径打印结果为 “&lt;v<sub>0</sub>, v<sub>2</sub>&gt; 4，&lt;v<sub>2</sub>, v<sub>3</sub>&gt; 8， &lt;v<sub>3</sub>, v<sub>4</sub>&gt; 3，&lt;v<sub>4</sub>, v<sub>7</sub>&gt; 4，&lt;v<sub>7</sub>, v<sub>8</sub>&gt; 5， &lt;v<sub>8</sub>, v<sub>9</sub>&gt; 3，”，最终关键路径如下图。</p><p><img src="http://1.117.162.142:9000/blog/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-7.png" alt="关键路径算法"></p></li></ol><p>分析整个求关键路径的算法，第 6 行诗 拓扑排序，时间复杂度为 O(n + e)，第 8～9 行时间复杂度为 O(n) ，第 10～17 行时间复杂度为 O(n + e)，第 18～ 26 行时间复杂度也为 O(n + e)，最终求关键路径算法的时间复杂度依然是 O(n + e)。</p><h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>图的存储结构一种阐述了 五种，其中比较重要的是邻接矩阵和邻接表，它们分别代表着边集是用数组还是链表的方式存储。十字链表是邻接矩阵的一种升级，而邻接多重表则是邻接表的升级。边集数组更多考虑的是对边的关注。用什么存储结构需要具体问题具体分析，通常稠密图，或读存数据较多，结构修改较少的图，用邻接矩阵要更合适，反之则应该考虑邻接表。</p><p>图的遍历分为深度和广度两种，各有优缺点。图的三种应用：最小生成树、最短路径和有向无环图的应用。</p><p>最小生成树，两种算法：普里姆 (Prim) 算法和克鲁斯卡尔 (Kruskal) 算法。普里姆算法像是走一步看一步的思维方式，逐步生成最小生成树。而克鲁斯卡尔算法则更有全局意识，直接从图中最短权值的边入手，找寻最后的答案。</p><p>最短路径的显示应用非常多。迪杰斯特拉 (Dijkstra) 算法更强调单源顶点查找路径的方式，比较符合我们正常的思路，容易理解原理，但算法代码相对复杂。而弗洛伊德 (Floyd) 算法则完全抛开了单点的局限思维方式，巧妙地应用矩阵的变换，用最清爽的代码实现了多顶点间最短路径求解的方案，原理理解有难度，但算法编写很简洁。</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="查找概论"><a href="#查找概论" class="headerlink" title="查找概论"></a>查找概论</h3><p><strong>查找表 (Search Table) 是由同一类型的数据元素 (或记录) 构成的集合。关键字 (Key) 是数据元素中某个数据项的值</strong>，又称为键值，用它可以标识一个数据元素。也可以标识一个记录的某个数据项 (字段)，称为关键码。**若此关键字可以唯一地标识一个记录，则称此关键字为主关键字 (Primary Key)<strong>。注意这也意味着，对不同的记录，其主关键字均不相同。主关键字所在的数据项称为主关键码。</strong>对于那些可以识别多个数据元素 (或记录) 的关键字，称为次关键字 (Secondary Key)。次关键字也可以理解为是不以唯一标识一个数据元素或记录的关键字，它对应的数据项就是次关键码。</p><blockquote><p>查找 (Searching) 就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素 (或记录)。</p></blockquote><p>查找表按照操作方式来分有两大种：静态查找表和动态查找表。<br><strong>静态查找表 (Static Search Table)：只作查找操作的查找表</strong>。它的主要操作有：</p><ol><li>查询某个“特定的”数据元素是否在查找表中。</li><li>检索某个“特定的”数据元素和各种属性。</li></ol><p><strong>动态查找表 (Dynamic Search Table)：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素</strong>。显然动态查找表的操作就是两个：</p><ol><li>查找时插入数据元素。</li><li>查找时删除数据元素。</li></ol><h3 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h3><p><strong>顺序查找 (Sequential Search) 又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个或最后一个记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果知道最后一个或第一个记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功</strong>。</p><h4 id="顺序表查找算法"><a href="#顺序表查找算法" class="headerlink" title="顺序表查找算法"></a>顺序表查找算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序查找，a 为数组，n 为要查找的数组个数，key 为要查找的关键字</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sequential_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i] == key)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码非常简单，就是在数组 a (注意元素值从下标 1 开始) 中查看有没有关键字 (key)，当需要查找复杂表结构的记录时，只需要把数组 a 与关键字 key 定义成需要的表结构和数据类型即可。</p><h4 id="顺序表查找优化"><a href="#顺序表查找优化" class="headerlink" title="顺序表查找优化"></a>顺序表查找优化</h4><p>到这里并非足够完美，因为每次循环时都需要对 i 是否越界，即是否小于等于 n 做判断。事实上，还可以有更好一点的办法，设置一个哨兵，可以解决不需要每次让 i 与 n 做比较。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有哨兵顺序查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sequential_Search2</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  a[<span class="number">0</span>] = key;<span class="comment">// 设置 a[0] 为关键字值，称之为哨兵</span></span><br><span class="line">  i = n;<span class="comment">// 循环从数组尾部开始</span></span><br><span class="line">  <span class="keyword">while</span>(a[i] != key) &#123;</span><br><span class="line">    i--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;<span class="comment">// 返回 0 则说明查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时代码是从尾部开始查找，由于 a[0] &#x3D; key，也就是说，如果在 a[i] 中有 key 则返回 i 值，查找成功。否则一定在最终的 a[0] 处等于 key，此时返回的是 0，即说明 a[1]~a[n] 中没有关键字 key，查找失败。</p><p>这种在查找方向的尽头放置哨兵面去了在查找过程中每一次比较后都要判断查找位置是否越界的小技巧，看似与原先差别不大，但在总数据较多时，效率提高很大，是非常好的编码技巧。当然，哨兵也不一定就一定要在数组开始，也可以在末端。</p><p>对于这种顺序查找算法来说，查找成功最好的情况就是在第一个位置就找到了，算法时间复杂度为 O(1)，最坏的情况是在最后一位置才找到，需要 n 次比较，时间复杂度为 O(n)，当查找不成功时，需要 n+1 次比较，时间复杂度为 O(n)。所以最终的时间复杂度还是 O(n)。</p><p>很显然，顺序查找技术是有很大缺点的，n 很大时，查找效率极为低下，不过优点也是有的，这个算法非常简单，对静态查找表的记录没有任何要求，在一些小型数据的查找时，是可以适用的。另外，也正由于查找概率的不同，完全可以将容易查找到的记录放在前面，而不常用的记录放置在后面，效率就可以有大幅提高。</p><h3 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h3><h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><p><strong>折半查找 (Binary Search) 技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序 (通常从小到大有序)，线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止</strong>。</p><p>假如在一个有序表数组 {0, 1, 16, 24, 35, 47, 59, 62, 73, 88, 99} 中查找是否存在 62 这个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 折半查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> low, high, mid;</span><br><span class="line">  low = <span class="number">1</span>;<span class="comment">// 定义最低下标为记录首位</span></span><br><span class="line">  high = n;<span class="comment">// 定义最高下标为记录末位</span></span><br><span class="line">  <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">    mid = (low + high) / <span class="number">2</span>;<span class="comment">// 折半</span></span><br><span class="line">    <span class="keyword">if</span> (key &lt; a[mid])<span class="comment">// 若查找值比中值小</span></span><br><span class="line">      high = mid - <span class="number">1</span>;<span class="comment">// 最高下标调整到中位下标小一位</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; a[mid])<span class="comment">// 若查找值比中值大</span></span><br><span class="line">      low = mid + <span class="number">1</span>;<span class="comment">// 最低下标调整到中位下标大一位</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> mid;<span class="comment">// 若相等则说明 mid 即为查找到的位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>折半查找算法的时间复杂度为 O(logn)，它显然远远好于顺序查找的 O(n) 时间复杂度了。</p><h4 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h4><p>**插值查找 (Interpolation Search) 是根据要查找的关键字 key 与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式 <code>(key - a[low])/(a[high] - a[low])</code>**。只需要将查办查找算法代码中第 7 行更改成以下就可以了<code>mid = low + (high -low) * (key - a[low]) / (a[high] - a[low]);</code>。应该说，从时间复杂度来看，他也是 O(logn)，但对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多。</p><h4 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h4><p>斐波那契查找 (Fibonacci Search) 利用了黄金分割原理来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契数列</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fibonacci_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> low, high, mid, i, k;</span><br><span class="line">  low = <span class="number">1</span>;<span class="comment">// 定义最低下标为记录首位</span></span><br><span class="line">  high = n;<span class="comment">// 定义最高下标为记录末位</span></span><br><span class="line">  k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n &gt; F[k] - <span class="number">1</span>)<span class="comment">// 计算 n 位于斐波那契数列的位置</span></span><br><span class="line">    k++;</span><br><span class="line">  <span class="keyword">for</span>(i = n; i &lt; F[k] - <span class="number">1</span>; i++)<span class="comment">// 将不满的数值补全</span></span><br><span class="line">    a[i] = a[n];</span><br><span class="line">  <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">    mid = low + F[k - <span class="number">1</span>] - <span class="number">1</span>;<span class="comment">// 计算当前分割的下标</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; a[mid]) &#123;<span class="comment">// 若查找记录小于当前分割记录</span></span><br><span class="line">      high = mid <span class="number">-1</span>;<span class="comment">// 最高下标调整到分割下标 mid - 1 处</span></span><br><span class="line">      k = k - <span class="number">1</span>;<span class="comment">// 斐波那契数列下标减一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; a[mid]) &#123;<span class="comment">// 若查找记录大于当前分割记录</span></span><br><span class="line">      low = mid + <span class="number">1</span>;<span class="comment">// 最低下标调整到分割下标 mid + 1 处</span></span><br><span class="line">      k = k - <span class="number">2</span>;<span class="comment">// 斐波那契数列下标减两位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(mid &lt;= n)</span><br><span class="line">        <span class="keyword">return</span> mid;<span class="comment">// 若相等则说明 mid 即为查找到的位置</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n;<span class="comment">// 若 mid &gt; n 说明是补全数值，返回 n</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>斐波那契查找算法的核心在于：</p><ol><li>当 key &#x3D; a[mid] 时，查找就成功；</li><li>当 key &lt; a[mid] 时，新范围是第 low 个到 mid - 1 个，此时范围个数为 F[k - 1] - 1 个；</li><li>当 key &gt; a[mid] 时，新范围是第 m + 1 个到第 high 个，此时范围个数为 F[k - 2] - 1个。</li></ol><p>也就是说，如果要查找的记录在右侧，则左侧的数据都不用再判断了，不断反复进行下去，对处于当中的大部分数据，其工作效率要高一些。所以尽管斐波那契查找的时间复杂也为 O(logn)，但就平均性能来说，斐波那契查找要优于折半查找。可惜如果是最坏情况，比如这里 key &#x3D; 1，那么始终都处于左侧长半区在查找，则查找效率要低于折半查找。</p><p>还有比较关键的一点，折半查找是进行加法于除法运算 (mid &#x3D; (low + high) &#x2F; 2)，插值查找进行复杂的四则运算 (mid &#x3D; low + (high - low) * (key - a[low]) &#x2F; (a[high] - a[low]))，而斐波那契查找只是最简单加减法运算 (mid &#x3D; low + F[k - 1] - 1)，在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率。</p><h3 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h3><p>以上几种比较高效的查找方法都是基于有序的基础之上的，但事实上，很多数据集可以增长非常快，如果要保证记录全部是按照当中某个关键字有序，其时间代价是非常昂贵的，所以这种数据通常都是按先后顺序存储。</p><p>数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构。<strong>索引就是把一个关键字与它对应的记录相关联的过程</strong>，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。</p><p>索引按照结构可以分为线性索引、树形索引和多级索引。<strong>所谓线性索引就是将索引项集合组织为线性结构，也称为索引表</strong>。</p><h4 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h4><p><strong>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项</strong>，如下图。</p><p><img src="http://1.117.162.142:9000/blog/%E7%A8%A0%E5%AF%86%E7%B4%A2%E5%BC%95.png" alt="稠密索引"></p><p><strong>对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列</strong>。</p><p>索引项有序也就意味着，要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高了效率。这显然是稠密索引有点，但是如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说，可能就需要反复去访问磁盘，查找性能反而大大下降了。</p><h4 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h4><p><strong>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件</strong>：</p><ul><li><strong>块内无序</strong>，即每一块内的记录不要求有序。当然，如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间的代价，因此通常不要求块内有序。</li><li><strong>块间有序</strong>，例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字……因为只有块间有序，才有可能在查找时带来效率。</li></ul><p>对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。如下图。定义的分块索引结构分三个数据项：</p><ul><li>最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块的关键字要大；</li><li>存储了块中的记录个数，以便于循环时使用；</li><li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。</li></ul><p><img src="http://1.117.162.142:9000/blog/%E5%88%86%E5%9D%97%E7%B4%A2%E5%BC%95.png" alt="分块索引"></p><p>在分块索引表查找，就是分两步进行：</p><ol><li>在分块索引表中查找要查关键字所在的块。由于分块索引表是块间有序的，因此很容易利用折半、插值等算法得到结果。</li><li>根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查找。</li></ol><p>分析一下分块索引的平均查找长度。设 n 个记录的数据集被平均分成 m 块，每个块中有 t 条记录，显然 n &#x3D; m * t，或者说 m &#x3D; n &#x2F; t。再假设 L<sub>b</sub> 为查找索引表的平均查找长度，因最好于最差的等概率原则，所以 L<sub>b</sub> 的平均长度为 (m + 1) &#x2F; 2。L<sub>w</sub> 为块中查找记录的平均查找长度，同理可知它的平均查找长度为 (t + 1) &#x2F; 2。</p><p>这样分块索引查找的平均查找长度为：</p><p>ASL<sub>w</sub> &#x3D; L<sub>b</sub> + L<sub>w</sub> &#x3D; (m + 1) &#x2F; 2 + (t + 1) &#x2F; 2 &#x3D; 1 &#x2F; 2(m + t) + 1 &#x3D; 1 &#x2F; 2(n &#x2F; t + t) + 1</p><p>注意上面这个式子的推导是为了让整个分块索引查找长度依赖 n 和 t 两个变量。从这里我们也就得到，平均长度不仅仅取决于数据集的总记录数 n，还和每一块的记录个数 t 相关。最佳的情况就是分的块数 m 与块中的记录数 t 相同，此时意味着 n &#x3D; m * t &#x3D; t<sup>2</sup>，即 ASL<sub>w</sub> &#x3D; 1 &#x2F; 2(n &#x2F; t + t) + 1 &#x3D; t + 1 &#x3D; √n + 1</p><p>可见，分块索引的效率比之顺序查找的 O(n) 是高了不少，不过显然它与折半查找的 O(long) 相比还有不小的差距。因此在确定所在块的过程中，由于块间有序，所以可以应用折半、插值等手段来提高效率。</p><p>总的来说，分块索引在兼顾了对细分块不需要有序的情况下，大大增加了整体查找的速度，所以普遍被用于数据库表查找等技术的应用当中。</p><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>索引项的通用结构是：</p><ul><li>次关键码</li><li>记录号表</li></ul><p>**其中记录号表存储具有相同次关键字的所有记录的记录号 (可以是指向记录的指针或者是该记录的主关键字)。这样的索引方法就是倒排索引 (inverted index)**。倒排索引源于实际应用中需要根据属性或字段、次关键码的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因为称为倒排索引。</p><p>倒排索引的优点显然就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果。但它的缺点是这个记录号不定长。</p><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p><strong>二叉排序树 (Binary Sort Tree)，又称为二叉查找树。它或者是一颗空树，或者是具有下列性质的二叉树</strong>。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树。</li></ul><p>从二叉排序树的定义可以知道，它前提是二叉树，然后它采用了递归的定义方法，再者，它的结点间满足一定的次序关系，左子树结点一定比其双亲结点小，右子树结点一定比其双亲结点大。</p><p>构造一棵二叉排序树的目的，其实并不是为了排序，而是为了提高查找和插入删除关键字的速度。不管怎么说，在一个有序数据集上的查找，速度总是要快于无序的数据集的，而二叉排序树这种非线性的结构，也有利于插入和删除的实现。</p><h4 id="二叉排序树查找操作"><a href="#二叉排序树查找操作" class="headerlink" title="二叉排序树查找操作"></a>二叉排序树查找操作</h4><p>提供一个二叉树的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的二叉链表结点结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span><span class="comment">// 结点结构</span></span><br><span class="line">  <span class="type">int</span> data;<span class="comment">// 结点数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><p>二叉排序树的查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归查找二叉排序树 T 中是否存在 key，指针 f 指向 T 的双亲，其初始调用值为 NULL。若查找成功，则指针 p 指向查找路径上访问的最后一个结点并返回 FALSE</span></span><br><span class="line">Status <span class="title function_">SearchBST</span><span class="params">(BiTree T, <span class="type">int</span> key, BiTree f, BiTree *p)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!T) &#123;<span class="comment">// 查找不成功</span></span><br><span class="line">    *p = f;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(key == T -&gt; data) &#123;<span class="comment">// 查找成功</span></span><br><span class="line">    *p = T;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T -&gt; data)</span><br><span class="line">    <span class="keyword">return</span> SearchBST(T -&gt; lchild, key, T, p);<span class="comment">// 在左子树继续查找</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> SearchBST(T -&gt; rchild, key, T, p);<span class="comment">// 在右子树继续查找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉排序树插入操作"><a href="#二叉排序树插入操作" class="headerlink" title="二叉排序树插入操作"></a>二叉排序树插入操作</h4><p>有了二叉排序树的查找函数，那么所谓的二叉排序树的插入，其实也就是将关键字放到树中的合适位置而已。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当二叉排序树 T 中不存在关键字等于 key 的数据元素时，插入 key 并返回 TRUE，否则返回 FALSE</span></span><br><span class="line">Status <span class="title function_">InsertBST</span><span class="params">(BiTree *T, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  BiTree p, s;</span><br><span class="line">  <span class="keyword">if</span>(!SearchBST(*T, key, <span class="literal">NULL</span>, &amp;p)) &#123;<span class="comment">// 查找不成功</span></span><br><span class="line">    s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    s -&gt; data = key;</span><br><span class="line">    s -&gt; lchild = s -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">      *T = s;<span class="comment">// 插入 s 为新的根结点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; p -&gt; data)</span><br><span class="line">      p -&gt; lchild = s;<span class="comment">// 插入 s 为左孩子</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      p -&gt; rchild = s;<span class="comment">// 插入 s 为右孩子</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;<span class="comment">// 树中已有关键字相同的结点，不再插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了二叉排序树的插入代码，是心啊二叉排序树的构建就非常容易了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">62</span>, <span class="number">88</span>, <span class="number">58</span>, <span class="number">47</span>, <span class="number">35</span>, <span class="number">73</span>, <span class="number">51</span>, <span class="number">99</span>, <span class="number">37</span>, <span class="number">93</span>&#125;;</span><br><span class="line">BiTree T = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  InsertBST(&amp;T, a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉排序树删除操作"><a href="#二叉排序树删除操作" class="headerlink" title="二叉排序树删除操作"></a>二叉排序树删除操作</h4><p>对删除结点三种情况的分析：</p><ul><li>叶子结点；</li><li>仅有左或右子树的结点；</li><li>左右子树都有的结点。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若二叉排序树 T 中存在关键字等于 key 的数据元素时，则删除该数据元素结点，并返回 TRUE；否则返回 FALSE</span></span><br><span class="line">Status <span class="title function_">DeleteBST</span><span class="params">(BiTree *T, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!*T)<span class="comment">// 不存在关键字等于 key 的数据元素</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(key == (*T) -&gt; data)<span class="comment">// 找到关键字等于 key 的数据元素</span></span><br><span class="line">      <span class="keyword">return</span> Delete(T);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; (*T) -&gt; data)</span><br><span class="line">      <span class="keyword">return</span> DeleteBST(&amp;(*T) -&gt; lchild, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> DeleteBST(&amp;(*T) -&gt; rchild, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码和前面的二叉排序树查找几乎完全相同，唯一的区别在于第 7 行，此时执行的是 Delete 方法，对当前结点进行删除操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从二叉排序树中删除结点 p，并重接它的左或右子树。</span></span><br><span class="line">status <span class="title function_">Delete</span><span class="params">(BiTree *p)</span> &#123;</span><br><span class="line">  BiTree q, s;</span><br><span class="line">  <span class="keyword">if</span>((*p) -&gt; rchild == <span class="literal">NULL</span>) &#123;<span class="comment">// 右子树空则只需重接它的左子树</span></span><br><span class="line">    q = *p; </span><br><span class="line">    *p = (*p) -&gt; lchild; </span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((*p) -&gt; lchild == <span class="literal">NULL</span>) &#123;<span class="comment">// 只需重接它的右子树</span></span><br><span class="line">    q = *p;</span><br><span class="line">    *p = (*p) -&gt; rchild;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;<span class="comment">// 左右子树均不空</span></span><br><span class="line">    q = *p;</span><br><span class="line">    s = (*p) -&gt; lchild;</span><br><span class="line">    <span class="keyword">while</span>(s -&gt; rchild) &#123;<span class="comment">// 转左，然后向右到尽头 (找待删结点的前驱)</span></span><br><span class="line">      q = s;</span><br><span class="line">      s = s -&gt; rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    (*p) -&gt; data = s -&gt; data;<span class="comment">// s 指向被删结点的直接前驱</span></span><br><span class="line">    <span class="keyword">if</span>(q != *p)</span><br><span class="line">      q -&gt; rchild = s -&gt; lchild;<span class="comment">// 重接 q 的右子树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      q -&gt; lchild = s -&gt; lchild;<span class="comment">// 重接 q 的左子树</span></span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> TRUE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉排序树总结"><a href="#二叉排序树总结" class="headerlink" title="二叉排序树总结"></a>二叉排序树总结</h4><p>总之，二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可。插入删除的时间性能比较好。而对于二叉排序树的查找，走的就是从根结点到要查找的结点的路径，其比较次数等于给定值的结点在二叉排序树的层数。极端情况，最少为 1 次，几根结点就是要找的结点，最多也不会超过树的深度。也就是说，二叉排序树的查找性能取决于二叉树排序树的形状。可问题在于，二叉排序树的形状是不确定的。</p><p>也就是说，希望二叉排序树是比较平衡的，即其深度与完全二叉树相同，均为 log<sub>2</sub>n + 1，那么查找的时间复杂度也就为 O(logn)，近似于折半查找。因此希望对一个集合按二叉排序树查找，最好是把它构建成一棵平衡二叉树。</p><h3 id="平衡二叉树-AVL-树"><a href="#平衡二叉树-AVL-树" class="headerlink" title="平衡二叉树 (AVL 树)"></a>平衡二叉树 (AVL 树)</h3><p><strong>平衡二叉树 (Self-Balancing Binary Search Tree 或 Height-Balanced Binary Search Tree)，是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于 1</strong>。</p><p>从平衡二叉树的英文名，可以体会到，它是<strong>一种高度平衡的二叉排序树</strong>。那什么叫做高度平衡呢？意思是说，要么它是一棵空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过 1。**将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子 BF (Balance Factor)**，那么平衡二叉树上所有结点的平衡因子只可能是 -1， 0 和 1。只要二叉树上有一个结点的平衡因子的绝对值大于 1，则该二叉树就是不平衡的。</p><p><strong>距离插入结点最近的，且平衡因子的绝对值大于 1 的结点为根的子树，称为最小不平衡子树</strong>。</p><h4 id="平衡二叉树实现原理"><a href="#平衡二叉树实现原理" class="headerlink" title="平衡二叉树实现原理"></a>平衡二叉树实现原理</h4><p>平衡二叉树构建的基本思想就是在构建二叉树排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。</p><h4 id="平衡二叉树的实现算法"><a href="#平衡二叉树的实现算法" class="headerlink" title="平衡二叉树的实现算法"></a>平衡二叉树的实现算法</h4><p>改进二叉排序树的结点结构，增加一个 bf，用来存储平衡因子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的二叉链表结点结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span><span class="comment">// 结点结构</span></span><br><span class="line">  <span class="type">int</span> data;<span class="comment">// 结点数据</span></span><br><span class="line">  <span class="type">int</span> bf;<span class="comment">// 结点的平衡因子</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><p>然后，对于右旋操作，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对以 p 为根的二叉排序树作右旋处理，处理之后 p 指向新的树根结点，即旋转处理之前的左子树的根结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">R_Rotate</span><span class="params">(BiTree *P)</span> &#123;</span><br><span class="line">  BiTree L;</span><br><span class="line">  l = (*P) -&gt; lchild;<span class="comment">// L 指向 p 的左子树根结点</span></span><br><span class="line">  (*P) -&gt; lchild = L -&gt; rchild;<span class="comment">// L 的右子树挂接为 p 的左子树</span></span><br><span class="line">  L -&gt; rchild = (*p);</span><br><span class="line">  *p = L;<span class="comment">// p 指向新的根结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数代码的意思是说，当传入一个二叉排序树 p，将它的左孩子结点定义为 L，将 L 的右子树变成 p 的左子树，再将 p 改成 L 的右子树，最后将 L 替换 P 成为根结点。这样就完成了一次右旋操作。</p><p>左旋操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对以 p 为根的二叉排序树作左旋处理，处理之后 p 指向新的树根结点，即旋转处理之前的右子树的根结点 0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">L_Rotate</span><span class="params">(BiTree *p)</span> &#123;</span><br><span class="line">  BiTree R;</span><br><span class="line">  R = (*p) -&gt; rchild;<span class="comment">// R 指向 p 的右子树根结点</span></span><br><span class="line">  (*p) -&gt; rchild = R -&gt; lchild;<span class="comment">// R 的左子树挂接为 P 的右子树</span></span><br><span class="line">  R -&gt; lchild = (*p);</span><br><span class="line">  *p = R;<span class="comment">// P 指向新的根结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左平衡旋转处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LH +1<span class="comment">/* 左高 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EH 0<span class="comment">/* 等高 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RH -1<span class="comment">/* 右高 */</span></span></span><br><span class="line"><span class="comment">/* 对以指针 T 所指结点为根的二叉树作左平衡旋转处理，本算法结束时，指针 T 指向新的根结点 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LeftBalance</span><span class="params">(BiTree *T)</span> &#123;</span><br><span class="line">  BiTree L, Lr;</span><br><span class="line">  L = (*T) -&gt; lchild;<span class="comment">// L 指向 T 的左子树的根结点</span></span><br><span class="line">  <span class="keyword">switch</span>(L -&gt; bf) &#123;<span class="comment">// 检查 T 的左子树的平衡度，并做相应平衡处理</span></span><br><span class="line">    <span class="keyword">case</span> LH:<span class="comment">// 新结点插入在 T 的左孩子的左子树上，要做单右旋处理</span></span><br><span class="line">      (*T) -&gt; bf = L -&gt; bf = EH;</span><br><span class="line">      R_Rotate(T);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RH:     <span class="comment">// 新结点插入在 T 的左孩子的右子树上，要做双旋处理</span></span><br><span class="line">      Lr = L -&gt; rchild;<span class="comment">// Lr 指向 T 的左孩子的右子树根</span></span><br><span class="line">      <span class="keyword">switch</span>(Lr -&gt; bd) &#123;<span class="comment">// 修改 T 及其左孩子的平衡因子</span></span><br><span class="line">        <span class="keyword">case</span> LH:</span><br><span class="line">          (*T) -&gt; bf = RH;</span><br><span class="line">          L -&gt; bf = EH;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EH:</span><br><span class="line">          (*T) -&gt; bf = L -&gt; bf = EH;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RH:</span><br><span class="line">          (*T) -&gt; bf = EH;</span><br><span class="line">          L -&gt; bf = LH;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Lr -&gt; bf = EH;</span><br><span class="line">      L_Rotate(&amp;(*T) -&gt; lchild);<span class="comment">// 对 T 的左子树作左旋平衡处理</span></span><br><span class="line">      R_Rotate(T);<span class="comment">// 对 T 作右旋平衡处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 若在平衡的二叉排序树 T 中不存在和 e 有相同关键字的结点，则插入一个数据元素为 e 的新结点并返回 1，否则返回 0。 */</span></span><br><span class="line"><span class="comment">/* 若因插入而使二叉排序树失去平衡，则作平衡旋转处理，布尔变量 taller 反应 T 长高与否 */</span></span><br><span class="line">Status <span class="title function_">InsertAVL</span><span class="params">(BiTree *T, <span class="type">int</span> e, Status *taller)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!*T) &#123;<span class="comment">// 插入新结点，树“长高”，置 taller 为 TRUE</span></span><br><span class="line">    *T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    (*T) -&gt; data = e;</span><br><span class="line">    (*T) -&gt; lchild = (*T) -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">    (*T) -&gt; bf = EH;</span><br><span class="line">    *taller = TRUE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(e == (*T) -&gt; data) &#123;<span class="comment">// 树中已存在和 e 有相同关键字的结点则不再插入</span></span><br><span class="line">      *taller = FALSE;</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(e &lt; (*T) -&gt; data) &#123;<span class="comment">// 应继续在 T 的左子树中进行搜索</span></span><br><span class="line">      <span class="keyword">if</span>(!InsertAVL(&amp;(*T) -&gt; lchild, e, taller))<span class="comment">// 未插入</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">      <span class="keyword">if</span>(taller) &#123;<span class="comment">// 已插入到 T 的左子树中且左子树“长高”</span></span><br><span class="line">        <span class="keyword">switch</span>((*T) -&gt; bf) &#123;<span class="comment">//检查 T 的平衡度</span></span><br><span class="line">          <span class="keyword">case</span> LH:<span class="comment">// 原本左子树比右子树高，需要作左平衡处理</span></span><br><span class="line">            LeftBalance(T);</span><br><span class="line">            *taller = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> EH:<span class="comment">// 原本左右子树等高，现因左子树增高而树增高</span></span><br><span class="line">            (*T) -&gt; bf = LH;</span><br><span class="line">            *taller = TRUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> RH:<span class="comment">// 原本右子树比左子树高，现左右子树等高</span></span><br><span class="line">            (*T) -&gt; bf = EH;</span><br><span class="line">            *taller = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 应继续在 T 的右子树中进行搜索</span></span><br><span class="line">      <span class="keyword">if</span>(!InsertAVL(&amp;(*T) -&gt; rchild, e, taller))<span class="comment">// 未插入</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">      <span class="keyword">if</span>(*taller) &#123;<span class="comment">// 已插入到 T 的右子树且右子树“长高”</span></span><br><span class="line">        <span class="keyword">switch</span>((*T) -&gt; bf) &#123;<span class="comment">// 检查 T 的平衡度</span></span><br><span class="line">          <span class="keyword">case</span> LH:<span class="comment">// 原本左子树比右子树高，现左、右子树等高</span></span><br><span class="line">            (*T) -&gt; bf = EH;</span><br><span class="line">            *taller = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> EH:<span class="comment">// 原本右右子树等高，现因右子树增高而树增高</span></span><br><span class="line">            (*T) -&gt; bf = RH;</span><br><span class="line">            *taller = TRUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> RH:<span class="comment">// 原本右子树比左子树高，需要作右平衡处理</span></span><br><span class="line">            RightBalance(T);</span><br><span class="line">            *taller = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成一棵平衡二叉树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>,  <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">BiTree T = <span class="literal">NULL</span>;</span><br><span class="line">Status taller;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  InsertAVL(&amp;T, a[i], &amp;taller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要查找的集合本身没有顺序，在频繁查找的同时也需要经常的插入和删除操作，显然需要构建一棵二叉排序树，但是不平衡的二叉排序树，查找效率是非常低的，因此需要在构建时，就让这棵二叉排序树是平衡二叉树，此时的查找时间复杂度就为 O(logn)，而插入和删除也为 O(logn)。显然这是比较理想的一种动态查找表算法。</p><h3 id="多路查找树-B-树"><a href="#多路查找树-B-树" class="headerlink" title="多路查找树 (B 树)"></a>多路查找树 (B 树)</h3><p><strong>多路查找树 (muitl-way search tree)，其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素</strong>。由于它是查找树，所有元素之间存在某种特定的排序关系。</p><h4 id="2-3-树"><a href="#2-3-树" class="headerlink" title="2-3 树"></a>2-3 树</h4><p>**2-3 树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子 (称它为 2 结点) 或三个孩子 (称它为 3 结点)**。</p><p><strong>一个 2 结点包含一个元素和两个孩子或没有孩子</strong>，且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。不过，与二叉排序树不同的是，这个 2 结点要么没有孩子，要有就有两个，不能只有一个孩子。</p><p><strong>一个 3 结点包含一小一大两个元素和三个孩子或没有孩子</strong>，一个 3 结点要么没有孩子，要么具有 3 个孩子。如果某个 3 结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。</p><p>并且 2-3 树中所有的叶子都在同一层次上。事实上，2-3 树复杂的地方就在于新结点的插入和已有结点的删除。毕竟，每个结点可能是 2 结点也可能是 3 结点，要保证所有叶子都在同一层次，是需要进行一番复杂操作的。</p><p><img src="http://1.117.162.142:9000/blog/2-3%E6%A0%91.png" alt="2-3树"></p><ul><li><p><strong>2-3树的插入实现</strong></p><p>  对于 2-3 树的插入来说，与二叉排序树相同，插入操作一定是发生在叶子结点上。可与二叉排序树不同的是，2-3 树插入一个元素的过程有可能会对该树的其余结构产生连锁反应。</p><p>  2-3 树插入可分为三种情况：</p><ol><li>对于空树，插入一个 2 结点即可。</li><li>插入结点到一个 2 结点的叶子上。应该说，由于其本身就只有一个元素，所以只需要将其升级为 3 结点即可。</li><li>要往 3 结点中插入一个新元素。因为 3 结点本身已经是 2-3 树的结点最大容量 (已经有两个元素)，因此就需要将其拆分，且将树中两元素或插入元素的三者中选择其一向上移动一层。复杂的情况也正在于此。</li></ol></li><li><p><strong>2-3 树的删除实现</strong></p><p>  2-3 树的删除也分为三种情况</p><ol><li>所删除元素位于一个 3 结点的叶子结点上，只需要在该结点处删除该元素即可，不会影响到整棵树的其他结点结构。</li><li>所删除的元素位于一个 2 结点上，即要删除的是一个只有一个元素的结点。对于删除叶子是 2 结点的情况，需要分四种情形来处理。<ul><li>此结点的双亲也是 2 结点，且拥有一个 3 结点的右孩子。</li><li>此结点的双亲是 2 结点，它的右孩子也是 2 结点。</li><li>此结点的双亲是一个 3 结点。</li><li>如果当前树是一个满二叉树的情况，此时删除任何一个叶子都会使得整棵树不能满足 2-3 树的定义。</li></ul></li><li>所删除的元素位于非叶子的分支结点。 通常是将树按中序遍历后得到此元素的前驱或后继元素，考虑让它们来补位即可。</li></ol></li><li><p><strong>2-3-4 树</strong></p><p>  <strong>2-3-4 树就是 2-3 树的概念扩展，包括了 4 结点的使用。一个 4 结点包含小中大三个元素和四个孩子或没有孩子</strong>，一个 4 结点要么没有孩子，要么具有 4 个孩子。如果某个 4 结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素。</p></li></ul><h4 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h4><p><strong>B 树 (B Tree) 是一种平衡的多路查找树，2-3 树和 2-3-4 树都是 B 树的特例。结点最大的孩子数目称为 B 树的阶 (order)，因此，2-3 树是 3 阶 B 树，2-3-4 树是 4 阶 B 树。</strong></p><p>一个 m 阶的 B 树具有如下属性：</p><ul><li>如果根结点不是叶结点，则其至少有两棵子树。</li><li>每一个非根的分支结点都有 k - 1 个元素和 k 个孩子，其中 (m &#x2F; 2) ≤ k ≤ m。每一个叶子结点 n 都有 k - 1 个元素，其中 (m &#x2F; 2) ≤ k ≤ m。</li><li>所有叶子结点都位于同一层次。</li><li>所有分支结点包含下列信息数据 (n, A<sub>0</sub>, K<sub>1</sub>, A<sub>1</sub>, K<sub>2</sub>, A<sub>2</sub>, ···, K<sub>n</sub>, A<sub>n</sub>)，其中：K<sub>i</sub> (i &#x3D; 1, 2, ……, n) 为关键字，且 K<sub>i</sub> &lt; K<sub>i + 1</sub> (i &#x3D; 1, 2, ···， n-1)；A<sub>i</sub> (i &#x3D; 0, 2, ···, n-1)；A<sub>i</sub> (i &#x3D; 0, 2, ···, n) 为指向子树根结点的指针，且指针 A<sub>i - 1</sub> 所指子树中所有结点的关键字均小于 K<sub>i</sub> (i &#x3D; 1, 2, ……, n)，A<sub>n</sub> 所指子树中所有结点的关键字均大于 K<sub>n</sub>，n · ((m &#x2F; 2) - 1 ≤ n ≤ m - 1) 为关键字的个数或 n + 1 为子树的个数。</li></ul><h4 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h4><p>B+ 树适应文件系统所需而出的一种 B 树的变形树。在 B 树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在 B+ 树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者 (叶子结点) 中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针。</p><p>一棵 m 阶的 B+ 树和 m 阶的 B 树的差异在于：</p><ul><li>有 n 棵子树的结点中包含有 n 个关键字；</li><li>所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接；</li><li>所有分支结点可以看成是索引，结点中仅含有其子树中的最大或最小关键字。</li></ul><p>这样的数据结构最大的好处就在于，如果是要随机查找，就从根结点出发，与 B 树的查找方式相同，只不过即使在分支结点找到了待查找的关键字，它也只是用来索引的，不能提供实际记录的访问，还是需要到达包含此关键字的终端结点。</p><p>如果是需要从最小关键字进行从小到大的顺序查找，就可以从最左侧的叶子结点出发，不经过分子结点，而是延着指向下一叶子的指针就可遍历所有的关键字。</p><p>B+ 树的结构特别适合带有范围的查找。B+ 树的插入、删除过程也都与 B 树类似，只不过插入和删除的元素都是在叶子结点上进行而已。</p><h3 id="散列表查找-哈希表-概述"><a href="#散列表查找-哈希表-概述" class="headerlink" title="散列表查找 (哈希表) 概述"></a>散列表查找 (哈希表) 概述</h3><h4 id="散列表查找定义"><a href="#散列表查找定义" class="headerlink" title="散列表查找定义"></a>散列表查找定义</h4><p>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，使得每个关键字 key 对应一个存储位置 f(key)。查找时，根据这个确定的对应关系找到给定值 key 的映射 f(key)，若查找集合中存在这个记录，则必定在 f(key) 的位置上。</p><p>这里把这种对应<strong>关系 f 称为散列函数，又称为哈希 (Hash) 函数</strong>。按这个思想，**采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表 (Hash Table)**。那么关键字对应的记录存储位置称为散列地址。</p><h4 id="散列表查找步骤"><a href="#散列表查找步骤" class="headerlink" title="散列表查找步骤"></a>散列表查找步骤</h4><p>整个散列过程其实就是两步。</p><ol><li>在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。</li><li>当查找记录时，通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。</li></ol><p>所以说，<strong>散列技术即是一种存储方法，也是一种查找方法</strong>。然而它与线性表、树、图等结构不同的是，前面几种结构，数据元素之间都存在某种逻辑关系，可以用连线图示表示出来，而散列技术的记录之间不存在什么逻辑关系，它只与关键字有关联。因此，散列主要是面向查找的存储结构。</p><p><strong>散列技术最适合的求解问题是查找与给定值相等的记录</strong>。对于查找来说，简化了比较过程，效率就会大大提高。</p><p>在理想情况下，每一个关键字，通过散列函数计算出来的地址都是不一样的，可现实中，这只是一个理想。时长会碰到**两个关键字 key<sub>1</sub> ≠ key<sub>2</sub>，但是却有 f(key<sub>1</sub>) &#x3D; f(key<sub>2</sub>)，这种现象称为冲突 (collision)，并把 key<sub>1</sub> 和 key<sub>2</sub> 称为这个散列函数的同义词 (synonym)**。出现了冲突当然非常糟糕，那将造成数据查找错误。</p><h3 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h3><p>什么才算是好的散列函数？</p><ol><li><p><strong>计算简单</strong></p><p> 设计一个算法可以保证所有的关键字都不会产生冲突，但是这个算法需要很复杂的计算，会耗费很多时间，这对于需要频繁地查找来说，就会大大降低查找的效率了。因此散列函数的计算时间不应超过其他查找技术与关键字比较的时间。</p></li><li><p><strong>散列地址分布均匀</strong></p><p> 解决冲突最好的办法就是尽量让散列地址均匀地分布在存储空间中，这样可以保证存储空间的有效利用，并减少为处理冲突而耗费的时间。</p></li></ol><p>几种常用的散列函数构造方法：</p><h4 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h4><p><strong>取关键字的某个线性函数值为散列地址</strong>。即</p><p><code>f(key) = a × key + b (a、b 为常数)</code></p><p>这样的散列函数优点就是检点、均匀，也不会产生冲突，但问题是这需要事先知道此关键字的分布情况，适合查找表较小且连续的情况。由于这样的限制，在显示应用中，此方法虽然简单，但却并不常用。</p><h4 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h4><p>如果关键字是位数较多的数字，比如 11 位手机号 “131xxxx1234”，其中前三位是接入号，一般对应不同运营商公司的子品牌，如 130 是连通如意通、136 是移动神州行、153 是电信等；中间四位是 HLR 识别号，表示用户号的归属地；后四位才是真正的用户号。</p><p>若现在要存储某家公司员工登记表，如果用手机号作为关键字，那么极有可能前 7 位都是相同的。那么选择后面的四位称为散列地址就是不错的选择。如果这样的抽取工作还是容易出现冲突，还可以对抽取出来的数字在进行反转 (如 1234 改成 4321)、右环位移 (如 1234 改成 4123)、左环位移、甚至前两数与后两数叠加 (如 1234 改成 12 + 34 &#x3D; 46) 等方法。总的目的就是为了提供一个散列函数，能能够合理地将关键字分配到散列表的各位置。</p><p>这里提到了一个关键词——抽取。抽取方法是使用关键字的一部分来计算散列存储位置的方法，这在散列函数中是常常用到的手段。</p><p>数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干分布比较均匀，就可以考虑用这个方法。</p><h4 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h4><p>这个方法计算很简单，假设关键字是 1234，那么它的平方就是 1522756，再抽取中间的 3 位就是 227，用做散列地址。再比如关键字是 4321，那么它的平方就是 18671041，抽取中间的 3 位就可以是 671，也可以是 710，用做散列地址。平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况。</p><h4 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h4><p>折叠法是将关键字从左到右分割成位数相等的几部分 (注意最后一部分位数不够时可以短些)，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。</p><p>比如关键字是 9876543210，散列表表长为三位，将它分为四组，987｜654｜321｜0，然后将它们叠加求和 987 + 654 + 321 + 0 &#x3D; 1962，在求后 3 位得到散列地址为 962。</p><p>有时可能这还不能保证分布均匀，不妨从一端向另一端来回折叠后对齐相加。比如将 987 和 321 反转，再与 654 和 0 相加，变成 789 + 654 + 123 + 0 &#x3D; 1566，此时散列地址为 566。</p><p>折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。</p><h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><p>此方法为最常用的构造散列函数方法。对于散列表长为 m 的散列函数公式为：</p><p><code>f(key) = key mod p (p ≤ m)</code></p><p>mod 是取模 (求余数) 的意思。事实上，这方法不仅可以对关键字直接取模，也可以在折叠、平方取中后再取模。</p><p>很显然，本方法的关键就在于选择合适的 p，p如果选得不好，就可能会容易产生同义词。</p><p>根据经验，若散列表表长为 m，通常 p 为小于或等于表长 (最好接近 m) 的最小质数或不包含小于 20 质因子的合数。</p><h4 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h4><p>选择一个随机数，取关键字的随机函数值为它的散列地址。也就是 f(key) &#x3D; random(key)。这里 random 是随机函数。当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。</p><p>总之，现实中，应该视不同的情况采用不同的散列函数。通过综合以下因素，可以决策选择哪种散列函数更合适。</p><ol><li>计算散列地址所需的时间。</li><li>关键字的长度。</li><li>散列表的大小。</li><li>关键字的分布情况。</li><li>记录查找的频率。</li><li>……</li></ol><h3 id="处理散列冲突的方法"><a href="#处理散列冲突的方法" class="headerlink" title="处理散列冲突的方法"></a>处理散列冲突的方法</h3><h4 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h4><p>所谓的<strong>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入</strong>。</p><p>它的公式是：</p><p><code>fi(key) = (f(key) + di) MOD m (di = 1, 2, 3, ……, m - 1)</code></p><p>解决冲突的开放定址法称为线性探测法。有时还会出现本来都不是同义词却需要争夺一个地址的情况，称这种现象为堆积。很显然，堆积的出现，使得我们需要不断处理冲突，无论是存入还是查找效率都会大大降低。</p><p><strong>增加平方运算的目的是为了不让关键字都聚集在某一块区域。称这种方法为二次探测法</strong>。</p><p><code>fi(key) = (f(key) + di) MOD m (di = 1, 1, 4, 4, ……, q^2, -q^2, q ≤ m / 2)</code></p><p>还有一种方法是，<strong>在冲突时，对于位移量 d<sub>i</sub> 采用随机函数计算得到，称之为随机探测法</strong>。</p><p>既然是随机，那么查找的时候不也随机生成 d<sub>i</sub> 吗？如果可以获得相同的地址？这里的随机其实是伪随机数。伪随机数是说，如果设置随机种子相同，则不断调用随机函数可以生成不会重复的数列，在查找时，用同样的随机种子，他每次得到的数列是相同的，相同的 d<sub>i</sub> 当然可以得到相同的散列地址。</p><p><code>fi(keyi) = (f(key) + di) MOD m (di 是一个随机数列)</code></p><p>总之，开放定址法只要在散列表未填满时，总是能找到不发生冲突的地址，是我们常用的解决冲突的方法。</p><h4 id="再散列函数法"><a href="#再散列函数法" class="headerlink" title="再散列函数法"></a>再散列函数法</h4><p>用买房子来举例，如果看房时的选择标准总是以市中心、交通便利、价格适中为指标，这样的房子凤毛麟角，基本上当你看到时，都已经被人买去了。</p><p>换一种思维，选择市郊的房子，交通尽管要差一些，但价格便宜很多，也许房子还可以买得大一些、质量好一些，并且由于更换了选房的想法，很快就找到了你需要的房子了。</p><p>对于散列表来说，事先准备多个散列函数。</p><p><code>fi(key) = RHi(key) (i = 1, 2, ···， k)</code></p><p>这里 RH<sub>i</sub> 就是不同的散列函数，可以把前面说的什么除留余数、折叠、平方取中全部用上。每当发生散列地址冲突时，就换一个散列函数计算，相信总会有一个可以把冲突解决掉。这种方法能够使得关键字不产生聚集，当然，相应地也增加了计算的时间。</p><h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>将所有关键字为同义词的记录存储在一个单链表中，称这种表为同义词字表，在散列表中只存储所有同义词字表的头指针。对于关键字集合 {12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34}，用 12 为除数，进行除留余数法，可得到如下图所示结构，此时，已经不存在什么冲突换址的问题，无论有多少个冲突，都只是在当前位置给单链表增加结点的问题。</p><p><img src="http://1.117.162.142:9000/blog/%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95.png" alt="链地址法"></p><p>链地址法给予可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保障。当然，这也就带来了查找时需要遍历单链表的性能损耗。</p><h4 id="公共溢出区法"><a href="#公共溢出区法" class="headerlink" title="公共溢出区法"></a>公共溢出区法</h4><p>这个方法其实就更好即理解，凡是冲突的都跟我走，我给你们这些冲突找个地呆着。这就如同孤儿院收留所有无家可归的孩子一样，我们为所有冲突的关键字建立了一个公共的溢出区来存放。</p><p>就前面的例子而言，共有三个关键字 {37, 48, 34} 与之前的关键字位置有冲突，那么就将它们存储到溢出表中，如下图。</p><p><img src="http://1.117.162.142:9000/blog/%E5%85%AC%E5%85%B1%E6%BA%A2%E5%87%BA%E5%8C%BA%E6%B3%95.png" alt="公共溢出区法"></p><p>在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功；如果不相等，则到溢出表去进行顺序查找。如果相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还时非常高的。</p><h3 id="散列表查找实现"><a href="#散列表查找实现" class="headerlink" title="散列表查找实现"></a>散列表查找实现</h3><h4 id="散列表查找算法实现"><a href="#散列表查找算法实现" class="headerlink" title="散列表查找算法实现"></a>散列表查找算法实现</h4><p>首先需要定义一个散列表的结构以及一些相关的常数。其中 HashTable 就是散列表结构。结构当中的 elem 为一个动态数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASHSIZE 12<span class="comment">// 定义散列表长为数组的长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULLKEY -32768</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> *elem;<span class="comment">// 数据元素存储基址，动态分配数组</span></span><br><span class="line">  <span class="type">int</span> count;<span class="comment">// 当前数据元素个数</span></span><br><span class="line">&#125;HashTable;</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;<span class="comment">// 散列表表长，全局变量</span></span><br></pre></td></tr></table></figure><p>有了结构的定义，可以对散列表进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化散列表 */</span></span><br><span class="line">Status <span class="title function_">InitHashTable</span><span class="params">(HashTable *H)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  m = HASHSIZE;</span><br><span class="line">  H -&gt; count = m;</span><br><span class="line">  H -&gt; elem = (<span class="type">int</span> *)<span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    H -&gt; elem[i] = NULLKEY;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了插入时计算地址，需要定义散列函数，散列函数可以根据不同情况更改算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 散列函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> key % m;<span class="comment">// 除留余数法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化完成后，可以对散列表进行插入操作。设计插入的关键字集合就是前面的 {12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34}。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入关键字进行散列表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertHash</span><span class="params">(HashTable *H, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> addr = Hash(key);<span class="comment">// 求散列地址</span></span><br><span class="line">  <span class="keyword">while</span>(H -&gt; elem[addr] != NULLKEY)<span class="comment">// 如果不为空，则冲突</span></span><br><span class="line">    addr = (addr + <span class="number">1</span>) % m;<span class="comment">// 开放定址法的线性探测</span></span><br><span class="line">  H -&gt; elem[addr] = key;<span class="comment">// 直到有空位后插入关键字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中插入关键字时，首先算出散列地址，如果当前地址不为空关键字，则说明有冲突。此时应用开放定址法的线性探测进行重新寻址，此处也可更改为链地址法等其它解决冲突的办法。</p><p>散列表存在后，在需要时就可以通过散列表查找要的记录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 散列表查找关键字 */</span></span><br><span class="line">Status <span class="title function_">SearchHash</span><span class="params">(HashTable H, <span class="type">int</span> key, <span class="type">int</span> *addr)</span> &#123;</span><br><span class="line">  *addr = Hash(key);<span class="comment">// 求散列地址</span></span><br><span class="line">  <span class="keyword">while</span>(H.elem[*addr] != key) &#123;<span class="comment">// 如果不为空，则冲突</span></span><br><span class="line">    *addr = (*addr + <span class="number">1</span>) % m;<span class="comment">// 开放定址法的线性探测</span></span><br><span class="line">    <span class="keyword">if</span>(H.elem[*addr] == NULLKEY || *addr == Hash(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> UNSUCCESS;<span class="comment">// 则说明关键字不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找的代码与插入的代码非常相似，只需做一个不存在关键字的判断而已。</p><h4 id="散列表查找性能分析"><a href="#散列表查找性能分析" class="headerlink" title="散列表查找性能分析"></a>散列表查找性能分析</h4><ol><li><p><strong>散列函数是否均匀</strong></p><p> 散列函数的好坏直接影响着出现冲突的频繁程度，不过，由于不同的散列函数对同一组随机的关键字，产生冲突的可能性是相同的，因此我们可以不考虑它对平均查找长度的影响。</p></li><li><p><strong>处理冲突的方法</strong></p><p> 相同的关键字、相同的散列函数，但处理冲突的方法不同，会是的平均查找长度不同。比如线性探测处理冲突可能会产生堆积，显然就没有二次探测法好，而链地址法处理冲突不会产生任何堆积，因而具有更佳的平均查找性能。</p></li><li><p><strong>散列表的装填因子</strong></p><p> 所谓的装填因子 𝛂 &#x3D; 填入表中的记录个数 &#x2F; 散列表长度。𝛂 标志着散列表的装满的程度。当填入表中的记录越多，𝛂 就越大，产生冲突的可能性就越大。比如前面的例子，如果你的散列表长度是 12，而填入表中的记录个数为 11，那么此时的装填因子 𝛂 &#x3D; 11 &#x2F; 12 &#x3D; 0.9167，再填入最后一个关键字产生冲突的可能性就非常之大。也就是说，散列表的平均查找长度取决于装填因子，而不是取决于查找集合中的记录个数。</p><p> 不管记录个数 n 有多大，我们总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围之内，此时我们散列查找的时间复杂度就真的是 O(1) 了。为了做到这一点，通常我们都是将散列表的空间设置得比查找集合大，此时虽然是浪费了一定的空间，但换来的是查找效率的大大提升，总的来说，还是非常值得的。</p></li></ol><h3 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h3><p>这一章的主题是 “查找” 。</p><p>首先，弄清楚查找表、记录、关键字、主关键字、静态查找表、动态查找表等概念。</p><p>然后，对于顺序表查找来说，尽管很简单，但它却是后面很多查找的基础，注意设置“哨兵”的技巧，可以使得本已经很难提升的算法里还是提高了性能。</p><p>有序查找，着重折半查找的思想，它在性能上比原来的顺序查找有了质的飞跃，由 O(n) 变成了 O(logn)。接着映出了两种优秀的有序查找：插值查找和斐波那契查找，它们三者各有优缺点。</p><p>线性索引查找，介绍了稠密索引、分块索引和倒排索引。索引技术被广泛的用于文件检索、数据库和搜索引擎等技术领域，是进一步学习这些技术的基础。</p><p>二叉排序树是动态查找最重要的数据结构，他可以在兼顾查找性能的基础上，让插入和删除也变得效率较高。不过为了达到最优的状态，二叉排序树是构造成平衡的二叉树才最佳。因此需要在学习关于平衡二叉树的数据结构，了解 AVL 树是如何处理平衡性的问题。</p><p>B 树这种数据结构是针对内存与外存之间的存取而专门设计的。由于内外存的查找性能更多取决于读取的次数，因此在设计中要考虑 B 树的平衡和层次。先通过最简单的 2-3 树来理解如果构建、插入、删除元素的操作，再通过 2-3-4 树的深化，最终来理解 B 树的原理，之后 介绍了 B+ 树的设计思想。</p><p>散列表是一种非常搞笑的查找数据结构，在原理上也与前面的查找不尽相同，它回避了关键字之间反复比较的繁琐，而是直接一步到位查找结果。当然，这也就带来了记录之间没有任何关联的弊端。应该说，散列表对于那种查找性能要求高，记录之间关系无要求的数据有非常好的适用性。在学习中要注意的是散列函数的选择和处理冲突的方法。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="排序的基本概念与分类"><a href="#排序的基本概念与分类" class="headerlink" title="排序的基本概念与分类"></a>排序的基本概念与分类</h3><blockquote><p>假设含有 n 个记录的序列为 {r<sub>1</sub>, r<sub>2</sub>, ···, r<sub>n</sub>}，其相应的关键字分别为 {k<sub>1</sub>, k<sub>2</sub>, ···, k<sub>n</sub>}，需确定 1，2，……，n 的一种排列 p<sub>1</sub>, p<sub>2</sub>, ···, p<sub>n</sub>，使其相应的关键字满足 k<sub>p1</sub> ≤ k<sub>p2</sub> ≤ …… ≤ k<sub>pn</sub> (非递减或递增) 关系，即使得序列成为一个按关键字有序的序列{r<sub>p1</sub>, r<sub>p2</sub>, ···, r<sub>pn</sub>}，这样的操作就称为排序。</p></blockquote><p>注意在排序问题中，通常将数据元素成为记录。显然输入的是一个记录集合，输出的也是一个记录集合，所以说，可以将排序看成是线性表的一种操作。</p><p>排序的一句是关键字之间的大小关系，那么，对于一个记录集合，针对不同的关键字进行排序，可以得到不同序列。</p><h4 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h4><p>也正是由于排序不仅是针对主关键字，那么对于次关键字，因为待排序的记录序列中可能存在两个或两个以上的关键字相等的记录，排序结果可能会存在不唯一的情况，给出了稳定与不稳定排序的定义。</p><p><strong>假设 k<sub>i</sub> &#x3D; k<sub>j</sub> (1 ≤ i ≤n, 1 ≤ j ≤ n, i ≠ j)，且在排序前的序列中 r<sub>i</sub> 领先于 r<sub>j</sub> (即 i &lt; j)。如果排序后 r<sub>i</sub> 仍领先于 r<sub>j</sub>，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中 r<sub>j</sub> 领先 r<sub>i</sub> ，则称所用的排序方法是不稳定的</strong>。</p><h4 id="内排序与外排序"><a href="#内排序与外排序" class="headerlink" title="内排序与外排序"></a>内排序与外排序</h4><p>根据在排序过程中待排序的记录是否全部被放置在内存中，排序分为：内排序和外排序。</p><p><strong>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行</strong>。</p><p>对于内排序来说，排序算法的性能主要是受 3 个方面影响：</p><ol><li><p><strong>时间性能</strong></p><p> 排序是数据处理中经常执行的一种操作，往往属于系统的核心部分，因此排序算法的时间开销是衡量其好坏的最重要的标志。在内排序中，主要进行两种操作：比较和移动。比较指关键字之间的比较，这是要做排序最起码的操作。移动指记录从一个位置移动到另一个位置，事实上，移动可以通过改变记录的存储方式来予以避免。总之，搞笑路的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。</p></li><li><p><strong>辅助空间</strong></p><p> 评价排序算法的另一个主要标准是执行算法所需要的辅助存储空间。辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。</p></li><li><p><strong>算法的复杂性</strong></p><p> 注意这里指的是算法本身的复杂度，而不是指算法的时间复杂度。显然算法过于复杂也会影响排序的性能。</p><p> 根据排序过程中截住的主要操作，把<strong>内排序分为：插入排序、交换排序、选择排序和归并排序</strong>。可以说，这些都是比较成熟的排序技术，已经被广泛地应用于许多的程序语言或数据库当中，甚至他们都已经封装了关于排序算法的实现代码。因此，学习这些排序算法的目的更多并不是为了去在现实中编程排序算法，而是通过学习来提升我们编写算法的能力，以便于去解决更多复杂和灵活的应用性问题。</p></li></ol><h4 id="排序用到的结构与函数"><a href="#排序用到的结构与函数" class="headerlink" title="排序用到的结构与函数"></a>排序用到的结构与函数</h4><p>为了讲清楚排序算法的代码，先提供一个用于排序用的顺序表结构，此结构也将用于之后的所有排序算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 10<span class="comment">// 用于要排序数组个数最大值，可根据需要修改</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> r[MAXSIZE + <span class="number">1</span>];<span class="comment">// 用于存储要排序数组，r[0] 用作哨兵或临时变量</span></span><br><span class="line">  <span class="type">int</span> length;<span class="comment">// 用于记录顺序表的长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>另外，由于排序最长用到的操作是数组两元素的交换，将它写成函数，在之后会大量用到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 交换 L 中数组 r 的下标为 i 和 j 的值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(SqList *L, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">  <span class="type">int</span> temp = L -&gt; r[i];</span><br><span class="line">  L -&gt; r[i] = L -&gt; r[j];</span><br><span class="line">  L -&gt; r[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="最简单排序实现"><a href="#最简单排序实现" class="headerlink" title="最简单排序实现"></a>最简单排序实现</h4><p><strong>冒泡排序 (Bubble Sort) 一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止</strong>。冒泡的视线在细节上可以有很多变化，我们将分别就 3 中不同的冒泡实现代码，来讲解冒泡排序的思想。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作交换排序 (冒泡排序初级版) */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort0</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; L -&gt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt;= L -&gt; length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(L -&gt;r[i] &gt; L -&gt; r[j]) &#123;</span><br><span class="line">        swap(L, i, j);<span class="comment">// 交换 L -&gt; r[i] 与 L -&gt; r[j] 的值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort1</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; L -&gt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(j = L -&gt; length - <span class="number">1</span>; j &gt;= i; j--) &#123;<span class="comment">// 注意 j 是从后往前循环</span></span><br><span class="line">      <span class="keyword">if</span>(L -&gt; r[j] &gt; L -&gt; r[j +<span class="number">1</span>]) &#123;<span class="comment">// 若前者大于后者 (注意这里与上一算法差异)</span></span><br><span class="line">        swap(L, j, j + <span class="number">1</span>);<span class="comment">// 交换 L -&gt; r[j] 与 L -&gt; r[j + 1] 的值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="冒泡排序优化"><a href="#冒泡排序优化" class="headerlink" title="冒泡排序优化"></a>冒泡排序优化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作改进冒泡算法 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort2</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  Status flag = TRUE;<span class="comment">// flag 用来作为标记</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; L -&gt; length &amp;&amp; flag; i++) &#123;<span class="comment">// 若 flag 为 true 则退出循环</span></span><br><span class="line">    flag = FLASE;<span class="comment">// 初始化为 false</span></span><br><span class="line">    <span class="keyword">for</span>(j = L -&gt; length - <span class="number">1</span>; j &gt;= i; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span>(L -&gt; r[j] &gt; L -&gt; r[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(L, j, j + <span class="number">1</span>);<span class="comment">// 交换 L -&gt; r[j] 与 L -&gt; r[j + 1] 的值</span></span><br><span class="line">        flag = TRUE;<span class="comment">// 如果有数据交换，则 flag 为 true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码改动的关键就是在 i 变量的 for 循环中，增加了对 flag 是否为 true 的判断。经过这样的改进，冒泡排序在性能上就有了一些提升，可以避免因已经有序的情况下的无意义循环判断。</p><h4 id="冒泡排序复杂度分析"><a href="#冒泡排序复杂度分析" class="headerlink" title="冒泡排序复杂度分析"></a>冒泡排序复杂度分析</h4><p>分析一下他的时间复杂度。当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据最后改进的代码，可以推断出就是 n - 1 次的比较，没有数据交换，时间复杂度为 O(n)。当最坏的情况，即待排序表是逆序的情况，此时需要比较n(n - 1) &#x2F; 2 次，并作等数量级的记录移动。因此，总的时间复杂度为 O(n<sup>2</sup>)。</p><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><h4 id="简单选择排序算法"><a href="#简单选择排序算法" class="headerlink" title="简单选择排序算法"></a>简单选择排序算法</h4><p><strong>简单选择排序法 (Simple Selection Sort) 就是通过 n - i 次关键字间的比较，从 n - i + 1 个记录中选出关键字最小的记录，并和第 i (1 ≤ i ≤ n) 个记录交换之</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作简单选择排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j, min;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; L -&gt; length; i++) &#123;</span><br><span class="line">    min = i;<span class="comment">// 将当前下标定义为最小值下标</span></span><br><span class="line">    <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; L -&gt; length; j++) &#123;<span class="comment">// 循环之后的数据</span></span><br><span class="line">      <span class="keyword">if</span>(L -&gt; r[min] &gt; L -&gt; r[j])<span class="comment">// 如果有小于当前最小值的关键字</span></span><br><span class="line">        min = j;<span class="comment">// 将此关键字的下标赋值给 min</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i != min)<span class="comment">// 若 min 不等于 i，说明找到最小值，交换</span></span><br><span class="line">      swap(L, i, min);<span class="comment">// 交换 L -&gt; r[i] 与 L -&gt; r[min] 的值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单选择排序复杂度分析"><a href="#简单选择排序复杂度分析" class="headerlink" title="简单选择排序复杂度分析"></a>简单选择排序复杂度分析</h4><p>从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，第 i 躺排序需要进行 n - i 次关键字的比较，此时需要比较 n(n - 1) &#x2F; 2 次。而对于交换次数而言，当最好的时候，交换为 0 次，最差的时候，也就初始降序时，交换次数为 n - 1 次，基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为 O(n<sup>2</sup>)。</p><p>应该说，尽管与冒泡排序同为 O(n<sup>2</sup>)，但简单选择排序的性能上还是要优于冒泡排序。</p><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><h4 id="直接插入排序算法"><a href="#直接插入排序算法" class="headerlink" title="直接插入排序算法"></a>直接插入排序算法</h4><p><strong>直接插入排序 (Straight Insertion Sort) 的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增 1 的有序表</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作直接插入排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= L -&gt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(L -&gt; r[i] &lt; L -&gt; r[i - <span class="number">1</span>]) &#123;<span class="comment">// 需将 L -&gt; r[i] 插入有序子表</span></span><br><span class="line">      L -&gt; r[<span class="number">0</span>] = L -&gt; r[i];<span class="comment">// 设置哨兵</span></span><br><span class="line">      <span class="keyword">for</span>(j = i - <span class="number">1</span>; L -&gt; r[j] &gt; L -&gt; r[<span class="number">0</span>]; j--)</span><br><span class="line">        L -&gt; r[j + <span class="number">1</span>] = L -&gt; r[j];<span class="comment">// 记录后移</span></span><br><span class="line">      L -&gt; r[j + <span class="number">1</span>] = L -&gt; r[<span class="number">0</span>];<span class="comment">// 插入到正确位置</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="直接插入排序复杂度分析"><a href="#直接插入排序复杂度分析" class="headerlink" title="直接插入排序复杂度分析"></a>直接插入排序复杂度分析</h4><p>从空间上看，它只需要一个记录的辅助空间，因此关键是看它的时间复杂度。</p><p>当最好的情况下，也就是要排序的表本身就是有序的，因此没有移动的记录，时间复杂度为 O(n)。最坏的情况是待排序表是逆序的情况，此时需要比较(n + 2)(n - 1) &#x2F; 2 次，而记录的移动次数也达到最大值 (n + 4)(n - 1) &#x2F; 2 次。</p><p>如果排序记录是随机的，那么根据概率相同的原则，平均比较和移动次数约为 n<sup>2</sup> &#x2F; 4 次。因此，得出直接插入排序法的时间复杂度为 O(n<sup>2</sup>)。从这里也看出，同样的 O(n<sup>2</sup>) 时间复杂度，直接插入排序比冒泡和简单选择排序性能要好一些。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>在这之前的排序算法的时间复杂度基本都是 O(n<sup>2</sup>) 的，希尔排序算法是突破这个时间复杂度的第一批算法之一。</p><p>直接插入排序的效率在某些时候是很高的，比如，记录本身就是基本有序的，只需要少量的插入操作，就可以完成整个记录集的排序工作，此时直接插入很高效。还有就是记录数比较少时，直接插入的优势也比较明显。可问题在于，两个条件本身就过于苛刻，现实中记录少或者基本有序都属于特殊情况。</p><p>科学家希尔研究出一种排序算法，对直接插入排序改进后可以增加效率。为了让待排序的记录个数较少？将原本有大量记录数的记录进行分组。分割成若干个字序列，此时每个字序列待排序的记录个数就比较少了，然后在这些字序列内分别进行直接插入排序，当整个序列都基本有序时，注意只是基本有序时，再对全体记录进行一次直接插入排序。<strong>所谓基本有序，就是小的关键字基本在前，大的基本在后面，不大不小的基本在中间，像{2, 1, 3, 6 ,4, 7, 5, 8, 9}</strong> 这样可以成为基本有序。问题其实也在这里，分割待排序记录的目的是为了减少待排序记录的个数，并使整个序列项基本有序发展。然后有些时候分完组后就各自排序的方法达不到要求。因此，需要采取跳跃分割的策略：<strong>将相距某个”增量“的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序</strong>。</p><h4 id="希尔排序算法"><a href="#希尔排序算法" class="headerlink" title="希尔排序算法"></a>希尔排序算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作希尔排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="type">int</span> increment = L -&gt; length;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    increment = increment / <span class="number">3</span> + <span class="number">1</span>;<span class="comment">// 增量序列</span></span><br><span class="line">    <span class="keyword">for</span>(i = increment + <span class="number">1</span>; i &lt;= L -&gt; length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(L -&gt; r[i] &lt; L -&gt; r[i - increment]) &#123;<span class="comment">// 需将 L -&gt; r[i] 插入有序增量字表</span></span><br><span class="line">        L -&gt; r[<span class="number">0</span>] = L -&gt; r[i];<span class="comment">// 暂存在 L -&gt; r[0]</span></span><br><span class="line">        <span class="keyword">for</span>(j = i - increment; j &gt; <span class="number">0</span> &amp;&amp; L -&gt; r[<span class="number">0</span>] &lt; L -&gt; r[j]; j -= increment)</span><br><span class="line">          L -&gt; r[j + increment] = L -&gt; r[j];<span class="comment">// 记录后移，查找插入位置</span></span><br><span class="line">        L -&gt; r[j + increment] = L -&gt; r[<span class="number">0</span>];<span class="comment">// 插入</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(increment &gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="希尔排序复杂度分析"><a href="#希尔排序复杂度分析" class="headerlink" title="希尔排序复杂度分析"></a>希尔排序复杂度分析</h4><p>通过这段代码的剖析，希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个字序列，实现跳跃式的移动，使得排序的效率提高。</p><p>这里的“增量”的选取就非常关键了。可究竟应该选取什么样的增量才是最好的，目前还是一个数学难题，迄今为止还没有人找到一个最好的增量序列。不过大量的研究表明，当增量序列为 dlta[k] &#x3D; 2<sup>t - k + 1</sup> - 1 (0 ≤ k ≤ t ≤ log<sub>2</sub>(n + 1)) 时，可以获得不错的效率，其时间复杂度为 O(n<sup>3 &#x2F; 2</sup>)，要好于直接排序的 O(n<sup>2</sup>)。需要注意的是，<strong>增量序列的最后一个增量值必须等于 1 才行</strong>。另外由于记录是跳跃式的移动，希尔排序并不是一种稳定的排序算法。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>简单选择排序，它在待排序的的 n 个记录中选择最小的记录需要比较 n - 1 次。可惜的是，这样的操作并没有把每一趟的比较结果保存下来，在后一趟的比较中，有许多比较在前一趟已经做过了，但由于前一趟排序时未保存这些比较结果，所以以后一趟排序时又重复执行了这些比较操作，因而记录的比较次数较多。</p><p>如果可以做到每次在选择到最小记录的同时，并根据比较结果对其他记录做出相应的调整，那样排序的总体效率就会非常高了。而堆排序 (Heap Sort)，就是对简单选择排序进行的一种改进，这种改进的效果是非常明显的。堆排序算法是 Floyd 和 Williams 在 1964 年共同发明的，同时，他们发明了 ”堆“ 这样的数据结构。</p><p><strong>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</strong>。</p><h4 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h4><p><strong>堆排序 (Heap Sort)</strong> 就是利用堆 (假设利用大顶堆) 进行排序的方法。它的基本思想是，<strong>将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走 (其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的 n - 1 个序列重新构造成一个堆，这样就会得到 n 个元素中的次小值。如果反复执行，便能得到一个有序序列了</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 进行堆排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = L -&gt; length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)<span class="comment">// 把 L 中的 r 构建成一个大顶堆</span></span><br><span class="line">    HeapAdjust(L, i, L -&gt; length);</span><br><span class="line">  <span class="keyword">for</span>(i = L -&gt; length; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">    swap(L, <span class="number">1</span>, i);<span class="comment">// 将堆顶记录和当前未经排序字序列的最后一个记录交换</span></span><br><span class="line">    HeapAdjust(L, <span class="number">1</span>, i - <span class="number">1</span>);<span class="comment">// 将 L -&gt; r[1..i - 1] 重新调整为大顶堆</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，整个排序过程分为两个 for 循环。第一个循环要完成的就是将现在的待排序序列构建成一个大顶堆。第二个循环要完成的就是逐步将每个最大值的根结点与末尾元素交换，并且再调整其成为大顶堆。</p><p>假设要排序的序列是 {50, 10, 90, 30, 70, 40, 80, 60, 20}，那么 L.length &#x3D; 9，第一个 for 循环，代码第 4 行，i 是从 9 &#x2F; 2 &#x3D; 4 开始，4 → 3 → 2 → 1 的变量变化。为什么不是从 1 到 9 或者从 9 到 1，而是从 4 到 1 呢？看了下图就明白了，他们都是有孩子的结点。注意灰色结点的下标编号就是 1、2、3、4。</p><p><img src="http://1.117.162.142:9000/blog/%E5%A0%86%E6%8E%92%E5%BA%8F.png" alt="堆排序"></p><p>所谓的将待排序的序列构建称为一个大顶堆，其实就是从下往上、从右到左，将每个非终端结点 (非叶结点) 当作根结点，将其和其子树调整成大顶堆。i 的 4 → 3 → 2 → 1 的变量变化，其实也就是 30，90，10，50 的结点调整过程。</p><p>既然已经弄清楚 i 的变化是在调整哪些元素了，现在来看关键的 HeadAdjust (堆调整) 函数是如何实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 已知 L -&gt; r[s..m] 中记录的关键字除 L -&gt;r[s] 之外均满足堆的定义 */</span></span><br><span class="line"><span class="comment">/* 本函数调整 L -&gt; r[s] 的关键字，使 L -&gt; r[s..m] 成为一个大顶堆 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapAdjust</span><span class="params">(SqList *L, <span class="type">int</span> s, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">  <span class="type">int</span> temp, j;</span><br><span class="line">  temp = L -&gt; r[s];</span><br><span class="line">  <span class="keyword">for</span>(j = <span class="number">2</span> * s; j &lt;= m; j *= <span class="number">2</span>) &#123;<span class="comment">// 沿关键字较大的孩子结点向下筛选</span></span><br><span class="line">    <span class="keyword">if</span>(j &lt; m &amp;&amp; L -&gt; r[j] &lt; L -&gt; r[j + <span class="number">1</span>])</span><br><span class="line">      ++j;<span class="comment">// j 为关键字中较大的记录的下标</span></span><br><span class="line">    <span class="keyword">if</span>(temp &gt;= L -&gt; r[j])</span><br><span class="line">      <span class="keyword">break</span>;<span class="comment">// rc 应插入在位置 s 上</span></span><br><span class="line">    L -&gt; r[s] = L -&gt; r[j];</span><br><span class="line">    s = j;</span><br><span class="line">  &#125;</span><br><span class="line">  L -&gt; r[s] = temp;<span class="comment">// 插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆排序复杂度分析"><a href="#堆排序复杂度分析" class="headerlink" title="堆排序复杂度分析"></a>堆排序复杂度分析</h4><p>它的运行时间主要是消耗在初始构建堆和在重建堆时的反复筛选上。在构建堆的过程中，因为是完全二叉树从最下层最右边的非终端结点开始构建，将它与其孩子进行比较和若有必要的互换，对于每个非终端结点来说，其实最多进行两次比较和互换操作，因此整个构建堆的时间复杂度为 O(n)。</p><p>在正式排序时，第 i 次取堆顶记录重建堆需要用 O(logi) 的时间 (完全二叉树的某个结点到根结点的距离为 log<sub>2</sub>i + 1)，并且须要取 n - 1 次堆顶记录，因此，重建堆的时间复杂度为 O(nlogn)。</p><p>所以总体来说，堆排序的时间复杂度为 O(nlogn)。由于堆排序对原始记录的排序状态并不敏感，因此它无论是最好、最坏和平均时间复杂度均为 O(nlogn)。这在性能上显然要远远好过于冒泡、简单选择、直接插入的 O(n<sup>2</sup>) 的时间复杂度了。</p><p>空间复杂度上，它只有一个用来交换的暂存单元，也非常不错。不过由于记录的比较与交换是跳跃式进行，因此堆排序也是一种不稳定的排序方法。另外，由于初始构建堆所需的比较次数较多，因此，它并不适合待排序序列个数较少的情况。</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="归并排序算法"><a href="#归并排序算法" class="headerlink" title="归并排序算法"></a>归并排序算法</h4><p>“归并” 一词的中文含义就是合并、并入的意思，而在数据结构中的定义是将两个或两个以上的有序表组合成一个新的有序表。</p><p><strong>归并排序 (Merging Sort)</strong> 就是利用归并的思想实现的排序方法。它的原理是<strong>假设初始序列含有 n 个记录，则可与看成是 n 个有序的字序列，每个字序列的长度为 1，然后两两归并，得到 ⎡n&#x2F;2⎤ (⎡x⎤ 表示不小于 x 的最小整数) 个长度为 2 或 1 的有序字序列；再两两归并，……，如此重复，直至得到一个长度为 n 的有序序列为止，这种排序方法称为 2 路归并排序</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作归并排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  MSort(L -&gt; r, L -&gt; r, <span class="number">1</span>, L -&gt; length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了与前面的排序算法同意，用了同样的参数定义 SqList *L，由于归并排序实现需要用到递归调用，因此在外封装了一个函数。假设现在要对数组 {50, 10, 90, 30, 70, 40, 80, 60, 20}  进行排序，L.length &#x3D; 9。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将 SR[s..t] 归并排序为 TR1[s..t] */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MSort</span><span class="params">(<span class="type">int</span> SR[], <span class="type">int</span> TR1[], <span class="type">int</span> s, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">  <span class="type">int</span> m;</span><br><span class="line">  <span class="type">int</span> TR2[MAXSIZE + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span>(s == t)</span><br><span class="line">    TR1[s] = SR[s];</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    m = (s + t) / <span class="number">2</span>;<span class="comment">// 将 SR[s..t] 平分为 SR[s..m] 和 SR[m + 1..t]</span></span><br><span class="line">    MSort(SR, TR2, s, m);<span class="comment">// 递归将 SR[s..m] 归并为有序的 TR2[s..m]</span></span><br><span class="line">    MSort(SR, TR2, m + <span class="number">1</span>, t);<span class="comment">// 递归将 SR[m + 1..t] 归并为有序 TR2[m + 1..t]</span></span><br><span class="line">    Merge(TR2, TR1, s, m, t);<span class="comment">// 将 TR2[s..m] 和 TR2[m + 1..t] 归并到 TR1[s..t]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Merge 函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将有序的 SR[i..m] 和 SR[m + 1..n] 归并为有序的 TR[i..n] */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> SR[], <span class="type">int</span>. TR[], <span class="type">int</span> i, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j, k, l;</span><br><span class="line">  <span class="keyword">for</span>(j = m + <span class="number">1</span>, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++) &#123;<span class="comment">// 将 SR 中记录由小到大并入 TR</span></span><br><span class="line">    <span class="keyword">if</span>(SR[i] &lt; SR[j])</span><br><span class="line">      TR[k] = SR[i++];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      TR[k] = SR[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i &lt;= m) &#123;</span><br><span class="line">    <span class="keyword">for</span>(l = <span class="number">0</span>; l &lt; = m - <span class="number">1</span>; l++) </span><br><span class="line">      TR[k + <span class="number">1</span>] = SR[i + <span class="number">1</span>];<span class="comment">// 将剩余的 SR[i..m] 复制到 TR</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(j &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">for</span>(l = <span class="number">0</span>; l &lt;= n - j; l++)</span><br><span class="line">      TR[k + l] = SR[j + l];<span class="comment">// 将剩余的 SR[j..n] 复制到 TR</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序复杂度分析"><a href="#归并排序复杂度分析" class="headerlink" title="归并排序复杂度分析"></a>归并排序复杂度分析</h4><p>分析归并排序的时间复杂度，一趟归并需要将 SR[1]<del>SR[n] 中相邻的长度为 h 的有序序列进行两两归并。并将结果放到 TR1[1]</del>TR1[n] 中，这需要将待排序序列中的所有记录扫描一遍，因此耗费 O(n) 时间，而由完全二叉树的深度可知，整个归并排序需要进行 ⎡log<sub>2</sub>n⎤次，因此，总的时间复杂度为 O(nlogn)，而且这是归并排序算法中最好、最坏、平均的时间性能。</p><p>由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为 log<sub>2</sub>n 的栈空间，因此空间复杂度 O(n + logn)。</p><p>另外，对代码进行仔细研究，发现 Merge 函数中有 if(SR[i] &lt; SR[j]) 语句，这就说明它需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。</p><p>也就是说，归并排序是一种比较占用内存，但却效率高且稳定的算法。</p><h4 id="非递归实现归并排序"><a href="#非递归实现归并排序" class="headerlink" title="非递归实现归并排序"></a>非递归实现归并排序</h4><p>归并排序大量引用了递归，尽管在代码上比较清晰，容易理解，但这会造成时间和空间上的性能损耗。排序追求的就是效率，有没有可能将递归转化成迭代呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 作归并非递归排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort2</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span>* TR = (<span class="type">int</span>*)<span class="built_in">malloc</span>(L -&gt; length * <span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">// 申请额外空间</span></span><br><span class="line">  <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(k &lt; L -&gt; length) &#123;</span><br><span class="line">    MergePass(L -&gt; r, TR, k, L -&gt; length);</span><br><span class="line">    k = <span class="number">2</span> * k;<span class="comment">// 字序列长度加倍</span></span><br><span class="line">    MergePass(TR, L -&gt; r, k, L -&gt; length);</span><br><span class="line">    k = <span class="number">2</span> * k;<span class="comment">// 字序列长度加倍</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MergePass 实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将 SR[] 中相邻长度为 s 的子序列两两归并到 TR[] */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergePass</span><span class="params">(<span class="type">int</span> SR[], <span class="type">int</span> TR[], <span class="type">int</span> s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  <span class="keyword">while</span>(i &lt;= n - <span class="number">2</span> * s + <span class="number">1</span>) &#123;</span><br><span class="line">    Merge(SR, TRk i, i + s - <span class="number">1</span>, i + <span class="number">2</span> * s - <span class="number">1</span>);<span class="comment">// 两两归并</span></span><br><span class="line">    i = i + <span class="number">2</span> * s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i &lt; n -s + <span class="number">1</span>)<span class="comment">// 归并最后两个序列</span></span><br><span class="line">    Merge(SR, TR, i, i + s - <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">else</span><span class="comment">// 若最后只剩下单个子序列</span></span><br><span class="line">    <span class="keyword">for</span>(j = i; j &lt;= n; j++)</span><br><span class="line">      TR[j] = SR[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>快速排序 (Quick Sort) 的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的</strong>。</p><p>假设现在要对数组 {50, 10, 90, 30, 70, 40, 80, 60, 20} 进行排序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对顺序表 L 作快速排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(SqList *L)</span> &#123;</span><br><span class="line">  QSort(L, <span class="number">1</span>, L -&gt; length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QSort</span><span class="params">(SqList *L, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pivot;</span><br><span class="line">  <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">    pivot = Partition(L, low, high);<span class="comment">// 将 L -&gt; r[low..high] 一分为二，算出枢轴值 pivot</span></span><br><span class="line">    QSort(L, low, pivot - <span class="number">1</span>);<span class="comment">// 对低子表递归排序</span></span><br><span class="line">    QSort(L, pivot + <span class="number">1</span>, high);<span class="comment">// 对高子表递归排序</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里的 <code>QSort(L, 1, L -&gt; length);</code> 中 1 和 L -&gt; length 相当于当前待排序的序列最小下标值 low 和最大下标值 high。</p><p>这一段代码的核心是<code>pivot = Partition(L, low, high);</code> 在执行它之前，L.r 的数组值为 {50, 10, 90, 30, 70, 40, 80, 60, 20} 。<strong>Partition 函数要做的，就是先选取当中的一个关键字</strong>，比如选择第一个关键字 50，然后**想尽办法将它放到一个位置，使得它左边的值都比它小，右边的值比它大，将这样的关键字称为枢轴 (pivot)**。</p><p>Partition 函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 交换顺序表 L 中子表的记录，使枢轴记录到位，并返回其所在位置。此时在它之前 (后) 的记录均不大 (小) 于它 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(SqList *L, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pivotkey;</span><br><span class="line">  pivotkey = L -&gt; r[low];<span class="comment">// 用子表的第一个记录作枢轴记录</span></span><br><span class="line">  <span class="keyword">while</span>(low &lt; high) &#123;<span class="comment">// 从表的两端交替向中间扫描</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; L -&gt; r[high] &gt;= pivotkey)</span><br><span class="line">      high--;</span><br><span class="line">    swap(L, low, high);<span class="comment">// 将比枢轴记录小的记录交换到低端</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; L -&gt; r[low] &lt;= pivotkey)</span><br><span class="line">      low++;</span><br><span class="line">    swap(L, low, high);<span class="comment">// 将比枢轴记录大的记录交换到高端</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> low;<span class="comment">// 返回枢轴所在位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速排序复杂度分析"><a href="#快速排序复杂度分析" class="headerlink" title="快速排序复杂度分析"></a>快速排序复杂度分析</h4><p>快速排序的时间性能取决于快速排序递归的深度，可以用递归树来描述递归算法的执行情况。{50, 10, 90, 30, 70, 40, 80, 60, 20} 在快速排序过程中，第一个关键字是 50，正好是待排序的序列的中间值，因此递归树是平衡的，此时性能也比较好。如下图</p><p><img src="http://1.117.162.142:9000/blog/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.png" alt="快速排序复杂度分析"></p><p>在最优情况下，Partition 每次都划分得很均匀，如果排序 n 个关键字，其递归树的深度就为 ⎣log<sub>2</sub>n⎦+ 1 (⎣x⎦表示不大于 x 的最大整数)，即仅需递归 log<sub>2</sub>n 次，需要时间为 T(n) 的话，第一次 Partition 应该是需要对整个数组扫描一遍，作 n 次比较。然后，获得的枢轴将数组一分为二，那么各自还需要 T(n &#x2F; 2) 的时间 (注意是最好情况，所以平分两半)。于是不断地划分下去。也就是说，在最优的情况下，快速排序算法的时间复杂度为 O(nlogn)。</p><p>在最坏的情况下，待排序的序列为正序或逆序，每次划分只得到一个比上一次划分少一个记录的子序列，注意另一个为空。如果递归树画出来，他就是一棵斜树。此时需要执行 n - 1 次递归调用，且第 i 次划分需要经过 n - 1 次关键字的比较才能找到第 i 个记录，也就是枢轴的位置，因此比较次数为 n(n - 1) &#x2F; 2，最终其时间复杂度为 O(n<sup>2</sup>)。</p><p>平均的情况，设枢轴的关键字应该在第 k 的位置 (1 ≤ k ≤ n)，由数学归纳法可证明，其数量级为 O(nlogn)。</p><p>就空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归树的深度为 log<sub>2</sub>n，其空间复杂度也就为 O(logn)，最坏情况，需要进行 n - 1 递归调用，其空间复杂度为 O(n)，平均情况，空间复杂度也为 O(logn)。</p><p>可惜的是，由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。</p><h4 id="快速排序优化"><a href="#快速排序优化" class="headerlink" title="快速排序优化"></a>快速排序优化</h4><ol><li><p><strong>优化选取枢轴</strong></p><p> 三数取中 (median-of-three) 法。即取三个关键字先进性排序，将中间数作为枢轴，一般是取左端、右端和中间三个数，也可以随机选取。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pivotkey;</span><br><span class="line"><span class="type">int</span> m = low + (high - low) / <span class="number">2</span>;<span class="comment">// 计算数组中间的元素的下标</span></span><br><span class="line"><span class="keyword">if</span>(L -&gt; r[low] &gt; L -&gt; r[high])</span><br><span class="line">  swap(L, low, high);<span class="comment">// 交换左端与右端数据，保证左端较小</span></span><br><span class="line"><span class="keyword">if</span>(L -&gt; r[m] &gt; L -&gt; r[high])</span><br><span class="line">  swap(L, high, m);<span class="comment">// 交换中间与右端数据，保证中间较小</span></span><br><span class="line"><span class="keyword">if</span>(L -&gt; r[m] &gt; L -&gt; r[low])</span><br><span class="line">  swap(L, m, low);<span class="comment">// 交换中间与左端数据，保证左端较小。此时 L.r[low] 已经为整个序列左中右三个关键字的中间值</span></span><br><span class="line">piovtkey = L -&gt; r[low];</span><br></pre></td></tr></table></figure></li><li><p><strong>优化不必要的交换</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 快速排序优化算法 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition1</span><span class="params">(SqList *L, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pivotkey;</span><br><span class="line">  <span class="comment">// 这里省略三数取中代码</span></span><br><span class="line">  piovtkey = L -&gt; r[low];<span class="comment">// 用子表的第一个记录作枢轴记录</span></span><br><span class="line">  L -&gt; r[<span class="number">0</span>] = pivotkey;<span class="comment">// 将枢轴关键字备份到 L -&gt; r[0]</span></span><br><span class="line">  <span class="keyword">while</span>(low &lt; high) &#123;<span class="comment">// 从表的两端交替向中间扫描</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; L -&gt; r[high] &gt;= pivotkey)</span><br><span class="line">      high--;</span><br><span class="line">    L -&gt; r[low] = L -&gt; r[high];<span class="comment">// 采用替换而不是交换的方式进行操作</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; L -&gt; r[low] &lt;= pivotkey)</span><br><span class="line">      low++;</span><br><span class="line">    L -&gt; r[high] = L -&gt; r[low];<span class="comment">// 采用替换而不是交换的方式进行操作</span></span><br><span class="line">  &#125;</span><br><span class="line">  L -&gt; r[low] = L -&gt; r[<span class="number">0</span>];<span class="comment">// 将枢轴数值替换回 L.r[low]</span></span><br><span class="line">  <span class="keyword">return</span> low;<span class="comment">// 返回枢轴所在位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>优化小数组时的排序方案</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LENGTH_INSERT_SORT 7<span class="comment">// 数组长度阀值</span></span></span><br><span class="line"><span class="comment">/* 对顺序表 L 中的子序列 L.r[low..high] 作快速排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pivot;</span><br><span class="line">  <span class="keyword">if</span>((high - low) &gt; MAX_LENGTH_INSERT_SORT) &#123;<span class="comment">// 当 high - low 大于常数时用快速排序</span></span><br><span class="line">    pivot = Partition(L, low, high);<span class="comment">// 将 L.r[low..high] 一分为二，并算出枢轴值 pivot</span></span><br><span class="line">    QSort(L, low, pivot - <span class="number">1</span>);<span class="comment">// 对低子表递归排序</span></span><br><span class="line">    QSort(L, pivot + <span class="number">1</span>, high);<span class="comment">// 对高子表递归排序</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">// 当 high - low 小于等于常数时用直接插入排序</span></span><br><span class="line">    InsertSort(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 增加了一个判断，当 high - low 不大于某个常数时，就用直接插入排序，这样就能保证最大化地利用两种排序的优势来完成排序工作。</p></li><li><p><strong>优化递归操作</strong></p><p> 递归对性能是有一定影响的，SQort 函数在其尾部有两次递归操作。如果待排序的序列划分极端不平衡，递归深度将趋近于 n，而不是平衡时的 log<sub>2</sub>n，这就不仅仅是速度快慢的问题了。栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。因此如果能减少递归，将会大大提高性能。</p><p> 对 QSort 实施<strong>尾递归</strong>优化：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对顺序表 L 中的子序列 L.r[low..high] 作快速排序 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Qsort1</span><span class="params">(SqList *L, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pivot；</span><br><span class="line">  <span class="keyword">if</span>((high - low) &gt; MAX_LENGTH_INSERT_SORT) &#123;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">      pivot = Partition1(L, low, high);<span class="comment">// L.r[low..high] 一分为二，算出枢轴值 pivot</span></span><br><span class="line">      QSort1(L, low, pivot - <span class="number">1</span>);<span class="comment">// 对低子表递归排序</span></span><br><span class="line">      low = pivot + <span class="number">1</span>;<span class="comment">// 尾递归</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    InsertSort(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当将 if 改成 while 后，因为第一次递归后，变量 low 就没有用处了，所以可以讲 pivot + 1 赋值给 low，再循环后，来一次 <code>Partition(L, low, hith)</code>，其效果等同于 <code>QSort(L, pivot + 1, high)</code>。结果相同，但因采用迭代而不是递归的方法可以缩减堆栈深度，从而提高了整体性能。</p></li><li><p><strong>了不起的排序算法</strong></p><p> 以上算法中，有按照实现方法分类命名的，如简单选择排序、直接插入排序、归并排序，有按照其排序的方式类比现实世界命名的，比如冒泡排序、堆排序，还有用人命命名的，比如希尔排序。但是快速排序却用“快速”命名，也就意味着只要再有人找到更好的排序法，此“快速”就会名不符实，不过，至少今天，TonyHoare 发明的快速排序法经过多次的优化后，在整体性能上，依然是排序算法王者。</p></li></ol><h3 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h3><p>首先根据排序的定义，提到了排序的稳定性，排序稳定对于某些特殊需求来说是至关重要的，因此在排序算法中国呢，需要关注此算法的稳定性如何。</p><p>根据将排序记录是否全部被放置在内存中，将排序分为内排序与外排序两种，外排序需要在内外存之间多次交换数据才能进行。</p><p>根据排序过程中借助的主要操作，将内排序分为：插入排序、交换排序、选择排序和归并排序四类。</p><p><img src="http://1.117.162.142:9000/blog/%E6%8E%92%E5%BA%8F.png" alt="排序"></p><p>事实上，目前还没有十全十美的排序算法，有优点就会有缺点，即使是快速排序法，也只是在整体性能上优越了，它也存在排序不稳定、需要大量辅助空间、对少量数据排序无优势等不足。</p><p>将 7 中算法的各种指标进行对比，如下表。</p><table><thead><tr><th align="center">排序方法</th><th align="center">平均情况</th><th align="center">最好情况</th><th align="center">最坏情况</th><th align="center">辅助空间</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(n)</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">简单选择排序</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">直接插入排序</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(n)</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">希尔排序</td><td align="center">O(nlogn)~O(n<sup>2</sup>)</td><td align="center">O(n<sup>13</sup>)</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">堆排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">归并排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(n)</td><td align="center">稳定</td></tr><tr><td align="center">快速排序</td><td align="center">O(nlogn)</td><td align="center">O(nlogn)</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(logn)~O(n)</td><td align="center">不稳定</td></tr></tbody></table><p>从算法的简单性来看，将 7 种算法分为两类：</p><ul><li>简单算法：冒泡、简单选择、直接插入</li><li>改进算法：希尔、堆、归并、快速</li></ul><p>从平均情况来看，显然最后 3 种改进算法要胜过希尔排序，并远远胜过前 3 种简单算法。</p><p>从最好情况看，反而冒泡和直接插入排序要更胜一筹，也就是说，如果待排序序列总是基本有序，反而不应该考虑 4 种复杂的改进算法。</p><p>从最坏情况看，堆排序与归并排序又强过快速排序以及其它简单排序。</p><p>从这三组时间复杂度的数据对比中，可以得出这样一个人时。堆排序和归并排序就像两个参加奥数考试的优等生，心理素质强，发挥稳定。而快速排序像是很情绪化的天才，心情好时表现极佳，碰到较糟糕环境会变得差强人意。但是他们如果都来比赛计算个位数的加减法，他们反而算不过成绩普通的冒泡和直接插入。</p><p>从空间复杂度来说，归并排序强调要马跑得快，就得给马吃个饱。快速排序也有相应的空间要求，反而堆排序等却都是少量索取，大量付出，对空间要求是 O(1)。如果执行算法的软件所处的环境非常在乎内存使用量的多少，选择归并排序和快速排序就不是一个较好的决策了。</p><p>从稳定性来看，归并排序独占鳌头，对于非常在乎排序稳定性的应用中，归并排序是个好算法。</p><p>从待排序记录的个数上来说，待排序的个数 n 越小，采用简单排序方法越合适。反之，n 越大，采用改进排序方法越合适。这也就是为什么对快速排序优化时，增加了一个阀值，低于阀值时换作直接插入排序的原因。</p><p>从下表的数据中，似乎简单选择排序在 3 种简单排序中性能最差，其实也不完全是，比如，如果记录的关键字本身信息量比较大 (例如，关键字都是数十位的数字)，此时表明占用存储空间很大，这样移动记录所花费的时间也越多。下表是 3 中简单排序算法的移动次数比较。</p><table><thead><tr><th align="center">排序方法</th><th align="center">平均情况</th><th align="center">最好情况</th><th align="center">最坏情况</th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center">O(n<sup>2</sup>)</td><td align="center">0</td><td align="center">O(n<sup>2</sup>)</td></tr><tr><td align="center">简单选择排序</td><td align="center">O(n)</td><td align="center">0</td><td align="center">O(n)</td></tr><tr><td align="center">直接插入排序</td><td align="center">O(n<sup>2</sup>)</td><td align="center">O(n)</td><td align="center">O(n<sup>2</sup>)</td></tr></tbody></table><p>会发现，此时简单选择排序就变得非常有优势，原因在于它是通过大量比较厚选择明确记录进行移动，有的放矢。因此对于数据量不是很大而记录的关键字信息量较大的排序要求，简单排序算法是占优的。另外，记录的关键字信息量大小对那四个改进算法影响不大。</p><p>总之，从综合各项指标来说，经过优化的快速排序是性能最好的排序算法，但是不同的场合也应该考虑使用不同的算法来应对。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2022/07/31/operatingSystem/"/>
      <url>/2022/07/31/operatingSystem/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-1-1-概念、功能和目标"><a href="#1-1-1-概念、功能和目标" class="headerlink" title="1.1.1 概念、功能和目标"></a>1.1.1 概念、功能和目标</h3><p><strong>概念</strong></p><p>操作系统是控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。</p><p><strong>操作系统的功能和目标</strong></p><blockquote><p>进程是一个程序的执行过程。执行前需要将该程序放到内存中，才能被CPU处理。</p></blockquote><ul><li><p>作为系统资源的管理者</p><ul><li>处理机管理：为程序分配CPU资源</li><li>存储器管理：需要把程序相关数据放入内存中的某个位置</li><li>文件管理：对应用程序的相关文件进行分层级的管理</li><li>设备管理：将程序需要的硬件设备划分配给进程或者回收。</li><li>目标：安全、高效</li></ul></li><li><p>作为用户和计算机硬件之间的接口</p><ul><li>提供命令接口：联机命令接口（用户说一句，系统做一句）、脱机命令接口（用户说一堆，系统做一堆）</li><li>提供程序接口（允许用户通过程序间接使用）：由一组系统调用组成（程序接口&#x3D;系统调用）</li><li>提供GUI（图形用户界面）</li><li>目标：方便用户使用</li></ul></li><li><p>作为最接近硬件的层次</p><ul><li>实现对硬件机器的拓展</li></ul></li></ul><p>没有任何软件支持的计算机称为裸机。在裸机上安装的操作系统，可以提供资源管理和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。通常把覆盖了软件的机器称为扩充机器，又称为虚拟机。</p><h3 id="1-1-2-操作系统的特征"><a href="#1-1-2-操作系统的特征" class="headerlink" title="1.1.2 操作系统的特征"></a>1.1.2 操作系统的特征</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。</p><p>并行：指两个或多个事件在同一时刻发生。</p><p>操作系统的并发性指计算机系统中同时存在着多个运行着的程序。</p><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>共享即资源共享，是指系统中的资源可提供内存中多个并发执行的进程共同使用。</p><p>资源共享方式</p><ul><li><p>互斥共享方式</p><p>  系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源</p></li><li><p>同时共享方式</p><p>  系统中的某些资源，允许一个时间段内有多个进程“同时”对他们进行访问</p><p>  所谓的”同时“往往是宏观上的，而在微观上，这些进程可能是交替地对资源进行访问的（即分时复用）</p></li></ul><p><strong>并发性和共享性互为存在条件</strong>。如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义。如果失去共享性，则两个或多个程序不能同时访问硬盘资源，就无法实现比如同时发送文件，也就无法并发。</p><h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p><blockquote><p>一个程序需要放入内存并给它分配CPU才能执行。虚拟技术中的“时分复用技术”，微观上处理机在各个微小的时间段内交替着为各个进程服务。</p></blockquote><p>虚拟技术可分为空分复用技术（如虚拟存储区技术）和时分复用技术（如虚拟处理器）。如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<strong>没有并发性，就谈不上虚拟性</strong>。 </p><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>异步是指在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><p>如果失去了并发性，则系统只能串行地处理各个进程，每个进程的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。</p><h3 id="1-1-3-操作系统的发展和分类"><a href="#1-1-3-操作系统的发展和分类" class="headerlink" title="1.1.3 操作系统的发展和分类"></a>1.1.3 操作系统的发展和分类</h3><h4 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h4><p>手工操作阶段人们将程序写到纸带上，通过在纸带上打孔来区分0&#x2F;1。计算机通过读取纸带上的程序来执行，执行完后再将程序结果打印在纸带上。计算机读取和打印结果的过程很慢（输入&#x2F;输出慢），但是执行程序的时间很快（处理速度快）。</p><p>主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低。</p><h4 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h4><ul><li><p>单道批处理系统</p><p>  引入脱机输入&#x2F;输出技术（用磁带完成），并<strong>监督程序</strong>（操作系统的雏形）负责控制作业的输入、输出。</p><p>  程序员先将自己在纸带上的程序通过外围机读到磁带上面，计算机读取磁带里的程序进行执行，并将执行结果输出到磁带中，程序员再通过外围机将程序输出带纸带上。</p></li></ul><p>优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。</p><p>缺点：内存中仅能有一道程序运行，只有该程序运行结束后才能调入下一道程序。<strong>CPU仍有大量的时间是在空闲等待I&#x2F;O完成</strong>。资源利用率依然很低。</p><ul><li><p>多道批处理系统</p><p>   在单道批处理系统的基础上，每次网内存中输入多道程序，操作系统正式诞生，并引入了中断技术，有操作系统负责管理这些程序的运行。各个程序并发执行。</p></li></ul><p>优点：多道程序并发执行，贡献计算机资源。资源利用率大幅提升，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。</p><p>缺点：用户响应时间长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行）</p><h4 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h4><p>计算机以时间片为单位轮流为各个用户&#x2F;作业服务，各个用户可通过终端与计算机进行交互。</p><p>优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p><p>缺点：不能优先处理一些紧急任务。操作系统对各个用户&#x2F;作业都是完全公平的，循环地为每个用户&#x2F;作业一个时间片，不区分任务的紧急性。</p><h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><p>优点：能够优先响应一些紧急任务，某些紧急任务不需要时间片排队。</p><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。</p><ul><li>硬实时系统：必须在绝对严格的规定时间内完成处理（如：导弹控制系统、自动驾驶系统）</li><li>软实时系统：能接受偶尔违反时间规定（如：12306火车订票系统）</li></ul><h4 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h4><p>是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows NT就是一种典型的网络操作系统，网站服务器就可以使用）</p><h4 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h4><p>主要特点是分布性和并发性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由他们并行、协同完成这个任务。</p><h4 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h4><p>如Windows XP、MacOS，方便个人使用。</p><h3 id="1-1-4-操作系统的运行机制与体系结构"><a href="#1-1-4-操作系统的运行机制与体系结构" class="headerlink" title="1.1.4 操作系统的运行机制与体系结构"></a>1.1.4 操作系统的运行机制与体系结构</h3><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><blockquote><p>问题：“指令”和我们平时所说的“代码”有什么区别？</p></blockquote><p>一段C语言代码通过编译，形成机器语言指令。<strong>一条高级语言的代码编译过后可能会对应多条指令。</strong></p><p>简单来说，“指令”就是处理器CPU能识别、执行的最基本命令</p><p>比如：加法指令就是让CPU进行加法运算</p><blockquote><p>新的问题：有的指令“人畜无害”。比如：加、减、乘、除这些普通的运算指令。有的指令有很高的权限。比如内存清零指令。比如用户程序可以使用这个指令，就意味着一个用户可以将其他用户的内存数据随意清零，这样做显然是很危险的。</p></blockquote><p>指令可以分为：</p><ul><li>特权指令：如内存清零指令（不允许用户程序使用）</li><li>非特权指令：如普通的运算指令</li></ul><blockquote><p>问题：CPU如何判断当前是否可以执行特权指令？</p></blockquote><p>两种处理器状态（用程序状态字寄存器PSW中的某标志位来标识当前处理器处于什么状态。如0为用户态，1为核心态）</p><ul><li>用户态（目态），此时CPU只能执行非特权指令</li><li>核心态（管态），特权指令、非特权指令都可以执行</li></ul><p>两种程序</p><ul><li><p>内核程序</p><p>  操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。</p></li><li><p>应用程序</p><p>  为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态。</p></li></ul><blockquote><p>操作系统中的那些功能应该由内核程序实现呢？</p></blockquote><h4 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h4><p>计算机系统的层次结构</p><p><img src="http://1.117.162.142:9000/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="计算机系统的层次结构"></p><p>时钟管理：实现计时功能</p><p>中断处理：负责实现中断机制</p><p>原语：</p><ul><li>一种特殊的程序。</li><li>是最接近硬件的部分。</li><li>这种程序的运行具有原子性——运行只能一气呵成，不可中断。</li><li>运行时间较短、调用频繁。</li></ul><p>内核是计算机配置的底层软件，是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是内核程序。</p><p>对系统资源进行管理的功能：</p><ul><li>进程管理</li><li>存储器管理</li><li>设备管理</li></ul><p>ps：有的系统不把这部分归为“内核功能”。也就是说，不同的操作系统，对内核功能的划分可能并不一样。</p><h4 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h4><p>操作系统的体系结构可分为：</p><ul><li><p>大内核</p><p>  将操作系统的主要功能模块都作为系统内核，运行在核心态</p><p>  优点：高性能</p><p>  缺点：内核代码庞大，结构混乱，难以维护</p></li><li><p>微内核</p><p>  只把最基本的功能保留在内核</p><p>  优点：内核功能少，结构清晰，方便维护</p><p>  缺点：需要频繁地在核心态和用户态之间切换，性能低</p></li></ul><p>类比：</p><p>操作系统的体系结构问题与企业的管理问题很相似。</p><p>内核就是企业的管理层，负责一些重要的工作。只有管理层才能执行特权指令，普通员工只能执行非特权指令。用户态、核心态之间的切换相当于普通员工和管理层之间的工作交接。</p><p>大内核：企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高；缺点是组织结构混乱，难以维护。</p><p>微内核：随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护；缺点是效率低。</p><h3 id="1-1-5-中断和异常"><a href="#1-1-5-中断和异常" class="headerlink" title="1.1.5 中断和异常"></a>1.1.5 中断和异常</h3><h4 id="中断机制的诞生"><a href="#中断机制的诞生" class="headerlink" title="中断机制的诞生"></a><strong>中断机制的诞生</strong></h4><p>为了解决各程序在早起的计算机中只能串行执行，系统资源利用率低的问题，人们发明了操作系统（作为计算机的管理者），引入中断机制，实现了多道程序并发执行。</p><p>本质：发生中断就意味着需要操作系统介入，开展管理工作。</p><h4 id="中断的概念和作用"><a href="#中断的概念和作用" class="headerlink" title="中断的概念和作用"></a><strong>中断的概念和作用</strong></h4><ol><li>当中断发生时，CPU立即进入核心态</li><li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理。</li><li>对于不同的中断信号，会进行不同的处理</li></ol><p>发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作（比如进程切换、分配I&#x2F;O设备等）需要使用特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行。</p><blockquote><p>问题：用户态、核心态之间的切换是怎么实现的？</p></blockquote><p>用户态 -&gt; 核心态是通过中断实现的。并且中断是唯一途径。</p><h4 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a><strong>中断的分类</strong></h4><p>中断可分为：</p><ul><li><p>内中断</p><p>  也称异常、例外、陷入。信号来源于CPU内部与当前执行的指令有关</p><ul><li><p>自愿中断——指令中断</p><p>  如系统调用时使用的访管指令（又叫陷入指令、trap指令）</p></li><li><p>强迫中断</p><ul><li>硬件故障（如缺页）</li><li>软件中断（如整数除0）</li></ul></li></ul></li><li><p>外中断</p><p>  信号来源于CPU外部。与当前执行的指令无关</p><ul><li>外设请求（如I&#x2F;O操作完成发出的中断信号）</li><li>人工干预（如用户强行终止一个进程）</li></ul></li></ul><p>另一种分类方式：</p><ul><li>内中断（内部异常）<ul><li>陷阱、陷入trap（有意而为之的异常，如系统调用）</li><li>故障fault（由错误条件引起的，可能被故障处理程序修复，如缺页）</li><li>终止abort（不可恢复的致命错误造成的结果，终止处理程序不再将控制返回给引发终止的应用程序，如整数除0）</li></ul></li><li>外中断<ul><li>I&#x2F;O中断请求</li><li>人工干预</li></ul></li></ul><h4 id="外中断的处理过程"><a href="#外中断的处理过程" class="headerlink" title="外中断的处理过程"></a><strong>外中断的处理过程</strong></h4><ol><li>执行完每个指令之后，CPU都要检查当前是否有外部中断信号</li><li>如果监测到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW、程序计数器PC、各种通用寄存器）</li><li>根据中断信号类型转入相应的中断处理程序</li><li>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</li></ol><h3 id="1-1-6-系统调用"><a href="#1-1-6-系统调用" class="headerlink" title="1.1.6 系统调用"></a>1.1.6 系统调用</h3><h4 id="什么是系统调用，有何作用？"><a href="#什么是系统调用，有何作用？" class="headerlink" title="什么是系统调用，有何作用？"></a><strong>什么是系统调用，有何作用？</strong></h4><p>系统调用是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为 一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获取操作系统的服务。</p><p>应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡事与资源有关的操作（如存储分配、I&#x2F;O操作、文件管理），都必须通过系统调用的方式来操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p><p>系统调用按功能可以分为：</p><ul><li>设备管理：完成设备的请求&#x2F;释放&#x2F;启动等功能</li><li>文件管理：完成文件的读&#x2F;写&#x2F;创建&#x2F;删除等功能</li><li>进程控制：完成进程的创建&#x2F;撤销&#x2F;阻塞&#x2F;唤醒等功能</li><li>进程通信：完成进程之间的消息传递&#x2F;信号传递等功能</li><li>内存管理：完成内存的分配&#x2F;回收等功能</li></ul><blockquote><p>系统调用相关处理涉及到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此系统调用的相关处理需要在核心态下进行。</p></blockquote><h4 id="系统调用和库函数的区别"><a href="#系统调用和库函数的区别" class="headerlink" title="系统调用和库函数的区别"></a><strong>系统调用和库函数的区别</strong></h4><p><img src="http://1.117.162.142:9000/blog/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8E%E5%BA%93%E5%87%BD%E6%95%B0.png" alt="系统调用与库函数"></p><table><thead><tr><th align="left">普通应用程序</th><th>可直接进行系统调用，也可以使用库函数。有的库函数设计系统调用，有的不涉及</th></tr></thead><tbody><tr><td align="left">编程语言</td><td>向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使上层进行系统调用更加方便。</td></tr><tr><td align="left">操作系统</td><td>向上提供系统调用</td></tr><tr><td align="left">裸机</td><td></td></tr></tbody></table><p>区别：</p><ul><li>系统调用是操作系统向上层提供的接口</li><li>有的库函数是对系统调用的进一步封装</li><li>当今编写的应用程序大多是通过高级语言提供的库函数间接地进行系统调用</li></ul><h4 id="系统调用背后的过程"><a href="#系统调用背后的过程" class="headerlink" title="系统调用背后的过程"></a><strong>系统调用背后的过程</strong></h4><p><img src="http://1.117.162.142:9000/blog/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="系统调用过程"></p><p>传递系统调用参数 -&gt; 执行陷入指令(用户态) -&gt; 执行系统调用相应服务程序(核心态) -&gt; 返回用户程序</p><p>注意：</p><ol><li>陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，从而CPU进入核心态。</li><li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</li><li>陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令</li></ol><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="2-1-1-进程的定义、组成、组织方式、特征"><a href="#2-1-1-进程的定义、组成、组织方式、特征" class="headerlink" title="2.1.1 进程的定义、组成、组织方式、特征"></a>2.1.1 进程的定义、组成、组织方式、特征</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>从不同的角度，进程可以有不同的定义，比较传统典型的定义有：</p><ol><li>进程是程序的一次执行过程。</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li><li>进程是具有独立功能的程序在数据集合上运行的过程，它是系统进程资源分配和调度的一个独立单位。</li></ol><p>不管从什么角度，它们都在强调进程是“动态性”的。</p><p>引入进程实体的概念后，可以把进程定义为：</p><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p><strong>程序：</strong>一个指令序列。</p><p>引入多道程序技术后，为了方便操作系统管理，完成各程序并发执行，引入了进程、进程实体的概念。</p><p>PCB、程序段、数据段三部分构成了进程实体 （进程映像）。</p><blockquote><p>PCB：系统为每个运行的程序配置一个数据结构，称为进程控制块(PCB)，用来描述进程的各种信息(如程序代码存放位置)</p><p>程序段：存放要执行的程序代码</p><p>数据段：存放程序运行过程中处理的各种数据，如全局变量、局部变量等。</p></blockquote><p>程序段、数据段、PCB三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体就简称为进程，例如：所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。</p><p><strong>PCB是进程存在的唯一标志！</strong></p><p>PCB中存放的信息：</p><ul><li><p>进程描述信息</p><ul><li>进程标识符PID：进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，用于区分不同的进程。</li><li>用户标识符UID</li></ul></li><li><p>进程控制和管理信息</p><ul><li>进程当前状态</li><li>进程优先级</li></ul></li><li><p>资源分配清单</p><ul><li>程序段指针</li><li>数据段指针</li><li>键盘</li><li>鼠标</li></ul></li><li><p>处理机相关信息</p><ul><li><p>各种寄存器值</p><p>  当进程切换时，需要把进程当前的运行情况记录下来保存在PCB中，如程序计数器的值表示了当前程序执行到那一句</p></li></ul></li></ul><h4 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h4><p>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。</p><p>ps：进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题。</p><p>进程的组织方式包括：</p><ul><li><p>链接方式</p><p>  链接方式按照进程状态将PCB分为多个队列，操作系统有志向各个队列的指针</p></li><li><p>索引方式</p><p>  索引方式根据进程状态的不同，建立几张索引表，各表项指向一个PCB，操作系统持有指向各个索引表的指针</p></li></ul><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li><p>动态性</p><p>  进程是程序的一次执行过程，是动态地产生、变化和消亡的</p></li><li><p>并发性</p><p>  内存中有多个进程实体，各进程可并发执行</p></li><li><p>独立性</p><p>  进程是能独立运行、独立获得资源、独立接受调度的基本单位</p></li><li><p>异步性</p><p>  各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题</p></li><li><p>结构性</p><p>  每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</p></li></ul><blockquote><p>动态性是进程最基本的特征。进程是资源分配、接受调度的基本单位。异步性会导致并发程序执行结果的不确定性。</p></blockquote><h3 id="2-1-2-进程的状态与转换"><a href="#2-1-2-进程的状态与转换" class="headerlink" title="2.1.2 进程的状态与转换"></a>2.1.2 进程的状态与转换</h3><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化的。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。</p><p>进程的三种基本状态：</p><ul><li><p>就绪态（Ready）</p><p>  此时进程已经具备运行条件（除处理机之外所有需要的资源），但由于没有空闲的CPU，而暂时不能运行。一旦获得处理机，即可立即进入运行态开始运行。</p></li><li><p>运行态（Running）</p><p>  此时进程占有CPU，并在CPU上运行。单核处理机环境下，每一个时刻最多只有一个进程处于运行态。双核环境下可以同时有两个进程处于运行态。</p></li><li><p>阻塞态（Waiting&#x2F;Blocked，又称：等待态）</p><p>  因等待某一事件而暂时不能运行。如等待操作系统分配打印机、等待磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务。</p></li></ul><p>一个进程的诞生和消亡过程并不是一瞬间完成的，也有一个创建和消亡的过程，所以进程还有两种状态：</p><ul><li><p>创建态（New，又称：新建态）</p><p>  一个程序需要在计算机中运行，操作系统需要完成创建进程。操作系统为该进程分配所需要的内存空间等系统资源，并为其创建、初始化PCB（如为进程分配PID）</p></li><li><p>终止态（Terminated，又称：结束态）</p><p>  进程运行结束（或者由于bug导致进程无法继续执行下去，比如数组越界错误，整数除零），需要撤销进程。操作系统需要完成撤销进程的相关工作。完成将分配给进程的资源回收，撤销进程PCB等工作。</p></li></ul><h4 id="进程状态的转换"><a href="#进程状态的转换" class="headerlink" title="进程状态的转换"></a>进程状态的转换</h4><p><img src="http://1.117.162.142:9000/blog/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="进程状态的转换"></p><p>进程从运行态 -&gt; 阻塞态是一种进程自身作出的主动行为</p><p>进程从阻塞态 -&gt; 就绪态不是进程自身能控制的，是一种被动行为</p><p>ps: 不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态，因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求。</p><ul><li><p>就绪态 -&gt; 运行态</p><p>  进程被调度</p></li><li><p>运行态 -&gt; 就绪态</p><p>  时间片到，或CPU被其他高优先级的进程抢占</p></li><li><p>运行态 -&gt; 阻塞态</p><p>  等待系统资源分配，或等待某事件发生（主动行为）</p></li><li><p>阻塞态 -&gt; 就绪态</p><p>  资源分配到尾，等待的事件发生（被动行为）</p></li><li><p>创建态 -&gt; 就绪态</p><p>  系统完成创建进程相关的工作</p></li><li><p>运行态 -&gt; 终止态</p><p>  进程运行结束，或运行过程中遇到不可修复的错误</p></li></ul><h3 id="2-1-3-进程控制"><a href="#2-1-3-进程控制" class="headerlink" title="2.1.3 进程控制"></a>2.1.3 进程控制</h3><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><p>简化理解：反正进程控制就是要实现进程状态转换。</p><p><img src="http://1.117.162.142:9000/blog/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6.png" alt="进程控制"></p><p>创建进程：需要初始化PCB、分配系统资源。</p><p>创建态 -&gt; 就绪态：需要修改PCB内容和相应队列</p><p>就绪态 -&gt; 运行态：需要回复进程运行环境、修改PCB内容和相应队列</p><p>运行态 -&gt; 就绪态：需要保存进程运行环境、修改PCB内容和相应队列</p><p>运行态 -&gt; 阻塞态：需要保存进程运行环境、修改PCB内容和相应队列</p><p>阻塞态 -&gt; 就绪态：需要修改PCB内容和相应队列。如果等待的是资源，则还需为进程分配系统资源</p><p>运行态 -&gt; 终止态：需回收进程拥有的资源，撤销PCB</p><p>进程状态的切换，中间所做的事情是比较复杂的，需要修改PCB的内容和将PCB放入相应的队列。加入一个进程的PCB从一个队列放入另一个队列中，但是并没有修改PCB中状态标志成新的状态。这种情况会导致系统错误，为了解决这个问题，引入了原语。</p><h4 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h4><p>用原语实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。</p><p>这种不可被中断的操作称为原子操作。</p><p>原语采用“关中断指令”和“开中断指令”实现。</p><p><img src="http://1.117.162.142:9000/blog/%E5%8E%9F%E8%AF%AD.png" alt="原语"></p><p>关&#x2F;开中断指令的权限非常大，必然是只允许在核心态下执行的特权命令。</p><p>进程控制会导致进程状态的转换。无论哪个原语，要做的无非是三类事情：</p><ol><li><p>更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）</p><p> a. 所有的进程控制原语一定都会修改进程状态标志</p><p> b. 剥夺当前运行进程的CPU使用权，必然需要保存其运行环境</p><p> c. 某进程开始运行前必然要恢复其运行环境</p></li><li><p>将PCB插入合适的队列</p></li><li><p>分配&#x2F;回收资源</p></li></ol><h4 id="进程控制相关的原语"><a href="#进程控制相关的原语" class="headerlink" title="进程控制相关的原语"></a>进程控制相关的原语</h4><ol><li>进程的创建：</li></ol><p>创建原语（无 -&gt; 创建态 -&gt; 就绪态）</p><ul><li>申请空白PCB</li><li>为新进程分配所需资源</li><li>初始化PCB</li><li>将PCB插入就绪队列</li></ul><p>引起进程创建的事件</p><ul><li>用户登录：分时系统中，用户登录成功，系统会建立为其建立一个新的进程</li><li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li><li>提供服务：用户向操作系统提出某些请求时，会建立一个进程处理该请求</li><li>应用请求：由用户进程主动请求创建一个子进程</li></ul><ol start="2"><li>进程的终止：</li></ol><p>撤销原语（就绪态&#x2F;阻塞态&#x2F;运行态 -&gt; 终止态 -&gt; 无）</p><ul><li>从PCB集合中找到终止进程的PCB</li><li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li><li>终止其所有子进程</li><li>将该进程拥有的所有资源归还给父进程或操作系统</li><li>删除PCB</li></ul><p>引起进程终止的事件：</p><ul><li>正常结束</li><li>异常结束</li><li>外界干预</li></ul><ol start="3"><li>进程的阻塞和唤醒（阻塞和唤醒要成对出现）</li></ol><p>阻塞原语（运行态 -&gt; 阻塞态）</p><ul><li>找到要阻塞的进程对应的PCB</li><li>保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li><li>将PCB插入相应事件的等待队列</li></ul><p>引起进程阻塞的事件：</p><ul><li>需要等待系统分配某种资源</li><li>需要等待相互合作的其他进程完成工作</li></ul><p>唤醒原语（阻塞态 -&gt; 就绪态）</p><ul><li>在事件等待队列中找到PCB</li><li>将PCB从等待队列移除，设置进程为就绪态</li><li>将PCB插入就绪队列，等待被调度</li></ul><p>引起进程唤醒的事件：</p><ul><li>等待的事件发生</li></ul><ol start="4"><li>进程的切换</li></ol><p>切换原语（运行态 -&gt; 阻塞态&#x2F;就绪态；就绪态 -&gt; 运行态）：</p><ul><li><p>将运行环境信息存入PCB</p></li><li><p>PCB移入相应队列</p></li><li><p>选择另一个进程执行，并更新其PCB</p></li><li><p>根据PCB恢复新进程所需的运行环境</p></li></ul><p>引起进程切换的事件：</p><ul><li>当前进程时间片到</li><li>有更高优先级的进程到达</li><li>当前进程主动阻塞</li><li>当前进程终止</li></ul><h3 id="2-1-4-进程通信"><a href="#2-1-4-进程通信" class="headerlink" title="2.1.4 进程通信"></a>2.1.4 进程通信</h3><blockquote><p>什么是进程通信？</p></blockquote><p>顾名思义，进程通信指进程之间的信息交换。</p><p>进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程</strong>拥有的<strong>内存地址空间相互独立</strong>。</p><p>为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p><p>实现进程间的安全通信的方法有<strong>共享存储</strong>、<strong>消息传递</strong>、<strong>管道通信</strong>。</p><h4 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h4><p>共享存储要求两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）。</p><p>操作系统只负责提供共享空间和同步互斥工具（如P、V操作）。</p><p>共享存储可分为基于数据结构的共享和基于存储区的贡献。</p><p><strong>基于数据结构</strong>的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。</p><p><strong>基于存储区</strong>的共享：在内存中画出一块共享存储区，数据的形式、 存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。</p><h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><blockquote><p>“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。</p></blockquote><ol><li>管道只能采用半双工通信，某一时间段内只能实现单项的传输。如果要实现双向同时通信，则需要设置两个管道。</li><li>各进程要互斥地访问管道。</li><li>数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。</li><li>如果没写满，就不允许读。如果没读空，就不允许写。</li><li>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。</li></ol><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p>进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息&#x2F;接收消息”两个原语进行数据交换。</p><p>格式化的消息包括消息头、消息体。</p><p>消息头包括发送进程ID、接收进程ID、消息类型、消息长度等格式化的信息（计算机网络中发送的“报文”其实就是一种格式化的消息）</p><p>消息传递的两种方式：</p><ol><li><p>直接通信方式</p><p> 消息直接挂到接收进程的消息缓冲队列上</p></li><li><p>间接通信方式</p><p> 消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。eg：计算机网络中的电子邮件系统。</p></li></ol><h3 id="2-1-5-线程概念和多线程模型"><a href="#2-1-5-线程概念和多线程模型" class="headerlink" title="2.1.5 线程概念和多线程模型"></a>2.1.5 线程概念和多线程模型</h3><h4 id="什么是线程，为什么要引入线程？"><a href="#什么是线程，为什么要引入线程？" class="headerlink" title="什么是线程，为什么要引入线程？"></a>什么是线程，为什么要引入线程？</h4><p>可以把线程理解为“轻量级进程“。</p><p>线程是一个<strong>基本的CPU执行单元</strong>，也是<strong>程序执行流的最小单位</strong>。</p><p>引入线程后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步<strong>提升了系统的并发度</strong>，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）</p><p>引入线程之后，进程制作为<strong>除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间都是分配给进程的）。</p><h4 id="引入线程机制后，有什么变化？"><a href="#引入线程机制后，有什么变化？" class="headerlink" title="引入线程机制后，有什么变化？"></a>引入线程机制后，有什么变化？</h4><p>从资源分配、调度来看：</p><ul><li>传统进程机制中，进程是资源分配、调度的基本单位</li><li>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</li></ul><p>从并发性来看：</p><ul><li>传统进程机制中，只能进程间并发</li><li>引入线程后，各线程间也能并发，提升了并发度</li></ul><p>从系统开销来看：</p><ul><li>传统的进程间并发，需要切换进程的运行环境，系统开销很大</li><li>线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小</li><li>引入线程后，并发所带来的系统开销减小</li></ul><h4 id="线程有哪些重要的属性"><a href="#线程有哪些重要的属性" class="headerlink" title="线程有哪些重要的属性"></a>线程有哪些重要的属性</h4><ul><li>线程是处理机调度的单位，进程是资源分配的单位</li><li>同一进程的各线程共享拥有的资源</li><li>同一进程内的线程切换不会导致进程切换</li><li>多CPU计算机中，各线程可占用不同的CPU</li><li>每个线程都有一个线程ID、线程控制块（TCB）</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销很大</li></ul><h4 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h4><p><strong>用户级线程(User-Level Thread, ULT)</strong></p><p><img src="http://1.117.162.142:9000/blog/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B.png" alt="用户级线程"></p><p>用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换）</p><p>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</p><p>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明）</p><p>可以理解为，“用户级线程”就是“从用户视角看能看到的线程”。</p><p><strong>内核级线程(Kernel-Level Thread, KLT, 又称“内核支持的线程”</strong></p><p><img src="http://1.117.162.142:9000/blog/%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B.png" alt="内核级线程"></p><p>内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。可以理解为，“内核级线程”就是“从操作系统内核视角看能看到的线程”。</p><p>在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m个内核级线程上（n&gt;m）</p><p><img src="http://1.117.162.142:9000/blog/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%90%88.png" alt="用户级线程和内核级线程组合"></p><p><strong>重点</strong>：</p><p>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</p><p>例如上面的模型中，该进程有两个内核级线程，三个用户级线程，在用户看来，这个进程中有三个线程。但即使该进程在一个四核处理机的计算机上运行，也最多只能被分配到两个核，最多只能有两个用户线程并行执行。</p><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p>在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”为题。</p><p><strong>多对一模型</strong>：</p><p><img src="http://1.117.162.142:9000/blog/%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B.png" alt="多对一模型"></p><p>多个用户级线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</p><p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p><p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p><p><strong>一对一模型</strong>：</p><p><img src="http://1.117.162.142:9000/blog/%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B.png" alt="一对一模型"></p><p>一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p><p><strong>多对多模型</strong>：</p><p><img src="http://1.117.162.142:9000/blog/%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B.png" alt="多对多模型"></p><p>n用户级线程映射到m内核级线程（n≥m）。每个用户级进程对应m个内核级线程。</p><p>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p><h3 id="2-2-1-处理机调度的概念、层次"><a href="#2-2-1-处理机调度的概念、层次" class="headerlink" title="2.2.1 处理机调度的概念、层次"></a>2.2.1 处理机调度的概念、层次</h3><h4 id="调度的基本概念"><a href="#调度的基本概念" class="headerlink" title="调度的基本概念"></a>调度的基本概念</h4><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。</p><p>在多道程序系统中，进程的数量往往是多余处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</p><h4 id="调度的三个层次"><a href="#调度的三个层次" class="headerlink" title="调度的三个层次"></a>调度的三个层次</h4><p>::: tip<br>外存：指计算机随机存储器(RAM)和CPU缓存之外的存储器，例如，计算机硬盘、软盘、光盘、U盘等。<br>:::</p><p><strong>1. 高级调度</strong></p><p>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</p><p>高级调度(作业调度)。按一定的原则从外存上处于后备队列的作业中挑选一个(或多个)作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB)，以使它(们)获得竞争处理机的权利。</p><p>高级调度是辅存(外存)与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p><p><strong>2. 中级调度</strong></p><p>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。</p><p>这么做的目的是为了提高内存利用率和系统吞吐量。</p><p>暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到挂起队列中。</p><p>中级调度(内存调度)，就是要决定将哪个处于挂起状态的进程重新调入内存。</p><p>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</p><p><strong>3. 低级调度</strong></p><p>低级调度(进程调度)，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</p><p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。</p><p>进程调度的频率很高，一般几十毫秒一次。</p><p><strong>补充：进程的挂起态与七状态模型</strong></p><p>暂时调到外存等待的进程状态为挂起状态(挂起态，suspend)</p><p>挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</p><p>五状态模型 -&gt; 七状态模型</p><p><img src="http://1.117.162.142:9000/blog/%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt="七状态模型"></p><p>注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但是挂起状态是将进程映像调到外存中去了，而阻塞态下的进程映像还在内存中。有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p><p><strong>三种调度的联系、对比</strong></p><table><thead><tr><th align="center"></th><th align="center">要做什么</th><th align="center">调度发生在</th><th align="center">发生频率</th><th align="center">对进程状态的影响</th></tr></thead><tbody><tr><td align="center">高级调度<br />(作业调度)</td><td align="center">按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td><td align="center">外存 -&gt; 内存<br />(面向作业)</td><td align="center">最低</td><td align="center">无 -&gt; 创建态 -&gt; 就绪态</td></tr><tr><td align="center">中级调度<br />(内存调度)</td><td align="center">按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td><td align="center">外存 -&gt; 内存<br />(面向进程)</td><td align="center">中等</td><td align="center">挂起态 -&gt; 就绪态<br />(阻塞挂起 -&gt; 阻塞态)</td></tr><tr><td align="center">低级调度<br />(进程调度)</td><td align="center">按照某种规则，从就绪队列中选择一个进程为其分配处理机</td><td align="center">内存 -&gt; CPU</td><td align="center">最高</td><td align="center">就绪态 -&gt; 运行态</td></tr></tbody></table><h3 id="2-2-2-进程调度的时机、切换与过程、方式"><a href="#2-2-2-进程调度的时机、切换与过程、方式" class="headerlink" title="2.2.2 进程调度的时机、切换与过程、方式"></a>2.2.2 进程调度的时机、切换与过程、方式</h3><h4 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a><strong>进程调度的时机</strong></h4><p>进程调度(低级调度)就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p><p>需要进行进程调度与切换的情况：</p><ul><li>当前运行的进程主动放弃处理机<ul><li>进程正常终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞(如等待I&#x2F;O)</li></ul></li><li>当前运行的进程被动放弃处理机<ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理(如I&#x2F;O中断)</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ul><p>不能进行进程调度与切换的情况：</p><ul><li>在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进程切换。</li><li>进程在操作系统内核程序临界区中。</li><li>在原子操作过程中(原语)。原子操作不可中断，要一气呵成(如修改PCB中进程状态标志，并把PCB放到相应队列)</li></ul><blockquote><p>进程在操作系统内核程序临界区中不能进行调度与切换。 ✓</p><p>进程处于临界区时不能进行处理机调度。✖︎</p><p>临界资源：一段时间内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。</p><p>临界区：访问临界资源的那段代码。</p><p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列(由各种就绪进程的PCB组成)。</p></blockquote><p><img src="http://1.117.162.142:9000/blog/%E5%86%85%E6%A0%B8%E4%B8%B4%E7%95%8C%E5%8C%BA%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.png" alt="内核临界区进程调度"></p><p>如果还没退出临界区(还没解锁)就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度。内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。</p><p><img src="http://1.117.162.142:9000/blog/%E6%99%AE%E9%80%9A%E4%B8%B4%E7%95%8C%E5%8C%BA.png" alt="普通临界区"></p><p>在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲。普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时，可以进行调度与切换。</p><h4 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a><strong>进程调度的方式</strong></h4><ul><li><p>非剥夺调度方式</p><p>  又称非抢占方式。即只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</p><p>  实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。</p></li><li><p>剥夺调度式</p><p>  又称抢占式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</p><p>  可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能(通过始终中断)。适合于分时操作系统、实时操作系统。</p></li></ul><h4 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a><strong>进程的切换与过程</strong></h4><p>“狭义的进程调度”与“进程切换”的区别：</p><p>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换)</p><p>进程切换指一个进程让出处理机，由另一个进程占用处理机的过程。</p><p>广义的进程调度包含了选择一个进程和进程切换两个步骤。</p><p>进程切换的过程主要完成了：</p><ol><li>对原来运行进程各种数据的保护</li><li>对新的进程各种数据的恢复</li></ol><p>​如程序计数器、程序状态字、各种数据寄存器等处理机线程信息，这些信息一般保存在进程控制块PCB）</p><p>ps：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p><h3 id="2-2-3-调度算法的评价指标"><a href="#2-2-3-调度算法的评价指标" class="headerlink" title="2.2.3 调度算法的评价指标"></a>2.2.3 调度算法的评价指标</h3><h4 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h4><p>指CPU“忙碌”的事件占总时间的比例。</p><p>利用率 &#x3D; 忙碌的事件 &#x2F; 总时间</p><h4 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h4><p>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业。</p><p>系统吞吐量指单位时间内完成作业的数量</p><p>系统吞吐量 &#x3D; 总共完成了多少道作业 &#x2F; 总共花了多少时间</p><h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h4><p>对于计算机来说，他很关心自己的作业从提交到完成花了多少时间。</p><p>周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。</p><p>它包括四个部分：作业在外存后备队列上等待作业调度(高级调度)的时间、进程在就绪队列上等待进程调度(低级调度)的时间、进程在CPU上执行的时间、进程等待I&#x2F;O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。</p><p>周转时间 &#x3D; 作业完成时间 - 作业提交时间</p><p>平均周转时间 &#x3D; 各作业周转时间之和 &#x2F; 作业数</p><p>带权周转时间 &#x3D; 作业周转时间 &#x2F; 作业实际运行的时间 &#x3D; (作业完成时间 - 作业提交时间) &#x2F; 作业实际运行的时间</p><h4 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h4><p>计算机的用户希望自己的作业尽可能少的等待处理机</p><p>等待时间是指进程&#x2F;作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</p><p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I&#x2F;O完成的期间其实进程也是在被服务的，所以不计入等待时间。</p><p>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p><p>一个作业总共需要被CPU服务多久，被I&#x2F;O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业&#x2F;进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。</p><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4><p>对于计算机用户来说，会希望自己提交的请求(比如通过键盘输入了一个调试命令)尽早地开始被系统服务、回应。</p><p>响应时间指从用户提交请求到首次产生响应所用的时间。</p><h3 id="2-2-4-调度算法"><a href="#2-2-4-调度算法" class="headerlink" title="2.2.4 调度算法"></a>2.2.4 调度算法</h3><h4 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务(FCFS)"></a><strong>先来先服务(FCFS)</strong></h4><ul><li><p>算法思想</p><p>  主要从“公平”的角度考虑(类似于我们生活中排队买东西的例子)</p></li><li><p>算法规则</p><p>  按照作业&#x2F;进程到达的先后顺序进行服务</p></li><li><p>用于作业&#x2F;进程调度</p><p>  用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列</p></li><li><p>是否可抢占？</p><p>  非抢占式的算法</p></li><li><p>优缺点</p><p>  优点：公平、算法实现简单</p><p>  缺点：排在长作业(进程)后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即FCFS算法对长作业有利，对短作业不利</p></li><li><p>是否会导致饥饿</p><p>  不会</p></li></ul><h4 id="短作业优先-SJF"><a href="#短作业优先-SJF" class="headerlink" title="短作业优先(SJF)"></a><strong>短作业优先(SJF)</strong></h4><ul><li><p>算法思想</p><p>  最求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间</p></li><li><p>算法规则</p><p>  最短的作业&#x2F;进程优先得到服务(所谓“最短”，是指要求服务时间最短)</p></li><li><p>用于作业&#x2F;进程调度</p><p>  既可用于作业调度，也可以用于进程调度。用于进程调度时称为“短进程优先”(SPF, Shortest Process First)算法。</p></li><li><p>是否可抢占</p><p>  SJF和SPF是非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法(SRTN， Shortest Remaining Time Next)</p></li><li><p>优缺点</p><p>  优点：“最短的”平均等待时间、平均周转时间</p><p>  缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业&#x2F;进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。</p></li><li><p>是否会导致饥饿</p><p>  会。如果源源不断的有短作业&#x2F;进程到来，可能是长作业&#x2F;进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”</p></li></ul><h4 id="高响应比优先-HRRN"><a href="#高响应比优先-HRRN" class="headerlink" title="高响应比优先(HRRN)"></a><strong>高响应比优先(HRRN)</strong></h4><ul><li><p>算法思想</p><p>  要综合考虑作业&#x2F;进程的等待时间和要求服务的时间</p></li><li><p>算法规则</p><p>  在每次调度时先计算各个作业&#x2F;进程的响应比，选择响应比最高的作业&#x2F;进程为其服务</p><p>  响应比 &#x3D; (等待时间 + 要求服务时间) &#x2F; 要求服务时间</p></li><li><p>用于作业&#x2F;进程调度</p><p>  既可用于作业调度，也可用于进程调度</p></li><li><p>是否可抢占</p><p>  非抢占式的算法。因此只有当前运行的作业&#x2F;进程主动放弃处理机时，才需要调度，才需要计算响应比。</p></li><li><p>优缺点</p><p>  综合考虑了等待时间和运行时间(要求服务时间)等待时间相同时，要求服务时间短的优先(SJF的优点)；要求服务时间相同时，等待时间长的优先(FCFS的优点)；对于长作业来说，随着等待时间越来越久，其响应也会越来越大，从而避免了长作业饥饿的问题。</p></li><li><p>是否会导致饥饿</p><p>  不会</p></li></ul><blockquote><p>ps: 这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于早期的批处理系统，当然，GCFS算法也结合其他的算法使用，在现在也扮演着很重要的角色。</p></blockquote><p>​    </p><h3 id="2-2-5-适合交互式系统的调度算法"><a href="#2-2-5-适合交互式系统的调度算法" class="headerlink" title="2.2.5 适合交互式系统的调度算法"></a>2.2.5 适合交互式系统的调度算法</h3><h4 id="时间片轮转-RR-Round-Robin"><a href="#时间片轮转-RR-Round-Robin" class="headerlink" title="时间片轮转(RR, Round-Robin)"></a>时间片轮转(RR, Round-Robin)</h4><ul><li><p>算法思想</p><p>  公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p></li><li><p>算法规则</p><p>  按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片(如100ms)。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</p></li><li><p>用于作业&#x2F;进程调度</p><p>  用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)</p></li><li><p>是否可抢占</p><p>  若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到。</p></li><li><p>优缺点</p><p>  优点：公平、响应快，适用于分时操作系统。</p><p>  缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</p></li><li><p>是否会导致饥饿</p><p>  不会</p></li><li><p>补充</p><p>  如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</p><p>  另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减小。可见时间片也不能太小。</p></li></ul><h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><ul><li><p>算法思想</p><p>  随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序。</p></li><li><p>算法规则</p><p>  调度时选择优先级最高的作业&#x2F;进程</p></li><li><p>用于作业&#x2F;进程调度</p><p>  既可用于作业调度，也可用于进程调度。甚至，还会用于I&#x2F;O调度中。</p></li><li><p>是否可抢占</p><p>  抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。</p></li><li><p>优缺点</p><p>  优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各个作业&#x2F;进程的偏好程度。</p><p>  缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</p></li><li><p>是否会导致饥饿</p><p>  会</p></li><li><p>补充</p><p>  就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近对头的位置。</p><p>  根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。</p><p>  静态优先级：创建进程时确定，之后一直不变。</p><p>  动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</p><blockquote><p>如何合理地设置各类进程的优先级？</p></blockquote><p>  通常系统进程优先级高于用户进程、前台进程优先级高于后台进程、操作系统更偏好I&#x2F;O型进程(或称I&#x2F;O繁忙型进程)</p><p>  Ps: 与I&#x2F;O型进程相对的是计算行进程(或称CPU繁忙型进程)</p><blockquote><p>如果采用的是动态优先级，什么时候应该调整？</p></blockquote><p>  可以从追求公平、提升资源利用率等角度考虑。如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级。如果某进程占用处理机运行了很长时间，则可适当降低其优先级。如果发现一个进程繁忙地进行I&#x2F;O操作，则可适当提升其优先级。</p></li></ul><h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><ul><li><p>算法思想</p><p>  对其他调度算法的折中权衡</p></li><li><p>算法规则</p><ol><li>设置多集就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾。</li><li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li></ol></li><li><p>用于作业&#x2F;进程调度</p><p>  用于进程调度</p></li><li><p>是否可抢占</p><p>  抢占式的算法。在k级队列的进程运行过程中，若更上级的队列(1～k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</p></li><li><p>优缺点</p><p>  对各类型进程相对公平(FCFS的优点)；每个新到达的进程都可以很快就得到响应(RR的优点)；短进程只用较少的十斤啊就可完成(SPF的优点)；不必实现估计进程的运行时间(避免用户作假)；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I&#x2F;O密集型进程(拓展：可以讲因I&#x2F;O而阻塞的进程重新放回原队列，这样I&#x2F;O型进程就可以保持较高优先级)</p></li><li><p>是否会导致饥饿</p><p>  会</p></li></ul><h3 id="2-3-1-进程同步、进程互斥"><a href="#2-3-1-进程同步、进程互斥" class="headerlink" title="2.3.1 进程同步、进程互斥"></a>2.3.1 进程同步、进程互斥</h3><h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><p>  同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于他们之间的相互合作。</p><h4 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h4><p>进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源(比如内存，又比如打印机、摄像头这样的I&#x2F;O设备)</p><p>资源共享的两种方式：</p><ul><li><p>互斥共享方式</p><p>  系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源</p></li><li><p>同时共享方式</p><p>  系统中的某些资源，允许一个时间段内有多个“同时”对它们进行访问。</p></li></ul><p>我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p><p>对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源后，另一个进程才能去访问临界资源。</p><p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  entry section;<span class="comment">// 进入区</span></span><br><span class="line">  critical section;<span class="comment">// 临界区</span></span><br><span class="line">  <span class="built_in">exit</span> section;<span class="comment">// 退出区</span></span><br><span class="line">  remainder section;<span class="comment">// 剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><ul><li>进入区：负责检查是否可进入临界区，若可以进入，则应设置<strong>正在访问临界资源的标志</strong>(可理解为“上锁”)，以阻止其他进程同时进入临界区</li><li>临界区：访问临界资源的那段代码</li><li>退出区：负责解除<strong>正在访问临界资源的标志</strong>(可理解为“解锁”)</li><li>剩余区：做其他处理</li></ul><p>ps：临界区是进程中访问临界资源的代码段。进入区和退出区是负责实现互斥的代码段。临界区也可称为“临界段”。</p><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p><ol><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)；</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ol><h3 id="2-3-2-进程互斥的软件实现方法"><a href="#2-3-2-进程互斥的软件实现方法" class="headerlink" title="2.3.2 进程互斥的软件实现方法"></a>2.3.2 进程互斥的软件实现方法</h3><h4 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h4><p>算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>; <span class="comment">// turn 表示当前允许进入临界区的进程号</span></span><br><span class="line"><span class="comment">// P0进程：</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">0</span>);<span class="comment">// ①</span></span><br><span class="line">critical section;<span class="comment">// ②</span></span><br><span class="line">turn = <span class="number">1</span>;<span class="comment">// ③</span></span><br><span class="line">remainder section;<span class="comment">// ④</span></span><br><span class="line"><span class="comment">// P1进程:</span></span><br><span class="line"><span class="keyword">while</span> (turn != <span class="number">1</span>);<span class="comment">// ⑤ 进入区</span></span><br><span class="line">critical section;<span class="comment">// ⑥ 临界区</span></span><br><span class="line">turn = <span class="number">0</span>;<span class="comment">// ⑦ 退出区</span></span><br><span class="line">remainder section;<span class="comment">// ⑧ 剩余区</span></span><br></pre></td></tr></table></figure><p>turn的初值为0，即刚开始只允许0号进程进入临界区。</p><p>若P1先上处理机运行，则会一直卡在⑤。直到P1的时间片用完，发生调度，切换P0上处理机运行。</p><p>代码①不会卡住P0，P0可以正常访问临界区，在P0访问临界区期间及时切换回P1，P1依然会卡在⑤。</p><p>只有P0在退出区将turn改为1后，P1才能进入临界区。</p><p>因此，该算法可以实现“同一时刻最多只允许一个进程访问临界区”</p><p>turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。也就是说，对于临界区的访问，一定是按P0 -&gt; P1 -&gt; P0 -&gt; P1 -&gt; ……这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。</p><p>因此，单标志存在的主要问题是：违背“空闲让进”原则。</p><h4 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h4><p>算法思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程相进入临界区的意愿，比如<code>flag[0] = true</code>意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];<span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">// 刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"><span class="comment">// P0进程：</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);<span class="comment">// ①</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">// ②</span></span><br><span class="line">critical section;<span class="comment">// ③</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;<span class="comment">// ④</span></span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">// P1进程：</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);<span class="comment">// ⑤ 如果此时P0想进入临界区，P1就一直循环等待</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;<span class="comment">// ⑥ 标记为P1进程想要进入临界区</span></span><br><span class="line">critical section;<span class="comment">// ⑦ 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">// ⑧ 访问完临界区，修改标记为P1不想使用临界区</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>若按照①⑤②⑥③⑦……的顺序执行，P0和P1将会同时访问临界区。</p><p>因此，双标志先检查法的主要问题是：违反“忙则等待”原则。</p><p>原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</p><h4 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h4><p>算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临时区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];<span class="comment">// 表示进入临界区意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">// 刚开始设置为两个进程都不想进入临界区</span></span><br><span class="line"><span class="comment">// P0进程：</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">// ①</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>]);<span class="comment">// ②</span></span><br><span class="line">critical section;<span class="comment">// ③</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;<span class="comment">// ④</span></span><br><span class="line">remainder = section;</span><br><span class="line"><span class="comment">// P1进程：</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;<span class="comment">// ⑤ 标记为P1进程都想要进入临界区</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>]);<span class="comment">// ⑥ 如果P0也想进入临界区，则P1循环等待</span></span><br><span class="line">critical section;<span class="comment">// ⑦ 访问临界区</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">// ⑧ 访问完临界区，修改标记为P1不想使用临界区</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>若按照①⑤②⑥……的顺序执行，P0和P1将都无法进入临界区</p><p>因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿“现象。</p><p>两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。</p><h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p>算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L. Peterson想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方使用临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];<span class="comment">// 表示进入临界区意愿的数组，初始值都是false</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;<span class="comment">// turn表示优先让哪个进程进入临界区</span></span><br><span class="line"><span class="comment">// P0进程：</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">// ①</span></span><br><span class="line">turn = <span class="number">1</span>;<span class="comment">// ②</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>);<span class="comment">// ③</span></span><br><span class="line">critical section;<span class="comment">// ④</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;<span class="comment">// ⑤</span></span><br><span class="line">remainder section;</span><br><span class="line"><span class="comment">// P1进程:</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;<span class="comment">// ⑥ 表示自己想进入临界区</span></span><br><span class="line">turn = <span class="number">0</span>;<span class="comment">// ⑦ 可以优先让对方进入临界区</span></span><br><span class="line"><span class="keyword">while</span> (flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);<span class="comment">// ⑧ 对方想进，且最后一次是自己“让梨”，那自己就循环等待</span></span><br><span class="line">critical section;<span class="comment">// ⑨</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">// ⑩ 访问完临界区，表示自己已经不想访问临界区了</span></span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p>两种双标志法的问题都是由于进入区的几个操作不能一气呵成导致的。我们可以推理验证在Peterson算法中，两个进程进入区中的各个操作按不同的顺序穿插执行会发生什么情况：</p><p>①②③⑥⑦⑧……</p><p>①⑥②③……</p><p>Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则。</p><h3 id="2-3-3-进程互斥的硬件实现方法"><a href="#2-3-3-进程互斥的硬件实现方法" class="headerlink" title="2.3.3 进程互斥的硬件实现方法"></a>2.3.3 进程互斥的硬件实现方法</h3><h4 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h4><p>利用“开&#x2F;关中断指令”实现(与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同事访问临界区的情况)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">关中断；<span class="comment">// 关中断后即不允许当前进程被中断，也必然不会发生进程切换</span></span><br><span class="line">临界区；</span><br><span class="line">开中断；<span class="comment">// 直到当前进程访问完临界区，在执行开中断指令，才有可能有别的进程上处理机并访问临界区</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>优点：简单、高效</p><p>缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程(因为开&#x2F;关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)。</p><h4 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h4><p>简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令。</p><p>TSL指令是硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 布尔型共享标量lock表示当前临界区是否被枷锁</span></span><br><span class="line"><span class="comment">// true表示已加锁，false表示未加锁</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">TestAndSet</span> <span class="params">(<span class="type">bool</span> *lock)</span> &#123;</span><br><span class="line">  <span class="type">bool</span> old;</span><br><span class="line">  old = *lock;<span class="comment">// old用来存放lock原来的值</span></span><br><span class="line">  *lock = <span class="literal">true</span>; <span class="comment">// 无论之前是否已加锁，都将lock设为true</span></span><br><span class="line">  <span class="keyword">return</span> old;<span class="comment">// 返回lock原来的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下是使用TSL指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="keyword">while</span> (TestAndSet (&amp;lock));<span class="comment">// &quot;上锁&quot;并“检查”</span></span><br><span class="line">临界区代码段...</span><br><span class="line">lock = <span class="literal">false</span>;<span class="comment">// &quot;解锁&quot;</span></span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure><p>若刚开始lock是false，则TSL返回的old值为false，while循环条件不满足，直接跳过循环，进入临界区。若刚开始lock是true，则执行TLS后old返回的值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p><p>相比软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</p><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等“。</p><h4 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h4><p>有的地方也叫Exchange指令，或简称XCHG指令</p><p>Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swap指令的作用是交换两个变量的值</span></span><br><span class="line">Swap （<span class="type">bool</span> *a, <span class="type">bool</span> *b) &#123;</span><br><span class="line">  <span class="type">bool</span> temp;</span><br><span class="line">  temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下是用Swap指令实现互斥的算法逻辑</span></span><br><span class="line"><span class="comment">// lock表示当前临界区是否被枷锁</span></span><br><span class="line"><span class="type">bool</span> old = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (old == <span class="literal">true</span>)</span><br><span class="line">  Swap (&amp;lock, &amp;old);</span><br><span class="line">临界区代码段...</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">剩余区代码段...</span><br></pre></td></tr></table></figure><p>逻辑上来看Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁(记录在old变量上)，再将上锁标记lock设置为true，最后检查old，如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p><p>优点：实现简单，无需像软件实现方法那样严格检查是否有逻辑漏洞；适用于多处理机环境</p><p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等“。</p><h3 id="2-3-4-信号量机制"><a href="#2-3-4-信号量机制" class="headerlink" title="2.3.4 信号量机制"></a>2.3.4 信号量机制</h3><blockquote><p>进程互斥的解决方案包括软件实现方式：单标志法、双标志先检查、双标志后检查、Peterson算法；硬件实现方式：中断屏蔽方法、TS&#x2F;TSL指令、Swap&#x2F;XCHG指令。但是在双标志先检查法中，进入区的“检查”、“上锁”操作无法一气呵成，从而导致两个进程有可能同时进入临界区的问题；以上所有方法都无法实现“让权等待”原则。1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法——<strong>信号量机制</strong></p></blockquote><p>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</p><p>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。</p><p>原语是一种特殊的程序段，其执行职能一气呵成，不可被中断。原语是由关中断&#x2F;开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</p><p>一对原语：wait(S)原语和signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的信号量S其实就是函数调用时传入的一个参数。</p><p>wait、signal原语常简称为P、V操作(来自荷兰语proberen和verhogen)。因此，做题的时候常把wait(S)、signal(S)两个操作分别写为P(S)、V(S)</p><h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p>用一个<strong>整数型的变量</strong>作为信号量，用来<strong>表示系统中某种资源的数量</strong>。</p><p>与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作</p><p>eg：某计算机系统中有一台打印机……</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">1</span>;<span class="comment">// 初始化整型信号量S，表示当前系统中可用的打印机资源数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span> <span class="params">(<span class="type">int</span> S)</span> &#123;<span class="comment">// wait原语，相当于“进入区”</span></span><br><span class="line">  <span class="keyword">while</span> (S &lt;= <span class="number">0</span>);<span class="comment">// 如果资源数不够，就一直循环等待</span></span><br><span class="line">  S = S - <span class="number">1</span>; <span class="comment">// 如果资源数够，则占用一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(<span class="type">int</span> S)</span> &#123;<span class="comment">// signal原语，相当于“退出区”</span></span><br><span class="line">  S = S + <span class="number">1</span>;<span class="comment">// 使用完资源后，在退出区释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进程P0:</span></span><br><span class="line">...</span><br><span class="line">wati(S);<span class="comment">// 进入区，申请资源</span></span><br><span class="line">使用打印机资源... <span class="comment">// 临界区，访问资源</span></span><br><span class="line">signal(S);<span class="comment">// 退出区，释放资源</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//进程P1:</span></span><br><span class="line">...</span><br><span class="line">wati(S);</span><br><span class="line">使用打印机资源...</span><br><span class="line">signal(S);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//进程P2:</span></span><br><span class="line">...</span><br><span class="line">wati(S);</span><br><span class="line">使用打印机资源...</span><br><span class="line">signal(S);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>wait原语“检查”和“上锁”一气呵成，避免了并发、异步导致的问题。但是还是存在不满足“让权等待”原则，会发生“忙等”</p><h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><p>整型信号量的缺陷是存在“忙等”问题，因此又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记录型信号量的定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> value;<span class="comment">// 剩余资源数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span><span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"><span class="comment">/*某进程需要使用资源时，通过wait原语申请*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span> <span class="params">(semaphore S)</span> &#123;</span><br><span class="line">  S.value--;</span><br><span class="line">  <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    block(S.L)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*进程使用完资源后，通过signal原语释放*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span> <span class="params">(semaphore S)</span> &#123;</span><br><span class="line">  S.value++;</span><br><span class="line">  <span class="keyword">if</span> (S.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    wakeup(S.L);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// P0进程：</span></span><br><span class="line">...</span><br><span class="line">wait(S);</span><br><span class="line">使用打印机...</span><br><span class="line">signal(S);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// P1进程：</span></span><br><span class="line">...</span><br><span class="line">wait(S);</span><br><span class="line">使用打印机...</span><br><span class="line">signal(S);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// P2进程：</span></span><br><span class="line">...</span><br><span class="line">wait(S);</span><br><span class="line">使用打印机...</span><br><span class="line">signal(S);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列（即阻塞队列）中。</p><p>释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态。</p><p>wait(S)、signal(S)也可以记为P(S)、V(S)，用于<strong>实现系统资源的“申请”和“释放”</strong>。</p><p><strong>S.value的初值</strong>表示系统中<strong>某种资源的数目</strong>。</p><p>对信号量S的一次P操作意味着进程<strong>请求一个单位的该类资源</strong>，因此需要执行S.value–, 表示资源数减1，当S.value &lt; 0时表示该类资源已分配完毕，因此进程应<strong>调用block原语进行自我阻塞<strong>（当前运行的进程从</strong>运行态 -&gt; 阻塞态</strong>），主动放弃处理机，并插入该类资源的等待队列S.L中。可见，该机制<strong>遵循了“让权等待”原则</strong>，不会出现“忙等”现象。</p><p>对信号量S的<strong>一次V操作</strong>意味着进程<strong>释放一个单位的该类资源</strong>，因此需要执行S.value++, 表示资源数加1，若加1后仍是S.value &lt;&#x3D;. 0，表示仍然有进程在等待该类资源，因此应**调用wakeup原语唤醒等待队列中第一个进程**（被唤醒进程从阻塞态 -&gt; 就绪态）。</p><h3 id="2-3-5-信号量的应用"><a href="#2-3-5-信号量的应用" class="headerlink" title="2.3.5 信号量的应用"></a>2.3.5 信号量的应用</h3><h4 id="实现进程互斥"><a href="#实现进程互斥" class="headerlink" title="实现进程互斥"></a>实现进程互斥</h4><ol><li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</li><li>设置互斥信号量mutex，初始值为1</li><li>在临界区之前执行P(mutex)</li><li>在临界区之后执行V(mutex)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*信号量机制实现互斥*/</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">// 初始化信号量</span></span><br><span class="line">P1() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(mutex);<span class="comment">// 使用临界资源前需要加锁</span></span><br><span class="line">  临界区代码段...</span><br><span class="line">  V(mutex);<span class="comment">// 使用临界资源后需要解锁</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(mutex);</span><br><span class="line">  临界区代码段...</span><br><span class="line">  V(mutex);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ps: 对<strong>不同的临界资源</strong>需要<strong>设置不同的互斥信号量</strong>。<strong>P、V操作必须成对出现</strong>。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</p><h4 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a>实现进程同步</h4><p>进程同步：各并发进程按要求有序地推进。</p><p>用信号量实现进程同步：</p><ol><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作(或两句代码)</li><li>设置同步信号量S，初始值为0</li><li>在“前操作”之后执行V操作</li><li>在“后操作”之前执行P操作</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*信号量机制实现同步*/</span></span><br><span class="line">semaphore S = <span class="number">0</span>;<span class="comment">// 初始化同步信号量，初始值为0</span></span><br><span class="line">P1() &#123;</span><br><span class="line">  代码<span class="number">1</span>;</span><br><span class="line">  代码<span class="number">2</span>;</span><br><span class="line">  V(S);</span><br><span class="line">  代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">  P(S);</span><br><span class="line">  代码<span class="number">4</span>;</span><br><span class="line">  代码<span class="number">5</span>;</span><br><span class="line">  代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若先执行到V(S)操作，则S++后S &#x3D; 1。之后当执行到P(S)操作时，由于S &#x3D; 1，表示有可用资源，会执行S–，S的值变回0，P2进程不会执行block原语，而是继续往下执行代码4。</p><p>若先执行到P(S)操作，由于S&#x3D;0，S–后S &#x3D; -1，表示此时没有可用资源，因此P操作会执行block原语，主动请求阻塞。之后当执行完代码2，继而执行V(S)操作，S++，使S变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作执行wakeup原语，唤醒P2进程。这样P2就可以继续执行代码4了。</p><h4 id="实现进程的前驱关系"><a href="#实现进程的前驱关系" class="headerlink" title="实现进程的前驱关系"></a>实现进程的前驱关系</h4><p>进程P1中有句代码S1，P2中有句代码S2，… P3 …P6中有句代码S6。这些代码要求按如下前驱图所示的顺序来执行：</p><p><img src="http://1.117.162.142:9000/blog/%E5%89%8D%E9%A9%B1%E5%9B%BE.png" alt="前驱图"></p><p>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）</p><ol><li>要为每一对前驱关系各设置一个同步变量</li><li>在“前操作”之后对相应的同步变量执行V操作</li><li>在“后操作”之前对相应的同步变量执行P操作</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">P1() &#123;</span><br><span class="line">  ...</span><br><span class="line">  S1;</span><br><span class="line">  V(a);</span><br><span class="line">  V(b);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">P2() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(a);</span><br><span class="line">  S2;</span><br><span class="line">  V(c);</span><br><span class="line">  V(d);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">P3() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(b);</span><br><span class="line">  S3;</span><br><span class="line">  V(g);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">P4() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(c);</span><br><span class="line">  S4;</span><br><span class="line">  V(e);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">P5() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(d);</span><br><span class="line">  S5;</span><br><span class="line">  V(f);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">P6() &#123;</span><br><span class="line">  ...</span><br><span class="line">  P(e);</span><br><span class="line">  P(f);</span><br><span class="line">  P(g);</span><br><span class="line">  S6;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-6-生产者-消费者问题"><a href="#2-3-6-生产者-消费者问题" class="headerlink" title="2.3.6 生产者-消费者问题"></a>2.3.6 生产者-消费者问题</h3><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区取出一个产品并使用。（这里的“产品”理解为某种数据）。</p><p>生产者、消费者共享一个初始为空、大小为n的缓冲区。</p><p>分析：</p><ul><li><p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</p><p>  同步关系。缓冲区满时，生产者要等待消费者取走产品</p></li><li><p>只有缓冲区不为空时，消费者才能从中取出产品，否则必须等待。</p><p>  同步关系。缓冲区空时，消费者要等待生产者放入产品</p></li><li><p>缓冲区是临界资源，各进程必须互斥地访问。</p><p>  互斥</p></li></ul><p>处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">// 互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore enpty = n;<span class="comment">// 同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;<span class="comment">// 同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br><span class="line">producer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    生产一个产品;</span><br><span class="line">    P(empty);<span class="comment">// ①</span></span><br><span class="line">    P(mutex);<span class="comment">// ②</span></span><br><span class="line">    把产品放入缓冲区;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(full);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(full);<span class="comment">// ③</span></span><br><span class="line">    P(mutex);<span class="comment">// ④</span></span><br><span class="line">    从缓冲区取出一个产品;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(empty);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：能够修改①和②，③和④的顺序。</p><p>如果修改，若此时缓冲区内已经放满产品，则empty &#x3D; 0，full &#x3D; n。</p><p>则生产者进程执行②使mutex &#x3D; 0，在执行①，由于已经没有空闲缓冲区，因此生产者被阻塞。由于生产者阻塞，因此切换回消费者进程。消费者进程执行④，由于mutex &#x3D; 0，即生产者还没有释放对临界资源的“锁”，因此消费者也被阻塞。</p><p>这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“死锁”。</p><p>同样的，若缓冲区中没有产品，即full &#x3D; 0，empty &#x3D; n。按④③②的顺序执行也会发生死锁。</p><p>因此，<strong>实现互斥的P操作一定要在实现同步的P操作之后</strong>。</p><p>V操作不会导致进程阻塞，因此两个V操作顺序可以交换。</p><h3 id="2-3-7-多生产者-多消费者问题"><a href="#2-3-7-多生产者-多消费者问题" class="headerlink" title="2.3.7 多生产者-多消费者问题"></a>2.3.7 多生产者-多消费者问题</h3><p> 桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可以向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</p><p><strong>分析：</strong></p><p>互斥关系：（mutex &#x3D; 1）</p><p>对缓冲区（盘子）的访问要互斥地进行</p><p>同步关系：（一前一后）</p><ol><li>父亲将苹果放入盘子后，女儿才能取苹果</li><li>母亲将橘子放入盘子后，儿子才能取橘子</li><li>只有盘子为空时，父亲或母亲才能放入水果</li></ol><p><strong>实现：</strong></p><p><img src="http://1.117.162.142:9000/blog/%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85.png" alt="多生产者多消费者"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">// 实现互斥访问盘子（缓冲区）</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;<span class="comment">// 盘子中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>;<span class="comment">// 盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;<span class="comment">// 盘子中还可以放多少个水果</span></span><br><span class="line">dad() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    准备一个苹果;</span><br><span class="line">    P(plate);</span><br><span class="line">    P(mutex);</span><br><span class="line">    把苹果放入盘子;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(apple);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">mom() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    准备一个橘子;</span><br><span class="line">    P(plate);</span><br><span class="line">    P(mutex);</span><br><span class="line">    把橘子放入盘子;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(orange);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">daughter() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(apple);</span><br><span class="line">    P(mutex);</span><br><span class="line">    从盘子中取出苹果;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(plate);</span><br><span class="line">    吃掉苹果;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">son() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(orange);</span><br><span class="line">    P(mutex);</span><br><span class="line">    从盘子中取出橘子;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(plate);</span><br><span class="line">    吃掉橘子;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考：</strong>可不可以不用互斥信号量</p><p><strong>分析：</strong>刚开始，儿子、女儿进程即使上处理机也会被阻塞。如果刚开始是父亲进程先上处理机，则：父亲P(plate)，可以访问盘子 -&gt; 母亲P(plate)，阻塞等待盘子 -&gt; 父亲放入苹果V(apple)，女儿进程被唤醒，其他进程即使运行也都会阻塞，暂时不可能访问临界资源(盘子) -&gt; 女儿P(apple)，访问盘子，V(plate)，等待盘子的母亲进程被唤醒 -&gt; 母亲进程访问盘子（其他进程暂时都无法进入临界区） -&gt; ……</p><p><strong>结论：</strong></p><p>当缓冲区的容量为1时，即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象。因为缓冲区的大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区……但是，当缓冲区的容量大于1时，会出现两个进程同时访问缓冲区的情况，有可能导致连个进程写入缓冲区的数据相互覆盖的情况。所以，如果缓冲区的大小大于1，就必须专门设置一个互斥信号量mutex来保证互斥访问缓冲区。</p><p><strong>总结：</strong></p><p>在生产者-消费者问题中，如果缓冲区大小为1，那么<strong>有可能</strong>不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</p><h3 id="2-3-8-吸烟者问题"><a href="#2-3-8-吸烟者问题" class="headerlink" title="2.3.8 吸烟者问题"></a>2.3.8 吸烟者问题</h3><p><strong>描述：</strong></p><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一只烟，抽烟者需要三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放在桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复（让三哥抽烟者轮流地抽烟）</p><p><strong>分析：</strong></p><ul><li>组合一：纸+胶水</li><li>组合二：烟草+胶水</li><li>组合三：烟草+纸</li></ul><p>同步关系：</p><ul><li>桌子上有组合一 -&gt; 第一个抽烟者取走东西</li><li>桌子上有组合二 -&gt; 第二个抽烟者取走东西</li><li>桌子上有组合三 -&gt; 第三个抽烟者取走东西</li><li>发出完成信号 -&gt; 供应者将下一个组合放到桌子上</li></ul><p><img src="http://1.117.162.142:9000/blog/%E6%8A%BD%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98.png" alt="抽烟者问题"></p><p><strong>实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>;<span class="comment">// 桌上组合一的数量</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>;<span class="comment">// 桌上组合二的数量</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>;<span class="comment">// 桌上组合三的数量</span></span><br><span class="line">semaphore finish = <span class="number">0</span>;<span class="comment">// 抽烟是否完成</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;<span class="comment">// 用于实现“三个抽烟者轮流抽烟”</span></span><br><span class="line">provider() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      将组合一放桌上;</span><br><span class="line">      V(offer1);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">      将组合二放桌上;</span><br><span class="line">      V(offer2);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>) &#123;</span><br><span class="line">      将组合三放桌上;</span><br><span class="line">      V(offer3);</span><br><span class="line">    &#125;</span><br><span class="line">    i = (i + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">    P(finish);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker1() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(offer1):</span><br><span class="line">    从桌上拿走组合一;</span><br><span class="line">    卷烟;</span><br><span class="line">    抽掉;</span><br><span class="line">    V(finish);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker2() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(offer2):</span><br><span class="line">    从桌上拿走组合二;</span><br><span class="line">    卷烟;</span><br><span class="line">    抽掉;</span><br><span class="line">    V(finish);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker3() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(offer3):</span><br><span class="line">    从桌上拿走组合三;</span><br><span class="line">    卷烟;</span><br><span class="line">    抽掉;</span><br><span class="line">    V(finish);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-9-读者-写者问题"><a href="#2-3-9-读者-写者问题" class="headerlink" title="2.3.9 读者-写者问题"></a>2.3.9 读者-写者问题</h3><p> <strong>问题</strong>：</p><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p><ol><li>允许多个读者可以同时对文件执行读操作；</li><li>只允许一个写者往文件中写信息；</li><li>任一写者在完成写操作之前不允许其他读者或写者工作；</li><li>写者执行写操作前，应让已有的读者和写者全部退出。</li></ol><p><strong>分析：</strong></p><p>两类进程：写进程、读进程</p><p>互斥关系：写进程—写进程、写进程—读进程。读进程与读进程不存在互斥关系。</p><ul><li><p>写者进程和任何进程都互斥，设置一个互斥信号量rw，在写者访问共享文件前后分别执行P、V操作。</p></li><li><p>读者进程和写者进程也要互斥，因此读者访问共享文件前后也要对rw执行P、V操作。</p></li><li><p>如果所有读者进程在访问共享文件之前都执行P(rw)操作，那么会导致各个读进程之间无法同时访问文件。</p></li><li><p><strong>读者写者问题的核心思想——怎么处理该问题呢？</strong></p><p>  P(rw)和V(rw)其实就是对共享文件的“加锁”和“解锁”。既然各个读进程需要同时访问，而读进程与写进程又必须互斥访问，那么我们可以让第一个访问文件的读进程“加锁”，让最后一个访问完文件的读进程“解锁”。可以设置一个整数变量count来记录当前有几个读进程在访问文件。</p></li></ul><p><strong>实现一：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>;<span class="comment">// 用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">writer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(rw);<span class="comment">// 写之前“加锁”</span></span><br><span class="line">    写文件...;</span><br><span class="line">    V(rw);<span class="comment">// 写之后“解锁”</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">      P(rw);<span class="comment">// 第一个读进程负责“加锁”</span></span><br><span class="line">    &#125;</span><br><span class="line">    count++;<span class="comment">// 访问文件的进程书+1</span></span><br><span class="line">    读文件...;</span><br><span class="line">    count--;<span class="comment">// 访问文件的读进程数-1</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">      V(rw);<span class="comment">// 最后一个读进程负责“解锁“</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考：</strong></p><p>若两个读进程并发执行，则两个读进程可能先后执行P(rw), 从而使第二个读进程阻塞的情况。</p><p>如何解决：</p><p>出现上述问题的原因在于对count变量的检查和赋值无法一气呵成，因此可以设置另一个互斥信号量来保证各读进程count的访问时互斥的。</p><p><strong>实现二：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>;<span class="comment">// 用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">// 用于保证对count变量的互斥访问 </span></span><br><span class="line">writer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(rw);<span class="comment">// 写之前“加锁”</span></span><br><span class="line">    写文件...;</span><br><span class="line">    V(rw);<span class="comment">// 写之后“解锁”</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(mutex);<span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">      P(rw);<span class="comment">// 第一个读进程负责“加锁”</span></span><br><span class="line">    &#125;</span><br><span class="line">    count++;<span class="comment">// 访问文件的进程书+1</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    读文件...;</span><br><span class="line">    P(mutex);<span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">    count--;<span class="comment">// 访问文件的读进程数-1</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">      V(rw);<span class="comment">// 最后一个读进程负责“解锁“</span></span><br><span class="line">    &#125;</span><br><span class="line">    V(mutex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>潜在的问题：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此，这种算法中，读进程是优先的。</p></blockquote><p><strong>实现三：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw = <span class="number">1</span>;<span class="comment">// 用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">// 记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">// 用于保证对count变量的互斥访问 </span></span><br><span class="line">semaphore w = <span class="number">1</span>;<span class="comment">// 用于实现“写优先”</span></span><br><span class="line">writer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(w);</span><br><span class="line">    P(rw);<span class="comment">// 写之前“加锁”</span></span><br><span class="line">    写文件...;</span><br><span class="line">    V(rw);<span class="comment">// 写之后“解锁”</span></span><br><span class="line">    V(w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">reader() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(w);</span><br><span class="line">    P(mutex);<span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">      P(rw);<span class="comment">// 第一个读进程负责“加锁”</span></span><br><span class="line">    &#125;</span><br><span class="line">    count++;<span class="comment">// 访问文件的进程书+1</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    V(w);</span><br><span class="line">    读文件...;</span><br><span class="line">    P(mutex);<span class="comment">// 各读进程互斥访问count</span></span><br><span class="line">    count--;<span class="comment">// 访问文件的读进程数-1</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">      V(rw);<span class="comment">// 最后一个读进程负责“解锁“</span></span><br><span class="line">    &#125;</span><br><span class="line">    V(mutex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><p>在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。也称为“读写公平法”。</p><h3 id="2-3-10-哲学家进餐问题"><a href="#2-3-10-哲学家进餐问题" class="headerlink" title="2.3.10 哲学家进餐问题"></a>2.3.10 哲学家进餐问题</h3><p><strong>问题：</strong></p><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌子摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子(一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p><p><img src="http://1.117.162.142:9000/blog/%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98.png" alt="哲学家进餐问题"></p><p><strong>分析：</strong></p><ol><li>关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</li><li>整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。</li><li>信号量设置。定义互斥信号量数组chopstick[5]&#x3D;{1,1,1,1,1}用于实现对5个筷子的互斥访问。并对哲学家按0～4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5。</li></ol><p><strong>思考：</strong></p><p>如何防止死锁的发生？</p><ol><li>可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。</li><li>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一支筷子，另一个会直接阻塞。这就避免了占有一只后再等待另一只的情况。</li><li>规定同时只有一个哲学家能拿起筷子吃饭</li></ol><p><strong>实现3：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">// 互斥地取筷子</span></span><br><span class="line">Pi() &#123;<span class="comment">// i号哲学家的进程</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    P(mutex);</span><br><span class="line">    P(chopstick[i]);<span class="comment">// 拿左边的筷子</span></span><br><span class="line">    p(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">// 拿右边的筷子</span></span><br><span class="line">    V(mutex);</span><br><span class="line">    吃饭...;</span><br><span class="line">    V(chopstick[i]);<span class="comment">// 放下左边的筷子</span></span><br><span class="line">    V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);<span class="comment">// 放下右边的筷子</span></span><br><span class="line">    思考...;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-11-管程"><a href="#2-3-11-管程" class="headerlink" title="2.3.11 管程"></a>2.3.11 管程</h3><h4 id="为什么要引入管程"><a href="#为什么要引入管程" class="headerlink" title="为什么要引入管程"></a>为什么要引入管程</h4><p>信号量机制存在的问题：编写程序困难、易出错。程序员在编程时需要关注复杂的PV操作。</p><h4 id="管程的定义和基本特征"><a href="#管程的定义和基本特征" class="headerlink" title="管程的定义和基本特征"></a>管程的定义和基本特征</h4><p>管程是一种特殊的软件模块，有这些部分组成：</p><ol><li>局部于管程的<strong>共享数据结构</strong>说明；</li><li>对该数据结构进行操作的<strong>一组过程</strong>（“过程”就是“函数”）；</li><li>对局部于管程的<strong>共享数据设置初始值的语句</strong>；</li><li>管程有一个名字。</li></ol><p><strong>管程的基本特征</strong>：</p><ol><li>局部于管程的数据智能被局部于管程的过程所访问；</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li><li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong>。</li></ol><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p><strong>用管程解决生产中消费者问题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">  condition full, empty;<span class="comment">//条件变量用来实现同步（排队）</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;<span class="comment">// 缓冲区中的产品数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(count == N) &#123;</span><br><span class="line">      wait(full);</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">    insert_item(item);</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">1</span>) &#123;</span><br><span class="line">      signal(empty);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">Item <span class="title function_">remove</span><span class="params">()</span> &#123;<span class="comment">// 从缓冲区中取出一个产品</span></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">      wait(empty);</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span>(count == N<span class="number">-1</span>) &#123;</span><br><span class="line">      signal(full);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> remove_item();</span><br><span class="line">  &#125;</span><br><span class="line">end monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line">producer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    item = 生产一个产品;</span><br><span class="line">    ProducerConsumer.insert(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者进程</span></span><br><span class="line">consumer() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    item = ProducerConsumer.remove();</span><br><span class="line">    消费产品item;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>管程中设置条件变量和等待&#x2F;唤醒操作，以解决同步问题。</p><p><strong>由编译器负责实现个进程互斥地进入管程中的过程。</strong></p></blockquote><p>引入管程的目的无非就是要更方便地实现进程互斥和同步。</p><ol><li>需要在管程中定义共享数据(如生产者消费者问题中的缓冲区)</li><li>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数（如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，在定义一个函数用于从缓冲区取出产品）</li><li>只有<strong>通过这些特定的“入口”才能访问共享数据</strong></li><li>管程中有很多“入口”，但是<strong>每次只能开放其中一个“入口”</strong>，并且<strong>只能让一个进程或线程进入</strong>（如生产者消费者问题中，个进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意：<strong>这种互斥特性是由编译器负责实现的，程序员不用关心</strong>。）</li><li>可在管程中设置条件变量即等待&#x2F;唤醒操作以解决同步问题。可以让一个进程或线程在田间变量上等待（此时，该进程应先释放管程的使用权，也就是让出“入口”）；可以通过唤醒操作将等待在条件上的进程或线程唤醒。</li></ol><p><strong>Java中，如果用关键字Synchronized来描述一个函数，那么这个函数同一时间段内只能被一个线程调用</strong>。</p><h3 id="2-4-1-死锁的概念"><a href="#2-4-1-死锁的概念" class="headerlink" title="2.4.1 死锁的概念"></a>2.4.1 死锁的概念</h3><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>在并发环境下，个进程因竞争资源而造成的一种**互相等待对方手里的资源，导致进程都阻塞，都无法向前推进的现象，就是死锁。</p><h4 id="死锁、饥饿、死循环的区别"><a href="#死锁、饥饿、死循环的区别" class="headerlink" title="死锁、饥饿、死循环的区别"></a>死锁、饥饿、死循环的区别</h4><p>死锁：各进程相互等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p><p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先(SPF)算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</p><p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。</p><table><thead><tr><th align="center"></th><th align="center">区别</th></tr></thead><tbody><tr><td align="center">死锁</td><td align="center">死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那至少<strong>有两个或两个以上的进程同时发生死锁</strong>。另外，发生死锁的进程一定处于阻塞态。</td></tr><tr><td align="center">饥饿</td><td align="center"><strong>可能只有一个进程发生饥饿</strong>。发生饥饿的进程既可能是阻塞态（如长期得不到需要的I&#x2F;O设备），也可能是就绪态（长期得不到处理机）</td></tr><tr><td align="center">死循环</td><td align="center">可能只有一个进程发生死循环。死循环的进程可以上处理机运行(可以是运行态)，只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。<strong>死锁和饥饿是管理者(操作系统)的问题，死循环是被管理者的问题</strong></td></tr></tbody></table><blockquote><p>共同点：都是进程无法顺利向前推进的现象（故意设计的死循环除外）。</p></blockquote><h4 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h4><p>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ol><li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源)。</li><li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ol><p>Tips：发生死锁时一定有循环等待，但是发生循环等待时未必死锁(循环等待是死锁的必要不充分条件)。如果同类资源数大于1，则及时有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p><h4 id="什么时候会发生死锁"><a href="#什么时候会发生死锁" class="headerlink" title="什么时候会发生死锁"></a>什么时候会发生死锁</h4><ol><li>对系统资源的竞争。各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引起死锁的。</li><li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两种会因为申请的资源被对方占有而阻塞，从而发生死锁。</li><li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看作是一种抽象的系统资源）</li></ol><p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p><h3 id="2-4-2-死锁的处理策略-预防死锁"><a href="#2-4-2-死锁的处理策略-预防死锁" class="headerlink" title="2.4.2 死锁的处理策略-预防死锁"></a>2.4.2 死锁的处理策略-预防死锁</h3><h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。</p><p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如SPOOLing技术。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备……</p><p>该策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。</p><h4 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h4><p>不剥夺条件：进程所获得的资源在未使用完之前，不能有其他进程强行夺走，只能主动释放。</p><p>破坏不剥夺条件：</p><p>方案一：当某个进程请求新的资源得不到满足时，他必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p><p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级(比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)</p><p>该策略的缺点：</p><ol><li>实现起来比较复杂</li><li>释放已获得的资源可能造成前一阶段工作的实效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li></ol><h4 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h4><p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</p><p>可以采用静态分配方法，即进程在运行前一次申请完他所需要的全部资源，在他的资源为满足前，不让他投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p><p>该策略实现起来简单，但也有明显的缺点：</p><p>有些资源可能只需要很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</p><h4 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h4><p>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</p><p>可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（机编号相同的资源）一次申请完。</p><p>原理分析：一个进程只有已占有小编好的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编好的资源，从而就不会产生循环等待的现象。</p><p>该策略的缺点：</p><ol><li>不方便增加新的设备，因为可能需要重新分配所有的编号</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li><li>必须按规定次序申请资源，用户编程麻烦</li></ol><h3 id="2-4-3-死锁的处理策略-避免死锁"><a href="#2-4-3-死锁的处理策略-避免死锁" class="headerlink" title="2.4.3 死锁的处理策略-避免死锁"></a>2.4.3 死锁的处理策略-避免死锁</h3><h4 id="什么是安全序列"><a href="#什么是安全序列" class="headerlink" title="什么是安全序列"></a>什么是安全序列</h4><p><strong>银行家算法：</strong></p><p>你是一位成功的银行家，手里掌握着100个亿的资金……有三个企业想找你贷款，分别是企业B、企业A、企业T，为了方便描述，简称BAT。</p><ul><li>B表示：“大哥，我最多会跟你姐70亿……”</li><li>A表示：“大哥，我最多会跟你借40亿……”</li><li>T表示：“大哥，我最多会跟你借50亿……”</li></ul><p>然而江湖中有个不成文的规矩：如果你借给企业的钱总数达不到企业提出的最大要求，那么不管你之前给企业借了多少钱，那些钱都拿不回来了……</p><p>刚开始，BAT三个企业分别从你这借了20、10、30亿……</p><table><thead><tr><th align="center"></th><th align="center">最大需求</th><th align="center">已借走</th><th align="center">最多还会借</th></tr></thead><tbody><tr><td align="center">B</td><td align="center">70</td><td align="center">20</td><td align="center">50</td></tr><tr><td align="center">A</td><td align="center">40</td><td align="center">10</td><td align="center">30</td></tr><tr><td align="center">T</td><td align="center">50</td><td align="center">30</td><td align="center">20</td></tr></tbody></table><p>所谓<strong>安全序列</strong>，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</p><p>如果分配了资源之后，系统中找不到任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。</p><p>银行家算法是荷兰学者Dijkstra为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用来避免死锁。</p><p><strong>核心思想：</strong>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p><p>可以把单维的数字拓展为多维的向量。比如：系统中有5个进程P0～P4，3中资源R0～R2，初始数量为(10，5，7)。</p><p>假设系统中有n个进程，m种资源，每个进程在运行前先声明对各种资源的最大需求数，则可用一个n×m的矩阵(可用二维数组实现)表示所有进程对各种资源的最大需求数。不妨称为最大需求矩阵Max，Max[i,j]&#x3D;k表示进程Pi最多需要k个资源Rj。同理，系统可以用一个n×m的分配矩阵Allocation表示对所有进程的资源分配情况。Max-Allocation&#x3D;Need矩阵，表示各进程最多还需要多少各类子资源。</p><p>另外，还要用一个长度为m的一维数组Available表示当前系统中还有多少可用资源。</p><p>某进程Pi向系统申请资源，可用一个长度为m的一维数组Request<sub>i</sub>表示本次申请的各种资源量。</p><p>可用银行家算法预判本次分配是否会导致系统进入不安全状态：</p><ol><li><p>如果Request<sub>i</sub>[j]&lt;&#x3D;Need[i,j] (0&lt;&#x3D;j&lt;&#x3D;m) 便转向2；否则认为出错。</p></li><li><p>如果Request<sub>i</sub>[j]&lt;&#x3D;Available[j] (0&lt;&#x3D;j&lt;&#x3D;m)，便转向3；否则表示尚无足够资源，Pi必须等待。</p></li><li><p>系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判）：</p><p> Available &#x3D; Available - Request<sub>i</sub> ;</p><p> Allocation[i,j] &#x3D; Allocation[i, j] + Request<sub>i</sub>[j] ;</p><p> Need[i, j] &#x3D; Need[i, j] - Request<sub>i</sub>[j]</p></li><li><p>操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。</p></li></ol><h3 id="2-4-4-死锁的处理策略-检测和解除"><a href="#2-4-4-死锁的处理策略-检测和解除" class="headerlink" title="2.4.4 死锁的处理策略-检测和解除"></a>2.4.4 死锁的处理策略-检测和解除</h3><p>数据结构：资源分配图</p><p><img src="http://1.117.162.142:9000/blog/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png" alt="资源分配图"></p><ul><li>两种节点<ul><li>进程节点：对应一个进程</li><li>资源节点：对应一类资源，一类资源可能有多个</li></ul></li><li>两种边<ul><li>进程节点 -&gt; 资源节点：表示进程想申请几个资源（每条边代表一个）</li><li>资源节点 -&gt; 进程节点：表示已经为进程分配了几个资源（每条边代表一个）</li></ul></li></ul><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><p>为了能对系统是否已发生了死锁进行检测，必须：</p><p>①用某种数据结构来保存资源的请求和分配信息；</p><p>②提供一种算法，利用上述信息来检测系统是否已进入死锁状态。</p><p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程……</p><p>如果按上述过程分析，最终能消除所有边，就称这个图是<strong>可完全简化的</strong>。此时一定没有发生死锁（相当于能找到一个安全序列）</p><p>如果最终不能消除所有边，那么此时就是发生了死锁。</p><p>最终还连着边的那些进程就是处于死锁状态的进程。</p><p><strong>检测死锁的算法：</strong></p><ol><li>在资源分配图中，找出既不阻塞又不是孤点的进程Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。</li><li>进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。</li></ol><p>死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。</p><h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h4><p>一旦检测出死锁的发生，就应该立即揭出死锁。</p><p>补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法<strong>化简资源分配图后，还连着边的那些进程就是死锁进程</strong></p><p>解除死锁的主要方法有：</p><ol><li>资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占他的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li></ol><p>Tips：如何决定“对谁下手“</p><ol><li>进程优先级</li><li>已执行多长时间</li><li>还要多久能完成</li><li>进程已经使用了多少资源</li><li>进程是交互式的还是批处理式的</li></ol><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="3-1-1-内存的基础知识"><a href="#3-1-1-内存的基础知识" class="headerlink" title="3.1.1 内存的基础知识"></a>3.1.1 内存的基础知识</h3><h4 id="什么是内存，有何作用"><a href="#什么是内存，有何作用" class="headerlink" title="什么是内存，有何作用"></a>什么是内存，有何作用</h4><p>内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。</p><p><img src="http://1.117.162.142:9000/blog/%E5%86%85%E5%AD%98.png" alt="内存"></p><p>内存中各有一个一个的“小房间”，每个小房间就是一个“存储单元”。如果计算机“按字节编址”，则每个存储单元大小为1字节，即1B，即8个二进制位。</p><p>内存地址从0开始，每个地址对应一个存储单元</p><p><strong>常见的数量单位</strong></p><p>2<sup>10</sup> &#x3D; 1K(千)</p><p>2<sup>20</sup> &#x3D; 1M(兆，百万)</p><p>2<sup>30</sup> &#x3D; 1G(十亿，千兆)</p><p>Ps：一台手机&#x2F;电脑有4GB内存，是什么意思？</p><p>是指该内存中可以存放4*2<sup>30</sup>个字节。如果是按字节编址的话，也就是有4*<sup>30</sup> &#x3D; 2<sup>32</sup>个“小房间”。这么多“小房间”，需要2<sup>32</sup>个地址才能一一标识，所以地址需要用32个二进制位来表示（0～2<sup>32</sup>-1）。</p><h4 id="进程运行的基本原理"><a href="#进程运行的基本原理" class="headerlink" title="进程运行的基本原理"></a>进程运行的基本原理</h4><p><strong>指令</strong></p><p>我们平时写的代码通过编译成CPU能够识别的指令。指令会告诉CPU应该去内存的哪个地址存&#x2F;取数据，这个数据应该做怎样的处理。</p><p><strong>逻辑地址 &amp; 物理地址</strong></p><blockquote><p>宿舍四个人一起出去旅行，四个人的学号尾号分别是0、1、2、3。住酒店时，酒店给你们安排了4个房号相连的房间。四个人按学号递增次序入住房间。比如0、1、2、3号同学分别去住了5、6、7、8号房间。四个人的编号0、1、2、3、4其实就是一个“相对位置”，而各自入住的房间号是一个“绝对位置”。只要知道0号同学住的是房间号为N的房间，那么M号同学的房号一定是N+M。也就是说，只要知道各个同学的“相对位置”和“起始房号”，就一定可以算出所有同学的“绝对位置”</p></blockquote><p>指令中的地址也可以采用这种思想。编译时产生的指令只关心“相对地址”，实际放入内存中时再想办法根据起始位置得到“绝对地址”。</p><p>eg：编译时只需要确定变量x存放的相对地址是100（也就是说相对进程在内存中的起始地址而言的地址）。CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。</p><p><strong>相对地址</strong>又称<strong>逻辑地址</strong>，<strong>绝对地址</strong>又称<strong>物理地址</strong>。</p><p><strong>从写程序到程序运行</strong></p><p><img src="http://1.117.162.142:9000/blog/%E4%BB%8E%E5%86%99%E7%A8%8B%E5%BA%8F%E5%88%B0%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C.png" alt="从写程序到程序运行"></p><p>编译：由编译程序将用户源码编译成若干个目标模块(编译就是把高级语言翻译为机器语言)</p><p>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块</p><p>装入(装载)：由装入程序将装入模块装入内存运行</p><h4 id="三种链接方式："><a href="#三种链接方式：" class="headerlink" title="三种链接方式："></a>三种链接方式：</h4><ul><li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件(装入模块)，之后不再拆开。</li><li>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式。</li><li>运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</li></ul><h4 id="三种装入方式："><a href="#三种装入方式：" class="headerlink" title="三种装入方式："></a>三种装入方式：</h4><p><strong>绝对装入</strong></p><p>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。</p><p>绝对装入<strong>只适合用于单道程序环境</strong>。程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时在转换为绝对地址。</p><p><strong>静态重定位</strong></p><p>又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时依次完成的）。</p><p>静态重定位的特点是在一个作业装入内存时，必须分配器要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</p><p><strong>动态重定位</strong></p><p>又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。</p><p>重定位寄存器：存放装入模块存放的起始位置。</p><p>采用动态重定位时允许程序在内存中发生移动。并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</p><h3 id="3-1-2-内存管理的概念"><a href="#3-1-2-内存管理的概念" class="headerlink" title="3.1.2 内存管理的概念"></a>3.1.2 内存管理的概念</h3><blockquote><p>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？</p></blockquote><h4 id="内存空间的分配与回收"><a href="#内存空间的分配与回收" class="headerlink" title="内存空间的分配与回收"></a>内存空间的分配与回收</h4><p>操作系统负责内存空间的分配与回收</p><h4 id="内存空间的扩展"><a href="#内存空间的扩展" class="headerlink" title="内存空间的扩展"></a>内存空间的扩展</h4><p>操作系统需要提供某种技术从逻辑上对<strong>内存空间进行扩充</strong></p><h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而<strong>逻辑地址到物理地址的转换</strong>(这个过程称为地址定位)应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。</p><h4 id="存储保护"><a href="#存储保护" class="headerlink" title="存储保护"></a>存储保护</h4><p>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰。</p><p>方法一：</p><p>在CPU设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</p><p>方法二：采用<strong>重定位寄存器</strong>(又称<strong>基址寄存器</strong>)和<strong>界地址寄存器</strong>(又称<strong>限长寄存器</strong>)进行越界检查。重定位寄存器中存放的是进程的<strong>起始物理地址</strong>。界地址寄存器中存放的是进程的<strong>最大逻辑地址</strong>。</p><h3 id="3-1-3-覆盖与交换"><a href="#3-1-3-覆盖与交换" class="headerlink" title="3.1.3 覆盖与交换"></a>3.1.3 覆盖与交换</h3><h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><blockquote><p>早起的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常会出现内存大小不够的情况。后来人们引入了覆盖技术，用来解决“程序大小超过物理内存综合”的问题。</p></blockquote><p>覆盖技术的思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时掉入内存。</p><p>内存中分为一个“固定区”和若干个“覆盖区”。</p><p>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）</p><p>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存。</p><p><img src="http://1.117.162.142:9000/blog/%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF.png" alt="覆盖技术"></p><p>按照自身逻辑结构，让那些不可能同时被访问的程序段共享同一个覆盖区。</p><p>缺点：必须由程序员声明覆盖结构，操作系统完成自动覆盖。对用户不透明，增加了用户编程负担。覆盖技术只用于早起的操作系统中，现在已成为历史。</p><h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><p>交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</p><p>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</p><p>暂时换出外存等待的进程状态为挂起状态（挂起态，suspend）</p><p>挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</p><ol><li><p>应该在外存（磁盘）的什么位置保存被换出的进程？</p><p> <img src="http://1.117.162.142:9000/blog/%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4.png" alt="磁盘存储空间"></p><p> 具有对换功能的操作系统中，通常把磁盘空间分为<strong>文件区</strong>和<strong>对换区</strong>两部分。文件区主要用于存放文件，<strong>主要追求存储空间的利用率</strong>，因此对文件区空间的管理<strong>采用离散分配方式</strong>；对换区空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理<strong>主要追求换入换出速度</strong>，因此通常对换区<strong>采用连续分配方式</strong>。总之，<strong>对换区的I&#x2F;O速度比文件区的更快</strong>。</p></li><li><p>什么时候应该交换？</p><p> 交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停，例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。</p></li><li><p>应该换出哪些进程？</p><p> 可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间……</p></li></ol><blockquote><p>Tip：PCB会常驻内存，不会被换出外存。</p></blockquote><h3 id="3-1-4-连续分配管理方式"><a href="#3-1-4-连续分配管理方式" class="headerlink" title="3.1.4 连续分配管理方式"></a>3.1.4 连续分配管理方式</h3><h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><p><img src="http://1.117.162.142:9000/blog/%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D.png" alt="单一连续分配"></p><p>在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。</p><p>内存中只能有一道用户程序，用户程序独占整个用户区空间。</p><p>优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早起的PC操作系统MS-DOS）。</p><p>缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。</p><h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><p><img src="http://1.117.162.142:9000/blog/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D.png" alt="固定分区分配"></p><p>20世纪60年代出现了多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会互相干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p><p>固定分区分配与两种方式：</p><ul><li><p>分区大小相等</p><p>  缺乏灵活性，但是很适用于一台计算机控制多个相同对象的场合（比如：钢铁厂有n个相同的锻钢炉，就可以把内存分为n个大小相等的区域存放n个炼钢炉控制程序）</p></li><li><p>分区大小不等</p><p>  增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区、适量中等分区、少量大分区）</p></li></ul><p>操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表象对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。</p><table><thead><tr><th align="center">分区号</th><th align="center">大小（MB）</th><th align="center">起始地址（M）</th><th align="center">状态</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">2</td><td align="center">8</td><td align="center">未分配</td></tr><tr><td align="center">2</td><td align="center">2</td><td align="center">10</td><td align="center">未分配</td></tr><tr><td align="center">3</td><td align="center">4</td><td align="center">12</td><td align="center">已分配</td></tr><tr><td align="center">……</td><td align="center">……</td><td align="center">……</td><td align="center">……</td></tr></tbody></table><p>当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。</p><p>优点：实现简单，无外部碎片。</p><p>缺点：</p><ul><li>当用户程序太大时，可能所有的分区都不满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能</li><li>会产生内部碎片，内存利用率低。</li></ul><h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p>动态分区又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg：假设某计算机内存大小为64MB，系统区8MB，用户区共56MB……）</p><ol><li><p>系统要用什么样的数据结构记录内存的使用情况？</p><p> 两种常用的数据结构：空闲分区表和空闲分区链。</p><table><thead><tr><th align="center">分区号</th><th align="center">大小（MB）</th><th align="center">起始地址（M）</th><th align="center">状态</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">20</td><td align="center">8</td><td align="center">空闲</td></tr><tr><td align="center">2</td><td align="center">10</td><td align="center">32</td><td align="center">空闲</td></tr><tr><td align="center">3</td><td align="center">4</td><td align="center">64</td><td align="center">空闲</td></tr></tbody></table><p> 空闲分区表：每个空闲分区对应一个表项。表项中包含分区好、分区大小、分区起始地址等信息。</p><p> <img src="http://1.117.162.142:9000/blog/%E7%A9%BA%E9%97%B2%E5%88%86%E5%8C%BA%E9%93%BE.png" alt="固定分区分配"></p><p> 空闲分区链：每个分区的起始部分和末尾部分分别设置向前指针和向后指针。起始部分处还可记录分区大小等信息。</p></li><li><p>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p><p> 把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。</p></li><li><p>如何进行分区的分配与回收操作？</p><ul><li><p>回收区的后面又一个相邻的空闲分区</p><p>  两个相邻的空闲分区合并为一个</p></li><li><p>回收区的前面有一个相邻的空闲分区</p><p>  两个相邻的空闲分区合并为一个</p></li><li><p>回收区前后各有一个相邻的空闲分区</p><p>  三个相邻的空闲分区合并为一个</p></li><li><p>回收区的前后都没有相邻的空闲分区</p><p>  新增一个表项</p><p>  各表项的顺序不一定按照地址递增顺序排序，具体的排序方式需要依据动态分区分配算法来确定。</p></li></ul><p> 动态分区分配没有内部碎片，但是有外部碎片。</p><p> 内部碎片：分配给某进程的内存区域中，如果有些部分没有用上。</p><p> 外部碎片：是指内存中的某些空闲分区由于太小而难以利用。</p><p> 如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片“不能满足进程的需求。</p><p> 可通过紧凑（拼凑，Compaction）技术来解决外部碎片。</p></li></ol><h3 id="3-1-5-动态分区分配算法"><a href="#3-1-5-动态分区分配算法" class="headerlink" title="3.1.5 动态分区分配算法"></a>3.1.5 动态分区分配算法</h3><h4 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h4><p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</p><p>实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><h4 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h4><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲去，即，优先使用更小的空闲去。</p><p>实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。</p><h4 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h4><p>又称最大适应算法（Largest Fit）</p><p>算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p><p>实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后“大进程”到达，就没有内存分区可用了。</p><h4 id="临近适应算法"><a href="#临近适应算法" class="headerlink" title="临近适应算法"></a>临近适应算法</h4><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p><p>实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）。</p><p>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）</p><h3 id="3-1-6-基本分页存储管理的基本概念"><a href="#3-1-6-基本分页存储管理的基本概念" class="headerlink" title="3.1.6 基本分页存储管理的基本概念"></a>3.1.6 基本分页存储管理的基本概念</h3><p><strong>把“固定分区分配”改造为“非连续分配版本”</strong></p><p>假设进程A大小为23MB，但是每个分区大小只有10MB，如果进程只能占用一个分区，那显然放不下。</p><p>解决思路：如果允许进程占用多个分区，那么可以把进程拆分成10MB+10MB+3MB三个部分，再把这三个部分分别放到三个分区中（这些分区不要求连续）……</p><p>进程A的最后一个部分是3MB，放入分区后会残生7MB的内部碎片。</p><p>如果每个分区大小为2MB，那么进程A可以拆分成11*2MB + 1MB共12个部分，只有最后一部分1MB占不满分区，会产生1MB的内部碎片。</p><p>显然，如果把分区大小设置得更小一些，内存碎片会更小，内存利用率会更高。</p><blockquote><p>基本分页存储的思想：把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分。</p></blockquote><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>将内存空间分为一个个大小相等的分区（比如：每个分区4KB），每个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“页框号”（或者“内存块号”、“页帧号”、“物理块号”）页框号从0开始。</p><p>将用户进程的地址空间也分为与页框大小相等的一个个区域，称为”页“或”页面“。每个页面也有一个编号，即”页号“，页号也是从0开始。</p><p>ps：进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片）</p><p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。</p><p>各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。</p><h4 id="如何实现地址的转换"><a href="#如何实现地址的转换" class="headerlink" title="如何实现地址的转换"></a>如何实现地址的转换</h4><p>将进程地址空间分页后，操作系统该如何实现逻辑地址到物理地址的转换？</p><p><img src="http://1.117.162.142:9000/blog/%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="地址转换"></p><p>CPU执行指令1，需要访问逻辑地址为80的内存单元，如何转化为物理地址？</p><p>逻辑地址为80的内存单元：</p><p>应该在1号页，该页在内存中的起始位置为450，逻辑地址为80的内存单元相对于该页的起始地址而言，“偏移量”应该是30。实际物理地址 &#x3D; 450 + 30 &#x3D; 480</p><ol><li>要算出逻辑地址对应的页号</li><li>要知道该页号对应页面在内存中的起始地址</li><li>要算出逻辑地址在页面内的“偏移量”</li><li>物理地址 &#x3D; 页面地址 + 页内偏移量</li></ol><p>如何计算：</p><p>页号 &#x3D; 逻辑地址 &#x2F; 页面长度 （取除法的整数部分）</p><p>页内偏移量 &#x3D; 逻辑地址 % 页面长度 （取除法的余数部分）</p><p>页面在内存中的起始位置：操作系统需要某种数据结构记录进程各个页面的起始位置。</p><p>页号 &#x3D; 80 &#x2F; 50 &#x3D; 1</p><p>页内偏移量 &#x3D; 80 % 50 &#x3D; 30</p><p>1号页在内存中存放的起始位置450</p><p>为了方便计算页号、页内偏移量，页面大小一般设为2的整数幂</p><h4 id="如何知道该页号对应页面在内存中的起始地址"><a href="#如何知道该页号对应页面在内存中的起始地址" class="headerlink" title="如何知道该页号对应页面在内存中的起始地址"></a>如何知道该页号对应页面在内存中的起始地址</h4><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。</p><ol><li>一个进程对应一张页表</li><li>进程的每一页对应一个页表项</li><li>每个页表项由“页号”和“块号”组成</li><li>页表记录进程页面和实际存放的内存块之间的对应关系</li><li>每个页表项的长度是相同的，页号是“隐含“的</li></ol><h3 id="3-1-7基本地址变换机构"><a href="#3-1-7基本地址变换机构" class="headerlink" title="3.1.7基本地址变换机构"></a>3.1.7基本地址变换机构</h3><h4 id="页表寄存器的作用"><a href="#页表寄存器的作用" class="headerlink" title="页表寄存器的作用"></a>页表寄存器的作用</h4><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</p><p>通常会在系统中设置一个<strong>页表寄存器</strong>（PTR），存放<strong>页表在内存中的起始地址F</strong>和<strong>页表长度M</strong>。进程未执行时，页表的始值和页表长度<strong>放在进程控制块（PCB）</strong>中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><p>ps：页面大小事2的整数幂。</p><h4 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h4><p><img src="http://1.117.162.142:9000/blog/%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B.png" alt="基本地址变换过程"></p><p>设页面大小为L，逻辑地址A到物理地址E的变换过程如下：</p><ol><li>计算页号P和页内偏移量W（如果用十进制数手算，则P&#x3D;A&#x2F;L，W&#x3D;A%L；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）</li><li>比较页号P和页表长度M，若P≥M，则产生越界中断，否则继续执行。（注意：页号是从0开始的，而页表长度至少为1，因此P&#x3D;M时也会越界）</li><li>页表中页号P对应的页表项地址 &#x3D; 页表起始地址F + 页号P * 页表项长度，取出该页表项内容b，即为内存块号。（注意区分页表项长度、页表长度、页面大小的区别。页表长度是指这个页表中总共有几个页表项，即总共有几个页；页表项长度指的是每个页表项占多大的存储空间；页面大小指的是一个页面占多大的存储空间）</li><li>计算E &#x3D; b * L + W，用得到的物理地址E去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）</li></ol><p>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显示地告诉系统这个逻辑地址中，页内偏移量占多少位。</p><h3 id="3-1-8-具有快表的地址变换机构"><a href="#3-1-8-具有快表的地址变换机构" class="headerlink" title="3.1.8 具有快表的地址变换机构"></a>3.1.8 具有快表的地址变换机构</h3><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）</p><p><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）</p><p>在基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。可以利用这个特性减少访问页表的次数。</p><h4 id="什么是快表（TLB）"><a href="#什么是快表（TLB）" class="headerlink" title="什么是快表（TLB）"></a>什么是快表（TLB）</h4><p>快表，又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p><p><img src="http://1.117.162.142:9000/blog/%E5%BF%AB%E8%A1%A8.png" alt="快表"></p><h4 id="引入快表后，地址的变换过程"><a href="#引入快表后，地址的变换过程" class="headerlink" title="引入快表后，地址的变换过程"></a>引入快表后，地址的变换过程</h4><ol><li>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</li><li>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存。（注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</li></ol><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。由于局部性原理，一般来说快表的命中率可以达到90%以上。</p><h3 id="3-1-9-两级页表"><a href="#3-1-9-两级页表" class="headerlink" title="3.1.9 两级页表"></a>3.1.9 两级页表</h3><h4 id="单级页表存在什么问题？"><a href="#单级页表存在什么问题？" class="headerlink" title="单级页表存在什么问题？"></a>单级页表存在什么问题？</h4><ul><li><p>页表必须连续存放，因此当页表很大时，需要占用多个连续的页框</p><p>  可将长长的页表进行分组，使某个内存块刚好可以放入一个分组（比如：页面大小4KB，每个页表项4B，每个页面可存放1K个页表项，因此每1K个连续的页表项为一组，每组刚好占一个内存块，再将各族离散地放到各个内存块中）</p><p>  另外，要为离散分配的页表再建立一张页表，成为页目录表，或称外层页表，或称顶层页表</p></li><li><p>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面</p></li></ul><h4 id="两级页表的原理、逻辑地址结构"><a href="#两级页表的原理、逻辑地址结构" class="headerlink" title="两级页表的原理、逻辑地址结构"></a>两级页表的原理、逻辑地址结构</h4><table><thead><tr><th align="center">31             ……            22</th><th align="center">21         ……       12</th><th align="center">11       ……       0</th></tr></thead><tbody><tr><td align="center">一级页号</td><td align="center">二级页号</td><td align="center">页内偏移量</td></tr></tbody></table><p>10位一级页号刚好可表示0～1023</p><h4 id="如何实现地址变换？"><a href="#如何实现地址变换？" class="headerlink" title="如何实现地址变换？"></a>如何实现地址变换？</h4><p>例：将逻辑地址（0000000000, 0000000001, 111111111111）转换为物理地址（用十进制表示）。</p><ol><li>按照地址结构将逻辑地址拆分成三部分</li><li>从PCB中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置</li><li>根据二级页号查表，找到最终想访问的内存块号</li><li>结合页内偏移量得到物理地址</li></ol><h4 id="两级页表问题需要注意的几个细节"><a href="#两级页表问题需要注意的几个细节" class="headerlink" title="两级页表问题需要注意的几个细节"></a>两级页表问题需要注意的几个细节</h4><ol><li><p>若采用多级页表机制，则各级页表的大小不能超过一个页面</p></li><li><p>两级页表的访存次数分析（假设没有快表机构）</p><p> 第一次访存：访问内存中的页目录表</p><p> 第二次访存：访问内存中的二级页表</p><p> 第三次访存：访问目标内存单元</p></li></ol><h3 id="3-1-10-基本分段式存储管理方式"><a href="#3-1-10-基本分段式存储管理方式" class="headerlink" title="3.1.10 基本分段式存储管理方式"></a>3.1.10 基本分段式存储管理方式</h3><h4 id="什么是分段"><a href="#什么是分段" class="headerlink" title="什么是分段"></a>什么是分段</h4><p>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址</p><p>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。</p><p><img src="http://1.117.162.142:9000/blog/%E5%88%86%E6%AE%B5.png" alt="分段"></p><p>分段系统的逻辑地址就够由段号（段名）和段内地址（段内偏移量）所组成。如：</p><p><img src="http://1.117.162.142:9000/blog/%E5%88%86%E6%AE%B5%E7%B3%BB%E7%BB%9F%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%84%E6%88%90.png" alt="分段系统逻辑地址组成"></p><p>段号的位数决定了每个进程最多可以分几个段</p><p>段内地址位数决定了每个段的最大长度是多少</p><p>在上述例子中，若系统是按字节寻址的，则</p><p>段号占16位，因此在该系统中，每个进程最多有2<sup>16</sup> &#x3D; 64K个段</p><p>段内地址占16位，因此每个段的最大长度是2<sup>16</sup> &#x3D; 64KB。</p><h4 id="什么是段表"><a href="#什么是段表" class="headerlink" title="什么是段表"></a>什么是段表</h4><p>程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”。</p><p><img src="http://1.117.162.142:9000/blog/%E6%AE%B5%E8%A1%A8.png" alt="段表"></p><ol><li>每个段对应一个段表项，其中记录了该段在内存中的起始位置（又称“基址”）和段的长度。</li><li>各个段表项的长度是相同的。例如：某系统按字节寻址，采用分段存储管理，逻辑地址结构为（段号16位，段内地址16位），因此用16位即可表示最大段长。物理内存大小为4GB（可用32位表示整个物理内存地址空间）。因此，可以让每个段表项占16+32&#x3D;48位，即6B。由于段表项长度相同，因此段号可以是隐含的，不占存储空间。若段表存放的起始地址位M，则K号段对应的段表项存放的地址为M+K*6</li></ol><h4 id="如何实现地址变换"><a href="#如何实现地址变换" class="headerlink" title="如何实现地址变换"></a>如何实现地址变换</h4><p><img src="http://1.117.162.142:9000/blog/%E6%AE%B5%E8%A1%A8%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="段表存储管理方式地址变换">变换” style&#x3D;”zoom:30%;”&gt;</p><h4 id="分段、分页管理的对比"><a href="#分段、分页管理的对比" class="headerlink" title="分段、分页管理的对比"></a>分段、分页管理的对比</h4><p>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</p><p>段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显示地给出段名。</p><p>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</p><p>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。</p><p>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</p><p>分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）</p><p>访问一个逻辑地址需要几次访存？</p><p>分页（单级页表）：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共两次访存</p><p>分段：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共两次访存于分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表放到快表中，这样可以少访问，加快地址变化速度。</p><h3 id="3-1-11-段页式管理方式"><a href="#3-1-11-段页式管理方式" class="headerlink" title="3.1.11 段页式管理方式"></a>3.1.11 段页式管理方式</h3><h4 id="分页、分段管理方式中最大的优缺点"><a href="#分页、分段管理方式中最大的优缺点" class="headerlink" title="分页、分段管理方式中最大的优缺点"></a>分页、分段管理方式中最大的优缺点</h4><table><thead><tr><th align="center"></th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">分页管理</td><td align="center">内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</td><td align="center">不方便按照逻辑模块实现信息的共享和保护</td></tr><tr><td align="center">分段管理</td><td align="center">很方便按照逻辑模块实现信息的共享和保护</td><td align="center">如果段长过大，为其分配很大的连续空间会很不方便，另外段式管理会产生外部碎片</td></tr></tbody></table><h4 id="分段-分页的结合——段页式管理方式"><a href="#分段-分页的结合——段页式管理方式" class="headerlink" title="分段+分页的结合——段页式管理方式"></a>分段+分页的结合——段页式管理方式</h4><p><img src="http://1.117.162.142:9000/blog/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86.png" alt="段页式管理"></p><p>将进程按逻辑模块分段，再将各段分页（如每个页面4KB）再将内存空间分为大小相同的内存块&#x2F;页框&#x2F;页帧&#x2F;物理块进程前将各页面分别装入内存块中。</p><p>分段系统的逻辑地址结构由段号和段内地址（段内偏移量）组成，如：</p><p><img src="http://1.117.162.142:9000/blog/%E5%88%86%E5%BA%A6%E7%B3%BB%E7%BB%9F%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png" alt="分度系统逻辑地址结构"></p><p>段页式系统的逻辑地址结构由段号、页号、页内地址（页内偏移量）组成，如：</p><p><img src="http://1.117.162.142:9000/blog/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png" alt="段页式系统地址结构"></p><blockquote><p>“分段”是对用户可见的，程序员编程时需要显示地给出段号、段内地址。而将各段“分页”对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此<strong>段页式管理地址结构是二维的</strong>。</p></blockquote><p>段号的位数决定了每个进程最多可以分为几个段</p><p>页号位数决定了每个段最大有多少页</p><p>页内偏移量决定了页面大小、内存块大小是多少</p><p>在上述例子中，若系统是按字节寻址的，则</p><p>段号占16位，因此在该系统中，每个进程最多有2<sup>16</sup> &#x3D; 64K个段</p><p>页号占4位，因此每个段最多有2<sup>4</sup> &#x3D; 16页</p><p>页内偏移量占12位，因此每个页面\每个内存块大小为2<sup>12</sup> &#x3D; 4096 &#x3D;4KB</p><h4 id="段表、页表"><a href="#段表、页表" class="headerlink" title="段表、页表"></a>段表、页表</h4><p><img src="http://1.117.162.142:9000/blog/%E6%AE%B5%E8%A1%A8%E6%AE%B5%E9%A1%B5.png" alt="段表段页"></p><p>每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成。每个段表项长度相等，段号是隐含的。</p><p>每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。</p><h4 id="如何实现地址变换-1"><a href="#如何实现地址变换-1" class="headerlink" title="如何实现地址变换"></a>如何实现地址变换</h4><p><img src="http://1.117.162.142:9000/blog/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="段页式管理地址变换"></p><h3 id="3-2-1-虚拟内存的基本概念"><a href="#3-2-1-虚拟内存的基本概念" class="headerlink" title="3.2.1 虚拟内存的基本概念"></a>3.2.1 虚拟内存的基本概念</h3><h4 id="传统存储管理方式的特征、缺点"><a href="#传统存储管理方式的特征、缺点" class="headerlink" title="传统存储管理方式的特征、缺点"></a>传统存储管理方式的特征、缺点</h4><p>传统存储管理（很多暂时用不到的数据也会长期占用内存，导致内存利用率不高）</p><ul><li>连续分配<ul><li>单一连续分配</li><li>固定分区分配</li><li>动态分区分配</li></ul></li><li>非连续分配<ul><li>基本分页存储管理</li><li>基本分段存储管理</li><li>基本段页式存储管理</li></ul></li></ul><p>一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：1. 作业很大时，不能全部装入内存，导致大作业无法运行；2. 当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。</p><p>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</p><h4 id="局部性原理-1"><a href="#局部性原理-1" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）</p><p>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</p><p><img src="http://1.117.162.142:9000/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="计算机中存储器的层次结构"></p><p>快表机构就是将近期常访问的页表项副本放到更高速的联想寄存器中</p><p>高速缓冲技术的思想：将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中。</p><h4 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h4><p><img src="http://1.117.162.142:9000/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="计算机中存储器的层次结构"></p><p>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。</p><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。</p><p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p><p>在操作系统的管理下，在用户看来似乎有一个比实际内存大的多的内存，这就是虚拟内存。</p><blockquote><p>操作系统虚拟性的一个体现，实际的物理内存大小没有变，知识在逻辑上进行了扩充。</p></blockquote><p>虚拟内存有以下三个主要特征：</p><p>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</p><p>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入换出。</p><p>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</p><h4 id="如何实现虚拟内存技术"><a href="#如何实现虚拟内存技术" class="headerlink" title="如何实现虚拟内存技术"></a>如何实现虚拟内存技术</h4><p>虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在离散分配的内存管理方式基础上。</p><p>虚拟内存的实现：</p><ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ul><p>传统的非连续分配存储管理和虚拟内存技术的主要区别：</p><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。（操作系统要提供请求调页或请求调段功能）</p><p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。（操作系统要提供页面置换或段置换的功能）</p><h3 id="3-2-2-请求分页管理方式"><a href="#3-2-2-请求分页管理方式" class="headerlink" title="3.2.2 请求分页管理方式"></a>3.2.2 请求分页管理方式</h3><h4 id="请求分页存储管理与基本分页存储管理的主要区别："><a href="#请求分页存储管理与基本分页存储管理的主要区别：" class="headerlink" title="请求分页存储管理与基本分页存储管理的主要区别："></a>请求分页存储管理与基本分页存储管理的主要区别：</h4><h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h4><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需要知道该页面在外存中存放的位置。</p><p>当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面：有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。</p><p><img src="http://1.117.162.142:9000/blog/%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6.png" alt="页表机制"></p><h4 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h4><p>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。</p><p>此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。</p><p>如何内存有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。</p><p>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</p><p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。</p><p>一条指令在执行期间，可能产生多次缺页中断。</p><h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p>请求分页存储管理与基本分页存储管理的主要区别：</p><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。</p><p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p><p><img src="http://1.117.162.142:9000/blog/%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png" alt="地址变换机构"></p><h3 id="3-2-3-页面置换算法"><a href="#3-2-3-页面置换算法" class="headerlink" title="3.2.3 页面置换算法"></a>3.2.3 页面置换算法</h3><h4 id="最佳置换算法OPT"><a href="#最佳置换算法OPT" class="headerlink" title="最佳置换算法OPT"></a>最佳置换算法OPT</h4><p>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。</p><p>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。</p><h4 id="先进先出置换算法FIFO"><a href="#先进先出置换算法FIFO" class="headerlink" title="先进先出置换算法FIFO"></a>先进先出置换算法FIFO</h4><p>每次选择淘汰的页面是最早进入内存的页面</p><p>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择对头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。</p><p>Belady异常——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p><p>只有IFO算法会产生Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差</p><h4 id="最近最久未使用置换算法LRU"><a href="#最近最久未使用置换算法LRU" class="headerlink" title="最近最久未使用置换算法LRU"></a>最近最久未使用置换算法LRU</h4><p>每次淘汰的页面是最近最久未使用的页面</p><p>实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p><p><img src="http://1.117.162.142:9000/blog/LRU.png" alt="LRU"></p><h4 id="时钟置换算法CLOCK"><a href="#时钟置换算法CLOCK" class="headerlink" title="时钟置换算法CLOCK"></a>时钟置换算法CLOCK</h4><p>最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法。</p><p>简单的CLOCK算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过连接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位置依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）</p><p><img src="http://1.117.162.142:9000/blog/CLOCK.png" alt="CLOCK"></p><h4 id="改进型的时钟置换算法"><a href="#改进型的时钟置换算法" class="headerlink" title="改进型的时钟置换算法"></a>改进型的时钟置换算法</h4><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I&#x2F;O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</p><p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I&#x2F;O操作。这就是改进型的时钟置换算法的思想。</p><p>修改位&#x3D;0，表示页面没有被修改过；修改位&#x3D;1，表示页面被修改过。</p><p>为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1，1）表示一个页面近期被访问过，且被修改过。</p><p>算法规则：将所有可能被置换的页面排成一个循环队列</p><p>第一轮：从当前位置开始扫描到第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位。</p><p>第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的帧访问位设为0.</p><p>第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位。</p><p>第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。</p><p>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描。</p><p><strong>四种页面置换算法比较</strong></p><p><img src="http://1.117.162.142:9000/blog/%E5%9B%9B%E7%A7%8D%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.png" alt="四种页面置换算法比较"></p><h3 id="3-2-4-页面分配策略"><a href="#3-2-4-页面分配策略" class="headerlink" title="3.2.4 页面分配策略"></a>3.2.4 页面分配策略</h3><h4 id="页面分配、置换策略"><a href="#页面分配、置换策略" class="headerlink" title="页面分配、置换策略"></a>页面分配、置换策略</h4><p><strong>驻留集：</strong>指请求分页存储管理中给进程分配的物理块的集合。</p><p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。</p><p>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于即成推进的时间很少；驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。</p><p><strong>固定分配：</strong>操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变。</p><p><strong>可变分配：</strong>先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变。</p><p><strong>局部置换：</strong>发生缺页时只能选进程自己的物理块进行置换。</p><p><strong>全局置换：</strong>可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</p><p><strong>固定分配局部置换：</strong>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。（采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）</p><p><strong>可变分配全剧置换：</strong>刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。</p><p><strong>可变分配局部置换：</strong>刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</p><p>可变分配全剧置换：只要缺页就给分配新物理块</p><p>可变分配局部置换：要根据发生缺页的频率来动态地增加或减少进程的物理块</p><h4 id="调入页面的时机"><a href="#调入页面的时机" class="headerlink" title="调入页面的时机"></a>调入页面的时机</h4><ol><li>预调页策略：根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略主要用于进程的首次调入，由程序员指出应该先调入哪些部分。</li><li>请求调页策略：进程在运行期间发现缺页时才将所缺页调入内存。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I&#x2F;O操作，因此I&#x2F;O开销比较大。</li></ol><h4 id="从何处调页"><a href="#从何处调页" class="headerlink" title="从何处调页"></a>从何处调页</h4><ol><li>系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。</li><li>系统缺少足够的对换区空间：凡事不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需要写回磁盘对换区，下次需要时再从对换区调入。</li><li>UNIX方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</li></ol><h4 id="抖动（颠簸）现象"><a href="#抖动（颠簸）现象" class="headerlink" title="抖动（颠簸）现象"></a>抖动（颠簸）现象</h4><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）。</p><blockquote><p>为进程分配的物理块太少，会使即成发生动都现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率</p></blockquote><h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><p>驻留集：指请求分页存储管理中给进程分配的内存块的集合</p><p>工作集：指在某段时间间隔里，进程实际访问页面的集合</p><p>操作系统会根据“窗口尺寸”来算出工作集。</p><p>工作集太小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若个内存块。如：窗口尺寸为5，经过一段时间的检测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。一般来说，<strong>驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页。</strong></p><blockquote><p>基于局部性原理克制，进程在一段时间内访问的页面与不久之后会访问的页面是有相关性的。因此，可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法——选择一个不在工作集中的页面进行淘汰。</p></blockquote><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="4-1-1-初识文件管理"><a href="#4-1-1-初识文件管理" class="headerlink" title="4.1.1 初识文件管理"></a>4.1.1 初识文件管理</h3><p><strong>文件的定义</strong>：一组有意义的信息的集合</p><h4 id="文件的属性"><a href="#文件的属性" class="headerlink" title="文件的属性"></a>文件的属性</h4><ul><li><p>文件名</p><p>  由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件。</p></li><li><p>标识符</p><p>  一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</p></li><li><p>类型</p><p>  指明文件的类型</p></li><li><p>位置</p><p>  文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</p></li><li><p>大小</p><p>  指明文件大小</p></li><li><p>创建时间、上次修改时间</p></li><li><p>文件所有者信息</p></li><li><p>保护信息</p><p>  对文件进行保护的访问控制信息</p></li></ul><h4 id="文件内部的数据应该怎样组织起来？"><a href="#文件内部的数据应该怎样组织起来？" class="headerlink" title="文件内部的数据应该怎样组织起来？"></a>文件内部的数据应该怎样组织起来？</h4><p>无结构文件：如文本文件。由一些二进制或字符流组成，又称“流式文件”</p><p>有结构文件：如数据库表。由一组相似的记录组成，又称“记录式文件”。记录是一组相关数据项的集合。</p><blockquote><p>数据项式文件系统中最基本的数据单位</p></blockquote><h4 id="文件内部的数据应该怎样组织起来？-1"><a href="#文件内部的数据应该怎样组织起来？-1" class="headerlink" title="文件内部的数据应该怎样组织起来？"></a>文件内部的数据应该怎样组织起来？</h4><p>文件的逻辑结构</p><p><img src="http://1.117.162.142:9000/blog/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="文件结构"></p><h4 id="文件之间应该怎样组织起来？"><a href="#文件之间应该怎样组织起来？" class="headerlink" title="文件之间应该怎样组织起来？"></a>文件之间应该怎样组织起来？</h4><p>目录结构</p><p><img src="http://1.117.162.142:9000/blog/%E6%96%87%E4%BB%B6%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.png" alt="文件逻辑结构"></p><p>用户可以自己创建一层一层的目录，各层目录中存放相应的文件。系统中的各个文件就通过一层一层的目录合理有序的组织起来。</p><p>目录其实也是一种特殊的有结构文件（由记录组成）。所谓的“目录”其实就是我们熟悉的“文件夹”。</p><h4 id="操作系统应该向上提供哪些功能？"><a href="#操作系统应该向上提供哪些功能？" class="headerlink" title="操作系统应该向上提供哪些功能？"></a>操作系统应该向上提供哪些功能？</h4><p>可以“<strong>创建文件</strong>”，新建后，图形化交互进程在背后调用了“<strong>create系统调用”</strong>。</p><p>可以“<strong>读文件</strong>”，将文件数据读入内存，才能让CPU处理（“记事本”应用程序通过操作系统提供的“读文件”功能，即<strong>read系统调用</strong>，将文件数据从外存读入内存，并显示在屏幕上）</p><p>可以“写文件”，将更改过的文件数据写回外存（“记事本”应用程序中编辑文件内容，点击“保存”后，“记事本”应用程序通过操作系统提供的“<strong>写文件</strong>”功能，即<strong>write系统调用</strong>，将文件数据从内存写回外存）</p><p>可以“<strong>删除文件</strong>”（点了“删除”之后，图形化交互进程通过操作系统提供的“<strong>删除文件</strong>”功能，即<strong>delete系统调用</strong>，将文件数据从外存中删除）</p><p>向上提供的几个最基本的功能：</p><ul><li>创建文件，create系统调用</li><li>删除文件，delete系统调用</li><li>读文件，read系统调用</li><li>写文件，write系统调用</li><li>打开文件，open系统调用。读&#x2F;写文件之前，需要“打开文件”。</li><li>关闭文件，close系统调用。读&#x2F;写文件结束之后，需要“关闭文件”。</li></ul><blockquote><p>可用几个基本操作完成更复杂的操作，比如：“文件复制”：先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中。</p></blockquote><h4 id="文件应该如何存放在外存？"><a href="#文件应该如何存放在外存？" class="headerlink" title="文件应该如何存放在外存？"></a>文件应该如何存放在外存？</h4><p>与内存一样，外存也是由一个个存储单元组成的，每个存储单元可以存储一定量的数据。每个存储单元对应一个物理地址。</p><p>类似于内存分为一个个“内存块”，外存会分为一个个“块&#x2F;磁盘块&#x2F;物理块”。每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址。同样类似的事，文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转换为外存的物理地址（物理块号，块内地址）的形式。块内地址的位数取决于磁盘块的大小。</p><p>操作系统以“块”为单位为文件分配存储空间，因此即使一个文件大小只有10B，但它依然需要占用1KB的磁盘块。外存中的数据读入内存时同样以块为单位。</p><h3 id="4-1-2-文件的逻辑结构"><a href="#4-1-2-文件的逻辑结构" class="headerlink" title="4.1.2 文件的逻辑结构"></a>4.1.2 文件的逻辑结构</h3><blockquote><p>所谓的“逻辑结构”，就是指在用户看来，文件内部的数据应该是如何组织起来的。而“物理结构”指的是在操作系统看来，文件的数据是如何放在外存中的。</p></blockquote><p>按文件是否有结构分类，可以分为无结构文件、有结构文件两种。</p><h4 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h4><p><strong>无结构文件</strong>：文件内部的数据就是一系列二进制流或字符流组成。又称“<strong>流式文件</strong>”。</p><p>如windows操作系统中的.txt文件。文件内部的数据其实就是一系列字符流，没有明显的结构特性。因此也不用探讨无结构文件的“逻辑结构”问题。</p><h4 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h4><p><strong>有结构文件</strong>：由一组相似的记录组成，又称“<strong>记录式文件</strong>”。每条记录由若干个数据项组成。如：数据库表文件。一般来说，每条记录有一个数据项可作为<strong>关键字</strong>。根据各条记录的长度（占用的存储空间）是否相等，又可分为<strong>定长记录</strong>和<strong>可变长记录</strong>两种。</p><p>根据有结构文件中的各条记录在逻辑上如何组织，可以分为三类：</p><ul><li><p>顺序文件</p><p>  文件中的记录一个接一个顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。</p><p>  顺序存储：逻辑上相邻的记录物理上也相邻（类似于顺序表）。可变长记录无法实现随机存取。每次只能从第一个记录开始依次往后查找。定长记录可实现随机存取。记录长度为L，则第i个记录存放的相对位置是i*L；若采用串结构，无法快速找到某关键字对应的记录；若采用顺序结构，可以快速找到关键字对应的记录（如折半查找）</p><p>  链式存储：逻辑上相邻的记录物理上不一定相邻（类似于链表）。无论是定长&#x2F;可变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找</p></li><li><p>索引文件</p><p>  缺点：每个记录对应一个索引表项，因此索引表可能会很大。比如：文件的每个记录平均只占8B，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了。</p></li><li><p>索引顺序文件</p><p>  索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是<strong>一组记录对应一个索引表项</strong>。</p><p>  索引顺序文件的索引项也不需要按关键字顺序排列，这样可以极大地方便新表项的插入。</p><p>  为了进一步提高检索效率，可以为顺序文件建立多极索引表。</p></li></ul><h3 id="4-1-3-文件目录"><a href="#4-1-3-文件目录" class="headerlink" title="4.1.3 文件目录"></a>4.1.3 文件目录</h3><h4 id="文件目录的实现"><a href="#文件目录的实现" class="headerlink" title="文件目录的实现"></a>文件目录的实现</h4><p><strong>文件控制块</strong></p><p>目录文件中的一条记录就是一个“文件控制块（FCB）“</p><p>FCB的有序集合称为”文件目录“，一个FC B就是一个文件目录项。</p><p>FCB中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读&#x2F;可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）</p><p>最重要，最基本还是文件名、文件存放的物理地址。（FCB实现了文件名和文件之间的映射。使用户（用户程序）可以实现“按名存取”）</p><p>需要对目录进行哪些操作？</p><p>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</p><p>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项</p><p>删除文件：当删除一个文件时，需要在目录中删除相应的目录项</p><p>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</p><p>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文件重命名）</p><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p><strong>单级目录结构</strong></p><p>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项。</p><p>单级目录实现了“按名存取“，但是不允许文件重名。在创建文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中。</p><p>显然，单级目录结构不适用于多用户操作系统</p><p><strong>两级目录结构</strong></p><p>早起的多用户操作系统，采用两级目录结构。分为主文件目录（MFD，Master File Directory）和用户文件目录（UFD，User File Directory）。</p><p>主文件目录记录用户名及相应用户文件目录的存放位置。</p><p>用户文件目录由该用户的文件FCB组成。</p><p>两级目录结构允许不同用户的文件重名，也可以在目录上实现访问限制（检查此时登录的用户名是否匹配）。但是两级目录结构依然缺乏灵活性，用户不能对自己的文件进行分类。</p><p><strong>多级目录结构</strong></p><p>又称树形目录结构。</p><p>用户或用户进程要访问某个文件时，要用文件路径名标识文件，文件路径名是个字符串。各级目录之间用“&#x2F;”隔开。从根目录出发的路径称为绝对路径。</p><p>例如：自拍.png的绝对路径是“&#x2F;照片&#x2F;2022-07&#x2F;自拍.png“</p><p>系统根据绝对路径一层一层地找到下一级目录。刚开始从外存读入根目录的目录表；找到”照片”目录的存放位置后，从外存读入对应的目录表；再找到“2022-07”目录的存放位置，再从外存读入对应目录表；最后才找到文件“自拍.png“的存放位置。整个过程需要3次读磁盘I&#x2F;O操作。</p><p>很多时候，用户会连续访问同一目录内的多个问津啊（比如：接连查看”2022-07“目录内的多个照片文件），显然，每次都从根目录开始查找，是很低效的。因此可以设置一个”当前目录“。例如，此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为“当前目录”。当用户想要访问某个文件时，可以使用从当前目录出发的“相对路径”。</p><p>在linux中，“**.**”表示当前目录，因此如果“照片”是当前目录，则“自拍.png”的相对路径为：“.&#x2F;2022-07&#x2F;自拍.png“。从当前路径出发，只需要查询内存中的”照片“目录表，即可知道”2022-07“目录表的存放位置，从外存调入该目录，即可知道”自拍.png“存放的位置了。</p><p>可见，引入”当前目录“和”相对路径“后，磁盘I&#x2F;O的次数减少了。这就提升了访问文件的效率。</p><p>树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构”。</p><p><strong>无环图目录结构</strong></p><p>在树形目录结构的基础上，增加一些指向同一节点的有向边，使整个目录称为一个有向无环图。可以更方便地实现多个用户间的文件共享。</p><p><strong>可以用不同的文件名只想同一个文件</strong>，甚至可以指向同一个目录（共享同一目录下的所有内容）。</p><p>需要为<strong>每个共享结点设置一个共享计数器</strong>，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的PCB、并使<strong>共享计数器减1</strong>，并不会直接删除共享结点。<strong>只有共享计数器减为0时，才删除结点。</strong></p><p>注意：共享文件不同于复制文件。在<strong>共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。</strong></p><h4 id="索引结点"><a href="#索引结点" class="headerlink" title="索引结点"></a>索引结点</h4><p>其实在查找各级目录的过程中，只需要用到“文件名”这个信息，只有文件名匹配时，才需要读出文件的其他信息。因此可以考虑让目录表“瘦身”来提升效率。</p><p>这样做有什么好处？</p><p>假设一个FCB是64B，磁盘块的大小为1KB，则每个磁盘块中只能存放16个FCB。若一个文件目录中共有640个目录项，则共需要占用640&#x2F;16&#x3D;40个盘块。因此按照某文件名检索该目录，平均需要查询320个目录项，平均需要启动磁盘（每次磁盘I&#x2F;O读入一块）。</p><p>若使用索引结点机制，文件名占14B，索引结点指针占2B，则每个盘块可存放64个目录项，那么按文件名检索目录平均只需要读入320&#x2F;64&#x3D;5个磁盘块。显然，这将大大提升文件检索速度。</p><p>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。</p><p>存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”。</p><p>相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件等。</p><h3 id="4-1-4-文件的物理结构"><a href="#4-1-4-文件的物理结构" class="headerlink" title="4.1.4 文件的物理结构"></a>4.1.4 文件的物理结构</h3><h4 id="文件块、磁盘块"><a href="#文件块、磁盘块" class="headerlink" title="文件块、磁盘块"></a>文件块、磁盘块</h4><p>类似于内存分页，磁盘中的存储单元也会被分为一个个“块&#x2F;磁盘块&#x2F;物理块”。很多操作系统中，<strong>磁盘块的大小与内存块、页面的大小相同。</strong></p><p>内存与磁盘之间的数据交换（即读&#x2F;写操作、磁盘I&#x2F;O）都是以“块”为单位进行的。即每次读入一块，或每次写出一块。</p><p>在内存管理中，进程的逻辑地址空间被分为一个一个页面</p><p>同样的，在外存管理中，为了方便对文件数据的姑那里，文件的逻辑地址空间也被分为了一个一个的文件“块”。</p><p>于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式。</p><p>操作系统为文件分配存储空间都是以块为单位的。</p><p>用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射。</p><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>连续分配方式要求每个文件在磁盘上占有一组连续的块。</p><blockquote><p>用户通过逻辑地址来操作自己的文件，操作系统如何实现从逻辑地址到物理地址的映射？</p></blockquote><p>（逻辑块号，块内地址）-&gt;（物理块号，块内地址）。只需转换块号就行，块内地址保持不变</p><p>用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项FCB……</p><p>物理块号 &#x3D; 起始块号 + 逻辑块号</p><p>当然，还需要检查用户提供的逻辑块号是否合法（逻辑块号 ≥ 长度 就不合法）。可以直接算出逻辑块号对应的物理块号，因此连续分配支持顺序访问和直接访问（即随机访问）。</p><p>读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。</p><p>结论：</p><p><strong>连续分配的文件在顺序读&#x2F;写时速度最快</strong></p><p>物理上采用<strong>连续分配的文件不方便拓展</strong></p><p>物理上采用<strong>连续分配，存储空间利用率低，会产生难以利用的磁盘碎片</strong>，可以用紧凑来处理碎片，但是需要耗费很大的时间代价。</p><p>优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快</p><p>缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片</p><h4 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h4><p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显示链接两种。</p><p><strong>隐式链接</strong></p><blockquote><p>如何实现文件的逻辑块号到物理块号的转变？</p></blockquote><p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项FCB……</p><p>从目录项中找到起始块号（即0号块），将0号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，再找到2号逻辑块的存放位置……以此类推。</p><p>因此，读入i号逻辑块，总共需要i+1次磁盘I&#x2F;O。</p><p>结论：采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查找效率低。另外，指向下一个盘块的指针页需要耗费少量的存储空间。采用隐式链接的链接分配方式，很方便文件拓展。另外，所有的的空闲磁盘块都可以被利用，不会有碎片问题，外存利用率高。</p><p>隐式链接——除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。</p><p>优点：很方便文件拓展，不会有碎片问题，外存利用率高。</p><p>缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</p><p><strong>显式链接</strong></p><p>把用于链接文件各物理块的指针显示地存放在一张表中。即文件分配表（FAT，File Allocation Table）。</p><p>假设某个新创建的文件“aaa“一次存放在磁盘块2 -&gt; 5 -&gt; 0 -&gt; 1，在目录中只需记录文件的起始块号。</p><p>注意：一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存。FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以时隐含的。</p><blockquote><p>如何实现文件的逻辑块号到物理块号的转变？</p></blockquote><p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项FCB……</p><p>从目录项中国呢找到起始块号，若i&gt;0，则查询内存中的文件分配表FAT，往后找到i号逻辑块对应的物理块号。<strong>逻辑块号转换成物理块号的过程不需要读磁盘操作。</strong></p><p>结论：采用<strong>链式分配（显式链接）</strong>方式的文件，支持顺序访问，也<strong>支持随机访问（想访问i号逻辑块时，并不需要依次访问之前的0～i-1号逻辑块）</strong>，由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。</p><p>显然，显式链接也<strong>不会产生外部碎片，也可以很方便地对文件进行拓展。</strong></p><p>显示链接——把用于链接文件各物理块的指针显示地存放在一张表中，即<strong>文件分配表</strong>（FAT，File Allocation Table）。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。</p><p>优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</p><p>缺点：文件分配表的需要占用一定的存储空间。</p><h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><p>索引分配允许文件离散地分配在各个磁盘块中，系统会<strong>为每个文件建立一张索引表</strong>，索引表中记录了文件的各个逻辑块对应的物理块（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系）。索引表存放的磁盘块称为<strong>索引块</strong>。文件数据存放的磁盘块称为<strong>数据块</strong>。</p><p>假设某个新创建的文件“aaa”的数据一次存放在磁盘块2 -&gt; 5 -&gt; 13 -&gt; 9。7号磁盘块作为“aaa”的索引块，索引块中保存了索引表的内容。</p><p>注：在显式链接的链式分配方式中，文件分配表FAT是一个磁盘对应一张。而索引分配方式中，索引表是一个文件对应一张。</p><p>可以用固定的长度表示物理块号（如：假设磁盘总容量为1TB&#x3D;2<sup>40</sup>B，磁盘块大小为1KB，则共有2<sup>30</sup>个磁盘块，则可用4B表示磁盘块号），因此，索引表中的“逻辑块号”可以是隐含的。</p><p>目录中需要记录文件的索引块是极好磁盘块。</p><blockquote><p>如何实现文件的逻辑块号到物理块号的转换？</p></blockquote><p>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项FCB……</p><p>从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可指i号逻辑块在外存中的存放位置。</p><p>可见，索引分配方式可以支持随机访问。文件拓展也很容易实现（只需要给文件分配一个空闲块，并增加了一个索引表项即可）但是索引表需要占用一定的存储空间</p><blockquote><p>如果一个文件的大小超过了256块，那么一个磁盘块是装不下文件的整张索引表的，如何解决这个问题？</p></blockquote><ol><li><p>链接方案</p><p> 如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</p></li><li><p>多层索引</p><p> 建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。</p></li><li><p>混合索引</p><p> 多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表）。</p><p> 优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少。</p></li></ol><h3 id="4-1-5-文件存储空间管理"><a href="#4-1-5-文件存储空间管理" class="headerlink" title="4.1.5 文件存储空间管理"></a>4.1.5 文件存储空间管理</h3><h4 id="存储空间的划分与初始化"><a href="#存储空间的划分与初始化" class="headerlink" title="存储空间的划分与初始化"></a>存储空间的划分与初始化</h4><p>存储空间的划分：将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘）。如：安装Windows操作系统的时候，一个必经步骤是——为磁盘分区（C:盘、D:盘、E:盘等）。有的系统支持超大型文件，可支持由多个物理磁盘组成一个文件卷。</p><p>存储空间的初始化：将各个文件卷划分为目录区、文件区。目录区主要存放文件目录信息FCB、用于磁盘存储空间管理的信息。文件区用于存放文件数据。</p><h4 id="几种管理方法"><a href="#几种管理方法" class="headerlink" title="几种管理方法"></a>几种管理方法</h4><p><strong>空闲表法</strong></p><p>如何分配磁盘块：与内存管理中的动态分区分配很类似，为一个文件<strong>分配连续的存储空间</strong>。同样<strong>可采用首次适应、最佳适应、最坏适应等算法</strong>来决定要为文件分配哪个区间。</p><p>如何回收磁盘块：与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况——1.回收区的前后都没有相邻空闲区；2.回收区的前后都是空闲区；3.回收区前面是空闲区；4.回收区后面是空闲区。<strong>总之，回收时需要注意表项的合并问题。</strong></p><p><strong>空闲链表法</strong></p><ul><li><p>空闲盘块链</p><p>  以盘块为单位组成一条空闲链。空闲盘块中存储这下一个空闲盘块的指针。操作系统中保存着链头、链尾指针。</p><p>  如何分配：若某文件申请K个盘块，则从链头开始一次摘下K个盘块分配，并修改空闲链的链头指针。</p><p>  如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</p></li><li><p>空闲盘区链</p><p>  以盘区为单位组成一条空闲链。空闲盘区中的第一个盘块内记录了盘区的长度、下一个盘区的指针。连续的空闲盘块组成一个空闲盘区。</p><p>  如何分配：若某文件申请k个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。</p><p>  如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有喝任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</p></li></ul><p><strong>位示图法</strong></p><p>位示图：每个二进制对应一个盘块。位示图一般用连续的“字”来表示，如一个字的字长是16位，字中的每一位对应一个盘块。因此可以用（字号，位号）对应一个盘块号。当然有的题目中也描述为（行号，列号）</p><p>（字号，位号）&#x3D;（i，j）的二进制位对应的盘块号b &#x3D; ni + j</p><p>b号盘块对应的字号i &#x3D; b &#x2F; n，位号j &#x3D; b % n</p><p>如何分配：若文件需要k个块，1.顺序扫描位示图，找到k个相邻或不相邻的“0”；2.根据字号、位号算出对应的盘块号，将相应盘块分配给文件；3.将相应位设置为“1”。</p><p>如何回收：1.根据回收的盘块号计算出对应的字号、位号；2.将相应二进制位设为“0”</p><p><strong>成组链接法</strong></p><p>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX系统中采用了成组链接法对磁盘空闲块进行管理。</p><p>文件卷的目录区中专门用一个磁盘块作为“超级块“，当系统启动时需要将超级块读入内存。并且要保证内存与外存中的”超级块“数据一致。</p><h3 id="4-1-6-文件的基本操作"><a href="#4-1-6-文件的基本操作" class="headerlink" title="4.1.6 文件的基本操作"></a>4.1.6 文件的基本操作</h3><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><p>进行Create系统调用时，需要提供的几个主要参数：</p><ol><li>所需的外存空间大小</li><li>文件存放路径</li><li>文件名</li></ol><p>操作系统在处理create系统调用时，主要做了两件事：</p><ol><li>在外存中找到文件所需的空间</li><li>根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息。</li></ol><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>进行Delete系统调用时，需要提供的几个主要参数：</p><ol><li>文件存放路径</li><li>文件名</li></ol><p>操作系统在处理Delete系统调用时，主要做了几件事：</p><ol><li>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项。</li><li>根据该目录项纪录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块。</li><li>从目录表中删除文件对应的目录项。</li></ol><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>进程使用read系统调用完成操作。需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明读入多少数据、指明读入的数据要放在内存中的什么位置。</p><p>操作系统在处理read系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</p><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>进程使用write系统调用完成操作，需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要写出多少数据、写回外存的数据放在内存中的什么位置。</p><p>操作系统在处理write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。</p><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>在很多操作系统中，在对文件进行操作之前，要求用户先使用open系统调用“打开文件“，需要提供的几个主要参数：</p><ol><li>文件存放路径</li><li>文件名</li><li>要对文件操作的类型，如：r只读，rw读写等。</li></ol><p>操作系统在处理open系统调用时，主要做了几件事：</p><ol><li>根据文件存放路径找到文件名对应的目录项，并检查该用户是否有指定的操作权限。</li><li>将目录项复制到内存中的”打开文件表“中。并将对应表的编号返回给用户。之后用户使用打开文件表的标号来指明要操作的文件。</li></ol><h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p>进程使用完文件后，要“关闭文件”</p><p>操作系统在处理Close系统调用时，主要做了几件事：</p><ol><li>将进程的打开文件表相应表项删除</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器count减1，若count&#x3D;0，则删除对应表项。</li></ol><h3 id="4-1-7-文件共享"><a href="#4-1-7-文件共享" class="headerlink" title="4.1.7 文件共享"></a>4.1.7 文件共享</h3><blockquote><p>多个用户共享同一个文件，意味着系统中只有“一份“文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。如果是多个用户都“复制”了同一个文件，那么系统中会有”好几份“文件数据。其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响。</p></blockquote><h4 id="基于索引结点的共享方式（硬链接）"><a href="#基于索引结点的共享方式（硬链接）" class="headerlink" title="基于索引结点的共享方式（硬链接）"></a>基于索引结点的共享方式（硬链接）</h4><p>索引结点，是一种文件目录瘦身策略。由于检索文件时只需要用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。</p><p>索引结点中设置了一个链接技术变量count，用于表示链接到本索引结点上的用户目录项数。</p><p>若count&#x3D;2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。</p><p>若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减1.</p><p>若count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。</p><p>当count&#x3D;0时系统负责删除文件。</p><h4 id="基于符号链的共享方式（软链接）"><a href="#基于符号链的共享方式（软链接）" class="headerlink" title="基于符号链的共享方式（软链接）"></a>基于符号链的共享方式（软链接）</h4><p>在一个Link型的文件中记录共享文件的存放路径（windows快捷方式）</p><p>操作系统根据路径一层层查找目录，最终找到共享文件</p><p>即使软链接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查找共享文件会失败（找不到对应目录项）</p><p>由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I&#x2F;O，因此用软链接访问。</p><h3 id="4-1-8-文件保护"><a href="#4-1-8-文件保护" class="headerlink" title="4.1.8 文件保护"></a>4.1.8 文件保护</h3><h4 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h4><p>为文件设置一个“口令”，用户请求访问该文件时必须提供“口令”。</p><p>口令一般存放在文件对应的FCB或索引结点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件。</p><p>优点：保存口令的空间开销不多，验证口令的时间开销也很小。</p><p>缺点：正确的“口令“存放在系统内部，不够安全。</p><h4 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h4><p>使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码“才能对文件进行正确的解密。</p><p>优点：保密性强，不需要在系统中存储”密码“</p><p>缺点：编码&#x2F;译码，或者说加密&#x2F;解密要花费一定时间。</p><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>在每个文件的FCB（或索引结点）中增加一个访问控制列表（Access-Control List, ACL），该表中记录了各个用户可以对该文件执行哪些操作。</p><p>访问类型：</p><ul><li>读：从文件中读数据</li><li>写：向文件中写数据</li><li>执行：将文件装入内存并执行</li><li>添加：将信息添加到文件结尾部分</li><li>删除：删除文件，释放空间</li><li>列表清单：列出文件名和文件属性</li></ul><p>精简的访问列表：以“组”为单位，标记各“组”用户可以对问及那执行哪些操作。如：分为系统管理员、文件主、文件主的伙伴、其他用户几个分组。</p><p>当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。</p><h3 id="4-1-9-文件系统的层次结构"><a href="#4-1-9-文件系统的层次结构" class="headerlink" title="4.1.9 文件系统的层次结构"></a>4.1.9 文件系统的层次结构</h3><p><img src="http://1.117.162.142:9000/blog/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="文件系统的层次结构"></p><p>用一个例子来辅助记忆文件系统的层次结构：</p><p>假设某用户请求删除文件“D:&#x2F;工作目录&#x2F;学生信息.xlsx“的最后100条记录。</p><ol><li>用户需要通过操作系统提供的接口发出上述请求——用户接口</li><li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项——文件目录系统</li><li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限——存取控制模块（存取控制验证层）</li><li>验证了用户的访问权限之后，需要把用户提供的”记录号“转变为对应的逻辑结构——逻辑文件系统与文件信息缓冲区</li><li>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址——物理文件系统</li><li>要删除这条记录，必定要对磁盘设备发出请求——设备管理程序模块</li><li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收——辅助分配模块</li></ol><h3 id="4-2-1-磁盘的结构"><a href="#4-2-1-磁盘的结构" class="headerlink" title="4.2.1 磁盘的结构"></a>4.2.1 磁盘的结构</h3><h4 id="磁盘、磁道、扇区的概念"><a href="#磁盘、磁道、扇区的概念" class="headerlink" title="磁盘、磁道、扇区的概念"></a>磁盘、磁道、扇区的概念</h4><p>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</p><p>磁盘的磁面被划分成一个个磁道。这样的一个“圈”就是一个磁道。</p><p>最内侧磁道上的扇区面积最小，因此数据密度最大</p><p>一个磁道又被分成一个个扇区，每个扇区就是一个“磁盘块”。各个扇区存放的数据量相同。</p><h4 id="如何在磁盘中读-x2F-写数据"><a href="#如何在磁盘中读-x2F-写数据" class="headerlink" title="如何在磁盘中读&#x2F;写数据"></a>如何在磁盘中读&#x2F;写数据</h4><p>需要把“磁头”移动到想要读&#x2F;写的扇区所在的磁道。磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读&#x2F;写操作。</p><h4 id="盘面、柱面的概念"><a href="#盘面、柱面的概念" class="headerlink" title="盘面、柱面的概念"></a>盘面、柱面的概念</h4><p>一个盘片可能会有两个盘面，每个 盘面对应一个磁头，所有的磁头都是连在同一个磁臂上的，因此所有磁头只能“共进退”，所有盘面中相对位置相同的磁道组成柱面。</p><h4 id="磁盘的物理地址"><a href="#磁盘的物理地址" class="headerlink" title="磁盘的物理地址"></a>磁盘的物理地址</h4><p>可用（柱面号，盘面号，扇区号）来定位任意一个“磁盘块“。文件数据存放在外存中的几号块，这个块号就可以转换成（柱面号，盘面号，扇区号）的地址形式。</p><p>可根据该地址读取一个”块”</p><ol><li>根据“柱面号”移动磁臂，让磁头指向柱面</li><li>激活指定盘面对应的磁头</li><li>磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读&#x2F;写。</li></ol><h4 id="磁盘的分类"><a href="#磁盘的分类" class="headerlink" title="磁盘的分类"></a>磁盘的分类</h4><p>磁头可以移动的活动头磁盘。磁臂可以来回伸缩来带动磁头定位磁道。</p><p>磁头不可移动的称为固定磁盘。这种磁盘中每个磁道由一个磁头。</p><p>盘片可以更换的称为可换盘磁盘。盘片不可更换的称为固定盘磁盘。</p><h3 id="4-2-2-磁盘调度算法"><a href="#4-2-2-磁盘调度算法" class="headerlink" title="4.2.2 磁盘调度算法"></a>4.2.2 磁盘调度算法</h3><h4 id="一次磁盘读-x2F-写操作需要的时间"><a href="#一次磁盘读-x2F-写操作需要的时间" class="headerlink" title="一次磁盘读&#x2F;写操作需要的时间"></a>一次磁盘读&#x2F;写操作需要的时间</h4><p><strong>寻找时间(寻道时间)T<sub>s</sub></strong>:</p><p>在读&#x2F;写数据钱，将磁头移动到指定磁道所花的时间。</p><ol><li><p>启动磁头臂是需要时间的。假设耗时为s；</p></li><li><p>移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。则：</p><p> 寻道时间T<sub>s</sub> &#x3D; s + m * n</p></li></ol><p><strong>延迟时间T<sub>R</sub></strong></p><p>通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r(单位：转&#x2F;秒，或转&#x2F;分)，则平均所需的延迟时间T<sub>R</sub> &#x3D; (1&#x2F;2) * (1&#x2F;r) &#x3D; 1&#x2F;2r。</p><p>1&#x2F;r就是转一圈需要的时间。找到目标扇区平均需要转半圈，因此再乘以1&#x2F;2。</p><p><strong>传输时间T<sub>t</sub></strong></p><p>从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读&#x2F;写的字节数为b，每个磁道上的字节数为N。则：传输时间T<sub>t</sub> &#x3D; (1&#x2F;r) * (b&#x2F;N) &#x3D; b&#x2F;(rN)。</p><p>总的平均存取时间T<sub>a</sub> &#x3D; T<sub>s</sub> + 1&#x2F;2r + b&#x2F;(rN)</p><blockquote><p>每个磁道要可存N字节的数据，因此b字节的数据需要b&#x2F;N个磁道才能存储。而读&#x2F;写一个磁道所需要的时间刚好又是转一圈所需要的时间1&#x2F;r。延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间。</p></blockquote><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><p><strong>先来先服务FCFS</strong></p><p>根据进程请求访问磁盘的先后顺序进行调度。</p><p>假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道。按照FCFS的规则，按照请求到达的顺序，磁头需要一次移动到55、58、39、18、90、160、150、38、184号磁道。磁头总共移动了45+3+19+21+72+70+10+112+146&#x3D;498个磁道</p><p>响应一个请求平均需要移动498&#x2F;9&#x3D;55.3个磁道（平均寻找长度）</p><p>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过得去。</p><p>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。</p><p><strong>最短寻找时间优先SSTF</strong></p><p>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优）</p><p>假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道。</p><p>磁头总共移动了（100-18）+（184-18）&#x3D;248个磁道</p><p>响应一个请求平均需要移动248&#x2F;9 &#x3D; 27.5个磁道（平均寻找长度）</p><p>优点：性能较好，平均寻道时间短</p><p>缺点：可能产生“饥饿”现象</p><p>eg：本例中，如果在处理18号磁道的访问请求时又来了一个38号磁道的访问请求，处理38号磁道的访问请求又来了一个18号磁道的访问请求。如果有源源不断的18号、38号磁道的访问请求到来的话，150、160、184号磁道的访问请求就永远得不到满足，从而产生“饥饿”现象。</p><blockquote><p>产生饥饿的原因在于：磁头在一个小区域内来回来去地移动。</p></blockquote><p><strong>扫描算法SCAN</strong></p><p>SSTF算法产生饥饿的原因在于：磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。这就是扫描算法的思想。由于磁头移动的方式很像电梯，因此也叫电梯算法。</p><p>假设某磁盘的磁道为0～200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、16 0、150、38、184号磁道</p><p>磁头总共移动了（200-100）+（200 -18）&#x3D; 32个磁道</p><p>响应一个请求平均需要移动282&#x2F;9&#x3D;31.3个磁道（平均寻找长度）</p><p>优点：</p><ol><li>只有到达最边上的磁道时，才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后，就不需要再往右移动磁头了。</li><li>SCAN算法对于各个位置磁道的响应频率不平均（如：假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离；而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了）</li></ol><p><strong>Look调度算法</strong></p><p>扫描算法中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。Look调度算法就是为了解决这个问题，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。（边移动边观察，因此叫Look）</p><p>假设某磁盘的磁道为0～200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道</p><p>磁头总共移动了（184 - 100）+（184 - 18）&#x3D; 250个磁道</p><p>响应一个请求平均需要移动250 &#x2F; 9 &#x3D; 27.5 个磁道（平均寻找长度）</p><p>优点：比起SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短。</p><p><strong>循环扫描算法C-SCAN</strong></p><p>SCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</p><p>假设某磁盘的磁道为0～200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道</p><p>磁头总共移动了（200 -100）+（200-0）+（90-0）&#x3D; 390 个磁道</p><p>响应一个请求平均需要移动390 &#x2F; 9 &#x3D; 43.3 个磁道（平均寻找长度）</p><p>优点：比起SCAN来，对于各个位置磁道的响应频率很平均。</p><p>缺点：只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了；并且，磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。另外，比起SCAN算法来，平均寻道时间更长。</p><p><strong>C-LOOK调度算法</strong></p><p>C-SCAN算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p><p>假设某磁盘的磁道为0～200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道</p><p>磁头总共移动了（184 - 100）+（184 - 18） +（90 - 18）&#x3D; 322 个磁道</p><p>响应一个请求平均需要移动322 &#x2F; 9 &#x3D; 35.8个磁道（平均寻找长度）</p><p>优点：比起C-SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短。</p><h3 id="4-2-3-减少磁盘延迟时间的方法"><a href="#4-2-3-减少磁盘延迟时间的方法" class="headerlink" title="4.2.3 减少磁盘延迟时间的方法"></a>4.2.3 减少磁盘延迟时间的方法</h3><h4 id="交替编号"><a href="#交替编号" class="headerlink" title="交替编号"></a>交替编号</h4><p>具体做法：让编号相邻的扇区在物理上不相邻</p><p>原理：读取完一个扇区后需要一段时间处理才可以继续读入下一个扇区</p><h4 id="错位命名"><a href="#错位命名" class="headerlink" title="错位命名"></a>错位命名</h4><p>具体做法：让相邻盘面的扇区编号“错位”</p><p>原理：与“交替编号”的原理相同。”错位命名法“可降低延迟时间</p><h4 id="磁盘地址结构的设计"><a href="#磁盘地址结构的设计" class="headerlink" title="磁盘地址结构的设计"></a>磁盘地址结构的设计</h4><blockquote><p>为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）</p></blockquote><p>假设某磁盘有8个柱面&#x2F;磁道（假设最内侧柱面&#x2F;磁道号为0），4个盘面，8个扇区。则可用3个二进制位表示柱面，2个二进制位表示盘面，3个二进制位表示扇区。</p><p>若物理地址结构式（盘面号，柱面号，扇区号），且需要连续读取物理地址（00，000，000）～（00，001，111）的扇区：</p><p>（00，000，000）～（00，000，111）转两圈可读完</p><p>之后再读取物理地址相邻的区域，即（00，001，000）～（00，001，111），需要启动磁头臂，将磁头移动到下一个磁道。</p><p>若物理地址结构式（柱面号，盘面号，扇区号），且需要连续读取物理地址（000，00，000）～（000，01，111）的扇区：</p><p>（000，00，000）～（000，00，111）由盘面0的磁头读入数据之后再读取物理地址相邻的区域，即（000，01， 000）～（000，01，111），由于柱面号&#x2F;磁道号相同，只是盘面号不同，因此不需要移动磁头臂。只需要激活相邻盘面的磁头即可。</p><p>原因：在读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间。</p><h3 id="4-2-4-磁盘的管理"><a href="#4-2-4-磁盘的管理" class="headerlink" title="4.2.4 磁盘的管理"></a>4.2.4 磁盘的管理</h3><h4 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h4><ol><li>进行低级格式化（物理格式化），将磁盘的各个磁道划分为扇区。一个扇区通常可分为头、数据区域（如512B大小）、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶检验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误）</li><li>将磁盘分区，每个分区由若干柱面组成（即分为我们熟悉的C盘、D盘、E盘）</li><li>进行逻辑格式化，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表）</li></ol><h4 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h4><p>计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行初始化程序（自举程序）完成的。初始化程序可以放在ROM（只读存储器）中。</p><p>ROM中的数据在出厂时就写入了，并且以后不能再修改。</p><p>ROM一般是出厂时就集成在主板上的。</p><p>ROM中只存放很小的“自举装入程序”。</p><p>完成的自举程序放在磁盘的启动块（即引导块&#x2F;启动分区）上，启动块位于磁盘的固定位置。</p><p>开机时计算机先运行“自举装入程序”，通过执行该程序就可找到引导块，并将完整的“自举程序”读入内存，完成初始化。拥有启动分区的磁盘称为启动磁盘或系统磁盘（C:盘）</p><h4 id="坏块的管理"><a href="#坏块的管理" class="headerlink" title="坏块的管理"></a>坏块的管理</h4><p>坏了、无法正常使用的是扇区就是“坏块”。这属于硬件故障，操作系统是无法修复的。应该将坏块标记出来，以免错误地使用到它。</p><p>对于简单的磁盘，可以在逻辑格式化时（建立文件系统时）对整个磁盘进行坏块检查，表明哪些扇区是坏扇区，比如：在FAT表上表明。（在这种方式中，坏块对操作系统不透明）</p><p>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。</p><p>在磁盘出厂前进行低级格式化（物理格式化）时就讲坏块链进行初始化。</p><p>会保留一些”备用扇区“，用于替换坏块。这种方案称为扇区备用。且这种处理方式中，坏块对操作系统透明。</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="5-1-1-I-x2F-O设备的概念和分类"><a href="#5-1-1-I-x2F-O设备的概念和分类" class="headerlink" title="5.1.1 I&#x2F;O设备的概念和分类"></a>5.1.1 I&#x2F;O设备的概念和分类</h3><h4 id="什么是I-x2F-O设备"><a href="#什么是I-x2F-O设备" class="headerlink" title="什么是I&#x2F;O设备"></a>什么是I&#x2F;O设备</h4><p>“I&#x2F;O”就是“输入&#x2F;输出”（Input&#x2F;Output）</p><p>I&#x2F;O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</p><p>UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。</p><p>Write操作：向外部设备写出数据</p><p>Read操作：从外部设备读入数据</p><h4 id="按使用特性分类"><a href="#按使用特性分类" class="headerlink" title="按使用特性分类"></a>按使用特性分类</h4><ul><li><p>人机交互类外部设备</p><p>  数据传输速度慢。包括鼠标、键盘、打印机等，用于人机交互</p></li><li><p>存储设备</p><p>  数据传输速度快。包括移动硬盘、光盘等，用于数据存储</p></li><li><p>网络通信设备</p><p>  数据传输速度介于上述两种之间。包括调制解调器等，用于网络通信</p></li></ul><h4 id="按传输速率分类"><a href="#按传输速率分类" class="headerlink" title="按传输速率分类"></a>按传输速率分类</h4><ul><li>低速设备：鼠标、键盘，每秒几个到几百字节</li><li>中速设备：激光打印机，每秒数千至上万个字节</li><li>高速设备：磁盘，每秒数千字节至前兆字节</li></ul><h4 id="按信息交换的单位分类"><a href="#按信息交换的单位分类" class="headerlink" title="按信息交换的单位分类"></a>按信息交换的单位分类</h4><ul><li><p>块设备：传输速率较高，可寻址，即对它随机地读&#x2F;写任一块。如磁盘等，数据传输的基本单位是“块”。</p></li><li><p>字符设备：传输速率较慢，不可寻址，在输入&#x2F;输出时常采用中断驱动方式。如鼠标、键盘等，数据传输的基本单位是字符。</p></li></ul><h3 id="5-1-2-I-x2F-O控制器"><a href="#5-1-2-I-x2F-O控制器" class="headerlink" title="5.1.2 I&#x2F;O控制器"></a>5.1.2 I&#x2F;O控制器</h3><p>CPU无法直接控制I&#x2F;O设备的机械部件，因此I&#x2F;O设备还要有一个电子部件作为CPU和I&#x2F;O设备机械部件之间的“中介”，用于实现CPU对设备的控制。</p><p>这个电子部件就是I&#x2F;O控制器，又称设备控制器。CPU可控制I&#x2F;O控制器，又由I&#x2F;O控制器来控制设备的机械部件。</p><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ul><li><p>接受和识别CPU发出的命令</p><p>  如CPU发来的read&#x2F;write命令，I&#x2F;O控制器中会有相应的控制寄存器来存放命令和参数</p></li><li><p>向CPU报告设备的状态</p><p>  I&#x2F;O控制器中会有相应的状态寄存器，用于记录I&#x2F;O设备的当前状态。如1表示空闲，0表示忙碌</p></li><li><p>数据交换</p><p>  I&#x2F;O控制器中会设置相应的数据寄存器。输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备。输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据。</p></li><li><p>地址识别</p><p>  类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的”地址“。I&#x2F;O控制器通过CPU提供的“地址”来判断CPU要读&#x2F;写的是哪个寄存器。</p></li></ul><h4 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h4><ul><li><p>CPU与控制器的接口</p><p>  用于实现CPU与控制器之间的通信。CPU通过控制线发出命令；通过地址线指明要操作的设备；通过数据线来取出（输入）数据，或放入（输出）数据</p></li><li><p>I&#x2F;O逻辑</p><p>  负责接收和识别CPU的各种命令（如地址译码），并负责对设备发出命令</p></li><li><p>控制器与设备的接口</p><p>  用于实现控制器与设备之间的通信</p></li></ul><p>ps：</p><ol><li>一个I&#x2F;O控制器可能会对应多个设备；</li><li>数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制&#x2F;状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像I&#x2F;O；另一些计算机则采用I&#x2F;O专用地址，即寄存器独立编址。</li></ol><h4 id="两种寄存器编址方式"><a href="#两种寄存器编址方式" class="headerlink" title="两种寄存器编址方式"></a>两种寄存器编址方式</h4><ul><li><p>内存映射I&#x2F;O</p><p>  控制器中的寄存器与内存地址统一编址</p><p>  优点：简化了指令。可以采用对内存进行操作的指令来对控制器进行操作。</p></li><li><p>寄存器独立编址</p><p>  控制器中的寄存器使用单独的地址。</p><p>  缺点：需要设置专门的指令来实现对控制器的操作，不仅要指明寄存器的地址，还要指明控制器的编号。</p></li></ul><h3 id="5-1-3-I-x2F-O控制方式"><a href="#5-1-3-I-x2F-O控制方式" class="headerlink" title="5.1.3 I&#x2F;O控制方式"></a>5.1.3 I&#x2F;O控制方式</h3><h4 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h4><p><strong>Key word：轮询</strong></p><ol><li><p>完成一次读&#x2F;写操作的流程（以读操作为例）</p><p> ①CPU向控制器发出读指令。于是设备启动，并且状态寄存器设为1（未就绪）</p><p> ②轮询检查控制器的状态（其实就是在不断地执行程序的循环，若状态位一直是1，说明设备还没准备好要输入的数据，于是CPU会不断地轮询）</p><p> ③摄入设备准备好数据后将数据传给控制器，并报告自身状态</p><p> ④控制器将输入的数据放到数据寄存器中，并将状态改为0（已就绪）</p><p> ⑤CPU发现设备已就绪，即可将数据寄存器中的内容读入CPU的寄存器中，再把CPU寄存器中的内容放入内存</p><p> ⑥若还要继续读入数据，则CPU继续发出读指令</p><p> <img src="http://1.117.162.142:9000/blog/%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png" alt="程序直接控制方式"></p></li><li><p>CPU干预的频率</p><p> 很频繁，I&#x2F;O操作开始之前、完成之后需要CPU介入，并且在等待I&#x2F;O完成的过程中CPU需要不断地轮询检查。</p></li><li><p>数据传送的单位</p><p> 每次读&#x2F;写一个字</p></li><li><p>数据的流向</p><p> 读操作（数据输入）：I&#x2F;O设备 -&gt; CPU -&gt; 内存</p><p> 写操作（数据输出）：内存 -&gt; CPU -&gt; I&#x2F;O设备</p><p> 每个字的读&#x2F;写都需要CPU的帮助</p></li><li><p>主要缺点和主要优点</p><p> 优点：实现简单。在读&#x2F;写指令之后，加上实现循环检查的一系列指令即可（因此才称为“程序直接控制方式”）</p><p> 缺点：CPU和I&#x2F;O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等“状态，CPU利用率低。</p></li></ol><h4 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h4><ol><li><p>完成一次读&#x2F;写操作的过程</p><p> <img src="http://1.117.162.142:9000/blog/%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F.png"></p></li><li><p>CPU干预的频率</p><p> 每次I&#x2F;O操作开始之前、完成之后需要CPU介入。等待I&#x2F;O完成的过程中CPU可以切换到别的进程执行。</p></li><li><p>数据传送的单位</p><p> 每次读&#x2F;写一个字</p></li><li><p>数据的流向</p><p> 读操作（数据输入）：I&#x2F;O设备 -&gt; CPU -&gt; 内存</p><p> 写操作（数据输出）：内存 -&gt; CPU -&gt; I&#x2F;O设备</p></li><li><p>主要缺点和主要优点</p><p> 优点：与“程序直接控制方式”相比，在“中断驱动方式”中，I&#x2F;O控制器会通过中断信号主动报告I&#x2F;O已完成，CPU不再需要不停地轮询。CPU和I&#x2F;O设备可并行工作，CPU利用率得到明显提升。</p><p> 缺点：每个字在I&#x2F;O设备与内存之间的传输，都需要经过CPU。而频繁的中断处理会消耗较多的CPU时间。</p></li></ol><p>引入中断机制。由于I&#x2F;O设备速度很慢，因此在CPU发出读&#x2F;写命令后，可将等待I&#x2F;O的进程阻塞，先切换到别的进程执行。当I&#x2F;O完成后，控制器会向CPU发出一个中断信号，CPU监测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，CPU从I&#x2F;O控制器读一个字的数据传送到CPU寄存器，在写入主存。接着，CPU恢复等待I&#x2F;O的进程（或其他进程）的运行环境，然后继续执行。</p><p>ps：</p><ol><li>CPU会在每个指令周期的末尾检查中断；</li><li>中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。如果中断发生的频率太高，也会降低系统性能。</li></ol><h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><p>与“中断驱动方式”相比，DMA方式（Direct Memory Access，直接存储器存取。主要用于块设备的I&#x2F;O控制）有这样几个改进：</p><p>①数据的传送单位是“块”。不再是一个字、一个字的传送</p><p>②数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为“快递小哥”</p><p>③仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</p><p><img src="http://1.117.162.142:9000/blog/DMA%E6%8E%A7%E5%88%B6%E5%99%A8.png" alt="DMA控制器"></p><p>DR（Data Register，数据寄存器）：暂存从设备到内存，或从内存到设备的数据。</p><p>MAR（Memory Address Register，内存地址寄存器）：在输入时，MAR表示数据应放到内存中的什么位置；输出时MAR表示要输出的数据放在内存中的什么位置。</p><p>DC（Data Counter，数据计数器）：表示剩余要读&#x2F;写的字节数。</p><p>CR（Command Register，命令&#x2F;状态寄存器）：用于存放CPU发来的I&#x2F;O命令，或设备的状态信息。</p><ol><li><p>完成一次读&#x2F;写操作的流程</p><p> <img src="http://1.117.162.142:9000/blog/DMA%E6%96%B9%E5%BC%8F.png" alt="DMA方式"></p></li><li><p>CPU干预的频率</p><p> 仅在传送一个或多个数据块的开始和结束时，才需要CPU干预</p></li><li><p>数据传送的单位</p><p> 每次读&#x2F;写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）</p></li><li><p>数据的流向（不再需要经过CPU）</p><p> 读操作（数据输入）：I&#x2F;O设备 -&gt; 内存</p><p> 写操作（数据输出）：内存 -&gt; I&#x2F;O设备</p></li><li><p>主要缺点和主要优点</p><p> 优点：数据传输以“块”为单位，CPU介入频率进一步降低。数据的传输不再需要先经过CPU在写入内存，数据传输效率进一步增加。CPU和I&#x2F;O设备的并行性得到提升。</p><p> 缺点：CPU每发出一条I&#x2F;O指令，只能读&#x2F;写一个或多个连续的数据块。如果要读&#x2F;写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I&#x2F;O指令，进行多次中断处理才能完成。</p></li></ol><h4 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h4><p>通道：一种硬件，可以理解为是“弱鸡版的CPU”。通道可以识别并执行一系列通道指令。与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存</p><p>①CPU向通道发出I&#x2F;O指令。指明通道程序在内存中的位置，并指明要操作的是哪个I&#x2F;O设备。之后CPU就切换到其他进程执行了</p><p>②通道执行内存中的通道程序（其中指明了要读入&#x2F;写出多少数据，读&#x2F;写的数据应放在内存的什么位置等信息）</p><p>③通道执行完规定的任务后，向CPU发出中断信号，之后C PU对中断进行处理</p><ol><li><p>完成一次读&#x2F;写操作的流程</p><p> <img src="http://1.117.162.142:9000/blog/%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png" alt="通道控制方式"></p></li><li><p>CPU干预的频率</p><p> 极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读&#x2F;写后才需要发出中断信号，请求CPU干预。</p></li><li><p>数据传送的单位</p><p> 每次读&#x2F;写一组数据块</p></li><li><p>数据的流向（在通道的控制下进行）</p><p> 读操作（数据输入）：I&#x2F;O设备 -&gt; 内存</p><p> 写操作（数据输出）：内存 -&gt; I&#x2F;O设备</p></li><li><p>主要缺点和主要优点</p><p> 缺点：实现复杂，需要专门的通道硬件支持</p><p> 优点：CPU、通道、I&#x2F;O设备可并行工作，资源利用率很高</p></li></ol><h3 id="5-1-4-I-x2F-O软件层次结构"><a href="#5-1-4-I-x2F-O软件层次结构" class="headerlink" title="5.1.4 I&#x2F;O软件层次结构"></a>5.1.4 I&#x2F;O软件层次结构</h3><p><img src="http://1.117.162.142:9000/blog/IO%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="IO软件层次结构"></p><h4 id="用户层软件"><a href="#用户层软件" class="headerlink" title="用户层软件"></a>用户层软件</h4><p>实现了与用户交互的接口，用户可直接使用该层提供的、与I&#x2F;O操作相关的库函数对设备进行操作</p><p>用户层软件将用户请求翻译成格式化的I&#x2F;O请求，并通过“系统调用”请求操作系统内核的服务</p><p>Windows操作系统向外提供的一系列系统调用，但是由于系统调用的格式严格，使用麻烦，因此在用户层上封装了一系列更方便的库函数共用户使用</p><h4 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h4><p>又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。</p><p>主要功能：</p><ol><li><p>向上一层提供统一的调用接口（如read&#x2F;write系统调用）</p></li><li><p>设备的保护</p><p> 原理类似与文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样。</p></li><li><p>差错处理</p><p> 设备独立性软件需要对一些设备的错误进行处理</p></li><li><p>设备的分配与回收</p></li><li><p>数据缓冲区管理</p><p> 可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</p></li><li><p>建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序</p><p> 用户或用户层软件发出I&#x2F;O操作相关系统调用时，需要指明此次要操作的I&#x2F;O设备的逻辑设备名</p><p> 设备独立性软件需要通过“逻辑设备表”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序</p></li></ol><p>操作系统可以采用两种方式管理逻辑设备表LUT：</p><ul><li>整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种只适用于丹用户操作系统。</li><li>为每个用户设置一张LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</li></ul><blockquote><p>为何不同的设备需要不同的设备驱动程序？</p></blockquote><p>不同设备的内部硬件特性不同，这些特性只有厂家才知道，因此厂家必须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作。</p><h4 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h4><p>主要负责对硬件设备的具体控制，将上层发出的一系列命令（如read&#x2F;write）转化成特定设备“能听得懂”的一些列操作。包括设置设备寄存器；检查设备状态等。</p><p>ps：驱动程序一般会以一个独立进程的方式存在。</p><h4 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h4><p>当I&#x2F;O任务完成时，I&#x2F;O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序的处理流程如下：</p><p>从控制器读出设备状态，若I&#x2F;O正常结束，从设备中读入一个字的数据并经由CPU放到内存缓冲区中。若I&#x2F;O异常结束，根据异常原因做响应处理。</p><h3 id="5-1-5-I-x2F-O核心子系统"><a href="#5-1-5-I-x2F-O核心子系统" class="headerlink" title="5.1.5 I&#x2F;O核心子系统"></a>5.1.5 I&#x2F;O核心子系统</h3><p><img src="http://1.117.162.142:9000/blog/IO%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F.png" alt="IO核心子系统"></p><h4 id="各功能要在那个层次实现"><a href="#各功能要在那个层次实现" class="headerlink" title="各功能要在那个层次实现"></a>各功能要在那个层次实现</h4><p>用户层软件：假脱机技术SPOOLing技术</p><p>设备独立性软件：I&#x2F;O调度、设备保护、设备分配与回收、缓冲区管理（即缓冲与高速缓存）</p><p>ps：假脱机技术SPOOLing技术需要请求“磁盘设备”的设备独立性软件的服务，因此一般来说假脱机技术是在用户层软件实现的。</p><p>I&#x2F;O调用：用某种算法确定一个好的顺序来处理各个I&#x2F;O请求。</p><h3 id="5-1-6-假脱机技术"><a href="#5-1-6-假脱机技术" class="headerlink" title="5.1.6 假脱机技术"></a>5.1.6 假脱机技术</h3><h4 id="什么是脱机技术，脱机技术可以解决什么问题"><a href="#什么是脱机技术，脱机技术可以解决什么问题" class="headerlink" title="什么是脱机技术，脱机技术可以解决什么问题"></a>什么是脱机技术，脱机技术可以解决什么问题</h4><p>手工操作阶段：主机直接从I&#x2F;O设备获得数据，由于设备速度慢，主机速度很快 。人机速度矛盾明显，主机要浪费很多时间来等待设备。</p><p>批处理阶段引入了脱机输入&#x2F;输出技术：在外围控制机的控制下，慢速输入设备的数据先辈输入到更快速的磁带上。之后主机可以从快速的磁带上读入数据，从而缓解了速度矛盾。引入脱机技术后，缓解了CPU与慢速I&#x2F;O设备的速度矛盾。另一方面，即使CPU在忙碌，也可以提前将数据输入到磁带；即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁道。</p><blockquote><p>脱机——脱离主机的控制进行的输入&#x2F;输出操作。</p></blockquote><h4 id="假脱机技术的实现原理"><a href="#假脱机技术的实现原理" class="headerlink" title="假脱机技术的实现原理"></a>假脱机技术的实现原理</h4><p>“假脱机技术”又称“SPOOLing技术”，是用软件的方式模拟脱机技术。SPOOLing系统的组成如下：</p><p><img src="http://1.117.162.142:9000/blog/spooling%E7%BB%84%E6%88%90.png" alt="spooling组成"></p><p><strong>输入井和输出井</strong></p><p>“输入井”模拟脱机输入时的磁带，用于收容I&#x2F;O设备输入的数据。</p><p>“输出井”模拟脱机输出时的磁带，用于收容用户进程输出的数据。</p><p><strong>输入进程和输出进程</strong></p><p>“输入进程”模拟脱机输入时的外围控制机</p><p>“输出进程”模拟脱机输出时的外围控制机</p><p><strong>输入缓冲区和输出缓冲区</strong></p><p>在输入进程的控制下，“输入缓冲区”用于暂存从输入设备输入的数据，之后在转存到输入井中</p><p>在输出进程的控制下，”输出缓冲区“用于暂存从输出井送来的数据，之后再传送到输出设备上</p><h4 id="共享打印机原理"><a href="#共享打印机原理" class="headerlink" title="共享打印机原理"></a>共享打印机原理</h4><p>独占式设备——只允许各个进程串行使用的设备。一段时间只能满足一个进程的请求。</p><p>共享设备——允许多个进程“同时”使用的设备（宏观上同时使用，微观上可能是交替使用）。可以同时满足多个进程的使用请求。</p><p>打印机是种“独占式设备”，但是可以用SPOOLing技术改造成“共享设备”</p><p>独占式设备的例子：若进程1正在使用打印机，则进程2请求使用打印机时必然阻塞等待</p><p>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给它们，而是由假脱机管理进程为每个进程做两件事：</p><ol><li>在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中；</li><li>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上。</li></ol><p>当打印机空闲时，输出进程会从文件队列的对头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务。</p><p>虽然系统中只有一台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。</p><p>SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备。</p><h3 id="5-1-7-设备的分配与回收"><a href="#5-1-7-设备的分配与回收" class="headerlink" title="5.1.7 设备的分配与回收"></a>5.1.7 设备的分配与回收</h3><h4 id="设备分配时应考虑的因素"><a href="#设备分配时应考虑的因素" class="headerlink" title="设备分配时应考虑的因素"></a>设备分配时应考虑的因素</h4><ul><li><p>设备的固有属性</p><ul><li>独占设备：一个时段只能分配给一个进程，如打印机</li><li>共享设备：可同时分配给多个进程使用，如磁盘。各进程往往使宏观上同时共享使用设备，而微观上交替使用。</li><li>虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用，如采用SPOOLing技术实现的共享打印机</li></ul></li><li><p>设备分配算法</p><p>  先来先服务、优先级高者优先、短任务优先等</p></li><li><p>设备分配中的安全性</p><ul><li><p>安全分配方式：为进程分配一个设备后就讲进程阻塞，本次I&#x2F;O完成后才将进程唤醒。</p><p>  一个时段内每个进程只能使用一个设备。</p><p>  优点：破坏了“请求和保持”条件，不会死锁</p><p>  缺点：对于一个进程来说，CPU和I&#x2F;O设备只能串行工作</p></li><li><p>不安全分配方式：进程发出I&#x2F;O请求后，系统为其分配I&#x2F;O设备，进程可继续执行，之后还可以发出新的I&#x2F;O请求。只有某个I&#x2F;O请求得不到满足时才将进程阻塞。</p><p>  一个进程可以同时使用多个设备</p><p>  优点：进程的计算任务和I&#x2F;O任务可以并行处理，使进程迅速推进</p><p>  缺点：有可能发生死锁（死锁避免、死锁的检测和解除）</p></li></ul></li></ul><h4 id="静态分配与动态分配"><a href="#静态分配与动态分配" class="headerlink" title="静态分配与动态分配"></a>静态分配与动态分配</h4><p>静态分配：进程运行前为其分配全部所需资源，运行结束后归坏资源。破坏了“请求和保持”条件，不会发生死锁</p><p>动态分配：进程运行过程中动态申请设备资源</p><h4 id="设备分配管理中的数据结构"><a href="#设备分配管理中的数据结构" class="headerlink" title="设备分配管理中的数据结构"></a>设备分配管理中的数据结构</h4><p>“设备、控制器、通道”之间的关系：</p><p><img src="http://1.117.162.142:9000/blog/%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8%E9%80%9A%E9%81%93%E5%85%B3%E7%B3%BB.png" alt="设备控制器通道关系"></p><p>一个通道可控制多个设备控制器，每个设备控制器可控制多个设备。</p><p>设备控制表（DCT）：系统为每个设备配置一张DCT，用于记录设备情况</p><p><img src="http://1.117.162.142:9000/blog/%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E8%A1%A8.png" alt="设备控制表"></p><p>控制器控制表（COCT）：每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。</p><p><img src="http://1.117.162.142:9000/blog/%E6%8E%A7%E5%88%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E8%A1%A8.png" alt="控制器控制表"></p><p>通道控制表（CHCT）：每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理。</p><p><img src="http://1.117.162.142:9000/blog/%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E8%A1%A8.png" alt="通道控制表"></p><p>系统设备表（SDT）：记录了系统中全部设备的情况，每个设备对应一个表目</p><p><img src="http://1.117.162.142:9000/blog/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E5%A4%87%E8%A1%A8.png" alt="系统设备表"></p><h4 id="设备分配的步骤"><a href="#设备分配的步骤" class="headerlink" title="设备分配的步骤"></a>设备分配的步骤</h4><ol><li>根据进程请求的物理设备名查找SDT（注：物理设备名时进程请求分配设备时提供的参数）</li><li>根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li><li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li></ol><blockquote><p>只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I&#x2F;O设备进行数据传送</p></blockquote><p>缺点：</p><ol><li>用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程</li><li>若换了一个物理设备，则程序无法运行</li><li>若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</li></ol><p>改进：建立逻辑设备名与物理设备名的映射机制，用户编程时只需要提供逻辑设备名</p><h4 id="设备分配步骤的改进方法"><a href="#设备分配步骤的改进方法" class="headerlink" title="设备分配步骤的改进方法"></a>设备分配步骤的改进方法</h4><ol><li>根据进程请求的逻辑设备名查找SDT（用户编程时提供的逻辑设备名其实就是“设备类型”）</li><li>查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表LUT中新增一个表项。</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li><li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li></ol><p>逻辑设备表LUT建立了逻辑设备名与物理设备名之间的映射关系。</p><p>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项。</p><p>如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址。</p><p>逻辑设备表的设置问题：</p><p>整个系统只有一张LUT：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统</p><p>每个用户一张LUT：不同用户的逻辑设备名可重复，适用于多用户操作系统</p><h3 id="5-1-8-缓冲区管理"><a href="#5-1-8-缓冲区管理" class="headerlink" title="5.1.8 缓冲区管理"></a>5.1.8 缓冲区管理</h3><h4 id="缓冲区的概念"><a href="#缓冲区的概念" class="headerlink" title="缓冲区的概念"></a>缓冲区的概念</h4><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</p><p>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</p><p>一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要阻止管理好这些缓冲区</p><p>缓冲区的作用：</p><ul><li>缓和CPU与I&#x2F;O设备之间速度不匹配的矛盾</li><li>减少对CPU的中断频率，放宽对CPU中断相应时间的限制</li><li>解决数据力度不匹配的问题</li><li>提高CPU与I&#x2F;O设备之间的并行性</li></ul><h4 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h4><p>假设某用户进程请求某块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区。当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满后，才能冲缓冲区把数据传出。</p><p>处理一块数据平均耗时Max(C, T) + M</p><h4 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h4><p>假设某用户进程请求某种块设备读入若干块的数据。若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区。</p><p>处理一个数据块的平均耗时为Max(T, C + M)</p><h4 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h4><p>将多个大小相等的缓冲区连接成一个循环队列。</p><h4 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h4><p>缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。</p><p>另外，根据一个缓冲区在世纪运算中扮演的功能不同，又设置了四种工作缓冲区：</p><ul><li>用于收容输入数据的工作缓冲区（hin）</li><li>用于提取输入数据的工作缓冲区（sin）</li><li>用于收容输出数据的工作缓冲区（hout）</li><li>用于提取输出数据的工作缓冲区（sout）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2022/07/13/computer/"/>
      <url>/2022/07/13/computer/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><h3 id="概念、组成、功能和分类"><a href="#概念、组成、功能和分类" class="headerlink" title="概念、组成、功能和分类"></a>概念、组成、功能和分类</h3><p>计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。</p><p>计算机网络是互联、自治的计算机集合。</p><ul><li>互联：互通互联——通信链路</li><li>自治：无主从关系</li></ul><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>数据通信</li><li>资源共享（硬件、软件、数据）</li><li>分布式处理  多台计算机各自承担同一工作任务的不同部分</li><li>提高靠靠性</li><li>负载均衡</li></ul><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li>组成部分分为软件、硬件和协议</li><li>工作方式包括边缘部分和核心部分。边缘部分从用户使用角度又可分为C&#x2F;S方式和P2P方式。核心部分为边缘部分提供服务。</li><li>功能组成包括通信子网和资源子网。通信子网实现数据通信，包括物理层、数据链路层和网络层。资源子网实现资源共享、数据处理等，包含会话层、表示层和应用层。</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>按分布范围可分为：广域网WAN、城域网MAN、局域网WAN和个人区域网PAN。</li><li>按使用者可分为：公用网和专用网。</li><li>按交换技术可分为：电路交换、报文交换和分组交换。</li><li>按拓扑结构可分为：总线型、星型、环形和网状型。</li><li>按传输技术可分为：广播式网络(共享公共通信信道)和点对点网络(使用分组存储转发和路由选择机制)。</li></ul><h3 id="标准化工组及相关组织"><a href="#标准化工组及相关组织" class="headerlink" title="标准化工组及相关组织"></a>标准化工组及相关组织</h3><blockquote><p>要实现不同厂商的硬、软件之间相互连通，必须遵从统一的标准。</p></blockquote><h4 id="标准的分类"><a href="#标准的分类" class="headerlink" title="标准的分类"></a>标准的分类</h4><ul><li>法定标准：由权威机构制定的正式的、合法的标准。eg: OSI</li><li>事实标准：某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准。eg:TCP&#x2F;IP</li></ul><h4 id="RFC（Request-For-Comments）因特网标准的形式"><a href="#RFC（Request-For-Comments）因特网标准的形式" class="headerlink" title="RFC（Request For Comments）因特网标准的形式"></a>RFC（Request For Comments）因特网标准的形式</h4><p>RFC要上升为因特网正式标准的四个阶段：</p><ol><li>因特网草案（Internet Draft）这个阶段还不是RFC文档。</li><li>建议标准（Proposed Standard）从这个阶段开始成为RFC文档。</li><li>草案标准（Draft Standard）IEFT、IAB</li><li>因特网标准（Internet Standard)</li></ol><h4 id="相关组织"><a href="#相关组织" class="headerlink" title="相关组织"></a>相关组织</h4><ul><li>国际标准化组织ISO：OSI参考模型、HDLC协议</li><li>国际电信联盟ITU：置顶通信规则</li><li>国际电气电子工程师协会IEEE：学术机构、IEEE802系列标准、5G</li><li>Internet工程师任务组IETF：负责因特网相关标准的制定</li></ul><h3 id="速率相关的性能指标"><a href="#速率相关的性能指标" class="headerlink" title="速率相关的性能指标"></a>速率相关的性能指标</h3><blockquote><p>速率即数据率或称数据传输率或比特率。也可以表示连接在计算机网络上的主机在数字信道上传送数据位数的速率。</p></blockquote><h4 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h4><p>单位是b&#x2F;s, kb&#x2F;s, Mb&#x2F;s, Gb&#x2F;s, Tb&#x2F;s</p><table><thead><tr><th>单位</th><th align="center">速率</th><th align="center">存储容量</th></tr></thead><tbody><tr><td>千</td><td align="center">1 kb&#x2F;s&#x3D;10^3 b&#x2F;s</td><td align="center">1 KB&#x3D;2^10 B&#x3D;1024 * 8 b</td></tr><tr><td>兆</td><td align="center">1 Mb&#x2F;s&#x3D;10^3 kb&#x2F;s&#x3D;10^6 b&#x2F;s</td><td align="center">1 MB&#x3D;2^10 KB&#x3D;1024 KB</td></tr><tr><td>吉</td><td align="center">1 Gb&#x2F;s&#x3D;10^3 Mb&#x2F;s&#x3D;10^6 Kb&#x2F;s&#x3D;10^ 9 b&#x2F;s</td><td align="center">1 GB&#x3D;2^10 MB&#x3D;1024 MB</td></tr><tr><td>太</td><td align="center">1 Tb&#x2F;s&#x3D;10^ Gb&#x2F;s&#x3D;10^6 Mb&#x2F;s&#x3D;10^9 Kb&#x2F;s&#x3D;10^12 b&#x2F;s</td><td align="center">1 TB&#x3D;2^10 GB&#x3D;1024 GB</td></tr></tbody></table><blockquote><p>ps: 1 Byte(字节)&#x3D;8bit(比特)</p></blockquote><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><p>原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹 Hz。</p><p>在计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间从网络中的某一点到令一点所能通过的最高数据率。单位是比特每秒，b&#x2F;s，kb&#x2F;s，Mb&#x2F;s，Tb&#x2F;s。即网络设备所支持的最高速率。</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>表示在单位时间内通过某个网络(或信道、接口)的数据量，单位b&#x2F;s，kb&#x2F;s，Mb&#x2F;s。</p><p>吞吐量受网络的带宽或网络的额定速率的限制。</p><h3 id="时延、时延带宽积、RTT和利用率"><a href="#时延、时延带宽积、RTT和利用率" class="headerlink" title="时延、时延带宽积、RTT和利用率"></a>时延、时延带宽积、RTT和利用率</h3><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><p>指数据（包围&#x2F;分组&#x2F;比特流）从网络（或链路）的一段传送到另一端所需的时间。也叫延迟或迟延。单位是s。</p><p><strong>发送时延</strong></p><ul><li>从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间。</li><li>发送时延&#x3D;数据长度&#x2F;信道带宽(发送速度)</li></ul><p><strong>传播时延</strong></p><ul><li>取决于电磁波传播速度和链路长度</li><li>传播时延&#x3D;信道长度&#x2F;电磁波在信道上的传播速率</li></ul><p><strong>排队时延</strong></p><ul><li>等待输出&#x2F;入链路可用</li></ul><p><strong>处理时延</strong></p><ul><li>检错找出口</li></ul><h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><p>时延带宽积又称为以比特为单位的链路长度，即某段链路现在有多少比特。<br>时延带宽积(bit)&#x3D;传播时延(s)*带宽(b&#x2F;s)</p><h4 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h4><p>从发送发发送数据开始，到发送发接收到接收方的确认，总共经历的时延。</p><p>RTT越大，在收到确认之前，可以发送的数据越多。</p><p>RTT包括往返传播时延(传播时延*2)和末端处理时间。</p><h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><p>利用率包括信道利用率和网络利用率。信道利用率&#x3D;有数据通过时间&#x2F;(有+无)数据通过时间。网络利用率等于信道利用率的加权平均值。</p><h3 id="分层结构、协议、接口和服务"><a href="#分层结构、协议、接口和服务" class="headerlink" title="分层结构、协议、接口和服务"></a>分层结构、协议、接口和服务</h3><h4 id="分层的基本原则"><a href="#分层的基本原则" class="headerlink" title="分层的基本原则"></a>分层的基本原则</h4><ul><li>各层之间相互独立，每层只实现一种相对独立的功能。</li><li>各层之间的界面自然清晰，易于理解，相互交流尽可能少。</li><li>结构上可分割开。每层都采用最合适的技术来实现。</li><li>保持下层对上层的独立性，上层单项使用下层提供的服务。</li><li>整个分层结构应该能促进标准化工作。</li></ul><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p>第n层中的活动元素称为n层实体。同一层的实体叫做对等实体。</p><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>为进行网络中的对等实体数据交换而建立的规则、标准或约定称为网络协议【水平方向】</p><p>语法：规定传输数据的格式</p><p>语义：规定所要完成的功能</p><p>同步：规定各种操作的顺序</p><h4 id="接口-访问服务点ASP"><a href="#接口-访问服务点ASP" class="headerlink" title="接口(访问服务点ASP)"></a>接口(访问服务点ASP)</h4><p>上层使用下层服务的入口</p><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>下层为相邻上层提供的功能调用。【垂直方向】</p><p><img src="http://1.117.162.142:9000/blog/p1.png"></p><p>SDU服务数据单元：未完成用户所要求的共功能而应传送的数据。</p><p>PCI协议控制信息：控制协议操作的信息。</p><p>PDU协议数据单元：对等层质传送的数据单元。</p><h3 id="OSI七层参考模型"><a href="#OSI七层参考模型" class="headerlink" title="OSI七层参考模型"></a>OSI七层参考模型</h3><p><img src="http://1.117.162.142:9000/blog/osi.png" alt="OSI 七层参考模型"></p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>所有能和用户交互产生网络流量的程序。</p><h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>用于处理在两个通信系统中交换信息的表示方式。</p><p>功能：</p><ul><li>数据格式变换——翻译官</li><li>数据加密解密——密码加密</li><li>数据压缩和恢复——图片压缩</li></ul><h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>向表示实体&#x2F;用户进程提供建立连接并在连接上有序地传送数据——建立同同步会话。</p><p>功能：</p><ul><li>建立、管理和终止会话。</li><li>使用校验点可使会话在通信失效时从校验点或同步点继续回复通信，实现数据同步。</li></ul><p>主要协议：ADS、SAP</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>负责主机中两个进程的通信。即端到端的通信。单位：报文段或用户数据报。</p><p>功能：</p><ul><li>可靠传输、不可靠传输</li><li>差错控制</li><li>流量控制</li><li>复用分用</li></ul><p>主要协议：TCP&#x2F;IP</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>把分组从源端缠讼到目的端，为分组交换网上的不同主机提供通信服务。单位：数据报。</p><p>功能：</p><ul><li>路由选择，最佳路径</li><li>流量控制</li><li>差错控制</li><li>拥塞控制</li></ul><p>主要协议：IP、IPX、ICMP、IGMP、ARP</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>把网络层传下来的数据报组装成帧。单位：帧</p><p>功能：</p><ul><li>成帧（定义帧的开始和结束）</li><li>差错控制：帧错或位错</li><li>流量控制</li><li>访问控制，控制对信道的访问</li></ul><p>主要协议：SDLC、HDLC、PPP、STP</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>在屋里媒体上实现比特流的透明传输——不管所传输数据是什么样的比特组合，都应当能狗在链路上传输。</p><p>功能：</p><ul><li>定义接口特性</li><li>定义传输模式。单工、半双工、双工</li><li>比特同步</li><li>比特编码</li></ul><p>主要协议：Rj45、802.5</p><h3 id="TCP-x2F-IP参考模型和5层参考模型"><a href="#TCP-x2F-IP参考模型和5层参考模型" class="headerlink" title="TCP&#x2F;IP参考模型和5层参考模型"></a>TCP&#x2F;IP参考模型和5层参考模型</h3><p>OSI参考 模型与TCP&#x2F;IP参考模型</p><p><img src="http://1.117.162.142:9000/blog/tcp.png" alt="TCP/IP 四层参考模型"></p><p>相同点：</p><ol><li>都分层</li><li>基于独立的协议栈的概念</li><li>可以实现异构网络互联</li></ol><p>不同点：</p><ol><li><p>OSI定义三点：服务、协议、接口</p></li><li><p>OSI先出现，参考模型限于协议发明，不偏向特定协议</p></li><li><p>TCP&#x2F;IP设计之初就考虑到异构网互联问题，将IP作为重要层次</p></li><li><table><thead><tr><th></th><th align="center">ISO&#x2F;OSI参考模型</th><th align="center">TCP&#x2F;IP模型</th></tr></thead><tbody><tr><td>网络层</td><td align="center">无连接+面向连接</td><td align="center">无连接</td></tr><tr><td>传输层</td><td align="center">面向连接</td><td align="center">无连接+面向连接</td></tr></tbody></table></li></ol><p>ps：面向连接：分为三个阶段，第一是建立连接，在此阶段，发出一个建立连接的请求。只有在连接成功建立之后，才能开始数据传输，这是第二阶段。接着，当数据传输完毕，必须释放连接。而面向无连接没有这么多阶段，它直接进行数据传输。</p><p>五层参考模型</p><p><img src="http://1.117.162.142:9000/blog/5floor.png" alt="五层参考模型"></p><p>五层参考模型的数据封装与解封装</p><p><img src="http://1.117.162.142:9000/blog/p2.png" alt="五层参考模型的数据封装与解封装"></p><h2 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h2><h3 id="物理层基础"><a href="#物理层基础" class="headerlink" title="物理层基础"></a>物理层基础</h3><h4 id="数据通信基础知识"><a href="#数据通信基础知识" class="headerlink" title="数据通信基础知识"></a>数据通信基础知识</h4><blockquote><p>物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 </p></blockquote><p><strong>物理层主要任务</strong>：确定与传输媒体接口有关的一些特性——定义标准。</p><ol><li>机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况。</li><li>电气特性：规定传输二进制位时，线路上信号的电眼范围、阻抗匹配、传输速率和距离限制等。</li><li>功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。</li><li>规程特性：定义各条物理线路的工作规程和时序关系。</li></ol><p><img src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.png" alt="典型数据通信模型"></p><p><strong>数据通信相关术语</strong></p><p>通信的目的是传递消息。</p><p><strong>数据</strong>：传送信息的实体，通常是有意义的符号序列。</p><p><strong>信号</strong>：数据的电器&#x2F;电磁的表现，是数据在传输过程中的存在形式。数字信号：代表消息的参数取值是离散的。模拟信号：代表消息的参数取值是连续的。</p><p><strong>信源</strong>：产生和发送数据的源头。</p><p><strong>信宿</strong>：接收数据的终点。</p><p><strong>信道</strong>：信号的传输媒介，一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。<br>信道按传输信号可分为传送模拟信号的模拟信道和传送数字信号的数字信道。按传输介质可分为无线信道和有线信道。</p><p><strong>三种通信方式</strong></p><p>从通信双发信息的交互方式看，可以有三种基本方式：</p><ol><li>单工通信：只有一个方向的通信而没有反方向的交互，仅需要一条信道。</li><li>半双工通信：通信的双方都可以发送或接受信息，但任何一方都不能同时发送和接收，需要两条信道。</li><li>全双工通信：通信双方可以同时发送和接收信息，也需要两条信道。</li></ol><p><strong>两种数据传输方式</strong></p><p>串行传输：速度慢，费用低，适合远距离</p><p>并行传输：速度快，费用高，适合近距离（常用语计算机内部数据传输）</p><h4 id="码元、波特、速率、带宽"><a href="#码元、波特、速率、带宽" class="headerlink" title="码元、波特、速率、带宽"></a>码元、波特、速率、带宽</h4><p><strong>码元</strong>是指一个固定时长的信号波形(数字脉冲)，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为K进制码元，而该时长称为码元宽度。当码元的离散状态有M个时(M大于2)，此时码元为M进制码元。<br><strong>1码元可以携带多个比特的信息量</strong>。例如，在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态。</p><p><strong>速率</strong>也叫数据率，是指数据的传输速率，表示单位时间内传输的数据量。可以用<strong>码元传输速率</strong>和<strong>信息传输速率</strong>表示。</p><ol><li>码元传输速率：别名码元速率、波形速率、调制速率、符号速率等，他表示单位时间内数字通信系统所传输的码元个数（也可称为脉冲个数或信号变化的次数），<br> 单位是<strong>波特（Baud）</strong>。1波特表述数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关。（1s传输多少个码元）</li><li>信息传输速率：别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数（即比特数），单位是比特&#x2F;秒（b&#x2F;s）。(1s传输 多少个比特)</li></ol><p>关系：若一个码元携带n bit的信息量，则M Baud的码元传输速率多对应的信息传输速率为M*n bit&#x2F;s。</p><p><strong>带宽</strong>表示在单位时间内从网络中的某一点到另一点所能通过的<strong>最高数据率</strong>，通常用来表示网络的通信线路所能传输数据的能力。单位是b&#x2F;s。</p><p><strong>习题：</strong></p><p>某一数字通信系统传输的是四进制码元，4s传输了8000个码元，求系统的码元传输速率是多少？信息传输速率是多少？若另一个通信系统传输的是十六进制码元，6s传输了7200个码元，<br>求它的码元传输速率是多少？信息传输速率是多少？并指出那个系统传输速率快？</p><p><strong>解：</strong></p><p>四进制码元系统：</p><p>码元传输速率：8000&#x2F;4&#x3D;2000 Baud，信息传输速率：2000*log(2)4&#x3D;4000 b&#x2F;s</p><p>十六进制码元系统：</p><p>码元传输速率：7200&#x2F;6&#x3D;1200 Baud，信息传输速率：1200*log(2)16&#x3D;4800 b&#x2F;s</p><p>因为系统传输的是比特流，通常比较信息传输速率，所以十六进制系统下传输速率更快。同时，如果用该系统去传输四进制码元，会有更高的码元传输速率。</p><h4 id="奈氏准则和香农定理"><a href="#奈氏准则和香农定理" class="headerlink" title="奈氏准则和香农定理"></a>奈氏准则和香农定理</h4><p>奈氏准则：在理想低通（无噪声，带宽受限）天渐狭，为了避免马健串扰，极限码元传输速率2W Baud，W是信道带宽，单位是Hz。</p><p>理想低通信道下的极限数据传输率&#x3D;2Wlog(2)V b&#x2F;s</p><blockquote><p>W 为带宽（Hz），V 为集中码元&#x2F;码元的离散电平数目</p></blockquote><ol><li>在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能。</li><li>信道的频率越宽（即能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输。</li><li>奈氏准则给出了码元传输速率的限制，但没有对信息传输速率给出限制。</li><li>由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特信息量，这就需要采用多元制的调制方法。</li></ol><p>香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</p><p>信道的极限数据传输速率&#x3D;Wlog(2)(1+S&#x2F;N) b&#x2F;s</p><blockquote><p>W 带宽Hz，S&#x2F;N 信噪比，S是信道所传信号的平均功率，N是信道内的高斯噪声功率。</p></blockquote><h3 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h3><h4 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h4><p>对信号进行再生和还原，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的功能。</p><p>中继器的两端：</p><p>两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互联，且两个网段速率要相同。</p><p>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适合于网段的数据。</p><p>两端可连相同媒体，也可连不同媒体。</p><p>中继器两端的网段一定要是同一个协议。</p><h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><p>对信号进行再生放大转发，对衰减的信号进行放大，接着转发到其它所有(除输入端口外)处于工作状态的端口上，以增加信号传输的距离，延长网络的长度。不具备信号的定向传送能力，是一个共享式设备。</p><h2 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="数据链路层功能概述"><a href="#数据链路层功能概述" class="headerlink" title="数据链路层功能概述"></a>数据链路层功能概述</h3><p><strong>结点</strong>：主机、路由器</p><p><strong>链路</strong>：网路中两个结点之间的物理通道 ，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无限链路。</p><p><strong>数据链路</strong>：网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路。</p><p><strong>帧</strong>：链路层的协议数据单元，封装网络层数据报。</p><blockquote><p>数据链路层在物理层提供服务的基础上想网络层提供服务，其最基本的服务是将源自网络层来的数据可靠的传输到相邻结点的目标机网络层。<br>其主要作用是<strong>加强物理层传输原始化比特流的功能</strong>，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p></blockquote><p>功能:</p><ol><li>为网络层提供服务。(无确认无连接服务，有确认无连接服务，有确认面向连接服务。)</li><li>链路管理，即连接的建立、维持、释放。（用于面向连接的服务）</li><li>组帧</li><li>流量控制。限制发送发</li><li>差错控制（帧错&#x2F;位错）。</li></ol><h3 id="封装成帧和透明传输"><a href="#封装成帧和透明传输" class="headerlink" title="封装成帧和透明传输"></a>封装成帧和透明传输</h3><p><strong>封装成帧</strong>就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，<br>从收到的比特流中识别帧的开始和结束。</p><p>首部和尾部包含许多的控制信息，他们的一个重要作用：<strong>帧定界</strong>（确定帧的界限）</p><p>帧同步：接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。</p><p>组帧的四种方法： 1.字符计数法; 2.字符(节)填充法；3.零比特填充法；4.违规编码法。</p><p><img src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.png" alt="组装成帧"></p><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><blockquote><p>指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就”看不见”有什么妨碍<br>数据传输的东西。当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，<br>使接收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的。</p></blockquote><p><strong>字符计数法</strong></p><p>帧首部使用一个计数字段（第一个字节，八位）来标明帧内字符数。</p><p><img src="http://1.117.162.142:9000/blog/%E5%AD%97%E7%AC%A6%E8%AE%A1%E6%95%B0%E6%B3%95.png" alt="字符计数法"></p><p>缺点：如果第一个字节出错，将导致后续所有帧全部出错，发送和接收方的数据就会混乱。</p><p><strong>字符填充法</strong></p><p><img src="http://1.117.162.142:9000/blog/%E5%AD%97%E7%AC%A6%E5%A1%AB%E5%85%85%E6%B3%95.png" alt="字符填充法"></p><p>如果在传输的每帧里面的原始数据里面存在和帧头或者帧尾相同的比特流时，接收法就会错误的处理数据。<br>所以在原始数据中出现帧头或帧尾的地方前面填充字符（遇到和填充字符相同的地方也需要在前面填充字节），<br>告诉接收方，接收时不需要管后面的内容，直到遇到真正的帧尾为止。</p><p><strong>零比特填充法</strong></p><p><img src="http://1.117.162.142:9000/blog/%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85%E6%B3%95.png" alt="零比特填充法"></p><p>操作：</p><p><img src="http://1.117.162.142:9000/blog/%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85%E6%B3%951.png"></p><ol><li>在发送端，扫描整个信息字段，只要连续5个1，就立即填入1个0。</li><li>再接收端收到一个帧时，先找到标志字段确定边界，在用硬件对比特流进行扫描。发现5个连续1时，删除后面的0。</li></ol><p><strong>优点：保证了透明传输，在传送的比特流中可以传送任意比特组合，而不会引起对帧边界的判断错误。</strong></p><p><strong>违规编码法</strong></p><p><img src="http://1.117.162.142:9000/blog/%E8%BF%9D%E8%A7%84%E7%BC%96%E7%A0%81%E6%B3%95.png" alt="违规编码法"></p><p>曼彻斯特编码中可以用高-低电平表示1，用低-高电平表示0，所以在传输数据时，源数据不会出现高-高或低-低电平。<br>可以用”高-高”，”低-低”来定界帧的起始和终止。</p><blockquote><p>由于字节计数法中Count字段的脆弱性（其值若有差错将导致灾难性的后果）及字符填充法实现上的复杂性和不兼容性，<br>目前较普遍使用的帧同步法是<strong>零比特填充</strong>和<strong>违规编码法</strong>。</p></blockquote><h3 id="差错控制（检错编码、纠错编码）"><a href="#差错控制（检错编码、纠错编码）" class="headerlink" title="差错控制（检错编码、纠错编码）"></a>差错控制（检错编码、纠错编码）</h3><h4 id="检错编码——奇偶检验码"><a href="#检错编码——奇偶检验码" class="headerlink" title="检错编码——奇偶检验码"></a>检错编码——奇偶检验码</h4><blockquote><p>奇偶校验码包含n-1为信息元和1位校验元。如果是奇校验：信息元+校验元中1的个数为奇数个，<br>如果是偶校验：信息元+校验元中1的个数是偶数个。</p></blockquote><p>奇偶校验码特点：</p><p>只能检查出奇数个比特错误，交错能力为50%。</p><p>当数据中有偶数个位发生0-1的置换，就不能检查出来。</p><h4 id="检错编码——CRC循环冗余码"><a href="#检错编码——CRC循环冗余码" class="headerlink" title="检错编码——CRC循环冗余码"></a>检错编码——CRC循环冗余码</h4><p>采用CRC循环冗余码时，最终发送的数据为源数据+帧校验序列FCS(冗余码)</p><p>冗余码的计算：</p><ol><li>加0。假设生成多项式G(x)的阶为r，则加r个0。</li><li>模2除法。数据加0后除以多项式，余数为冗余码FCS——CRC检验码的比特序列。</li></ol><p>Tips：多项式为N位，阶位N-1。</p><p><img src="http://1.117.162.142:9000/blog/%E8%AE%A1%E7%AE%97FCS.png"></p><p>接收端检错过程：</p><p>把收到的每一帧都除以相同的除数，然后检查得到的余数R。</p><ol><li>余数为0，判定这个帧没有差错，则接收</li><li>余数不为0，判定这个帧有差错（无法确定到位），丢弃。</li></ol><p>FCS的生成以及接收端CRC检验都是由硬件实现，处理很迅速，因此不会延误数据的传输。</p><p>在数据链路层仅仅使用循环冗余检验CRC差错检测技术，只能做到对帧的无差错接收，<br>即”凡事接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生<br>差错”。接收端丢弃的帧虽然曾收到了，但是最终还是因为有差错被丢弃。**”凡是接收端数据链路层接收的帧均可以以非常<br>接近1的概率认为无差错”。**</p><h4 id="纠错编码——海明码（汉明码）"><a href="#纠错编码——海明码（汉明码）" class="headerlink" title="纠错编码——海明码（汉明码）"></a>纠错编码——海明码（汉明码）</h4><blockquote><p>海明码: 发现双比特错，纠正单比特错。</p></blockquote><p>海明码的工作流程：</p><ol><li>确定校验码位数r</li></ol><p>海明不等式：2^r &gt;&#x3D; k+r+1   r为冗余信息位，k为信息位。</p><p>eg：要发送的数据：D&#x3D;101101</p><p>数据的位数k&#x3D;6，满足不等式的最小r为4，也就是D&#x3D;101101的海明码应该有6+4&#x3D;10位，其中源数据6位，校验码4位。</p><ol start="2"><li>确定校验码和数据的位置</li></ol><p><img src="http://1.117.162.142:9000/blog/%E7%A1%AE%E5%AE%9A%E6%A0%A1%E9%AA%8C%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%8D%E7%BD%AE.png" alt="确定校验码和数据的位置"></p><ol start="3"><li>求出校验码的值</li></ol><p><img src="http://1.117.162.142:9000/blog/%E6%B5%B7%E6%98%8E%E7%A0%811.png" alt="求出校验码的值"></p><ol start="4"><li>检错并纠错</li></ol><p><img src="http://1.117.162.142:9000/blog/%E6%B5%B7%E6%98%8E%E7%A0%812.png" alt="检错并纠错"></p><h3 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h3><blockquote><p>较高的发送速度和较低的接收能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。 </p></blockquote><p>数据链路层的流量控制是点对点的，而传输层的流量控制是端对端的。</p><p>数据链路层流量控制手段：接收方收不下就不回复确认。</p><p>传输层流量控制手段：接收端给发送端一个窗口公告。</p><h4 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h4><p><img src="http://1.117.162.142:9000/blog/%E5%81%9C%E6%AD%A2-%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE.png" alt="停止-等待协议"></p><p>每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧。</p><ol><li>为什么要有停止-等待协议？</li></ol><p>除了比特出差错，底层信道还会出现丢包问题。为了实现流量控制。</p><ol start="2"><li>研究停等协议的前提？</li></ol><p>因为是在讨论可靠传输的原理，所以并不考虑数据是在哪一个层次上传送的。<br>“停止-等待”就是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。</p><blockquote><p>丢包：物理线路故障、设备故障、病毒攻击、路由信息错误等原因，会导致数据包的丢失。</p></blockquote><p><strong>停等协议——无差错情况</strong></p><p><img src="http://1.117.162.142:9000/blog/%E6%97%A0%E5%B7%AE%E9%94%99%E6%83%85%E5%86%B5.png" alt="无差错情况"></p><p><strong>停等协议——有差错情况</strong></p><p>数据帧丢失或检测到帧出错</p><p><img src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E5%B8%A7%E4%B8%A2%E5%A4%B1.png" alt="数据帧丢失"></p><p>ack丢失</p><p><img src="http://1.117.162.142:9000/blog/ack%E4%B8%A2%E5%A4%B1.png" alt="ack丢失"></p><p>ack迟到</p><p><img src="http://1.117.162.142:9000/blog/ack%E8%BF%9F%E5%88%B0.png" alt="ack迟到"></p><p><strong>信道利用率</strong></p><p>发送发在一个发送周期内，有效的发送数据所需要的时间占整个发送周期的比率。</p><p>信道利用率&#x3D;(L&#x2F;C)&#x2F;T</p><blockquote><p>L：T内发送L比特数据。C：发送方数据传输率。T：发送周期，从开始发送数据，到接收到第一个确认帧为止。</p></blockquote><p><strong>信道吞吐率&#x3D;信道利用率*发送发的发送速率</strong></p><h4 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h4><h5 id="后退N帧协议（GBN）"><a href="#后退N帧协议（GBN）" class="headerlink" title="后退N帧协议（GBN）"></a>后退N帧协议（GBN）</h5><p>GBN发送发必须响应的三件事：</p><ol><li>上层的调用</li></ol><p>上层要发送数据时，发送方先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送；如果窗口已满<br>，发送方只需将数据返回给上层，暗示上层窗口已满。上层等一会再发送。（实际实现中，发送发可以缓存这些<br>数据，窗口不满时再发送帧）。</p><ol start="2"><li>收到了一个ACK</li></ol><p>GBN协议中，对n号帧的确认采用累计确认的方式，标明接收方已经收到n号帧和它之前的全部帧。</p><ol start="3"><li>超时事件</li></ol><p>协议的名字为后退N帧&#x2F;回退N帧，来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样，<br>定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已发送但未被确认的帧。</p><p>GBN接收方要做的事：</p><p>如果正确收到n号帧，并且按序，那么接收方为n帧发送一个ack，并将该帧中的数据部分交付给上层。</p><p>其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK。接收方无需缓存任何失序帧，只需要维护一个信息：<br>expectedseqnum(下一个按序接收的帧序号)。</p><p>运行中的GBN:</p><p><img src="http://1.117.162.142:9000/blog/%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84GBN.png" alt="运行中的GBN"></p><p>优点：因连续发送数据帧而提高了信道利用率</p><p>缺点：在重传时必须把原来已经正确传送的数据帧重传，使传送效率降低。</p><h5 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a>选择重传协议（SR）</h5><p><strong>SR中的滑动窗口机制</strong></p><p><img src="http://1.117.162.142:9000/blog/SR%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6.png" alt="SR滑动窗口机制"></p><p><strong>发送方必须响应的三件事</strong></p><ul><li>上层调用</li></ul><p>从上层收到数据后，SR发送发检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧；<br>否则就像GNB一样，要么将数据缓存，要么返回给上层之后在传输。</p><ul><li>收到一个ACK</li></ul><p>如果收到ACK，加入该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接受。如果该帧序号是窗口<br>的下界(最左边第一个窗口对应的序号)，则窗口想前移动到具有最小序号的未确认帧处。如果窗口移动了<br>并且有序号在窗口内的未发送帧，则发送这些帧。</p><ul><li>超时事件</li></ul><p>每个帧都有自己的定时器，一个超时事件发生后只重传一个帧。</p><p><strong>接收方要做的事</strong></p><p>SR接收方将确认一个正确接受的帧而不管其是否按序。失序的帧将被缓存，并返回给发送方一个该帧<br>的确认帧【收谁确认谁】，直到所有帧(即序号更小的帧)皆被收到为止，这是才可以将一批帧按序交付给<br>上层，然后向前移动滑动窗口。</p><p><strong>运行中的SR</strong></p><p><img src="http://1.117.162.142:9000/blog/%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84SR.png" alt="运行中的SR"></p><p><strong>窗口大小的上限</strong></p><p>发送窗口最好等于接收窗口</p><p>WTMax&#x3D;WRMax&#x3D;2^(n-1)</p><blockquote><p>WTMax 发送窗口，WRMax 接收窗口，n 表示用多少个比特标帧序号。eg：n&#x3D;2，序号就有 0 1 2 3</p></blockquote><h3 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h3><p>点对点链路：两个相邻结点通过一个链路相连，没有第三者。应用：PPP协议，常用语<strong>广域网</strong>。</p><p>广播式链路：所有主机共享通信介质。应用：早起的总线以太网、无线局域网、常用于<strong>局域网</strong>。<br>典型拓扑结构：总线型，星型（逻辑总线型）</p><h4 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h4><blockquote><p>介质访问控制的内容是采取一定的措施，使得两对结点之间的通信不会发生互相干扰的情况。</p></blockquote><p>静态划分信道——信道划分介质访问控制</p><blockquote><p>信道划分介质访问控制：将使用介质的每个设备与来自同一信道上的其它设备的通信隔离开，把时域和频域<br>资源合理地分配给网络上的设备。</p></blockquote><p><strong>频分多路复用 FDM</strong></p><p>用户分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽<br>（频率带宽）资源。</p><p>充分利用传输介质带宽，系统效率提高；由于技术比较成熟，实现也比较容易。</p><p><strong>时分多路复用 TDM</strong></p><p>将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，所有<br>用户轮流占用信道。</p><p><strong>波分多路复用 WDM</strong></p><p>波分多路复用就是光的频分多路复用，在一根光纤中传输多种不同波长（频率）的光信号，由于波长（频率）不同，<br>所以各路光信号互不干扰，最后在用波长分解复用器将各路波长分解出来。</p><p><strong>码分多路复用 CDM</strong></p><p>码分多址（CDMA）是码分复用的一种方式。</p><p>1比特分为多个码片&#x2F;芯片（chip），每一站点被指定一个唯一的m位的芯片序列。发送1时站点发送芯片序列，<br>发送0时发送芯片序列反码（通常把0写成-1）。</p><p>如何不打架：多个站点同时发送数据的时候，要求各个站点芯片序列相互正交。</p><p>如何合并：各路数据在信道中被线性相加。</p><p>如何分离：合并的数据和源站规格化内积。</p><p><strong>动态分配信道——随机访问介质访问控制</strong></p><p>ALOHA协议</p><p>纯ALOHA协议思想：不监听信道，不按时间槽发送，随机重发。如果发生冲突，接收方在就会检测出差错，<br>然后不予确认，发送发在一定时间内收不到就会判断发生冲突。超时后等一随机时间再重传。</p><p>时隙ALOHA协议</p><p>时隙ALOHA协议的思想：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，<br>若发生冲突，则必须等到下一个时间片开始时刻再发送。</p><p>CSMA协议（载波监听多路访问协议）</p><blockquote><p>CS：载波监听，每一个站在发送数据之前都要检测一下总线上是否有其他计算机再发送数据。（当几个站同时在<br>总线上发送数据时，总线上的信号电压摆动值将会增大。当一个站监测到的信号电压摆动值超过一定门限值时，就认为总线上<br>至少有两个站同时再发送数据，标明产生了碰撞，即发生了冲突。）</p></blockquote><blockquote><p>MA：多点接入，表示许多计算机一多点接入的方式连接在一根总线上。</p></blockquote><p><strong>1-坚持CSMA</strong></p><p>坚持指的是对于监听信道忙之后的坚持。</p><p>1-坚持CSMA思想：如果一个主机要发送消息，那么他先监听信道。空闲则直接传输，不必等待。忙则一直监听，知道空闲马上传输。<br>如果有冲突（一段时间内未收到肯定回复），则等待一个随机长的时间再监听，重复上述过程。</p><p>优点：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失。</p><p>缺点：假如有两个或两个以上的站点有数据要发送，冲突就不可避免。</p><p><strong>非坚持CSMA</strong></p><p>非坚持指的是对于监听信道忙之后就不继续监听。</p><p>非坚持CSMA思想：如果一个主机要发送消息，那么他先监听信道。空闲则直接传输，不必等待。忙则等待一个随机的时间之后再进行监听。</p><p>优点：采用随机的重发延迟时间可以肩上冲突发生的可能性。</p><p>缺点：可能存在大家都在延迟等待过程，使得媒体仍可能处于空闲状态，媒体使用率降低。</p><p><strong>p-坚持CAMS</strong></p><p>p-坚持指的是对于监听信道空闲的处理。</p><p>p-坚持CSMA思想：如果一个主机要发送消息，那么他先监听信道。空闲则以p概率直接传输，不必等待；概率1-p等待到下一个时间槽再传输。<br>忙则等待一个随机的时间之后在进行监听。</p><p>优点：既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少媒体空闲时间的这种方案。</p><p>缺点：发生冲突后还是要坚持把数据帧发送完，造成了浪费。</p><p>三种CSMA对比</p><table><thead><tr><th align="center"></th><th align="center">1-坚持CSMA</th><th align="center">非坚持CSMA</th><th align="center">p-坚持CSMA</th></tr></thead><tbody><tr><td align="center">信道空闲</td><td align="center">马上发</td><td align="center">马上发</td><td align="center">p概率马上发，1-p概率等到下一个时隙再发送</td></tr><tr><td align="center">信道忙</td><td align="center">继续坚持监听</td><td align="center">放弃监听，等待一个随机时间再监听</td><td align="center">放弃监听，等待一个随机时间再监听</td></tr></tbody></table><p><strong>动态分配信道——论序访问介质访问控制</strong></p><p>令牌传递协议</p><p>令牌：一个特俗格式的MAC控制帧，不含任何信息。控制信道的使用，确保同一时刻只有一个结点独占信道。每个结点都可以在一定的时间<br>内（令牌持有时间）获得发送数据的权利，比不是无限之地持有令牌。</p><p>缺点：</p><p>存在令牌开销、等待延迟、单点故障</p><blockquote><p>应用于令牌环网（物理星型拓扑，逻辑环形拓扑）<br>采用令牌传送方式的网络常用于负载较重、通信量较大的网络中。</p></blockquote><p><strong>CSMA&#x2F;CA协议</strong>（载波监听多点接入&#x2F;碰撞避免）</p><p>发送数据前，先检测信道是否空闲。</p><p>空闲则发出RTS（request to send），RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息；信道忙则等待。</p><p>接收端收到RTS后，将响应CTS（clear to send）。</p><p>发送端收到CTS后，开始发送数据帧（同时预约信道：发送发告知其他站点自己要传多久数据）。</p><p>接收端收到数据帧后，江永CRC来检验数据是否正确，正确则响应ACK帧。</p><p>发送方收到ACK就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止（采用二进制指数退避算法来确定随机的推迟时间）。</p><h3 id="局域网基本概念和体系结构"><a href="#局域网基本概念和体系结构" class="headerlink" title="局域网基本概念和体系结构"></a>局域网基本概念和体系结构</h3><p>局域网（Local Area Network）：简称LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道。</p><p>特点1：覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</p><p>特点2：使用专门铺设的传输介质（双绞线、同轴电缆）进行联网，数据传输速率高（10Mb&#x2F;s～10Gb&#x2F;s）。</p><p>特点3：通信延迟时间短，误码率低，可靠性较高。</p><p>特点4：各站为平等关系，共享传输信道。</p><p>特点5：多采用分布式控制和广播式通信，能进行广播和组播。</p><p>决定局域网的主要要素为：<strong>网络拓扑</strong>，<strong>传输介质</strong>与<strong>介质访问控制方法</strong>。</p><h4 id="局域网拓扑结构"><a href="#局域网拓扑结构" class="headerlink" title="局域网拓扑结构"></a>局域网拓扑结构</h4><p><strong>星型拓扑</strong></p><p><img src="http://1.117.162.142:9000/blog/%E6%98%9F%E5%9E%8B%E6%8B%93%E6%89%91.png" alt="星型拓扑"></p><p>中心节点是控制中心，任意两个节点间的通信最多只需两步，传输速度快，并且网络构型简单、建网容易、便于控制和管理。但这种网络<br>系统，网络可靠性低，网络共享能力差，有单点故障问题。</p><p><strong>总线型</strong></p><p><img src="http://1.117.162.142:9000/blog/%E6%80%BB%E7%BA%BF%E5%9E%8B%E6%8B%93%E6%89%91.png" alt="总线型拓扑"></p><p>网络可靠性高、网络节点间响应速度快、共享资源能力强、设备投入量少、成本低、安装使用方便，当某个工作站节点出现故障时，对整个<br>网络系统影响小。</p><p><strong>环型拓扑</strong></p><p><img src="http://1.117.162.142:9000/blog/%E7%8E%AF%E5%9E%8B%E6%8B%93%E6%89%91.png" alt="环形拓扑"></p><p>系统中通信设备和线路比较节省。有单点故障问题；由于环路是封闭的，所以不便于扩充，系统响应延时长，且信息传输效率相对较低。</p><p><strong>树型拓扑</strong></p><p><img src="http://1.117.162.142:9000/blog/%E6%A0%91%E5%9E%8B%E6%8B%93%E6%89%91.png" alt="树型拓扑"></p><p>易于拓展，易于隔离故障，也容易有单点故障。</p><h4 id="局域网的分类"><a href="#局域网的分类" class="headerlink" title="局域网的分类"></a>局域网的分类</h4><ol><li>以太网：以太网是应用最为广泛的局域网，包括标准以太网（10Mbps）、快速以太网（100Mbps）、千兆以太网（1000Mbps）和10G以太网，<br> 他们都符合IEEE 802.3系列标准规范。逻辑拓扑总线型，物理拓扑是星型或拓展星型。使用CSMA&#x2F;CD。</li><li>令牌环网：物理上采用了星型拓扑结构，逻辑上是环形拓扑结构。已是”明日黄花”。</li><li>FDDI（Fiber Distributed Data Interface）：物理上采用了双环形拓扑结构，逻辑上是环形拓扑结构。</li><li>ATM（Asynchronous Transfer Mode）：较新型的单元交换技术，使用53字节固定长度的单元进行交换。</li><li>无线局域网（Wireless Local Area Network；WLAN）：采用IEEE 802.11标准。</li></ol><blockquote><p>IEEE 802系列标准是IEEE 802 LAN&#x2F;MAN标准委员会制定的局域网、城域网技术标准（1980年2月成立）。其中最广泛使用的有以太网、令牌环、<br>无线局域网等。这一系列标准中的每一个子标准都由委员会中的一个专门工作组负责。</p></blockquote><h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><p>由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带总线局域网规范，是当今现有局域网采用的最通用的通信协议标准。<br>以太网使用CSMA&#x2F;CD（载波监听多路访问及冲突检测）技术。</p><p>以太网在局域网各种技术中占统治性地位：</p><ol><li>造价低廉</li><li>是应用最广泛的局域网技术；</li><li>比令牌环网、ATM网便宜，简单；</li><li>满足网络速率要求：10Mb&#x2F;s～10Gb&#x2F;s。</li></ol><p>计算机与外界有局域网的连接是通过通信适配器的。</p><p><img src="http://1.117.162.142:9000/blog/%E9%80%9A%E4%BF%A1%E9%80%82%E9%85%8D%E5%99%A8.png" alt="通信适配器"></p><p>在局域网中，硬件地址又称为物理地址，或MAC地址。【实际上是标识符】</p><blockquote><p>MAC地址：每个适配器又一个全球唯一的48位2进制地址，前24位代表厂家（由IEEE规定），后24位厂家自己制定。常用6个16进制数表述，<br>如02-60-8c-e4-b1-21。</p></blockquote><p><img src="http://1.117.162.142:9000/blog/MAC%E5%B8%A7.png" alt="MAC帧"></p><h4 id="CSMA-x2F-CD协议（载波监听多点接入-x2F-碰撞检测）"><a href="#CSMA-x2F-CD协议（载波监听多点接入-x2F-碰撞检测）" class="headerlink" title="CSMA&#x2F;CD协议（载波监听多点接入&#x2F;碰撞检测）"></a>CSMA&#x2F;CD协议（载波监听多点接入&#x2F;碰撞检测）</h4><blockquote><p>CS：载波监听，每一个站在发送数据之前以及发送数据时都要检测一下总线上是否有其他计算机在发送数据。</p></blockquote><blockquote><p>MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。（总线型网络）</p></blockquote><blockquote><p>CD：碰撞检测（冲突检测），”边发送边监听”，适配器发送数据边检测信道上信号的变化情况，以便判断自己在发送数据时其它站是否也在发送数据。</p></blockquote><p>确定碰撞后的重传时机（截断二进制指数归避算法）：</p><ol><li>确定基本退避（推迟）时间为争用期2𝞃。</li><li>定义参数k，它等于重传次数，但k不超过10，即k&#x3D;min[重传次数，10]。当重传次数不超过10时，k等于重传次数；当重传次数大于10时，<br> k就不再增大而一直等于10。</li><li>从离散的整数集合[0,1,2^k-1]中随机取出一个数r，重传所需要退避的时间就是r倍的基本退避时间，即2r𝞃。</li><li>当重传达16次仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错。<br> 第一次重传，k&#x3D;1，r从{0,1}选；重传推迟时间为0或2𝞃，在这两个时间中随机选一个；若再次碰撞，则在第二次重传时，<br> k&#x3D;2，r从{0，1，2，3}选；重传推迟时间为0或2𝞃或4𝞃或6𝞃，在这四个时间中随机选一个；若再次碰撞，则第三次重传时，k&#x3D;3，r从{0,1,2,3,4,5,6,7}选……</li></ol><p>最小帧长</p><p>真的传输时延至少要两倍于信号在总线中的传播时延。</p><p>帧长（bit）&#x2F;数据传输速率≥2𝞃</p><p>最小帧长&#x3D;总线传播时延×数据传输速率×2，也就是2𝞃 × 数据传输速率</p><h3 id="PPP协议和HDLC协议"><a href="#PPP协议和HDLC协议" class="headerlink" title="PPP协议和HDLC协议"></a>PPP协议和HDLC协议</h3><p><strong>PPP（point to point）</strong></p><p>点对点协议是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都是用ppp协议。只支持全双工链路。</p><p>ppp协议帧格式</p><p><img src="http://1.117.162.142:9000/blog/ppp%E5%8D%8F%E8%AE%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="ppp协议帧格式"></p><p><strong>HDLC协议（高级数据链路控制High——Level Data Link Control）</strong></p><p>高级数据链路控制是一个在同步网上传输数据、面向比特的数据链路高层协议，它是由国际标准化组织ISO根据IBM<br>公司的SDLC（SynchronousData Link Control）协议扩展开发而成的。数据报文可透明传输，用于实现透明传输的”0比特插入法”易于硬件实现。</p><p>HDLC帧格式</p><p><img src="http://1.117.162.142:9000/blog/HDLC%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="HDLC帧格式"></p><ol><li>信息帧（I）第1为为0，用来传输数据信息，或使用捎带技术对数据逆行确认；</li><li>监督帧（S）10，用于流量控制和差错控制，执行对信息帧的确认、请求重发和请求暂停发送等功能</li><li>无编号帧（U）11，用于提供对链路的建立、拆除等多种控制功能。</li></ol><p><strong>ppp和HDLC比较</strong>：</p><ul><li>都支持全双工链路</li><li>都可以实现透明传输</li><li>都可以实现差错检测，但不纠正差错</li></ul><table><thead><tr><th align="center">PPP协议</th><th align="center">面向字节</th><th align="center">2B协议字段</th><th align="center">无序号和确认机制</th><th align="center">不可靠</th></tr></thead><tbody><tr><td align="center">HDLC协议</td><td align="center">面向比特</td><td align="center">没有</td><td align="center">有编号和确认</td><td align="center">可靠</td></tr></tbody></table><h2 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h2><blockquote><p>主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报。</p></blockquote><p>功能：</p><ol><li>路由选择与分组转发</li><li>异构网络互联</li><li>拥塞控制</li></ol><h3 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h3><p><strong>电路交换</strong></p><p>建立连接（呼叫&#x2F;电路建立）-&gt; 通信 -&gt; 释放连接（拆除电路）</p><p>优点：</p><ul><li>通信时延小</li><li>有序传输</li><li>没有冲突（独占资源）</li><li>实时性强</li></ul><p>缺点：</p><ul><li>建立连接时间长</li><li>线路独占、使用效率低</li><li>灵活性差</li><li>无差错控制能力</li></ul><p><strong>报文交换</strong></p><blockquote><p>报文：源应用发送的信息整体。</p></blockquote><p>优点：</p><ul><li>无需建立连接</li><li>存储转发，动态分配线路</li><li>线路可靠性较高</li><li>线路利用率较高</li><li>多目标服务</li></ul><p>缺点：</p><ul><li>有存储转发时延</li><li>报文大小不定，需要网络节点有较大缓存空间</li></ul><p><strong>分组交换</strong></p><blockquote><p>分组：把大的数据块分割成小的数据块</p></blockquote><p>优点：</p><ul><li>无需建立连接</li><li>存储转发，动态分配线路</li><li>线路可靠性较高</li><li>线路利用率较高</li><li>相对于报文交换，存储管理更容易</li></ul><p>缺点：</p><ul><li>有存储转发时延</li><li>需要传输额外的信息量</li><li>乱序到目的主机时，要对分组排序重组</li></ul><p><img src="http://1.117.162.142:9000/blog/%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F.png" alt="三种交换方式"></p><ol><li>报文交换和分组交换采用存储转发。</li><li>传送数据量大，且传送时间远大于呼叫时，选择电路交换。电路交换传输时延最小。</li><li>从信道利用率看，报文交换和分组交换由于电路交换，其中分组交换时延更小。</li></ol><p><strong>数据报方式</strong></p><p>为网络层提供无连接服务。</p><blockquote><p>不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</p></blockquote><p><strong>虚电路方式</strong></p><p>为网络层提供连接服务。</p><blockquote><p>首先为分组的传输确定传输路径（建立连接），然后沿该路径（连接）传输系列分组，系列分组传输路径相同，传输结束后拆除连接。</p></blockquote><p><img src="http://1.117.162.142:9000/blog/%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%92%8C%E8%99%9A%E7%94%B5%E8%B7%AF.png" alt="数据报和虚电路"></p><h3 id="路由算法与路由协议概述"><a href="#路由算法与路由协议概述" class="headerlink" title="路由算法与路由协议概述"></a>路由算法与路由协议概述</h3><ul><li>静态路由算法（非自适应路由算法）</li></ul><p>管理员手工配置路由信息，简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和较小的商业网络。<br>缺点是路由更新慢，不适用于大型网络。</p><ul><li>动态路由算法（自适应路由算法）</li></ul><p>路由器间彼此交换信息，按照路由算法优化出路由表项。路由更新快，适用于大型网络，即使响应链路费用或网络拓扑变化。缺点：<br>算法复杂，增加网络负担。</p><p><strong>分层次的路由选择协议</strong></p><p>自治系统AS：在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量已确定分组在该AS内的路由，<br>同时还是用一种AS之间的路由协议已确定在AS之间的路由。一个AS内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器<br>在本自治系统内都必须连通。</p><h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><p><img src="http://1.117.162.142:9000/blog/ip%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="IP数据报格式"></p><ul><li>版本：IPv4&#x2F;IPv6</li><li>首部长度：单位是4B，最小为5。</li><li>区分服务：指示期望获得哪种类型的服务。</li><li>总长度：首部+数据，单位是1B。</li><li>标志：只有2为有意义 x _ _<ul><li>中间位DF(Dont Fragment)：DF&#x3D;1，禁止分片；DF&#x3D;0，允许分片</li><li>最低位MF(More Fragment)：MF&#x3D;1，后面”还有分片”；MF&#x3D;0，代表最后一片&#x2F;没分片。</li></ul></li><li>生存时间（TTL）：IP分组的保质期。经过一个路由器-1，变成0则丢弃。</li><li>协议：数据部分的协议。</li><li>首部检验和：只检验首部。</li><li>可选字段：0～40B，用来支持排错、测量以及安全措施。</li><li>填充：全0，把首部补成4B的整数倍。</li></ul><h3 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h3><p> IP地址:全世界唯一的32位&#x2F;4字符标识符,表示路由器主机的接口。</p><p>IP地址::&#x3D;{&lt;网络号&gt;&lt;主机号&gt;}</p><p>eg：11011111 00000001 00000001 00000001 &#x3D; 223.1.1.1</p><p>分类的IP地址：</p><p><img src="http://1.117.162.142:9000/blog/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png" alt="IP地址分类"></p><table><thead><tr><th align="center">网络类别</th><th align="center">最大可用网络数</th><th align="center">第一个可用的网络号</th><th align="center">最后一个可用的网络号</th><th align="center">每个网络中的最大主机数</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">2<sup>7</sup>-2</td><td align="center">1</td><td align="center">126</td><td align="center">2<sup>24</sup>-2</td></tr><tr><td align="center">B</td><td align="center">2<sup>14</sup>-1</td><td align="center">128.1</td><td align="center">191.255</td><td align="center">2<sup>16</sup>-2</td></tr><tr><td align="center">C</td><td align="center">2<sup>21</sup>-1</td><td align="center">192.0.1</td><td align="center">223.255.255</td><td align="center">2<sup>8</sup>-2</td></tr></tbody></table><p>特殊IP地址：</p><table><thead><tr><th align="center">NetID 网络号</th><th align="center">HostID 主机号</th><th align="center">作为IP分组源地址</th><th align="center">作为IP分组目的地址</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">全0</td><td align="center">全0</td><td align="center">可以</td><td align="center">不可以</td><td align="center">本网范围内表示主机，路由表中用于表示默认路由(表示整个Internet网络)</td></tr><tr><td align="center">全0</td><td align="center">特定值</td><td align="center">不可以</td><td align="center">可以</td><td align="center">表示本网内某个特定主机</td></tr><tr><td align="center">全1</td><td align="center">全1</td><td align="center">不可以</td><td align="center">可以</td><td align="center">本网广播地址(路由器不转发)</td></tr><tr><td align="center">特定值</td><td align="center">全0</td><td align="center">不可以</td><td align="center">不可以</td><td align="center">网络地址，表示一个网络</td></tr><tr><td align="center">特定值</td><td align="center">全1</td><td align="center">不可以</td><td align="center">可以</td><td align="center">直接广播地址，对特定网络上的所有主机进行广播</td></tr><tr><td align="center">127</td><td align="center">任何数(非全0&#x2F;1)</td><td align="center">可以</td><td align="center">可以</td><td align="center">用于本地软件环回测试，称为环回地址</td></tr></tbody></table><p>私有IP地址：</p><table><thead><tr><th align="center">地址类别</th><th align="center">地址范围</th><th align="center">网段个数</th></tr></thead><tbody><tr><td align="center">A类</td><td align="center">10.0.0.0~10.255.255.255</td><td align="center">1</td></tr><tr><td align="center">B类</td><td align="center">172.16.0.0~172.31.255.255</td><td align="center">16</td></tr><tr><td align="center">C类</td><td align="center">192.168.0.0~192.168.255.255</td><td align="center">256</td></tr></tbody></table><p>ps：路由器对目的地址是私有IP地址的数据报一律不进行转发。</p><h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3><p> 网络地址转换NAT(Network Address Translation): 在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址。</p><p><img src="http://1.117.162.142:9000/blog/nat.png" alt="NAT"></p><p>假如主机A要发送消息给主机B，A在封装数据报时，源地址和端口就是主机A的，目的地址是主机B的地址，当数据报到达NAT路由器时，会将数据报里的源地址和端口号修改为NAT路由器自己的地址和端口号，这个数据报此时就能够在因特网中进行传输了。</p><p>当主机B给主机C发送消息，主机B封装数据报时，目的地址和端口就是NAT路由器的地址和端口号，当数据报到达路由器时，会按照NAT转换表将目的地址和端口号替换为主机C的。</p><h3 id="子网划分和子网掩码"><a href="#子网划分和子网掩码" class="headerlink" title="子网划分和子网掩码"></a>子网划分和子网掩码</h3><p><img src="http://1.117.162.142:9000/blog/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86.png" alt="子网划分"></p><p>子网掩码：网络号（子网号）全1，主机号全零</p><h3 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h3><ul><li>消除了传统的A类、B类和C类地址以及划分子网的概念。</li></ul><p><img src="http://1.117.162.142:9000/blog/CIDR.png" alt="CIDR"></p><p>CIDR记法：IP地址后加上“&#x2F;”，然后写上网络前缀（可以任意长度）的位数。eg：128.14.32.0&#x2F;20</p><ul><li>融合子网掩码，方便子网划分。</li></ul><p>CIDR把网络前缀都相同的连续的IP地址组成一个”CIDR地址块“。</p><p>128.14.35.7&#x2F;20是某CIDR地址块中的一个地址</p><p>​    二进制：10000000 00001110 00100011 00000111</p><p>最小地址：10000000 00001110 00100000 00000000</p><p>最大地址：10000000 00001110 00101111 11111111</p><p>​    地址块：128.14.32.0&#x2F;20          ”&#x2F;20地址块“ </p><p>子网掩码：11111111 11111111 11110000 00000000</p><h4 id="构成超网"><a href="#构成超网" class="headerlink" title="构成超网"></a><strong>构成超网</strong></h4><p>将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合。</p><p>方法：将网络前缀缩短。</p><p>eg：网络1：206.1.0.0&#x2F;17；网络2：206.1.128.0&#x2F;17。将两个网络聚合成一个网络。</p><p>网络1:</p><p>二进制：11001101 00000001 00000000 00000000</p><p>掩    码：11111111 11111110 00000000 00000000</p><p>网络2:</p><p>二进制：11001101 00000001 10000000 00000000</p><p>掩    码：11111111 11111110 00000000 00000000</p><p>聚合之后的网络：206.1.0.0&#x2F;16。</p><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>由于在实际网络的链路上传送数据帧时，最终必须使用mac地址。</p><p>ARP协议：完成主机或路由器IP地址到MAC地址的映射。</p><p>ARP协议使用过程：</p><p>检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求，同一局域网中所有主机都能收到该请求。目的主机收到请求后就会像源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存（10-20min更新一次）。</p><p>ARP协议4种典型情况：</p><ol><li>主机A发给本网络上的主机B：用ARP找到主机B的硬件地址；</li><li>主机A发给另一网络上的主机B：用ARP找到本网络上一个路由器（网关）的硬件地址；</li><li>路由器发给本网络的主机A：用ARP找到主机A的硬件地址；</li><li>路由器发给另一网络的主机B：用ARP找到本网络上的一个路由器的 硬件地址。</li></ol><p><strong>ARP协议自动进行</strong></p><h3 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3><p>动态主机配置协议DHCP是应用层协议，使用客户&#x2F;服务器方式，客户端和服务端通过广播方式进行交互，基于UDP。DHCP提供即插即用联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址，允许地址重用，支持移动用户加入网络，支持在用地址续租。</p><ol><li>主机广播DHCP发现报文（试图找到网络中的服务器，服务器获得一个IP地址）</li><li>DHCP服务器广播DHCP提供报文（服务器拟分配给主机一个IP地址及相关配置，先到先得）</li><li>主机广播DHCP请求报文（主机想服务器请求提供IP地址）</li><li>DHCP服务器广播DHCP确认报文（正式将IP地址分配给主机）</li></ol><h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p><img src="http://1.117.162.142:9000/blog/%E7%BD%91%E7%BB%9C%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AEICMP.png" alt="网络控制报文协议ICMP"></p><p><strong>ICMP差错报告报文</strong>：</p><ol><li>终点不可达：当路由器或主机不能交付数据报时就像源点发送终点不可达报文。</li><li>源点抑制：当路由器或主机由于拥塞而迭起数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。</li><li>时间超过：当路由器收到生存时间TTL&#x3D;0的数据报时，除丢弃该数据外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li><li>参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。</li><li>改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</li></ol><p><strong>ICMP差错报告报文数据字段</strong></p><p><img src="http://1.117.162.142:9000/blog/ICMP%E5%B7%AE%E9%94%99%E6%8A%A5%E5%91%8A%E6%8A%A5%E6%96%87%E6%95%B0%E6%8D%AE%E5%AD%97%E6%AE%B5.png" alt="ICMP差错报告报文数据字段"></p><p><strong>不应发送ICMP差错报文的情况</strong>：</p><ol><li>对ICMP差错报告报文不在发送ICMP差错报告报文。</li><li>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。</li><li>对具有组播地址的数据报都不发送ICMP差错报告报文。</li><li>对具有特俗地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文。</li></ol><p><strong>ICMP询问报文</strong>：</p><ol><li>回送请求和回答报文：主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。测试目的站是否可达以及了解其相关状态。</li><li>时间戳请求和回答报文：请某个主机或路由器回答当前的日期和时间。用来进行时钟同步和测量时间。</li><li><del>掩码地址请求和回答报文</del></li><li><del>路由器询问和通告报文</del></li></ol><p><strong>ICMP的应用</strong></p><p>PING：测试两个主机之间的连通性，使用了ICMP回送请求和回答报文。</p><p>Traceroute：跟踪一个分组从源点到终点的路径，使用了ICMP时间超过差错报告报文。</p><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><blockquote><p>IPv6从根本上决解地址耗尽问题。方法：改进首部格式；快速处理&#x2F;转发数据报；支持QoS。</p></blockquote><p><strong>IPv6出局报格式</strong></p><p><img src="http://1.117.162.142:9000/blog/ipv6%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="IPv6数据报格式"></p><ul><li>版本致命了协议版本，总是6</li><li>优先级：区分数据报的类别和优先级</li><li>“流”是互联网上从特定源点到特定终点的一系列数据报。所有属于同一个流的数据报都具有同样的一个流的数据报都具有同样的流标签。</li><li>下一个首部：表示下一个扩展首部或上层协议首部。</li><li>条数限制：相当于IPv4的TTL</li></ul><p><strong>IPv6和IPv4</strong></p><ol><li>IPv6将地址从32位（4B）扩大到128位（16B），更大的地址空间。</li><li>IPv6将IPv4的<strong>校验和字段彻底移除</strong>，以减少每跳的处理时间。</li><li>IPv6将IPv4的可选字段移除首部，变成了扩展首部，称为灵活的首部格式，路由器通常不对扩展首部进行检查，大大提高了路由器的处理效率。</li><li>IPv6支持<strong>即插即用</strong>（即自动配置），不需要DHCP协议。</li><li>IPv6首部长度必须是<strong>8B的整数倍</strong>，IPv4首部是4B的整数倍。</li><li>IPv6<strong>只能在主机处分片</strong>，IPv4可以在路由器和主机处分片。</li><li>ICMPv6:附加报文类型“分组过大”。</li><li>IPv6支持资源的预分配，支持实时视像等要求，保证一定的带宽和时延的应用。</li><li>IPv6取消了协议字段，改成下一个首部字段。</li><li>IPv6取消了总长度字段，该用有效载荷长度字段。</li><li>IPv6取消了服务类型字段。</li></ol><p><strong>IPv6地址表示形式</strong></p><p>一般形式</p><p>冒号十六进制记法：4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170</p><p>压缩形式</p><p>4BF5:0000:0000:0000:BA5F:039A:000A:2176</p><p>4BF5:0:0:0:BA5F:39A:A:2176</p><p>零压缩：一连串连续的0可以被一对冒号取代。</p><p>FF05:0:0:0:0:0:0:B3</p><p>FF05::B3</p><blockquote><p><strong>双冒号表示法在一个地址种仅可以出现一次。</strong></p></blockquote><p><strong>IPv6基本地址类型</strong></p><p>单播：一对一通信，可做源地址+目的地址</p><p>多播：一对多通信，可做目的地址</p><p>任播：一对多中的一个通信，可做目的地址</p><p><strong>IPv6向IPv4过渡的策略</strong></p><ul><li>双栈协议</li></ul><p>双协议栈技术就是指在一台设备上同时启用IPv4协议栈和IPv6协议栈。这样的话，这台设备既能和IPv4网络通信，又能和IPv6网络通信。如果这台设备是一个路由器，那么这台路由器的不同接口上，分别配置了IPv4地址和IPv6地址，并很可能分别连接了IPv4网络和IPv6网络。如果这台设备是一个计算机，那么它将同时拥有IPv4地址和IPv6地址，并具备同时处理这两个协议地址的功能。</p><ul><li>隧道技术</li></ul><p>通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据（或负载）可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包重新封装然后通过隧道发送。</p><h3 id="RIP协议与距离向量算法"><a href="#RIP协议与距离向量算法" class="headerlink" title="RIP协议与距离向量算法"></a>RIP协议与距离向量算法</h3><p>RIP是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大优点是简单。</p><p>RIP协议要求网络中每一个路由器都维护从它自己到其它每一个目的网络的唯一最佳距离记录（即一组距离）。距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达。<strong>RIP协议只适用于小互联网</strong>。</p><p>RIP协议和谁交换？多久交换一次？交换什么？</p><ol><li>仅和相邻路由器交换信息。</li><li>路由器交换的信息是自己的路由表。</li><li>每30秒交换一次路由信息，只知道自己连接的网络的距离（距离为1），接着每一个路由器也只和数据非常有限的相邻路由器交换并更新路由信息。</li><li>经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短路径和下一跳路由器的地址，即“收敛”。</li></ol><p><strong>距离向量算法</strong></p><ol><li>修改相邻路由器发来的RIP报文中所由表项</li></ol><p>对地址为X的相邻路由器发来的RIP报文，修改此报文中的所有项目：把“下一跳”字段中的地址改为X，并把所有的”距离“字段+1</p><ol start="2"><li><p>对修改后的RIP报文中的每一个项目，进行一下步骤：</p><ol><li><p>R1路由表中若没有Net3，这把该项目填入R1</p></li><li><p>R1路由表中若没有Net3，则查看下一跳路由器地址：</p><p> 若下一跳是X，则用收到的项目替换源路由表中的项目；</p><p> 若下一跳不是X，原来距离比从X走的距离远则更新，否则不做处理。</p></li></ol></li><li><p>若180s还没收到相邻路由器X的更新路由表，则把X记为不可达的路由器，即把距离设置为16。</p></li><li><p>返回</p></li></ol><p><strong>RIP协议的报文格式</strong></p><p><img src="http://1.117.162.142:9000/blog/RIP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="RIP协议的报文格式"></p><p>RIP的特点：当网络出现故障时，要经过比较长的时间（例如数分钟）才能将此信息传送到所有的路由器，“慢收敛”。</p><h3 id="OSPF协议与链路状态算法"><a href="#OSPF协议与链路状态算法" class="headerlink" title="OSPF协议与链路状态算法"></a>OSPF协议与链路状态算法</h3><p>开放最短路径优先OSPF协议：“开放”标明OSPF协议不是受某一家厂商控制，而是公开发表的；“最短路径优先”是因为使用了Dijkatra提出的最短路径算法SPF。</p><p>OSPF最主要的特征就是使用分布式的<strong>链路状态协议</strong>。</p><p>OSPF的特点：</p><ol><li><p>使用洪泛法向自治系统内所有路由器发送消息，即路由器通过输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再次将此信息发往其所有的相邻路由器。<strong>广播</strong></p><p> 最终整个区域内所有路由器都得到了这个信息的一个副本。</p></li><li><p>发送的信息就是与本路由器相邻的所有路由器的链路状态（本路由器和哪些路由器相邻，以及该链路的度量&#x2F;代价——费用、距离、时延、带宽等）。</p></li><li><p>只有当链路状态发生变化时，路由器才向所有路由器洪泛发送此信息。</p><p> 最后，所有路由器都能建立一个链路状态数据库，即全网拓扑图。</p></li></ol><p><strong>链路状态路由算法</strong></p><ol><li>每个路由器发现它的邻居节点【HELLO问候分组】，并了解邻居节点的网络地址。</li><li>设置到它的每个邻居的成本度量metric。</li><li>构造【DD数据库描述分组】，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</li><li>如果DD分组中的摘要自己都有，则邻站不做处理；如果有没有的或者是更新的，则发送【LSR链路状态请求分组】请求自己没有的和比自己更新的信息。</li><li>收到邻站的LSR分组后，发送【LSU链路状态更新分组】进行更新。</li><li>更新完毕后，邻站返回一个【LSAck链路状态确认分组】进行确认。</li></ol><p>只要一个路由器的链路状态发生变化：</p><ol start="5"><li>泛洪发送【LSU链路状态更新分组】进行更新。</li><li>更新完毕后，其它站返回一个【LSAck链路状态确认分组】进行确认。</li><li>使用Dijkstra根据自己的链路状态数据库构造到其他节点间的最短路径。</li></ol><p><strong>OSPF的区域</strong></p><p>为了使OSPF能够用于规模很大的网络，OSPF将一个自治系统再划分为若干个更小的范围，叫做区域。每一个区域都有一个32位的区域标识符（用点分十进制表示）。区域也不能太大，在一个区域内的路由器最好不超过200个。</p><p><img src="http://1.117.162.142:9000/blog/OSPF%E7%9A%84%E5%8C%BA%E5%9F%9F.png" alt="OSPF的区域"></p><p><strong>OSPF其他特点</strong></p><ol><li>每个30min，要刷新一次数据库中的链路状态。</li><li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF协议要比距离向量协议RIP好得多。</li><li>OSPF不存在坏消息传得慢的问题，它的收敛速度很快。</li></ol><h3 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h3><p>与其他AS的邻站BGP发言人交换信息。</p><p>交换的网络可达性的信息，即要到达某个网络所要经过的一系列AS。</p><p>发生变化时更新有变化的部分。</p><p>BGP所交换的网络可达性的信息就是要到达某个网络所要经过的一系列AS。当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据数据所采用的呃策略从收到的路由信息中找出到达各AS的较好路由。</p><p><strong>BGP协议报文格式</strong></p><p>一个BGP发言人与其它自治系统中的BGP发言人要交换路由信息，就要先建立TCP连接，即通过TCP传送，然后再此连接上交换BGP报文以建立BGP会话（session），利用BGP会话交换路由信息。</p><p><img src="http://1.117.162.142:9000/blog/BGP%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="BGP协议报文格式"></p><p>BGP是应用层协议，借助TCP传送。</p><p><strong>BGP协议特点</strong></p><p>BGP支持CIDR，因此BGP的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。</p><p>在BGP刚刚运行时，BGP的邻站是交换整个的BGP路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销都有好处。</p><p><strong>BGP-4的四种报文</strong></p><ol><li>OPEN（打开）报文：用来与相邻的另一个BGP发言人建立关系，并认证发送方。</li><li>UPDATE（更新）报文：通告新路径或撤销原路径。</li><li>KEEPALIVE（保活）报文：在无UPDATE时，周期性证实邻站的连通性；也作为OPEN的确认。</li><li>NOTIFICATION（通知）报文：报告先前报文的差错；也被用于关闭连接。</li></ol><p><strong>三种路由协议比较</strong></p><p>RIP是一种分布式的基于距离向量的内部网关路由选择协议，用过广播UDP报文来交换路由信息。</p><p>OSPF是一个内部网关协议，要交换的信息量较大，应使报文的长度尽量短，所以不使用传输层协议（如UDP或TCP），而是直接采用IP。</p><p>BGP是一个外部网关协议，在不同的自治系统之间交换路由信息，由于网络环境复杂，需要保证可靠传输，所以采用TCP。</p><table><thead><tr><th align="center">协议</th><th align="center">RIP</th><th align="center">OSPF</th><th align="center">BGP</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">内部</td><td align="center">内部</td><td align="center">外部</td></tr><tr><td align="center">路由算法</td><td align="center">距离-向量</td><td align="center">链路状态</td><td align="center">路径-向量</td></tr><tr><td align="center">传递协议</td><td align="center">UDP</td><td align="center">IP</td><td align="center">TCP</td></tr><tr><td align="center">路径选择</td><td align="center">跳数最少</td><td align="center">代价最低</td><td align="center">较好，非最佳</td></tr><tr><td align="center">交换节点</td><td align="center">和本节点相连的路由器</td><td align="center">网络中的所有路由器</td><td align="center">和本节点相邻的路由器</td></tr><tr><td align="center">交换内容</td><td align="center">当前本路由器知道的全部信息，即自己的路由表</td><td align="center">与本路由器相邻的所有路由器的链路状态</td><td align="center">首次   整个路由表<br />非首次  有变化的部分</td></tr></tbody></table><h3 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h3><p> <strong>IP数据报的三种传输方式</strong>：</p><p>单播：单播用于发送数据报到单个目的地，且每发送一份单播报文都是用一个单播IP地址作为目的地址。是一种点对点传输方式。</p><p>广播：广播是指发送数据报到同一广播域或子网内的所有设备的一种数据传输方式，是一种点对多点传输方式。</p><p>组播：当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据报建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点传输方式。</p><p><strong>IP组播地址</strong></p><p>IP组播地址让源设备能够将分组发送给一组设备。属于多播组的设备将被分配一个组播组IP地址（一群共同需求主机的相同标识）。</p><p>组播地址范围为224.0.0.0～239.255.255.255（D类地址），一个D类地址表示一个组播组。只能用作分组的目标地址。源地址总是为单播地址。</p><ol><li>组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于UDP。</li><li>对组播数据报不产生ICMP差错报文</li><li>并非所有D类地址都可以作为组播地址</li></ol><p><strong>组播的两个情况</strong></p><ul><li>硬件组播</li></ul><p>同单播地址一样，组播IP地址也需要相应的组播MAC地址在本地网络中实际传送帧。组播MAC地址以十六进制值01-00-5E打头，余下的6个十六进制位是根据IP组播地址的最后23为转换得到的。</p><p><img src="http://1.117.162.142:9000/blog/%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%92%AD.png" alt="硬件组播"></p><p>收到多播数据报的主机，还要在IP层利用软件进行过滤，把不是本主机要接收的数据报丢弃。</p><ul><li>在因特网的范围内进行组播</li></ul><p><strong>IGMP协议</strong></p><p>IGMP协议让路哟起知道本局域网上是否有主机（的进程）参加或退出了某个组播组。</p><p>IGMP工作的两个阶段</p><ol><li>某主机要加入组播组时，该主机向组播组的组播地址发送一个IGMP报文，声明自己要称为该组的成员。本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。</li><li>本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。</li></ol><p>只要有一个主机对某个组相应，那么组播路由器就认为这个组是活跃的；如果经过几次探询后没有一个主机相应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</p><p><strong>组播路由器知道的成员关系只是所连接的局域网中无组播组的成员。</strong></p><p><strong>组播路由选择协议</strong></p><p>组播路由选择协议目的是找出以源主机为根节点的组播转发树。</p><p>构造树可以避免在路由器之间兜圈子。</p><p>对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树。</p><p>组播路由选择协议常使用的三种算法：</p><ul><li>基于链路状态的路由选择</li><li>基于距离-向量的路由选择</li><li>协议无关的组播（稀疏&#x2F;密集）</li></ul><h3 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h3><p> <strong>移动IP相关术语</strong></p><p>移动IP技术是移动节点（计算机&#x2F;服务器等）以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证了基于网络IP的网络权限在漫游过程中不发生任何改变。</p><p><strong>移动节点</strong>：具有永久IP地址的移动设备</p><p><strong>归属代理（本地代理）</strong>：一个移动节点拥有的就“居所”称为归属网络，在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理。</p><p><strong>外部代理（外地代理）</strong>：在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理。</p><p><strong>永久地址（归属地址&#x2F;主地址）</strong>：移动站点在归属网络中的原始地址。</p><p><strong>转交地址（辅地址）</strong>：移动站点在外部网络使用的临时地址。</p><p><strong>移动IP通信过程</strong></p><p>A刚进入外部网络：</p><ol><li>在外部代理登记获得一个转交地址，离开时注销；</li><li>外地代理向本地代理登记转交地址。</li></ol><p>B给A发送数据报：</p><ol><li>本地代理接获数据报。</li><li>本地代理在封装数据报，新的数据报目的地址是转交地址，发给外部代理（隧道）。</li><li>外部代理拆封数据报并发给A。</li></ol><p>A给B发送数据报：</p><ol><li>A用自己的主地址作为数据报源地址，用B的IP地址作为数据报的目的地址。</li></ol><p>A移动到了下一个网络：</p><ol><li>在新外部代理登记注册一个转交地址</li><li>新外部代理给本地代理发送新的转交地址（覆盖旧的）</li><li>通信</li></ol><p>A回到了归属网络：</p><ol><li>A向本地代理注销转交地址</li><li>按原始方式通信</li></ol><h2 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h2><h3 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h3><p>传输层使用网络层的服务为应用层提供通信服务。传输层的功能：</p><ol><li><p>传输层提供进程和进程之间的逻辑通信</p></li><li><p>复用和分用</p></li><li><p>传输层对收到的报文进行差错检测</p></li><li><p>传输层的两种协议（TCP、UDP）</p><ol><li><p>TCP</p><p> 面向连接的传输控制协议。传送数据之前必须建立连接，数据传送结束后要释放连接。不提供传送结束后要释放连接。不提供广播或多播服务。由于TCP要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销：确认、流量控制、计时器及连接管理。<strong>可靠，面向连接，时延大，适用于大文件。</strong></p></li><li><p>UDP</p><p> 无连接的用户数据报协议UDP。传送数据之前不需要建立连接，收到UDP报文后也不需要给出任何确认。<strong>不可靠，无连接，时延小，适用于小文件。</strong></p></li></ol></li></ol><p><strong>传输层的寻址与端口</strong></p><p>复用：应用层所有的应用进程都可以通过传输层再传输到网络层。</p><p>分用：传输层从网络层收到数据后交付指明的应用进程。</p><p>逻辑端口&#x2F;软件端口：端口是传输层的SAP，标识主机中的应用进程。端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的。端口号长度为16bit，能表示65536个不同的端口号。</p><p>端口号：</p><ul><li><p>服务端使用的端口号</p><ul><li><p>熟知端口号<strong>0～1023</strong></p><p>  给TCP&#x2F;IP最重要的一些应用程序，让所有用户都知道。</p></li><li><p>登记端口号1024～49151</p><p>  为没有熟知端口号的应用程序使用的。</p></li></ul></li><li><p>客户端使用的端口号<strong>49152～65535</strong></p><p>  仅在客户端进程运行时才动态选择</p></li></ul><table><thead><tr><th align="center">应用程序</th><th align="center">FTP</th><th align="center">TELNET</th><th align="center">SMTP</th><th align="center">DNS</th><th align="center">TFTP</th><th align="center">HTTP</th><th align="center">SNMP</th></tr></thead><tbody><tr><td align="center">熟知端口号</td><td align="center">21</td><td align="center">23</td><td align="center">25</td><td align="center">53</td><td align="center">69</td><td align="center">80</td><td align="center">161</td></tr></tbody></table><h3 id="UDP协议（用户数据报协议）"><a href="#UDP协议（用户数据报协议）" class="headerlink" title="UDP协议（用户数据报协议）"></a>UDP协议（用户数据报协议）</h3><p>UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能。</p><p>UDP的主要特点：</p><ol><li>UDP是无连接的，减少开销和发送数据之前的时延。</li><li>UDP使用最大努力交付，即不保证可靠交付。</li><li>UDP是面向报文的，适合一次性传输少量数据的网络应用。</li><li>UDP无拥塞控制，适合很多实时应用。</li><li>UDP首部开销小，8B，TCP 20B。</li></ol><p><strong>UDP首部格式</strong></p><p><img src="http://1.117.162.142:9000/blog/UDP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png" alt="UDP首部格式"></p><p>分用时，找不到对应的目的端口号，就丢弃报文，并给发送方发送ICMP“端口不可达”差错报告报文。 </p><p><strong>UDP校验</strong></p><p><img src="http://1.117.162.142:9000/blog/UDP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="UDP数据报格式"></p><p>伪首部只有在计算检验和时才出现，不向下传送也不向上递交。</p><p>17：封装UDP报文的IP数据报首部协议字段是17。</p><p>UDP长度：UDP首部8B+数据部分长度（不包括伪首部）。</p><p><img src="http://1.117.162.142:9000/blog/UDP%E6%A0%A1%E9%AA%8C.png" alt="UDP校验"></p><p>在发送端：</p><ol><li>填上伪首部</li><li>全0填充检验和字段</li><li>全0填充数据部分（UDP数据报要看成许多4B的字串接起来）</li><li>伪首部+首部+数据部分采用二进制反码求和</li><li>把和求反码填入校验和字段</li><li>去掉伪首部，发送</li></ol><p>在接收端：</p><ol><li>填上伪首部</li><li>伪首部+首部+数据部分采用二进制反码求和</li><li>结果全为1则无差错，否则丢弃数据报&#x2F;交给应用层附上出差错的警告</li></ol><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>特点：</p><ol><li><p>TCP是面向连接（虚连接）的传输层协议。</p></li><li><p>每一条TCP连接只能有两个端点，每一个TCP连接只能是点对点的。</p></li><li><p>TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达。</p></li><li><p>TCP提供全双工通信。</p><p> 发送缓存：准备发送的数据&amp;已发送但尚未接收到确认的数据</p><p> 接收缓存：按序到达但尚未被接收应用程序读取的数据&amp;不按序到达的数据</p></li><li><p>TCP面向字节流</p><p> TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。</p></li></ol><p><strong>TCP报文首部格式</strong></p><p><img src="http://1.117.162.142:9000/blog/TCP%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png" alt="TCP报文首部格式"></p><p> <strong>序号</strong>：在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，本字段表表示报文段所发送数据的第一个字节的序号。</p><p><strong>确认号</strong>：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则证明到序号N-1为止的所有数据都已正确收到。</p><p>**数据偏移(首部长度)**：TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B为单位，即1个数值是4B。</p><p><strong>6个控制位</strong></p><ul><li><strong>紧急位URG</strong>：URG&#x3D;1时，标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。</li><li><strong>确认位ACK</strong>：ACK&#x3D;1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1。</li><li><strong>推送位PSH</strong>：PSH&#x3D;1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。</li><li><strong>复位RST</strong>：RST&#x3D;1时，标明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。</li><li><strong>同步位SYN</strong>：SYN&#x3D;1时，表明是一个链接请求&#x2F;连接接受报文。</li><li><strong>终止位FIN</strong>：FIN&#x3D;1时，表明此报文段发送方数据已发完，要求释放连接。</li></ul><p><strong>窗口</strong>：指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量。</p><p><strong>检验和</strong>：检验首部+数据，检验时要加上12B伪首部，第四个字段为6。</p><p><strong>紧急指针</strong>：URG&#x3D;1时才有意义，指出本报文段中紧急数据的字节数。</p><p><strong>选项</strong>：最大报文段长度MSS、窗口扩大、时间戳、选择确认……</p><p>TCP连接的三个阶段：</p><p>连接建立 -&gt; 数据传输 -&gt; 连接释放</p><p><strong>TCP建立连接</strong></p><p><img src="http://1.117.162.142:9000/blog/TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png" alt="TCP建立连接"></p><ol><li><p>客户端发送数据连接请求报文段，无应用层数据。</p><p> SYN&#x3D;1，seq&#x3D;x(随机)</p></li><li><p>服务器端为该TCP连接分配缓存和随机变量，并向客户端返回确认报文段，允许连接，无应用层数据。</p><p> SYN&#x3D;1，ACK&#x3D;1，seq&#x3D;y(随机)，ack&#x3D;x+1</p></li><li><p>客户端为该TCP连接分配缓存和变量，并向服务器端返回确认的确认，可以携带数据。</p><p> SYN&#x3D;0，ACK&#x3D;1，seq&#x3D;x+1，ack&#x3D;y+1</p></li></ol><p><strong>SYN洪泛攻击</strong></p><p>SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p><p>解决方法：<strong>SYN cookie</strong></p><p><strong>TCO释放连接</strong></p><p><img src="http://1.117.162.142:9000/blog/TCP%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5.png" alt="TCP释放连接"></p><ol><li><p>客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接。</p><p> FIN&#x3D;1，seq&#x3D;u</p></li><li><p>服务器端回送一个确认报文段，客户到服务器这个方向的连接就释放了——半关闭状态。</p><p> ACK&#x3D;1，seq&#x3D;v，ack&#x3D;u+1</p></li><li><p>服务器端发完数据，就发出连接释放报文段，主动关闭TCP连接。</p><p> FIN&#x3D;1，ACK&#x3D;1，seq&#x3D;w，ack&#x3D;u+1</p></li><li><p>客户端回送一个确认报文段，再等到时间等待计时器设置的2MSL(最长报文段寿命)后，连接彻底关闭。</p><p> ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1</p></li></ol><p> <strong>TCP可靠传输</strong></p><p>保证接收方进程从缓存区读出的字节流与发送发发出的字节流是完全一样的。</p><p>TCP实现可靠传输的机制：</p><ol><li>校验：与UDP校验一样，增加伪首部。</li><li>序号：一个字节占一个序号，序号字段指的是一个报文段第一个字节的序号。</li><li>确认：TCP接收方对已经正确接收到的报文段进行确认。</li><li>重传：TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段。TCP采用自适应算法，动态改变重传时间RTTs(加权平均往返时间)。</li></ol><p><strong>TCP流量控制</strong></p><p>流量控制：让发送方慢点，要让接收方来得及接收。</p><p>TCP利用滑动窗口机制实现流量控制。</p><p>在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给发送方），发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。</p><p><strong>发送窗口大小可以动态变化。</strong></p><p>A向B发送数据，连接建立时，B告诉A：“我的rwnd&#x3D;400(字节)“，设每一个报文段100B，报文段序号初始值为1。</p><p><img src="http://1.117.162.142:9000/blog/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png" alt="TCP流量控制"></p><p>TCP为每一个连接设有一个持续计时器，只要TCP连接的一方受到对方的零窗口通知，就启动持续计时器。</p><p>若持续计时器设置的时间到期，就发送一个零窗口探测报文段。接收方收到探测报文段时给出现在的窗口值。</p><p>若窗口仍然是0，那么发送方就重新设置持续计时器。</p><p><strong>TCP拥塞控制</strong></p><p>出现拥塞的条件：对资源需求的总和&gt;可用资源</p><p>网络中有许多资源同时呈现供应不足 -&gt; 网络性能变坏 -&gt; 网络吞吐量将随输入负荷增大而下降</p><p>拥塞控制：防止过多的数据注入到网络中。 </p><p><strong>拥塞控制四种算法</strong></p><p>假定：</p><ol><li><p>数据单方向传送，而另一个方向只传送确认</p></li><li><p>接收方总是有足够大的缓存空间，因而发送窗口大小取决于拥塞程度</p><p> 发送串口&#x3D;Min{接收窗口rwnd，拥塞窗口cwnd}</p><p> 接收窗口：接收方根据接受缓存设置的值，并告知给发送方，反映接收方容量。</p><p> 拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量。</p></li></ol><p>慢开始和拥塞避免</p><p><img src="http://1.117.162.142:9000/blog/%E6%85%A2%E5%BC%80%E5%A7%8B%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.png" alt="慢开始和拥塞避免"></p><p>开始时cwnd&#x3D;1的一个报文段</p><p>一个传输轮次：</p><p>发送了一批报文段并收到它们的确认的时间。一个往返时延RTT。开始发送一批拥塞窗口内的报文段到开始发送下一批拥塞窗口内的报文段的时间。</p><p>快重传和快恢复</p><p><img src="http://1.117.162.142:9000/blog/%E5%BF%AB%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E6%81%A2%E5%A4%8D.png" alt="快重传和快恢复"></p><h2 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h2><p><strong>应用层概述</strong></p><p>应用层对应用程序的通信提供服务。</p><p><strong>应用层协议定义</strong>：</p><p>应用进程交换的报文类型，请求还是响应？</p><p>各种报文类型的语法，如报文中的各个字段及其详细描述</p><p>字段的语义，即包含在字段中的信息的含义</p><p>进程何时、如何发送报文，以及对报文进行响应的规则</p><p><strong>应用层的功能</strong>：</p><p>文件传输、访问和管理</p><p>电子邮件</p><p>虚拟终端</p><p>查询服务和远程作业登录</p><p><strong>应用层的重要协议</strong>：</p><p>FTP、SMTP、POP3、HTTP、DNS</p><h3 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h3><p><strong>客户&#x2F;服务器(c&#x2F;s)模型</strong></p><p>服务器：提供计算服务的设备</p><ol><li>永久的提供服务</li><li>永久性访问地址&#x2F;域名</li></ol><p>客户机：请求计算服务的主机</p><ol><li>与服务器通信，使用服务器提供的服务</li><li>间歇性接入网络</li><li>可能使用动态IP地址</li><li>不与其他客户机直接通信</li></ol><p>应用：Web、文件传输FTP、远程登录、电子邮件</p><p><strong>P2P模型</strong></p><p>不存在永远在线的服务器</p><p>每个主机既可以提供服务，也可以请求服务</p><p>任意端系统&#x2F;节点之间可以直接通讯</p><p>节点间接性接入网络</p><p>节点可能改变IP地址</p><p>可扩展性好</p><p>网络健壮性强</p><h3 id="DNS系统"><a href="#DNS系统" class="headerlink" title="DNS系统"></a>DNS系统</h3><p><strong>域名</strong></p><p><a href="http://www.baidu.com/">www.baidu.com</a></p><p>com：顶级域名</p><p>baidu：二级域名</p><p>www：三级域名</p><ul><li>根：‘.’</li><li>顶级域名<ul><li>国家顶级域名：cn, us, uk</li><li>通用顶级域名：com, net, org, gov, int, aero, museum, travel</li><li>基础结构域名&#x2F;反向域名：arpa</li></ul></li><li>二级域名<ul><li>类别域名：ac, com, edu, gov, mil, net, org</li><li>行政区域名 用于我国各省、自治区、直辖市 bj, js</li></ul></li><li>三级域名</li><li>四级域名</li></ul><p><img src="http://1.117.162.142:9000/blog/%E5%9F%9F%E5%90%8D.png" alt="域名"></p><p><strong>域名解析过程</strong></p><p><img src="http://1.117.162.142:9000/blog/%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2.png" alt="递归查询"></p><p><img src="http://1.117.162.142:9000/blog/%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2.png" alt="迭代查询"></p><h3 id="文件传输协议FTP"><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a>文件传输协议FTP</h3><p><strong>文件传送协议FTP（File Transfer Protocol）</strong></p><p>提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力</p><p>FTP是基于客户&#x2F;服务器（c&#x2F;s）的协议</p><p>用户通过一个客户机程序连接至在远程计算机上运行的服务器程序。依照FTP协议提供服务，进行文件传送的计算机就是FTP服务器。连接FTP服务器，遵循FTP协议的服务器传送文件的电脑就是FT P客户端。</p><p><img src="http://1.117.162.142:9000/blog/FTP.png" alt="FTP工作原理"></p><p>控制连接始终保持</p><p>数据连接保持一会</p><p>是否使用TCP 20端口建立数据连接与传输模式有关</p><p>主动方式使用TCP 20端口</p><p>被动方式由服务器和客户端自行协商决定（端口&gt;1024）</p><p>FTP传输模式：</p><ul><li>文本模式：ASCII模式，以文本序列传输数据；</li><li>二进制模式：Binary模式，以二进制序列传输数据。</li></ul><p>简单文件传送协议TFTP（Trivial File Transfer Protocol）</p><h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><p>电子邮件的信息格式：</p><ul><li><p>信封：<a href="mailto:&#x61;&#x62;&#x63;&#x2e;&#64;&#x31;&#54;&#51;&#46;&#99;&#111;&#x6d;">&#x61;&#x62;&#x63;&#x2e;&#64;&#x31;&#54;&#51;&#46;&#99;&#111;&#x6d;</a></p></li><li><p>内容：</p><ul><li><p>首部</p><p>  To:<a href="mailto:&#97;&#x62;&#99;&#46;&#64;&#x31;&#x36;&#51;&#46;&#99;&#111;&#109;">&#97;&#x62;&#99;&#46;&#64;&#x31;&#x36;&#51;&#46;&#99;&#111;&#109;</a></p><p>  Subject:hello!</p></li><li><p>主题</p></li></ul></li></ul><p>组成结构</p><ul><li>用户代理：电子邮件客户端软件——撰写、显示、处理、通信</li><li>邮件服务器<ul><li>发送和接受邮件</li><li>向发件人报告邮件传送结果</li></ul></li><li>协议<ul><li>SMTP协议（发）</li><li>POP3、IMAP（收）</li></ul></li></ul><p><img src="http://1.117.162.142:9000/blog/%E9%82%AE%E4%BB%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="邮件工作原理"></p><p><strong>简单邮件传送协议SMTP</strong></p><p>SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息。</p><p>负责发送邮件的SMTP进程就是SMTP客户，负责接收邮件的进程就是SMTP服务器</p><p>SMTP规定了14条命令（几个字母）和21种应答信息（三位数字代码+简单文字说明）</p><p>采用TCP连接，端口号25，C&#x2F;S</p><p>过程：</p><p>连接建立 -&gt; 邮件发送 -&gt; 连接释放</p><p>缺点：</p><ol><li>SMTP不能传送可执行文件或者其他二进制对象。</li><li>SMTP仅限于传送7位ASCII码，不能传送其他非英语国家的文字。</li><li>SMTP服务器会拒绝超过一定长度的邮件。</li></ol><p><strong>邮局协议POP3</strong></p><p>采用C&#x2F;S模式的TCP连接，端口号110</p><p>POP3工作方式：下载并保留，下载并删除</p><p><strong>网际报文存取协议IMAP</strong></p><p>IMAP协议比POP协议复杂。当用户PC上的IMAP客户程序打开IMAP服务器的邮箱时，用户可以看到邮箱的首部，若用户需要打开某个邮件，该邮件才能上传到用户的计算机上。IMAP可以让用户在不同的地方使用不同的计算机随时上网阅读处理邮件，还允许只读邮件中的某一个部分（先看正文，由WIFI的时候再下载附件）。</p><h3 id="万维网和HTTP协议"><a href="#万维网和HTTP协议" class="headerlink" title="万维网和HTTP协议"></a>万维网和HTTP协议</h3><p>万维网www(World Wide Web) 是一个大规模的、联机式的信息储藏所&#x2F;资料空间，是无数个网络站点和网页的集合。 </p><p>同一资源定位符URL—————-&gt;资源(文字、视频、音频……)</p><p>URL一般形式：</p><p>​&lt;协议&gt;:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;<a href="http://www.pku.edu.cn/">http://www.pku.edu.cn</a></p><p>​http域名</p><p>​ftp IP地址</p><p>用户通过点击超链接获取资源，这些资源通过超文本传输协议(HTTP)传送给使用者。</p><p>万维网以客户&#x2F;服务器方式工作，用户使用的浏览器就是万维网客户程序，万维网文档所驻留的主机运行服务器程序。</p><p>万维网使用超文本标记语言HTML，使得万维网页面设计者可以很方便地从一个界面的链接转到另一个界面，并能够在自己的屏幕上显示出来。</p><p><strong>超文本传输协议HTTP</strong></p><p>HTTP协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。</p><p><img src="http://1.117.162.142:9000/blog/HTTP1.png" alt="HTTP1"></p><p>用户浏览页面方法：</p><ol><li>输入URL</li><li>点击超链接</li></ol><p>具体过程：</p><ol><li>浏览器分析URL</li><li>浏览器向DNS请求解析IP地址</li><li>DNS解析出IP地址</li><li>浏览器与服务器建立TCP连接</li><li>浏览器发出取文件命令</li><li>服务器响应</li><li>释放TCP连接</li><li>浏览器显示</li></ol><p><strong>HTTP协议的特点</strong></p><p>HTTP协议是无状态的。</p><p>但是在实际工作中，一些万维网站点常常希望能够识别用户。</p><p>COOkie时存储在用户主机中的文本文件，记录一段时间内某用户（使用识别码，如“123456”）的访问记录。</p><p>HTTP采用TCP作为运输层协议，但HTTP协议本身是无连接的（通信双方在交换HTTP报文之前不需要建立HTTP连接）。</p><p>HTTP的连接方式：</p><ul><li>持久连接keep-alive<ul><li>非流水</li><li>流水</li></ul></li><li>非持久连接close</li></ul><p>HTTP非持久连接</p><p><img src="http://1.117.162.142:9000/blog/http%E9%9D%9E%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5.png" alt="http非持久连接"></p><p>HTTP持久连接</p><p><img src="http://1.117.162.142:9000/blog/http%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5.png" alt="http持久连接"></p><p><strong>报文结构</strong></p><p>HTTP报文是面向文本的，因此在报文中的每一个字段都是一些ASCII码串。</p><p><img src="http://1.117.162.142:9000/blog/http%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png" alt="报文结构"></p><p>状态码：</p><ul><li><p>1xx表示通知信息的，如请求收到了或正在处理</p></li><li><p>2xx表示成功，如接受或知道了</p></li><li><p>3xx表示重定向，如要完成请求还必须采取进一步的行动</p></li><li><p>4xx表示客户的差错，如请求中有错误的语法或不能完成</p></li><li><p>5xx表示服务器的差错，如服务器失效无法完成请求</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO 框架</title>
      <link href="/2021/12/25/io/"/>
      <url>/2021/12/25/io/</url>
      
        <content type="html"><![CDATA[<h1 id="io流"><a href="#io流" class="headerlink" title="io流"></a>io流</h1><ul><li><p>输入流</p><ul><li>InputStream<ul><li>FileInputStream</li><li>BufferedInputStream</li><li>ObjectInputStream</li></ul></li><li>Reader<ul><li>FileReader</li><li>BufferedReader</li><li>InputStreamReader</li></ul></li></ul></li><li><p>输出流</p><ul><li>OutputStream<ul><li>FileOutputStream</li><li>BufferedOutputStream</li><li>ObjectOutputStream</li></ul></li><li>Writer<ul><li>FileWriter</li><li>BufferedWriter</li><li>OutputStreamWriter</li></ul></li></ul></li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件流：文件在程序中是以流的形式来操作的</p><ul><li>Java程序通过&#x3D;&#x3D;输入流&#x3D;&#x3D;从磁盘读取文件数据</li><li>Java程序通过&#x3D;&#x3D;输出流&#x3D;&#x3D;将数据写入到磁盘</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> zhangjian</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: io</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/9/18 15:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">creat01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;c:\\work\\io1.txt&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">            System.out.println(<span class="string">&quot;文件创建成功!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">creat02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;c:\\work&quot;</span>, <span class="string">&quot;io2.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">            System.out.println(<span class="string">&quot;文件创建成功!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>获取文件信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getFileInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;c:\\work\\io1.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;文件名字=&quot;</span> + file.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件绝对路径=&quot;</span> + file.getAbsolutePath());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件父级目录=&quot;</span> + file.getParent());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件大小=&quot;</span> + file.length());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件是否存在=&quot;</span> + file.exists());</span><br><span class="line">    System.out.println(<span class="string">&quot;是不是一个文件=&quot;</span> + file.isFile());</span><br><span class="line">    System.out.println(<span class="string">&quot;是不是一个目录=&quot;</span> + file.isDirectory());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">directory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;c:\\work\\io2.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.delete()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">directory1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;c:\\work\\m1\\m2&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;目录已存在&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.mkdirs()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;c:\\work\\m1\\m2&quot;</span> + <span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;c:\\work\\m1\\m2&quot;</span> + <span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="io流原理及流的分类"><a href="#io流原理及流的分类" class="headerlink" title="io流原理及流的分类"></a>io流原理及流的分类</h3><ul><li><p>io原理</p><ul><li>i&#x2F;o是Input&#x2F;Output的缩写，i&#x2F;o技术是非常使用的技术，用于处理数据传输。如读写文件，网络通讯等</li><li>Java程序中，对于数据的输入输出操作以流stream的方式进行</li><li>Java.io包下提供了各种流的类和接口，用以获取不同种类的数据，并通过方法输入或输出数据</li></ul></li><li><p>流的分类</p><ul><li>按操作数据单位不同分为：字节流(8 bit)，字符流(按字符)</li><li>按数据流的流向不同分为：输入流，输出流</li><li>按流的角色的不同分为：节点流和处理流</li></ul></li></ul><table><thead><tr><th align="center">抽象基类</th><th align="center">字节流</th><th align="center">字符流</th></tr></thead><tbody><tr><td align="center">输入流</td><td align="center">InputStream</td><td align="center">Reader</td></tr><tr><td align="center">输出流</td><td align="center">OutputStream</td><td align="center">Writer</td></tr></tbody></table><p>![iostream2xx](C:\Most used software\Notes\io流.assets\io1.png)</p><blockquote><p>FileInputStream</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileinputStream</span> &#123;</span><br><span class="line">    <span class="comment">// 单个字节读</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Train\\Data structure and algorithm\\test.txt&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">readData</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">            <span class="comment">// 读完返回-1</span></span><br><span class="line">            <span class="keyword">while</span> ((readData = fileInputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>) readData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次读取8个字节</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile02</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Train\\Data structure and algorithm\\test.txt&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">            <span class="comment">// 读完返回-1，没读完返回实际读了的个数</span></span><br><span class="line">            <span class="keyword">while</span> ((len = fileInputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>FileOutputStream 文件输出流</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileoutputStream</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Train\\Data structure and algorithm\\map.txt&quot;</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// new FileOutputStream(filePath)是覆盖写入</span></span><br><span class="line">            <span class="comment">// new FileOutputStream(filePath， true)是追加写入</span></span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">            <span class="comment">// 写入一个字节</span></span><br><span class="line">            <span class="comment">//fileOutputStream.write(&#x27;A&#x27;);</span></span><br><span class="line">            <span class="comment">// getBytes() 把字符串转化为字节数组</span></span><br><span class="line">            <span class="comment">//fileOutputStream.write(str.getBytes());</span></span><br><span class="line">            <span class="comment">// write(byte[] b, int off, int len)将len字节从位于偏移量off的指定字节数组写入此文件输出流</span></span><br><span class="line">            fileOutputStream.write(str.getBytes(), <span class="number">0</span>, str.length());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例：文件拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCopy</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fileCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">srcFilePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\10466\\Pictures\\Camera Roll\\傻狗.jpg&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Train\\Data structure and algorithm\\傻狗.jpg&quot;</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFilePath);</span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFilePath);</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = fileInputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fileOutputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;拷贝成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileOutputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                    fileOutputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                    fileInputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>FileReader</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader_</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fileReader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Train\\Data structure and algorithm\\map.txt&quot;</span>;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath);</span><br><span class="line">            <span class="comment">// 单个字符读取</span></span><br><span class="line">            <span class="comment">//while ((data = fileReader.read()) != -1) &#123;</span></span><br><span class="line">                <span class="comment">//System.out.print((char) data);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//字符数组读取</span></span><br><span class="line">            <span class="keyword">while</span>((data = fileReader.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, data));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fileReader != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileReader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>FileWriter</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWrite_</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fileWrite</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Train\\Data structure and algorithm\\map.txt&quot;</span>;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">char</span>[] str = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 写入单个字符</span></span><br><span class="line">            <span class="comment">//fileWriter.write(&#x27;H&#x27;);</span></span><br><span class="line">            <span class="comment">// 写入指定字符数组</span></span><br><span class="line">            <span class="comment">//fileWriter.write(str);</span></span><br><span class="line">            <span class="comment">// 写入指定字符数组的指定部分</span></span><br><span class="line">            <span class="comment">//fileWriter.write(&quot; 你好!Hello!&quot;.toCharArray(), 0, 3);</span></span><br><span class="line">            <span class="comment">// 写入整个字符串</span></span><br><span class="line">            <span class="comment">//fileWriter.write(&quot; 你好!Hello!&quot;);</span></span><br><span class="line">            <span class="comment">// 写入字符串的指定部分</span></span><br><span class="line">            fileWriter.write(<span class="string">&quot; 重庆！&quot;</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 大数据时，循环写入</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fileWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileWriter.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;FileWrite再写入时，一定要将流close或者flush，不然输入写不进去，因为真正执行write操作的是在close或者flush时。&#x3D;&#x3D;</p><h3 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h3><ul><li><p>节点流可以从一个&#x3D;&#x3D;特定的数据源&#x3D;&#x3D;读写数据，如FileReader、FileWriter</p></li><li><p>处理流（也叫包装流）是连接在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，也更加灵活，如BufferedReader、BufferedWriter</p></li><li><p>节点流和处理流的区别和联系</p><ul><li>节点流是底层流\低级流，直接跟数据源相接</li><li>处理流（包装流）包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出</li><li>处理流（包装流）对节点流进行包装，使用了&#x3D;&#x3D;修饰器设计模式&#x3D;&#x3D;，不会直接与数据源相连</li></ul></li><li><p>处理流的功能主要体现在以下两个方面：</p><ul><li>性能的提高：主要以增加缓冲的方式来提高输入输出的效率</li><li>操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便</li></ul></li></ul><table><thead><tr><th align="center">分类</th><th align="center">字节输入流</th><th align="center">字节输出流</th><th align="center">字符输入流</th><th align="center">字符输出流</th><th align="center"></th></tr></thead><tbody><tr><td align="center">抽象基类</td><td align="center">InputStream</td><td align="center">OutputStream</td><td align="center">Reader</td><td align="center">Writer</td><td align="center"></td></tr><tr><td align="center">访问文件</td><td align="center">FileInputStream</td><td align="center">FileOutputStream</td><td align="center">FileReader</td><td align="center">FileWriter</td><td align="center">节点流</td></tr><tr><td align="center">访问数组</td><td align="center">ByteArrayInputStream</td><td align="center">ByteArrayOutputStream</td><td align="center">CharArrayReader</td><td align="center">CharArrayWriter</td><td align="center">节点流</td></tr><tr><td align="center">访问管道</td><td align="center">PipedInputStream</td><td align="center">PipedOutputStream</td><td align="center">PipedReader</td><td align="center">PipedWriter</td><td align="center">节点流</td></tr><tr><td align="center">访问字符串</td><td align="center"></td><td align="center"></td><td align="center">StringReader</td><td align="center">StringWriter</td><td align="center">节点流</td></tr><tr><td align="center">缓冲流</td><td align="center">BufferedInputStream</td><td align="center">BufferedOutputStream</td><td align="center">BufferedReader</td><td align="center">BufferedWriter</td><td align="center">处理流</td></tr><tr><td align="center">转换流</td><td align="center"></td><td align="center"></td><td align="center">InputStreamReader</td><td align="center">OutputStreamWriter</td><td align="center">处理流</td></tr><tr><td align="center">对象流</td><td align="center">ObjectInputStream</td><td align="center">ObjectOutputStream</td><td align="center"></td><td align="center"></td><td align="center">处理流</td></tr><tr><td align="center">抽象基类</td><td align="center">FiterInputStream</td><td align="center">FileOutputStream</td><td align="center">FiterReader</td><td align="center">FiterWriter</td><td align="center">处理流</td></tr><tr><td align="center">打印流</td><td align="center"></td><td align="center">printStream</td><td align="center"></td><td align="center">printWriter</td><td align="center">处理流</td></tr><tr><td align="center">推回输入流</td><td align="center">PushbackInputStream</td><td align="center"></td><td align="center">PushbackReader</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">特殊流</td><td align="center">DataInputStream</td><td align="center">DataOutputStream</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><blockquote><p>BufferedReader</p></blockquote><p>BufferedReader、BufferedWriter属于字符流，是&#x3D;&#x3D;按照字符来读取数据&#x3D;&#x3D;的，关闭处理流时，只需要关闭外层流即可,尽量用来&#x3D;&#x3D;操作文本文件&#x3D;&#x3D;，操作二进制文件（例如：图片，视频）会打不开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReader_</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bufferedReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Train\\Data structure and algorithm\\map.txt&quot;</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="comment">// 按行读取，读完后返回null</span></span><br><span class="line">        <span class="keyword">while</span>((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>BufferedWriter</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedWriter_</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bufferedWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Train\\Data structure and algorithm\\map.txt&quot;</span>;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath, <span class="literal">true</span>));</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">        <span class="comment">// 换行符</span></span><br><span class="line">        bufferedWriter.newLine();</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;hello, java&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine();</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例：拷贝文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedCopy</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bufferedCopy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">srcFilePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Train\\Data structure and algorithm\\map.txt&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Train\\Data structure and algorithm\\map3.txt&quot;</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bufferedReader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFilePath));</span><br><span class="line">            bufferedWriter = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFilePath));</span><br><span class="line">            <span class="keyword">while</span>((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                bufferedWriter.write(line);</span><br><span class="line">                bufferedWriter.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件拷贝成功！！！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bufferedReader != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufferedReader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bufferedWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufferedWriter.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>BufferedInputStream</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(InputStream inputStream)</span><br></pre></td></tr></table></figure><blockquote><p>BufferedOutputStream</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(OutputStream outputStream)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedCopy02</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bufferedCopy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">srcFilePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\10466\\Pictures\\Camera Roll\\小白狗.jpg&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Train\\Data structure and algorithm\\小白狗.jpg&quot;</span>;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bufferedInputStream= <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFilePath));</span><br><span class="line">            bufferedOutputStream = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFilePath));</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = bufferedInputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bufferedOutputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件拷比完毕！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bufferedInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufferedInputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bufferedOutputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufferedOutputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;既可以操纵二进制文件，也可以操作文本文件&#x3D;&#x3D;</p><blockquote><p>ObjectInputStream &amp; ObjectOutputStream 对象流，也是处理流(包装流)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(InputStream inputStream)</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(OutputStream outputStream)</span><br></pre></td></tr></table></figure><p>序列化和反序列化：</p><ul><li>序列化就是在保存数据的时候，保存&#x3D;&#x3D;数据的值&#x3D;&#x3D;和&#x3D;&#x3D;数据类型&#x3D;&#x3D;</li><li>反序列化就是在恢复数据时，恢复&#x3D;&#x3D;数据的值&#x3D;&#x3D;和&#x3D;&#x3D;数据类型&#x3D;&#x3D;</li><li>需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：<ul><li>Serializable    推荐实现这个接口，这是一个&#x3D;&#x3D;标记接口&#x3D;&#x3D;，里面没有任何方法</li><li>Externalizable</li></ul></li></ul><p>序列化数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectOutputStream_</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">objectoutputstream</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Train\\Data structure and algorithm\\data.dat&quot;</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath));</span><br><span class="line">        <span class="comment">// 序列化后，保存的文件格式不是纯文本，而是按照他的格式来保存的</span></span><br><span class="line">        <span class="comment">// 序列化数据到data.dat</span></span><br><span class="line">        objectOutputStream.write(<span class="number">100</span>);<span class="comment">// int -&gt; Integer(实现了 Serializable接口)</span></span><br><span class="line">        objectOutputStream.writeBoolean(<span class="literal">true</span>);<span class="comment">// boolean -&gt; Boolean(实现了 Serializable接口)</span></span><br><span class="line">        objectOutputStream.writeChar(<span class="string">&#x27;a&#x27;</span>);<span class="comment">// char -&gt; Char(实现了 Serializable接口)</span></span><br><span class="line">        objectOutputStream.writeDouble(<span class="number">1.1</span>);<span class="comment">//double -&gt; Double(实现了 Serializable接口)</span></span><br><span class="line">        objectOutputStream.writeUTF(<span class="string">&quot;你好白！&quot;</span>);<span class="comment">// String</span></span><br><span class="line">        <span class="comment">// 保存Dog对象</span></span><br><span class="line">        objectOutputStream.writeObject(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小白&quot;</span>, <span class="number">2</span>));</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;数据序列化成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectInputStream_</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ob</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Train\\Data structure and algorithm\\data.dat&quot;</span>;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath));</span><br><span class="line">        <span class="comment">// 反序列化的顺序要和序列化的顺序一至</span></span><br><span class="line">        System.out.println(objectInputStream.readInt());</span><br><span class="line">        System.out.println(objectInputStream.readBoolean());</span><br><span class="line">        System.out.println(objectInputStream.readChar());</span><br><span class="line">        System.out.println(objectInputStream.readDouble());</span><br><span class="line">        System.out.println(objectInputStream.readUTF());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">dog</span> <span class="operator">=</span> objectInputStream.readObject();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行类型：&quot;</span> + dog.getClass());</span><br><span class="line">        System.out.println(<span class="string">&quot;dog信息：&quot;</span> + dog);</span><br><span class="line">        objectInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>读写顺序要一致</li><li>要求序列化或反序列化对象，需要实现Serializable</li><li>序列化的类中建议添加SerialVersionUID，为了提高版本的兼容性<code>private static final long serialVersionUID = 1L;</code></li><li>序列化对象时，默认将里面所有属性都进行序列化，但除了static或transient修饰的成员</li><li>序列化对象时，要求里面属性的类型也需要实现序列化接口</li><li>序列化具备可继承性，也就是如果某类已经实现了序列化，则他的所有子类也已经默认实现了序列化</li></ul><blockquote><p>标准输入流和标准输出流</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputAndOutput</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//System类的 public final static InputStream in = null;</span></span><br><span class="line">        <span class="comment">//System.in 编译类型    InputStream</span></span><br><span class="line">        <span class="comment">//System.in 运行类型    BufferedInputStream</span></span><br><span class="line">        <span class="comment">//表示的标准输入   键盘</span></span><br><span class="line">        System.out.println(System.in.getClass());</span><br><span class="line">        <span class="comment">//System.out public final static PrintStream out = null;</span></span><br><span class="line">        <span class="comment">//编译类型 PrintStream</span></span><br><span class="line">        <span class="comment">//运行类型 PrintStream</span></span><br><span class="line">        <span class="comment">//便是标准输出  显示器</span></span><br><span class="line">        System.out.println(System.out.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>InputStreamReader    &amp;    OutputStreamWriter   转换流</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(InputStream in, <span class="string">&quot;gbk&quot;</span>)</span><br></pre></td></tr></table></figure><p>当处理纯文本数据时，如果使用字符流效率更高，并且可以有效解决中文问题，所以建议将字节流转换成字符流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeQuestions</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Train\\Data structure and algorithm\\map.txt&quot;</span>;</span><br><span class="line">        <span class="comment">//InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(filePath), &quot;gbk&quot;);</span></span><br><span class="line">        <span class="comment">//BufferedReader bufferedReader = new BufferedReader(inputStreamReader);</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath), <span class="string">&quot;gbk&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriter_</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Train\\Data structure and algorithm\\la.txt&quot;</span>;</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">outputStreamWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        outputStreamWriter.write(<span class="string">&quot;hello,世界!&quot;</span>);</span><br><span class="line">        outputStreamWriter.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;文件保存成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PrintStream-打印流   只有输出流没有输入流</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream_</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> System.out;</span><br><span class="line">        out.print(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">        <span class="comment">//修改打印流输出的位置，默认是显示器</span></span><br><span class="line">        out.close();</span><br><span class="line">        System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;C:\\Train\\Data structure and algorithm\\t1.txt&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,world,世界！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PrintWriter</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintWriter_</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;C:\\Train\\Data structure and algorithm\\t2.txt&quot;</span>));</span><br><span class="line">        printWriter.println(<span class="string">&quot;hello，重庆&quot;</span>);</span><br><span class="line">        printWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Properties 类</p></blockquote><p>Properties的常见方法：</p><ul><li>load: 加载配置文件的键值对到Properties对象</li><li>list: 将数据显示到指定设备</li><li>getProperty(key): 设置键值对到Properties对象</li><li>store：将Properties中的键值对存储到配置文件中，在idea中，保存信息到配置文件，如果含有中文，会存储为unicode码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties_</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        properties.list(System.out);</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名：&quot;</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//如果文件有该key，就修改，没有就创建</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;charset&quot;</span>, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        properties.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\mysql2.properties&quot;</span>), <span class="string">&quot;注释&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;文件保存成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul><li>判断当前目录下是否有文件夹mytemp，如果没有就创建</li><li>在mytemp目录下，创建文件hello.txt</li><li>如果hello.txt存在，提示该文件已经存在，</li><li>在hello.txt文件中，写入hello，world</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Train</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">train01</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">directoryPath</span> <span class="operator">=</span> <span class="string">&quot;mytemp&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(directoryPath);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(file.mkdirs()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;创建 &quot;</span> + directoryPath + <span class="string">&quot; 创建成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;创建 &quot;</span> + directoryPath + <span class="string">&quot; 创建失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> directoryPath + <span class="string">&quot;\\hello.txt&quot;</span>;</span><br><span class="line">        file = <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.createNewFile()) &#123;</span><br><span class="line">                System.out.println(filePath + <span class="string">&quot; 创建成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(filePath + <span class="string">&quot; 创建失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(filePath + <span class="string">&quot; 已经存在，不再重复创建。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(file));</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用BufferedReader读取一个文本文件，为每行加上行号，再连同内容一并输出到屏幕上。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">train02</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;C:\\Train\\Data structure and algorithm\\map.txt&quot;</span>));</span><br><span class="line">    <span class="comment">//如果编码不是utf-8</span></span><br><span class="line">    <span class="comment">//BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(filePath), &quot;gbk&quot;));</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((str = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        row++;</span><br><span class="line">        System.out.println(row + <span class="string">&quot; &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">    bufferedReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>要编写一个dog.properties<ul><li>name&#x3D;tom</li><li>color&#x3D;red</li></ul></li><li>编写Dog类（name,age,color）创建一个dog对象，读取dog.properties用相应的内容完成属性初始化，并输出</li><li>序列化到dog.dat文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">train03</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Train\\Data structure and algorithm\\src\\dog.properties&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath1</span> <span class="operator">=</span> <span class="string">&quot;C:\\Train\\Data structure and algorithm\\src\\dog.dat&quot;</span>;</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath));</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(properties.getProperty(<span class="string">&quot;name&quot;</span>), Integer.parseInt(properties.getProperty(<span class="string">&quot;age&quot;</span>)), properties.getProperty(<span class="string">&quot;color&quot;</span>));</span><br><span class="line">    System.out.println(dog);</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath1));</span><br><span class="line">    objectOutputStream.writeObject(dog);</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;序列化完成！&quot;</span>);</span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath1));</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> (Dog)objectInputStream.readObject();</span><br><span class="line">    System.out.println(dog1);</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastDFS 分布式文件系统</title>
      <link href="/2021/12/20/fastdfs/"/>
      <url>/2021/12/20/fastdfs/</url>
      
        <content type="html"><![CDATA[<h3 id="相关文件下载地址"><a href="#相关文件下载地址" class="headerlink" title="相关文件下载地址"></a>相关文件下载地址</h3><ul><li>fastdfs、libfastcommon、fastdfs-nginx-module三个tar.gz包 :<code>https://github.com/happyfish100</code></li><li>nginx.tar.gz包: <code>http://nginx.org/en/download.html</code></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装C环境"><a href="#安装C环境" class="headerlink" title="安装C环境"></a>安装C环境</h4><ul><li>yum -y install gcc-c++</li></ul><h4 id="fastdfs依赖libevent库"><a href="#fastdfs依赖libevent库" class="headerlink" title="fastdfs依赖libevent库"></a>fastdfs依赖libevent库</h4><ul><li>yum -y install libevent</li></ul><h4 id="在服务器-x2F-usr-x2F-local-x2F-创建fastdfs文件夹，将下载的四个包放进这个目录"><a href="#在服务器-x2F-usr-x2F-local-x2F-创建fastdfs文件夹，将下载的四个包放进这个目录" class="headerlink" title="在服务器&#x2F;usr&#x2F;local&#x2F;创建fastdfs文件夹，将下载的四个包放进这个目录"></a>在服务器&#x2F;usr&#x2F;local&#x2F;创建fastdfs文件夹，将下载的四个包放进这个目录</h4><ul><li>mkdir &#x2F;usr&#x2F;local&#x2F;fastdfs</li></ul><h4 id="安装libfastcommon"><a href="#安装libfastcommon" class="headerlink" title="安装libfastcommon"></a>安装libfastcommon</h4><ul><li>tar -zxf libfastcommon-1.0.53.tar.gz    并进入libfastcommon-1.0.53目录</li><li>.&#x2F;make.sh</li><li>.&#x2F;make.sh install</li><li>cd &#x2F;usr&#x2F;lib64      -&gt;    cp libfastcommon.so &#x2F;usr&#x2F;lib&#x2F;</li><li>cd &#x2F;usr&#x2F;local&#x2F;fastdfs&#x2F;                rm -rf libfastcommon-1.0.53.tar.gz</li><li>tar -zxf fastdfs-6.07.tar.gz         rm -rf fastdfs-6.07.tar.gz</li><li>cd fastdfs-6.07    .&#x2F;make.sh    .&#x2F;make.sh install</li><li>cd conf               cp * &#x2F;etc&#x2F;fdfs&#x2F;</li></ul><h4 id="安装Tracker服务"><a href="#安装Tracker服务" class="headerlink" title="安装Tracker服务"></a>安装Tracker服务</h4><ul><li>cd fastdfs-6.07&#x2F;tracker&#x2F;         vim &#x2F;etc&#x2F;fdfs&#x2F;tracker.conf</li><li>修改<ul><li>base_path &#x3D; &#x2F;usr&#x2F;local&#x2F;fastdfs&#x2F;fastdfs-6.07&#x2F;tracker</li></ul></li><li>启动<ul><li>&#x2F;usr&#x2F;bin&#x2F;fdfs_trackerd &#x2F;etc&#x2F;fdfs&#x2F;tracker.conf</li></ul></li><li>重启<ul><li>&#x2F;usr&#x2F;bin&#x2F;fdfs_trackerd &#x2F;etc&#x2F;fdfs&#x2F;tracker.conf restart</li></ul></li></ul><h4 id="安装Storage服务"><a href="#安装Storage服务" class="headerlink" title="安装Storage服务"></a>安装Storage服务</h4><ul><li>cd ..&#x2F;storage&#x2F;        vim &#x2F;etc&#x2F;fdfs&#x2F;storage.conf<ul><li>base_path &#x3D; &#x2F;usr&#x2F;local&#x2F;fastdfs&#x2F;fastdfs-6.07&#x2F;storage</li><li>store_path0 &#x3D; &#x2F;usr&#x2F;local&#x2F;fastdfs&#x2F;fastdfs-6.07&#x2F;storage</li><li>tracker_server &#x3D; 121.199.16.28:22122</li></ul></li><li>启动<ul><li>&#x2F;usr&#x2F;bin&#x2F;fdfs_storaged &#x2F;etc&#x2F;fdfs&#x2F;storage.conf</li></ul></li></ul><h4 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h4><ul><li>cd &#x2F;usr&#x2F;local&#x2F;fastdfs&#x2F;fastdfs-6.07&#x2F;client&#x2F;         cp libfdfsclient.so &#x2F;usr&#x2F;lib</li><li>修改<ul><li>vim &#x2F;etc&#x2F;fdfs&#x2F;client.conf</li><li>base_path &#x3D; &#x2F;usr&#x2F;local&#x2F;fastdfs&#x2F;fastdfs-6.07&#x2F;client</li><li>tracker_server &#x3D; 121.199.16.28:22122</li></ul></li><li>测试<ul><li>vim &#x2F;home&#x2F;test.txt</li></ul></li><li>上传<ul><li>&#x2F;usr&#x2F;bin&#x2F;fdfs_test &#x2F;etc&#x2F;fdfs&#x2F;client.conf upload &#x2F;home&#x2F;test.txt</li></ul></li></ul><h4 id="防火墙开端口"><a href="#防火墙开端口" class="headerlink" title="防火墙开端口"></a>防火墙开端口</h4><ul><li>firewall-cmd –zone&#x3D;public –add-port&#x3D;23000&#x2F;tcp –permanent</li></ul><h4 id="重启防火墙"><a href="#重启防火墙" class="headerlink" title="重启防火墙"></a>重启防火墙</h4><ul><li>systemctl restart firewalld.service</li></ul><h4 id="安装nginx依赖"><a href="#安装nginx依赖" class="headerlink" title="安装nginx依赖"></a>安装nginx依赖</h4><ul><li>yum install -y pcre pcre-devel zlib zlib-devel openssl openssl-devel</li></ul><h4 id="安装nginx和fastdfs插件"><a href="#安装nginx和fastdfs插件" class="headerlink" title="安装nginx和fastdfs插件"></a>安装nginx和fastdfs插件</h4><ul><li>tar -zxf fastdfs-nginx-module-1.22.tar.gz</li><li>cd fastdfs-nginx-module-1.22&#x2F;src                         vim config</li><li>:%s&#x2F;local/&#x2F;&#x2F;g</li><li>cp mod_fastdfs.conf &#x2F;etc&#x2F;fdfs&#x2F;               vim&#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf</li><li>修改<ul><li>tracker_server&#x3D;121.199.16.28:22122</li><li>url_have_group_name &#x3D; true</li><li>store_path0&#x3D;&#x2F;usr&#x2F;local&#x2F;fastdfs&#x2F;fastdfs-6.07&#x2F;storage</li></ul></li></ul><h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h4><ul><li>tar -zxf nginx-release-1.20.2.tar.gz        cd nginx-release-1.20.2</li><li>.&#x2F;configure –add-module&#x3D;&#x2F;usr&#x2F;local&#x2F;fastdfs&#x2F;fastdfs-nginx-module-1.22&#x2F;src</li><li>make</li><li>make install</li><li>cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;config              vim nginx.conf</li><li>添加<ul><li>location &#x2F;group1&#x2F;M00&#x2F; {<br>ngx_fastdfs_module;<br>}</li></ul></li><li>启动nginx<ul><li>cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin    .&#x2F;nginx</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 文件系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch Linux</title>
      <link href="/2021/12/14/archlinux/"/>
      <url>/2021/12/14/archlinux/</url>
      
        <content type="html"><![CDATA[<blockquote><p>对下载的镜像进行MD5校验</p></blockquote><p><code>md5sum archlinux-202x.0x.01-x86_64.iso</code></p><blockquote><p>passwd    修改密码</p></blockquote><blockquote><p>iwctl          联网</p></blockquote><p><code>device list</code> 查看网卡</p><p><code>station wlan0 scan</code> 扫描</p><p><code>station wlan0 get-networks</code> 列出所有网络</p><p><code>station wlan0 connect 网络名</code></p><p>测试 ping <a href="http://www.archlinux.org/">www.archlinux.org</a></p><blockquote><p>systemctl stop reflector.service    禁用 reflector</p></blockquote><blockquote><p>ls &#x2F;sys&#x2F;firmware&#x2F;efi&#x2F;efivars&#x2F;          验证启动模式</p></blockquote><blockquote><p>timedatectl set-ntp true                 同步时间    不然后面没法下载东西</p></blockquote><blockquote><p>lsblk                                                   查看磁盘设备</p></blockquote><blockquote><p>gdisk &#x2F;dev&#x2F;sda                                 清盘</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # timedatectl set-ntp true</span><br><span class="line">root@archiso ~ # lsblk</span><br><span class="line">NAME  MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">loop0   7:0    0 662.7M  1 loop /run/archiso/airootfs</span><br><span class="line">sda     8:0    0    64G  0 disk </span><br><span class="line">sr0    11:0    1 832.3M  0 rom  /run/archiso/bootmnt</span><br><span class="line">root@archiso ~ # gdisk /dev/sda</span><br><span class="line">GPT fdisk (gdisk) version 1.0.8</span><br><span class="line"></span><br><span class="line">Partition table scan:</span><br><span class="line">  MBR: not present</span><br><span class="line">  BSD: not present</span><br><span class="line">  APM: not present</span><br><span class="line">  GPT: not present</span><br><span class="line"></span><br><span class="line">Creating new GPT entries in memory.</span><br><span class="line"></span><br><span class="line">Command (? for help): x</span><br><span class="line"></span><br><span class="line">Expert command (? for help): z</span><br><span class="line">About to wipe out GPT on /dev/sda. Proceed? (Y/N): y</span><br><span class="line">GPT data structures destroyed! You may now partition the disk using fdisk or</span><br><span class="line">other utilities.</span><br><span class="line">Blank out MBR? (Y/N): y</span><br></pre></td></tr></table></figure><blockquote><p>cgdisk &#x2F;dev&#x2F;sda             磁盘分区</p></blockquote><p>new   -&gt;   回车  -&gt;   1G    -&gt;     ef00    -&gt;    boot</p><p>new         回车         8G             8200          swap</p><p>new         回车         20              8300          root</p><p>new         回车         35               8300         home</p><p>write  -&gt;   yes   -&gt;   quit</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # cgdisk /dev/sda</span><br><span class="line">Type search string, or &lt;Enter&gt; to show all codes: efi</span><br><span class="line">ef00 EFI system partition                </span><br><span class="line"></span><br><span class="line">Press the &lt;Enter&gt; key to continue: </span><br><span class="line">root@archiso ~ # lsblk</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">loop0    7:0    0 662.7M  1 loop /run/archiso/airootfs</span><br><span class="line">sda      8:0    0    64G  0 disk </span><br><span class="line">├─sda1   8:1    0     1G  0 part </span><br><span class="line">├─sda2   8:2    0     8G  0 part </span><br><span class="line">├─sda3   8:3    0    20G  0 part </span><br><span class="line">└─sda4   8:4    0    35G  0 part </span><br><span class="line">sr0     11:0    1 832.3M  0 rom  /run/archiso/bootmnt</span><br><span class="line">root@archiso ~ # </span><br></pre></td></tr></table></figure><blockquote><p>创建文件系统  格式化分区</p></blockquote><ul><li>启动分区,  <code>mkfs.fat -F32 /dev/sda1</code></li><li>交换分区，<code>mkswap /dev/sda2</code>   启用swap分区：<code>swapon /dev/sda2</code></li><li>系统分区，<code>mkfs.ext4 /dev/sda3</code></li><li>用户分区，<code>mkfs.ext4 /dev/sda4</code></li></ul><blockquote><p>挂载分区</p></blockquote><ul><li><p>挂载系统分区    <code>mount /dev/sda3 /mnt</code></p></li><li><p>挂载启动分区    <code>mkdir /mnt/boot</code>   <code>mount /dev/sda1 /mnt/boot</code></p></li><li><p>挂载用户分区    <code>mkdir /mnt/home</code>   <code>mount /dev/sda4 /mnt/home</code></p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # mount /dev/sda3 /mnt</span><br><span class="line">root@archiso ~ # mkdir /mnt/boot</span><br><span class="line">root@archiso ~ # mount /dev/sda1 /mnt/boot</span><br><span class="line">root@archiso ~ # mkdir /mnt/home</span><br><span class="line">root@archiso ~ # mount /dev/sda4 /mnt/home</span><br><span class="line">root@archiso ~ # lsblk</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">loop0    7:0    0 662.7M  1 loop /run/archiso/airootfs</span><br><span class="line">sda      8:0    0    64G  0 disk </span><br><span class="line">├─sda1   8:1    0     1G  0 part /mnt/boot</span><br><span class="line">├─sda2   8:2    0     8G  0 part [SWAP]</span><br><span class="line">├─sda3   8:3    0    20G  0 part /mnt</span><br><span class="line">└─sda4   8:4    0    35G  0 part /mnt/home</span><br><span class="line">sr0     11:0    1 832.3M  0 rom  /run/archiso/bootmnt</span><br></pre></td></tr></table></figure><blockquote><p>设置pacman服务器</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">直接切换为中国的软件包</span><br><span class="line">curl -L -o /etc/pacman.d/mirrorlist &quot;https://archlinux.org/mirrorlist/?country=CN&quot;</span><br><span class="line">然后编辑/etc/pacman.d/mirrorlist，反注释其中一个或多个链接。</span><br><span class="line"></span><br><span class="line">root@archiso ~ # nano /etc/pacman.d/mirrorlist </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步</span></span><br><span class="line">root@archiso ~ # pacman -Sy               </span><br><span class="line">:: Synchronizing package databases...</span><br><span class="line"> core                                   136.1 KiB  69.2 KiB/s 00:02 [#####################################] 100%</span><br><span class="line"> extra                                 1586.3 KiB  1164 KiB/s 00:01 [#####################################] 100%</span><br><span class="line"> community                                5.8 MiB  3.18 MiB/s 00:02 [#####################################] 100</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份</span></span><br><span class="line">root@archiso ~ # cp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.backup    </span><br><span class="line">root@archiso ~ # reflector --verbose --latest 15 --sort rate --save /etc/pacman.d/mirrorlist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server = http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = http://mirrors.163.com/archlinux/$repo/os/$arch</span><br><span class="line">Server = http://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = http://mirrors.zju.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = http://mirrors.cqu.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = http://mirrors.lzu.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line">Server = http://mirrors.neusoft.edu.cn/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure><blockquote><p>安装基本系统及固件</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@archiso ~ # pacstrap -i /mnt linux linux-headers linux-firmware base base-devel vim nano intel-ucode</span><br><span class="line">root@archiso ~ # genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><blockquote><p>进入系统</p></blockquote><p><code>arch-chroot /mnt</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@archiso /]# pacman -Syy</span><br><span class="line">:: Synchronizing package databases...</span><br><span class="line"> core                                   136.1 KiB   560 KiB/s 00:00 [######################################] 100%</span><br><span class="line"> extra                                 1586.3 KiB  6.65 MiB/s 00:00 [######################################] 100%</span><br><span class="line"> community                                5.8 MiB  33.1 MiB/s 00:00 [######################################] 100%</span><br></pre></td></tr></table></figure><blockquote><p>配置系统时区</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure><blockquote><p>本地化&#x2F;语言配置</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/locale.gen</span><br><span class="line">[root@archiso /]# locale-gen</span><br><span class="line">Generating locales...</span><br><span class="line">  en_US.UTF-8... done</span><br><span class="line">  zh_CN.UTF-8... done</span><br><span class="line">Generation complete.</span><br><span class="line">[root@archiso /]# echo LANG=en_US.UTF-8 &gt; /etc/locale.conf</span><br><span class="line">[root@archiso /]# nano /etc/locale.conf</span><br><span class="line">[root@archiso /]# nano /etc/locale.conf</span><br><span class="line">[root@archiso /]# export LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure><blockquote><p>网络配置</p></blockquote><ul><li>修改hostname文件   <code>nano /etc/hostname</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELL</span><br></pre></td></tr></table></figure><ul><li>修改hosts文件   <code>nano /etc/hosts</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1localhost</span><br><span class="line">::1localhost</span><br><span class="line">127.0.1.1DELL.localdomainDELL # 主机名.本地域名 主机名</span><br></pre></td></tr></table></figure><blockquote><p>添加用户</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加用户</span></span><br><span class="line">useradd -m -g users -G wheel,storage,power -s /bin/bash username</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改用户密码</span></span><br><span class="line">passwd username</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改root用户密码</span></span><br><span class="line">passwd root</span><br></pre></td></tr></table></figure><blockquote><p>添加用户权限</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EDITOR=nano visudo</span><br><span class="line"></span><br><span class="line">去掉 #%wheel ALL=(ALL) ALL 前面的#号</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在最后一行添加默认管理员密码</span></span><br><span class="line">Defaults rootpw</span><br></pre></td></tr></table></figure><blockquote><p>安装grub</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载grub安装需要的文件</span></span><br><span class="line">pacman -S grub efibootmgr intel-ucode os-prober</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看系统架构</span></span><br><span class="line">uname -m     // x86_64</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装grub</span></span><br><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成主配置文件</span></span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><blockquote><p>安装和配置Systemd启动器</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">bootctl install</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nano /boot/loader/entries/arch.conf</span></span><br><span class="line">title My Arch Linux</span><br><span class="line">linux /vmlinuz-linux   # 长期自持内核(vm linuz-linux-lts)</span><br><span class="line">initrd /intel-ucode.img</span><br><span class="line">initrd /initramfs-linux.img</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;optinos root=PARTUUID=<span class="subst">$(blkid -s PARTUUID -o value /dev/sda3)</span> rw&quot;</span> &gt;&gt; /boot/loader/entries/arch.conf</span></span><br></pre></td></tr></table></figure><blockquote><p>systemctl enable fstrim.timer</p></blockquote><blockquote><p>开启32位应用支持</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nano /etc/pacman.conf</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去掉下面两行的前面的 <span class="comment"># 号</span></span></span><br><span class="line">[multilib]</span><br><span class="line">Include = /etc/pacman.d/mirrorlist</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加archlinuxcn源   在最后面加</span></span><br><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel = TrustAll</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步一下</span></span><br><span class="line">pacman -Syy</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装archlinux密钥环</span></span><br><span class="line">pacman -S archlinuxcn-keyring</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果报错就按顺序执行下面的操作</span></span><br><span class="line">pacman -Syu haveged</span><br><span class="line">systemctl start haveged</span><br><span class="line">systemctl enable haveged</span><br><span class="line"></span><br><span class="line">rm -fr /etc/pacman.d/gnupg</span><br><span class="line">pacman-key --init</span><br><span class="line">pacman-key --populate archlinux</span><br><span class="line">pacman-key --populate archlinuxcn</span><br></pre></td></tr></table></figure><blockquote><p>安装网络，声音，蓝牙，文件管理后台</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">网络</span></span><br><span class="line">pacman -S networkmanager network-manager-applet dialog wpa_supplicant dhcpcd </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">systemctl enable NetworkManager</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">蓝牙   文件管理等</span></span><br><span class="line">pacman -S mtools dosfstools bluez bluez-utils cups xdg-utils xdg-user-dirs alsa-utils pulseaudio pulseaudio-bluetooth reflector openssh</span><br></pre></td></tr></table></figure><blockquote><p><strong>安装显卡</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行如下命令查询显卡类型</span></span><br><span class="line">lspci | grep -e VGA -e 3D</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有开源驱动</span></span><br><span class="line">pacman -Ss xf86-video</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">英特尔显卡</span></span><br><span class="line">pacman -S xf86-video-intel mesa lib32-mesa</span><br><span class="line">pacman -S mesa lib32-mesa vulkan-intel lib32-vulkan-intel</span><br><span class="line">pacman -S mesa lib32-mesa vulkan-intel lib32-vulkan-intel</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AMD 显卡</span></span><br><span class="line">pacman -S xf86-video-amdgpu lib32-vulkan-radeon libva-mesa-driver lib32-mesa-driver</span><br><span class="line">mesa-vdpau lib32-mesa-vdpau</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Nvidia 显卡</span></span><br><span class="line">pacman -S nvidia dkms libglvnd lib32-libglvnd nvidia-utils lib32-nvidia-utils opencl-nvidia lib32-opencl-nvidia nvidia-settings</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">双显卡切换</span></span><br><span class="line">yay -S optimus-manager optimus-manager-qt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以用命令切换显卡</span></span><br><span class="line">optimus-manager --switch nvidia</span><br><span class="line">optimus-manager --switch integrated</span><br><span class="line">optimus-manager --switch hybrid</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以用 optimus-manager-qt 提供的图形界面切换</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Pacman钩子</strong> 为了避免更新 NVIDIA 驱动之后忘了更新initramfs</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nano /etc/mkinitcpio.conf</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在MODULES=() 中按顺序添加</span></span><br><span class="line">MODULES=(nvidia nvidia_modeset nvidia_uvm nvidia_drm)</span><br><span class="line"></span><br><span class="line">mkdir /etc/pacman.d/hooks</span><br><span class="line">nano /etc/pacman.d/hooks/nvidia.hook</span><br><span class="line">[Trigger]</span><br><span class="line">Operation=Install</span><br><span class="line">Operation=Upgrade</span><br><span class="line">Operation=Remove</span><br><span class="line">Type=Package</span><br><span class="line">Target=nvidia</span><br><span class="line">Target=linux</span><br><span class="line"></span><br><span class="line">[Action]</span><br><span class="line">Depends=mkinitcpio</span><br><span class="line">When=PostTransaction</span><br><span class="line">Exec=/usr/bin/mkinitcpio -P</span><br></pre></td></tr></table></figure><p>回去改启动器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">systemd启动器</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nano /boot/loader/entries/arch.conf</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 options 的rw后面接上 nvidia-drm.modeset=1</span></span><br><span class="line">options        root=PARTUUID=14420948-2cea-4de7-b042-40f67c618660 rw nvidia-drm.modeset=1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">grub启动器</span></span><br><span class="line">nano /etc/default/grub</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">&quot;loglevel=3 quiet&quot;</span>后面加上nvidia-drm.modeset=1</span></span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;loglevel=3 quiet nvidia-drm.modeset=1&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新生成配置文件</span></span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><blockquote><p>安装xorg窗口系统</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S xorg-server xorg-apps xorg-xinit xorg-twm xorg-xclock xterm</span><br></pre></td></tr></table></figure><p>测试  <code>startx</code></p><blockquote><p>安装KDE桌面</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S sddm plasma</span><br><span class="line">systemctl enable sddm</span><br></pre></td></tr></table></figure><blockquote><p>最后exit   -&gt; umount -R &#x2F;mnt  -&gt;reboot</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装英文和中文字体</span></span><br><span class="line">sudo pacman -S ttf-dejavu wqy-microhei</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统配置中文</span></span><br><span class="line">系统设置 -&gt; Regional Settings -&gt; Language -&gt; add languages -&gt; 简体中文 -&gt; 置顶</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装中文输入法</span></span><br><span class="line">sudo pacman -S fcitx fcitx-im kcm-fcitx fcitx-googlepinyin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置fcitx环境变量</span></span><br><span class="line">sudo nano .pam_environment</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">fcitx</span></span><br><span class="line">GTK_IM_MODULE DEFAULT=fcitx</span><br><span class="line">QT_IM_MODULE  DEFAULT=fcitx</span><br><span class="line">XMODIFIERS    DEFAULT=\@im=fcitx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装文件管理器 文本/代码编辑器 下拉命令行 分区管理器 k易连</span> </span><br><span class="line">sudo pacman -S dolphin kate yakuake partitionmanager kdeconnect </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装zsh</span></span><br><span class="line">sudo pacman -S zsh zsh-completions</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将zsh设为默认shell</span></span><br><span class="line">sudo chsh -s /bin/zsh zhangjian(用户名)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载oh my zsh</span></span><br><span class="line">sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置主题</span></span><br><span class="line">nano .zshrc</span><br><span class="line">ZSH_THEME=&quot;crcandy&quot;</span><br></pre></td></tr></table></figure><blockquote><p>java，maven环境</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># JDK1<span class="number">.8</span></span><br><span class="line">JAVA_HOME=/opt/jdk1<span class="number">.8</span><span class="number">.0_301</span></span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"></span><br><span class="line"># Maven</span><br><span class="line">MAVEN_HOME=/usr/local/apache-maven-<span class="number">3.8</span><span class="number">.2</span></span><br><span class="line">export MAVEN_HOME</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;/bin</span><br></pre></td></tr></table></figure><h3 id="pacman命令"><a href="#pacman命令" class="headerlink" title="pacman命令"></a>pacman命令</h3><ul><li><p>安装指定包<code>pacman -S 包名</code>   –needed会覆盖之前安装的包依赖</p></li><li><p>删除软件包</p><ul><li>删除单个软件包，并保留其全部已安装的依赖关系 <code>pacman -R 包名</code></li><li>删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系 <code>pacman -Rs 包名</code></li><li>删除软件包和所有依赖这个软件包的程序 <code>pacman -Rsc 包名</code></li><li>删除一个被其他软件包依赖的软件包，但是不删除依赖这个软件包的其他软件包 <code>pacman -Rdd 包名</code></li><li>删除某些程序是会备份重要配置文件，在其后面加上*.pacsave扩展名。-n选项可以避免备份这些文件 <code>pacman -Rn 包名</code></li></ul></li><li><p>升级包 <code>pacman -Syu</code></p></li><li><p>查询包数据库</p><ul><li>在包数据库中查询软件包，查询位置包含了软件包的名字和描述<code>pacman -Ss string1 string2 ...</code></li><li>查询已安装的软件包  <code>pacman -Qs string1 string2 ...</code></li><li>按文件名查找软件库  <code>pacman -F string1 string2 ...</code></li><li>显示软件包的详尽的信息  <code>pacman -Si package_name</code></li><li>查询本地安装包的详细信息  <code>pacman -Qi package_name</code></li><li>使用两个 <code>-i</code> 将同时显示备份文件和修改状态  <code>pacman -Qii package_name</code></li><li>要获取已安装软件包所包含文件的列表  <code>pacman -Ql package_name</code></li><li>查询远程库中软件包包含的文件  <code>pacman -Fl package_name</code></li><li>检查软件包安装的文件是否都存在  <code>pacman -Qk package_name</code></li><li>两个参数<code>k</code>将会执行一次更彻底的检查。 查询数据库获取某个文件属于哪个软件包  <code>pacman -Qo /path/to/file_name</code></li><li>查询文件属于远程数据库中的哪个软件包  <code>pacman -F /path/to/file_name</code></li><li>罗列所有不再作为依赖的软件包(孤立orphans)  <code>pacman -Qdt</code></li><li>要罗列所有明确安装而且不被其它包依赖的软件包  <code>pacman -Qet</code></li><li>要显示软件包的依赖树  <code>pactree package_name</code></li></ul></li><li><p>其他命令</p><ul><li><p>升级系统时安装其他软件包  <code>pacman -Syu package_name1 package_name2 ...</code></p></li><li><p>下载包而不安装它  <code>pacman -Sw package_name</code></p></li><li><p>安装一个<strong>本地</strong>包(不从源里下载）  <code>pacman -U /path/to/package/package_name-version.pkg.tar.xz</code></p></li><li><p>要将本地包保存至缓存，可执行  <code>pacman -U file:///path/to/package/package_name-version.pkg.tar.xz</code></p></li><li><p>安装一个<strong>远程</strong>包（不在 <em>pacman</em> 配置的源里面）  <code>pacman -U http://www.example.com/repo/example.pkg.tar.xz</code></p></li></ul></li></ul><h3 id="Xorg"><a href="#Xorg" class="headerlink" title="Xorg"></a>Xorg</h3><p><a href="https://wiki.archlinux.org/title/Xorg_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">https://wiki.archlinux.org/title/Xorg_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 基础</title>
      <link href="/2021/11/14/jvm/"/>
      <url>/2021/11/14/jvm/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>其中类加载的过程包括了 <code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>五个阶段。在这五个阶段中，<code>加载</code>、<code>验证</code>、<code>准备</code>和<code>初始化</code>这四个阶段发生的顺序是确定的，而<code>解析</code>阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或者晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><p><img src="http://1.117.162.142:9000/blog/image-20220331134854285.png" alt="image-20220331134854285"></p><h3 id="类的加载：查找并加载类的二进制数据"><a href="#类的加载：查找并加载类的二进制数据" class="headerlink" title="类的加载：查找并加载类的二进制数据"></a>类的加载：查找并加载类的二进制数据</h3><p>加载是类加载过程的第一阶段，在加载阶段，虚拟机需要完成以下三件事情：</p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在 Java 堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。</li></ul><p><img src="http://1.117.162.142:9000/blog/image-20220331145507548.png" alt="image-20220331145507548"></p><p>相对于类加载的其他阶段而言，加载阶段(准确的说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在 Java 堆中也创建一个 java.lang.Class 类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p>类加载器并不需要等到某个类被”首次主动使用”时再加载它，JVM 规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了 .class 文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError)如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><blockquote><p>加载 .class 文件的方式</p></blockquote><ul><li>从本地系统中直接加载</li><li>通过网络下载 .class 文件</li><li>从 zip、jar 等归档文件中加载 .class 文件</li><li>从专有数据库中提取 .class 文件</li><li>将 java 源文件动态编译为 .class 文件</li></ul><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证：确保被加载的类的正确性"><a href="#验证：确保被加载的类的正确性" class="headerlink" title="验证：确保被加载的类的正确性"></a><u>验证：确保被加载的类的正确性</u></h4><p>验证时连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><ul><li><code>文件格式验证</code>：验证字节流是否符合 Class 文件格式的规范；例如：是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li><code>元数据验证</code>：对字节码描述的信息进行语义分析(注意：对比 <code>javac</code>编译阶段的语义分析)，以保证其描述的信息符合 Java 语言规范的要求；例如：这个类是否有父类，除了<code>java.lang.Object</code>之外。</li><li><code>字节验证码</code>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li><code>符号引用验证</code>：确保解析动作能正确执行。</li></ul><blockquote><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p></blockquote><h4 id="准备：为类的静态变量分配内存，并将其初始化为默认值"><a href="#准备：为类的静态变量分配内存，并将其初始化为默认值" class="headerlink" title="准备：为类的静态变量分配内存，并将其初始化为默认值"></a><u>准备：为类的静态变量分配内存，并将其初始化为默认值</u></h4><p>准备阶段是正式为类变量分配内存并设置类变量初始化值的阶段，<strong>这些内存都将在方法去区中分配</strong>。对于该阶段有以下几点需要注意：</p><ul><li>这时候进行内存分配的仅包括类变量(<code>static</code>)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>这里所设置的初始值通常情况下是数据类型默认的零值(如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等)，而不是被在 Java 代码中被显示地赋予的值。</li><li>假设一个类变量的定义为：<code>public static int value = 3;</code>那么变量 value 在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 3 的 <code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit()&gt;</code>方法之中的，所以把 value 赋值为 3 的动作将在初始化阶段才会执行。</li></ul><blockquote><p>这里还需要注意如下几点</p></blockquote><ul><li><p>对基本数据类型来说，对于类变量(static)和全局变量，如果不显示地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显示地为其赋值，否则编译时不通过。</p><ul><li>对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显示地赋值，否则编译时不通过；而只被 final 修饰的常量则既可以在声明时显示地为其赋值，也可以在类初始化时显示地为其赋值，总之，在使用前必须为其显示地赋值，系统不会为其赋予默认零值。</li><li>对于引用数据类型<code>reference</code>来说，如数组引用、对象引用等，如果没有对其进行显示地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。</li><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li><li>如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。假设上面的类变量 value 被定义为：<code>public static final int value = 3;</code>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 3。我们可以理解为<code>static final</code>常量在编译器就将其结果放入了调用它的类的常量池中。</li></ul><h4 id="解析：把类中的符号引用转换为直接引用"><a href="#解析：把类中的符号引用转换为直接引用" class="headerlink" title="解析：把类中的符号引用转换为直接引用"></a><u>解析：把类中的符号引用转换为直接引用</u></h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点</code>限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p><p><code>直接引用</code>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM 负责对类进行初始值，主要对类变量进行初始化。在 Java 中对类变量进行初始值设定有两种方式：</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul><p><strong>JVM 初始化步骤</strong></p><ul><li>假设这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统一次执行这些初始化语句</li></ul><p><strong>类初始化时机</strong>：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p><ul><li>创建类的实例，也就是 new 的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射(如Class.forName(“com.donkey.jvm.Test”))</li><li>初始化某个类的子类，则其父类也会被初始化</li><li>Java 虚拟机启动时被标明为启动类的类(Java Test)，直接使用 java.exe 命令来运行某个主类</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>类访问方法区的数据结构的接口，对象是 Heap 区的数据。</p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p><strong>Java 虚拟机将结束生命周期的集中情况</strong></p><ul><li>执行了 System.exit() 方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致 Java 虚拟机进程终止</li></ul><h2 id="类加载器，JVM-类加载机制"><a href="#类加载器，JVM-类加载机制" class="headerlink" title="类加载器，JVM 类加载机制"></a>类加载器，JVM 类加载机制</h2><h3 id="类加载器的层次"><a href="#类加载器的层次" class="headerlink" title="类加载器的层次"></a>类加载器的层次</h3><p><img src="http://1.117.162.142:9000/blog/java_jvm_classload_3.png"></p><blockquote><p>注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p></blockquote><blockquote><p>站在 Java 虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：他使用 C++ 实现(这里仅限于<code>Hotspot</code>，也就是 JDK1.5之后默认的虚拟机，有很多其他的虚拟机使用 Java 语言实现的)，是虚拟机自身的一部分；所有其他的类加载器：这些类加载器都由 Java 语言实现，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p></blockquote><p><strong>站在 Java 开发人员的角度来看，类加载器可以大致划分为以下三类：</strong></p><p><code>启动类加载器</code>：Bootstrap ClassLoader，负责加载存放在 JDK\jre\lib(JDK 代表 JDK 的安装目录，下同)下，或被 -Xbootclasspath 参数指定的路径中，并且能被虚拟机识别的类库(如 rt.jar，所有的 java.* 开头的类均被 Bootstrap ClassLoader 加载)。启动类加载器是无法被 Java 程序直接引用的。</p><p><code>扩展类加载器</code>：Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载 JDK\jre\lib\ext 目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。</p><p><code>应用程序类加载器</code>: Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为 JVM 自带的 ClassLoader 只是懂得从本地文件系统加载标准的 java class 文件，因此如果编写了自己的 ClassLoader，便可以做到如下几点：</p><ul><li>在执行置信代码之前，自动验证数字签名。</li><li>动态地创建符合用户特定需要的定制化构建类。</li><li>从特定的场所取得 java class，例如数据库中和网络中。</li></ul><h3 id="寻找类加载器"><a href="#寻找类加载器" class="headerlink" title="寻找类加载器"></a>寻找类加载器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@64fef26a</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1ddd40f3</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>从上面的结果可以看出，并没有获取到<code>ExtClassLoader</code>的父 Loader，原因是<code>Bootstrap</code>(引导类加载器)是用 C 语言实现的，找不到一个确定的返回父 Loader 的方式，于是就返回 <code>null</code>。</p><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><p>类加载有三种方式：</p><ol><li>命令行启动应用时由 JVM 初始化加载</li><li>通过 Class.forName() 方法动态加载</li><li>通过 ClassLoader.loadClass() 方法动态加载</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">loaderTest</span> &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123; </span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> HelloWorld.class.getClassLoader(); </span><br><span class="line">                System.out.println(loader); </span><br><span class="line">                <span class="comment">//使用ClassLoader.loadClass()来加载类，不会执行初始化块 </span></span><br><span class="line">                loader.loadClass(<span class="string">&quot;Test2&quot;</span>); </span><br><span class="line">                <span class="comment">//使用Class.forName()来加载类，默认会执行初始化块 </span></span><br><span class="line"><span class="comment">//                Class.forName(&quot;Test2&quot;); </span></span><br><span class="line">                <span class="comment">//使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 </span></span><br><span class="line"><span class="comment">//                Class.forName(&quot;Test2&quot;, false, loader); </span></span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123; </span><br><span class="line">        <span class="keyword">static</span> &#123; </span><br><span class="line">                System.out.println(<span class="string">&quot;静态初始化块执行了！&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别切换加载方式，会有不同的输出结果。</p><blockquote><p>Class.forName() 和 ClassLoader.loadClass() 区别？</p></blockquote><ul><li>Class.forName(): 将类的 .class 文件加载到 jvm 中之外，还会对类进行解释，执行类中的 static 块；</li><li>ClassLoader.loadClass(): 只干一件事情，就是将 .class 文件加载到 jvm 中，不会执行 static 中的内容,只有在 newInstance 才会去执行static块。</li><li>Class.forName(name, initialize, loader)带参函数也可控制是否加载 static 块。并且只有调用了 newInstance() 方法采用调用构造函数，创建类的对象 。</li></ul><h2 id="JVM-类加载机制"><a href="#JVM-类加载机制" class="headerlink" title="JVM 类加载机制"></a>JVM 类加载机制</h2><ul><li><p><code>全盘负责</code>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p></li><li><p><code>父类委托</code>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p></li><li><p><code>缓存机制</code>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p></li><li><p><code>双亲委派机制</code>, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p></li></ul><p><strong>双亲委派机制过程？</strong></p><ol><li><p>当 AppClassLoader 加载一个 class 时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器 ExtClassLoader 去完成。</p></li><li><p>当 ExtClassLoader 加载一个 class 时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给 BootStrapClassLoader 去完成。</p></li><li><p>如果 BootStrapClassLoader 加载失败(例如在 $JAVA_HOME&#x2F;jre&#x2F;lib 里未查找到该 class)，会使用 ExtClassLoader 来尝试加载；</p></li><li><p>若 ExtClassLoader 也加载失败，则会使用 AppClassLoader 来加载，如果 AppClassLoader 也加载失败，则会报出异常ClassNotFoundException。</p></li></ol><p>​    <strong>双亲委派代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name)<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="comment">// 首先判断该类型是否已经被加载</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                         <span class="comment">//如果存在父类加载器，就委派给父类加载器加载</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</span></span><br><span class="line">                        c = findBootstrapClass0(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                 <span class="comment">// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>双亲委派优势</strong></p><ul><li>系统类防止内存中出现多份同样的字节码。</li><li>保证 Java 程序安全稳定运行</li></ul><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类，从上面 loadClass 方法分析来看，我们只需要重写 findClass 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">byte</span>[] classData = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> root + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[bufferSize];</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(String root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>();</span><br><span class="line">        classLoader.setRoot(<span class="string">&quot;D:\\temp&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; testClass = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testClass = classLoader.loadClass(<span class="string">&quot;com.pdai.jvm.classloader.Test2&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> testClass.newInstance();</span><br><span class="line">            System.out.println(object.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，并未对 class 文件进行加密，因此没有解密的过程。</p><p><strong>这里有几点需要注意：</strong></p><ul><li>这里传递的文件名需要是类的全限定性名称，即<code>com.donkey.jvm.classloader.Test2</code>格式的，因为 defineClass 方法是按这种格式进行处理的。</li><li>最好不要重写 loadClass 方法，因为这样容易破坏双亲委托模式。</li><li>这类 Test 类本身可以被 AppClassLoader 类加载，因此我们不能把 com.donkey.jvm.classloader.Test2 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader 加载，而不会通过我们自定义类加载器来加载。</li></ul><h1 id="JVM-垃圾回收机制"><a href="#JVM-垃圾回收机制" class="headerlink" title="JVM 垃圾回收机制"></a>JVM 垃圾回收机制</h1><h2 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h2><h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1. 引用计数算法"></a>1. 引用计数算法</h3><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加1，引用失效时计数器减1。引用计数器为0的对象可被回收。</p><p>两个对象出现循环引用的情况下，此时引用计数器永远不为0，导致无法对它们进行回收。</p><p>正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objectB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        objectA.instance = objectB;</span><br><span class="line">        objectB.instance = objectA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h3><p>通过 GC Roots 作为起始点进行搜索，能够到达的对象都是存活的，不可达的对象可被回收。</p><p><img src="http://1.117.162.142:9000/blog/0635cbe8.png"></p><p>Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容：</p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><h3 id="3-方法区的回收"><a href="#3-方法区的回收" class="headerlink" title="3. 方法区的回收"></a>3. 方法区的回收</h3><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。</p><p>主要是对常量池的回收和对类的卸载。</p><p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。</p><p>类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：</p><ul><li>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ul><p>可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。</p><h3 id="4-finalize"><a href="#4-finalize" class="headerlink" title="4. finalize()"></a>4. finalize()</h3><p>finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p><p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判断对象是否可被回收都与引用有关。</p><p>Java 具有四种强度不同的引用类型。</p><h3 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h3><p>被强引用关联的对象不会被回收。</p><p>使用 new 一个新对象的方式来创建强引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><h3 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h3><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>使用 SoftReference 类来创建软引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">Softreference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure><h3 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h3><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>使用 WeakReference 类来实现弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h3><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。</p><p>为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。</p><p>使用 PhantomReference 来实现虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="1-标记-清除"><a href="#1-标记-清除" class="headerlink" title="1. 标记 - 清除"></a>1. 标记 - 清除</h3><p><img src="http://1.117.162.142:9000/blog/a4248c4b-6c1d-4fb8-a557-86da92d3a294.jpeg"></p><p>将存活的对象进行标记，然后清理掉未被标记的对象。</p><p>不足：</p><ul><li>标记和清除过程效率都不高；</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li></ul><h3 id="2-标记-整理"><a href="#2-标记-整理" class="headerlink" title="2. 标记 - 整理"></a>2. 标记 - 整理</h3><p><img src="http://1.117.162.142:9000/blog/902b83ab-8054-4bd2-898f-9a4a0fe52830.jpeg"></p><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h3 id="3-复制"><a href="#3-复制" class="headerlink" title="3. 复制"></a>3. 复制</h3><p><img src="http://1.117.162.142:9000/blog/e6b733ad-606d-4028-b3e8-83c3a73a3797.jpeg"></p><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p><p>主要不足时只使用了内存的一半。</p><p>现在的商业虚拟机都采用这种手机算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p><p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8 ：1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p><h3 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4. 分代收集"></a>4. 分代收集</h3><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p><p>一般将堆分为新生代和老年代。</p><ul><li>新生代使用：复制算法</li><li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="http://1.117.162.142:9000/blog/c625baa0-dde6-449e-93df-c3a67f2f430f.jpeg"></p><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><ul><li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；</li><li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul><h3 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h3><p><img src="http://1.117.162.142:9000/blog/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpeg"></p><p>Serial 翻译为串行，也就是说它以串行的方式执行。</p><p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p><p>它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p><h3 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. ParNew 收集器</h3><p><img src="http://1.117.162.142:9000/blog/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpeg"></p><p>它是 Serial 收集器的多线程版本。</p><p>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有他能与 CMS 收集器配合工作。</p><p>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p><h3 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. Parallel Scavenge 收集器</h3><p>与 ParNew 一样是多线程收集器。</p><p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为”吞吐量优先”收集器。这里的吞吐量是指 CPU 用于运行用户代码的时间占总时间的比值。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p><p>可以通过一个开关参数打开 GC 自适应的调节策略(GC Ergonomics)，就不需要手动置顶新生代的大小(-Xmn)、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数来。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p><h3 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4. Serial Old 收集器"></a>4. Serial Old 收集器</h3><p><img src="http://1.117.162.142:9000/blog/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpeg"></p><p>是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果在 Server 模式下，它有两大用途：</p><ul><li>在 JDK 1.5 以及之前版本(Parallel Old 诞生以前)中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ul><h3 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. Parallel Old 收集器</h3><p><img src="http://1.117.162.142:9000/blog/278fe431-af88-4a95-a895-9c3b80117de3.jpeg"></p><p>是 Parallel Scavenge 收集器的老年代版本。</p><p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p><h3 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h3><p><img src="http://1.117.162.142:9000/blog/62e77997-6957-4b68-8d12-bfd609bb2c68.jpeg"></p><p>CMS(Concurrent Mark Sweep)，Mark Sweep 指的是标记 - 清除算法。</p><p>分为以下四个流程：</p><ul><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ul><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p>具有一下缺点：</p><ul><li>吞吐量低: 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul><h3 id="7-G1-收集器"><a href="#7-G1-收集器" class="headerlink" title="7. G1 收集器"></a>7. G1 收集器</h3><p>G1(Garbage-First)，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p><p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p><p><img src="http://1.117.162.142:9000/blog/4cf711a8-7ab2-4152-b85c-d5c226733807.png"></p><p>G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。</p><p><img src="http://1.117.162.142:9000/blog/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png"></p><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p><img src="http://1.117.162.142:9000/blog/f99ee771-c56f-47fb-9148-c0036695b5fe.jpeg"></p><p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤:</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记: 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收: 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p>具备如下特点:</p><ul><li>空间整合: 整体来看是基于“标记 - 整理”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h3><p>JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。</p><p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full  GC）</p><ul><li>部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：<ul><li>新生代收集（Minor GC&#x2F;Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC&#x2F;Old GC）：只是老年代的垃圾收集<ul><li>目前，只有 CMS GC 会有单独收集老年代的行为</li><li>很多时候 Major GC 会和 Full GC  混合使用，需要具体分辨是老年代回收还是整堆回收</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集<ul><li>目前只有 G1 GC 会有这种行为</li></ul></li></ul></li><li>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾</li></ul><h3 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h3><h4 id="1-对象优先在-Eden-分配"><a href="#1-对象优先在-Eden-分配" class="headerlink" title="1. 对象优先在 Eden 分配"></a>1. 对象优先在 Eden 分配</h4><p>大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p><h4 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h4><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p><p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。</p><h4 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代"></a>3. 长期存活的对象进入老年代</h4><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p><p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p><h4 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h4><p>虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p><h4 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h4><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p><p>如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。</p><h3 id="Full-GC-的触发条件"><a href="#Full-GC-的触发条件" class="headerlink" title="Full GC 的触发条件"></a>Full GC 的触发条件</h3><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件:</p><h4 id="1-调用-System-gc"><a href="#1-调用-System-gc" class="headerlink" title="1. 调用 System.gc()"></a>1. 调用 System.gc()</h4><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><h4 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h4><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><h4 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3. 空间分配担保失败"></a>3. 空间分配担保失败</h4><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第五小节。</p><h4 id="4-JDK-1-7-及以前的永久代空间不足"><a href="#4-JDK-1-7-及以前的永久代空间不足" class="headerlink" title="4. JDK 1.7 及以前的永久代空间不足"></a>4. JDK 1.7 及以前的永久代空间不足</h4><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p><p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p><h4 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5. Concurrent Mode Failure"></a>5. Concurrent Mode Failure</h4><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC 并发编程</title>
      <link href="/2021/10/14/juc/"/>
      <url>/2021/10/14/juc/</url>
      
        <content type="html"><![CDATA[<h3 id="线程-和-进程"><a href="#线程-和-进程" class="headerlink" title="线程 和 进程"></a>线程 和 进程</h3><blockquote><p>Java不能直接使用线程，他是调用了本地native的start0()方法</p></blockquote><blockquote><p>线程的六种状态</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">//新建</span></span><br><span class="line">    NEW,</span><br><span class="line">    <span class="comment">//运行</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line">    <span class="comment">//阻塞</span></span><br><span class="line">    BLOCKED,</span><br><span class="line">    <span class="comment">//等待，死死的等</span></span><br><span class="line">    WAITING,</span><br><span class="line">    <span class="comment">//超时等待</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    <span class="comment">//终止</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>wait   sleep 区别</p></blockquote><ul><li><p>来自不同的类</p><ul><li>wait  &#x3D;&gt;  Object</li><li>sleep  &#x3D;&gt;  Thread</li></ul></li><li><p>关于锁的释放</p><p>wait 会释放锁，sleep 不会释放锁</p></li><li><p>使用范围不同</p><ul><li>wait 必须放在同步代码块中</li><li>sleep 在任何地方都可以</li></ul></li><li><p>是否需要捕获异常</p><ul><li>wait 不需要捕获异常</li><li>sleep 需要捕获异常</li></ul></li></ul><h3 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="Lock 锁"></a>Lock 锁</h3><blockquote><p>传统 synchronized</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//并发编程就是多个线程操作同一个资源    </span></span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) ticket.sale();&#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) ticket.sale();&#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) ticket.sale();&#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"><span class="comment">//synchronized 本质就是 队列，锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出了一张票，剩余&quot;</span> + (--number));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Lock 接口</p></blockquote><p>new ReentrantLock() 时，如果传入参数true，则为公平锁，如果传false或者不传，就为非公平锁。</p><p>&#x3D;&#x3D;默认是非公平锁。&#x3D;&#x3D;</p><p>公平锁：公平的，先来先执行</p><p>非公平锁：不公平的，可以插队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) ticket.sale();&#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) ticket.sale();&#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) ticket.sale();&#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Lock 三部曲</span></span><br><span class="line"><span class="comment">// 1、 new RenntrantLock()</span></span><br><span class="line"><span class="comment">// 2、 lock.lock()  加锁</span></span><br><span class="line"><span class="comment">// 3、 lock.unlock()  解锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();   <span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;          <span class="comment">//业务代码</span></span><br><span class="line">            <span class="keyword">if</span>(number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖出了一张票，剩余&quot;</span> + (--number));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();   <span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Synchronized 和 Lock 的区别</p></blockquote><ul><li>Synchronized 内置的java关键字，Lock 一个Java类</li><li>Synchronized 无法判断获取锁的状态，Lock 可以判断是否获取到了锁</li><li>Synchronized 会自动释放锁，Lock 必须要手动释放锁，如果不释放锁就是造成<strong>死锁</strong></li><li>Synchronized 假如线程1获得锁，然后阻塞了，线程2就会无线的等待下去；Lock 锁就不一定会等带下去</li><li>Synchronized 可重入锁，不可以中断锁，非公平；Lock 可重入锁，可以判断锁，非公平（可以自己设置）</li><li>Synchronized 适合锁少量的代码同步问题，Lock 适合锁大量的同步代码</li></ul><blockquote><p>锁是什么，如何判断锁的是谁！</p></blockquote><h3 id="生产者-和-消费者"><a href="#生产者-和-消费者" class="headerlink" title="生产者 和 消费者"></a>生产者 和 消费者</h3><blockquote><p>Synchronized 版生产者和消费者</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程间的通信问题 ：生产者和消费者问题   等待唤醒和通知唤醒</span></span><br><span class="line"><span class="comment"> * 线程交替执行    A B 操作同一变量   number = 0</span></span><br><span class="line"><span class="comment"> * A number + 1</span></span><br><span class="line"><span class="comment"> * B number - 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源类</span></span><br><span class="line"><span class="comment"> * 判断等待   业务     通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();  <span class="comment">// 等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();  <span class="comment">// 通知</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait(); <span class="comment">// 等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll(); <span class="comment">// 通知</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<img src="http://1.117.162.142:9000/blog/image-20210818095429555.png" alt="image-20210818095429555"></p><p>&#x3D;&#x3D;这样会产生的问题：&#x3D;&#x3D;线程如果是大于2个的话就不安全，因为if()判断只执行一次会造成&#x3D;&#x3D;虚假唤醒&#x3D;&#x3D;。</p><p><img src="http://1.117.162.142:9000/blog/image-20210818095625503.png" alt="image-20210818095625503"></p><p><strong>虚假唤醒：线程可以唤醒，但是不会被通知、中断或超时，即是虚假唤醒。</strong></p><p>换句话说等待应该出现在循环中，用 &#x3D;&#x3D;while()&#x3D;&#x3D; 循环防止虚假唤醒。</p><p><img src="http://1.117.162.142:9000/blog/image-20210818095703359.png" alt="image-20210818095703359"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();  <span class="comment">// 等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.print(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();  <span class="comment">// 通知</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait(); <span class="comment">// 等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.print(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll(); <span class="comment">// 通知</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JUC 版生产者和消费者</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//Confition取代了对象监视器方法的使用，也就是 wait() notify() 方法</span></span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">condition.await()   &lt;==&gt;  wait()</span><br><span class="line">condition.signalAll()  &lt;==&gt;  notify()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data2</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;data.increment();&#125;&#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;data.decrement();&#125;&#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;data.decrement();&#125;&#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;data.decrement();&#125;&#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Confition取代了对象监视器方法的使用，也就是 wait() notify() 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.print(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            condition.signalAll();  <span class="comment">// 通知</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">                condition.await(); <span class="comment">// 等待</span></span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.print(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            condition.signalAll(); <span class="comment">// 通知</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="http://1.117.162.142:9000/blog/image-20210818104523172.png" alt="image-20210818104523172"></p><p>&#x3D;&#x3D;Condition可以只监视一个方法，通过多个监视器就可以实现线程按顺序进行执行， 因此Condition可以实现<strong>精准的通知和唤醒线程</strong>&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data3</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data3</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">5</span>; i++) data.printA();&#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">5</span>; i++) data.printB();&#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">5</span>; i++) data.printC();&#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">1</span>) &#123; <span class="comment">// 判断</span></span><br><span class="line">                condition1.await();  <span class="comment">// 等待</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 业务</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;===&gt;A&quot;</span>);</span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();  <span class="comment">// 通知</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">2</span>) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;===&gt;B&quot;</span>);</span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">3</span>) &#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;===&gt;C&quot;</span>);</span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="http://1.117.162.142:9000/blog/image-20210818113116938.png" alt="image-20210818113116938"></p><h3 id="8锁现象-锁的8个问题"><a href="#8锁现象-锁的8个问题" class="headerlink" title="8锁现象(锁的8个问题)"></a>8锁现象(锁的8个问题)</h3><p>如何判断所得是谁   –&gt; new 出来的对象  Class 模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁问题一：标准情况下(线程A调用后延迟一秒调用线程B)，两个线程先打印 发短信 还是 打电话 ？  发短信</span></span><br><span class="line"><span class="comment"> * 8锁问题二：send()方法延迟4秒执行，两个线程先打印 发短信 还是 打电话 ？  发短信</span></span><br><span class="line"><span class="comment"> * synchronized 锁的是方法的调用者，AB两个线程都是用的同一个对象 phone ，所以用的是同一把锁，谁先拿到谁先执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock8Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;phone.send();&#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;phone.call();&#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁问题三：Phone类中添加一个普通方法vedio(), 线程A调用send()方法，线程B调用vedio()方法, 先打印 发短信 还是 打视频 ？  打视频</span></span><br><span class="line"><span class="comment"> * vedio()方法是一个普通方法，不受锁的影响，所以先打印打视频</span></span><br><span class="line"><span class="comment"> * 8锁问题四：new两个Phone对象，线程A调用phone1对象的send()方法，线程B调用phone2对象的call()方法，先打印 发短信 还是 打电话 ？ 打电话</span></span><br><span class="line"><span class="comment"> * synchronized 锁的是方法的调用者，线程A和线程B不是用的同一个对象，两个调用者就有两把锁, 互不影响,所以先打印 打电话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock8Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone2</span> <span class="variable">phone1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone2</span>();</span><br><span class="line">        <span class="type">Phone2</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;phone1.send();&#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;phone2.call();&#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">vedio</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打视频&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁问题五：将Phone类中的 send() call()方法改为静态同步方法，线程A调用send()，线程B调用call()，先打印 发短信 还是 打电话 ?   发短信</span></span><br><span class="line"><span class="comment"> * 静态同步方法锁的是 class 对象，线程A和线程B都用的同一个对象，这个对象的模板也即是这个类的class对象，只有一把锁，所以先打印发短信</span></span><br><span class="line"><span class="comment"> * 8锁问题六：线程A和线程B调用两个对象，线程A 调用phone1对象的send()方法，线程B调用phone2对象的call()方法， 先打印 发短信 还是 打电话 ？   发短信</span></span><br><span class="line"><span class="comment"> * 线程A和相乘B虽然用的是两个对象，但是这两个对象的 class 类是同一个，静态同步方法锁的是 class 对象，这两个对象用的是同一把锁，所以先打印 发短信</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock8Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone3</span> <span class="variable">phone1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone3</span>();</span><br><span class="line">        <span class="type">Phone3</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone3</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;phone1.send();&#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;phone2.call();&#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一个类只有一个 class 对象  (class模板)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">vedio</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打视频&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8锁问题七：Phone4类中，send()方法为静态同步方法，call()为普通同步方法，线程A和线程B用同一个对象，线程A调用phone对象的send()，线程B调用phone对象的call()， 先打印 发短信 还是 打电话 ？ 打电话</span></span><br><span class="line"><span class="comment"> * 静态同步方法锁的是 class 对象，普通同步方法锁的是方法的调用者，线程A和线程B调用的方法用的不是同一把锁，所以先打印打电话</span></span><br><span class="line"><span class="comment"> * 8锁问题八：线程A和线程B分别调用phone1和phone2的send() call()，先打印 发短信 还是 打电话 ？ 打电话</span></span><br><span class="line"><span class="comment"> *答案和问题七一样</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock8Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone4</span> <span class="variable">phone1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone4</span>();</span><br><span class="line">        <span class="type">Phone4</span> <span class="variable">phone2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone4</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;phone1.send();&#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;phone2.call();&#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集合类不安全"><a href="#集合类不安全" class="headerlink" title="集合类不安全"></a>集合类不安全</h3><p><strong>List不安全：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并发时, ArrayList是不安全的,会报 &#x3D;&#x3D;java.util.ConcurrentModificationException&#x3D;&#x3D; 并发修改异常</p><p><strong>解决方案一:</strong></p><p>将<code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>改为<code>List&lt;String&gt; list = new Vector&lt;&gt;();</code>  Vector默认就是线程安全的, synchronized 修饰的</p><p><strong>解决方案二:</strong></p><p>将<code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>  改为  <code>List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());</code></p><p><strong>解决方案三:</strong></p><p>将<code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>  改为  <code>List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</code></p><p>CopyOnWrite 写入时复制, 是计算机程序设计领域的一种优化策略,简称COW</p><p>多线程调用list时, 读取时都是固定的, 写入时覆盖 在写入时避免覆盖造成数据问题</p><blockquote><p>CopyOnWriteArrayList 比  Vector 牛逼在哪里?</p></blockquote><p>Vector是用synchronized实现线程安全的, 效率比较低, CopyOnWriteArrayList 是用的 Lock锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Set不安全：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line">                System.out.println(set); &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程操作会报java.util.ConcurrentModificationException 并发修改异常</p><p><strong>解决方案一:</strong></p><p>将<code>Set&lt;String&gt; set = new HashSet&lt;&gt;();</code>  改为  <code>Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</code>用集合工具类将HashSet转为安全的</p><p><strong>解决方案二:</strong></p><p>将<code>Set&lt;String&gt; set = new HashSet&lt;&gt;();</code>  改为  <code>Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();</code></p><p>HashSet()底层就是HashMap(), add()方法就是用的map.put()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Map不安全：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// Map&lt;String, Object&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(myThread);  <span class="comment">//适配类</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">o</span> <span class="operator">=</span> (Integer) futureTask.get();<span class="comment">//get方法可能残生阻塞</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">122</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;因为Thread直接收Runnable接口，所以无法直接将Callable的实现类放进去，所以需要通过FutureTask去进行适配。&#x3D;&#x3D;</p><h3 id="常用辅助类"><a href="#常用辅助类" class="headerlink" title="常用辅助类"></a>常用辅助类</h3><p>&#x3D;&#x3D;CountDownLatch&#x3D;&#x3D;   减法计数器</p><ul><li>允许一个或多个线程等待知道其他线程中执行的一组操作完成的同步辅助。</li><li>当countdown方法的调用时计数器为零时，所有await的线程就被释放</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);   <span class="comment">//计数器  总共计数5次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">                countDownLatch.countDown(); <span class="comment">// 执行了方法计数器减一</span></span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();  <span class="comment">// 当计数器为0时唤醒，再向下执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;全部执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;CyclicBarrier&#x3D;&#x3D;    加法计数器</p><ul><li>允许一组线程全部等待彼此达到共同屏障点的同步辅助。</li><li>就是等计数器达到指定值时，await的线程就被释放</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;宝石收集完了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;集齐了&quot;</span> + temp + <span class="string">&quot;颗宝石&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;Semaphore&#x3D;&#x3D;    信号量</p><ul><li>一个计数信号量，在概念上，信号量维持一组许可证。</li><li>如果有必要，每个acquire()都会阻塞，知道许可证可用，然后才能使用它。</li><li>每个release()添加许可证，潜在的释放阻塞获取方。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 六辆车抢三个车位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDeno</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;抢到了车位&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;离开了此停车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原理：</strong></p><p><code>semaphore.acquire()</code>    获得，假设信号量已经满了，就等待，知道被释放     信号量-1</p><p><code>semaphore.release()</code>    释放，会将当前的信号量释放，然后唤醒等待的线程  信号量+1</p><p>作用：多个共享资源互斥的使用！并发限流，控制最大的线程数！</p><h3 id="读写锁-ReadWriteLock"><a href="#读写锁-ReadWriteLock" class="headerlink" title="读写锁   ReadWriteLock"></a>读写锁   <strong>ReadWriteLock</strong></h3><p>读的时候可以很多一起读，但是写的时候就只能一个线程写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// MyCache myCache = new MyCache();</span></span><br><span class="line">        <span class="type">MyCacheLock</span> <span class="variable">myCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCacheLock</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myCache.put(String.valueOf(temp), temp);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                myCache.get(String.valueOf(temp));</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义缓存</span></span><br><span class="line"><span class="comment"> * volatile  保留原子性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object val)</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写入&quot;</span> + key);</span><br><span class="line">        map.put(key, val);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写入成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取&quot;</span> + key);</span><br><span class="line">        map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCacheLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object val)</span> &#123;</span><br><span class="line">        readWriteLock.writeLock().lock();  <span class="comment">//加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写入&quot;</span> + key);</span><br><span class="line">            map.put(key, val);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;写入成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();  <span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">            readWriteLock.readLock().lock();   <span class="comment">//加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取&quot;</span> + key);</span><br><span class="line">            map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;读取成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();   <span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞队列-BlockingQucue"><a href="#阻塞队列-BlockingQucue" class="headerlink" title="阻塞队列 BlockingQucue"></a>阻塞队列 BlockingQucue</h3><blockquote><p>四组API</p></blockquote><table><thead><tr><th align="center">方式</th><th align="center">抛出异常</th><th align="center">不抛出异常, 有返回值</th><th align="center">阻塞等待</th><th align="center">超时等待</th></tr></thead><tbody><tr><td align="center">添加</td><td align="center">add()</td><td align="center">offer()</td><td align="center">put()</td><td align="center">offer(值, 时间, 时间单位)</td></tr><tr><td align="center">移除</td><td align="center">remove()</td><td align="center">poll()</td><td align="center">take()</td><td align="center">poll(时间, 时间单位)</td></tr><tr><td align="center">检测队首元素</td><td align="center">element()</td><td align="center">peek()</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQucueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// test1();</span></span><br><span class="line">        <span class="comment">// test2();</span></span><br><span class="line">        <span class="comment">// test3();</span></span><br><span class="line">        test4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="number">1</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="number">2</span>));</span><br><span class="line">        System.out.println(blockingQueue.add(<span class="number">3</span>));</span><br><span class="line">        <span class="comment">//查看队首元素</span></span><br><span class="line">        System.out.println(blockingQueue.element());</span><br><span class="line">        <span class="comment">// java.lang.IllegalStateException: Queue full 抛出队列已满异常</span></span><br><span class="line">        <span class="comment">// System.out.println(blockingQueue.add(4));</span></span><br><span class="line">        System.out.println(<span class="string">&quot;#####&quot;</span>);</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        System.out.println(blockingQueue.remove());</span><br><span class="line">        <span class="comment">// java.util.NoSuchElementException 抛出异常</span></span><br><span class="line">        <span class="comment">// System.out.println(blockingQueue.remove());</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">1</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">2</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">3</span>));</span><br><span class="line">        <span class="comment">// 查看队首元素</span></span><br><span class="line">        System.out.println(blockingQueue.peek());</span><br><span class="line">        <span class="comment">// 不抛异常 返回false</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">4</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;######&quot;</span>);</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.peek());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        <span class="comment">// 不跑异常 返回null</span></span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        blockingQueue.put(<span class="number">1</span>);</span><br><span class="line">        blockingQueue.put(<span class="number">2</span>);</span><br><span class="line">        blockingQueue.put(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 不抛异常，但是会一直等待</span></span><br><span class="line">        <span class="comment">// blockingQueue.put(4);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;######&quot;</span>);</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        <span class="comment">// 不抛异常，但是一直等待</span></span><br><span class="line">        <span class="comment">// System.out.println(blockingQueue.take());</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">1</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">2</span>));</span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">3</span>));</span><br><span class="line">        <span class="comment">// 等两秒 如果添加失败就返回false</span></span><br><span class="line">        System.out.println(blockingQueue.offer(<span class="number">3</span>, <span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">        System.out.println(<span class="string">&quot;######&quot;</span>);</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        System.out.println(blockingQueue.poll());</span><br><span class="line">        <span class="comment">// 等两秒  如果获取不到就返回null</span></span><br><span class="line">        System.out.println(blockingQueue.poll(<span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="同步队列-SynchronousQueue"><a href="#同步队列-SynchronousQueue" class="headerlink" title="同步队列  SynchronousQueue"></a>同步队列  SynchronousQueue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步队列</span></span><br><span class="line"><span class="comment"> * 和其他 BlockingQueue 不一样，SynchronousQueue 不存储元素</span></span><br><span class="line"><span class="comment"> * put了一个一个元素，必须先将他从里面take出来，否则不能再put进去值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronousQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//同步队列</span></span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; put 1&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; put 2&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="number">2</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; put 3&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; take &quot;</span> + blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; take &quot;</span> + blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; take &quot;</span> + blockingQueue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><blockquote><p>线程池</p></blockquote><p>程序的运行本质就是占用系统的资源！优化资源的使用使用池化技术</p><p>线程池、链接池、内存池、对象池</p><p>池化技术：事先准备好一些资源，有人要用，就来找我拿，用完之后再还我</p><p><strong>线程池的好处：</strong></p><ul><li>降低资源的消耗</li><li>提高响应的速度</li><li>方便管理</li></ul><p>&#x3D;&#x3D;线程复用、可以控制最大并发数、管理线程&#x3D;&#x3D;</p><blockquote><p>线程池：三大方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executors  工具类</span></span><br><span class="line"><span class="comment"> * 阿里巴巴开发手册不建议用Executors去创建线程池，不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// ExecutorService threadPool = Executors.newSingleThreadExecutor();  // 单个线程</span></span><br><span class="line">        <span class="comment">// ExecutorService threadPool = Executors.newFixedThreadPool(5);   // 创建一个固定的线程池的大小</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();    <span class="comment">// 动态变化</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 使用线程池来创建线程</span></span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ok&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 线程池用完之后，程序结束，关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>7大参数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, </span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">            <span class="literal">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>int corePoolSize – 要保留在池中的线程数，即使它们处于空闲状态，除非设置了allowCoreThreadTimeOut</li><li>int maximumPoolSize – 池中允许的最大线程数</li><li>long keepAliveTime – 当线程数大于核心数时，这是多余空闲线程在终止前等待新任务的最长时间。</li><li>TimeUnit unit – keepAliveTime参数的时间单位</li><li>BlockingQueue workQueue – 用于在执行任务之前保存任务的队列。 这个队列将只保存execute方法提交的Runnable任务。</li><li>ThreadFactory threadFactory – 执行程序创建新线程时使用的工厂</li><li>RejectedExecutionHandler handler – 执行被阻塞时使用的处理程序，因为达到了线程边界和队列容量</li></ol><blockquote><p>4大拒绝策略</p></blockquote><p><img src="http://1.117.162.142:9000/blog/image-20210823114434460.png" alt="image-20210823114434460"></p><ul><li>AbortPolicy 阻塞队列满了，不处理多的线程，抛出异常<code>java.util.concurrent.RejectedExecutionException</code></li><li>CallerRunPolicy 阻塞队列满了，多的线程哪里来回哪里去 <code>main ok</code></li><li>DiscardOldestPolicy 阻塞队列满了，不会抛出异常</li><li>DiscardPolicy 阻塞队列满了，尝试去和最早运行的进程竞争，也不会抛出异常</li></ul><blockquote><p>最大线程到底如何定义(调优)</p></blockquote><ul><li><p>CPU 密集型 电脑是多少核就能同时执行几个线程，可以保持cpu的效率最高</p><ul><li><code>Runtime.getRuntime().availableProcessors()</code></li></ul></li><li><p>IO 密集型 判断程序中十分耗IO的线程  可以设置成两倍</p></li></ul><h3 id="四大函数式接口-（只有一个方法的接口）"><a href="#四大函数式接口-（只有一个方法的接口）" class="headerlink" title="四大函数式接口  （只有一个方法的接口）"></a>四大函数式接口  （只有一个方法的接口）</h3><blockquote><p>函数型接口：有一个输入  有一个输出</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Function&lt;String, String&gt; function = new Function&lt;String, String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public String apply(String s) &#123;</span></span><br><span class="line"><span class="comment">//                return s;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line">        <span class="comment">// lambda 表达式</span></span><br><span class="line">        Function&lt;String, String&gt; function = str -&gt; &#123;<span class="keyword">return</span> str;&#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;str&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Predicate 断定型接口 有一个输入参数，返回值只能是布尔值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断字符是否为空</span></span><br><span class="line"><span class="comment">//        Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public boolean test(String s) &#123;</span></span><br><span class="line"><span class="comment">//                return s.isEmpty();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = str -&gt; &#123;<span class="keyword">return</span>  str.isEmpty();&#125;;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Consumer 消费型接口  只有输入 没有返回值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void accept(String s) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(s);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = str -&gt; &#123;System.out.println(str);&#125;;</span><br><span class="line">        consumer.accept(<span class="string">&quot;asda&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Supplier 供给型接口  没有参数  只有返回值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Supplier&lt;Integer&gt; supplier = new Supplier&lt;Integer&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public Integer get() &#123;</span></span><br><span class="line"><span class="comment">//                return 2048;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line">        <span class="type">Supplier</span> <span class="variable">supplier</span> <span class="operator">=</span> () -&gt; &#123;<span class="keyword">return</span> <span class="number">2048</span>;&#125;;</span><br><span class="line">                System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目要求：一分钟内完成此题目，只能用一行代码实现！</span></span><br><span class="line"><span class="comment"> * 现有5个用户，筛选：</span></span><br><span class="line"><span class="comment"> * 1、ID必须是偶数</span></span><br><span class="line"><span class="comment"> * 2、年龄必须大于23岁</span></span><br><span class="line"><span class="comment"> * 3、用户名转为大写字母</span></span><br><span class="line"><span class="comment"> * 4、用户名字母倒着排序</span></span><br><span class="line"><span class="comment"> * 5、只输出一个用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">6</span>, <span class="string">&quot;e&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);</span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(u -&gt; &#123;<span class="keyword">return</span> u.getId() % <span class="number">2</span> == <span class="number">0</span>;&#125;)</span><br><span class="line">                .filter(u -&gt; &#123;<span class="keyword">return</span> u.getAge() &gt; <span class="number">23</span>;&#125;)</span><br><span class="line">                .map(u -&gt; &#123;<span class="keyword">return</span> u.getName().toUpperCase();&#125;)</span><br><span class="line">                .sorted((uu1, uu2) -&gt; &#123;<span class="keyword">return</span> uu2.compareTo(uu1);&#125;)</span><br><span class="line">                .limit(<span class="number">1</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>并行执行任务，提高效率，大数据量</p><p><strong>特点：工作窃取</strong></p><p>计算从 1 加到 10 0000 0000</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinDemo</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1l</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">10_0000_0000l</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">10000l</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinDemo</span><span class="params">(Long start, Long end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((end - start) &lt; temp) &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0l</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(start, middle);</span><br><span class="line">            task1.fork();</span><br><span class="line">            <span class="type">ForkJoinDemo</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">            task2.fork();</span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 普通方法</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">sum1</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1L</span>; i &lt;= <span class="number">10_0000_0000</span>; i++) &#123;</span><br><span class="line">            sum1 += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum = &quot;</span> + sum1 + <span class="string">&quot;, 普通方法计算时间: &quot;</span> + (end1 - start1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// forkjoin 方法</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="type">ForkJoinDemo</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinDemo</span>(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">sum2</span> <span class="operator">=</span> submit.get();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum = &quot;</span> + sum2 + <span class="string">&quot;, forkjoin 方法计算时间: &quot;</span> + (end2 - start2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Stream 并行流</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start3</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum3</span> <span class="operator">=</span> LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">10_0000_0000</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end3</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum = &quot;</span> + sum3 + <span class="string">&quot;, Stream 并行流计算时间: &quot;</span> + (end3 - start3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span> = 500000000500000000, 普通方法计算时间: 8257</span><br><span class="line"><span class="built_in">sum</span> = 500000000500000000, ForkJoin 方法计算时间: 7386</span><br><span class="line"><span class="built_in">sum</span> = 500000000500000000, Stream 并行流计算时间: 115</span><br></pre></td></tr></table></figure><h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3><blockquote><p>Future 设计初衷: 对将来的某个事件的结果进行建模</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 发起一个请求，无返回值</span></span><br><span class="line"><span class="comment">//        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                TimeUnit.SECONDS.sleep(2);</span></span><br><span class="line"><span class="comment">//            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            System.out.println(Thread.currentThread().getName() + &quot;runAsync=&gt;Void&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;11111&quot;);</span></span><br><span class="line"><span class="comment">//        completableFuture.get();</span></span><br><span class="line">        <span class="comment">// 有返回结果的supplyAsync异步回调</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;supplyAsync=&gt;Integer&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t=&gt;&quot;</span> + t);</span><br><span class="line">            System.out.println(<span class="string">&quot;u=&gt;&quot;</span> + u);</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">404</span>;</span><br><span class="line">        &#125;).get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><blockquote><p>请你谈谈你对Volatile的理解</p></blockquote><p>Volatile是java虚拟机提供的轻量级的同步机制</p><ul><li><p>保证可见性</p></li><li><p>不保证原子性</p></li><li><p>禁止指令重排</p></li></ul><blockquote><p>什么是JMM</p></blockquote><p>JMM：java内存模型，不存在的东西，概念！约定！</p><p><strong>关于JMM的一些同步的约定：</strong></p><ul><li>线程解锁前，必须把共享变量&#x3D;&#x3D;立刻&#x3D;&#x3D;刷回主存</li><li>线程加锁前 ，必须读取主存中的最新值到工作内存中</li><li>加锁和解锁是同一把锁</li></ul><p>线程    工作内存    主内存</p><p><strong>8种操作</strong>：</p><p><img src="http://1.117.162.142:9000/blog/image-20210823165410206.png" alt="image-20210823165410206"></p><p><strong>内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）</strong></p><ul><li>lock   （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态</li><li>unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li><li>read  （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load   （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中</li><li>use   （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令</li><li>assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中</li><li>store  （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用</li><li>write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li></ul><p><strong>JMM对这八种指令的使用，制定了如下规则：</strong></p><ul><li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</li><li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</li><li>不允许一个线程将没有assign的数据从工作内存同步回主内存</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</li><li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</li><li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li><li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li></ul><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><ul><li>保证可见性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不保证原子性</li></ul><p>线程A在执行任务的时候，不可能被打扰，也不可能被分割，要么同时成功，要么同时失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        num++;  <span class="comment">//不是一个原子性操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">main <span class="number">19263</span></span><br></pre></td></tr></table></figure><p>解决方法：</p><ol><li>加synchronized关键字</li><li>加lock</li><li>&#x3D;&#x3D;使用原子类&#x3D;&#x3D;</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    num.getAndIncrement(); <span class="comment">// AtomicInteger + 1 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>禁止指令重排</li></ul><blockquote><p>什么是指令重排</p></blockquote><p>程序不一样是按照我们写的那样去执行的。</p><p>源代码-&gt;编译器优化的重排-&gt;指令并行也可能重排-&gt;内存系统也会重排-&gt;执行</p><p>&#x3D;&#x3D;处理器在进行指令重拍的时候，会考虑数据之间的依赖性&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">a = a + <span class="number">4</span>;</span><br><span class="line">b = a * a;</span><br></pre></td></tr></table></figure><p>这是我们期望的代码执行顺序，但是程序执行时不一样是按照这个顺序执行，由于指令重排，就可能会导致程序报错。</p><p>volatile可以避免指令重排：</p><p>&#x3D;&#x3D;内存屏障&#x3D;&#x3D;是CPU的指令，可以保证特定操作的执行顺序；还可以保证某些变量的内存可见性。利用这两点，volatile实现了可见性</p><h3 id="彻底理解单例模式"><a href="#彻底理解单例模式" class="headerlink" title="彻底理解单例模式"></a>彻底理解单例模式</h3><blockquote><p>饿汉式单例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hungry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Hungry</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Hungry</span> <span class="variable">HUNGRY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hungry</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> HUNGRY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DCL懒汉式单例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">status</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazyMan.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (status == <span class="literal">false</span>) &#123;</span><br><span class="line">                status = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不要试图用反射破坏单例&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双重检测模式的 懒汉式单例 DCL懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMan == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyMan == <span class="literal">null</span>) &#123;</span><br><span class="line">                    lazyMan = <span class="keyword">new</span> <span class="title class_">LazyMan</span>(); <span class="comment">// 不是一个原子性操作</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 1. 分配内存空间</span></span><br><span class="line"><span class="comment">                     * 2. 执行构造方法，初始化对象</span></span><br><span class="line"><span class="comment">                     * 3. 把这个对象只想这个空间</span></span><br><span class="line"><span class="comment">                     * 这是期望的程序执行顺序，但是有可能发生指令重排</span></span><br><span class="line"><span class="comment">                     * 所以要为 lazyMan 加上 volatile</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">// LazyMan instance1 = LazyMan.getInstance();</span></span><br><span class="line">        Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(<span class="literal">null</span>);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">status</span> <span class="operator">=</span> LazyMan.class.getDeclaredField(<span class="string">&quot;status&quot;</span>);</span><br><span class="line">        status.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">instance1</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        status.set(instance1, <span class="literal">false</span>);</span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">instance2</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(instance1);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>静态内部类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Holder</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.HOLDER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Holder</span> <span class="variable">HOLDER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>枚举单例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum 本身也是一个Class类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingle</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EnumSingle <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance1</span> <span class="operator">=</span> EnumSingle.INSTANCE;</span><br><span class="line">        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">EnumSingle</span> <span class="variable">instance2</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(instance1);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>完整的枚举单例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumSingle02</span> &#123;</span><br><span class="line">    <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EnumSingle02</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 定义一个静态枚举类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">SingletonEnum</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个枚举对象，该对象天生为单例</span></span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> EnumSingle02 enumSingle02;</span><br><span class="line">        <span class="comment">// 私有化枚举的构造函数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">SingletonEnum</span><span class="params">()</span> &#123;</span><br><span class="line">            enumSingle02 = <span class="keyword">new</span> <span class="title class_">EnumSingle02</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> EnumSingle02 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> enumSingle02;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对外暴露一个获取EnumSingle02对象的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnumSingle02 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonEnum.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EnumSingle02</span> <span class="variable">instance1</span> <span class="operator">=</span> EnumSingle02.getInstance();</span><br><span class="line">        <span class="type">EnumSingle02</span> <span class="variable">instance2</span> <span class="operator">=</span> EnumSingle02.getInstance();</span><br><span class="line">        System.out.println(instance1);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">        System.out.println(instance1 == instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;反射不能破环枚举&#x3D;&#x3D;</p><h3 id="深入理解CAS"><a href="#深入理解CAS" class="headerlink" title="深入理解CAS"></a>深入理解CAS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CAS compareAndSet : 比较并交换</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">2020</span>);</span><br><span class="line">        <span class="comment">// expect 期望  update 更新</span></span><br><span class="line">        <span class="comment">// public final boolean compareAndSet(int expect, int update)</span></span><br><span class="line">        <span class="comment">// 如果当前值==预期值，则原子地将值设置为给定的更新值。</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>探究原子加一方法<code>atomicInteger.getAndIncrement()</code></p><blockquote><p>Unsafe 类</p></blockquote><p><img src="http://1.117.162.142:9000/blog/image-20210824112442041.png" alt="image-20210824112442041"></p><p>valueOffset 内存地址偏移值</p><p><img src="http://1.117.162.142:9000/blog/image-20210824113052901.png" alt="image-20210824113052901"></p><p><img src="http://1.117.162.142:9000/blog/image-20210824113405903.png" alt="image-20210824113405903"></p><p>CAS：比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么就执行操作，如果不是就一直循环！</p><p><strong>缺点：</strong></p><ul><li>循环会耗时，但是比用java还是快很很多</li><li>一次性只能保证一个共享变量的原子性</li><li>会导致ABA问题</li></ul><blockquote><p>CAS : ABA 问题(狸猫换太子)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">2020</span>);</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">        <span class="comment">// expect 期望  update 更新</span></span><br><span class="line">        <span class="comment">// public final boolean compareAndSet(int expect, int update)</span></span><br><span class="line">        <span class="comment">// 如果当前值==预期值，则原子地将值设置为给定的更新值。</span></span><br><span class="line">        <span class="comment">//======================捣乱的线程=============================</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2021</span>, <span class="number">2020</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">        <span class="comment">//======================期望的线程=============================</span></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">2020</span>, <span class="number">2021</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这个也会执行成功，但是我们期望的线程得到的是已经被修改的，并不是原来的那个。</p><p>解决办法原子引用</p><h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><p>带版本号的原子操作</p><p>解决ABA问题只需要引入原子引用。对应的思想就是乐观锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();<span class="comment">// 获得版本号</span></span><br><span class="line">            System.out.println(<span class="string">&quot;A1 =&gt; &quot;</span> + stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(<span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">                    stamp, atomicStampedReference.getStamp() + <span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;A2 =&gt; &quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(<span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">                    atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;A3 =&gt; &quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(<span class="string">&quot;B1 =&gt; &quot;</span> + stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(<span class="number">1</span>, <span class="number">6</span>,</span><br><span class="line">                    stamp, atomicStampedReference.getStamp() + <span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;B2 =&gt; &quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="各种锁的理解"><a href="#各种锁的理解" class="headerlink" title="各种锁的理解"></a>各种锁的理解</h3><blockquote><p>公平锁、非公平锁</p></blockquote><p>公平锁：非常公平，不可以插队，线程先来后到</p><p>非公平锁：非常不公平，可以插队，默认都是非公平的</p><blockquote><p>可重入锁</p></blockquote><p>可重入锁（递归锁） 获取外面的锁时，也会获取里面的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sms</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; sms&quot;</span>);</span><br><span class="line">            call();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; call&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>自旋锁   spinlock</p></blockquote><p><img src="http://1.117.162.142:9000/blog/image-20210824113405903.png" alt="image-20210824113405903"></p><p>自定义自旋锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自旋锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinlockDemo</span> &#123;</span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt; mylock&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="literal">null</span>, thread)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myUnLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt; myunlock&quot;</span>);</span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">SpinlockDemo</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpinlockDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.myUnLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.myLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.myUnLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>死锁</p></blockquote><p><img src="http://1.117.162.142:9000/blog/image-20210824141724231.png" alt="image-20210824141724231"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 死锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="string">&quot;lockB&quot;</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(lockA, lockB), <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(lockB, lockA), <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockA;</span><br><span class="line">    <span class="keyword">private</span> String lockB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String lockA, String lockB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lockA = lockA;</span><br><span class="line">        <span class="built_in">this</span>.lockB = lockB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; lock: &quot;</span> + lockA + <span class="string">&quot; =&gt; get &quot;</span> + lockB);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; lock: &quot;</span> + lockB + <span class="string">&quot; =&gt; get &quot;</span> + lockA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;排除死锁&#x3D;&#x3D;</p><p><code>jps -l </code> 定位进程号</p><p><img src="http://1.117.162.142:9000/blog/image-20210824143738660.png" alt="image-20210824143738660"></p><p><code>jstack 进程号</code>  查看进程信息</p><p><img src="http://1.117.162.142:9000/blog/image-20210824144044633.png" alt="image-20210824144044633"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
